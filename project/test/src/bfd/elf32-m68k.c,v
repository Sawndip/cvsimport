head	1.143;
access;
symbols
	sid-snapshot-20180601:1.143
	sid-snapshot-20180501:1.143
	sid-snapshot-20180401:1.143
	sid-snapshot-20180301:1.143
	sid-snapshot-20180201:1.143
	sid-snapshot-20180101:1.143
	sid-snapshot-20171201:1.143
	sid-snapshot-20171101:1.143
	sid-snapshot-20171001:1.143
	sid-snapshot-20170901:1.143
	sid-snapshot-20170801:1.143
	sid-snapshot-20170701:1.143
	sid-snapshot-20170601:1.143
	sid-snapshot-20170501:1.143
	sid-snapshot-20170401:1.143
	sid-snapshot-20170301:1.143
	sid-snapshot-20170201:1.143
	sid-snapshot-20170101:1.143
	sid-snapshot-20161201:1.143
	sid-snapshot-20161101:1.143
	sid-snapshot-20160901:1.143
	sid-snapshot-20160801:1.143
	sid-snapshot-20160701:1.143
	sid-snapshot-20160601:1.143
	sid-snapshot-20160501:1.143
	sid-snapshot-20160401:1.143
	sid-snapshot-20160301:1.143
	sid-snapshot-20160201:1.143
	sid-snapshot-20160101:1.143
	sid-snapshot-20151201:1.143
	sid-snapshot-20151101:1.143
	sid-snapshot-20151001:1.143
	sid-snapshot-20150901:1.143
	sid-snapshot-20150801:1.143
	sid-snapshot-20150701:1.143
	sid-snapshot-20150601:1.143
	sid-snapshot-20150501:1.143
	sid-snapshot-20150401:1.143
	sid-snapshot-20150301:1.143
	sid-snapshot-20150201:1.143
	sid-snapshot-20150101:1.143
	sid-snapshot-20141201:1.143
	sid-snapshot-20141101:1.143
	sid-snapshot-20141001:1.143
	sid-snapshot-20140901:1.143
	sid-snapshot-20140801:1.143
	sid-snapshot-20140701:1.143
	sid-snapshot-20140601:1.143
	sid-snapshot-20140501:1.143
	sid-snapshot-20140401:1.143
	sid-snapshot-20140301:1.143
	sid-snapshot-20140201:1.143
	sid-snapshot-20140101:1.143
	sid-snapshot-20131201:1.143
	sid-snapshot-20131101:1.143
	sid-snapshot-20131001:1.142
	binutils-2_24-branch:1.142.0.2
	binutils-2_24-branchpoint:1.142
	binutils-2_21_1:1.124
	sid-snapshot-20130901:1.142
	gdb_7_6_1-2013-08-30-release:1.140
	sid-snapshot-20130801:1.142
	sid-snapshot-20130701:1.142
	sid-snapshot-20130601:1.142
	sid-snapshot-20130501:1.142
	gdb_7_6-2013-04-26-release:1.140
	sid-snapshot-20130401:1.142
	binutils-2_23_2:1.137
	gdb_7_6-branch:1.140.0.2
	gdb_7_6-2013-03-12-branchpoint:1.140
	sid-snapshot-20130301:1.140
	sid-snapshot-20130201:1.137
	sid-snapshot-20130101:1.137
	sid-snapshot-20121201:1.137
	gdb_7_5_1-2012-11-29-release:1.137
	binutils-2_23_1:1.137
	sid-snapshot-20121101:1.137
	binutils-2_23:1.137
	sid-snapshot-20121001:1.137
	sid-snapshot-20120901:1.137
	gdb_7_5-2012-08-17-release:1.137
	sid-snapshot-20120801:1.137
	binutils-2_23-branch:1.137.0.4
	binutils-2_23-branchpoint:1.137
	gdb_7_5-branch:1.137.0.2
	gdb_7_5-2012-07-18-branchpoint:1.137
	sid-snapshot-20120701:1.136
	sid-snapshot-20120601:1.134
	sid-snapshot-20120501:1.132
	binutils-2_22_branch:1.126.0.4
	gdb_7_4_1-2012-04-26-release:1.128
	sid-snapshot-20120401:1.130
	sid-snapshot-20120301:1.128
	sid-snapshot-20120201:1.128
	gdb_7_4-2012-01-24-release:1.128
	sid-snapshot-20120101:1.128
	gdb_7_4-branch:1.128.0.2
	gdb_7_4-2011-12-13-branchpoint:1.128
	sid-snapshot-20111201:1.127
	binutils-2_22:1.126
	sid-snapshot-20111101:1.127
	sid-snapshot-20111001:1.126
	binutils-2_22-branch:1.126.0.2
	binutils-2_22-branchpoint:1.126
	gdb_7_3_1-2011-09-04-release:1.125
	sid-snapshot-20110901:1.126
	sid-snapshot-20110801:1.126
	gdb_7_3-2011-07-26-release:1.125
	sid-snapshot-20110701:1.126
	sid-snapshot-20110601:1.125
	sid-snapshot-20110501:1.125
	gdb_7_3-branch:1.125.0.2
	gdb_7_3-2011-04-01-branchpoint:1.125
	sid-snapshot-20110401:1.125
	sid-snapshot-20110301:1.125
	sid-snapshot-20110201:1.124
	sid-snapshot-20110101:1.124
	binutils-2_21:1.124
	sid-snapshot-20101201:1.124
	binutils-2_21-branch:1.124.0.2
	binutils-2_21-branchpoint:1.124
	sid-snapshot-20101101:1.124
	sid-snapshot-20101001:1.123
	binutils-2_20_1:1.115
	gdb_7_2-2010-09-02-release:1.119
	sid-snapshot-20100901:1.122
	sid-snapshot-20100801:1.119
	gdb_7_2-branch:1.119.0.2
	gdb_7_2-2010-07-07-branchpoint:1.119
	sid-snapshot-20100701:1.119
	sid-snapshot-20100601:1.118
	sid-snapshot-20100501:1.118
	sid-snapshot-20100401:1.118
	gdb_7_1-2010-03-18-release:1.118
	sid-snapshot-20100301:1.118
	gdb_7_1-branch:1.118.0.2
	gdb_7_1-2010-02-18-branchpoint:1.118
	sid-snapshot-20100201:1.117
	sid-snapshot-20100101:1.117
	gdb_7_0_1-2009-12-22-release:1.116
	sid-snapshot-20091201:1.117
	sid-snapshot-20091101:1.117
	binutils-2_20:1.115
	gdb_7_0-2009-10-06-release:1.116
	sid-snapshot-20091001:1.117
	gdb_7_0-branch:1.116.0.2
	gdb_7_0-2009-09-16-branchpoint:1.116
	arc-sim-20090309:1.106
	binutils-arc-20081103-branch:1.108.0.12
	binutils-arc-20081103-branchpoint:1.108
	binutils-2_20-branch:1.115.0.2
	binutils-2_20-branchpoint:1.115
	sid-snapshot-20090901:1.115
	sid-snapshot-20090801:1.112
	msnyder-checkpoint-072509-branch:1.112.0.4
	msnyder-checkpoint-072509-branchpoint:1.112
	sid-snapshot-20090701:1.112
	dje-cgen-play1-branch:1.112.0.2
	dje-cgen-play1-branchpoint:1.112
	sid-snapshot-20090601:1.111
	sid-snapshot-20090501:1.111
	sid-snapshot-20090401:1.111
	arc-20081103-branch:1.108.0.10
	arc-20081103-branchpoint:1.108
	arc-insight_6_8-branch:1.106.0.6
	arc-insight_6_8-branchpoint:1.106
	insight_6_8-branch:1.106.0.4
	insight_6_8-branchpoint:1.106
	sid-snapshot-20090301:1.111
	binutils-2_19_1:1.108
	sid-snapshot-20090201:1.110
	sid-snapshot-20090101:1.110
	reverse-20081226-branch:1.110.0.2
	reverse-20081226-branchpoint:1.110
	sid-snapshot-20081201:1.109
	multiprocess-20081120-branch:1.108.0.8
	multiprocess-20081120-branchpoint:1.108
	sid-snapshot-20081101:1.108
	binutils-2_19:1.108
	sid-snapshot-20081001:1.108
	reverse-20080930-branch:1.108.0.6
	reverse-20080930-branchpoint:1.108
	binutils-2_19-branch:1.108.0.4
	binutils-2_19-branchpoint:1.108
	sid-snapshot-20080901:1.108
	sid-snapshot-20080801:1.108
	reverse-20080717-branch:1.108.0.2
	reverse-20080717-branchpoint:1.108
	sid-snapshot-20080701:1.108
	msnyder-reverse-20080609-branch:1.107.0.2
	msnyder-reverse-20080609-branchpoint:1.107
	drow-reverse-20070409-branch:1.99.0.2
	drow-reverse-20070409-branchpoint:1.99
	sid-snapshot-20080601:1.107
	sid-snapshot-20080501:1.106
	sid-snapshot-20080403:1.106
	sid-snapshot-20080401:1.106
	gdb_6_8-2008-03-27-release:1.106
	sid-snapshot-20080301:1.106
	gdb_6_8-branch:1.106.0.2
	gdb_6_8-2008-02-26-branchpoint:1.106
	sid-snapshot-20080201:1.106
	sid-snapshot-20080101:1.105
	sid-snapshot-20071201:1.105
	sid-snapshot-20071101:1.105
	gdb_6_7_1-2007-10-29-release:1.103
	gdb_6_7-2007-10-10-release:1.103
	sid-snapshot-20071001:1.105
	gdb_6_7-branch:1.103.0.4
	gdb_6_7-2007-09-07-branchpoint:1.103
	binutils-2_18:1.103
	binutils-2_18-branch:1.103.0.2
	binutils-2_18-branchpoint:1.103
	insight_6_6-20070208-release:1.93
	binutils-csl-coldfire-4_1-32:1.88.2.6
	binutils-csl-sourcerygxx-4_1-32:1.88.2.6
	gdb_6_6-2006-12-18-release:1.93
	binutils-csl-innovasic-fido-3_4_4-33:1.88.2.6
	binutils-csl-sourcerygxx-3_4_4-32:1.73
	binutils-csl-coldfire-4_1-30:1.88.2.3
	binutils-csl-sourcerygxx-4_1-30:1.88.2.3
	binutils-csl-coldfire-4_1-28:1.88.2.3
	binutils-csl-sourcerygxx-4_1-29:1.88.2.6
	binutils-csl-sourcerygxx-4_1-28:1.88.2.3
	gdb_6_6-branch:1.93.0.2
	gdb_6_6-2006-11-15-branchpoint:1.93
	binutils-csl-arm-2006q3-27:1.88.2.2
	binutils-csl-sourcerygxx-4_1-27:1.88.2.2
	binutils-csl-arm-2006q3-26:1.88.2.2
	binutils-csl-sourcerygxx-4_1-26:1.88.2.2
	binutils-csl-sourcerygxx-4_1-25:1.88.2.2
	binutils-csl-sourcerygxx-4_1-24:1.88.2.2
	binutils-csl-sourcerygxx-4_1-23:1.88.2.2
	insight_6_5-20061003-release:1.89
	gdb-csl-symbian-6_4_50_20060226-12:1.85
	binutils-csl-sourcerygxx-4_1-21:1.88.2.2
	binutils-csl-arm-2006q3-21:1.88.2.2
	binutils-csl-sourcerygxx-4_1-22:1.88.2.2
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.88.2.2
	binutils-csl-sourcerygxx-4_1-20:1.88.2.2
	binutils-csl-arm-2006q3-19:1.88.2.2
	binutils-csl-sourcerygxx-4_1-19:1.88.2.2
	binutils-csl-sourcerygxx-4_1-18:1.88.2.2
	binutils-csl-renesas-4_1-9:1.88.2.2
	gdb-csl-sourcerygxx-3_4_4-25:1.84
	binutils-csl-sourcerygxx-3_4_4-25:1.73
	nickrob-async-20060828-mergepoint:1.90
	gdb-csl-symbian-6_4_50_20060226-11:1.85
	binutils-csl-renesas-4_1-8:1.88.2.2
	binutils-csl-renesas-4_1-7:1.88.2.2
	binutils-csl-renesas-4_1-6:1.88.2.2
	gdb-csl-sourcerygxx-4_1-17:1.85
	binutils-csl-sourcerygxx-4_1-17:1.88.2.2
	gdb-csl-20060226-branch-local-2:1.85
	gdb-csl-sourcerygxx-4_1-14:1.85
	binutils-csl-sourcerygxx-4_1-14:1.88.2.2
	binutils-csl-sourcerygxx-4_1-15:1.88.2.2
	gdb-csl-sourcerygxx-4_1-13:1.85
	binutils-csl-sourcerygxx-4_1-13:1.88.2.2
	binutils-2_17:1.89
	gdb-csl-sourcerygxx-4_1-12:1.85
	binutils-csl-sourcerygxx-4_1-12:1.88.2.2
	gdb-csl-sourcerygxx-3_4_4-21:1.85
	binutils-csl-sourcerygxx-3_4_4-21:1.88.2.2
	gdb_6_5-20060621-release:1.89
	binutils-csl-wrs-linux-3_4_4-24:1.73
	binutils-csl-wrs-linux-3_4_4-23:1.73
	gdb-csl-sourcerygxx-4_1-9:1.85
	binutils-csl-sourcerygxx-4_1-9:1.88.2.2
	gdb-csl-sourcerygxx-4_1-8:1.85
	binutils-csl-sourcerygxx-4_1-8:1.88.2.2
	gdb-csl-sourcerygxx-4_1-7:1.85
	binutils-csl-sourcerygxx-4_1-7:1.88.2.2
	gdb-csl-arm-2006q1-6:1.85
	binutils-csl-arm-2006q1-6:1.88.2.2
	gdb-csl-sourcerygxx-4_1-6:1.85
	binutils-csl-sourcerygxx-4_1-6:1.88.2.2
	binutils-csl-wrs-linux-3_4_4-22:1.73
	gdb-csl-symbian-6_4_50_20060226-10:1.85
	gdb-csl-symbian-6_4_50_20060226-9:1.85
	gdb-csl-symbian-6_4_50_20060226-8:1.85
	gdb-csl-coldfire-4_1-11:1.85
	binutils-csl-coldfire-4_1-11:1.88.2.2
	gdb-csl-sourcerygxx-3_4_4-19:1.85
	binutils-csl-sourcerygxx-3_4_4-19:1.88.2.2
	gdb-csl-coldfire-4_1-10:1.85
	gdb_6_5-branch:1.89.0.12
	gdb_6_5-2006-05-14-branchpoint:1.89
	binutils-csl-coldfire-4_1-10:1.88.2.2
	gdb-csl-sourcerygxx-4_1-5:1.85
	binutils-csl-sourcerygxx-4_1-5:1.88.2.2
	nickrob-async-20060513-branch:1.89.0.10
	nickrob-async-20060513-branchpoint:1.89
	gdb-csl-sourcerygxx-4_1-4:1.85
	binutils-csl-sourcerygxx-4_1-4:1.88.2.2
	msnyder-reverse-20060502-branch:1.89.0.8
	msnyder-reverse-20060502-branchpoint:1.89
	binutils-csl-wrs-linux-3_4_4-21:1.73
	gdb-csl-morpho-4_1-4:1.85
	binutils-csl-morpho-4_1-4:1.88.2.2
	gdb-csl-sourcerygxx-3_4_4-17:1.85
	binutils-csl-sourcerygxx-3_4_4-17:1.88.2.1
	binutils-csl-wrs-linux-3_4_4-20:1.73
	readline_5_1-import-branch:1.89.0.6
	readline_5_1-import-branchpoint:1.89
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.85
	binutils-2_17-branch:1.89.0.4
	binutils-2_17-branchpoint:1.89
	gdb-csl-symbian-20060226-branch:1.85.0.4
	gdb-csl-symbian-20060226-branchpoint:1.85
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.85
	msnyder-reverse-20060331-branch:1.89.0.2
	msnyder-reverse-20060331-branchpoint:1.89
	binutils-csl-2_17-branch:1.88.0.2
	binutils-csl-2_17-branchpoint:1.88
	gdb-csl-available-20060303-branch:1.86.0.2
	gdb-csl-available-20060303-branchpoint:1.86
	gdb-csl-20060226-branch:1.85.0.2
	gdb-csl-20060226-branchpoint:1.85
	gdb_6_4-20051202-release:1.84
	msnyder-fork-checkpoint-branch:1.84.0.6
	msnyder-fork-checkpoint-branchpoint:1.84
	gdb-csl-gxxpro-6_3-branch:1.84.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.84
	gdb_6_4-branch:1.84.0.2
	gdb_6_4-2005-11-01-branchpoint:1.84
	gdb-csl-arm-20051020-branch:1.83.0.2
	gdb-csl-arm-20051020-branchpoint:1.83
	binutils-csl-gxxpro-3_4-branch:1.73.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.73
	binutils-2_16_1:1.73
	msnyder-tracepoint-checkpoint-branch:1.78.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.78
	gdb-csl-arm-20050325-2005-q1b:1.74
	binutils-csl-arm-2005q1b:1.73
	binutils-2_16:1.73
	gdb-csl-arm-20050325-2005-q1a:1.74
	binutils-csl-arm-2005q1a:1.73
	csl-arm-20050325-branch:1.74.0.2
	csl-arm-20050325-branchpoint:1.74
	binutils-csl-arm-2005q1-branch:1.73.0.4
	binutils-csl-arm-2005q1-branchpoint:1.73
	binutils-2_16-branch:1.73.0.2
	binutils-2_16-branchpoint:1.73
	csl-arm-2004-q3d:1.70
	gdb_6_3-20041109-release:1.68
	gdb_6_3-branch:1.68.0.2
	gdb_6_3-20041019-branchpoint:1.68
	csl-arm-2004-q3:1.68
	drow_intercu-merge-20040921:1.68
	drow_intercu-merge-20040915:1.66
	jimb-gdb_6_2-e500-branch:1.65.0.6
	jimb-gdb_6_2-e500-branchpoint:1.65
	gdb_6_2-20040730-release:1.65
	gdb_6_2-branch:1.65.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.65
	gdb_6_1_1-20040616-release:1.61
	binutils-2_15:1.61.6.1
	binutils-2_15-branchpoint:1.61
	csl-arm-2004-q1a:1.64
	csl-arm-2004-q1:1.64
	gdb_6_1-2004-04-05-release:1.61
	drow_intercu-merge-20040402:1.64
	drow_intercu-merge-20040327:1.63
	ezannoni_pie-20040323-branch:1.62.0.2
	ezannoni_pie-20040323-branchpoint:1.62
	cagney_tramp-20040321-mergepoint:1.61
	cagney_tramp-20040309-branch:1.61.0.12
	cagney_tramp-20040309-branchpoint:1.61
	gdb_6_1-branch:1.61.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.61
	drow_intercu-20040221-branch:1.61.0.8
	drow_intercu-20040221-branchpoint:1.61
	binutils-2_15-branch:1.61.0.6
	cagney_bfdfile-20040213-branch:1.61.0.4
	cagney_bfdfile-20040213-branchpoint:1.61
	drow-cplus-merge-20040208:1.61
	carlton_dictionary-20040126-merge:1.61
	cagney_bigcore-20040122-branch:1.61.0.2
	cagney_bigcore-20040122-branchpoint:1.61
	drow-cplus-merge-20040113:1.61
	csl-arm-2003-q4:1.60
	drow-cplus-merge-20031224:1.60
	drow-cplus-merge-20031220:1.60
	carlton_dictionary-20031215-merge:1.60
	drow-cplus-merge-20031214:1.60
	carlton-dictionary-20031111-merge:1.60
	gdb_6_0-2003-10-04-release:1.56
	kettenis_sparc-20030918-branch:1.58.0.6
	kettenis_sparc-20030918-branchpoint:1.58
	carlton_dictionary-20030917-merge:1.58
	ezannoni_pie-20030916-branchpoint:1.58
	ezannoni_pie-20030916-branch:1.58.0.4
	cagney_x86i386-20030821-branch:1.58.0.2
	cagney_x86i386-20030821-branchpoint:1.58
	carlton_dictionary-20030805-merge:1.57
	carlton_dictionary-20030627-merge:1.57
	gdb_6_0-branch:1.56.0.10
	gdb_6_0-2003-06-23-branchpoint:1.56
	jimb-ppc64-linux-20030613-branch:1.56.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.56
	binutils-2_14:1.53
	cagney_convert-20030606-branch:1.56.0.6
	cagney_convert-20030606-branchpoint:1.56
	cagney_writestrings-20030508-branch:1.54.0.4
	cagney_writestrings-20030508-branchpoint:1.54
	jimb-ppc64-linux-20030528-branch:1.56.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.56
	carlton_dictionary-20030523-merge:1.56
	cagney_fileio-20030521-branch:1.56.0.2
	cagney_fileio-20030521-branchpoint:1.56
	kettenis_i386newframe-20030517-mergepoint:1.55
	jimb-ppc64-linux-20030509-branch:1.54.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.54
	kettenis_i386newframe-20030504-mergepoint:1.53
	carlton_dictionary-20030430-merge:1.53
	binutils-2_14-branch:1.53.0.10
	binutils-2_14-branchpoint:1.53
	kettenis_i386newframe-20030419-branch:1.53.0.8
	kettenis_i386newframe-20030419-branchpoint:1.53
	carlton_dictionary-20030416-merge:1.53
	cagney_frameaddr-20030409-mergepoint:1.53
	kettenis_i386newframe-20030406-branch:1.53.0.6
	kettenis_i386newframe-20030406-branchpoint:1.53
	cagney_frameaddr-20030403-branchpoint:1.53
	cagney_frameaddr-20030403-branch:1.53.0.4
	cagney_framebase-20030330-mergepoint:1.53
	cagney_framebase-20030326-branch:1.53.0.2
	cagney_framebase-20030326-branchpoint:1.53
	cagney_lazyid-20030317-branch:1.52.0.8
	cagney_lazyid-20030317-branchpoint:1.52
	kettenis-i386newframe-20030316-mergepoint:1.52
	offbyone-20030313-branch:1.52.0.6
	offbyone-20030313-branchpoint:1.52
	kettenis-i386newframe-20030308-branch:1.52.0.4
	kettenis-i386newframe-20030308-branchpoint:1.52
	carlton_dictionary-20030305-merge:1.52
	cagney_offbyone-20030303-branch:1.52.0.2
	cagney_offbyone-20030303-branchpoint:1.52
	carlton_dictionary-20030207-merge:1.51
	interps-20030202-branch:1.50.0.4
	interps-20030202-branchpoint:1.50
	cagney-unwind-20030108-branch:1.50.0.2
	cagney-unwind-20030108-branchpoint:1.50
	binutils-2_13_2_1:1.45.2.1
	binutils-2_13_2:1.45.2.1
	carlton_dictionary-20021223-merge:1.49
	gdb_5_3-2002-12-12-release:1.46
	carlton_dictionary-20021115-merge:1.46
	binutils-2_13_1:1.45
	kseitz_interps-20021105-merge:1.46
	kseitz_interps-20021103-merge:1.46
	drow-cplus-merge-20021020:1.46
	drow-cplus-merge-20021025:1.46
	carlton_dictionary-20021025-merge:1.46
	carlton_dictionary-20021011-merge:1.46
	drow-cplus-branch:1.46.0.12
	drow-cplus-branchpoint:1.46
	kseitz_interps-20020930-merge:1.46
	carlton_dictionary-20020927-merge:1.46
	carlton_dictionary-branch:1.46.0.10
	carlton_dictionary-20020920-branchpoint:1.46
	sid-20020905-branchpoint:1.46
	sid-20020905-branch:1.46.0.8
	gdb_5_3-branch:1.46.0.6
	gdb_5_3-2002-09-04-branchpoint:1.46
	kseitz_interps-20020829-merge:1.46
	cagney_sysregs-20020825-branch:1.46.0.4
	cagney_sysregs-20020825-branchpoint:1.46
	readline_4_3-import-branch:1.46.0.2
	readline_4_3-import-branchpoint:1.46
	binutils-2_13:1.45
	gdb_5_2_1-2002-07-23-release:1.37
	binutils-2_13-branchpoint:1.45
	binutils-2_13-branch:1.45.0.2
	kseitz_interps-20020528-branch:1.41.0.2
	kseitz_interps-20020528-branchpoint:1.41
	cagney_regbuf-20020515-branch:1.40.0.2
	cagney_regbuf-20020515-branchpoint:1.40
	binutils-2_12_1:1.35.2.4
	jimb-macro-020506-branch:1.39.0.2
	jimb-macro-020506-branchpoint:1.39
	gdb_5_2-2002-04-29-release:1.37
	binutils-2_12:1.35.2.2
	gdb_5_2-branch:1.37.0.2
	gdb_5_2-2002-03-03-branchpoint:1.37
	binutils-2_12-branch:1.35.0.2
	binutils-2_12-branchpoint:1.35
	gdb_5_1_1-2002-01-24-release:1.23
	gdb_5_1_0_1-2002-01-03-release:1.23
	cygnus_cvs_20020108_pre:1.34
	gdb_5_1_0_1-2002-01-03-branch:1.23.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.23
	gdb_5_1-2001-11-21-release:1.23
	gdb_s390-2001-09-26-branch:1.23.0.4
	gdb_s390-2001-09-26-branchpoint:1.23
	gdb_5_1-2001-07-29-branch:1.23.0.2
	gdb_5_1-2001-07-29-branchpoint:1.23
	binutils-2_11_2:1.21.2.2
	binutils-2_11_1:1.21.2.2
	binutils-2_11:1.21.2.1
	x86_64versiong3:1.21
	binutils-2_11-branch:1.21.0.2
	insight-precleanup-2001-01-01:1.20
	binutils-2_10_1:1.12.2.1
	binutils-2_10:1.12
	gdb-premipsmulti-2000-06-06-branch:1.14.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.14
	gdb_5_0-2000-05-19-release:1.12
	gdb_4_18_2-2000-05-18-release:1.12
	gdb_4_95_1-2000-05-11-snapshot:1.12
	gdb_4_95_0-2000-04-27-snapshot:1.12
	gdb_5_0-2000-04-10-branch:1.12.0.4
	gdb_5_0-2000-04-10-branchpoint:1.12
	binutils-2_10-branch:1.12.0.2
	binutils-2_10-branchpoint:1.12
	binutils_latest_snapshot:1.143
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.7
	binu_ss_19990602:1.4
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.143
date	2013.10.08.15.57.24;	author schwab;	state Exp;
branches;
next	1.142;

1.142
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2013.02.10.04.36.31;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2012.07.13.14.22.47;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2012.06.29.14.45.59;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2012.06.22.09.30.18;	author schwab;	state Exp;
branches;
next	1.134;

1.134
date	2012.05.21.08.17.15;	author schwab;	state Exp;
branches;
next	1.133;

1.133
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.132;

1.132
date	2012.04.26.14.38.45;	author schwab;	state Exp;
branches;
next	1.131;

1.131
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2012.03.31.14.27.33;	author schwab;	state Exp;
branches;
next	1.129;

1.129
date	2012.03.13.06.04.34;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2011.12.01.15.50.58;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2011.10.19.07.17.14;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2011.02.22.15.46.13;	author schwab;	state Exp;
branches;
next	1.124;

1.124
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.123;

1.123
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.122;

1.122
date	2010.08.25.14.53.42;	author hjl;	state Exp;
branches;
next	1.121;

1.121
date	2010.08.20.21.06.30;	author macro;	state Exp;
branches;
next	1.120;

1.120
date	2010.08.13.13.03.45;	author nathan;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.28.09.34.20;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2009.09.07.16.29.34;	author schwab;	state Exp;
branches;
next	1.115;

1.115
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2009.08.26.13.42.27;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2009.08.26.13.35.36;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2009.02.03.14.36.46;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2008.12.23.10.23.53;	author schwab;	state Exp;
branches;
next	1.109;

1.109
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2008.06.29.12.56.40;	author schwab;	state Exp;
branches;
next	1.107;

1.107
date	2008.05.21.12.01.36;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.105;

1.105
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.104;

1.104
date	2007.09.11.16.07.50;	author kazu;	state Exp;
branches;
next	1.103;

1.103
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.101;

1.101
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2007.04.23.07.51.26;	author nathan;	state Exp;
branches;
next	1.99;

1.99
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.08.18.42.36;	author kazu;	state Exp;
branches;
next	1.96;

1.96
date	2006.12.25.22.39.21;	author kazu;	state Exp;
branches;
next	1.95;

1.95
date	2006.12.19.13.24.56;	author kazu;	state Exp;
branches;
next	1.94;

1.94
date	2006.12.07.15.39.01;	author kazu;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2006.06.14.08.27.40;	author rsandifo;	state Exp;
branches;
next	1.89;

1.89
date	2006.03.25.10.24.27;	author rsandifo;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2006.03.06.13.42.03;	author nathan;	state Exp;
branches;
next	1.86;

1.86
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.85;

1.85
date	2006.02.07.19.01.09;	author nathan;	state Exp;
branches;
next	1.84;

1.84
date	2005.11.01.22.57.23;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2005.08.25.02.32.09;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2005.08.18.01.28.23;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2005.07.08.06.19.59;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2005.06.20.18.12.07;	author hjl;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.05.14.33.48;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.04.15.53.16;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.04.11.00.13;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.18.17.20.29;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2005.01.11.09.32.49;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.07.10.51.45;	author schwab;	state Exp;
branches;
next	1.70;

1.70
date	2004.10.21.15.28.23;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2004.10.20.21.29.45;	author schwab;	state Exp;
branches;
next	1.68;

1.68
date	2004.09.17.07.14.27;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2004.09.16.14.52.04;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.24.04.46.20;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.25.12.48.35;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.08.11.01.37;	author kazu;	state Exp;
branches
	1.61.6.1
	1.61.8.1;
next	1.60;

1.60
date	2003.11.11.13.32.37;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.17.19.40.36;	author schwab;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.11.16.19.12;	author schwab;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.26.14.20.14;	author schwab;	state Exp;
branches
	1.53.8.1;
next	1.52;

1.52
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.04.13.23.40;	author schwab;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.07.13.12.35;	author schwab;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.04.15.07.13;	author schwab;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches
	1.46.10.1
	1.46.12.1;
next	1.45;

1.45
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.05.13.31.59;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.25.13.09.37;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.05.07.00.16.51;	author amodra;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2002.04.04.19.53.36;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.28.03.27.43;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.19.12.40.25;	author jakub;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.13.18.14.40;	author thorpej;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.08.19.18.35;	author cgd;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.12.18.17.59.58;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.27.09.16.10;	author schwab;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.20.10.11.07;	author schwab;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.08.21.03.59;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.12.08.18.34.31;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.06.18.59.48;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.19.23.21.36;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.15.18.52.12;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.21.23.41.32;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.27.00.31.17;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.11.19.15.41.55;	author clm;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.18.25.09;	author clm;	state Exp;
branches;
next	1.7;

1.7
date	99.07.13.18.21.18;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.07.12.08.15.16;	author schwab;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.07.35.03;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.02.02.53.19;	author schwab;	state Exp;
branches;
next	1.3;

1.3
date	99.05.05.11.34.29;	author clm;	state Exp;
branches;
next	1.2;

1.2
date	99.05.05.10.56.17;	author clm;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.126.2.1
date	2011.12.02.13.36.32;	author hp;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2012.05.11.12.24.24;	author nickc;	state Exp;
branches;
next	;

1.88.2.1
date	2006.03.21.09.51.28;	author rsandifo;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2006.04.27.17.01.18;	author rsandifo;	state Exp;
branches;
next	1.88.2.3;

1.88.2.3
date	2006.11.17.14.21.49;	author kazu;	state Exp;
branches;
next	1.88.2.4;

1.88.2.4
date	2006.11.28.14.09.49;	author kazu;	state Exp;
branches;
next	1.88.2.5;

1.88.2.5
date	2006.11.29.10.32.51;	author kazu;	state Exp;
branches;
next	1.88.2.6;

1.88.2.6
date	2006.11.30.14.49.41;	author kazu;	state Exp;
branches;
next	;

1.61.6.1
date	2004.04.08.12.41.42;	author amodra;	state Exp;
branches;
next	;

1.61.8.1
date	2004.03.27.17.37.33;	author drow;	state Exp;
branches;
next	1.61.8.2;

1.61.8.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.61.8.3;

1.61.8.3
date	2004.09.16.17.00.24;	author drow;	state Exp;
branches;
next	1.61.8.4;

1.61.8.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.53.8.1
date	2003.05.18.09.43.41;	author kettenis;	state Exp;
branches;
next	;

1.46.10.1
date	2002.12.23.19.37.42;	author carlton;	state Exp;
branches;
next	1.46.10.2;

1.46.10.2
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.46.10.3;

1.46.10.3
date	2003.03.06.00.56.15;	author carlton;	state Exp;
branches;
next	1.46.10.4;

1.46.10.4
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.46.10.5;

1.46.10.5
date	2003.05.23.18.40.23;	author carlton;	state Exp;
branches;
next	1.46.10.6;

1.46.10.6
date	2003.06.27.21.49.15;	author carlton;	state Exp;
branches;
next	1.46.10.7;

1.46.10.7
date	2003.09.17.21.27.51;	author carlton;	state Exp;
branches;
next	1.46.10.8;

1.46.10.8
date	2003.11.11.23.50.17;	author carlton;	state Exp;
branches;
next	1.46.10.9;

1.46.10.9
date	2004.01.26.19.11.05;	author carlton;	state Exp;
branches;
next	;

1.46.12.1
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	1.46.12.2;

1.46.12.2
date	2004.01.13.16.11.37;	author drow;	state Exp;
branches;
next	;

1.45.2.1
date	2002.12.15.22.31.45;	author drow;	state Exp;
branches;
next	;

1.41.2.1
date	2002.06.20.01.30.17;	author kseitz;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.07.22.21.46.44;	author kseitz;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	;

1.40.2.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.35.2.1
date	2002.02.13.19.16.41;	author thorpej;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.02.19.13.10.21;	author jakub;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2002.04.04.14.52.57;	author amodra;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2002.05.09.11.50.23;	author amodra;	state Exp;
branches;
next	;

1.21.2.1
date	2001.03.20.10.10.04;	author schwab;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.143
log
@* elf32-m68k.c (elf_m68k_size_dynamic_sections): Add DT_DEBUG also
for PIE executables.
@
text
@/* Motorola 68k series support for 32-bit ELF
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/m68k.h"
#include "opcode/m68k.h"

static bfd_boolean
elf_m68k_discard_copies (struct elf_link_hash_entry *, void *);

static reloc_howto_type howto_table[] =
{
  HOWTO(R_68K_NONE,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_NONE",      FALSE, 0, 0x00000000,FALSE),
  HOWTO(R_68K_32,         0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_32",        FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_16,         0, 1,16, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_16",        FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_8,          0, 0, 8, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_8",         FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PC32,       0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PC32",      FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PC16,       0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC16",      FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PC8,        0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC8",       FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_GOT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_GOT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GOT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_GOT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PLT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PLT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PLT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_PLT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_PLT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_PLT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_COPY,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_COPY",      FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GLOB_DAT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_GLOB_DAT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_JMP_SLOT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_JMP_SLOT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_RELATIVE,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_RELATIVE",  FALSE, 0, 0xffffffff,FALSE),
  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_68K_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_68K_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),
  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_68K_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_68K_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),

  /* TLS general dynamic variable reference.  */
  HOWTO (R_68K_TLS_GD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_GD32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_GD16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_GD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_GD8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_GD8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic variable reference.  */
  HOWTO (R_68K_TLS_LDM32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDM32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LDM16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDM16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LDM8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDM8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LDO32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDO32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LDO16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LDO8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LDO8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS initial execution variable reference.  */
  HOWTO (R_68K_TLS_IE32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_IE32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_IE16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_IE16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_IE8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_IE8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local execution variable reference.  */
  HOWTO (R_68K_TLS_LE32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LE32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LE16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LE16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_LE8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_LE8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS GD/LD dynamic relocations.  */
  HOWTO (R_68K_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_DTPMOD32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_DTPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_DTPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_68K_TLS_TPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_68K_TLS_TPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static void
rtype_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int indx = ELF32_R_TYPE (dst->r_info);

  if (indx >= (unsigned int) R_68K_max)
    {
      (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
			     abfd, (int) indx);
      indx = R_68K_NONE;
    }
  cache_ptr->howto = &howto_table[indx];
}

#define elf_info_to_howto rtype_to_howto

static const struct
{
  bfd_reloc_code_real_type bfd_val;
  int elf_val;
}
  reloc_map[] =
{
  { BFD_RELOC_NONE, R_68K_NONE },
  { BFD_RELOC_32, R_68K_32 },
  { BFD_RELOC_16, R_68K_16 },
  { BFD_RELOC_8, R_68K_8 },
  { BFD_RELOC_32_PCREL, R_68K_PC32 },
  { BFD_RELOC_16_PCREL, R_68K_PC16 },
  { BFD_RELOC_8_PCREL, R_68K_PC8 },
  { BFD_RELOC_32_GOT_PCREL, R_68K_GOT32 },
  { BFD_RELOC_16_GOT_PCREL, R_68K_GOT16 },
  { BFD_RELOC_8_GOT_PCREL, R_68K_GOT8 },
  { BFD_RELOC_32_GOTOFF, R_68K_GOT32O },
  { BFD_RELOC_16_GOTOFF, R_68K_GOT16O },
  { BFD_RELOC_8_GOTOFF, R_68K_GOT8O },
  { BFD_RELOC_32_PLT_PCREL, R_68K_PLT32 },
  { BFD_RELOC_16_PLT_PCREL, R_68K_PLT16 },
  { BFD_RELOC_8_PLT_PCREL, R_68K_PLT8 },
  { BFD_RELOC_32_PLTOFF, R_68K_PLT32O },
  { BFD_RELOC_16_PLTOFF, R_68K_PLT16O },
  { BFD_RELOC_8_PLTOFF, R_68K_PLT8O },
  { BFD_RELOC_NONE, R_68K_COPY },
  { BFD_RELOC_68K_GLOB_DAT, R_68K_GLOB_DAT },
  { BFD_RELOC_68K_JMP_SLOT, R_68K_JMP_SLOT },
  { BFD_RELOC_68K_RELATIVE, R_68K_RELATIVE },
  { BFD_RELOC_CTOR, R_68K_32 },
  { BFD_RELOC_VTABLE_INHERIT, R_68K_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_68K_GNU_VTENTRY },
  { BFD_RELOC_68K_TLS_GD32, R_68K_TLS_GD32 },
  { BFD_RELOC_68K_TLS_GD16, R_68K_TLS_GD16 },
  { BFD_RELOC_68K_TLS_GD8, R_68K_TLS_GD8 },
  { BFD_RELOC_68K_TLS_LDM32, R_68K_TLS_LDM32 },
  { BFD_RELOC_68K_TLS_LDM16, R_68K_TLS_LDM16 },
  { BFD_RELOC_68K_TLS_LDM8, R_68K_TLS_LDM8 },
  { BFD_RELOC_68K_TLS_LDO32, R_68K_TLS_LDO32 },
  { BFD_RELOC_68K_TLS_LDO16, R_68K_TLS_LDO16 },
  { BFD_RELOC_68K_TLS_LDO8, R_68K_TLS_LDO8 },
  { BFD_RELOC_68K_TLS_IE32, R_68K_TLS_IE32 },
  { BFD_RELOC_68K_TLS_IE16, R_68K_TLS_IE16 },
  { BFD_RELOC_68K_TLS_IE8, R_68K_TLS_IE8 },
  { BFD_RELOC_68K_TLS_LE32, R_68K_TLS_LE32 },
  { BFD_RELOC_68K_TLS_LE16, R_68K_TLS_LE16 },
  { BFD_RELOC_68K_TLS_LE8, R_68K_TLS_LE8 },
};

static reloc_howto_type *
reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
		   bfd_reloc_code_real_type code)
{
  unsigned int i;
  for (i = 0; i < sizeof (reloc_map) / sizeof (reloc_map[0]); i++)
    {
      if (reloc_map[i].bfd_val == code)
	return &howto_table[reloc_map[i].elf_val];
    }
  return 0;
}

static reloc_howto_type *
reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
{
  unsigned int i;

  for (i = 0; i < sizeof (howto_table) / sizeof (howto_table[0]); i++)
    if (howto_table[i].name != NULL
	&& strcasecmp (howto_table[i].name, r_name) == 0)
      return &howto_table[i];

  return NULL;
}

#define bfd_elf32_bfd_reloc_type_lookup reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup reloc_name_lookup
#define ELF_ARCH bfd_arch_m68k
#define ELF_TARGET_ID M68K_ELF_DATA

/* Functions for the m68k ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

/* Describes one of the various PLT styles.  */

struct elf_m68k_plt_info
{
  /* The size of each PLT entry.  */
  bfd_vma size;

  /* The template for the first PLT entry.  */
  const bfd_byte *plt0_entry;

  /* Offsets of fields in PLT0_ENTRY that require R_68K_PC32 relocations.
     The comments by each member indicate the value that the relocation
     is against.  */
  struct {
    unsigned int got4; /* .got + 4 */
    unsigned int got8; /* .got + 8 */
  } plt0_relocs;

  /* The template for a symbol's PLT entry.  */
  const bfd_byte *symbol_entry;

  /* Offsets of fields in SYMBOL_ENTRY that require R_68K_PC32 relocations.
     The comments by each member indicate the value that the relocation
     is against.  */
  struct {
    unsigned int got; /* the symbol's .got.plt entry */
    unsigned int plt; /* .plt */
  } symbol_relocs;

  /* The offset of the resolver stub from the start of SYMBOL_ENTRY.
     The stub starts with "move.l #relocoffset,%d0".  */
  bfd_vma symbol_resolve_entry;
};

/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 20

/* The first entry in a procedure linkage table looks like this.  See
   the SVR4 ABI m68k supplement to see how this works.  */

static const bfd_byte elf_m68k_plt0_entry[PLT_ENTRY_SIZE] =
{
  0x2f, 0x3b, 0x01, 0x70, /* move.l (%pc,addr),-(%sp) */
  0, 0, 0, 2,		  /* + (.got + 4) - . */
  0x4e, 0xfb, 0x01, 0x71, /* jmp ([%pc,addr]) */
  0, 0, 0, 2,		  /* + (.got + 8) - . */
  0, 0, 0, 0		  /* pad out to 20 bytes.  */
};

/* Subsequent entries in a procedure linkage table look like this.  */

static const bfd_byte elf_m68k_plt_entry[PLT_ENTRY_SIZE] =
{
  0x4e, 0xfb, 0x01, 0x71, /* jmp ([%pc,symbol@@GOTPC]) */
  0, 0, 0, 2,		  /* + (.got.plt entry) - . */
  0x2f, 0x3c,		  /* move.l #offset,-(%sp) */
  0, 0, 0, 0,		  /* + reloc index */
  0x60, 0xff,		  /* bra.l .plt */
  0, 0, 0, 0		  /* + .plt - . */
};

static const struct elf_m68k_plt_info elf_m68k_plt_info = {
  PLT_ENTRY_SIZE,
  elf_m68k_plt0_entry, { 4, 12 },
  elf_m68k_plt_entry, { 4, 16 }, 8
};

#define ISAB_PLT_ENTRY_SIZE 24

static const bfd_byte elf_isab_plt0_entry[ISAB_PLT_ENTRY_SIZE] =
{
  0x20, 0x3c,             /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* + (.got + 4) - . */
  0x2f, 0x3b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l),-(%sp) */
  0x20, 0x3c,             /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* + (.got + 8) - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
  0x4e, 0xd0,             /* jmp (%a0) */
  0x4e, 0x71		  /* nop */
};

/* Subsequent entries in a procedure linkage table look like this.  */

static const bfd_byte elf_isab_plt_entry[ISAB_PLT_ENTRY_SIZE] =
{
  0x20, 0x3c,             /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* + (.got.plt entry) - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
  0x4e, 0xd0,             /* jmp (%a0) */
  0x2f, 0x3c,             /* move.l #offset,-(%sp) */
  0, 0, 0, 0,             /* + reloc index */
  0x60, 0xff,             /* bra.l .plt */
  0, 0, 0, 0              /* + .plt - . */
};

static const struct elf_m68k_plt_info elf_isab_plt_info = {
  ISAB_PLT_ENTRY_SIZE,
  elf_isab_plt0_entry, { 2, 12 },
  elf_isab_plt_entry, { 2, 20 }, 12
};

#define ISAC_PLT_ENTRY_SIZE 24

static const bfd_byte elf_isac_plt0_entry[ISAC_PLT_ENTRY_SIZE] =
{
  0x20, 0x3c,		  /* move.l #offset,%d0 */
  0, 0, 0, 0,		  /* replaced with .got + 4 - . */
  0x2e, 0xbb, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l),(%sp) */
  0x20, 0x3c,		  /* move.l #offset,%d0 */
  0, 0, 0, 0,		  /* replaced with .got + 8 - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
  0x4e, 0xd0,		  /* jmp (%a0) */
  0x4e, 0x71		  /* nop */
};

/* Subsequent entries in a procedure linkage table look like this.  */

static const bfd_byte elf_isac_plt_entry[ISAC_PLT_ENTRY_SIZE] =
{
  0x20, 0x3c,		  /* move.l #offset,%d0 */
  0, 0, 0, 0,		  /* replaced with (.got entry) - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
  0x4e, 0xd0,		  /* jmp (%a0) */
  0x2f, 0x3c,		  /* move.l #offset,-(%sp) */
  0, 0, 0, 0,		  /* replaced with offset into relocation table */
  0x61, 0xff,		  /* bsr.l .plt */
  0, 0, 0, 0 		  /* replaced with .plt - . */
};

static const struct elf_m68k_plt_info elf_isac_plt_info = {
  ISAC_PLT_ENTRY_SIZE,
  elf_isac_plt0_entry, { 2, 12},
  elf_isac_plt_entry, { 2, 20 }, 12
};

#define CPU32_PLT_ENTRY_SIZE 24
/* Procedure linkage table entries for the cpu32 */
static const bfd_byte elf_cpu32_plt0_entry[CPU32_PLT_ENTRY_SIZE] =
{
  0x2f, 0x3b, 0x01, 0x70, /* move.l (%pc,addr),-(%sp) */
  0, 0, 0, 2,             /* + (.got + 4) - . */
  0x22, 0x7b, 0x01, 0x70, /* moveal %pc@@(0xc), %a1 */
  0, 0, 0, 2,             /* + (.got + 8) - . */
  0x4e, 0xd1,             /* jmp %a1@@ */
  0, 0, 0, 0,             /* pad out to 24 bytes.  */
  0, 0
};

static const bfd_byte elf_cpu32_plt_entry[CPU32_PLT_ENTRY_SIZE] =
{
  0x22, 0x7b, 0x01, 0x70,  /* moveal %pc@@(0xc), %a1 */
  0, 0, 0, 2,              /* + (.got.plt entry) - . */
  0x4e, 0xd1,              /* jmp %a1@@ */
  0x2f, 0x3c,              /* move.l #offset,-(%sp) */
  0, 0, 0, 0,              /* + reloc index */
  0x60, 0xff,              /* bra.l .plt */
  0, 0, 0, 0,              /* + .plt - . */
  0, 0
};

static const struct elf_m68k_plt_info elf_cpu32_plt_info = {
  CPU32_PLT_ENTRY_SIZE,
  elf_cpu32_plt0_entry, { 4, 12 },
  elf_cpu32_plt_entry, { 4, 18 }, 10
};

/* The m68k linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that it
   can discard PC relative relocs if it doesn't need them when linking
   with -Bsymbolic.  We store the information in a field extending the
   regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we have
   copied for a given symbol.  */

struct elf_m68k_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_m68k_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* Forward declaration.  */
struct elf_m68k_got_entry;

/* m68k ELF linker hash entry.  */

struct elf_m68k_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_m68k_pcrel_relocs_copied *pcrel_relocs_copied;

  /* Key to got_entries.  */
  unsigned long got_entry_key;

  /* List of GOT entries for this symbol.  This list is build during
     offset finalization and is used within elf_m68k_finish_dynamic_symbol
     to traverse all GOT entries for a particular symbol.

     ??? We could've used root.got.glist field instead, but having
     a separate field is cleaner.  */
  struct elf_m68k_got_entry *glist;
};

#define elf_m68k_hash_entry(ent) ((struct elf_m68k_link_hash_entry *) (ent))

/* Key part of GOT entry in hashtable.  */
struct elf_m68k_got_entry_key
{
  /* BFD in which this symbol was defined.  NULL for global symbols.  */
  const bfd *bfd;

  /* Symbol index.  Either local symbol index or h->got_entry_key.  */
  unsigned long symndx;

  /* Type is one of R_68K_GOT{8, 16, 32}O, R_68K_TLS_GD{8, 16, 32},
     R_68K_TLS_LDM{8, 16, 32} or R_68K_TLS_IE{8, 16, 32}.

     From perspective of hashtable key, only elf_m68k_got_reloc_type (type)
     matters.  That is, we distinguish between, say, R_68K_GOT16O
     and R_68K_GOT32O when allocating offsets, but they are considered to be
     the same when searching got->entries.  */
  enum elf_m68k_reloc_type type;
};

/* Size of the GOT offset suitable for relocation.  */
enum elf_m68k_got_offset_size { R_8, R_16, R_32, R_LAST };

/* Entry of the GOT.  */
struct elf_m68k_got_entry
{
  /* GOT entries are put into a got->entries hashtable.  This is the key.  */
  struct elf_m68k_got_entry_key key_;

  /* GOT entry data.  We need s1 before offset finalization and s2 after.  */
  union
  {
    struct
    {
      /* Number of times this entry is referenced.  It is used to
	 filter out unnecessary GOT slots in elf_m68k_gc_sweep_hook.  */
      bfd_vma refcount;
    } s1;

    struct
    {
      /* Offset from the start of .got section.  To calculate offset relative
	 to GOT pointer one should substract got->offset from this value.  */
      bfd_vma offset;

      /* Pointer to the next GOT entry for this global symbol.
	 Symbols have at most one entry in one GOT, but might
	 have entries in more than one GOT.
	 Root of this list is h->glist.
	 NULL for local symbols.  */
      struct elf_m68k_got_entry *next;
    } s2;
  } u;
};

/* Return representative type for relocation R_TYPE.
   This is used to avoid enumerating many relocations in comparisons,
   switches etc.  */

static enum elf_m68k_reloc_type
elf_m68k_reloc_got_type (enum elf_m68k_reloc_type r_type)
{
  switch (r_type)
    {
      /* In most cases R_68K_GOTx relocations require the very same
	 handling as R_68K_GOT32O relocation.  In cases when we need
	 to distinguish between the two, we use explicitly compare against
	 r_type.  */
    case R_68K_GOT32:
    case R_68K_GOT16:
    case R_68K_GOT8:
    case R_68K_GOT32O:
    case R_68K_GOT16O:
    case R_68K_GOT8O:
      return R_68K_GOT32O;

    case R_68K_TLS_GD32:
    case R_68K_TLS_GD16:
    case R_68K_TLS_GD8:
      return R_68K_TLS_GD32;

    case R_68K_TLS_LDM32:
    case R_68K_TLS_LDM16:
    case R_68K_TLS_LDM8:
      return R_68K_TLS_LDM32;

    case R_68K_TLS_IE32:
    case R_68K_TLS_IE16:
    case R_68K_TLS_IE8:
      return R_68K_TLS_IE32;

    default:
      BFD_ASSERT (FALSE);
      return 0;
    }
}

/* Return size of the GOT entry offset for relocation R_TYPE.  */

static enum elf_m68k_got_offset_size
elf_m68k_reloc_got_offset_size (enum elf_m68k_reloc_type r_type)
{
  switch (r_type)
    {
    case R_68K_GOT32: case R_68K_GOT16: case R_68K_GOT8:
    case R_68K_GOT32O: case R_68K_TLS_GD32: case R_68K_TLS_LDM32:
    case R_68K_TLS_IE32:
      return R_32;

    case R_68K_GOT16O: case R_68K_TLS_GD16: case R_68K_TLS_LDM16:
    case R_68K_TLS_IE16:
      return R_16;

    case R_68K_GOT8O: case R_68K_TLS_GD8: case R_68K_TLS_LDM8:
    case R_68K_TLS_IE8:
      return R_8;

    default:
      BFD_ASSERT (FALSE);
      return 0;
    }
}

/* Return number of GOT entries we need to allocate in GOT for
   relocation R_TYPE.  */

static bfd_vma
elf_m68k_reloc_got_n_slots (enum elf_m68k_reloc_type r_type)
{
  switch (elf_m68k_reloc_got_type (r_type))
    {
    case R_68K_GOT32O:
    case R_68K_TLS_IE32:
      return 1;

    case R_68K_TLS_GD32:
    case R_68K_TLS_LDM32:
      return 2;

    default:
      BFD_ASSERT (FALSE);
      return 0;
    }
}

/* Return TRUE if relocation R_TYPE is a TLS one.  */

static bfd_boolean
elf_m68k_reloc_tls_p (enum elf_m68k_reloc_type r_type)
{
  switch (r_type)
    {
    case R_68K_TLS_GD32: case R_68K_TLS_GD16: case R_68K_TLS_GD8:
    case R_68K_TLS_LDM32: case R_68K_TLS_LDM16: case R_68K_TLS_LDM8:
    case R_68K_TLS_LDO32: case R_68K_TLS_LDO16: case R_68K_TLS_LDO8:
    case R_68K_TLS_IE32: case R_68K_TLS_IE16: case R_68K_TLS_IE8:
    case R_68K_TLS_LE32: case R_68K_TLS_LE16: case R_68K_TLS_LE8:
    case R_68K_TLS_DTPMOD32: case R_68K_TLS_DTPREL32: case R_68K_TLS_TPREL32:
      return TRUE;

    default:
      return FALSE;
    }
}

/* Data structure representing a single GOT.  */
struct elf_m68k_got
{
  /* Hashtable of 'struct elf_m68k_got_entry's.
     Starting size of this table is the maximum number of
     R_68K_GOT8O entries.  */
  htab_t entries;

  /* Number of R_x slots in this GOT.  Some (e.g., TLS) entries require
     several GOT slots.

     n_slots[R_8] is the count of R_8 slots in this GOT.
     n_slots[R_16] is the cumulative count of R_8 and R_16 slots
     in this GOT.
     n_slots[R_32] is the cumulative count of R_8, R_16 and R_32 slots
     in this GOT.  This is the total number of slots.  */
  bfd_vma n_slots[R_LAST];

  /* Number of local (entry->key_.h == NULL) slots in this GOT.
     This is only used to properly calculate size of .rela.got section;
     see elf_m68k_partition_multi_got.  */
  bfd_vma local_n_slots;

  /* Offset of this GOT relative to beginning of .got section.  */
  bfd_vma offset;
};

/* BFD and its GOT.  This is an entry in multi_got->bfd2got hashtable.  */
struct elf_m68k_bfd2got_entry
{
  /* BFD.  */
  const bfd *bfd;

  /* Assigned GOT.  Before partitioning multi-GOT each BFD has its own
     GOT structure.  After partitioning several BFD's might [and often do]
     share a single GOT.  */
  struct elf_m68k_got *got;
};

/* The main data structure holding all the pieces.  */
struct elf_m68k_multi_got
{
  /* Hashtable mapping each BFD to its GOT.  If a BFD doesn't have an entry
     here, then it doesn't need a GOT (this includes the case of a BFD
     having an empty GOT).

     ??? This hashtable can be replaced by an array indexed by bfd->id.  */
  htab_t bfd2got;

  /* Next symndx to assign a global symbol.
     h->got_entry_key is initialized from this counter.  */
  unsigned long global_symndx;
};

/* m68k ELF linker hash table.  */

struct elf_m68k_link_hash_table
{
  struct elf_link_hash_table root;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  /* The PLT format used by this link, or NULL if the format has not
     yet been chosen.  */
  const struct elf_m68k_plt_info *plt_info;

  /* True, if GP is loaded within each function which uses it.
     Set to TRUE when GOT negative offsets or multi-GOT is enabled.  */
  bfd_boolean local_gp_p;

  /* Switch controlling use of negative offsets to double the size of GOTs.  */
  bfd_boolean use_neg_got_offsets_p;

  /* Switch controlling generation of multiple GOTs.  */
  bfd_boolean allow_multigot_p;

  /* Multi-GOT data structure.  */
  struct elf_m68k_multi_got multi_got_;
};

/* Get the m68k ELF linker hash table from a link_info structure.  */

#define elf_m68k_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == M68K_ELF_DATA ? ((struct elf_m68k_link_hash_table *) ((p)->hash)) : NULL)

/* Shortcut to multi-GOT data.  */
#define elf_m68k_multi_got(INFO) (&elf_m68k_hash_table (INFO)->multi_got_)

/* Create an entry in an m68k ELF linker hash table.  */

static struct bfd_hash_entry *
elf_m68k_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  struct bfd_hash_entry *ret = entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table,
			     sizeof (struct elf_m68k_link_hash_entry));
  if (ret == NULL)
    return ret;

  /* Call the allocation method of the superclass.  */
  ret = _bfd_elf_link_hash_newfunc (ret, table, string);
  if (ret != NULL)
    {
      elf_m68k_hash_entry (ret)->pcrel_relocs_copied = NULL;
      elf_m68k_hash_entry (ret)->got_entry_key = 0;
      elf_m68k_hash_entry (ret)->glist = NULL;
    }

  return ret;
}

/* Create an m68k ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_m68k_link_hash_table_create (bfd *abfd)
{
  struct elf_m68k_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_m68k_link_hash_table);

  ret = (struct elf_m68k_link_hash_table *) bfd_zmalloc (amt);
  if (ret == (struct elf_m68k_link_hash_table *) NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      elf_m68k_link_hash_newfunc,
				      sizeof (struct elf_m68k_link_hash_entry),
				      M68K_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->multi_got_.global_symndx = 1;

  return &ret->root.root;
}

/* Destruct local data.  */

static void
elf_m68k_link_hash_table_free (struct bfd_link_hash_table *_htab)
{
  struct elf_m68k_link_hash_table *htab;

  htab = (struct elf_m68k_link_hash_table *) _htab;

  if (htab->multi_got_.bfd2got != NULL)
    {
      htab_delete (htab->multi_got_.bfd2got);
      htab->multi_got_.bfd2got = NULL;
    }
  _bfd_elf_link_hash_table_free (_htab);
}

/* Set the right machine number.  */

static bfd_boolean
elf32_m68k_object_p (bfd *abfd)
{
  unsigned int mach = 0;
  unsigned features = 0;
  flagword eflags = elf_elfheader (abfd)->e_flags;

  if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
    features |= m68000;
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
    features |= cpu32;
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
    features |= fido_a;
  else
    {
      switch (eflags & EF_M68K_CF_ISA_MASK)
	{
	case EF_M68K_CF_ISA_A_NODIV:
	  features |= mcfisa_a;
	  break;
	case EF_M68K_CF_ISA_A:
	  features |= mcfisa_a|mcfhwdiv;
	  break;
	case EF_M68K_CF_ISA_A_PLUS:
	  features |= mcfisa_a|mcfisa_aa|mcfhwdiv|mcfusp;
	  break;
	case EF_M68K_CF_ISA_B_NOUSP:
	  features |= mcfisa_a|mcfisa_b|mcfhwdiv;
	  break;
	case EF_M68K_CF_ISA_B:
	  features |= mcfisa_a|mcfisa_b|mcfhwdiv|mcfusp;
	  break;
	case EF_M68K_CF_ISA_C:
	  features |= mcfisa_a|mcfisa_c|mcfhwdiv|mcfusp;
	  break;
	case EF_M68K_CF_ISA_C_NODIV:
	  features |= mcfisa_a|mcfisa_c|mcfusp;
	  break;
	}
      switch (eflags & EF_M68K_CF_MAC_MASK)
	{
	case EF_M68K_CF_MAC:
	  features |= mcfmac;
	  break;
	case EF_M68K_CF_EMAC:
	  features |= mcfemac;
	  break;
	}
      if (eflags & EF_M68K_CF_FLOAT)
	features |= cfloat;
    }

  mach = bfd_m68k_features_to_mach (features);
  bfd_default_set_arch_mach (abfd, bfd_arch_m68k, mach);

  return TRUE;
}

/* Somewhat reverse of elf32_m68k_object_p, this sets the e_flag
   field based on the machine number.  */

static void
elf_m68k_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
{
  int mach = bfd_get_mach (abfd);
  unsigned long e_flags = elf_elfheader (abfd)->e_flags;

  if (!e_flags)
    {
      unsigned int arch_mask;

      arch_mask = bfd_m68k_mach_to_features (mach);

      if (arch_mask & m68000)
	e_flags = EF_M68K_M68000;
      else if (arch_mask & cpu32)
	e_flags = EF_M68K_CPU32;
      else if (arch_mask & fido_a)
	e_flags = EF_M68K_FIDO;
      else
	{
	  switch (arch_mask
		  & (mcfisa_a | mcfisa_aa | mcfisa_b | mcfisa_c | mcfhwdiv | mcfusp))
	    {
	    case mcfisa_a:
	      e_flags |= EF_M68K_CF_ISA_A_NODIV;
	      break;
	    case mcfisa_a | mcfhwdiv:
	      e_flags |= EF_M68K_CF_ISA_A;
	      break;
	    case mcfisa_a | mcfisa_aa | mcfhwdiv | mcfusp:
	      e_flags |= EF_M68K_CF_ISA_A_PLUS;
	      break;
	    case mcfisa_a | mcfisa_b | mcfhwdiv:
	      e_flags |= EF_M68K_CF_ISA_B_NOUSP;
	      break;
	    case mcfisa_a | mcfisa_b | mcfhwdiv | mcfusp:
	      e_flags |= EF_M68K_CF_ISA_B;
	      break;
	    case mcfisa_a | mcfisa_c | mcfhwdiv | mcfusp:
	      e_flags |= EF_M68K_CF_ISA_C;
	      break;
	    case mcfisa_a | mcfisa_c | mcfusp:
	      e_flags |= EF_M68K_CF_ISA_C_NODIV;
	      break;
	    }
	  if (arch_mask & mcfmac)
	    e_flags |= EF_M68K_CF_MAC;
	  else if (arch_mask & mcfemac)
	    e_flags |= EF_M68K_CF_EMAC;
	  if (arch_mask & cfloat)
	    e_flags |= EF_M68K_CF_FLOAT | EF_M68K_CFV4E;
	}
      elf_elfheader (abfd)->e_flags = e_flags;
    }
}

/* Keep m68k-specific flags in the ELF header.  */

static bfd_boolean
elf32_m68k_set_private_flags (bfd *abfd, flagword flags)
{
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */
static bfd_boolean
elf32_m68k_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword out_flags;
  flagword in_flags;
  flagword out_isa;
  flagword in_isa;
  const bfd_arch_info_type *arch_info;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return FALSE;

  /* Get the merged machine.  This checks for incompatibility between
     Coldfire & non-Coldfire flags, incompability between different
     Coldfire ISAs, and incompability between different MAC types.  */
  arch_info = bfd_arch_get_compatible (ibfd, obfd, FALSE);
  if (!arch_info)
    return FALSE;

  bfd_set_arch_mach (obfd, bfd_arch_m68k, arch_info->mach);

  in_flags = elf_elfheader (ibfd)->e_flags;
  if (!elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      out_flags = in_flags;
    }
  else
    {
      out_flags = elf_elfheader (obfd)->e_flags;
      unsigned int variant_mask;

      if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	variant_mask = 0;
      else if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	variant_mask = 0;
      else if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	variant_mask = 0;
      else
	variant_mask = EF_M68K_CF_ISA_MASK;

      in_isa = (in_flags & variant_mask);
      out_isa = (out_flags & variant_mask);
      if (in_isa > out_isa)
	out_flags ^= in_isa ^ out_isa;
      if (((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32
	   && (out_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	  || ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO
	      && (out_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32))
	out_flags = EF_M68K_FIDO;
      else
      out_flags |= in_flags ^ in_isa;
    }
  elf_elfheader (obfd)->e_flags = out_flags;

  return TRUE;
}

/* Display the flags field.  */

static bfd_boolean
elf32_m68k_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE *file = (FILE *) ptr;
  flagword eflags = elf_elfheader (abfd)->e_flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* Ignore init flag - it may not be set, despite the flags field containing valid data.  */

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
    fprintf (file, " [m68000]");
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
    fprintf (file, " [cpu32]");
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
    fprintf (file, " [fido]");
  else
    {
      if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
	fprintf (file, " [cfv4e]");

      if (eflags & EF_M68K_CF_ISA_MASK)
	{
	  char const *isa = _("unknown");
	  char const *mac = _("unknown");
	  char const *additional = "";

	  switch (eflags & EF_M68K_CF_ISA_MASK)
	    {
	    case EF_M68K_CF_ISA_A_NODIV:
	      isa = "A";
	      additional = " [nodiv]";
	      break;
	    case EF_M68K_CF_ISA_A:
	      isa = "A";
	      break;
	    case EF_M68K_CF_ISA_A_PLUS:
	      isa = "A+";
	      break;
	    case EF_M68K_CF_ISA_B_NOUSP:
	      isa = "B";
	      additional = " [nousp]";
	      break;
	    case EF_M68K_CF_ISA_B:
	      isa = "B";
	      break;
	    case EF_M68K_CF_ISA_C:
	      isa = "C";
	      break;
	    case EF_M68K_CF_ISA_C_NODIV:
	      isa = "C";
	      additional = " [nodiv]";
	      break;
	    }
	  fprintf (file, " [isa %s]%s", isa, additional);

	  if (eflags & EF_M68K_CF_FLOAT)
	    fprintf (file, " [float]");

	  switch (eflags & EF_M68K_CF_MAC_MASK)
	    {
	    case 0:
	      mac = NULL;
	      break;
	    case EF_M68K_CF_MAC:
	      mac = "mac";
	      break;
	    case EF_M68K_CF_EMAC:
	      mac = "emac";
	      break;
	    case EF_M68K_CF_EMAC_B:
	      mac = "emac_b";
	      break;
	    }
	  if (mac)
	    fprintf (file, " [%s]", mac);
	}
    }

  fputc ('\n', file);

  return TRUE;
}

/* Multi-GOT support implementation design:

   Multi-GOT starts in check_relocs hook.  There we scan all
   relocations of a BFD and build a local GOT (struct elf_m68k_got)
   for it.  If a single BFD appears to require too many GOT slots with
   R_68K_GOT8O or R_68K_GOT16O relocations, we fail with notification
   to user.
   After check_relocs has been invoked for each input BFD, we have
   constructed a GOT for each input BFD.

   To minimize total number of GOTs required for a particular output BFD
   (as some environments support only 1 GOT per output object) we try
   to merge some of the GOTs to share an offset space.  Ideally [and in most
   cases] we end up with a single GOT.  In cases when there are too many
   restricted relocations (e.g., R_68K_GOT16O relocations) we end up with
   several GOTs, assuming the environment can handle them.

   Partitioning is done in elf_m68k_partition_multi_got.  We start with
   an empty GOT and traverse bfd2got hashtable putting got_entries from
   local GOTs to the new 'big' one.  We do that by constructing an
   intermediate GOT holding all the entries the local GOT has and the big
   GOT lacks.  Then we check if there is room in the big GOT to accomodate
   all the entries from diff.  On success we add those entries to the big
   GOT; on failure we start the new 'big' GOT and retry the adding of
   entries from the local GOT.  Note that this retry will always succeed as
   each local GOT doesn't overflow the limits.  After partitioning we
   end up with each bfd assigned one of the big GOTs.  GOT entries in the
   big GOTs are initialized with GOT offsets.  Note that big GOTs are
   positioned consequently in program space and represent a single huge GOT
   to the outside world.

   After that we get to elf_m68k_relocate_section.  There we
   adjust relocations of GOT pointer (_GLOBAL_OFFSET_TABLE_) and symbol
   relocations to refer to appropriate [assigned to current input_bfd]
   big GOT.

   Notes:

   GOT entry type: We have several types of GOT entries.
   * R_8 type is used in entries for symbols that have at least one
   R_68K_GOT8O or R_68K_TLS_*8 relocation.  We can have at most 0x40
   such entries in one GOT.
   * R_16 type is used in entries for symbols that have at least one
   R_68K_GOT16O or R_68K_TLS_*16 relocation and no R_8 relocations.
   We can have at most 0x4000 such entries in one GOT.
   * R_32 type is used in all other cases.  We can have as many
   such entries in one GOT as we'd like.
   When counting relocations we have to include the count of the smaller
   ranged relocations in the counts of the larger ranged ones in order
   to correctly detect overflow.

   Sorting the GOT: In each GOT starting offsets are assigned to
   R_8 entries, which are followed by R_16 entries, and
   R_32 entries go at the end.  See finalize_got_offsets for details.

   Negative GOT offsets: To double usable offset range of GOTs we use
   negative offsets.  As we assign entries with GOT offsets relative to
   start of .got section, the offset values are positive.  They become
   negative only in relocate_section where got->offset value is
   subtracted from them.

   3 special GOT entries: There are 3 special GOT entries used internally
   by loader.  These entries happen to be placed to .got.plt section,
   so we don't do anything about them in multi-GOT support.

   Memory management: All data except for hashtables
   multi_got->bfd2got and got->entries are allocated on
   elf_hash_table (info)->dynobj bfd (for this reason we pass 'info'
   to most functions), so we don't need to care to free them.  At the
   moment of allocation hashtables are being linked into main data
   structure (multi_got), all pieces of which are reachable from
   elf_m68k_multi_got (info).  We deallocate them in
   elf_m68k_link_hash_table_free.  */

/* Initialize GOT.  */

static void
elf_m68k_init_got (struct elf_m68k_got *got)
{
  got->entries = NULL;
  got->n_slots[R_8] = 0;
  got->n_slots[R_16] = 0;
  got->n_slots[R_32] = 0;
  got->local_n_slots = 0;
  got->offset = (bfd_vma) -1;
}

/* Destruct GOT.  */

static void
elf_m68k_clear_got (struct elf_m68k_got *got)
{
  if (got->entries != NULL)
    {
      htab_delete (got->entries);
      got->entries = NULL;
    }
}

/* Create and empty GOT structure.  INFO is the context where memory
   should be allocated.  */

static struct elf_m68k_got *
elf_m68k_create_empty_got (struct bfd_link_info *info)
{
  struct elf_m68k_got *got;

  got = bfd_alloc (elf_hash_table (info)->dynobj, sizeof (*got));
  if (got == NULL)
    return NULL;

  elf_m68k_init_got (got);

  return got;
}

/* Initialize KEY.  */

static void
elf_m68k_init_got_entry_key (struct elf_m68k_got_entry_key *key,
			     struct elf_link_hash_entry *h,
			     const bfd *abfd, unsigned long symndx,
			     enum elf_m68k_reloc_type reloc_type)
{
  if (elf_m68k_reloc_got_type (reloc_type) == R_68K_TLS_LDM32)
    /* All TLS_LDM relocations share a single GOT entry.  */
    {
      key->bfd = NULL;
      key->symndx = 0;
    }
  else if (h != NULL)
    /* Global symbols are identified with their got_entry_key.  */
    {
      key->bfd = NULL;
      key->symndx = elf_m68k_hash_entry (h)->got_entry_key;
      BFD_ASSERT (key->symndx != 0);
    }
  else
    /* Local symbols are identified by BFD they appear in and symndx.  */
    {
      key->bfd = abfd;
      key->symndx = symndx;
    }

  key->type = reloc_type;
}

/* Calculate hash of got_entry.
   ??? Is it good?  */

static hashval_t
elf_m68k_got_entry_hash (const void *_entry)
{
  const struct elf_m68k_got_entry_key *key;

  key = &((const struct elf_m68k_got_entry *) _entry)->key_;

  return (key->symndx
	  + (key->bfd != NULL ? (int) key->bfd->id : -1)
	  + elf_m68k_reloc_got_type (key->type));
}

/* Check if two got entries are equal.  */

static int
elf_m68k_got_entry_eq (const void *_entry1, const void *_entry2)
{
  const struct elf_m68k_got_entry_key *key1;
  const struct elf_m68k_got_entry_key *key2;

  key1 = &((const struct elf_m68k_got_entry *) _entry1)->key_;
  key2 = &((const struct elf_m68k_got_entry *) _entry2)->key_;

  return (key1->bfd == key2->bfd
	  && key1->symndx == key2->symndx
	  && (elf_m68k_reloc_got_type (key1->type)
	      == elf_m68k_reloc_got_type (key2->type)));
}

/* When using negative offsets, we allocate one extra R_8, one extra R_16
   and one extra R_32 slots to simplify handling of 2-slot entries during
   offset allocation -- hence -1 for R_8 slots and -2 for R_16 slots.  */

/* Maximal number of R_8 slots in a single GOT.  */
#define ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT(INFO)		\
  (elf_m68k_hash_table (INFO)->use_neg_got_offsets_p		\
   ? (0x40 - 1)							\
   : 0x20)

/* Maximal number of R_8 and R_16 slots in a single GOT.  */
#define ELF_M68K_R_8_16_MAX_N_SLOTS_IN_GOT(INFO)		\
  (elf_m68k_hash_table (INFO)->use_neg_got_offsets_p		\
   ? (0x4000 - 2)						\
   : 0x2000)

/* SEARCH - simply search the hashtable, don't insert new entries or fail when
   the entry cannot be found.
   FIND_OR_CREATE - search for an existing entry, but create new if there's
   no such.
   MUST_FIND - search for an existing entry and assert that it exist.
   MUST_CREATE - assert that there's no such entry and create new one.  */
enum elf_m68k_get_entry_howto
  {
    SEARCH,
    FIND_OR_CREATE,
    MUST_FIND,
    MUST_CREATE
  };

/* Get or create (depending on HOWTO) entry with KEY in GOT.
   INFO is context in which memory should be allocated (can be NULL if
   HOWTO is SEARCH or MUST_FIND).  */

static struct elf_m68k_got_entry *
elf_m68k_get_got_entry (struct elf_m68k_got *got,
			const struct elf_m68k_got_entry_key *key,
			enum elf_m68k_get_entry_howto howto,
			struct bfd_link_info *info)
{
  struct elf_m68k_got_entry entry_;
  struct elf_m68k_got_entry *entry;
  void **ptr;

  BFD_ASSERT ((info == NULL) == (howto == SEARCH || howto == MUST_FIND));

  if (got->entries == NULL)
    /* This is the first entry in ABFD.  Initialize hashtable.  */
    {
      if (howto == SEARCH)
	return NULL;

      got->entries = htab_try_create (ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT
				      (info),
				      elf_m68k_got_entry_hash,
				      elf_m68k_got_entry_eq, NULL);
      if (got->entries == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
    }

  entry_.key_ = *key;
  ptr = htab_find_slot (got->entries, &entry_, (howto != SEARCH
						? INSERT : NO_INSERT));
  if (ptr == NULL)
    {
      if (howto == SEARCH)
	/* Entry not found.  */
	return NULL;

      /* We're out of memory.  */
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  if (*ptr == NULL)
    /* We didn't find the entry and we're asked to create a new one.  */
    {
      BFD_ASSERT (howto != MUST_FIND && howto != SEARCH);

      entry = bfd_alloc (elf_hash_table (info)->dynobj, sizeof (*entry));
      if (entry == NULL)
	return NULL;

      /* Initialize new entry.  */
      entry->key_ = *key;

      entry->u.s1.refcount = 0;

      /* Mark the entry as not initialized.  */
      entry->key_.type = R_68K_max;

      *ptr = entry;
    }
  else
    /* We found the entry.  */
    {
      BFD_ASSERT (howto != MUST_CREATE);

      entry = *ptr;
    }

  return entry;
}

/* Update GOT counters when merging entry of WAS type with entry of NEW type.
   Return the value to which ENTRY's type should be set.  */

static enum elf_m68k_reloc_type
elf_m68k_update_got_entry_type (struct elf_m68k_got *got,
				enum elf_m68k_reloc_type was,
				enum elf_m68k_reloc_type new_reloc)
{
  enum elf_m68k_got_offset_size was_size;
  enum elf_m68k_got_offset_size new_size;
  bfd_vma n_slots;

  if (was == R_68K_max)
    /* The type of the entry is not initialized yet.  */
    {
      /* Update all got->n_slots counters, including n_slots[R_32].  */
      was_size = R_LAST;

      was = new_reloc;
    }
  else
    {
      /* !!! We, probably, should emit an error rather then fail on assert
	 in such a case.  */
      BFD_ASSERT (elf_m68k_reloc_got_type (was)
		  == elf_m68k_reloc_got_type (new_reloc));

      was_size = elf_m68k_reloc_got_offset_size (was);
    }

  new_size = elf_m68k_reloc_got_offset_size (new_reloc);
  n_slots = elf_m68k_reloc_got_n_slots (new_reloc);

  while (was_size > new_size)
    {
      --was_size;
      got->n_slots[was_size] += n_slots;
    }

  if (new_reloc > was)
    /* Relocations are ordered from bigger got offset size to lesser,
       so choose the relocation type with lesser offset size.  */
    was = new_reloc;

  return was;
}

/* Update GOT counters when removing an entry of type TYPE.  */

static void
elf_m68k_remove_got_entry_type (struct elf_m68k_got *got,
				enum elf_m68k_reloc_type type)
{
  enum elf_m68k_got_offset_size os;
  bfd_vma n_slots;

  n_slots = elf_m68k_reloc_got_n_slots (type);

  /* Decrese counter of slots with offset size corresponding to TYPE
     and all greater offset sizes.  */
  for (os = elf_m68k_reloc_got_offset_size (type); os <= R_32; ++os)
    {
      BFD_ASSERT (got->n_slots[os] >= n_slots);

      got->n_slots[os] -= n_slots;
    }
}

/* Add new or update existing entry to GOT.
   H, ABFD, TYPE and SYMNDX is data for the entry.
   INFO is a context where memory should be allocated.  */

static struct elf_m68k_got_entry *
elf_m68k_add_entry_to_got (struct elf_m68k_got *got,
			   struct elf_link_hash_entry *h,
			   const bfd *abfd,
			   enum elf_m68k_reloc_type reloc_type,
			   unsigned long symndx,
			   struct bfd_link_info *info)
{
  struct elf_m68k_got_entry_key key_;
  struct elf_m68k_got_entry *entry;

  if (h != NULL && elf_m68k_hash_entry (h)->got_entry_key == 0)
    elf_m68k_hash_entry (h)->got_entry_key
      = elf_m68k_multi_got (info)->global_symndx++;

  elf_m68k_init_got_entry_key (&key_, h, abfd, symndx, reloc_type);

  entry = elf_m68k_get_got_entry (got, &key_, FIND_OR_CREATE, info);
  if (entry == NULL)
    return NULL;

  /* Determine entry's type and update got->n_slots counters.  */
  entry->key_.type = elf_m68k_update_got_entry_type (got,
						     entry->key_.type,
						     reloc_type);

  /* Update refcount.  */
  ++entry->u.s1.refcount;

  if (entry->u.s1.refcount == 1)
    /* We see this entry for the first time.  */
    {
      if (entry->key_.bfd != NULL)
	got->local_n_slots += elf_m68k_reloc_got_n_slots (entry->key_.type);
    }

  BFD_ASSERT (got->n_slots[R_32] >= got->local_n_slots);

  if ((got->n_slots[R_8]
       > ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info))
      || (got->n_slots[R_16]
	  > ELF_M68K_R_8_16_MAX_N_SLOTS_IN_GOT (info)))
    /* This BFD has too many relocation.  */
    {
      if (got->n_slots[R_8] > ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info))
	(*_bfd_error_handler) (_("%B: GOT overflow: "
				 "Number of relocations with 8-bit "
				 "offset > %d"),
			       abfd,
			       ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info));
      else
	(*_bfd_error_handler) (_("%B: GOT overflow: "
				 "Number of relocations with 8- or 16-bit "
				 "offset > %d"),
			       abfd,
			       ELF_M68K_R_8_16_MAX_N_SLOTS_IN_GOT (info));

      return NULL;
    }

  return entry;
}

/* Compute the hash value of the bfd in a bfd2got hash entry.  */

static hashval_t
elf_m68k_bfd2got_entry_hash (const void *entry)
{
  const struct elf_m68k_bfd2got_entry *e;

  e = (const struct elf_m68k_bfd2got_entry *) entry;

  return e->bfd->id;
}

/* Check whether two hash entries have the same bfd.  */

static int
elf_m68k_bfd2got_entry_eq (const void *entry1, const void *entry2)
{
  const struct elf_m68k_bfd2got_entry *e1;
  const struct elf_m68k_bfd2got_entry *e2;

  e1 = (const struct elf_m68k_bfd2got_entry *) entry1;
  e2 = (const struct elf_m68k_bfd2got_entry *) entry2;

  return e1->bfd == e2->bfd;
}

/* Destruct a bfd2got entry.  */

static void
elf_m68k_bfd2got_entry_del (void *_entry)
{
  struct elf_m68k_bfd2got_entry *entry;

  entry = (struct elf_m68k_bfd2got_entry *) _entry;

  BFD_ASSERT (entry->got != NULL);
  elf_m68k_clear_got (entry->got);
}

/* Find existing or create new (depending on HOWTO) bfd2got entry in
   MULTI_GOT.  ABFD is the bfd we need a GOT for.  INFO is a context where
   memory should be allocated.  */

static struct elf_m68k_bfd2got_entry *
elf_m68k_get_bfd2got_entry (struct elf_m68k_multi_got *multi_got,
			    const bfd *abfd,
			    enum elf_m68k_get_entry_howto howto,
			    struct bfd_link_info *info)
{
  struct elf_m68k_bfd2got_entry entry_;
  void **ptr;
  struct elf_m68k_bfd2got_entry *entry;

  BFD_ASSERT ((info == NULL) == (howto == SEARCH || howto == MUST_FIND));

  if (multi_got->bfd2got == NULL)
    /* This is the first GOT.  Initialize bfd2got.  */
    {
      if (howto == SEARCH)
	return NULL;

      multi_got->bfd2got = htab_try_create (1, elf_m68k_bfd2got_entry_hash,
					    elf_m68k_bfd2got_entry_eq,
					    elf_m68k_bfd2got_entry_del);
      if (multi_got->bfd2got == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
    }

  entry_.bfd = abfd;
  ptr = htab_find_slot (multi_got->bfd2got, &entry_, (howto != SEARCH
						      ? INSERT : NO_INSERT));
  if (ptr == NULL)
    {
      if (howto == SEARCH)
	/* Entry not found.  */
	return NULL;

      /* We're out of memory.  */
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  if (*ptr == NULL)
    /* Entry was not found.  Create new one.  */
    {
      BFD_ASSERT (howto != MUST_FIND && howto != SEARCH);

      entry = ((struct elf_m68k_bfd2got_entry *)
	       bfd_alloc (elf_hash_table (info)->dynobj, sizeof (*entry)));
      if (entry == NULL)
	return NULL;

      entry->bfd = abfd;

      entry->got = elf_m68k_create_empty_got (info);
      if (entry->got == NULL)
	return NULL;

      *ptr = entry;
    }
  else
    {
      BFD_ASSERT (howto != MUST_CREATE);

      /* Return existing entry.  */
      entry = *ptr;
    }

  return entry;
}

struct elf_m68k_can_merge_gots_arg
{
  /* A current_got that we constructing a DIFF against.  */
  struct elf_m68k_got *big;

  /* GOT holding entries not present or that should be changed in
     BIG.  */
  struct elf_m68k_got *diff;

  /* Context where to allocate memory.  */
  struct bfd_link_info *info;

  /* Error flag.  */
  bfd_boolean error_p;
};

/* Process a single entry from the small GOT to see if it should be added
   or updated in the big GOT.  */

static int
elf_m68k_can_merge_gots_1 (void **_entry_ptr, void *_arg)
{
  const struct elf_m68k_got_entry *entry1;
  struct elf_m68k_can_merge_gots_arg *arg;
  const struct elf_m68k_got_entry *entry2;
  enum elf_m68k_reloc_type type;

  entry1 = (const struct elf_m68k_got_entry *) *_entry_ptr;
  arg = (struct elf_m68k_can_merge_gots_arg *) _arg;

  entry2 = elf_m68k_get_got_entry (arg->big, &entry1->key_, SEARCH, NULL);

  if (entry2 != NULL)
    /* We found an existing entry.  Check if we should update it.  */
    {
      type = elf_m68k_update_got_entry_type (arg->diff,
					     entry2->key_.type,
					     entry1->key_.type);

      if (type == entry2->key_.type)
	/* ENTRY1 doesn't update data in ENTRY2.  Skip it.
	   To skip creation of difference entry we use the type,
	   which we won't see in GOT entries for sure.  */
	type = R_68K_max;
    }
  else
    /* We didn't find the entry.  Add entry1 to DIFF.  */
    {
      BFD_ASSERT (entry1->key_.type != R_68K_max);

      type = elf_m68k_update_got_entry_type (arg->diff,
					     R_68K_max, entry1->key_.type);

      if (entry1->key_.bfd != NULL)
	arg->diff->local_n_slots += elf_m68k_reloc_got_n_slots (type);
    }

  if (type != R_68K_max)
    /* Create an entry in DIFF.  */
    {
      struct elf_m68k_got_entry *entry;

      entry = elf_m68k_get_got_entry (arg->diff, &entry1->key_, MUST_CREATE,
				      arg->info);
      if (entry == NULL)
	{
	  arg->error_p = TRUE;
	  return 0;
	}

      entry->key_.type = type;
    }

  return 1;
}

/* Return TRUE if SMALL GOT can be added to BIG GOT without overflowing it.
   Construct DIFF GOT holding the entries which should be added or updated
   in BIG GOT to accumulate information from SMALL.
   INFO is the context where memory should be allocated.  */

static bfd_boolean
elf_m68k_can_merge_gots (struct elf_m68k_got *big,
			 const struct elf_m68k_got *small,
			 struct bfd_link_info *info,
			 struct elf_m68k_got *diff)
{
  struct elf_m68k_can_merge_gots_arg arg_;

  BFD_ASSERT (small->offset == (bfd_vma) -1);

  arg_.big = big;
  arg_.diff = diff;
  arg_.info = info;
  arg_.error_p = FALSE;
  htab_traverse_noresize (small->entries, elf_m68k_can_merge_gots_1, &arg_);
  if (arg_.error_p)
    {
      diff->offset = 0;
      return FALSE;
    }

  /* Check for overflow.  */
  if ((big->n_slots[R_8] + arg_.diff->n_slots[R_8]
       > ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info))
      || (big->n_slots[R_16] + arg_.diff->n_slots[R_16]
	  > ELF_M68K_R_8_16_MAX_N_SLOTS_IN_GOT (info)))
    return FALSE;

  return TRUE;
}

struct elf_m68k_merge_gots_arg
{
  /* The BIG got.  */
  struct elf_m68k_got *big;

  /* Context where memory should be allocated.  */
  struct bfd_link_info *info;

  /* Error flag.  */
  bfd_boolean error_p;
};

/* Process a single entry from DIFF got.  Add or update corresponding
   entry in the BIG got.  */

static int
elf_m68k_merge_gots_1 (void **entry_ptr, void *_arg)
{
  const struct elf_m68k_got_entry *from;
  struct elf_m68k_merge_gots_arg *arg;
  struct elf_m68k_got_entry *to;

  from = (const struct elf_m68k_got_entry *) *entry_ptr;
  arg = (struct elf_m68k_merge_gots_arg *) _arg;

  to = elf_m68k_get_got_entry (arg->big, &from->key_, FIND_OR_CREATE,
			       arg->info);
  if (to == NULL)
    {
      arg->error_p = TRUE;
      return 0;
    }

  BFD_ASSERT (to->u.s1.refcount == 0);
  /* All we need to merge is TYPE.  */
  to->key_.type = from->key_.type;

  return 1;
}

/* Merge data from DIFF to BIG.  INFO is context where memory should be
   allocated.  */

static bfd_boolean
elf_m68k_merge_gots (struct elf_m68k_got *big,
		     struct elf_m68k_got *diff,
		     struct bfd_link_info *info)
{
  if (diff->entries != NULL)
    /* DIFF is not empty.  Merge it into BIG GOT.  */
    {
      struct elf_m68k_merge_gots_arg arg_;

      /* Merge entries.  */
      arg_.big = big;
      arg_.info = info;
      arg_.error_p = FALSE;
      htab_traverse_noresize (diff->entries, elf_m68k_merge_gots_1, &arg_);
      if (arg_.error_p)
	return FALSE;

      /* Merge counters.  */
      big->n_slots[R_8] += diff->n_slots[R_8];
      big->n_slots[R_16] += diff->n_slots[R_16];
      big->n_slots[R_32] += diff->n_slots[R_32];
      big->local_n_slots += diff->local_n_slots;
    }
  else
    /* DIFF is empty.  */
    {
      BFD_ASSERT (diff->n_slots[R_8] == 0);
      BFD_ASSERT (diff->n_slots[R_16] == 0);
      BFD_ASSERT (diff->n_slots[R_32] == 0);
      BFD_ASSERT (diff->local_n_slots == 0);
    }

  BFD_ASSERT (!elf_m68k_hash_table (info)->allow_multigot_p
	      || ((big->n_slots[R_8]
		   <= ELF_M68K_R_8_MAX_N_SLOTS_IN_GOT (info))
		  && (big->n_slots[R_16]
		      <= ELF_M68K_R_8_16_MAX_N_SLOTS_IN_GOT (info))));

  return TRUE;
}

struct elf_m68k_finalize_got_offsets_arg
{
  /* Ranges of the offsets for GOT entries.
     R_x entries receive offsets between offset1[R_x] and offset2[R_x].
     R_x is R_8, R_16 and R_32.  */
  bfd_vma *offset1;
  bfd_vma *offset2;

  /* Mapping from global symndx to global symbols.
     This is used to build lists of got entries for global symbols.  */
  struct elf_m68k_link_hash_entry **symndx2h;

  bfd_vma n_ldm_entries;
};

/* Assign ENTRY an offset.  Build list of GOT entries for global symbols
   along the way.  */

static int
elf_m68k_finalize_got_offsets_1 (void **entry_ptr, void *_arg)
{
  struct elf_m68k_got_entry *entry;
  struct elf_m68k_finalize_got_offsets_arg *arg;

  enum elf_m68k_got_offset_size got_offset_size;
  bfd_vma entry_size;

  entry = (struct elf_m68k_got_entry *) *entry_ptr;
  arg = (struct elf_m68k_finalize_got_offsets_arg *) _arg;

  /* This should be a fresh entry created in elf_m68k_can_merge_gots.  */
  BFD_ASSERT (entry->u.s1.refcount == 0);

  /* Get GOT offset size for the entry .  */
  got_offset_size = elf_m68k_reloc_got_offset_size (entry->key_.type);

  /* Calculate entry size in bytes.  */
  entry_size = 4 * elf_m68k_reloc_got_n_slots (entry->key_.type);

  /* Check if we should switch to negative range of the offsets. */
  if (arg->offset1[got_offset_size] + entry_size
      > arg->offset2[got_offset_size])
    {
      /* Verify that this is the only switch to negative range for
	 got_offset_size.  If this assertion fails, then we've miscalculated
	 range for got_offset_size entries in
	 elf_m68k_finalize_got_offsets.  */
      BFD_ASSERT (arg->offset2[got_offset_size]
		  != arg->offset2[-(int) got_offset_size - 1]);

      /* Switch.  */
      arg->offset1[got_offset_size] = arg->offset1[-(int) got_offset_size - 1];
      arg->offset2[got_offset_size] = arg->offset2[-(int) got_offset_size - 1];

      /* Verify that now we have enough room for the entry.  */
      BFD_ASSERT (arg->offset1[got_offset_size] + entry_size
		  <= arg->offset2[got_offset_size]);
    }

  /* Assign offset to entry.  */
  entry->u.s2.offset = arg->offset1[got_offset_size];
  arg->offset1[got_offset_size] += entry_size;

  if (entry->key_.bfd == NULL)
    /* Hook up this entry into the list of got_entries of H.  */
    {
      struct elf_m68k_link_hash_entry *h;

      h = arg->symndx2h[entry->key_.symndx];
      if (h != NULL)
	{
	  entry->u.s2.next = h->glist;
	  h->glist = entry;
	}
      else
	/* This should be the entry for TLS_LDM relocation then.  */
	{
	  BFD_ASSERT ((elf_m68k_reloc_got_type (entry->key_.type)
		       == R_68K_TLS_LDM32)
		      && entry->key_.symndx == 0);

	  ++arg->n_ldm_entries;
	}
    }
  else
    /* This entry is for local symbol.  */
    entry->u.s2.next = NULL;

  return 1;
}

/* Assign offsets within GOT.  USE_NEG_GOT_OFFSETS_P indicates if we
   should use negative offsets.
   Build list of GOT entries for global symbols along the way.
   SYMNDX2H is mapping from global symbol indices to actual
   global symbols.
   Return offset at which next GOT should start.  */

static void
elf_m68k_finalize_got_offsets (struct elf_m68k_got *got,
			       bfd_boolean use_neg_got_offsets_p,
			       struct elf_m68k_link_hash_entry **symndx2h,
			       bfd_vma *final_offset, bfd_vma *n_ldm_entries)
{
  struct elf_m68k_finalize_got_offsets_arg arg_;
  bfd_vma offset1_[2 * R_LAST];
  bfd_vma offset2_[2 * R_LAST];
  int i;
  bfd_vma start_offset;

  BFD_ASSERT (got->offset != (bfd_vma) -1);

  /* We set entry offsets relative to the .got section (and not the
     start of a particular GOT), so that we can use them in
     finish_dynamic_symbol without needing to know the GOT which they come
     from.  */

  /* Put offset1 in the middle of offset1_, same for offset2.  */
  arg_.offset1 = offset1_ + R_LAST;
  arg_.offset2 = offset2_ + R_LAST;

  start_offset = got->offset;

  if (use_neg_got_offsets_p)
    /* Setup both negative and positive ranges for R_8, R_16 and R_32.  */
    i = -(int) R_32 - 1;
  else
    /* Setup positives ranges for R_8, R_16 and R_32.  */
    i = (int) R_8;

  for (; i <= (int) R_32; ++i)
    {
      int j;
      size_t n;

      /* Set beginning of the range of offsets I.  */
      arg_.offset1[i] = start_offset;

      /* Calculate number of slots that require I offsets.  */
      j = (i >= 0) ? i : -i - 1;
      n = (j >= 1) ? got->n_slots[j - 1] : 0;
      n = got->n_slots[j] - n;

      if (use_neg_got_offsets_p && n != 0)
	{
	  if (i < 0)
	    /* We first fill the positive side of the range, so we might
	       end up with one empty slot at that side when we can't fit
	       whole 2-slot entry.  Account for that at negative side of
	       the interval with one additional entry.  */
	    n = n / 2 + 1;
	  else
	    /* When the number of slots is odd, make positive side of the
	       range one entry bigger.  */
	    n = (n + 1) / 2;
	}

      /* N is the number of slots that require I offsets.
	 Calculate length of the range for I offsets.  */
      n = 4 * n;

      /* Set end of the range.  */
      arg_.offset2[i] = start_offset + n;

      start_offset = arg_.offset2[i];
    }

  if (!use_neg_got_offsets_p)
    /* Make sure that if we try to switch to negative offsets in
       elf_m68k_finalize_got_offsets_1, the assert therein will catch
       the bug.  */
    for (i = R_8; i <= R_32; ++i)
      arg_.offset2[-i - 1] = arg_.offset2[i];

  /* Setup got->offset.  offset1[R_8] is either in the middle or at the
     beginning of GOT depending on use_neg_got_offsets_p.  */
  got->offset = arg_.offset1[R_8];

  arg_.symndx2h = symndx2h;
  arg_.n_ldm_entries = 0;

  /* Assign offsets.  */
  htab_traverse (got->entries, elf_m68k_finalize_got_offsets_1, &arg_);

  /* Check offset ranges we have actually assigned.  */
  for (i = (int) R_8; i <= (int) R_32; ++i)
    BFD_ASSERT (arg_.offset2[i] - arg_.offset1[i] <= 4);

  *final_offset = start_offset;
  *n_ldm_entries = arg_.n_ldm_entries;
}

struct elf_m68k_partition_multi_got_arg
{
  /* The GOT we are adding entries to.  Aka big got.  */
  struct elf_m68k_got *current_got;

  /* Offset to assign the next CURRENT_GOT.  */
  bfd_vma offset;

  /* Context where memory should be allocated.  */
  struct bfd_link_info *info;

  /* Total number of slots in the .got section.
     This is used to calculate size of the .got and .rela.got sections.  */
  bfd_vma n_slots;

  /* Difference in numbers of allocated slots in the .got section
     and necessary relocations in the .rela.got section.
     This is used to calculate size of the .rela.got section.  */
  bfd_vma slots_relas_diff;

  /* Error flag.  */
  bfd_boolean error_p;

  /* Mapping from global symndx to global symbols.
     This is used to build lists of got entries for global symbols.  */
  struct elf_m68k_link_hash_entry **symndx2h;
};

static void
elf_m68k_partition_multi_got_2 (struct elf_m68k_partition_multi_got_arg *arg)
{
  bfd_vma n_ldm_entries;

  elf_m68k_finalize_got_offsets (arg->current_got,
				 (elf_m68k_hash_table (arg->info)
				  ->use_neg_got_offsets_p),
				 arg->symndx2h,
				 &arg->offset, &n_ldm_entries);

  arg->n_slots += arg->current_got->n_slots[R_32];

  if (!arg->info->shared)
    /* If we are generating a shared object, we need to
       output a R_68K_RELATIVE reloc so that the dynamic
       linker can adjust this GOT entry.  Overwise we
       don't need space in .rela.got for local symbols.  */
    arg->slots_relas_diff += arg->current_got->local_n_slots;

  /* @@LDM relocations require a 2-slot GOT entry, but only
     one relocation.  Account for that.  */
  arg->slots_relas_diff += n_ldm_entries;

  BFD_ASSERT (arg->slots_relas_diff <= arg->n_slots);
}


/* Process a single BFD2GOT entry and either merge GOT to CURRENT_GOT
   or start a new CURRENT_GOT.  */

static int
elf_m68k_partition_multi_got_1 (void **_entry, void *_arg)
{
  struct elf_m68k_bfd2got_entry *entry;
  struct elf_m68k_partition_multi_got_arg *arg;
  struct elf_m68k_got *got;
  struct elf_m68k_got diff_;
  struct elf_m68k_got *diff;

  entry = (struct elf_m68k_bfd2got_entry *) *_entry;
  arg = (struct elf_m68k_partition_multi_got_arg *) _arg;

  got = entry->got;
  BFD_ASSERT (got != NULL);
  BFD_ASSERT (got->offset == (bfd_vma) -1);

  diff = NULL;

  if (arg->current_got != NULL)
    /* Construct diff.  */
    {
      diff = &diff_;
      elf_m68k_init_got (diff);

      if (!elf_m68k_can_merge_gots (arg->current_got, got, arg->info, diff))
	{
	  if (diff->offset == 0)
	    /* Offset set to 0 in the diff_ indicates an error.  */
	    {
	      arg->error_p = TRUE;
	      goto final_return;
	    }

	  if (elf_m68k_hash_table (arg->info)->allow_multigot_p)
	    {
	      elf_m68k_clear_got (diff);
	      /* Schedule to finish up current_got and start new one.  */
	      diff = NULL;
	    }
	  /* else
	     Merge GOTs no matter what.  If big GOT overflows,
	     we'll fail in relocate_section due to truncated relocations.

	     ??? May be fail earlier?  E.g., in can_merge_gots.  */
	}
    }
  else
    /* Diff of got against empty current_got is got itself.  */
    {
      /* Create empty current_got to put subsequent GOTs to.  */
      arg->current_got = elf_m68k_create_empty_got (arg->info);
      if (arg->current_got == NULL)
	{
	  arg->error_p = TRUE;
	  goto final_return;
	}

      arg->current_got->offset = arg->offset;

      diff = got;
    }

  if (diff != NULL)
    {
      if (!elf_m68k_merge_gots (arg->current_got, diff, arg->info))
	{
	  arg->error_p = TRUE;
	  goto final_return;
	}

      /* Now we can free GOT.  */
      elf_m68k_clear_got (got);

      entry->got = arg->current_got;
    }
  else
    {
      /* Finish up current_got.  */
      elf_m68k_partition_multi_got_2 (arg);

      /* Schedule to start a new current_got.  */
      arg->current_got = NULL;

      /* Retry.  */
      if (!elf_m68k_partition_multi_got_1 (_entry, _arg))
	{
	  BFD_ASSERT (arg->error_p);
	  goto final_return;
	}
    }

 final_return:
  if (diff != NULL)
    elf_m68k_clear_got (diff);

  return arg->error_p == FALSE ? 1 : 0;
}

/* Helper function to build symndx2h mapping.  */

static bfd_boolean
elf_m68k_init_symndx2h_1 (struct elf_link_hash_entry *_h,
			  void *_arg)
{
  struct elf_m68k_link_hash_entry *h;

  h = elf_m68k_hash_entry (_h);

  if (h->got_entry_key != 0)
    /* H has at least one entry in the GOT.  */
    {
      struct elf_m68k_partition_multi_got_arg *arg;

      arg = (struct elf_m68k_partition_multi_got_arg *) _arg;

      BFD_ASSERT (arg->symndx2h[h->got_entry_key] == NULL);
      arg->symndx2h[h->got_entry_key] = h;
    }

  return TRUE;
}

/* Merge GOTs of some BFDs, assign offsets to GOT entries and build
   lists of GOT entries for global symbols.
   Calculate sizes of .got and .rela.got sections.  */

static bfd_boolean
elf_m68k_partition_multi_got (struct bfd_link_info *info)
{
  struct elf_m68k_multi_got *multi_got;
  struct elf_m68k_partition_multi_got_arg arg_;

  multi_got = elf_m68k_multi_got (info);

  arg_.current_got = NULL;
  arg_.offset = 0;
  arg_.info = info;
  arg_.n_slots = 0;
  arg_.slots_relas_diff = 0;
  arg_.error_p = FALSE;

  if (multi_got->bfd2got != NULL)
    {
      /* Initialize symndx2h mapping.  */
      {
	arg_.symndx2h = bfd_zmalloc (multi_got->global_symndx
				     * sizeof (*arg_.symndx2h));
	if (arg_.symndx2h == NULL)
	  return FALSE;

	elf_link_hash_traverse (elf_hash_table (info),
				elf_m68k_init_symndx2h_1, &arg_);
      }

      /* Partition.  */
      htab_traverse (multi_got->bfd2got, elf_m68k_partition_multi_got_1,
		     &arg_);
      if (arg_.error_p)
	{
	  free (arg_.symndx2h);
	  arg_.symndx2h = NULL;

	  return FALSE;
	}

      /* Finish up last current_got.  */
      elf_m68k_partition_multi_got_2 (&arg_);

      free (arg_.symndx2h);
    }

  if (elf_hash_table (info)->dynobj != NULL)
    /* Set sizes of .got and .rela.got sections.  */
    {
      asection *s;

      s = bfd_get_linker_section (elf_hash_table (info)->dynobj, ".got");
      if (s != NULL)
	s->size = arg_.offset;
      else
	BFD_ASSERT (arg_.offset == 0);

      BFD_ASSERT (arg_.slots_relas_diff <= arg_.n_slots);
      arg_.n_slots -= arg_.slots_relas_diff;

      s = bfd_get_linker_section (elf_hash_table (info)->dynobj, ".rela.got");
      if (s != NULL)
	s->size = arg_.n_slots * sizeof (Elf32_External_Rela);
      else
	BFD_ASSERT (arg_.n_slots == 0);
    }
  else
    BFD_ASSERT (multi_got->bfd2got == NULL);

  return TRUE;
}

/* Specialized version of elf_m68k_get_got_entry that returns pointer
   to hashtable slot, thus allowing removal of entry via
   elf_m68k_remove_got_entry.  */

static struct elf_m68k_got_entry **
elf_m68k_find_got_entry_ptr (struct elf_m68k_got *got,
			     struct elf_m68k_got_entry_key *key)
{
  void **ptr;
  struct elf_m68k_got_entry entry_;
  struct elf_m68k_got_entry **entry_ptr;

  entry_.key_ = *key;
  ptr = htab_find_slot (got->entries, &entry_, NO_INSERT);
  BFD_ASSERT (ptr != NULL);

  entry_ptr = (struct elf_m68k_got_entry **) ptr;

  return entry_ptr;
}

/* Remove entry pointed to by ENTRY_PTR from GOT.  */

static void
elf_m68k_remove_got_entry (struct elf_m68k_got *got,
			   struct elf_m68k_got_entry **entry_ptr)
{
  struct elf_m68k_got_entry *entry;

  entry = *entry_ptr;

  /* Check that offsets have not been finalized yet.  */
  BFD_ASSERT (got->offset == (bfd_vma) -1);
  /* Check that this entry is indeed unused.  */
  BFD_ASSERT (entry->u.s1.refcount == 0);

  elf_m68k_remove_got_entry_type (got, entry->key_.type);

  if (entry->key_.bfd != NULL)
    got->local_n_slots -= elf_m68k_reloc_got_n_slots (entry->key_.type);

  BFD_ASSERT (got->n_slots[R_32] >= got->local_n_slots);

  htab_clear_slot (got->entries, (void **) entry_ptr);
}

/* Copy any information related to dynamic linking from a pre-existing
   symbol to a newly created symbol.  Also called to copy flags and
   other back-end info to a weakdef, in which case the symbol is not
   newly created and plt/got refcounts and dynamic indices should not
   be copied.  */

static void
elf_m68k_copy_indirect_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *_dir,
			       struct elf_link_hash_entry *_ind)
{
  struct elf_m68k_link_hash_entry *dir;
  struct elf_m68k_link_hash_entry *ind;

  _bfd_elf_link_hash_copy_indirect (info, _dir, _ind);

  if (_ind->root.type != bfd_link_hash_indirect)
    return;

  dir = elf_m68k_hash_entry (_dir);
  ind = elf_m68k_hash_entry (_ind);

  /* Any absolute non-dynamic relocations against an indirect or weak
     definition will be against the target symbol.  */
  _dir->non_got_ref |= _ind->non_got_ref;

  /* We might have a direct symbol already having entries in the GOTs.
     Update its key only in case indirect symbol has GOT entries and
     assert that both indirect and direct symbols don't have GOT entries
     at the same time.  */
  if (ind->got_entry_key != 0)
    {
      BFD_ASSERT (dir->got_entry_key == 0);
      /* Assert that GOTs aren't partioned yet.  */
      BFD_ASSERT (ind->glist == NULL);

      dir->got_entry_key = ind->got_entry_key;
      ind->got_entry_key = 0;
    }
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
elf_m68k_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;
  struct elf_m68k_got *got;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  got = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_68K_GOT8:
	case R_68K_GOT16:
	case R_68K_GOT32:
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */

	  /* Relative GOT relocations.  */
	case R_68K_GOT8O:
	case R_68K_GOT16O:
	case R_68K_GOT32O:
	  /* Fall through.  */

	  /* TLS relocations.  */
	case R_68K_TLS_GD8:
	case R_68K_TLS_GD16:
	case R_68K_TLS_GD32:
	case R_68K_TLS_LDM8:
	case R_68K_TLS_LDM16:
	case R_68K_TLS_LDM32:
	case R_68K_TLS_IE8:
	case R_68K_TLS_IE16:
	case R_68K_TLS_IE32:

	case R_68K_TLS_TPREL32:
	case R_68K_TLS_DTPREL32:

	  if (ELF32_R_TYPE (rel->r_info) == R_68K_TLS_TPREL32
	      && info->shared)
	    /* Do the special chorus for libraries with static TLS.  */
	    info->flags |= DF_STATIC_TLS;

	  /* This symbol requires a global offset table entry.  */

	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_linker_section (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY);
		  srelgot = bfd_make_section_anyway_with_flags (dynobj,
								".rela.got",
								flags);
		  if (srelgot == NULL
		      || !bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (got == NULL)
	    {
	      struct elf_m68k_bfd2got_entry *bfd2got_entry;

	      bfd2got_entry
		= elf_m68k_get_bfd2got_entry (elf_m68k_multi_got (info),
					      abfd, FIND_OR_CREATE, info);
	      if (bfd2got_entry == NULL)
		return FALSE;

	      got = bfd2got_entry->got;
	      BFD_ASSERT (got != NULL);
	    }

	  {
	    struct elf_m68k_got_entry *got_entry;

	    /* Add entry to got.  */
	    got_entry = elf_m68k_add_entry_to_got (got, h, abfd,
						   ELF32_R_TYPE (rel->r_info),
						   r_symndx, info);
	    if (got_entry == NULL)
	      return FALSE;

	    if (got_entry->u.s1.refcount == 1)
	      {
		/* Make sure this symbol is output as a dynamic symbol.  */
		if (h != NULL
		    && h->dynindx == -1
		    && !h->forced_local)
		  {
		    if (!bfd_elf_link_record_dynamic_symbol (info, h))
		      return FALSE;
		  }
	      }
	  }

	  break;

	case R_68K_PLT8:
	case R_68K_PLT16:
	case R_68K_PLT32:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h == NULL)
	    continue;

	  h->needs_plt = 1;
	  h->plt.refcount++;
	  break;

	case R_68K_PLT8O:
	case R_68K_PLT16O:
	case R_68K_PLT32O:
	  /* This symbol requires a procedure linkage table entry.  */

	  if (h == NULL)
	    {
	      /* It does not make sense to have this relocation for a
		 local symbol.  FIXME: does it?  How to handle it if
		 it does make sense?  */
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (!bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  h->needs_plt = 1;
	  h->plt.refcount++;
	  break;

	case R_68K_PC8:
	case R_68K_PC16:
	case R_68K_PC32:
	  /* If we are creating a shared library and this is not a local
	     symbol, we need to copy the reloc into the shared library.
	     However when linking with -Bsymbolic and this is a global
	     symbol which is defined in an object we are including in the
	     link (i.e., DEF_REGULAR is set), then we can resolve the
	     reloc directly.  At this point we have not seen all the input
	     files, so it is possible that DEF_REGULAR is not set now but
	     will be set later (it is never cleared).  We account for that
	     possibility below by storing information in the
	     pcrel_relocs_copied field of the hash table entry.  */
	  if (!(info->shared
		&& (sec->flags & SEC_ALLOC) != 0
		&& h != NULL
		&& (!info->symbolic
		    || h->root.type == bfd_link_hash_defweak
		    || !h->def_regular)))
	    {
	      if (h != NULL)
		{
		  /* Make sure a plt entry is created for this symbol if
		     it turns out to be a function defined by a dynamic
		     object.  */
		  h->plt.refcount++;
		}
	      break;
	    }
	  /* Fall through.  */
	case R_68K_8:
	case R_68K_16:
	case R_68K_32:
	  /* We don't need to handle relocs into sections not going into
	     the "real" output.  */
	  if ((sec->flags & SEC_ALLOC) == 0)
	      break;

	  if (h != NULL)
	    {
	      /* Make sure a plt entry is created for this symbol if it
		 turns out to be a function defined by a dynamic object.  */
	      h->plt.refcount++;

	      if (info->executable)
		/* This symbol needs a non-GOT reference.  */
		h->non_got_ref = 1;
	    }

	  /* If we are creating a shared library, we need to copy the
	     reloc into the shared library.  */
	  if (info->shared)
	    {
	      /* When creating a shared object, we must copy these
		 reloc types into the output file.  We create a reloc
		 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      if (sec->flags & SEC_READONLY
		  /* Don't set DF_TEXTREL yet for PC relative
		     relocations, they might be discarded later.  */
		  && !(ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC32))
		    info->flags |= DF_TEXTREL;

	      sreloc->size += sizeof (Elf32_External_Rela);

	      /* We count the number of PC relative relocations we have
		 entered for this symbol, so that we can discard them
		 again if, in the -Bsymbolic case, the symbol is later
		 defined by a regular object, or, in the normal shared
		 case, the symbol is forced to be local.  Note that this
		 function is only called if we are using an m68kelf linker
		 hash table, which means that h is really a pointer to an
		 elf_m68k_link_hash_entry.  */
	      if (ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC32)
		{
		  struct elf_m68k_pcrel_relocs_copied *p;
		  struct elf_m68k_pcrel_relocs_copied **head;

		  if (h != NULL)
		    {
		      struct elf_m68k_link_hash_entry *eh
			= elf_m68k_hash_entry (h);
		      head = &eh->pcrel_relocs_copied;
		    }
		  else
		    {
		      asection *s;
		      void *vpp;
		      Elf_Internal_Sym *isym;

		      isym = bfd_sym_from_r_symndx (&elf_m68k_hash_table (info)->sym_cache,
						    abfd, r_symndx);
		      if (isym == NULL)
			return FALSE;

		      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		      if (s == NULL)
			s = sec;

		      vpp = &elf_section_data (s)->local_dynrel;
		      head = (struct elf_m68k_pcrel_relocs_copied **) vpp;
		    }

		  for (p = *head; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
		    {
		      p = ((struct elf_m68k_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return FALSE;
		      p->next = *head;
		      *head = p;
		      p->section = sreloc;
		      p->count = 0;
		    }

		  ++p->count;
		}
	    }

	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_68K_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_68K_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf_m68k_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_68K_GNU_VTINHERIT:
      case R_68K_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf_m68k_gc_sweep_hook (bfd *abfd,
			struct bfd_link_info *info,
			asection *sec,
			const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;
  struct elf_m68k_got *got;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  got = NULL;

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_68K_GOT8:
	case R_68K_GOT16:
	case R_68K_GOT32:
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;

	  /* FALLTHRU */
	case R_68K_GOT8O:
	case R_68K_GOT16O:
	case R_68K_GOT32O:
	  /* Fall through.  */

	  /* TLS relocations.  */
	case R_68K_TLS_GD8:
	case R_68K_TLS_GD16:
	case R_68K_TLS_GD32:
	case R_68K_TLS_LDM8:
	case R_68K_TLS_LDM16:
	case R_68K_TLS_LDM32:
	case R_68K_TLS_IE8:
	case R_68K_TLS_IE16:
	case R_68K_TLS_IE32:

	case R_68K_TLS_TPREL32:
	case R_68K_TLS_DTPREL32:

	  if (got == NULL)
	    {
	      got = elf_m68k_get_bfd2got_entry (elf_m68k_multi_got (info),
						abfd, MUST_FIND, NULL)->got;
	      BFD_ASSERT (got != NULL);
	    }

	  {
	    struct elf_m68k_got_entry_key key_;
	    struct elf_m68k_got_entry **got_entry_ptr;
	    struct elf_m68k_got_entry *got_entry;

	    elf_m68k_init_got_entry_key (&key_, h, abfd, r_symndx,
					 ELF32_R_TYPE (rel->r_info));
	    got_entry_ptr = elf_m68k_find_got_entry_ptr (got, &key_);

	    got_entry = *got_entry_ptr;

	    if (got_entry->u.s1.refcount > 0)
	      {
		--got_entry->u.s1.refcount;

		if (got_entry->u.s1.refcount == 0)
		  /* We don't need the .got entry any more.  */
		  elf_m68k_remove_got_entry (got, got_entry_ptr);
	      }
	  }
	  break;

	case R_68K_PLT8:
	case R_68K_PLT16:
	case R_68K_PLT32:
	case R_68K_PLT8O:
	case R_68K_PLT16O:
	case R_68K_PLT32O:
	case R_68K_PC8:
	case R_68K_PC16:
	case R_68K_PC32:
	case R_68K_8:
	case R_68K_16:
	case R_68K_32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		--h->plt.refcount;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the type of PLT associated with OUTPUT_BFD.  */

static const struct elf_m68k_plt_info *
elf_m68k_get_plt_info (bfd *output_bfd)
{
  unsigned int features;

  features = bfd_m68k_mach_to_features (bfd_get_mach (output_bfd));
  if (features & cpu32)
    return &elf_cpu32_plt_info;
  if (features & mcfisa_b)
    return &elf_isab_plt_info;
  if (features & mcfisa_c)
    return &elf_isac_plt_info;
  return &elf_m68k_plt_info;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.
   It's a convenient place to determine the PLT style.  */

static bfd_boolean
elf_m68k_always_size_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  /* Bind input BFDs to GOTs and calculate sizes of .got and .rela.got
     sections.  */
  if (!elf_m68k_partition_multi_got (info))
    return FALSE;

  elf_m68k_hash_table (info)->plt_info = elf_m68k_get_plt_info (output_bfd);
  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_m68k_adjust_dynamic_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h)
{
  struct elf_m68k_link_hash_table *htab;
  bfd *dynobj;
  asection *s;

  htab = elf_m68k_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if ((h->plt.refcount <= 0
           || SYMBOL_CALLS_LOCAL (info, h)
	   || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	       && h->root.type == bfd_link_hash_undefweak))
	  /* We must always create the plt entry if it was referenced
	     by a PLTxxO relocation.  In this case we already recorded
	     it as a dynamic symbol.  */
	  && h->dynindx == -1)
	{
	  /* This case can occur if we saw a PLTxx reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PCxx reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  return TRUE;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->size == 0)
	s->size = htab->plt_info->size;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (!info->shared
	  && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
	}

      h->plt.offset = s->size;

      /* Make room for this entry.  */
      s->size += htab->plt_info->size;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_linker_section (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->size += 4;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf32_External_Rela);

      return TRUE;
    }

  /* Reinitialize the plt offset now that it is not used as a reference
     count any more.  */
  h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_linker_section (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_68K_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean plt;
  bfd_boolean relocs;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }
  else
    {
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.  */
      s = bfd_get_linker_section (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     For the normal shared case we discard the PC relative relocs
     against symbols that have become local due to visibility changes.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_m68k_discard_copies,
			    info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strcmp (name, ".plt") == 0)
	{
	  /* Remember whether there is a PLT.  */
	  plt = s->size != 0;
	}
      else if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".got")
	       && strcmp (name, ".dynbss") != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      /* FIXME: This should be a call to bfd_alloc not bfd_zalloc.
	 Unused entries should be reclaimed before the section's contents
	 are written out, but at the moment this does not happen.  Thus in
	 order to prevent writing out garbage, we initialise the section's
	 contents to zero.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_m68k_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
	}

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* This function is called via elf_link_hash_traverse if we are
   creating a shared object.  In the -Bsymbolic case it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal shared case, it
   discards space for pc-relative relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.

   We also check whether any of the remaining relocations apply
   against a readonly section, and set the DF_TEXTREL flag in this
   case.  */

static bfd_boolean
elf_m68k_discard_copies (struct elf_link_hash_entry *h,
			 void * inf)
{
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
  struct elf_m68k_pcrel_relocs_copied *s;

  if (!SYMBOL_CALLS_LOCAL (info, h))
    {
      if ((info->flags & DF_TEXTREL) == 0)
	{
	  /* Look for relocations against read-only sections.  */
	  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
	       s != NULL;
	       s = s->next)
	    if ((s->section->flags & SEC_READONLY) != 0)
	      {
		info->flags |= DF_TEXTREL;
		break;
	      }
	}

      /* Make sure undefined weak symbols are output as a dynamic symbol
	 in PIEs.  */
      if (h->non_got_ref
	  && h->root.type == bfd_link_hash_undefweak
	  && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  && h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      return TRUE;
    }

  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
       s != NULL;
       s = s->next)
    s->section->size -= s->count * sizeof (Elf32_External_Rela);

  return TRUE;
}


/* Install relocation RELA.  */

static void
elf_m68k_install_rela (bfd *output_bfd,
		       asection *srela,
		       Elf_Internal_Rela *rela)
{
  bfd_byte *loc;

  loc = srela->contents;
  loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
  bfd_elf32_swap_reloca_out (output_bfd, rela, loc);
}

/* Find the base offsets for thread-local storage in this object,
   for GD/LD and IE/LE respectively.  */

#define DTP_OFFSET 0x8000
#define TP_OFFSET  0x7000

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma + DTP_OFFSET;
}

static bfd_vma
tpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma + TP_OFFSET;
}

/* Output necessary relocation to handle a symbol during static link.
   This function is called from elf_m68k_relocate_section.  */

static void
elf_m68k_init_got_entry_static (struct bfd_link_info *info,
				bfd *output_bfd,
				enum elf_m68k_reloc_type r_type,
				asection *sgot,
				bfd_vma got_entry_offset,
				bfd_vma relocation)
{
  switch (elf_m68k_reloc_got_type (r_type))
    {
    case R_68K_GOT32O:
      bfd_put_32 (output_bfd, relocation, sgot->contents + got_entry_offset);
      break;

    case R_68K_TLS_GD32:
      /* We know the offset within the module,
	 put it into the second GOT slot.  */
      bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
		  sgot->contents + got_entry_offset + 4);
      /* FALLTHRU */

    case R_68K_TLS_LDM32:
      /* Mark it as belonging to module 1, the executable.  */
      bfd_put_32 (output_bfd, 1, sgot->contents + got_entry_offset);
      break;

    case R_68K_TLS_IE32:
      bfd_put_32 (output_bfd, relocation - tpoff_base (info),
		  sgot->contents + got_entry_offset);
      break;

    default:
      BFD_ASSERT (FALSE);
    }
}

/* Output necessary relocation to handle a local symbol
   during dynamic link.
   This function is called either from elf_m68k_relocate_section
   or from elf_m68k_finish_dynamic_symbol.  */

static void
elf_m68k_init_got_entry_local_shared (struct bfd_link_info *info,
				      bfd *output_bfd,
				      enum elf_m68k_reloc_type r_type,
				      asection *sgot,
				      bfd_vma got_entry_offset,
				      bfd_vma relocation,
				      asection *srela)
{
  Elf_Internal_Rela outrel;

  switch (elf_m68k_reloc_got_type (r_type))
    {
    case R_68K_GOT32O:
      /* Emit RELATIVE relocation to initialize GOT slot
	 at run-time.  */
      outrel.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
      outrel.r_addend = relocation;
      break;

    case R_68K_TLS_GD32:
      /* We know the offset within the module,
	 put it into the second GOT slot.  */
      bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
		  sgot->contents + got_entry_offset + 4);
      /* FALLTHRU */

    case R_68K_TLS_LDM32:
      /* We don't know the module number,
	 create a relocation for it.  */
      outrel.r_info = ELF32_R_INFO (0, R_68K_TLS_DTPMOD32);
      outrel.r_addend = 0;
      break;

    case R_68K_TLS_IE32:
      /* Emit TPREL relocation to initialize GOT slot
	 at run-time.  */
      outrel.r_info = ELF32_R_INFO (0, R_68K_TLS_TPREL32);
      outrel.r_addend = relocation - elf_hash_table (info)->tls_sec->vma;
      break;

    default:
      BFD_ASSERT (FALSE);
    }

  /* Offset of the GOT entry.  */
  outrel.r_offset = (sgot->output_section->vma
		     + sgot->output_offset
		     + got_entry_offset);

  /* Install one of the above relocations.  */
  elf_m68k_install_rela (output_bfd, srela, &outrel);

  bfd_put_32 (output_bfd, outrel.r_addend, sgot->contents + got_entry_offset);
}

/* Relocate an M68K ELF section.  */

static bfd_boolean
elf_m68k_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  asection *sgot;
  asection *splt;
  asection *sreloc;
  asection *srela;
  struct elf_m68k_got *got;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  sgot = NULL;
  splt = NULL;
  sreloc = NULL;
  srela = NULL;

  got = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_68K_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = howto_table + r_type;

      r_symndx = ELF32_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      switch (r_type)
	{
	case R_68K_GOT8:
	case R_68K_GOT16:
	case R_68K_GOT32:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    {
	      if (elf_m68k_hash_table (info)->local_gp_p)
		{
		  bfd_vma sgot_output_offset;
		  bfd_vma got_offset;

		  if (sgot == NULL)
		    {
		      sgot = bfd_get_linker_section (dynobj, ".got");

		      if (sgot != NULL)
			sgot_output_offset = sgot->output_offset;
		      else
			/* In this case we have a reference to
			   _GLOBAL_OFFSET_TABLE_, but the GOT itself is
			   empty.
			   ??? Issue a warning?  */
			sgot_output_offset = 0;
		    }
		  else
		    sgot_output_offset = sgot->output_offset;

		  if (got == NULL)
		    {
		      struct elf_m68k_bfd2got_entry *bfd2got_entry;

		      bfd2got_entry
			= elf_m68k_get_bfd2got_entry (elf_m68k_multi_got (info),
						      input_bfd, SEARCH, NULL);

		      if (bfd2got_entry != NULL)
			{
			  got = bfd2got_entry->got;
			  BFD_ASSERT (got != NULL);

			  got_offset = got->offset;
			}
		      else
			/* In this case we have a reference to
			   _GLOBAL_OFFSET_TABLE_, but no other references
			   accessing any GOT entries.
			   ??? Issue a warning?  */
			got_offset = 0;
		    }
		  else
		    got_offset = got->offset;

		  /* Adjust GOT pointer to point to the GOT
		     assigned to input_bfd.  */
		  rel->r_addend += sgot_output_offset + got_offset;
		}
	      else
		BFD_ASSERT (got == NULL || got->offset == 0);

	      break;
	    }
	  /* Fall through.  */
	case R_68K_GOT8O:
	case R_68K_GOT16O:
	case R_68K_GOT32O:

	case R_68K_TLS_LDM32:
	case R_68K_TLS_LDM16:
	case R_68K_TLS_LDM8:

	case R_68K_TLS_GD8:
	case R_68K_TLS_GD16:
	case R_68K_TLS_GD32:

	case R_68K_TLS_IE8:
	case R_68K_TLS_IE16:
	case R_68K_TLS_IE32:

	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */

	  {
	    struct elf_m68k_got_entry_key key_;
	    bfd_vma *off_ptr;
	    bfd_vma off;

	    if (sgot == NULL)
	      {
		sgot = bfd_get_linker_section (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
	      }

	    if (got == NULL)
	      {
		got = elf_m68k_get_bfd2got_entry (elf_m68k_multi_got (info),
						  input_bfd, MUST_FIND,
						  NULL)->got;
		BFD_ASSERT (got != NULL);
	      }

	    /* Get GOT offset for this symbol.  */
	    elf_m68k_init_got_entry_key (&key_, h, input_bfd, r_symndx,
					 r_type);
	    off_ptr = &elf_m68k_get_got_entry (got, &key_, MUST_FIND,
					       NULL)->u.s2.offset;
	    off = *off_ptr;

	    /* The offset must always be a multiple of 4.  We use
	       the least significant bit to record whether we have
	       already generated the necessary reloc.  */
	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		if (h != NULL
		    /* @@TLSLDM relocations are bounded to the module, in
		       which the symbol is defined -- not to the symbol
		       itself.  */
		    && elf_m68k_reloc_got_type (r_type) != R_68K_TLS_LDM32)
		  {
		    bfd_boolean dyn;

		    dyn = elf_hash_table (info)->dynamic_sections_created;
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
			|| (info->shared
			    && SYMBOL_REFERENCES_LOCAL (info, h))
			|| (ELF_ST_VISIBILITY (h->other)
			    && h->root.type == bfd_link_hash_undefweak))
		      {
			/* This is actually a static link, or it is a
			   -Bsymbolic link and the symbol is defined
			   locally, or the symbol was forced to be local
			   because of a version file.  We must initialize
			   this entry in the global offset table.  Since
			   the offset must always be a multiple of 4, we
			   use the least significant bit to record whether
			   we have initialized it already.

			   When doing a dynamic link, we create a .rela.got
			   relocation entry to initialize the value.  This
			   is done in the finish_dynamic_symbol routine.  */

			elf_m68k_init_got_entry_static (info,
							output_bfd,
							r_type,
							sgot,
							off,
							relocation);

			*off_ptr |= 1;
		      }
		    else
		      unresolved_reloc = FALSE;
		  }
		else if (info->shared) /* && h == NULL */
		  /* Process local symbol during dynamic link.  */
		  {
		    if (srela == NULL)
		      {
			srela = bfd_get_linker_section (dynobj, ".rela.got");
			BFD_ASSERT (srela != NULL);
		      }

		    elf_m68k_init_got_entry_local_shared (info,
							  output_bfd,
							  r_type,
							  sgot,
							  off,
							  relocation,
							  srela);

		    *off_ptr |= 1;
		  }
		else /* h == NULL && !info->shared */
		  {
		    elf_m68k_init_got_entry_static (info,
						    output_bfd,
						    r_type,
						    sgot,
						    off,
						    relocation);

		    *off_ptr |= 1;
		  }
	      }

	    /* We don't use elf_m68k_reloc_got_type in the condition below
	       because this is the only place where difference between
	       R_68K_GOTx and R_68K_GOTxO relocations matters.  */
	    if (r_type == R_68K_GOT32O
		|| r_type == R_68K_GOT16O
		|| r_type == R_68K_GOT8O
		|| elf_m68k_reloc_got_type (r_type) == R_68K_TLS_GD32
		|| elf_m68k_reloc_got_type (r_type) == R_68K_TLS_LDM32
		|| elf_m68k_reloc_got_type (r_type) == R_68K_TLS_IE32)
	      {
		/* GOT pointer is adjusted to point to the start/middle
		   of local GOT.  Adjust the offset accordingly.  */
		BFD_ASSERT (elf_m68k_hash_table (info)->use_neg_got_offsets_p
			    || off >= got->offset);

		if (elf_m68k_hash_table (info)->local_gp_p)
		  relocation = off - got->offset;
		else
		  {
		    BFD_ASSERT (got->offset == 0);
		    relocation = sgot->output_offset + off;
		  }

		/* This relocation does not use the addend.  */
		rel->r_addend = 0;
	      }
	    else
	      relocation = (sgot->output_section->vma + sgot->output_offset
			    + off);
	  }
	  break;

	case R_68K_TLS_LDO32:
	case R_68K_TLS_LDO16:
	case R_68K_TLS_LDO8:
	  relocation -= dtpoff_base (info);
	  break;

	case R_68K_TLS_LE32:
	case R_68K_TLS_LE16:
	case R_68K_TLS_LE8:
	  if (info->shared && !info->pie)
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): R_68K_TLS_LE32 relocation not permitted "
		   "in shared object"),
		 input_bfd, input_section, (long) rel->r_offset, howto->name);

	      return FALSE;
	    }
	  else
	    relocation -= tpoff_base (info);

	  break;

	case R_68K_PLT8:
	case R_68K_PLT16:
	case R_68K_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLTxx reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
	      || !elf_hash_table (info)->dynamic_sections_created)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  if (splt == NULL)
	    {
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_68K_PLT8O:
	case R_68K_PLT16O:
	case R_68K_PLT32O:
	  /* Relocation is the offset of the entry for this symbol in
	     the procedure linkage table.  */
	  BFD_ASSERT (h != NULL && h->plt.offset != (bfd_vma) -1);

	  if (splt == NULL)
	    {
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  relocation = h->plt.offset;
	  unresolved_reloc = FALSE;

	  /* This relocation does not use the addend.  */
	  rel->r_addend = 0;

	  break;

	case R_68K_8:
	case R_68K_16:
	case R_68K_32:
	case R_68K_PC8:
	case R_68K_PC16:
	case R_68K_PC32:
	  if (info->shared
	      && r_symndx != STN_UNDEF
	      && (input_section->flags & SEC_ALLOC) != 0
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
	      && ((r_type != R_68K_PC8
		   && r_type != R_68K_PC16
		   && r_type != R_68K_PC32)
		  || !SYMBOL_CALLS_LOCAL (info, h)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (h != NULL
		       && h->dynindx != -1
		       && (r_type == R_68K_PC8
			   || r_type == R_68K_PC16
			   || r_type == R_68K_PC32
			   || !info->shared
			   || !info->symbolic
			   || !h->def_regular))
		{
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  /* This symbol is local, or marked to become local.  */
		  outrel.r_addend = relocation + rel->r_addend;

		  if (r_type == R_68K_32)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
		    }
		  else
		    {
		      long indx;

		      if (bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.  */
			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    {
			      struct elf_link_hash_table *htab;
			      htab = elf_hash_table (info);
			      osec = htab->text_index_section;
			      indx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (indx != 0);
			}

		      outrel.r_info = ELF32_R_INFO (indx, r_type);
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* This reloc will be computed at runtime, so there's no
                 need to do anything now, except for R_68K_32
                 relocations that have been turned into
                 R_68K_RELATIVE.  */
	      if (!relocate)
		continue;
	    }

	  break;

	case R_68K_GNU_VTINHERIT:
	case R_68K_GNU_VTENTRY:
	  /* These are no-ops in the end.  */
	  continue;

	default:
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     h->root.root.string);
	  return FALSE;
	}

      if (r_symndx != STN_UNDEF
	  && r_type != R_68K_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  char sym_type;

	  sym_type = (sym != NULL) ? ELF32_ST_TYPE (sym->st_info) : h->type;

	  if (elf_m68k_reloc_tls_p (r_type) != (sym_type == STT_TLS))
	    {
	      const char *name;

	      if (h != NULL)
		name = h->root.root.string;
	      else
		{
		  name = (bfd_elf_string_from_elf_section
			  (input_bfd, symtab_hdr->sh_link, sym->st_name));
		  if (name == NULL || *name == '\0')
		    name = bfd_section_name (input_bfd, sec);
		}

	      (*_bfd_error_handler)
		((sym_type == STT_TLS
		  ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
		  : _("%B(%A+0x%lx): %s used with non-TLS symbol %s")),
		 input_bfd,
		 input_section,
		 (long) rel->r_offset,
		 howto->name,
		 name);
	    }
	}

      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, (h ? &h->root : NULL), name, howto->name,
		     (bfd_vma) 0, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Install an M_68K_PC32 relocation against VALUE at offset OFFSET
   into section SEC.  */

static void
elf_m68k_install_pc32 (asection *sec, bfd_vma offset, bfd_vma value)
{
  /* Make VALUE PC-relative.  */
  value -= sec->output_section->vma + offset;

  /* Apply any in-place addend.  */
  value += bfd_get_32 (sec->owner, sec->contents + offset);

  bfd_put_32 (sec->owner, value, sec->contents + offset);
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf_m68k_finish_dynamic_symbol (bfd *output_bfd,
				struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				Elf_Internal_Sym *sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      const struct elf_m68k_plt_info *plt_info;
      asection *splt;
      asection *sgot;
      asection *srela;
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      plt_info = elf_m68k_hash_table (info)->plt_info;
      splt = bfd_get_linker_section (dynobj, ".plt");
      sgot = bfd_get_linker_section (dynobj, ".got.plt");
      srela = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = (h->plt.offset / plt_info->size) - 1;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      memcpy (splt->contents + h->plt.offset,
	      plt_info->symbol_entry,
	      plt_info->size);

      elf_m68k_install_pc32 (splt, h->plt.offset + plt_info->symbol_relocs.got,
			     (sgot->output_section->vma
			      + sgot->output_offset
			      + got_offset));

      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		  splt->contents
		  + h->plt.offset
		  + plt_info->symbol_resolve_entry + 2);

      elf_m68k_install_pc32 (splt, h->plt.offset + plt_info->symbol_relocs.plt,
			     splt->output_section->vma);

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset
		   + plt_info->symbol_resolve_entry),
		  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_JMP_SLOT);
      rela.r_addend = 0;
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (elf_m68k_hash_entry (h)->glist != NULL)
    {
      asection *sgot;
      asection *srela;
      struct elf_m68k_got_entry *got_entry;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      sgot = bfd_get_linker_section (dynobj, ".got");
      srela = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);

      got_entry = elf_m68k_hash_entry (h)->glist;

      while (got_entry != NULL)
	{
	  enum elf_m68k_reloc_type r_type;
	  bfd_vma got_entry_offset;

	  r_type = got_entry->key_.type;
	  got_entry_offset = got_entry->u.s2.offset &~ (bfd_vma) 1;

	  /* If this is a -Bsymbolic link, and the symbol is defined
	     locally, we just want to emit a RELATIVE reloc.  Likewise if
	     the symbol was forced to be local because of a version file.
	     The entry in the global offset table already have been
	     initialized in the relocate_section function.  */
	  if (info->shared
	      && SYMBOL_REFERENCES_LOCAL (info, h))
	    {
	      bfd_vma relocation;

	      relocation = bfd_get_signed_32 (output_bfd,
					      (sgot->contents
					       + got_entry_offset));

	      /* Undo TP bias.  */
	      switch (elf_m68k_reloc_got_type (r_type))
		{
		case R_68K_GOT32O:
		case R_68K_TLS_LDM32:
		  break;

		case R_68K_TLS_GD32:
		  /* The value for this relocation is actually put in
		     the second GOT slot.  */
		  relocation = bfd_get_signed_32 (output_bfd,
						  (sgot->contents
						   + got_entry_offset + 4));
		  relocation += dtpoff_base (info);
		  break;

		case R_68K_TLS_IE32:
		  relocation += tpoff_base (info);
		  break;

		default:
		  BFD_ASSERT (FALSE);
		}

	      elf_m68k_init_got_entry_local_shared (info,
						    output_bfd,
						    r_type,
						    sgot,
						    got_entry_offset,
						    relocation,
						    srela);
	    }
	  else
	    {
	      Elf_Internal_Rela rela;

	      /* Put zeros to GOT slots that will be initialized
		 at run-time.  */
	      {
		bfd_vma n_slots;

		n_slots = elf_m68k_reloc_got_n_slots (got_entry->key_.type);
		while (n_slots--)
		  bfd_put_32 (output_bfd, (bfd_vma) 0,
			      (sgot->contents + got_entry_offset
			       + 4 * n_slots));
	      }

	      rela.r_addend = 0;
	      rela.r_offset = (sgot->output_section->vma
			       + sgot->output_offset
			       + got_entry_offset);

	      switch (elf_m68k_reloc_got_type (r_type))
		{
		case R_68K_GOT32O:
		  rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_GLOB_DAT);
		  elf_m68k_install_rela (output_bfd, srela, &rela);
		  break;

		case R_68K_TLS_GD32:
		  rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_TLS_DTPMOD32);
		  elf_m68k_install_rela (output_bfd, srela, &rela);

		  rela.r_offset += 4;
		  rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_TLS_DTPREL32);
		  elf_m68k_install_rela (output_bfd, srela, &rela);
		  break;

		case R_68K_TLS_IE32:
		  rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_TLS_TPREL32);
		  elf_m68k_install_rela (output_bfd, srela, &rela);
		  break;

		default:
		  BFD_ASSERT (FALSE);
		  break;
		}
	    }

	  got_entry = got_entry->u.s2.next;
	}
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (s != NULL);

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_COPY);
      rela.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf_m68k_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sgot;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_linker_section (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* The procedure linkage table relocs (DT_JMPREL) should
		 not be included in the overall relocs (DT_RELA).
		 Therefore, we override the DT_RELASZ entry here to
		 make it not include the JMPREL relocs.  Since the
		 linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0)
	{
	  const struct elf_m68k_plt_info *plt_info;

	  plt_info = elf_m68k_hash_table (info)->plt_info;
	  memcpy (splt->contents, plt_info->plt0_entry, plt_info->size);

	  elf_m68k_install_pc32 (splt, plt_info->plt0_relocs.got4,
				 (sgot->output_section->vma
				  + sgot->output_offset
				  + 4));

	  elf_m68k_install_pc32 (splt, plt_info->plt0_relocs.got8,
				 (sgot->output_section->vma
				  + sgot->output_offset
				  + 8));

	  elf_section_data (splt->output_section)->this_hdr.sh_entsize
	    = plt_info->size;
	}
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

  return TRUE;
}

/* Given a .data section and a .emreloc in-memory section, store
   relocation information into the .emreloc section which can be
   used at runtime to relocate the section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_m68k_elf32_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *p;
  bfd_size_type amt;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, datasec, NULL, (Elf_Internal_Rela *) NULL,
		      info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  amt = (bfd_size_type) datasec->reloc_count * 12;
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, amt);
  if (relsec->contents == NULL)
    goto error_return;

  p = relsec->contents;

  irelend = internal_relocs + datasec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
       reloc section.  The longword will be the address in the data
       section which must be relocated.  It is followed by the name
       of the target section NUL-padded or truncated to 8
       characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_68K_32)
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}

      /* Get the target section referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols if we haven't done so already.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	  else
	    targetsec = NULL;
	}

      bfd_put_32 (abfd, irel->r_offset + datasec->output_offset, p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy ((char *) p + 4, targetsec->output_section->name, 8);
    }

  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  return TRUE;

error_return:
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* Set target options.  */

void
bfd_elf_m68k_set_target_options (struct bfd_link_info *info, int got_handling)
{
  struct elf_m68k_link_hash_table *htab;
  bfd_boolean use_neg_got_offsets_p;
  bfd_boolean allow_multigot_p;
  bfd_boolean local_gp_p;

  switch (got_handling)
    {
    case 0:
      /* --got=single.  */
      local_gp_p = FALSE;
      use_neg_got_offsets_p = FALSE;
      allow_multigot_p = FALSE;
      break;

    case 1:
      /* --got=negative.  */
      local_gp_p = TRUE;
      use_neg_got_offsets_p = TRUE;
      allow_multigot_p = FALSE;
      break;

    case 2:
      /* --got=multigot.  */
      local_gp_p = TRUE;
      use_neg_got_offsets_p = TRUE;
      allow_multigot_p = TRUE;
      break;

    default:
      BFD_ASSERT (FALSE);
      return;
    }

  htab = elf_m68k_hash_table (info);
  if (htab != NULL)
    {
      htab->local_gp_p = local_gp_p;
      htab->use_neg_got_offsets_p = use_neg_got_offsets_p;
      htab->allow_multigot_p = allow_multigot_p;
    }
}

static enum elf_reloc_type_class
elf32_m68k_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_68K_RELATIVE:
      return reloc_class_relative;
    case R_68K_JMP_SLOT:
      return reloc_class_plt;
    case R_68K_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_m68k_plt_sym_val (bfd_vma i, const asection *plt,
		      const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + (i + 1) * elf_m68k_get_plt_info (plt->owner)->size;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
elf_m68k_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
    default:
      return FALSE;

    case 154:		/* Linux/m68k */
      /* pr_cursig */
      elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

      /* pr_pid */
      elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 22);

      /* pr_reg */
      offset = 70;
      size = 80;

      break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf_m68k_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
    default:
      return FALSE;

    case 124:		/* Linux/m68k elf_prpsinfo.  */
      elf_tdata (abfd)->core->pid
	= bfd_get_32 (abfd, note->descdata + 12);
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (n > 0 && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

#define TARGET_BIG_SYM			bfd_elf32_m68k_vec
#define TARGET_BIG_NAME			"elf32-m68k"
#define ELF_MACHINE_CODE		EM_68K
#define ELF_MAXPAGESIZE			0x2000
#define elf_backend_create_dynamic_sections \
					_bfd_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create \
					elf_m68k_link_hash_table_create
/* ??? Should it be this macro or bfd_elfNN_bfd_link_hash_table_create?  */
#define bfd_elf32_bfd_link_hash_table_free \
					elf_m68k_link_hash_table_free
#define bfd_elf32_bfd_final_link	bfd_elf_final_link

#define elf_backend_check_relocs	elf_m68k_check_relocs
#define elf_backend_always_size_sections \
					elf_m68k_always_size_sections
#define elf_backend_adjust_dynamic_symbol \
					elf_m68k_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
					elf_m68k_size_dynamic_sections
#define elf_backend_final_write_processing	elf_m68k_final_write_processing
#define elf_backend_init_index_section	_bfd_elf_init_1_index_section
#define elf_backend_relocate_section	elf_m68k_relocate_section
#define elf_backend_finish_dynamic_symbol \
					elf_m68k_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					elf_m68k_finish_dynamic_sections
#define elf_backend_gc_mark_hook	elf_m68k_gc_mark_hook
#define elf_backend_gc_sweep_hook	elf_m68k_gc_sweep_hook
#define elf_backend_copy_indirect_symbol elf_m68k_copy_indirect_symbol
#define bfd_elf32_bfd_merge_private_bfd_data \
                                        elf32_m68k_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags \
                                        elf32_m68k_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
                                        elf32_m68k_print_private_bfd_data
#define elf_backend_reloc_type_class	elf32_m68k_reloc_type_class
#define elf_backend_plt_sym_val		elf_m68k_plt_sym_val
#define elf_backend_object_p		elf32_m68k_object_p
#define elf_backend_grok_prstatus	elf_m68k_grok_prstatus
#define elf_backend_grok_psinfo		elf_m68k_grok_psinfo

#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size	12
#define elf_backend_rela_normal		1

#include "elf32-target.h"
@


1.142
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d3370 1
a3370 1
      if (!info->shared)
@


1.141
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d2587 4
@


1.140
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d4740 3
a4742 1
elf32_m68k_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.139
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d4780 1
a4780 1
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d4783 1
a4783 1
      elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 22);
d4806 1
a4806 1
      elf_tdata (abfd)->core_pid
d4808 1
a4808 1
      elf_tdata (abfd)->core_program
d4810 1
a4810 1
      elf_tdata (abfd)->core_command
d4818 1
a4818 1
    char *command = elf_tdata (abfd)->core_command;
@


1.138
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d985 1
@


1.137
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d953 1
a953 1
  ret = (struct elf_m68k_link_hash_table *) bfd_malloc (amt);
a965 6
  ret->sym_cache.abfd = NULL;
  ret->plt_info = NULL;
  ret->local_gp_p = FALSE;
  ret->use_neg_got_offsets_p = FALSE;
  ret->allow_multigot_p = FALSE;
  ret->multi_got_.bfd2got = NULL;
@


1.136
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d31 2
a32 34
static reloc_howto_type *reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void rtype_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static struct bfd_hash_entry *elf_m68k_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *elf_m68k_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean elf_m68k_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf_m68k_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf_m68k_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_m68k_discard_copies
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_m68k_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf_m68k_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf_m68k_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf32_m68k_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean elf32_m68k_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_m68k_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static enum elf_reloc_type_class elf32_m68k_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d34 2
a35 1
static reloc_howto_type howto_table[] = {
d413 2
a414 3
reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1116 1
a1116 3
elf32_m68k_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d1126 1
a1126 3
elf32_m68k_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2548 4
a2551 5
elf_m68k_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3094 2
a3095 3
elf_m68k_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d3248 2
a3249 3
elf_m68k_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d3291 1
a3291 1
			    (PTR) info);
d3419 2
a3420 3
elf_m68k_discard_copies (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d3605 8
a3612 10
elf_m68k_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d4228 4
a4231 5
elf_m68k_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d4463 1
a4463 3
elf_m68k_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d4607 1
a4607 1
		     (abfd, datasec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d4745 1
a4745 2
elf32_m68k_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
@


1.135
log
@* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Don't make
_GLOBAL_OFFSET_TABLE_ and _DYNAMIC absolute.
@
text
@d2471 1
a2471 1
      s = bfd_get_section_by_name (elf_hash_table (info)->dynobj, ".got");
d2480 1
a2480 1
      s = bfd_get_section_by_name (elf_hash_table (info)->dynobj, ".rela.got");
d2678 1
a2678 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d2685 1
a2685 1
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d2688 6
a2693 8
		  srelgot = bfd_make_section_with_flags (dynobj,
							 ".rela.got",
							 (SEC_ALLOC
							  | SEC_LOAD
							  | SEC_HAS_CONTENTS
							  | SEC_IN_MEMORY
							  | SEC_LINKER_CREATED
							  | SEC_READONLY));
d3183 1
a3183 1
      s = bfd_get_section_by_name (dynobj, ".plt");
d3210 1
a3210 1
      s = bfd_get_section_by_name (dynobj, ".got.plt");
d3215 1
a3215 1
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
d3263 1
a3263 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d3274 1
a3274 1
      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d3303 1
a3303 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d3316 1
a3316 1
      s = bfd_get_section_by_name (dynobj, ".rela.got");
d3747 1
a3747 1
		      sgot = bfd_get_section_by_name (dynobj, ".got");
d3822 1
a3822 1
		sgot = bfd_get_section_by_name (dynobj, ".got");
d3893 1
a3893 1
			srela = bfd_get_section_by_name (dynobj, ".rela.got");
d3997 1
a3997 1
	      splt = bfd_get_section_by_name (dynobj, ".plt");
d4016 1
a4016 1
	      splt = bfd_get_section_by_name (dynobj, ".plt");
d4297 3
a4299 3
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
d4364 2
a4365 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
d4488 1
a4488 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
d4516 1
a4516 1
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d4518 1
a4518 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d4525 1
a4525 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.134
log
@* elf32-m68k.c (elf_m68k_grok_prstatus): New function.
(elf_m68k_grok_psinfo): New function.
(elf_backend_grok_prstatus): Define.
(elf_backend_grok_psinfo): Define.
@
text
@a4502 5
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;

@


1.133
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d4824 63
d4926 2
@


1.132
log
@* elf32-m68k.c (elf_m68k_check_relocs): Mark non-GOT references
also when generating PIE.
(elf_m68k_discard_copies): Mark undefined weak symbols referenced
by relocations as dynamic.
@
text
@d3727 1
a3727 1
					 rel, relend, howto, contents);
@


1.131
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2830 1
a2830 1
	      if (!info->shared)
d3482 12
@


1.130
log
@* elf32-m68k.c (elf_m68k_relocate_section): Allow
R_68K_TLS_LE{8,16,32} for PIE.
@
text
@d3713 1
a3713 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.129
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3951 1
a3951 1
	  if (info->shared)
@


1.128
log
@	* elf32-m68k.c (elf_m68k_check_relocs) <R_68K_8, R68K_16, R_68K_32>: For
	non-SEC_ALLOC sections break before GOT and PLT accounting.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a3254 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d3272 1
a3272 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.127
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2819 5
d2837 1
a2837 2
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0)
@


1.126
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d4151 3
a4153 1
	       && h->def_dynamic))
@


1.126.2.1
log
@2011-12-01  Mikael Pettersson  <mikpe@@it.uu.se>

	Apply mainline patches
	* elf32-m68k.c (elf_m68k_check_relocs) <R_68K_8, R68K_16, R_68K_32>: For
	non-SEC_ALLOC sections break before GOT and PLT accounting.
@
text
@a2818 5
	  /* We don't need to handle relocs into sections not going into
	     the "real" output.  */
	  if ((sec->flags & SEC_ALLOC) == 0)
	      break;

d2832 2
a2833 1
	  if (info->shared)
@


1.126.2.2
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3720 1
a3720 1
      if (sec != NULL && discarded_section (sec))
@


1.125
log
@* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): For a TLS_GD
relocation read the value from the second GOT slot.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a3469 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.124
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d4393 5
@


1.123
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d3719 2
a3720 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.122
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d4037 1
a4037 1
	      && r_symndx != 0
d4172 1
a4172 1
      if (r_symndx != 0
@


1.121
log
@	* elf32-m68k.c (bfd_elf_m68k_set_target_options): Don't set GOT
	options unless an m68k hash table has been found.
@
text
@d472 1
@


1.120
log
@	bfd/
	* elf32-m69k.c (elf32_m68k_print_private_bfd_data): Detect EMAC_B
	variant.

	binutils/
	* readelf.c (get_machine_flags): Detect CF ISA C and EMAC_B
	variants.
@
text
@d4748 3
a4750 2

  htab = elf_m68k_hash_table (info);
d4756 3
a4758 3
      htab->local_gp_p = FALSE;
      htab->use_neg_got_offsets_p = FALSE;
      htab->allow_multigot_p = FALSE;
d4763 3
a4765 3
      htab->local_gp_p = TRUE;
      htab->use_neg_got_offsets_p = TRUE;
      htab->allow_multigot_p = FALSE;
d4770 3
a4772 3
      htab->local_gp_p = TRUE;
      htab->use_neg_got_offsets_p = TRUE;
      htab->allow_multigot_p = TRUE;
d4777 9
@


1.119
log
@fix set but unused variable warnings
@
text
@d1296 3
@


1.118
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a2970 2
  asection *sgot;
  asection *srelgot;
a2981 3

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
@


1.117
log
@        * elf32-m68k.c (elf_m68k_final_write_processing): New function.
       (elf_backend_final_write_processing): Macro defined as above function.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d940 2
a941 1
  ((struct elf_m68k_link_hash_table *) (p)->hash)
d949 3
a951 4
elf_m68k_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d978 1
a978 2
elf_m68k_link_hash_table_create (abfd)
     bfd *abfd;
d989 2
a990 1
				      sizeof (struct elf_m68k_link_hash_entry)))
@


1.116
log
@* elf32-m68k.c (rtype_to_howto): If the reloc index is out of
range call the bfd error hander and use R_68K_NONE instead.
@
text
@d1083 60
d1144 1
d4828 1
@


1.115
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d377 1
a377 4
rtype_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d379 9
a387 2
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_68K_max);
  cache_ptr->howto = &howto_table[ELF32_R_TYPE(dst->r_info)];
@


1.114
log
@        * elf32-m68k.c: Rewrite initialization of GOT entries for TLS
        relocations.  Rewrite output of dynamic TLS relocations.
        (DTP_OFFSET, TP_OFFSET): New constants.
        (dtpoff_base): Update.
        (tpoff): Rename to tpoff_base, update.
        (elf_m68k_init_got_entry_static, elf_m68k_init_got_entry_local_shared):
        New functions.  Move code from elf_m68k_relocate_section here.
        (elf_m68k_relocate_section): Update.
        (elf_m68k_finish_dynamic_symbol): Fix handling of local TLS symbols.
@
text
@d1534 1
a1534 1
				enum elf_m68k_reloc_type new)
d1546 1
a1546 1
      was = new;
d1553 1
a1553 1
		  == elf_m68k_reloc_got_type (new));
d1558 2
a1559 2
  new_size = elf_m68k_reloc_got_offset_size (new);
  n_slots = elf_m68k_reloc_got_n_slots (new);
d1567 1
a1567 1
  if (new > was)
d1570 1
a1570 1
    was = new;
@


1.113
log
@        * elf32-m68k.c (elf_m68k_copy_indirect_symbol): Propagate non_got_ref
        value.
        (elf_m68k_check_relocs): Handle dynamic TLS relocations.
        Handle non_got_ref field.
        (elf_m68k_adjust_dynamic_symbol): Handle non_got_ref field.

        * tls-def-1.s, tls-def-1.d, tls-gd-1.d2, tls-gd-1.d3, tls-main-1.s,
        * tls-main-1.d: New files.
        * m68k.exp: Run new TLS tests.
@
text
@d3449 5
a3453 3
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */
d3461 1
a3461 1
  return elf_hash_table (info)->tls_sec->vma;
a3463 3
/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

d3465 1
a3465 1
tpoff (struct bfd_link_info *info, bfd_vma address)
a3466 3
  struct elf_link_hash_table *htab = elf_hash_table (info);
  bfd_vma base;

d3468 1
a3468 1
  if (htab->tls_sec == NULL)
d3470 101
a3570 2
  base = align_power ((bfd_vma) 8, htab->tls_sec->alignment_power);
  return address - htab->tls_sec->vma + base;
d3593 1
d3605 1
d3804 1
a3804 1
			   because of a version file..  We must initialize
d3814 6
a3819 20
			if (elf_m68k_reloc_got_type (r_type) == R_68K_GOT32O)
			  bfd_put_32 (output_bfd, relocation,
				      sgot->contents + off);
			else if (elf_m68k_reloc_got_type (r_type)
				 == R_68K_TLS_GD32)
			  /* Mark it as belonging to module 1,
			     the executable.  */
			  {
			    bfd_put_32 (output_bfd, 1,
					sgot->contents + off);
			    bfd_put_32 (output_bfd, (relocation
						     - dtpoff_base (info)),
					sgot->contents + off + 4);
			  }
			else if (elf_m68k_reloc_got_type (r_type)
				 == R_68K_TLS_IE32)
			  bfd_put_32 (output_bfd, tpoff (info, relocation),
				      sgot->contents + off);
			else
			  BFD_ASSERT (FALSE);
d3827 1
d3829 1
a3829 20
		    asection *srela;
		    Elf_Internal_Rela outrel;

		    srela = bfd_get_section_by_name (dynobj, ".rela.got");
		    BFD_ASSERT (srela != NULL);

		    if (elf_m68k_reloc_got_type (r_type) == R_68K_GOT32O)
		      {
			/* Emit RELATIVE relocation to initialize GOT slot
			   at run-time.  */
			outrel.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
			outrel.r_addend = relocation;
			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + off);

			elf_m68k_install_rela (output_bfd, srela, &outrel);
		      }
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_LDM32)
d3831 2
a3832 26
			/* If we don't know the module number, create
			   a relocation for it.  */
			outrel.r_info = ELF32_R_INFO (0, R_68K_TLS_DTPMOD32);
			outrel.r_addend = 0;
			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + off);

			elf_m68k_install_rela (output_bfd, srela, &outrel);
		      }
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_GD32)
		      {
			/* If we don't know the module number, create
			   a relocation for it.  */
			outrel.r_info = ELF32_R_INFO (0, R_68K_TLS_DTPMOD32);
			outrel.r_addend = 0;
			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + off);

			elf_m68k_install_rela (output_bfd, srela, &outrel);

			bfd_put_32 (output_bfd, (relocation
						 - dtpoff_base (info)),
				    sgot->contents + off + 4);
a3833 13
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_IE32)
		      {
			outrel.r_info = ELF32_R_INFO (0, R_68K_TLS_TPREL32);
			outrel.r_addend = relocation - dtpoff_base (info);
			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + off);

			elf_m68k_install_rela (output_bfd, srela, &outrel);
		      }
		    else
		      BFD_ASSERT (FALSE);
d3835 7
a3841 2
		    bfd_put_32 (output_bfd, outrel.r_addend,
				sgot->contents + off);
d3847 6
a3852 27
		    if (elf_m68k_reloc_got_type (r_type) == R_68K_GOT32O)
		      bfd_put_32 (output_bfd, relocation,
				  sgot->contents + off);
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_LDM32)
		      /* If this is a static link, put the number of the
			 only module in the GOT slot.  */
		      bfd_put_32 (output_bfd, 1, sgot->contents + off);
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_GD32)
		      {
			/* If we are not emitting relocations for a
			   general dynamic reference, then we must be in a
			   static link or an executable link with the
			   symbol binding locally.  Mark it as belonging
			   to module 1, the executable.  */
			bfd_put_32 (output_bfd, 1, sgot->contents + off);
			bfd_put_32 (output_bfd, (relocation
						 - dtpoff_base (info)),
				    sgot->contents + off + 4);
		      }
		    else if (elf_m68k_reloc_got_type (r_type)
			     == R_68K_TLS_IE32)
		      bfd_put_32 (output_bfd, tpoff (info, relocation),
				  sgot->contents + off);
		    else
		      BFD_ASSERT (FALSE);
a3881 1
		BFD_ASSERT (rel->r_addend == 0);
d3909 1
a3909 1
	    relocation = tpoff (info, relocation);
d4308 1
a4308 1
	  Elf_Internal_Rela rela;
d4311 1
a4313 4
	  rela.r_offset = (sgot->output_section->vma
			   + sgot->output_offset
			   + got_entry_offset);

d4322 1
a4322 3
	      rela.r_addend = bfd_get_signed_32 (output_bfd,
						 (sgot->contents
						  + got_entry_offset));
d4324 6
a4329 1
	      switch (elf_m68k_reloc_got_type (got_entry->key_.type))
d4332 1
a4332 1
		  rela.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
d4336 1
a4336 1
		  rela.r_info = ELF32_R_INFO (0, R_68K_TLS_DTPMOD32);
d4340 1
a4340 1
		  rela.r_info = ELF32_R_INFO (0, R_68K_TLS_TPREL32);
a4344 1
		  break;
d4347 7
a4353 1
		elf_m68k_install_rela (output_bfd, srela, &rela);
d4357 2
d4372 3
d4376 1
a4376 1
	      switch (elf_m68k_reloc_got_type (got_entry->key_.type))
@


1.112
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d2490 4
d2588 8
d2754 4
d2965 3
d3181 5
@


1.111
log
@        M68K TLS support.

        ld/testsuite/
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: Update.
        * ld-m68k/got-multigot-14-ok.d: Update.
        * ld-m68k/m68k-got.exp: Update.
        * ld-m68k/got-negative-12-13-14-34-ok.d: Update.
        * ld-m68k/got-negative-14-ok.d: Update.
        * ld-m68k/tls-gd-1.d, ld-m68k/tls-gd-2.d: New tests.
        * ld-m68k/tls-gd-ie-1.d, ld-m68k/tls-ie-1.d: New tests.
        * ld-m68k/tls-ld-1.d, ld-m68k/tls-ld-2.d: New tests.
        * ld-m68k/tls-ld-1.s, ld-m68k/tls-ld-2.s, ld-m68k/tls-le-1.s:
        New test sources.
        * ld-m68k/tls-no-1.s, ld-m68k/tls-gd-ie-1.s, ld-m68k/tls-gd-1.s:
        New test sources.
        * ld-m68k/tls-gd-2.s, ld-m68k/tls-ie-1.s: New test sources.
        * ld-m68k/m68k.exp: Run new tests.
        (merge isa-a isa-a:nodiv): Fix.

        gas/testsuite/
        * gas/m68k/tls-gd-3.d, gas/m68k/tls-gd-3.s: New test.
        * gas/m68k/all.exp: Run it.

        gas/
        * config/m68k-parse.h (enum pic_relocation): Add values for TLS
        relocations.
        * config/m68k-parse.y (yylex): Parse TLS relocations.
        * config/tc-m68k.c (m68k_elf_cons): New static function.
        (md_pseudo_table): Use it.
        (get_reloc_code, tc_m68k_fix_adjustable, tc_gen_reloc): Handle TLS
        relocations.
        (md_apply_fix): Fix to set thread local flag.
        (m68k_elf_suffix): New static function; helper for m68k_elf_cons.

        include/elf/
        * m68k.h: Map TLS relocations to numbers.

        bfd/
        * bfd-in2.h: Regenerate.
        * elf32-m68k.c: Handle 2-slot GOT entries.  Rename variables and
        fields from n_entries to n_slots where appropriate, update comments.
        (HOWTO): Add TLS relocations.
        (reloc_map): Map BFD_RELOC_68K_TLS_* to R_68K_TLS_*.
        (enum elf_m68k_got_offset_size): New enum.
        (struct elf_m68k_got_entry.type): Move field to ...
        (struct elf_m68k_got_entry_key): ... here.  Update all uses.
        (elf_m68k_reloc_got_type, elf_m68k_reloc_got_offset_size): New static
        functions.
        (elf_m68k_reloc_got_n_entries, elf_m68k_reloc_tls_p): New static
        functions.
        (struct elf_m68k_got): merge rel_8o_n_entries and rel_8o_16o_n_entries
        fields into n_entries array.  Update comments.
        (elf_m68k_init_got): Simplify, update all uses.
        (elf_m68k_init_got_entry_key): Handle R_68K_TLS_LDM32 reloc, update.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT): Adjust to handle 2-slot
        GOT entries; update name, update all uses.
        (ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): Ditto.
        (elf_m68k_get_got_entry): Update.
        (elf_m68k_update_got_entry_type): Rewrite to handle TLS GOT entries,
        simplify.
        (elf_m68k_remove_got_entry_type): Simplify.
        (elf_m68k_add_entry_to_got, elf_m68k_can_merge_gots_1): Update.
        (elf_m68k_can_merge_gots): Update.
        (elf_m68k_merge_gots_1, elf_m68k_merge_gots): Update.
        (struct elf_m68k_finalize_got_offsets_arg): Rewrite to handle 2-slot
        GOT entries, simplify.
        (elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Same.
        (struct elf_m68k_partition_multi_got_arg): Add slots_relas_diff
        field, remove obsoleted local_n_entries field.
        (elf_m68k_partition_multi_got_2): New static function.
        (elf_m68k_partition_multi_got_1, elf_m68k_partition_multi_got): Use it;
        update.
        (elf_m68k_remove_got_entry_type): Update.
        (elf_m68k_install_rela, dtpoff_base, tpoff): New static functions.
        (elf_m68k_check_relocs): Handle TLS relocations.  Remove unnecessary
        update of sgot->size and srelgot->size.
        (elf_m68k_gc_sweep_hook): Update.
        (elf_m68k_install_rela, dtpoff_base, tpoff): New static functions.
        (elf_m68k_relocate_section, elf_m68k_finish_dynamic_symbol): Handle
        TLS relocations.
        * reloc.c (BFD_RELOC_68K_TLS_*): Declare TLS relocations.
        * libbfd.h (bfd_reloc_code_real_names): Add BFD_RELOC_68K_TLS_*.
@
text
@d912 2
a913 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d992 1
a992 1
  ret->sym_sec.abfd = NULL;
d2796 1
d2798 6
a2803 3
		      s = (bfd_section_from_r_symndx
			   (abfd, &elf_m68k_hash_table (info)->sym_sec,
			    sec, r_symndx));
d2805 1
a2805 1
			return FALSE;
@


1.110
log
@* elf32-m68k.c (elf_m68k_discard_copies): Use SYMBOL_CALLS_LOCAL.
(elf_m68k_relocate_section): Use SYMBOL_CALLS_LOCAL and
SYMBOL_REFERENCES_LOCAL.
(elf_m68k_relocate_section): Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d117 257
d392 3
a394 1
} reloc_map[] = {
d421 15
d696 9
d707 3
a723 3

      /* Type is one of R_68K_GOT8O, R_68K_GOT16O or R_68K_GOT32O.  */
      int type;
d742 110
d860 2
a861 7
  /* Number of R_68K_GOT8O entries in this GOT.
     This is used to detect the overflow of number of such entries.  */
  bfd_vma rel_8o_n_entries;

  /* Cumulative count of R_68K_GOT8O and R_68K_GOT16O entries in this GOT.
     This is used to detect the overflow of number of such entries.  */
  bfd_vma rel_8o_16o_n_entries;
d863 8
a870 1
  /* Number of local (entry->key_.h == NULL) entries in this GOT.
d873 1
a873 1
  bfd_vma local_n_entries;
d1280 3
a1282 3
   GOT entry type: We have 3 types of GOT entries.
   * R_68K_GOT8O type is used in entries for symbols that have
   at least one R_68K_GOT8O relocation.  We can have at most 0x40
d1284 2
a1285 2
   * R_68K_GOT16O type is used in entries for symbols that have
   at least one R_68K_GOT16O relocation and no R_68K_GOT8O relocations.
d1287 2
a1288 2
   * R_68K_GOT32O type is used in all other cases.  We can have as many
   such entries in one GOT as we like.
d1294 2
a1295 2
   R_68K_GOT8O entries, which are followed by R_68K_GOT16O entries, and
   R_68K_GOT32O entries go at the end.  See finalize_got_offsets for details.
d1319 8
a1326 12
elf_m68k_init_got (struct elf_m68k_got *got,
		   htab_t entries,
		   bfd_vma rel_8o_n_entries,
		   bfd_vma rel_8o_16o_n_entries,
		   bfd_vma local_n_entries,
		   bfd_vma offset)
{
  got->entries = entries;
  got->rel_8o_n_entries = rel_8o_n_entries;
  got->rel_8o_16o_n_entries = rel_8o_16o_n_entries;
  got->local_n_entries = local_n_entries;
  got->offset = offset;
d1353 1
a1353 1
  elf_m68k_init_got (got, NULL, 0, 0, 0, (bfd_vma) -1);
d1363 2
a1364 1
			     const bfd *abfd, unsigned long symndx)
d1366 8
a1373 1
  if (h != NULL)
d1380 1
d1385 2
d1399 3
a1401 3
  return key->symndx + (key->bfd != NULL
			? (int) key->bfd->id
			: -1);
d1416 3
a1418 1
	  && key1->symndx == key2->symndx);
d1421 6
a1426 2
/* Maximal number of R_68K_GOT8O entries in a single GOT.  */
#define ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT(INFO)		\
d1428 1
a1428 1
   ? 0x40							\
d1431 2
a1432 2
/* Maximal number of R_68K_GOT8O and R_68K_GOT16O entries in a single GOT.  */
#define ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT(INFO)		\
d1434 1
a1434 1
   ? 0x4000							\
d1473 1
a1473 1
      got->entries = htab_try_create (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT
d1511 3
a1513 1
      entry->u.s1.type = R_68K_GOT32O;
d1531 11
a1541 5
static int
elf_m68k_update_got_entry_type (struct elf_m68k_got *got, int was, int new)
{
  if (new == R_68K_GOT8O && was != R_68K_GOT8O)
    /* NEW overrides WAS.  */
d1543 2
a1544 1
      ++got->rel_8o_n_entries;
d1546 1
a1546 3
      if (was != R_68K_GOT16O)
	/* Update this counter too.  */
	++got->rel_8o_16o_n_entries;
a1547 3
  else if (new == R_68K_GOT16O && was != R_68K_GOT8O && was != R_68K_GOT16O)
    /* NEW overrides WAS.  */
    ++got->rel_8o_16o_n_entries;
d1549 17
a1565 2
    /* NEW doesn't override WAS.  */
    new = was;
d1567 6
a1572 1
  return new;
d1578 2
a1579 1
elf_m68k_remove_got_entry_type (struct elf_m68k_got *got, int type)
d1581 2
a1582 4
  switch (type)
    {
    case R_68K_GOT8O:
      BFD_ASSERT (got->rel_8o_n_entries > 0);
d1584 1
a1584 2
      --got->rel_8o_n_entries;
      /* FALLTHRU */
d1586 5
a1590 5
    case R_68K_GOT16O:
      BFD_ASSERT (got->rel_8o_16o_n_entries >= got->rel_8o_n_entries);

      --got->rel_8o_16o_n_entries;
      /* FALLTHRU */
d1592 1
a1592 5
    case R_68K_GOT32O:
      break;

    default:
      BFD_ASSERT (FALSE);
d1604 2
a1605 1
			   int type, unsigned long symndx,
d1615 1
a1615 1
  elf_m68k_init_got_entry_key (&key_, h, abfd, symndx);
d1621 5
d1633 1
a1633 1
	++got->local_n_entries;
d1636 1
a1636 3
  /* Determine entry's type and update got->rel_*_n_entries counters.  */
  entry->u.s1.type = elf_m68k_update_got_entry_type (got, entry->u.s1.type,
						     type);
d1638 4
a1641 4
  if ((got->rel_8o_n_entries
       > ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT (info))
      || (got->rel_8o_16o_n_entries
	  > ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT (info)))
d1644 1
a1644 2
      if (got->rel_8o_n_entries
	  > ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT (info))
d1646 2
a1647 1
				 "Number of R_68K_GOT8O relocations > %d"),
d1649 1
a1649 1
			       ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT (info));
d1652 2
a1653 2
				 "Number of R_68K_GOT8O and R_68K_GOT16O "
				 "relocations > %d"),
d1655 1
a1655 1
			       ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT (info));
d1802 1
a1802 1
  int type;
d1810 1
d1812 3
a1814 2
      type = elf_m68k_update_got_entry_type (arg->diff, entry2->u.s1.type,
					     entry1->u.s1.type);
d1816 1
a1816 1
      if (type == entry2->u.s1.type)
d1820 1
a1820 1
	type = R_68K_32;
d1823 1
d1825 1
a1825 1
      BFD_ASSERT (entry1->u.s1.type != R_68K_32);
d1827 2
a1828 2
      type = elf_m68k_update_got_entry_type (arg->diff, R_68K_GOT32O,
					     entry1->u.s1.type);
a1829 1
      /* Update local counter.  */
d1831 1
a1831 1
	++arg->diff->local_n_entries;
d1834 1
a1834 1
  if (type != R_68K_32)
d1847 1
a1847 1
      entry->u.s1.type = type;
d1880 4
a1883 4
  if ((big->rel_8o_n_entries + arg_.diff->rel_8o_n_entries
       > ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT (info))
      || (big->rel_8o_16o_n_entries + arg_.diff->rel_8o_16o_n_entries
	  > ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT (info)))
d1924 1
a1924 1
  to->u.s1.type = from->u.s1.type;
d1951 4
a1954 3
      big->rel_8o_n_entries += diff->rel_8o_n_entries;
      big->rel_8o_16o_n_entries += diff->rel_8o_16o_n_entries;
      big->local_n_entries += diff->local_n_entries;
d1959 4
a1962 3
      BFD_ASSERT (diff->rel_8o_n_entries == 0);
      BFD_ASSERT (diff->rel_8o_16o_n_entries == 0);
      BFD_ASSERT (diff->local_n_entries == 0);
d1966 4
a1969 4
	      || ((big->rel_8o_n_entries
		   <= ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT (info))
		  && (big->rel_8o_16o_n_entries
		      <= ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT (info))));
d1976 5
a1980 14
  /* Offset for the next R_68K_GOT8O entry.  */
  bfd_vma rel_8o_offset;

  /* Offset for the next R_68K_GOT16O entry.  */
  bfd_vma rel_16o_offset;

  /* Offset for the next R_68K_GOT32O entry.  */
  bfd_vma rel_32o_offset;

  /* Should we use negative (relative to GP) offsets for GOT entries.  */
  bfd_boolean use_neg_got_offsets_p;

  /* Offset of this GOT relative to .got section.  */
  bfd_vma got_offset;
d1985 2
d1998 3
d2007 2
a2008 24
  switch (entry->u.s1.type)
    {
    case R_68K_GOT8O:
      entry->u.s2.offset = arg->rel_8o_offset;

      if (arg->use_neg_got_offsets_p)
	{
	  if (arg->rel_8o_offset >= arg->got_offset)
	    /* We've assigned a positive offset to this entry,
	       next entry should get (-abs(offset) - 4).  */
	    arg->rel_8o_offset = (arg->got_offset
				  - (arg->rel_8o_offset - arg->got_offset)
				  - 4);
	  else
	    /* We've assigned a negative offset to this entry,
	       next entry should get (+abs(offset) + 0).  */
	    arg->rel_8o_offset = (arg->got_offset
				  + (arg->got_offset - arg->rel_8o_offset));
	}
      else
	/* Next entry will simply get next offset.  */
	arg->rel_8o_offset += 4;

      break;
d2010 2
a2011 2
    case R_68K_GOT16O:
      entry->u.s2.offset = arg->rel_16o_offset;
d2013 23
a2035 47
      if (arg->use_neg_got_offsets_p)
	{
	  if (arg->rel_16o_offset >= arg->got_offset)
	    /* We've assigned a positive offset to this entry,
	       next entry should get (-abs(offset) - 4).  */
	    arg->rel_16o_offset = (arg->got_offset
				   - (arg->rel_16o_offset - arg->got_offset)
				   - 4);
	  else
	    /* We've assigned a negative offset to this entry,
	       next entry should get (+abs(offset) + 0).  */
	    arg->rel_16o_offset = (arg->got_offset
				   + (arg->got_offset - arg->rel_16o_offset));
	}
      else
	/* Next entry will simply get next offset.  */
	arg->rel_16o_offset += 4;

      break;

    case R_68K_GOT32O:
      entry->u.s2.offset = arg->rel_32o_offset;

      if (arg->use_neg_got_offsets_p)
	{
	  if (arg->rel_32o_offset >= arg->got_offset)
	    /* We've assigned a positive offset to this entry,
	       next entry should get (-abs(offset) - 4).  */
	    arg->rel_32o_offset = (arg->got_offset
				   - (arg->rel_32o_offset - arg->got_offset)
				   - 4);
	  else
	    /* We've assigned a negative offset to this entry,
	       next entry should get (+abs(offset) + 0).  */
	    arg->rel_32o_offset = (arg->got_offset
				   + (arg->got_offset - arg->rel_32o_offset));
	}
      else
	/* Next entry will simply get next offset.  */
	arg->rel_32o_offset += 4;

      break;

    default:
      BFD_ASSERT (FALSE);
      break;
    }
a2041 1
      BFD_ASSERT (entry->key_.symndx != 0);
d2043 11
a2053 1
      BFD_ASSERT (h != NULL);
d2055 2
a2056 2
      entry->u.s2.next = h->glist;
      h->glist = entry;
d2069 2
a2070 1
   global symbols.  */
d2075 2
a2076 1
			       struct elf_m68k_link_hash_entry **symndx2h)
d2079 4
d2088 1
a2088 1
     finish_dynamic_symbol without needing to know the GOT they come
d2091 6
d2098 7
d2106 1
d2109 2
a2110 8
      /* Put GOT pointer in the middle of GOT.  */
      n = htab_elements (got->entries);
      if ((n & 1) == 0)
	/* Even number of GOT entries.  */
	got->offset += 2 * n;
      else
	/* Odd number of GOT entries.  */
	got->offset += 2 * (n - 1);
d2112 18
a2129 2
      /* R_68K_GOT8O entries shall start at GOT offset.  */
      arg_.rel_8o_offset = got->offset;
d2131 3
a2133 27
      n = got->rel_8o_n_entries;
      if ((n & 1) == 0)
	/* Even number of R_68K_GOT8O entries.
	   The last R_68K_GOT8O entry will be at
	   (got->offset - 2 * n).  Hence the first R_68K_GOT16O
	   entry will be at offset ...  */
	arg_.rel_16o_offset = got->offset + 2 * n;
      else
	/* Odd number of R_68K_GOT8O entries.
	   The last R_68K_GOT8O entry will be at
	   (got->offset + 2 * (n - 1)).  Hence the first R_68K_GOT16O
	   entry will be at offset ...  */
	arg_.rel_16o_offset = got->offset - 2 * (n - 1) - 4;

      n = got->rel_8o_16o_n_entries;
      if ((n & 1) == 0)
	/* Even number of R_68K_GOT8O and R_68K_GOT16O entries.
	   The last R_68K_GOT8O entry will be at
	   (got->offset - 2 * n).  Hence the first R_68K_GOT32O
	   entry will be at offset ...  */
	arg_.rel_32o_offset = got->offset + 2 * n;
      else
	/* Odd number of R_68K_GOT8O and R_68K_GOT16O entries.
	   The last R_68K_GOT16O entry will be at
	   (got->offset + 2 * (n - 1)).  Hence the first R_68K_GOT32O
	   entry will be at offset ...  */
	arg_.rel_32o_offset = got->offset - 2 * (n - 1) - 4;
d2135 2
a2136 1
      arg_.use_neg_got_offsets_p = TRUE;
d2138 1
a2138 1
      arg_.got_offset = got->offset;
a2139 5
  else
    {
      arg_.rel_8o_offset = got->offset;
      arg_.rel_16o_offset = 4 * got->rel_8o_n_entries + got->offset;
      arg_.rel_32o_offset = 4 * got->rel_8o_16o_n_entries + got->offset;
d2141 6
a2146 1
      arg_.use_neg_got_offsets_p = FALSE;
d2148 3
a2150 3
      /* This shouldn't be used.  */
      arg_.got_offset = (bfd_vma) -1;
    }
d2153 1
d2155 1
d2158 3
a2160 8
  /* Calculate offset ranges we have actually assigned.  */
  if (use_neg_got_offsets_p)
    {
      if (arg_.rel_8o_offset == (bfd_vma) -4
	  || arg_.rel_8o_offset < got->offset)
	arg_.rel_8o_offset = 2 * (got->offset - arg_.rel_8o_offset) - 4;
      else
	arg_.rel_8o_offset = 2 * (arg_.rel_8o_offset - got->offset);
d2162 2
a2163 23
      if (arg_.rel_16o_offset == (bfd_vma) -4
	  || arg_.rel_16o_offset < got->offset)
	arg_.rel_16o_offset = 2 * (got->offset - arg_.rel_16o_offset) - 4;
      else
	arg_.rel_16o_offset = 2 * (arg_.rel_16o_offset - got->offset);

      if (arg_.rel_32o_offset == (bfd_vma) -4
	  || arg_.rel_32o_offset < got->offset)
	arg_.rel_32o_offset = 2 * (got->offset - arg_.rel_32o_offset) - 4;
      else
	arg_.rel_32o_offset = 2 * (arg_.rel_32o_offset - got->offset);
    }
  else
    {
      arg_.rel_8o_offset -= got->offset;
      arg_.rel_16o_offset -= got->offset;
      arg_.rel_32o_offset -= got->offset;
    }

  /* These asserts check that we got counting of entries right.  */
  BFD_ASSERT (arg_.rel_8o_offset == 4 * got->rel_8o_n_entries);
  BFD_ASSERT (arg_.rel_16o_offset == 4 * got->rel_8o_16o_n_entries);
  BFD_ASSERT (arg_.rel_32o_offset == 4 * htab_elements (got->entries));
d2177 1
a2177 1
  /* Total number of entries in the .got section.
d2179 1
a2179 1
  bfd_vma n_entries;
d2181 2
a2182 1
  /* Total number of local entries in the .got section.
d2184 1
a2184 1
  bfd_vma local_n_entries;
d2194 28
a2230 1
  struct elf_m68k_got *current_got;
d2247 1
a2247 1
      elf_m68k_init_got (diff, NULL, 0, 0, 0, (bfd_vma) -1);
d2261 1
a2261 1
	      /* Schedule to finish up CURRENT_GOT and start new one.  */
d2274 1
a2274 1
      /* Create empty CURRENT_GOT to subsequent GOTs to.  */
a2286 2
  current_got = arg->current_got;

d2289 1
a2289 1
      if (!elf_m68k_merge_gots (current_got, diff, arg->info))
d2298 1
a2298 1
      entry->got = current_got;
d2302 3
a2306 15
      arg->offset = (current_got->offset
		     + 4 * htab_elements (current_got->entries));

      /* Finish up current_got.  */
      {
	elf_m68k_finalize_got_offsets (current_got,
				       elf_m68k_hash_table (arg->info)
				       ->use_neg_got_offsets_p,
				       arg->symndx2h);

	arg->n_entries += htab_elements (current_got->entries);
	arg->local_n_entries += current_got->local_n_entries;

	BFD_ASSERT (arg->local_n_entries <= arg->n_entries);
      }
d2362 2
a2363 2
  arg_.n_entries = 0;
  arg_.local_n_entries = 0;
d2391 1
a2391 10
      {
	elf_m68k_finalize_got_offsets (arg_.current_got,
				       elf_m68k_hash_table (info)
				       ->use_neg_got_offsets_p, arg_.symndx2h);

	arg_.n_entries += htab_elements (arg_.current_got->entries);
	arg_.local_n_entries += arg_.current_got->local_n_entries;

	BFD_ASSERT (arg_.local_n_entries <= arg_.n_entries);
      }
d2403 1
a2403 1
	s->size = arg_.n_entries * 4;
d2405 1
a2405 1
	BFD_ASSERT (arg_.n_entries == 0);
d2407 2
a2408 9
      /* If we are generating a shared object, we need to
	 output a R_68K_RELATIVE reloc so that the dynamic
	 linker can adjust this GOT entry.  Overwise we
	 don't need space in .rela.got for local symbols.  */
      if (!info->shared)
	{
	  BFD_ASSERT (arg_.local_n_entries <= arg_.n_entries);
	  arg_.n_entries -= arg_.local_n_entries;
	}
d2412 1
a2412 1
	s->size = arg_.n_entries * sizeof (Elf32_External_Rela);
d2414 1
a2414 1
	BFD_ASSERT (arg_.n_entries == 0);
d2458 1
a2458 1
  elf_m68k_remove_got_entry_type (got, entry->u.s1.type);
d2461 3
a2463 1
    --got->local_n_entries;
d2566 2
d2571 13
a2653 8

		/* Allocate space in the .got section.  */
		sgot->size += 4;

		/* Allocate relocation space.  */
		if (h != NULL
		    || info->shared)
		  srelgot->size += sizeof (Elf32_External_Rela);
d2932 13
d2957 2
a2958 1
	    elf_m68k_init_got_entry_key (&key_, h, abfd, r_symndx);
d3406 44
d3612 13
d3648 2
a3649 1
	    elf_m68k_init_got_entry_key (&key_, h, input_bfd, r_symndx);
d3654 6
a3659 1
	    if (h != NULL)
d3661 7
a3667 1
		bfd_boolean dyn;
d3669 6
a3674 22
		dyn = elf_hash_table (info)->dynamic_sections_created;
		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& SYMBOL_REFERENCES_LOCAL (info, h))
		    || (ELF_ST_VISIBILITY (h->other)
			&& h->root.type == bfd_link_hash_undefweak))
		  {
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally, or the symbol was forced to be local
		       because of a version file..  We must initialize
		       this entry in the global offset table.  Since
		       the offset must always be a multiple of 4, we
		       use the least significant bit to record whether
		       we have initialized it already.

		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
d3676 34
a3709 2
			bfd_put_32 (output_bfd, relocation,
				    sgot->contents + off);
d3712 2
d3715 1
a3715 11
		else
		  unresolved_reloc = FALSE;
	      }
	    else
	      {
		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
d3717 5
a3721 1
		    bfd_put_32 (output_bfd, relocation, sgot->contents + off);
d3723 1
a3723 1
		    if (info->shared)
d3725 7
a3731 3
			asection *s;
			Elf_Internal_Rela outrel;
			bfd_byte *loc;
d3733 25
a3757 2
			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);
d3759 11
d3773 33
a3805 5
			outrel.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
			outrel.r_addend = relocation;
			loc = s->contents;
			loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d3807 6
d3818 4
a3821 1
	    if (r_type == R_68K_GOT8O
d3823 4
a3826 1
		|| r_type == R_68K_GOT32O)
d3851 23
d4069 36
d4270 3
a4272 1
	  bfd_byte *loc;
d4276 1
a4276 1
			   + (got_entry->u.s2.offset &~ (bfd_vma) 1));
d4281 1
a4281 1
	     The entry in the global offset table will already have been
a4285 1
	      rela.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
d4288 22
a4309 2
						  + (got_entry->u.s2.offset
						     &~ (bfd_vma) 1)));
d4313 12
a4324 4
	      bfd_put_32 (output_bfd, (bfd_vma) 0,
			  sgot->contents + (got_entry->u.s2.offset
					    &~ (bfd_vma) 1));
	      rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_GLOB_DAT);
d4326 26
a4353 4
	  loc = srela->contents;
	  loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

@


1.109
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d2983 1
a2983 3
  if (!h->def_regular
      || (!info->symbolic
	  && !h->forced_local))
d3206 3
a3208 4
			&& (info->symbolic
			    || h->dynindx == -1
			    || h->forced_local)
			&& h->def_regular))
d3348 3
a3353 8
	  if (h == NULL
	      || (info->shared
		  && h->forced_local))
	    break;
	  /* Fall through.  */
	case R_68K_8:
	case R_68K_16:
	case R_68K_32:
d3363 1
a3363 4
		  || (h != NULL
		      && h->dynindx != -1
		      && (!info->symbolic
			  || !h->def_regular))))
d3667 1
a3667 4
	      && (info->symbolic
		  || h->dynindx == -1
		  || h->forced_local)
	      && h->def_regular)
@


1.108
log
@	* elf32-m68k.c (elf_m68k_relocate_section): Don't ignore existing
	addend on _GLOBAL_OFFSET_TABLE_.

ld/testsuite/:
	* ld-m68k/got-1.s: New file.
	* ld-m68k/got-1.d: New dump test.
	* ld-m68k/m68k.exp: Run it.
@
text
@d2371 2
a2372 1
		  const char *name;
d2374 1
a2374 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a2375 21

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    (SEC_ALLOC
							     | SEC_LOAD
							     | SEC_HAS_CONTENTS
							     | SEC_IN_MEMORY
							     | SEC_LINKER_CREATED
							     | SEC_READONLY));
		      if (sreloc == NULL
			  || !bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.107
log
@        Multi-GOT support for m68k.

        bfd/

        * elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
        glist): New fields.
        (struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
        struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
        struct elf_m68k_multi_got): New data structures.
        (struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
        allow_multigot_p, multi_got_): New fields.
        (elf_m68k_multi_got): New macro.
        (elf_m68k_link_hash_newfunc): Initialize new fields of
        struct elf_m68k_link_hash_entry.
        (elf_m68k_link_hash_table_create): Initialize new fields of
        struct elf_m68k_link_hash_table.
        (elf_m68k_link_hash_table_free): New static function implementing hook.
        (elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
        static functions for struct elf_m68k_got.
        (elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
        elf_m68k_got_entry_eq): New static functions for
        struct elf_m68k_got_entry.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
        ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
        (enum elf_m68k_get_entry_howto): New enum.
        (elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
        elf_m68k_remove_got_entry_type): New static functions for
        struct elf_m68k_got_entry.
        (elf_m68k_add_entry_to_got): New static function.
        (elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
        elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
        functions for struct elf_m68k_bfd2got_entry.
        (struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
        elf_m68k_can_merge_gots): New traversal.
        (struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
        elf_m68k_merge_gots): Ditto.
        (struct elf_m68k_finalize_got_offsets_arg,
        elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
        (struct elf_m68k_partition_multi_got_arg,
        elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
        elf_m68k_partition_multi_got): Ditto.
        (elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
        functions.
        (elf_m68k_copy_indirect_symbol): New static function implementing
        a hook.
        (elf_m68k_check_relocs): Update to add entries to multi-GOT.
        (elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
        (elf_m68k_always_size_sections): Assign BFDs to GOTs.
        (elf_m68k_relocate_section): Update to properly handle GOT relocations.
        (elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
        of a global symbol.
        (bfd_elf_m68k_set_target_options): New function.
        (bfd_elf32_bfd_link_hash_table_free): Define hook.
        (bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
        to skip generic calculation of GOT offsets.
        (elf_backend_copy_indirect_symbol): Define hook.

        * bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
        * bfd-in2.h: Regenerate.

        ld/

        * configure.in (--enable-got): New option.  Handle it.
        * configure: Regenerate.
        * config.in: Regenerate.

        * emultempl/m68kelf.em: (got_handling_target_default): New shell
        variable.
        (GOT_HANDLING_TARGET_DEFAULT): New macro.
        (GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
        option if one was given.
        (got_handling): New static variable.
        (elf_m68k_create_output_section_statements): New static function
        implementing hook.
        (PARSE_AND_LIST_PROLOGUE): Define shell variable.
        (OPTION_GOT): New macro.
        (PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
        --got option.
        (got): New linker option.
        (PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
        for --got option.
        (PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
        option.

        * ld.texinfo: Document --got=<type> option.
        * gen-doc.texi: Add M68K.
        * NEWS: Mention the new feature.

        ld/testsuite/

        * ld-m68k/got-12.s: New file.
        * ld-m68k/got-13.s: New file.
        * ld-m68k/got-14.s: New file.
        * ld-m68k/got-15.s: New file.
        * ld-m68k/got-34.s: New file.
        * ld-m68k/got-35.s: New file.
        * ld-m68k/got-single-12-ok.d: New dump test.
        * ld-m68k/got-single-13-er.d: New dump test.
        * ld-m68k/got-negative-14-ok.d: New dump test.
        * ld-m68k/got-negative-15-er.d: New dump test.
        * ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
        * ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
        * ld-m68k/got-multigot-14-ok.d: New dump test.
        * ld-m68k/got-multigot-15-er.d: New dump test.
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
        * ld-m68k/xgot-15.s: New source.
        * ld-m68k/got-xgot-15-ok.d: New test.
        * ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
        * ld-m68k/m68k.exp: Run new tests.
@
text
@a3137 2
	      BFD_ASSERT (rel->r_addend == 0);

d3186 1
a3186 1
		  rel->r_addend = sgot_output_offset + got_offset;
@


1.106
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d270 1
a270 1
#define ISAB_PLT_ENTRY_SIZE 24 
d304 1
a304 1
#define ISAC_PLT_ENTRY_SIZE 24 
d388 3
d399 11
d414 97
d523 13
d543 3
d567 5
a571 1
    elf_m68k_hash_entry (ret)->pcrel_relocs_copied = NULL;
d599 5
d608 16
d707 1
a707 1
  
d715 1296
a2010 3
  arch_info = bfd_arch_get_compatible (ibfd, obfd, FALSE);
  if (!arch_info)
    return FALSE;
d2012 1
a2012 7
  bfd_set_arch_mach (obfd, bfd_arch_m68k, arch_info->mach);
  
  in_flags = elf_elfheader (ibfd)->e_flags;
  if (!elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      out_flags = in_flags;
d2014 3
a2016 1
  else
d2018 1
a2018 2
      out_flags = elf_elfheader (obfd)->e_flags;
      unsigned int variant_mask;
d2020 3
a2022 6
      if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	variant_mask = 0;
      else if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	variant_mask = 0;
      else if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	variant_mask = 0;
d2024 11
a2034 1
	variant_mask = EF_M68K_CF_ISA_MASK;
d2036 3
a2038 9
      in_isa = (in_flags & variant_mask);
      out_isa = (out_flags & variant_mask);
      if (in_isa > out_isa)
	out_flags ^= in_isa ^ out_isa;
      if (((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32
	   && (out_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	  || ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO
	      && (out_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32))
	out_flags = EF_M68K_FIDO;
d2040 1
a2040 1
      out_flags |= in_flags ^ in_isa;
d2042 2
a2043 1
  elf_elfheader (obfd)->e_flags = out_flags;
d2048 26
a2073 5
/* Display the flags field.  */
static bfd_boolean
elf32_m68k_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d2075 16
a2090 2
  FILE *file = (FILE *) ptr;
  flagword eflags = elf_elfheader (abfd)->e_flags;
d2092 5
a2096 1
  BFD_ASSERT (abfd != NULL && ptr != NULL);
d2098 7
a2104 2
  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);
d2106 1
a2106 1
  /* Ignore init flag - it may not be set, despite the flags field containing valid data.  */
d2108 2
a2109 2
  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2111 8
a2118 7
  if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
    fprintf (file, " [m68000]");
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
    fprintf (file, " [cpu32]");
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
    fprintf (file, " [fido]");
  else
d2120 3
a2122 2
      if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
	fprintf (file, " [cfv4e]");
d2124 2
a2125 51
      if (eflags & EF_M68K_CF_ISA_MASK)
	{
	  char const *isa = _("unknown");
	  char const *mac = _("unknown");
	  char const *additional = "";
      
	  switch (eflags & EF_M68K_CF_ISA_MASK)
	    {
	    case EF_M68K_CF_ISA_A_NODIV:
	      isa = "A";
	      additional = " [nodiv]";
	      break;
	    case EF_M68K_CF_ISA_A:
	      isa = "A";
	      break;
	    case EF_M68K_CF_ISA_A_PLUS:
	      isa = "A+";
	      break;
	    case EF_M68K_CF_ISA_B_NOUSP:
	      isa = "B";
	      additional = " [nousp]";
	      break;
	    case EF_M68K_CF_ISA_B:
	      isa = "B";
	      break;
	    case EF_M68K_CF_ISA_C:
	      isa = "C";
	      break;
	    case EF_M68K_CF_ISA_C_NODIV:
	      isa = "C";
	      additional = " [nodiv]";
	      break;
	    }
	  fprintf (file, " [isa %s]%s", isa, additional);
	  if (eflags & EF_M68K_CF_FLOAT)
	    fprintf (file, " [float]");
	  switch (eflags & EF_M68K_CF_MAC_MASK)
	    {
	    case 0:
	      mac = NULL;
	      break;
	    case EF_M68K_CF_MAC:
	      mac = "mac";
	      break;
	    case EF_M68K_CF_EMAC:
	      mac = "emac";
	      break;
	    }
	  if (mac)
	    fprintf (file, " [%s]", mac);
	}
d2127 1
a2127 2
  
  fputc ('\n', file);
a2128 2
  return TRUE;
}
a2142 1
  bfd_signed_vma *local_got_refcounts;
d2148 1
a2155 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d2161 2
d2229 1
a2229 1
	  if (h != NULL)
d2231 35
a2265 9
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1
		      && !h->forced_local)
		    {
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
			return FALSE;
		    }
d2267 3
a2269 3
		  /* Allocate space in the .got section.  */
		  sgot->size += 4;
		  /* Allocate relocation space.  */
d2271 2
a2272 9
		}
	      h->got.refcount++;
	    }
	  else
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;
a2273 21
		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->size += 4;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
			 output a R_68K_RELATIVE reloc so that the dynamic
			 linker can adjust this GOT entry.  */
		      srelgot->size += sizeof (Elf32_External_Rela);
		    }
		}
	      local_got_refcounts[r_symndx]++;
	    }
a2524 1
  bfd_signed_vma *local_got_refcounts;
d2529 1
a2539 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d2543 1
d2565 5
d2573 1
a2573 1
	  if (h != NULL)
d2575 3
a2577 24
	      if (h->got.refcount > 0)
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      if (info->shared)
			srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
d2579 20
d2652 5
a3051 1
  bfd_vma *local_got_offsets;
d3055 1
a3061 1
  local_got_offsets = elf_local_got_offsets (input_bfd);
d3067 2
d3137 58
a3194 1
	    break;
d3203 2
d3213 14
a3230 3
		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) -1);

d3257 1
a3257 1
			h->got.offset |= 1;
a3264 5
		BFD_ASSERT (local_got_offsets != NULL
			    && local_got_offsets[r_symndx] != (bfd_vma) -1);

		off = local_got_offsets[r_symndx];

d3293 1
a3293 1
		    local_got_offsets[r_symndx] |= 1;
a3296 1
	    relocation = sgot->output_offset + off;
d3301 13
d3315 1
d3319 2
a3320 1
	      relocation += sgot->output_section->vma;
d3674 1
a3674 1
  if (h->got.offset != (bfd_vma) -1)
d3678 1
a3678 2
      Elf_Internal_Rela rela;
      bfd_byte *loc;
d3687 1
a3687 3
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));
d3689 1
a3689 17
      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic
	      || h->dynindx == -1
	      || h->forced_local)
	  && h->def_regular)
	{
	  rela.r_info = ELF32_R_INFO (0, R_68K_RELATIVE);
	  rela.r_addend = bfd_get_signed_32 (output_bfd,
					     (sgot->contents
					      + (h->got.offset &~ (bfd_vma) 1)));
	}
      else
d3691 38
a3728 4
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      sgot->contents + (h->got.offset &~ (bfd_vma) 1));
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_68K_GLOB_DAT);
	  rela.r_addend = 0;
a3729 4

      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d4004 37
d4076 4
a4079 1
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link
d4096 1
@


1.105
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d1096 3
@


1.104
log
@bfd/
	* archures.c: Add bfd_mach_mcf_isa_c_nodiv,
	bfd_mach_mcf_isa_c_nodiv_mac & bfd_mach_mcf_isa_c_nodiv_emac.
	* ieee.c (ieee_write_processor): Update coldfire architecture
	list.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c (arch_info_struct): Add isa_c nodiv architectures.
	(m68k_arch_features): Likewise.
	* elf32-m68k.c (elf32_m68k_object_p): Add EF_M68K_CF_ISA_C_NODIV.
	(elf32_m68k_print_private_bfd_data): Likewise.

gas/
	* config/tc-m68k.c (m68k_ip): Add mcfisa_c case.
	(m68k_elf_final_processing): Add EF_M68K_CF_ISA_C_NODIV.

include/elf/
	* m68k.h (EF_M68K_CF_ISA_C_NODIV): New.
@
text
@d1045 3
a1047 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.103
log
@Switch sources over to use the GPL version 3
@
text
@d509 3
d664 4
@


1.102
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.101
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1217 1
  unsigned int power_of_two;
d1362 1
a1362 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (!bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.100
log
@	gas/testsuite/
	* gas/m68k/br-isaa.s: New.
	* gas/m68k/br-isaa.d: New.
	* gas/m68k/br-isab.s: New.
	* gas/m68k/br-isab.d: New.
	* gas/m68k/br-isac.s: New.
	* gas/m68k/br-isac.d: New.
	* gas/m68k/all.exp: Adjust.

	gas/
	* config/tc-m68k.c (mcf54455_ctrl): New.
	(HAVE_LONG_DISP, HAVE_LONG_CALL, HAVE_LONG_COND): New.
	(m68k_archs): Add isac.
	(m68k_cpus): Add 54455 family.
	(m68k_ip): Split Bg into Bb, Bs, Bg.
	(m68k_elf_final_processing): Add ISA_C.
	* doc/c-m68k.texi (M680x0 Options): Add isac.

	include/opcode/
	* m68k.h (mcfisa_c): New.
	(mcfusp, mcf_mask): Adjust.

	bfd/
	* archures.c (bfd_mach_mcf_isa_c, bfd_mach_mcf_isa_c_mac,
	bfd_mach_mcf_isa_c_emac): New.
	* elf32-m68k.c (ISAC_PLT_ENTRY_SIZE, elf_isac_plt0_entry,
	elf_isac_plt_entry, elf_isac_plt_info): New.
	(elf32_m68k_object_p): Add ISA_C.
	(elf32_m68k_print_private_bfd_data): Print ISA_C.
	(elf32_m68k_get_plt_info): Detect ISA_C.
	* cpu-m68k.c (arch_info): Add ISAC.
	(m68k_arch_features): Likewise,
	(bfd_m68k_compatible): ISAs B & C are not compatible.

	opcodes/
	* m68k-opc.c: Mark mcfisa_c instructions.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.99
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d303 34
d505 3
d657 3
d1188 2
@


1.98
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d177 13
d191 1
@


1.97
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): Rename to bfd_mach_fido.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Use bfd_mach_fido instead of
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Use fido_a instead of cpu32.
	(bfd_m68k_compatible): Reject the combination of Fido and
	ColdFire.  Accept the combination of CPU32 and Fido with a
	warning.
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_merge_private_bfd_data,
	elf32_m68k_print_private_bfd_data): Treat Fido as an
	architecture by itself.

binutils/
	* readelf.c (get_machine_flags): Treat Fido as an architecture
	by itself.

gas/
	* config/tc-m68k.c (m68k_archs, m68k_cpus): Treat Fido as an
	architecture by itself.
	(m68k_ip): Don't issue a warning for tbl instructions on fido.
	(m68k_elf_final_processing): Treat Fido as an architecture by
	itself.

include/elf/
	* m68k.h (EF_M68K_FIDO): New.
	(EF_M68K_ARCH_MASK): OR EF_M68K_FIDO.
	(EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): Remove.

include/opcode/
	* m68k.h (m68010up): OR fido_a.

opcodes/
	* m68k-opc.c (m68k_opcodes): Replace cpu32 with
	cpu32 | fido_a except on tbl instructions.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
a1567 3
  if (info->relocatable)
    return TRUE;

d1622 14
@


1.96
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

gas/
	* config/tc-m68k.c (cpu_of_arch): Add fido.
	(m68k_archs, m68k_cpu): Add entries for fido.
	(m68k_elf_final_processing): Handle EF_M68K_CPU32_FIDO_A.

include/elf/
	* m68k.h (EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): New.

include/opcode/
	* m68k.h (fido_a): New.
@
text
@d435 3
a437 8
    {
      features |= cpu32;
      switch (eflags & EF_M68K_CPU32_MASK)
	{
        case EF_M68K_CPU32_FIDO_A:
	  features |= fido_a; break;
	}
    }
d528 3
a530 1
	variant_mask = EF_M68K_CPU32_MASK;
d538 6
d573 3
a575 5
    {
      fprintf (file, " [cpu32]");
      if (eflags & EF_M68K_CPU32_FIDO_A)
	fprintf (file, " [fido]");
    }
@


1.95
log
@bfd/
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_print_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

include/elf/
	* m68k.h (EF_M68K_ARCH_MASK): New.
@
text
@d435 8
a442 1
    features |= cpu32;
d533 1
a533 1
	variant_mask = 0;
d570 5
a574 1
    fprintf (file, " [cpu32]");
@


1.94
log
@bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

binutils/
	* readelf.c: Update uses of EF_M68K_*.

gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d432 1
a432 1
  if (eflags & EF_M68K_M68000)
d434 1
a434 1
  else if (eflags & EF_M68K_CPU32)
d436 1
a436 1
  else if (eflags & EF_M68K_CF_ISA_MASK)
d521 11
a531 2
      in_isa = (in_flags & EF_M68K_CF_ISA_MASK);
      out_isa = (out_flags & EF_M68K_CF_ISA_MASK);
d560 3
a562 1
  if (eflags & EF_M68K_CPU32)
d564 4
d569 5
a573 11
  if (eflags & EF_M68K_M68000)
    fprintf (file, " [m68000]");

  if (eflags & EF_M68K_CFV4E)
    fprintf (file, " [cfv4e]");

  if (eflags & EF_M68K_CF_ISA_MASK)
    {
      char const *isa = _("unknown");
      char const *mac = _("unknown");
      char const *additional = "";
d575 37
a611 34
      switch (eflags & EF_M68K_CF_ISA_MASK)
	{
	case EF_M68K_CF_ISA_A_NODIV:
	  isa = "A";
	  additional = " [nodiv]";
	  break;
	case EF_M68K_CF_ISA_A:
	  isa = "A";
	  break;
	case EF_M68K_CF_ISA_A_PLUS:
	  isa = "A+";
	  break;
	case EF_M68K_CF_ISA_B_NOUSP:
	  isa = "B";
	  additional = " [nousp]";
	  break;
	case EF_M68K_CF_ISA_B:
	  isa = "B";
	  break;
	}
      fprintf (file, " [isa %s]%s", isa, additional);
      if (eflags & EF_M68K_CF_FLOAT)
	fprintf (file, " [float]");
      switch (eflags & EF_M68K_CF_MAC_MASK)
	{
	case 0:
	  mac = NULL;
	  break;
	case EF_M68K_CF_MAC:
	  mac = "mac";
	  break;
	case EF_M68K_CF_EMAC:
	  mac = "emac";
	  break;
a612 2
      if (mac)
	fprintf (file, " [%s]", mac);
@


1.93
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d436 1
a436 1
  else if (eflags & EF_M68K_ISA_MASK)
d438 1
a438 1
      switch (eflags & EF_M68K_ISA_MASK)
d440 1
a440 1
	case EF_M68K_ISA_A_NODIV:
d443 1
a443 1
	case EF_M68K_ISA_A:
d446 1
a446 1
	case EF_M68K_ISA_A_PLUS:
d449 1
a449 1
	case EF_M68K_ISA_B_NOUSP:
d452 1
a452 1
	case EF_M68K_ISA_B:
d456 1
a456 1
      switch (eflags & EF_M68K_MAC_MASK)
d458 1
a458 1
	case EF_M68K_MAC:
d461 1
a461 1
	case EF_M68K_EMAC:
d465 1
a465 1
      if (eflags & EF_M68K_FLOAT)
d521 2
a522 2
      in_isa = (in_flags & EF_M68K_ISA_MASK);
      out_isa = (out_flags & EF_M68K_ISA_MASK);
d560 1
a560 1
  if (eflags & EF_M68K_ISA_MASK)
d566 1
a566 1
      switch (eflags & EF_M68K_ISA_MASK)
d568 1
a568 1
	case EF_M68K_ISA_A_NODIV:
d572 1
a572 1
	case EF_M68K_ISA_A:
d575 1
a575 1
	case EF_M68K_ISA_A_PLUS:
d578 1
a578 1
	case EF_M68K_ISA_B_NOUSP:
d582 1
a582 1
	case EF_M68K_ISA_B:
d587 1
a587 1
      if (eflags & EF_M68K_FLOAT)
d589 1
a589 1
      switch (eflags & EF_M68K_MAC_MASK)
d594 1
a594 1
	case EF_M68K_MAC:
d597 1
a597 1
	case EF_M68K_EMAC:
@


1.92
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d1836 2
a1841 1
		      outrel.r_addend = relocation + rel->r_addend;
d1858 5
d1865 8
a1872 1
			  BFD_ASSERT (indx > 0);
a1875 1
		      outrel.r_addend = relocation + rel->r_addend;
d2433 1
@


1.91
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@a39 6
static asection *elf_m68k_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf_m68k_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d977 5
a981 6
elf_m68k_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d984 6
a989 24
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_68K_GNU_VTINHERIT:
	case R_68K_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d991 1
a991 1
  return NULL;
d997 4
a1000 5
elf_m68k_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
@


1.90
log
@bfd/
	* elf32-m68k.c (elf_m68k_plt_info): New structure.
	(elf_m68k_plt0_entry): Add R_68K_PC32-style in-place addends.
	(elf_m68k_plt_entry): Likewise.
	(elf_m68k_plt_info): New table.
	(CFV4E_PLT_ENTRY_SIZE): Rename to...
	(ISAB_PLT_ENTRY_SIZE): ...this.
	(CFV4E_FLAG): Delete.
	(elf_cfv4e_plt0_entry): Rename to...
	(elf_isab_plt0_entry): ...this.  Adjust comments.  Use (-6,%pc,%d0)
	for the second instruction too.
	(elf_cfv4e_plt_entry): Rename to...
	(elf_isab_plt_entry): ...this.  Adjust comments and use (-6,%pc,%d0).
	(elf_isab_plt_info): New table.
	(CPU32_FLAG): Delete.
	(PLT_CPU32_ENTRY_SIZE): Rename to...
	(CPU32_PLT_ENTRY_SIZE): ...this.
	(elf_cpu32_plt0_entry): Update bounds accordingly.  Add R_68K_PC32-
	style in-place addends.
	(elf_cpu32_plt_entry): Likewise.
	(elf_cpu32_plt_info): New table.
	(elf_m68k_link_hash_table): Add a plt_info field.
	(elf_m68k_link_hash_table_create): Initialize it.
	(elf_m68k_get_plt_info): New function.
	(elf_m68k_always_size_sections): Likewise.
	(elf_m68k_adjust_dynamic_symbol): Use the plt_info hash table field.
	(elf_m68k_install_pc32): New function.
	(elf_m68k_finish_dynamic_symbol): Factor code using plt_info and
	elf_m68k_install_pc32.
	(elf_m68k_finish_dynamic_sections): Likewise.
	(elf_m68k_plt_sym_val): Use elf_m68k_get_plt_info.
	(elf_backend_always_size_sections): Define.

ld/testsuite/
	* ld-m68k/plt1.s, ld-m68k/plt1-empty.s, ld-m68k/plt1.ld: New files.
	* ld-m68k/plt1-68020.d, ld-m68k/plt1-cpu32.d: Likewise.
	* ld-m68k/plt1-isab.d: Likewise.
	* ld-m68k/m68k.exp: Run new PLT tests.
@
text
@d867 1
a867 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d1405 1
a1405 1
      else if (strncmp (name, ".rela", 5) == 0)
d1416 1
a1416 1
      else if (strncmp (name, ".got", 4) != 0
@


1.89
log
@bfd/
	* cpu-m68k.c (bfd_m68k_compatible): Treat ISA A+ and ISA B code as
	incompatible.  Likewise MAC and EMAC code.
	* elf32-m68k.c (elf32_m68k_merge_private_bfd_data): Use
	bfd_get_compatible to set the new bfd architecture.  Rely on it
	to detect incompatibilities.

gas/
	* config/tc-m68k.c (m68k_cpus): Change cpu_cf5208 entries to use
	mcfemac instead of mcfmac.

ld/testsuite/
	* ld-m68k/merge-error-1a.s, ld-m68k/merge-error-1b.s,
	* ld-m68k/merge-error-1a.d, ld-m68k/merge-error-1b.d,
	* ld-m68k/merge-error-1c.d, ld-m68k/merge-error-1d.d,
	* ld-m68k/merge-error-1e.d, ld-m68k/merge-ok-1a.d,
	* ld-m68k/merge-ok-1b.d: New tests.
	* ld-m68k/m68k.exp: Run them.
@
text
@d193 34
d237 1
a237 1
  0, 0, 0, 0,		  /* replaced with offset to .got + 4.  */
d239 1
a239 1
  0, 0, 0, 0,		  /* replaced with offset to .got + 8.  */
d248 1
a248 1
  0, 0, 0, 0,		  /* replaced with offset to symbol's .got entry.  */
d250 1
a250 1
  0, 0, 0, 0,		  /* replaced with offset into relocation table.  */
d252 1
a252 1
  0, 0, 0, 0		  /* replaced with offset to start of .plt.  */
d255 5
d261 1
a261 3
#define CFV4E_PLT_ENTRY_SIZE 24 

#define CFV4E_FLAG(abfd)  (elf_elfheader (abfd)->e_flags & EF_M68K_CFV4E)
d263 1
a263 1
static const bfd_byte elf_cfv4e_plt0_entry[CFV4E_PLT_ENTRY_SIZE] =
d265 6
a270 6
  0x20, 0x3c,
  0, 0, 0, 0,             /* Replaced with offset to .got + 4.  */
  0x2f, 0x3b, 0x08, 0xfa, /* move.l (%pc,addr),-(%sp) */
  0x20, 0x3c,
  0, 0, 0, 0,             /* Replaced with offset to .got + 8.  */
  0x20, 0x7b, 0x08, 0x00, /* move.l (%pc,%d0:l), %a0 */
d277 1
a277 1
static const bfd_byte elf_cfv4e_plt_entry[CFV4E_PLT_ENTRY_SIZE] =
d279 3
a281 3
  0x20, 0x3c,
  0, 0, 0, 0,             /* Replaced with offset to symbol's .got entry.  */
  0x20, 0x7b, 0x08, 0x00, /* move.l (%pc,%d0:l), %a0 */
d284 1
a284 1
  0, 0, 0, 0,             /* Replaced with offset into relocation table.  */
d286 1
a286 1
  0, 0, 0, 0              /* Replaced with offset to start of .plt.  */
d289 5
a293 1
#define CPU32_FLAG(abfd)  (elf_elfheader (abfd)->e_flags & EF_M68K_CPU32)
d295 1
a295 1
#define PLT_CPU32_ENTRY_SIZE 24
d297 1
a297 1
static const bfd_byte elf_cpu32_plt0_entry[PLT_CPU32_ENTRY_SIZE] =
d300 1
a300 1
  0, 0, 0, 0,             /* replaced with offset to .got + 4.  */
d302 1
a302 1
  0, 0, 0, 0,             /* replace with offset to .got +8.  */
d308 1
a308 1
static const bfd_byte elf_cpu32_plt_entry[PLT_CPU32_ENTRY_SIZE] =
d311 1
a311 1
  0, 0, 0, 0,              /* replaced with offset to symbol's .got entry.  */
d314 1
a314 1
  0, 0, 0, 0,              /* replaced with offset into relocation table.  */
d316 1
a316 1
  0, 0, 0, 0,              /* replaced with offset to start of .plt.  */
d320 6
d365 4
d424 1
d1125 26
d1163 1
d1168 1
d1218 1
a1218 8
	{
	  if (CPU32_FLAG (dynobj))
	    s->size += PLT_CPU32_ENTRY_SIZE;
	  else if (CFV4E_FLAG (dynobj))
	    s->size += CFV4E_PLT_ENTRY_SIZE;
	  else
	    s->size += PLT_ENTRY_SIZE;
	}
d1235 1
a1235 6
      if (CPU32_FLAG (dynobj))
        s->size += PLT_CPU32_ENTRY_SIZE;
      else if (CFV4E_FLAG (dynobj))
	s->size += CFV4E_PLT_ENTRY_SIZE;
      else
        s->size += PLT_ENTRY_SIZE;
d1980 15
a2005 1
  int plt_off1, plt_off2, plt_off3;
d2011 1
d2025 1
d2035 1
a2035 6
      if (CPU32_FLAG (output_bfd))
        plt_index = (h->plt.offset / PLT_CPU32_ENTRY_SIZE) - 1;
      else if (CFV4E_FLAG (output_bfd))
	plt_index = (h->plt.offset / CFV4E_PLT_ENTRY_SIZE) - 1;
      else
        plt_index = (h->plt.offset / PLT_ENTRY_SIZE) - 1;
d2042 8
a2049 26
      if (CPU32_FLAG (output_bfd))
        {
          /* Fill in the entry in the procedure linkage table.  */
          memcpy (splt->contents + h->plt.offset, elf_cpu32_plt_entry,
	          PLT_CPU32_ENTRY_SIZE);
          plt_off1 = 4;
          plt_off2 = 12;
          plt_off3 = 18;
        }
      else if (CFV4E_FLAG (output_bfd))
        {
          memcpy (splt->contents + h->plt.offset, elf_cfv4e_plt_entry,
	          CFV4E_PLT_ENTRY_SIZE);
          plt_off1 = 2;
          plt_off2 = 14;
          plt_off3 = 20;
	}
      else
        {
          /* Fill in the entry in the procedure linkage table.  */
          memcpy (splt->contents + h->plt.offset, elf_m68k_plt_entry,
	          PLT_ENTRY_SIZE);
          plt_off1 = 4;
          plt_off2 = 10;
          plt_off3 = 16;
        }
d2051 4
a2054 9
      /* The offset is relative to the first extension word.  */
      bfd_put_32 (output_bfd,
		  sgot->output_section->vma
		  + sgot->output_offset
		  + got_offset
		  - (splt->output_section->vma
		     + h->plt.offset
		     + (CFV4E_FLAG (output_bfd) ? 8 : 2)),
		  splt->contents + h->plt.offset + plt_off1);
d2056 2
a2057 4
      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		  splt->contents + h->plt.offset + plt_off2);
      bfd_put_32 (output_bfd, - (h->plt.offset + plt_off3),
		  splt->contents + h->plt.offset + plt_off3);
d2064 1
a2064 1
		   + (CFV4E_FLAG (output_bfd) ? 12 : 8)),
d2242 17
a2258 48
	  if (CFV4E_FLAG (output_bfd))
           {
	     memcpy (splt->contents, elf_cfv4e_plt0_entry, CFV4E_PLT_ENTRY_SIZE);
             bfd_put_32 (output_bfd,
                         (sgot->output_section->vma
                          + sgot->output_offset + 4
                          - (splt->output_section->vma + 2)),
                         splt->contents + 2);
             bfd_put_32 (output_bfd,
                         (sgot->output_section->vma
                          + sgot->output_offset + 8
                          - (splt->output_section->vma + 10) - 8),
                         splt->contents + 12);
             elf_section_data (splt->output_section)->this_hdr.sh_entsize
	       = CFV4E_PLT_ENTRY_SIZE;
           }
	  else if (CPU32_FLAG (output_bfd))
            {
              memcpy (splt->contents, elf_cpu32_plt0_entry, PLT_CPU32_ENTRY_SIZE);
	      bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 4
		           - (splt->output_section->vma + 2)),
		          splt->contents + 4);
	      bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 8
		           - (splt->output_section->vma + 10)),
		          splt->contents + 12);
              elf_section_data (splt->output_section)->this_hdr.sh_entsize
               = PLT_CPU32_ENTRY_SIZE;
            }
          else
            {
	      memcpy (splt->contents, elf_m68k_plt0_entry, PLT_ENTRY_SIZE);
	      bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 4
		           - (splt->output_section->vma + 2)),
		          splt->contents + 4);
	      bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 8
		           - (splt->output_section->vma + 10)),
		          splt->contents + 12);
              elf_section_data (splt->output_section)->this_hdr.sh_entsize
               = PLT_ENTRY_SIZE;
            }
d2427 1
a2427 3
  if (CPU32_FLAG (plt->owner))
    return plt->vma + (i + 1) * PLT_CPU32_ENTRY_SIZE;
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
d2441 2
@


1.88
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d449 3
a451 1
  unsigned in_mach, out_mach;
d457 8
a464 24
  in_mach = bfd_get_mach (ibfd);
  out_mach = bfd_get_mach (obfd);
  if (!out_mach || !in_mach)
    /* One is unknown, copy the input machine.  */
    out_mach = in_mach;
  else if (in_mach != out_mach)
    {
      if (in_mach <= bfd_mach_m68060 && out_mach <= bfd_mach_m68060)
	{
	  /* Merge m68k machine. */
	  if (in_mach > out_mach)
	    out_mach = in_mach;
	}
      else if (in_mach >= bfd_mach_mcf_isa_a_nodiv
	       && out_mach >= bfd_mach_mcf_isa_a_nodiv)
	/* Merge cf machine.  */
	out_mach = bfd_m68k_features_to_mach
	  (bfd_m68k_mach_to_features (in_mach)
	   | bfd_m68k_mach_to_features (out_mach));
      else
	/* They are incompatible.  */
	return FALSE;
    }
  bfd_set_arch_mach (obfd, bfd_arch_m68k, out_mach);
d466 1
a466 3
  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

d474 6
a479 48
      flagword isa_in = in_flags & EF_M68K_ISA_MASK;
      flagword isa_out = out_flags & EF_M68K_ISA_MASK;
      
      
      /* Copy legacy flags.  */
      out_flags |= in_flags & (EF_M68K_CPU32 | EF_M68K_M68000 | EF_M68K_CFV4E);

      if ((isa_in | isa_out)
	  && ((in_flags | out_flags) & (EF_M68K_CPU32 | EF_M68K_M68000)))
	/* Mixing m68k and cf is not allowed */
	return FALSE;
      
      if (isa_in)
	{
	  if (isa_out)
	    {
	      if (isa_out == EF_M68K_ISA_A_PLUS
		  && (isa_in == EF_M68K_ISA_B_NOUSP
		      || isa_in == EF_M68K_ISA_B))
		/* Cannot mix A+ and B */
		return FALSE;
	      if (isa_in == EF_M68K_ISA_A_PLUS
		  && (isa_out == EF_M68K_ISA_B_NOUSP
		      || isa_out == EF_M68K_ISA_B))
		/* Cannot mix B and A+ */
		return FALSE;
	      
	      if (isa_in > isa_out)
		out_flags ^= isa_in ^ isa_out;

	      out_flags |= in_flags & EF_M68K_FLOAT;
	      if (in_flags & EF_M68K_MAC_MASK)
		{
		  if (!(out_flags & EF_M68K_MAC_MASK))
		    out_flags |= in_flags & EF_M68K_MAC_MASK;
		  else if ((out_flags & EF_M68K_MAC_MASK)
			   != (in_flags & EF_M68K_MAC_MASK))
		    /* Cannot mix MACs */
		    return FALSE;
		}
	    }
	  else
	    {
	      /* Copy the coldfire bits.  */
	      out_flags &= ~EF_M68K_CF_MASK;
	      out_flags |= in_flags & EF_M68K_CF_MASK;
	    }
	}
@


1.88.2.1
log
@bfd/
	* cpu-m68k.c (bfd_m68k_compatible): Treat ISA A+ and ISA B code as
	incompatible.  Likewise MAC and EMAC code.
	* elf32-m68k.c (elf32_m68k_merge_private_bfd_data): Use
	bfd_get_compatible to set the new bfd architecture.  Rely on it
	to detect incompatibilities.

gas/
	* config/tc-m68k.c (m68k_cpus): Change cpu_cf5208 entries to use
	mcfemac instead of mcfmac.

ld/testsuite/
	* ld-m68k/merge-error-1a.s, ld-m68k/merge-error-1b.s,
	* ld-m68k/merge-error-1a.d, ld-m68k/merge-error-1b.d,
	* ld-m68k/merge-error-1c.d, ld-m68k/merge-error-1d.d,
	* ld-m68k/merge-error-1e.d, ld-m68k/merge-ok-1a.d,
	* ld-m68k/merge-ok-1b.d: New tests.
	* ld-m68k/m68k.exp: Run them.
@
text
@d449 1
a449 3
  flagword out_isa;
  flagword in_isa;
  const bfd_arch_info_type *arch_info;
d455 27
a481 6
  /* Get the merged machine.  This checks for incompatibility between
     Coldfire & non-Coldfire flags, incompability between different
     Coldfire ISAs, and incompability between different MAC types.  */
  arch_info = bfd_arch_get_compatible (ibfd, obfd, FALSE);
  if (!arch_info)
    return FALSE;
a482 3
  bfd_set_arch_mach (obfd, bfd_arch_m68k, arch_info->mach);
  
  in_flags = elf_elfheader (ibfd)->e_flags;
d490 48
a537 6
      out_flags = elf_elfheader (obfd)->e_flags;
      in_isa = (in_flags & EF_M68K_ISA_MASK);
      out_isa = (out_flags & EF_M68K_ISA_MASK);
      if (in_isa > out_isa)
	out_flags ^= in_isa ^ out_isa;
      out_flags |= in_flags ^ in_isa;
@


1.88.2.2
log
@bfd/
	* elf32-m68k.c (elf_m68k_pcrel_insn): New structure.
	(elf_m68k_plt_info): Likewise.
	(elf_m68k_plt_info): New table.
	(CFV4E_PLT_ENTRY_SIZE): Rename to...
	(ISAB_PLT_ENTRY_SIZE): ...this.
	(CFV4E_FLAG): Delete.
	(elf_cfv4e_plt0_entry): Rename to...
	(elf_isab_plt0_entry): ...this.  Adjust comments.  Use (-6,%pc,%d0)
	for the second instruction too.
	(elf_cfv4e_plt_entry): Rename to...
	(elf_isab_plt_entry): ...this.  Adjust comments and use (-6,%pc,%d0).
	(elf_isab_plt_info): New table.
	(CPU32_FLAG): Delete.
	(PLT_CPU32_ENTRY_SIZE): Rename to...
	(CPU32_PLT_ENTRY_SIZE): ...this.
	(elf_cpu32_plt0_entry): Update bounds accordingly.
	(elf_cpu32_plt_entry): Likewise.
	(elf_cpu32_plt_info): New table.
	(elf_m68k_link_hash_table): Add a plt_info field.
	(elf_m68k_link_hash_table_create): Initialize it.
	(elf_m68k_get_plt_info): New function.
	(elf_m68k_always_size_sections): Likewise.
	(elf_m68k_adjust_dynamic_symbol): Use the plt_info hash table field.
	(elf_m68k_install_pcrel_field): New function.
	(elf_m68k_finish_dynamic_symbol): Factor code using plt_info and
	elf_m68k_install_pcrel_field.
	(elf_m68k_finish_dynamic_sections): Likewise.
	(elf_m68k_plt_sym_val): Use elf_m68k_get_plt_info.
	(elf_backend_always_size_sections): Define.
@
text
@a192 40
/* An instruction that contains a 32-bit PC-relative offset.  */

struct elf_m68k_pcrel_insn
{
  /* The address of the instruction.  */
  bfd_vma addr;

  /* The offset of the PC-relative offset.  */
  bfd_vma field_offset;
};

/* Describes one of the PLT styles.  */

struct elf_m68k_plt_info
{
  /* The size of each entry.  */
  bfd_vma size;

  /* The template for the first PLT entry.  */
  const bfd_byte *plt0_entry;

  /* The PLT0_ENTRY instructions that contain PC-relative
     .got + 4 and .got + 8 fields.  */
  struct elf_m68k_pcrel_insn plt0_got4_ptr;
  struct elf_m68k_pcrel_insn plt0_got8_ptr;

  /* The template for a symbol's PLT entry.  */
  const bfd_byte *symbol_entry;

  /* The SYMBOL_ENTRY instruction that contains the PC-relative
     .got.plt field.  */
  struct elf_m68k_pcrel_insn symbol_got_ptr;

  /* The offset of the resolver stub from the start of SYMBOL_ENTRY.  */
  bfd_vma symbol_resolve_entry;

  /* The SYMBOL_ENTRY instruction that branches to .plt.  */
  struct elf_m68k_pcrel_insn symbol_plt_ptr;
};

a220 5
static const struct elf_m68k_plt_info elf_m68k_plt_info = {
  PLT_ENTRY_SIZE,
  elf_m68k_plt0_entry, { 0, 4 }, { 8, 4 },
  elf_m68k_plt_entry, { 0, 4 }, 8, { 14, 2 }
};
d222 3
a224 1
#define ISAB_PLT_ENTRY_SIZE 24 
d226 1
a226 1
static const bfd_byte elf_isab_plt0_entry[ISAB_PLT_ENTRY_SIZE] =
d228 6
a233 6
  0x20, 0x3c,             /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* replaced with .got + 4 - . */
  0x2f, 0x3b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l),-(%sp) */
  0x20, 0x3c,		  /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* replaced with .got + 8 - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
d240 1
a240 1
static const bfd_byte elf_isab_plt_entry[ISAB_PLT_ENTRY_SIZE] =
d242 3
a244 3
  0x20, 0x3c,             /* move.l #offset,%d0 */
  0, 0, 0, 0,             /* replaced with (.got entry) - . */
  0x20, 0x7b, 0x08, 0xfa, /* move.l (-6,%pc,%d0:l), %a0 */
d247 1
a247 1
  0, 0, 0, 0,             /* replaced with offset into relocation table */
d249 1
a249 1
  0, 0, 0, 0              /* replaced with .plt - . */
d252 1
a252 5
static const struct elf_m68k_plt_info elf_isab_plt_info = {
  ISAB_PLT_ENTRY_SIZE,
  elf_isab_plt0_entry, { 0, 2 }, { 10, 2 },
  elf_isab_plt_entry, { 0, 2 }, 12, { 18, 2 }
};
d254 1
a254 1
#define CPU32_PLT_ENTRY_SIZE 24
d256 1
a256 1
static const bfd_byte elf_cpu32_plt0_entry[CPU32_PLT_ENTRY_SIZE] =
d267 1
a267 1
static const bfd_byte elf_cpu32_plt_entry[CPU32_PLT_ENTRY_SIZE] =
a278 6
static const struct elf_m68k_plt_info elf_cpu32_plt_info = {
  CPU32_PLT_ENTRY_SIZE,
  elf_cpu32_plt0_entry, { 0, 4 }, { 8, 4 },
  elf_cpu32_plt_entry, { 0, 4 }, 10, { 16, 2 }
};

a317 4

  /* The PLT format used by this link, or NULL if the format has not
     yet been chosen.  */
  const struct elf_m68k_plt_info *plt_info;
a372 1
  ret->plt_info = NULL;
a1072 26

/* Return the type of PLT associated with OUTPUT_BFD.  */

static const struct elf_m68k_plt_info *
elf_m68k_get_plt_info (bfd *output_bfd)
{
  unsigned int features;

  features = bfd_m68k_mach_to_features (bfd_get_mach (output_bfd));
  if (features & cpu32)
    return &elf_cpu32_plt_info;
  if (features & mcfisa_b)
    return &elf_isab_plt_info;
  return &elf_m68k_plt_info;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.
   It's a convenient place to determine the PLT style.  */

static bfd_boolean
elf_m68k_always_size_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  elf_m68k_hash_table (info)->plt_info = elf_m68k_get_plt_info (output_bfd);
  return TRUE;
}
a1084 1
  struct elf_m68k_link_hash_table *htab;
a1088 1
  htab = elf_m68k_hash_table (info);
d1138 8
a1145 1
	s->size = htab->plt_info->size;
d1162 6
a1167 1
      s->size += htab->plt_info->size;
a1911 15
/* Make the PC-relative field of INSN point to VALUE.  The instruction
   is located in section SEC and is displaced by an extra OFFSET bytes
   from the start of that section.  (This offset applies on top of the
   one in INSN itself.)  */

static void
elf_m68k_install_pcrel_field (asection *sec, bfd_vma offset,
			      const struct elf_m68k_pcrel_insn *insn,
			      bfd_vma value)
{
  bfd_put_32 (sec->owner,
	      value - (sec->output_section->vma + offset + insn->addr + 2),
	      sec->contents + offset + insn->addr + insn->field_offset);
}

d1923 1
a1928 1
      const struct elf_m68k_plt_info *plt_info;
a1941 1
      plt_info = elf_m68k_hash_table (info)->plt_info;
d1951 6
a1956 1
      plt_index = (h->plt.offset / plt_info->size) - 1;
d1963 36
a1998 9
      memcpy (splt->contents + h->plt.offset,
	      plt_info->symbol_entry,
	      plt_info->size);

      elf_m68k_install_pcrel_field (splt, h->plt.offset,
				    &plt_info->symbol_got_ptr,
				    (sgot->output_section->vma
				     + sgot->output_offset
				     + got_offset));
d2001 3
a2003 7
		  splt->contents
		  + h->plt.offset
		  + plt_info->symbol_resolve_entry + 2);

      elf_m68k_install_pcrel_field (splt, h->plt.offset,
				    &plt_info->symbol_plt_ptr,
				    splt->output_section->vma);
d2010 1
a2010 1
		   + plt_info->symbol_resolve_entry),
d2188 48
a2235 17
	  const struct elf_m68k_plt_info *plt_info;

	  plt_info = elf_m68k_hash_table (info)->plt_info;
	  memcpy (splt->contents, plt_info->plt0_entry, plt_info->size);

	  elf_m68k_install_pcrel_field (splt, 0, &plt_info->plt0_got4_ptr,
					(sgot->output_section->vma
					 + sgot->output_offset
					 + 4));

	  elf_m68k_install_pcrel_field (splt, 0, &plt_info->plt0_got8_ptr,
					(sgot->output_section->vma
					 + sgot->output_offset
					 + 8));

	  elf_section_data (splt->output_section)->this_hdr.sh_entsize
	    = plt_info->size;
d2404 3
a2406 1
  return plt->vma + (i + 1) * elf_m68k_get_plt_info (plt->owner)->size;
a2419 2
#define elf_backend_always_size_sections \
					elf_m68k_always_size_sections
@


1.88.2.3
log
@	bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

	binutils/
	* readelf.c: Update uses of EF_M68K_*.

	gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

	include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d448 1
a448 1
  else if (eflags & EF_M68K_CF_ISA_MASK)
d450 1
a450 1
      switch (eflags & EF_M68K_CF_ISA_MASK)
d452 1
a452 1
	case EF_M68K_CF_ISA_A_NODIV:
d455 1
a455 1
	case EF_M68K_CF_ISA_A:
d458 1
a458 1
	case EF_M68K_CF_ISA_A_PLUS:
d461 1
a461 1
	case EF_M68K_CF_ISA_B_NOUSP:
d464 1
a464 1
	case EF_M68K_CF_ISA_B:
d468 1
a468 1
      switch (eflags & EF_M68K_CF_MAC_MASK)
d470 1
a470 1
	case EF_M68K_CF_MAC:
d473 1
a473 1
	case EF_M68K_CF_EMAC:
d477 1
a477 1
      if (eflags & EF_M68K_CF_FLOAT)
d533 2
a534 2
      in_isa = (in_flags & EF_M68K_CF_ISA_MASK);
      out_isa = (out_flags & EF_M68K_CF_ISA_MASK);
d572 1
a572 1
  if (eflags & EF_M68K_CF_ISA_MASK)
d578 1
a578 1
      switch (eflags & EF_M68K_CF_ISA_MASK)
d580 1
a580 1
	case EF_M68K_CF_ISA_A_NODIV:
d584 1
a584 1
	case EF_M68K_CF_ISA_A:
d587 1
a587 1
	case EF_M68K_CF_ISA_A_PLUS:
d590 1
a590 1
	case EF_M68K_CF_ISA_B_NOUSP:
d594 1
a594 1
	case EF_M68K_CF_ISA_B:
d599 1
a599 1
      if (eflags & EF_M68K_CF_FLOAT)
d601 1
a601 1
      switch (eflags & EF_M68K_CF_MAC_MASK)
d606 1
a606 1
	case EF_M68K_CF_MAC:
d609 1
a609 1
	case EF_M68K_CF_EMAC:
@


1.88.2.4
log
@	bfd/
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_print_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

	binutils/
	* readelf.c (get_machine_flags): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

	include/elf/
	* m68k.h (EF_M68K_ARCH_MASK): New.
@
text
@d444 1
a444 1
  if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
d446 1
a446 1
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
d448 1
a448 3
  else if (((eflags & EF_M68K_ARCH_MASK) == 0
	    && (eflags & EF_M68K_CF_ISA_MASK) != 0)
	   || (eflags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
d563 4
a566 1
  if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
d568 9
a576 14
  else if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
    fprintf (file, " [cpu32]");
  else if (((eflags & EF_M68K_ARCH_MASK) == 0
	    && (eflags & EF_M68K_CF_ISA_MASK) != 0)
	   || (eflags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
    {
      if ((eflags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
	fprintf (file, " [cfv4e]");

      if (eflags & EF_M68K_CF_ISA_MASK)
	{
	  char const *isa = _("unknown");
	  char const *mac = _("unknown");
	  char const *additional = "";
d578 34
a611 37
	  switch (eflags & EF_M68K_CF_ISA_MASK)
	    {
	    case EF_M68K_CF_ISA_A_NODIV:
	      isa = "A";
	      additional = " [nodiv]";
	      break;
	    case EF_M68K_CF_ISA_A:
	      isa = "A";
	      break;
	    case EF_M68K_CF_ISA_A_PLUS:
	      isa = "A+";
	      break;
	    case EF_M68K_CF_ISA_B_NOUSP:
	      isa = "B";
	      additional = " [nousp]";
	      break;
	    case EF_M68K_CF_ISA_B:
	      isa = "B";
	      break;
	    }
	  fprintf (file, " [isa %s]%s", isa, additional);
	  if (eflags & EF_M68K_CF_FLOAT)
	    fprintf (file, " [float]");
	  switch (eflags & EF_M68K_CF_MAC_MASK)
	    {
	    case 0:
	      mac = NULL;
	      break;
	    case EF_M68K_CF_MAC:
	      mac = "mac";
	      break;
	    case EF_M68K_CF_EMAC:
	      mac = "emac";
	      break;
	    }
	  if (mac)
	    fprintf (file, " [%s]", mac);
d613 2
@


1.88.2.5
log
@	bfd/
	* elf32-m68k.c (elf32_m68k_object_p): Treat the default case
	as ColdFire.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.  Treat the default case as ColdFire.

	binutils/
	* readelf.c (get_machine_flags): Treat the default case as
	ColdFire.
@
text
@d448 3
a450 1
  else
d535 2
a536 11
      unsigned int variant_mask;

      if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	variant_mask = 0;
      else if ((in_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	variant_mask = 0;
      else
	variant_mask = EF_M68K_CF_ISA_MASK;

      in_isa = (in_flags & variant_mask);
      out_isa = (out_flags & variant_mask);
d569 3
a571 1
  else
@


1.88.2.6
log
@	bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Add an entry corresponding to
	bfd_mach_cpu32_fido.
	(bfd_m68k_compatible): Handle bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

	gas/
	* config/tc-m68k.c (m68k_elf_final_processing): Handle
	EF_M68K_CPU32_FIDO_A.

	include/
	* include/elf/m68k.h (EF_M68K_CPU32_FIDO_A,
	EF_M68K_CPU32_MASK): New.
@
text
@d447 1
a447 8
    {
      features |= cpu32;
      switch (eflags & EF_M68K_CPU32_MASK)
	{
        case EF_M68K_CPU32_FIDO_A:
	  features |= fido_a; break;
	}
    }
d538 1
a538 1
	variant_mask = EF_M68K_CPU32_MASK;
d575 1
a575 5
    {
      fprintf (file, " [cpu32]");
      if (eflags & EF_M68K_CPU32_FIDO_A)
	fprintf (file, " [fido]");
    }
@


1.87
log
@	bfd:
	* archures.c (bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_b_nousp):
	New.  Adjust other variants.
	(bfd_default_scan): Update.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c: Adjust.
	(bfd_m68k_compatible): New. Use it for architectures.
	* elf32-m68k.c (elf32_m68k_object_p): Adjust.
	(elf32_m68k_merge_private_bfd_data): Adjust.  Correct isa-a/b
	mismatch.
	(elf32_m68k_print_private_bfd_data): Adjust.
	* ieee.c (ieee_write_processor): Adjust.

	binutils:
	* readelf.c (get_machine_flags): Adjust.

	gas:
	* config/tc-m68k.c (m68k_extensions): Allow 'float' on both m68k
	and cf.
	(m68k_ip): <case 'J'> Check we have some control regs.
	(md_parse_option): Allow raw arch switch.
	(m68k_init_arch): Better detection of arch/cpu mismatch.  Detect
	whether 68881 or cfloat was meant by -mfloat.
	(md_show_usage): Adjust extension display.
	(m68k_elf_final_processing): Adjust.

	gas/testsuite:
	* gas/m68k/arch-cpu-1.s: Tweak.
	* gas/m68k/arch-cpu-1.d: Tweak.

	include/elf:
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A,
	EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B, EF_M68K_ISA_C): Adjust.
	(EF_M68K_ISA_A_NODIV, EF_M68K_ISA_B_NOUSP): New.
	(EF_M68K_HW_DIV, EF_M68K_USP): Remove.
	(EF_M68K_MAC, EF_M68K_EMAC, EF_M68K_FLOAT): Adjust.
	(EF_M68K_EMAC_B): New.

	ld/testsuite:
	* ld-m68k: New tests.
@
text
@d364 3
a366 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_m68k_link_hash_newfunc))
@


1.86
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d393 12
d406 1
a406 7
	  features |= mcfisa_b;
	  /* FALLTHROUGH */
	case EF_M68K_ISA_A_PLUS:
	  features |= mcfisa_aa;
	  /* FALLTHROUGH */
	case EF_M68K_ISA_A:
	  features |= mcfisa_a;
a408 2
      if (eflags & EF_M68K_HW_DIV)
	features |= mcfhwdiv;
a417 2
      if (eflags & EF_M68K_USP)
	features |= mcfusp;
d467 2
a468 1
      else if (in_mach >= bfd_mach_mcf_isa_a && out_mach >= bfd_mach_mcf_isa_a)
d489 4
d496 1
a496 1
      if (((in_flags | out_flags) & EF_M68K_ISA_MASK)
d501 1
a501 1
      if (in_flags & EF_M68K_ISA_MASK)
d503 1
a503 1
	  if (out_flags & EF_M68K_ISA_MASK)
d505 15
a519 9
	      /* Merge cf specific flags */
	      if ((in_flags & EF_M68K_ISA_MASK)
		  > (out_flags & EF_M68K_ISA_MASK))
		{
		  out_flags ^= out_flags & EF_M68K_ISA_MASK;
		  out_flags |= in_flags & EF_M68K_ISA_MASK;
		}
	      out_flags |= in_flags
		& (EF_M68K_HW_DIV | EF_M68K_USP | EF_M68K_FLOAT);
d575 1
d579 4
d589 4
d597 3
a599 3
      fprintf (file, " [isa %s]", isa);
      if (eflags & EF_M68K_HW_DIV)
	fprintf (file, " [hwdiv]");
a613 4
      if (eflags & EF_M68K_USP)
	fprintf (file, " [usp");
      if (eflags & EF_M68K_FLOAT)
	fprintf (file, " [float]");
@


1.85
log
@	* bfd/archures.c (bfd_mach_mcf5200, bfd_mach_mcf5206e,
	bfd_mach_mcf5307, bfd_mach_mcf5407, bfd_mach_mcf528x,
	bfd_mach_mcfv4e, bfd_mach_mcf521x, bfd_mach_mcf5249,
	bfd_mach_mcf547x, bfd_mach_mcf548x): Remove.
	(bfd_mach_mcf_isa_a, bfd_mach_mcf_isa_a_div,
	bfd_mach_mcf_isa_a_div_mac, bfd_mach_mcf_isa_a_div_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_aplus_usp,
	bfd_mach_mcf_isa_aplus_usp_mac, bfd_mach_mcf_isa_aplus_usp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac, bfd_mach_mcf_isa_b_emac,
	bfd_mach_mcf_isa_b_usp_float, bfd_mach_mcf_isa_b_usp_float_mac,
	bfd_mach_mcf_isa_b_usp_float_emac): New.
	(bfd_default_scan): Update coldfire mapping.
	* bfd/bfd-in.h (bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Declare.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/cpu-m68k.c (arch_info_struct): Add new coldfire machines,
	adjust legacy names.
	(m68k_arch_features): New.
	(bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Define.
	* bfd/elf32-m68k.c (elf32_m68k_object_p): New.
	(elf32_m68k_merge_private_bfd_data): Merge the CF EF flags.
	(elf32_m68k_print_private_bfd_data): Print the CF EF flags.
	(elf_backend_object_p): Define.
	* bfd/ieee.c (ieee_write_processor): Update coldfire machines.
	* bfd/libbfd.h: Rebuilt.

	* gas/config/tc-m68k.c (mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs): New.
	(not_current_architecture, selected_arch, selected_cpu): New.
	(m68k_archs, m68k_extensions): New.
	(archs): Renamed to ...
	(m68k_cpus): ... here.  Adjust.
	(n_arches): Remove.
	(md_pseudo_table): Add arch and cpu directives.
	(find_cf_chip, m68k_ip): Adjust table scanning.
	(no_68851, no_68881): Remove.
	(md_assemble): Lazily initialize.
	(select_control_regs): Adjust cpu names. Add 5208, 5213, 5329.
	(md_init_after_args): Move functionality to m68k_init_arch.
	(mri_chip): Adjust table scanning.
	(md_parse_option): Reimplement 'm' processing to add -march & -mcpu
	options with saner parsing.
	(m68k_lookup_cpu, m68k_set_arch, m68k_set_cpu, m68k_set_extension,
	m68k_init_arch): New.
	(s_m68k_cpu, s_m68k_arch): New.
	(md_show_usage): Adjust.
	(m68k_elf_final_processing): Set CF EF flags.
	* gas/config/tc-m68k.h (m68k_init_after_args): Remove.
	(tc_init_after_args): Remove.
	* gas/doc/c-m68k.texi (M68K-Opts): Document -march, -mcpu options.
	(M68k-Directives): Document .arch and .cpu directives.

	* gas/testsuite/gas/m68k/all.exp: Add arch-cpu-1 test.
	* gas/testsuite/gas/m68k/arch-cpu-1.[sd]: New.

	* include/elf/m68k.h (EF_CPU32, EF_M68000, EF_CFV4E): Rename to ...
	(EF_M68K_CPU32, EF_M68K_M68000, EF_M68K_CFV4E): ... here.
	(EF_M68K_ISA_MASK, EF_M68K_ISA_A, EF_M68K_M68K_ISA_A_PLUS,
	EF_M68K_ISA_B, EF_M68K_HW_DIV, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_USP, EF_M68K_FLOAT): New.

	* include/opcode/m68k.h (m68008, m68ec030, m68882): Remove.
	(m68k_mask): New.
	(cpu_m68k, cpu_cf): New.
	(mcf5200, mcf5206e, mcf521x, mcf5249, mcf528x, mcf5307, mcf5407,
	mcf5470, mcf5480): Rename to cpu_<foo>. Add m680x0 variants.

	* opcodes/m68k-dis.c (print_insn_m68k): Use
	bfd_m68k_mach_to_features.

	* binutils/readelf.c (get_machine_flags): Add logic for EF_M68K flags.
@
text
@d2143 1
a2143 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.84
log
@	PR ld/1775
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Add required
	parentheses.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d27 1
d224 1
a224 1
#define CFV4E_FLAG(abfd)  (elf_elfheader (abfd)->e_flags & EF_CFV4E)
d252 1
a252 1
#define CPU32_FLAG(abfd)  (elf_elfheader (abfd)->e_flags & EF_CPU32)
d376 50
d446 2
a447 1

d450 1
a450 1
    return TRUE;
d452 24
d482 42
a523 1
      elf_elfheader (obfd)->e_flags = in_flags;
d525 1
d537 1
d549 5
a553 2
  if (elf_elfheader (abfd)->e_flags & EF_CPU32)
    fprintf (file, _(" [cpu32]"));
d555 2
a556 2
  if (elf_elfheader (abfd)->e_flags & EF_M68000)
    fprintf (file, _(" [m68000]"));
d558 40
d2478 1
@


1.83
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d1874 1
a1874 1
		     + CFV4E_FLAG (output_bfd) ? 8 : 2),
d1887 1
a1887 1
		   + CFV4E_FLAG (output_bfd) ? 12 : 8),
@


1.82
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d748 2
d756 2
a757 2
		      head = ((struct elf_m68k_pcrel_relocs_copied **)
			      &elf_section_data (s)->local_dynrel);
@


1.81
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1735 1
a1735 1
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
d1739 1
@


1.80
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1084 7
@


1.79
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a1191 1
      bfd_boolean strip;
a1199 2
      strip = FALSE;

d1202 2
a1203 11
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
d1207 1
a1207 14
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
d1216 2
a1217 1
      else if (strncmp (name, ".got", 4) != 0)
d1223 1
a1223 1
      if (strip)
d1225 9
d1238 3
d1248 1
a1248 1
      if (s->contents == NULL && s->size != 0)
@


1.78
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d484 6
a489 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.77
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d520 8
a527 1
		  srelgot = bfd_make_section (dynobj, ".rela.got");
a528 7
		      || !bfd_set_section_flags (dynobj, srelgot,
						 (SEC_ALLOC
						  | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
d694 8
a701 1
		      sreloc = bfd_make_section (dynobj, name);
a702 7
			  || !bfd_set_section_flags (dynobj, sreloc,
						     (SEC_ALLOC
						      | SEC_LOAD
						      | SEC_HAS_CONTENTS
						      | SEC_IN_MEMORY
						      | SEC_LINKER_CREATED
						      | SEC_READONLY))
@


1.76
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.75
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1244 1
a1244 1
	  _bfd_strip_section_from_output (info, s);
@


1.74
log
@Add support for generating PLT lookups for the ColdFire.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.73
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d220 31
d1011 2
d1034 2
d1825 4
a1828 2
      if ( CPU32_FLAG (output_bfd))
        plt_index = h->plt.offset / PLT_CPU32_ENTRY_SIZE - 1;
d1830 1
a1830 1
        plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d1837 1
a1837 1
      if ( CPU32_FLAG (output_bfd))
d1846 8
d1866 6
a1871 5
		  (sgot->output_section->vma
		   + sgot->output_offset
		   + got_offset
		   - (splt->output_section->vma
		      + h->plt.offset + 2)),
d1884 1
a1884 1
		   + 8),
d2062 17
a2078 1
          if (!CPU32_FLAG (output_bfd))
d2080 1
a2080 1
	      memcpy (splt->contents, elf_m68k_plt0_entry, PLT_ENTRY_SIZE);
d2092 1
a2092 1
               = PLT_ENTRY_SIZE;
d2094 1
a2094 1
          else /* cpu32 */
d2096 1
a2096 1
              memcpy (splt->contents, elf_cpu32_plt0_entry, PLT_CPU32_ENTRY_SIZE);
d2108 1
a2108 1
               = PLT_CPU32_ENTRY_SIZE;
@


1.72
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d2173 1
a2173 1
	strncpy (p + 4, targetsec->output_section->name, 8);
@


1.71
log
@	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Use
	SYMBOL_CALLS_LOCAL and check for undefweak symbols with
	non-default visibility.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d838 10
a847 1
      struct elf_link_hash_entry *h;
d857 1
a857 2
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
a858 1
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d898 1
a898 2
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
a899 1
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.70
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d939 4
a942 3
      if (! info->shared
	  && !h->def_dynamic
	  && !h->ref_dynamic
d950 3
a952 4
	     object.  In such a case, we don't actually need to build
	     a procedure linkage table, and we can just do a PCxx
	     reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
a953 6
	  return TRUE;
	}

      /* GC may have rendered this entry unused.  */
      if (h->plt.refcount <= 0)
	{
a954 1
	  h->plt.offset = (bfd_vma) -1;
@


1.69
log
@	* elf32-m68k.c (elf_m68k_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
@
text
@d1734 3
a1736 2
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
@


1.68
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d2210 12
d2251 1
@


1.67
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d928 1
a928 1
		  || h->weakdef != NULL
d1027 1
a1027 1
  if (h->weakdef != NULL)
d1029 4
a1032 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.66
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d509 1
a509 1
		      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d567 1
a567 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d587 1
a587 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d593 1
a593 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d615 1
a615 2
		    || (h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_REGULAR) == 0)))
d927 1
a927 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d929 3
a931 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d937 1
a937 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d940 2
a941 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
d952 1
a952 1
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
d960 1
a960 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d967 1
a967 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d992 1
a992 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1070 1
a1070 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1294 1
a1294 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
d1296 1
a1296 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
d1441 2
a1442 2
			    || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
			&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)) != 0)
d1578 1
a1578 1
		  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))
d1596 1
a1596 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1628 1
a1628 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1699 1
a1699 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d1851 1
a1851 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1885 2
a1886 2
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1906 1
a1906 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.65
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1708 3
a1710 3
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
d1747 2
a1748 3
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
@


1.64
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d516 1
a516 1
		  sgot->_raw_size += 4;
d518 1
a518 1
		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
d539 1
a539 1
		  sgot->_raw_size += 4;
d545 1
a545 1
		      srelgot->_raw_size += sizeof (Elf32_External_Rela);
d687 1
a687 1
	      sreloc->_raw_size += sizeof (Elf32_External_Rela);
d859 2
a860 2
		      sgot->_raw_size -= 4;
		      srelgot->_raw_size -= sizeof (Elf32_External_Rela);
d872 1
a872 1
		      sgot->_raw_size -= 4;
d874 1
a874 1
			srelgot->_raw_size -= sizeof (Elf32_External_Rela);
d982 1
a982 1
      if (s->_raw_size == 0)
d985 1
a985 1
	    s->_raw_size += PLT_CPU32_ENTRY_SIZE;
d987 1
a987 1
	    s->_raw_size += PLT_ENTRY_SIZE;
d999 1
a999 1
	  h->root.u.def.value = s->_raw_size;
d1002 1
a1002 1
      h->plt.offset = s->_raw_size;
d1006 1
a1006 1
        s->_raw_size += PLT_CPU32_ENTRY_SIZE;
d1008 1
a1008 1
        s->_raw_size += PLT_ENTRY_SIZE;
d1014 1
a1014 1
      s->_raw_size += 4;
d1019 1
a1019 1
      s->_raw_size += sizeof (Elf32_External_Rela);
d1073 1
a1073 1
      srel->_raw_size += sizeof (Elf32_External_Rela);
d1084 1
a1084 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d1093 1
a1093 1
  h->root.u.def.value = s->_raw_size;
d1096 1
a1096 1
  s->_raw_size += h->size;
d1123 1
a1123 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1136 1
a1136 1
	s->_raw_size = 0;
d1171 1
a1171 1
	  if (s->_raw_size == 0)
d1185 1
a1185 1
	  if (s->_raw_size == 0)
d1225 2
a1226 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1321 1
a1321 1
    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
d1972 1
a1972 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2001 1
a2001 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d2015 1
a2015 6
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
d2022 1
a2022 1
      if (splt->_raw_size > 0)
d2060 1
a2060 1
  if (sgot->_raw_size > 0)
@


1.63
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d511 1
a511 1
		      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
d589 1
a589 1
	      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
d748 1
a748 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d755 1
a755 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d973 1
a973 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
a1101 11
/* This is the condition under which elf_m68k_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf_m68k_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d2234 1
a2234 1
#define bfd_elf32_bfd_final_link	_bfd_elf32_gc_common_final_link
@


1.62
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d1250 1
a1250 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.61
log
@	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Terminate early
	if no dynamic object is present.  Declare r_symndx and h in an
	inner scope.
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d1413 4
a1416 1
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
@


1.61.6.1
log
@Merge from mainline
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d511 1
a511 1
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d589 1
a589 1
	      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d748 1
a748 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d755 1
a755 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d973 1
a973 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1102 11
d1250 1
a1250 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1413 1
a1413 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2242 1
a2242 1
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link
@


1.61.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d1250 1
a1250 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1413 1
a1413 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.61.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d511 1
a511 1
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d589 1
a589 1
	      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d748 1
a748 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d755 1
a755 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d973 1
a973 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1102 11
d2245 1
a2245 1
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link
@


1.61.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d516 1
a516 1
		  sgot->size += 4;
d518 1
a518 1
		  srelgot->size += sizeof (Elf32_External_Rela);
d539 1
a539 1
		  sgot->size += 4;
d545 1
a545 1
		      srelgot->size += sizeof (Elf32_External_Rela);
d687 1
a687 1
	      sreloc->size += sizeof (Elf32_External_Rela);
d859 2
a860 2
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
d872 1
a872 1
		      sgot->size -= 4;
d874 1
a874 1
			srelgot->size -= sizeof (Elf32_External_Rela);
d982 1
a982 1
      if (s->size == 0)
d985 1
a985 1
	    s->size += PLT_CPU32_ENTRY_SIZE;
d987 1
a987 1
	    s->size += PLT_ENTRY_SIZE;
d999 1
a999 1
	  h->root.u.def.value = s->size;
d1002 1
a1002 1
      h->plt.offset = s->size;
d1006 1
a1006 1
        s->size += PLT_CPU32_ENTRY_SIZE;
d1008 1
a1008 1
        s->size += PLT_ENTRY_SIZE;
d1014 1
a1014 1
      s->size += 4;
d1019 1
a1019 1
      s->size += sizeof (Elf32_External_Rela);
d1073 1
a1073 1
      srel->size += sizeof (Elf32_External_Rela);
d1084 2
a1085 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1094 1
a1094 1
  h->root.u.def.value = s->size;
d1097 1
a1097 1
  s->size += h->size;
d1124 1
a1124 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1137 1
a1137 1
	s->size = 0;
d1172 1
a1172 1
	  if (s->size == 0)
d1186 1
a1186 1
	  if (s->size == 0)
d1226 2
a1227 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d1322 1
a1322 1
    s->section->size -= s->count * sizeof (Elf32_External_Rela);
d1709 3
a1711 3
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
d1748 3
a1750 2
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
d1973 1
a1973 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d2002 4
a2005 1
	      dyn.d_un.d_val = s->size;
d2019 6
a2024 1
		dyn.d_un.d_val -= s->size;
d2031 1
a2031 1
      if (splt->size > 0)
d2069 1
a2069 1
  if (sgot->size > 0)
@


1.61.8.4
log
@Merge from mainline.
@
text
@d509 1
a509 1
		      && !h->forced_local)
d567 1
a567 1
	  h->needs_plt = 1;
d587 1
a587 1
	      && !h->forced_local)
d593 1
a593 1
	  h->needs_plt = 1;
d615 2
a616 1
		    || !h->def_regular)))
d928 8
a935 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d941 1
a941 1
      || h->needs_plt)
d944 2
a945 2
	  && !h->def_dynamic
	  && !h->ref_dynamic
d956 1
a956 1
	  BFD_ASSERT (h->needs_plt);
d964 1
a964 1
	  h->needs_plt = 0;
d971 1
a971 1
	  && !h->forced_local)
d996 1
a996 1
	  && !h->def_regular)
d1031 1
a1031 1
  if (h->u.weakdef != NULL)
d1033 4
a1036 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1074 1
a1074 1
      h->needs_copy = 1;
d1298 1
a1298 1
  if (!h->def_regular
d1300 1
a1300 1
	  && !h->forced_local))
d1445 2
a1446 2
			    || h->forced_local)
			&& h->def_regular))
d1582 1
a1582 1
		  && h->forced_local))
d1600 2
a1601 1
			  || !h->def_regular))))
d1633 2
a1634 1
			   || !h->def_regular))
d1705 1
a1705 1
	       && h->def_dynamic))
d1857 1
a1857 1
      if (!h->def_regular)
d1891 2
a1892 2
	      || h->forced_local)
	  && h->def_regular)
d1912 1
a1912 1
  if (h->needs_copy)
@


1.60
log
@Fix decision about when a .interp section should exist
@
text
@a819 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
d824 4
a831 4
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

d838 3
@


1.59
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1130 1
a1130 1
      if (!info->shared)
@


1.58
log
@Better handking for unresolved symbols
@
text
@d1406 1
a1406 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d1660 1
a1660 10
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
@


1.57
log
@Correct spelling of "relocatable".
@
text
@d1401 1
d1410 1
a1410 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1412 1
a1412 31
	  relocation = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (!(info->callbacks->undefined_symbol
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	    }
@


1.56
log
@	* elf32-m68k.c (elf_m68k_check_relocs): Cache reloc section in
	elf_section_data during processing of pc-relative and absolute
	relocations.
	(elf_m68k_relocate_section): Use the cached reloc section instead
	of computing it again.  Fix handling of visibility.  Don't modify
	addend when copying over a relocation into the output.
@
text
@d430 1
a430 1
  if (info->relocateable)
d1361 1
a1361 1
  if (info->relocateable)
d2156 1
a2156 1
  BFD_ASSERT (! info->relocateable);
@


1.55
log
@	* elf32-m68k.c (elf_m68k_relocate_section): Replace ugly
	complicated tests for unresolvable relocs with a simple direct
	scheme using "unresolved_reloc" var.  Report some detail on
	bfd_reloc_outofrange and similar errors.
@
text
@d676 1
d1631 3
d1637 5
a1641 3
		  || (!info->symbolic
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
a1650 20
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

a1665 2
	      /* h->dynindx may be -1 if the symbol was marked to
                 become local.  */
d1667 6
a1672 1
		       && ((! info->symbolic && h->dynindx != -1)
a1675 1
		  BFD_ASSERT (h->dynindx != -1);
d1677 1
a1677 1
		  outrel.r_addend = relocation + rel->r_addend;
d1681 1
d1721 4
@


1.54
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1383 1
d1399 1
d1412 2
d1418 6
a1423 50
	      if (((r_type == R_68K_PLT8
		    || r_type == R_68K_PLT16
		    || r_type == R_68K_PLT32
		    || r_type == R_68K_PLT8O
		    || r_type == R_68K_PLT16O
		    || r_type == R_68K_PLT32O)
		   && h->plt.offset != (bfd_vma) -1
		   && elf_hash_table (info)->dynamic_sections_created)
		  || ((r_type == R_68K_GOT8O
		       || r_type == R_68K_GOT16O
		       || r_type == R_68K_GOT32O
		       || ((r_type == R_68K_GOT8
			    || r_type == R_68K_GOT16
			    || r_type == R_68K_GOT32)
			   && strcmp (h->root.root.string,
				      "_GLOBAL_OFFSET_TABLE_") != 0))
		      && (WILL_CALL_FINISH_DYNAMIC_SYMBOL
			  (elf_hash_table (info)->dynamic_sections_created,
			   info->shared, h))
		      && (! info->shared
			  || (! info->symbolic
			      && h->dynindx != -1
			      && (h->elf_link_hash_flags
				  & ELF_LINK_FORCED_LOCAL) == 0)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_68K_32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
		      && (r_type == R_68K_8
			  || r_type == R_68K_16
			  || r_type == R_68K_32
			  || r_type == R_68K_PC8
			  || r_type == R_68K_PC16
			  || r_type == R_68K_PC32)))
		{
		  /* In these cases, we don't need the relocation
		     value.  We check specially because in some
		     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
d1430 1
a1430 1
	    relocation = 0;
d1434 1
a1434 1
	    relocation = 0;
a1442 1
	      relocation = 0;
d1508 2
d1592 1
d1609 1
d1756 16
d1778 5
a1782 1
	  switch (r)
d1784 8
a1791 6
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;
d1793 15
a1807 18
		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (!(info->callbacks->reloc_overflow
		      (info, name, howto->name, (bfd_vma) 0,
		       input_bfd, input_section, rel->r_offset)))
		  return FALSE;
	      }
	      break;
@


1.53
log
@	* elf32-m68k.c (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(elf_m68k_relocate_section): Use it to correctly handle symbols
	forced to be local.
	(elf_m68k_finish_dynamic_symbol): Emit RELATIVE reloc for got
	entries for symbols that are forced to be local.
@
text
@d2191 1
a2191 1
  internal_relocs = (_bfd_elf32_link_read_relocs
@


1.53.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a1382 1
      bfd_boolean unresolved_reloc;
a1397 1
      unresolved_reloc = FALSE;
a1409 2

	  relocation = 0;
d1414 50
a1463 6
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
d1470 1
a1470 1
	    ;
d1474 1
a1474 1
	    ;
d1483 1
a1548 2
		else
		  unresolved_reloc = FALSE;
a1630 1
	  unresolved_reloc = FALSE;
a1646 1
	  unresolved_reloc = FALSE;
a1792 16
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     h->root.root.string);
	  return FALSE;
	}

d1799 1
a1799 5
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
d1801 6
a1806 8
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }
d1808 18
a1825 15
	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
d2191 1
a2191 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.52
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d1100 11
d1430 3
a1432 1
		      && elf_hash_table (info)->dynamic_sections_created
d1434 4
a1437 1
			  || (! info->symbolic && h->dynindx != -1)
d1515 2
d1520 2
a1521 1
		if (!elf_hash_table (info)->dynamic_sections_created
d1523 4
a1526 2
			&& (info->symbolic || h->dynindx == -1)
			&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d1964 3
a1966 1
	  && (info->symbolic || h->dynindx == -1)
@


1.51
log
@	* elf32-m68k.c (elf_m68k_hash_entry): Define.
	(elf_m68k_link_hash_traverse): Remove.
	(elf_m68k_link_hash_newfunc): Use struct bfd_hash_entry and
	elf_m68k_hash_entry instead of struct elf_m68k_link_hash_entry to
	reduce casting.
	(elf_m68k_check_relocs): Use elf_m68k_hash_entry instead of
	casting.
	(elf_m68k_size_dynamic_sections): Use elf_link_hash_traverse
	instead of elf_m68k_link_hash_traverse.
	(elf_m68k_discard_copies): Change first parameter to pointer to
	struct elf_link_hash_entry and use elf_m68k_hash_entry when struct
	elf_m68k_link_hash_entry is needed.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d93 1
a93 1
  /* GNU extension to record C++ vtable hierarchy */
d107 1
a107 1
  /* GNU extension to record C++ vtable member usage */
a183 1
/* end code generated by elf.el */
d344 1
a344 1
/* Keep m68k-specific flags in the ELF header */
d381 1
a381 1
/* Display the flags field */
a1009 1

a1014 1

a1455 1
		   && (!info->symbolic || info->allow_shlib_undefined)
@


1.50
log
@	* elf32-m68k.c (elf_m68k_check_relocs): Don't set DF_TEXTREL for
	PC relative relocations.
	(elf_m68k_discard_copies): Set it here instead.
@
text
@d49 2
d277 2
a288 13
/* Declare this now that the above structures are defined.  */

static bfd_boolean elf_m68k_discard_copies
  PARAMS ((struct elf_m68k_link_hash_entry *, PTR));

/* Traverse an m68k ELF linker hash table.  */

#define elf_m68k_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
    (info)))

d302 1
a302 2
  struct elf_m68k_link_hash_entry *ret =
    (struct elf_m68k_link_hash_entry *) entry;
d306 5
a310 6
  if (ret == (struct elf_m68k_link_hash_entry *) NULL)
    ret = ((struct elf_m68k_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_m68k_link_hash_entry)));
  if (ret == (struct elf_m68k_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d313 3
a315 7
  ret = ((struct elf_m68k_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_m68k_link_hash_entry *) NULL)
    {
      ret->pcrel_relocs_copied = NULL;
    }
d317 1
a317 1
  return (struct bfd_hash_entry *) ret;
d707 1
a707 1
			= (struct elf_m68k_link_hash_entry *) h;
d1148 3
a1150 3
    elf_m68k_link_hash_traverse (elf_m68k_hash_table (info),
				 elf_m68k_discard_copies,
				 (PTR) info);
d1276 1
a1276 1
/* This function is called via elf_m68k_link_hash_traverse if we are
d1291 1
a1291 1
     struct elf_m68k_link_hash_entry *h;
d1297 2
a1298 2
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_m68k_link_hash_entry *) h->root.root.u.i.link;
d1300 1
a1300 1
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
d1302 1
a1302 1
	  && (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
d1307 3
a1309 1
	  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
d1316 1
d1320 3
a1322 1
  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
@


1.49
log
@	* elf32-m68k.c (struct elf_m68k_link_hash_table): Add sym_sec
	member.
	(elf_m68k_link_hash_table_create): Initialize it.
	(elf_m68k_check_relocs): Handle symbols that are forced to be
	local due to visibility changes.
	(elf_m68k_adjust_dynamic_symbol): Likewise.
	(elf_m68k_size_dynamic_sections): Likewise.
	(elf_m68k_discard_copies): Likewise.
	(elf_m68k_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d692 8
a699 1
		  if (sec->flags & SEC_READONLY)
a700 1
		}
d1294 1
a1294 1
   are defined in regular objects.  For the normal shared case, if
d1298 5
a1302 1
   relocate_section routine.  */
d1318 13
a1330 1
    return TRUE;
@


1.48
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d280 3
d355 2
d524 2
a525 1
		  if (h->dynindx == -1)
d602 2
a603 1
	  if (h->dynindx == -1)
d630 1
d698 7
a704 6
	      /* If we are linking with -Bsymbolic, we count the number of
		 PC relative relocations we have entered for this symbol,
		 so that we can discard them again if the symbol is later
		 defined by a regular object.  Note that this function is
		 only called if we are using an m68kelf linker hash table,
		 which means that h is really a pointer to an
d706 3
a708 4
	      if ((ELF32_R_TYPE (rel->r_info) == R_68K_PC8
 		   || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
 		   || ELF32_R_TYPE (rel->r_info) == R_68K_PC32)
		  && info->symbolic)
a709 1
		  struct elf_m68k_link_hash_entry *eh;
d711 16
d728 3
a730 1
		  eh = (struct elf_m68k_link_hash_entry *) h;
d732 1
a732 1
		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
d742 2
a743 2
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
d978 2
a979 1
      if (h->dynindx == -1)
d1150 7
a1156 5
  /* If this is a -Bsymbolic shared link, then we need to discard all PC
     relative relocs against symbols defined in a regular object.  We
     allocated space for them in the check_relocs routine, but we will not
     fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
d1159 1
a1159 1
				 (PTR) NULL);
d1286 7
a1292 4
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are defined
   in regular objects.  We allocated space for them in the check_relocs
   routine, but we won't fill them in in the relocate_section routine.  */
d1295 1
a1295 1
elf_m68k_discard_copies (h, ignore)
d1297 1
a1297 1
     PTR ignore ATTRIBUTE_UNUSED;
d1299 1
d1305 3
a1307 2
  /* We only discard relocs for symbols defined in a regular object.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1627 3
a1629 1
	  if (h == NULL)
@


1.47
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d36 1
a36 1
static boolean elf_m68k_check_relocs
d42 1
a42 1
static boolean elf_m68k_gc_sweep_hook
d45 1
a45 1
static boolean elf_m68k_adjust_dynamic_symbol
d47 1
a47 1
static boolean elf_m68k_size_dynamic_sections
d49 1
a49 1
static boolean elf_m68k_relocate_section
d52 1
a52 1
static boolean elf_m68k_finish_dynamic_symbol
d55 1
a55 1
static boolean elf_m68k_finish_dynamic_sections
d58 1
a58 1
static boolean elf32_m68k_set_private_flags
d60 1
a60 1
static boolean elf32_m68k_merge_private_bfd_data
d62 1
a62 1
static boolean elf32_m68k_print_private_bfd_data
d68 23
a90 23
  HOWTO(R_68K_NONE,       0, 0, 0, false,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_NONE",      false, 0, 0x00000000,false),
  HOWTO(R_68K_32,         0, 2,32, false,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_32",        false, 0, 0xffffffff,false),
  HOWTO(R_68K_16,         0, 1,16, false,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_16",        false, 0, 0x0000ffff,false),
  HOWTO(R_68K_8,          0, 0, 8, false,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_8",         false, 0, 0x000000ff,false),
  HOWTO(R_68K_PC32,       0, 2,32, true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PC32",      false, 0, 0xffffffff,true),
  HOWTO(R_68K_PC16,       0, 1,16, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC16",      false, 0, 0x0000ffff,true),
  HOWTO(R_68K_PC8,        0, 0, 8, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC8",       false, 0, 0x000000ff,true),
  HOWTO(R_68K_GOT32,      0, 2,32, true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32",     false, 0, 0xffffffff,true),
  HOWTO(R_68K_GOT16,      0, 1,16, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16",     false, 0, 0x0000ffff,true),
  HOWTO(R_68K_GOT8,       0, 0, 8, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8",      false, 0, 0x000000ff,true),
  HOWTO(R_68K_GOT32O,     0, 2,32, false,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32O",    false, 0, 0xffffffff,false),
  HOWTO(R_68K_GOT16O,     0, 1,16, false,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16O",    false, 0, 0x0000ffff,false),
  HOWTO(R_68K_GOT8O,      0, 0, 8, false,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8O",     false, 0, 0x000000ff,false),
  HOWTO(R_68K_PLT32,      0, 2,32, true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32",     false, 0, 0xffffffff,true),
  HOWTO(R_68K_PLT16,      0, 1,16, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16",     false, 0, 0x0000ffff,true),
  HOWTO(R_68K_PLT8,       0, 0, 8, true, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8",      false, 0, 0x000000ff,true),
  HOWTO(R_68K_PLT32O,     0, 2,32, false,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32O",    false, 0, 0xffffffff,false),
  HOWTO(R_68K_PLT16O,     0, 1,16, false,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16O",    false, 0, 0x0000ffff,false),
  HOWTO(R_68K_PLT8O,      0, 0, 8, false,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8O",     false, 0, 0x000000ff,false),
  HOWTO(R_68K_COPY,       0, 0, 0, false,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_COPY",      false, 0, 0xffffffff,false),
  HOWTO(R_68K_GLOB_DAT,   0, 2,32, false,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_GLOB_DAT",  false, 0, 0xffffffff,false),
  HOWTO(R_68K_JMP_SLOT,   0, 2,32, false,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_JMP_SLOT",  false, 0, 0xffffffff,false),
  HOWTO(R_68K_RELATIVE,   0, 2,32, false,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_RELATIVE",  false, 0, 0xffffffff,false),
d96 1
a96 1
	 false,			/* pc_relative */
d101 1
a101 1
	 false,			/* partial_inplace */
d104 1
a104 1
	 false),
d110 1
a110 1
	 false,			/* pc_relative */
d115 1
a115 1
	 false,			/* partial_inplace */
d118 1
a118 1
	 false),
d284 1
a284 1
static boolean elf_m68k_discard_copies
d292 1
a292 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d356 1
a356 1
static boolean
d362 2
a363 2
  elf_flags_init (abfd) = true;
  return true;
d368 1
a368 1
static boolean
d378 1
a378 1
    return true;
d385 1
a385 1
      elf_flags_init (obfd) = true;
d389 1
a389 1
  return true;
d393 1
a393 1
static boolean
d418 1
a418 1
  return true;
d424 1
a424 1
static boolean
d442 1
a442 1
    return true;
d485 1
a485 1
		return false;
d510 1
a510 1
		    return false;
d522 1
a522 1
			return false;
d544 1
a544 1
		    return false;
d592 1
a592 1
	      return false;
d599 1
a599 1
		return false;
d663 1
a663 1
		    return false;
d682 1
a682 1
			return false;
d716 1
a716 1
			return false;
d733 1
a733 1
	    return false;
d740 1
a740 1
	    return false;
d748 1
a748 1
  return true;
d793 1
a793 1
static boolean
d816 1
a816 1
    return true;
d889 1
a889 1
  return true;
d898 1
a898 1
static boolean
d941 1
a941 1
	  return true;
d949 1
a949 1
	  return true;
d956 1
a956 1
	    return false;
d1005 1
a1005 1
      return true;
d1021 1
a1021 1
      return true;
d1032 1
a1032 1
    return true;
d1073 1
a1073 1
	return false;
d1083 1
a1083 1
  return true;
d1088 1
a1088 1
static boolean
d1095 2
a1096 2
  boolean plt;
  boolean relocs;
d1136 2
a1137 2
  plt = false;
  relocs = false;
d1141 1
a1141 1
      boolean strip;
d1150 1
a1150 1
      strip = false;
d1158 1
a1158 1
	      strip = true;
d1163 1
a1163 1
	      plt = true;
d1179 1
a1179 1
	      strip = true;
d1183 1
a1183 1
	      relocs = true;
d1210 1
a1210 1
	return false;
d1226 1
a1226 1
	    return false;
d1235 1
a1235 1
	    return false;
d1243 1
a1243 1
	    return false;
d1249 1
a1249 1
	    return false;
d1254 1
a1254 1
  return true;
d1263 1
a1263 1
static boolean
d1275 1
a1275 1
    return true;
d1280 1
a1280 1
  return true;
d1285 1
a1285 1
static boolean
d1308 1
a1308 1
    return true;
d1336 1
a1336 1
	  return false;
d1425 1
a1425 1
		return false;
d1612 1
a1612 1
	      boolean skip, relocate;
d1627 1
a1627 1
		    return false;
d1638 2
a1639 2
	      skip = false;
	      relocate = false;
d1645 1
a1645 1
		skip = true;
d1647 1
a1647 1
		skip = true, relocate = true;
d1668 1
a1668 1
		      relocate = true;
d1690 1
a1690 1
			  return false;
d1752 1
a1752 1
		      return false;
d1759 1
a1759 1
		  return false;
d1766 1
a1766 1
  return true;
d1772 1
a1772 1
static boolean
d1951 1
a1951 1
  return true;
d1956 1
a1956 1
static boolean
d2090 1
a2090 1
  return true;
d2100 1
a2100 1
boolean
d2120 1
a2120 1
    return true;
d2205 1
a2205 1
  return true;
d2213 1
a2213 1
  return false;
@


1.46
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d31 1
a31 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d1506 1
a1506 1
			asection *srelgot;
d1508 1
d1510 2
a1511 2
			srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (srelgot != NULL);
d1518 3
a1520 5
			bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						   (((Elf32_External_Rela *)
						     srelgot->contents)
						    + srelgot->reloc_count));
			++srelgot->reloc_count;
d1611 1
d1706 3
a1708 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d1792 1
d1865 2
a1866 3
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + plt_index));
d1881 1
d1916 3
a1918 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
d1925 1
d1942 2
a1943 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
@


1.46.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d36 1
a36 1
static bfd_boolean elf_m68k_check_relocs
d42 1
a42 1
static bfd_boolean elf_m68k_gc_sweep_hook
d45 1
a45 1
static bfd_boolean elf_m68k_adjust_dynamic_symbol
d47 1
a47 1
static bfd_boolean elf_m68k_size_dynamic_sections
d49 1
a49 3
static bfd_boolean elf_m68k_discard_copies
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_m68k_relocate_section
d52 1
a52 1
static bfd_boolean elf_m68k_finish_dynamic_symbol
d55 1
a55 1
static bfd_boolean elf_m68k_finish_dynamic_sections
d58 1
a58 1
static bfd_boolean elf32_m68k_set_private_flags
d60 1
a60 1
static bfd_boolean elf32_m68k_merge_private_bfd_data
d62 1
a62 1
static bfd_boolean elf32_m68k_print_private_bfd_data
d68 24
a91 24
  HOWTO(R_68K_NONE,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_NONE",      FALSE, 0, 0x00000000,FALSE),
  HOWTO(R_68K_32,         0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_32",        FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_16,         0, 1,16, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_16",        FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_8,          0, 0, 8, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_8",         FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PC32,       0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PC32",      FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PC16,       0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC16",      FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PC8,        0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC8",       FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_GOT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_GOT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GOT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_GOT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PLT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PLT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PLT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_PLT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_PLT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_PLT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_COPY,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_COPY",      FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GLOB_DAT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_GLOB_DAT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_JMP_SLOT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_JMP_SLOT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_RELATIVE,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_RELATIVE",  FALSE, 0, 0xffffffff,FALSE),
  /* GNU extension to record C++ vtable hierarchy.  */
d96 1
a96 1
	 FALSE,			/* pc_relative */
d101 1
a101 1
	 FALSE,			/* partial_inplace */
d104 2
a105 2
	 FALSE),
  /* GNU extension to record C++ vtable member usage.  */
d110 1
a110 1
	 FALSE,			/* pc_relative */
d115 1
a115 1
	 FALSE,			/* partial_inplace */
d118 1
a118 1
	 FALSE),
d182 1
a274 2
#define elf_m68k_hash_entry(ent) ((struct elf_m68k_link_hash_entry *) (ent))

d280 3
d284 10
a293 3
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};
d308 2
a309 1
  struct bfd_hash_entry *ret = entry;
d313 6
a318 5
  if (ret == NULL)
    ret = bfd_hash_allocate (table,
			     sizeof (struct elf_m68k_link_hash_entry));
  if (ret == NULL)
    return ret;
d321 7
a327 3
  ret = _bfd_elf_link_hash_newfunc (ret, table, string);
  if (ret != NULL)
    elf_m68k_hash_entry (ret)->pcrel_relocs_copied = NULL;
d329 1
a329 1
  return ret;
a351 2
  ret->sym_sec.abfd = NULL;

d355 2
a356 2
/* Keep m68k-specific flags in the ELF header.  */
static bfd_boolean
d362 2
a363 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d368 1
a368 1
static bfd_boolean
d378 1
a378 1
    return TRUE;
d385 1
a385 1
      elf_flags_init (obfd) = TRUE;
d389 1
a389 1
  return TRUE;
d392 2
a393 2
/* Display the flags field.  */
static bfd_boolean
d418 1
a418 1
  return TRUE;
d424 1
a424 1
static bfd_boolean
d441 2
a442 2
  if (info->relocatable)
    return TRUE;
d485 1
a485 1
		return FALSE;
d510 1
a510 1
		    return FALSE;
d519 1
a519 2
		  if (h->dynindx == -1
		      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d522 1
a522 1
			return FALSE;
d544 1
a544 1
		    return FALSE;
d592 1
a592 1
	      return FALSE;
d596 1
a596 2
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d599 1
a599 1
		return FALSE;
a622 1
		    || h->root.type == bfd_link_hash_defweak
d663 1
a663 1
		    return FALSE;
d682 1
a682 1
			return FALSE;
d684 2
a685 1
		  elf_section_data (sec)->sreloc = sreloc;
a687 8
	      if (sec->flags & SEC_READONLY
		  /* Don't set DF_TEXTREL yet for PC relative
		     relocations, they might be discarded later.  */
		  && !(ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC32))
		    info->flags |= DF_TEXTREL;

d690 6
a695 7
	      /* We count the number of PC relative relocations we have
		 entered for this symbol, so that we can discard them
		 again if, in the -Bsymbolic case, the symbol is later
		 defined by a regular object, or, in the normal shared
		 case, the symbol is forced to be local.  Note that this
		 function is only called if we are using an m68kelf linker
		 hash table, which means that h is really a pointer to an
d697 4
a700 3
	      if (ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC32)
d702 1
a703 16
		  struct elf_m68k_pcrel_relocs_copied **head;

		  if (h != NULL)
		    {
		      struct elf_m68k_link_hash_entry *eh
			= elf_m68k_hash_entry (h);
		      head = &eh->pcrel_relocs_copied;
		    }
		  else
		    {
		      asection *s;
		      s = (bfd_section_from_r_symndx
			   (abfd, &elf_m68k_hash_table (info)->sym_sec,
			    sec, r_symndx));
		      if (s == NULL)
			return FALSE;
d705 1
a705 3
		      head = ((struct elf_m68k_pcrel_relocs_copied **)
			      &elf_section_data (s)->local_dynrel);
		    }
d707 1
a707 1
		  for (p = *head; p != NULL; p = p->next)
d716 3
a718 3
			return FALSE;
		      p->next = *head;
		      *head = p;
d733 1
a733 1
	    return FALSE;
d740 1
a740 1
	    return FALSE;
d748 1
a748 1
  return TRUE;
d793 1
a793 1
static bfd_boolean
d816 1
a816 1
    return TRUE;
d889 1
a889 1
  return TRUE;
d898 1
a898 1
static bfd_boolean
d941 1
a941 1
	  return TRUE;
d949 1
a949 1
	  return TRUE;
d953 1
a953 2
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d956 1
a956 1
	    return FALSE;
d994 1
d1000 1
d1005 1
a1005 1
      return TRUE;
d1021 1
a1021 1
      return TRUE;
d1032 1
a1032 1
    return TRUE;
d1073 1
a1073 1
	return FALSE;
d1083 1
a1083 1
  return TRUE;
a1085 11
/* This is the condition under which elf_m68k_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf_m68k_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1088 1
a1088 1
static bfd_boolean
d1095 2
a1096 2
  bfd_boolean plt;
  bfd_boolean relocs;
d1104 1
a1104 1
      if (info->executable)
d1124 8
a1131 10
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     For the normal shared case we discard the PC relative relocs
     against symbols that have become local due to visibility changes.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_m68k_discard_copies,
			    (PTR) info);
d1136 2
a1137 2
  plt = FALSE;
  relocs = FALSE;
d1141 1
a1141 1
      bfd_boolean strip;
d1150 1
a1150 1
      strip = FALSE;
d1158 1
a1158 1
	      strip = TRUE;
d1163 1
a1163 1
	      plt = TRUE;
d1179 1
a1179 1
	      strip = TRUE;
d1183 1
a1183 1
	      relocs = TRUE;
d1210 1
a1210 1
	return FALSE;
d1226 1
a1226 1
	    return FALSE;
d1235 1
a1235 1
	    return FALSE;
d1243 1
a1243 1
	    return FALSE;
d1249 1
a1249 1
	    return FALSE;
d1254 1
a1254 1
  return TRUE;
d1257 10
a1266 17
/* This function is called via elf_link_hash_traverse if we are
   creating a shared object.  In the -Bsymbolic case it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal shared case, it
   discards space for pc-relative relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.

   We also check whether any of the remaining relocations apply
   against a readonly section, and set the DF_TEXTREL flag in this
   case.  */

static bfd_boolean
elf_m68k_discard_copies (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
a1267 1
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d1270 2
a1271 19
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      || (!info->symbolic
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
    {
      if ((info->flags & DF_TEXTREL) == 0)
	{
	  /* Look for relocations against read-only sections.  */
	  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
	       s != NULL;
	       s = s->next)
	    if ((s->section->flags & SEC_READONLY) != 0)
	      {
		info->flags |= DF_TEXTREL;
		break;
	      }
	}
d1273 3
a1275 2
      return TRUE;
    }
d1277 1
a1277 3
  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
       s != NULL;
       s = s->next)
d1280 1
a1280 1
  return TRUE;
d1285 1
a1285 1
static bfd_boolean
d1307 2
a1308 2
  if (info->relocatable)
    return TRUE;
a1329 1
      bfd_boolean unresolved_reloc;
d1336 1
a1336 1
	  return FALSE;
a1344 2
      unresolved_reloc = FALSE;

d1349 1
a1349 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1353 75
a1427 3
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
a1457 2
		bfd_boolean dyn;

d1461 1
a1461 2
		dyn = elf_hash_table (info)->dynamic_sections_created;
		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1463 2
a1464 4
			&& (info->symbolic
			    || h->dynindx == -1
			    || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
			&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)) != 0)
a1486 2
		else
		  unresolved_reloc = FALSE;
d1506 1
a1506 1
			asection *s;
a1507 1
			bfd_byte *loc;
d1509 2
a1510 2
			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);
d1517 5
a1521 3
			loc = s->contents;
			loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
a1569 1
	  unresolved_reloc = FALSE;
a1585 1
	  unresolved_reloc = FALSE;
d1595 1
a1595 3
	  if (h == NULL
	      || (info->shared
		  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))
a1603 3
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
d1607 3
a1609 5
		  || (h != NULL
		      && h->dynindx != -1
		      && (!info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1612 1
a1612 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1618 22
a1639 2
	      skip = FALSE;
	      relocate = FALSE;
d1645 1
a1645 1
		skip = TRUE;
d1647 1
a1647 1
		skip = TRUE, relocate = TRUE;
d1653 2
d1656 1
a1656 6
		       && h->dynindx != -1
		       && (r_type == R_68K_PC8
			   || r_type == R_68K_PC16
			   || r_type == R_68K_PC32
			   || !info->shared
			   || !info->symbolic
d1660 1
d1662 1
a1662 1
		  outrel.r_addend = rel->r_addend;
a1665 1
		  /* This symbol is local, or marked to become local.  */
d1668 1
a1668 1
		      relocate = TRUE;
d1676 10
a1685 1
		      if (bfd_is_abs_section (sec))
d1690 1
a1690 1
			  return FALSE;
d1706 5
a1710 7
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
a1730 16
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     h->root.root.string);
	  return FALSE;
	}

d1737 1
a1737 5
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
d1739 6
a1744 8
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }
d1746 18
a1763 15
	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
d1768 1
a1768 1
  return TRUE;
d1774 1
a1774 1
static bfd_boolean
a1793 1
      bfd_byte *loc;
d1866 3
a1868 2
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1882 1
      bfd_byte *loc;
d1901 1
a1901 3
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
d1917 4
a1920 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1926 1
      bfd_byte *loc;
d1943 4
a1946 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d1954 1
a1954 1
  return TRUE;
d1959 1
a1959 1
static bfd_boolean
d2093 1
a2093 1
  return TRUE;
d2103 1
a2103 1
bfd_boolean
d2118 1
a2118 1
  BFD_ASSERT (! info->relocatable);
d2123 1
a2123 1
    return TRUE;
d2128 1
a2128 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2208 1
a2208 1
  return TRUE;
d2216 1
a2216 1
  return FALSE;
@


1.46.12.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d820 2
d826 4
a833 4
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

a839 3
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

@


1.46.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d31 1
a31 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d36 1
a36 1
static bfd_boolean elf_m68k_check_relocs
d42 1
a42 1
static bfd_boolean elf_m68k_gc_sweep_hook
d45 1
a45 1
static bfd_boolean elf_m68k_adjust_dynamic_symbol
d47 1
a47 1
static bfd_boolean elf_m68k_size_dynamic_sections
d49 1
a49 1
static bfd_boolean elf_m68k_relocate_section
d52 1
a52 1
static bfd_boolean elf_m68k_finish_dynamic_symbol
d55 1
a55 1
static bfd_boolean elf_m68k_finish_dynamic_sections
d58 1
a58 1
static bfd_boolean elf32_m68k_set_private_flags
d60 1
a60 1
static bfd_boolean elf32_m68k_merge_private_bfd_data
d62 1
a62 1
static bfd_boolean elf32_m68k_print_private_bfd_data
d68 23
a90 23
  HOWTO(R_68K_NONE,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_NONE",      FALSE, 0, 0x00000000,FALSE),
  HOWTO(R_68K_32,         0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_32",        FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_16,         0, 1,16, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_16",        FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_8,          0, 0, 8, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_8",         FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PC32,       0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PC32",      FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PC16,       0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC16",      FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PC8,        0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PC8",       FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_GOT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_GOT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_GOT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_GOT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GOT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_GOT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_GOT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_PLT32,      0, 2,32, TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32",     FALSE, 0, 0xffffffff,TRUE),
  HOWTO(R_68K_PLT16,      0, 1,16, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16",     FALSE, 0, 0x0000ffff,TRUE),
  HOWTO(R_68K_PLT8,       0, 0, 8, TRUE, 0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8",      FALSE, 0, 0x000000ff,TRUE),
  HOWTO(R_68K_PLT32O,     0, 2,32, FALSE,0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_68K_PLT32O",    FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_PLT16O,     0, 1,16, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT16O",    FALSE, 0, 0x0000ffff,FALSE),
  HOWTO(R_68K_PLT8O,      0, 0, 8, FALSE,0, complain_overflow_signed,   bfd_elf_generic_reloc, "R_68K_PLT8O",     FALSE, 0, 0x000000ff,FALSE),
  HOWTO(R_68K_COPY,       0, 0, 0, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_COPY",      FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_GLOB_DAT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_GLOB_DAT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_JMP_SLOT,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_JMP_SLOT",  FALSE, 0, 0xffffffff,FALSE),
  HOWTO(R_68K_RELATIVE,   0, 2,32, FALSE,0, complain_overflow_dont,     bfd_elf_generic_reloc, "R_68K_RELATIVE",  FALSE, 0, 0xffffffff,FALSE),
d96 1
a96 1
	 FALSE,			/* pc_relative */
d101 1
a101 1
	 FALSE,			/* partial_inplace */
d104 1
a104 1
	 FALSE),
d110 1
a110 1
	 FALSE,			/* pc_relative */
d115 1
a115 1
	 FALSE,			/* partial_inplace */
d118 1
a118 1
	 FALSE),
a279 3

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d284 1
a284 1
static bfd_boolean elf_m68k_discard_copies
d292 1
a292 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
a351 2
  ret->sym_sec.abfd = NULL;

d356 1
a356 1
static bfd_boolean
d362 2
a363 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d368 1
a368 1
static bfd_boolean
d378 1
a378 1
    return TRUE;
d385 1
a385 1
      elf_flags_init (obfd) = TRUE;
d389 1
a389 1
  return TRUE;
d393 1
a393 1
static bfd_boolean
d418 1
a418 1
  return TRUE;
d424 1
a424 1
static bfd_boolean
d442 1
a442 1
    return TRUE;
d485 1
a485 1
		return FALSE;
d510 1
a510 1
		    return FALSE;
d519 1
a519 2
		  if (h->dynindx == -1
		      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d522 1
a522 1
			return FALSE;
d544 1
a544 1
		    return FALSE;
d592 1
a592 1
	      return FALSE;
d596 1
a596 2
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d599 1
a599 1
		return FALSE;
a622 1
		    || h->root.type == bfd_link_hash_defweak
d663 1
a663 1
		    return FALSE;
d682 1
a682 1
			return FALSE;
d690 6
a695 7
	      /* We count the number of PC relative relocations we have
		 entered for this symbol, so that we can discard them
		 again if, in the -Bsymbolic case, the symbol is later
		 defined by a regular object, or, in the normal shared
		 case, the symbol is forced to be local.  Note that this
		 function is only called if we are using an m68kelf linker
		 hash table, which means that h is really a pointer to an
d697 4
a700 3
	      if (ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC32)
d702 1
a703 16
		  struct elf_m68k_pcrel_relocs_copied **head;

		  if (h != NULL)
		    {
		      struct elf_m68k_link_hash_entry *eh
			= (struct elf_m68k_link_hash_entry *) h;
		      head = &eh->pcrel_relocs_copied;
		    }
		  else
		    {
		      asection *s;
		      s = (bfd_section_from_r_symndx
			   (abfd, &elf_m68k_hash_table (info)->sym_sec,
			    sec, r_symndx));
		      if (s == NULL)
			return FALSE;
d705 1
a705 3
		      head = ((struct elf_m68k_pcrel_relocs_copied **)
			      &elf_section_data (s)->local_dynrel);
		    }
d707 1
a707 1
		  for (p = *head; p != NULL; p = p->next)
d716 3
a718 3
			return FALSE;
		      p->next = *head;
		      *head = p;
d733 1
a733 1
	    return FALSE;
d740 1
a740 1
	    return FALSE;
d748 1
a748 1
  return TRUE;
d793 1
a793 1
static bfd_boolean
d816 1
a816 1
    return TRUE;
d889 1
a889 1
  return TRUE;
d898 1
a898 1
static bfd_boolean
d941 1
a941 1
	  return TRUE;
d949 1
a949 1
	  return TRUE;
d953 1
a953 2
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d956 1
a956 1
	    return FALSE;
d1005 1
a1005 1
      return TRUE;
d1021 1
a1021 1
      return TRUE;
d1032 1
a1032 1
    return TRUE;
d1073 1
a1073 1
	return FALSE;
d1083 1
a1083 1
  return TRUE;
d1088 1
a1088 1
static bfd_boolean
d1095 2
a1096 2
  bfd_boolean plt;
  bfd_boolean relocs;
d1124 5
a1128 7
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     For the normal shared case we discard the PC relative relocs
     against symbols that have become local due to visibility changes.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
d1131 1
a1131 1
				 (PTR) info);
d1136 2
a1137 2
  plt = FALSE;
  relocs = FALSE;
d1141 1
a1141 1
      bfd_boolean strip;
d1150 1
a1150 1
      strip = FALSE;
d1158 1
a1158 1
	      strip = TRUE;
d1163 1
a1163 1
	      plt = TRUE;
d1179 1
a1179 1
	      strip = TRUE;
d1183 1
a1183 1
	      relocs = TRUE;
d1210 1
a1210 1
	return FALSE;
d1226 1
a1226 1
	    return FALSE;
d1235 1
a1235 1
	    return FALSE;
d1243 1
a1243 1
	    return FALSE;
d1249 1
a1249 1
	    return FALSE;
d1254 1
a1254 1
  return TRUE;
d1258 4
a1261 7
   creating a shared object.  In the -Bsymbolic case it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal shared case, if
   discards space for pc-relative relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */
d1263 2
a1264 2
static bfd_boolean
elf_m68k_discard_copies (h, inf)
d1266 1
a1266 1
     PTR inf;
a1267 1
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d1273 3
a1275 4
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      || (!info->symbolic
	  && (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
    return TRUE;
d1280 1
a1280 1
  return TRUE;
d1285 1
a1285 1
static bfd_boolean
d1308 1
a1308 1
    return TRUE;
d1336 1
a1336 1
	  return FALSE;
d1425 1
a1425 1
		return FALSE;
d1506 1
a1506 1
			asection *s;
a1507 1
			bfd_byte *loc;
d1509 2
a1510 2
			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);
d1517 5
a1521 3
			loc = s->contents;
			loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d1595 1
a1595 3
	  if (h == NULL
	      || (info->shared
		  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))
d1612 1
a1612 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1627 1
a1627 1
		    return FALSE;
d1638 2
a1639 2
	      skip = FALSE;
	      relocate = FALSE;
d1645 1
a1645 1
		skip = TRUE;
d1647 1
a1647 1
		skip = TRUE, relocate = TRUE;
d1668 1
a1668 1
		      relocate = TRUE;
d1690 1
a1690 1
			  return FALSE;
d1706 5
a1710 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d1754 1
a1754 1
		      return FALSE;
d1761 1
a1761 1
		  return FALSE;
d1768 1
a1768 1
  return TRUE;
d1774 1
a1774 1
static bfd_boolean
a1793 1
      bfd_byte *loc;
d1866 3
a1868 2
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1882 1
      bfd_byte *loc;
d1917 4
a1920 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1926 1
      bfd_byte *loc;
d1943 4
a1946 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d1954 1
a1954 1
  return TRUE;
d1959 1
a1959 1
static bfd_boolean
d2093 1
a2093 1
  return TRUE;
d2103 1
a2103 1
bfd_boolean
d2123 1
a2123 1
    return TRUE;
d2208 1
a2208 1
  return TRUE;
d2216 1
a2216 1
  return FALSE;
@


1.46.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a48 2
static bfd_boolean elf_m68k_discard_copies
  PARAMS ((struct elf_link_hash_entry *, PTR));
a274 2
#define elf_m68k_hash_entry(ent) ((struct elf_m68k_link_hash_entry *) (ent))

d285 13
d311 2
a312 1
  struct bfd_hash_entry *ret = entry;
d316 6
a321 5
  if (ret == NULL)
    ret = bfd_hash_allocate (table,
			     sizeof (struct elf_m68k_link_hash_entry));
  if (ret == NULL)
    return ret;
d324 7
a330 3
  ret = _bfd_elf_link_hash_newfunc (ret, table, string);
  if (ret != NULL)
    elf_m68k_hash_entry (ret)->pcrel_relocs_copied = NULL;
d332 1
a332 1
  return ret;
d692 2
a695 8
	      if (sec->flags & SEC_READONLY
		  /* Don't set DF_TEXTREL yet for PC relative
		     relocations, they might be discarded later.  */
		  && !(ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		       || ELF32_R_TYPE (rel->r_info) == R_68K_PC32))
		    info->flags |= DF_TEXTREL;

d716 1
a716 1
			= elf_m68k_hash_entry (h);
d1157 3
a1159 3
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_m68k_discard_copies,
			    (PTR) info);
d1285 1
a1285 1
/* This function is called via elf_link_hash_traverse if we are
d1288 1
a1288 1
   are defined in regular objects.  For the normal shared case, it
d1292 1
a1292 5
   relocate_section routine.

   We also check whether any of the remaining relocations apply
   against a readonly section, and set the DF_TEXTREL flag in this
   case.  */
d1296 1
a1296 1
     struct elf_link_hash_entry *h;
d1302 2
a1303 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1305 1
a1305 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
d1307 2
a1308 17
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
    {
      if ((info->flags & DF_TEXTREL) == 0)
	{
	  /* Look for relocations against read-only sections.  */
	  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
	       s != NULL;
	       s = s->next)
	    if ((s->section->flags & SEC_READONLY) != 0)
	      {
		info->flags |= DF_TEXTREL;
		break;
	      }
	}

      return TRUE;
    }
d1310 1
a1310 3
  for (s = elf_m68k_hash_entry (h)->pcrel_relocs_copied;
       s != NULL;
       s = s->next)
@


1.46.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d93 1
a93 1
  /* GNU extension to record C++ vtable hierarchy.  */
d107 1
a107 1
  /* GNU extension to record C++ vtable member usage.  */
d184 1
d345 1
a345 1
/* Keep m68k-specific flags in the ELF header.  */
d382 1
a382 1
/* Display the flags field.  */
d1011 1
d1017 1
d1459 1
@


1.46.10.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a1099 11
/* This is the condition under which elf_m68k_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf_m68k_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1419 1
a1419 3
		      && (WILL_CALL_FINISH_DYNAMIC_SYMBOL
			  (elf_hash_table (info)->dynamic_sections_created,
			   info->shared, h))
d1421 1
a1421 4
			  || (! info->symbolic
			      && h->dynindx != -1
			      && (h->elf_link_hash_flags
				  & ELF_LINK_FORCED_LOCAL) == 0)
a1498 2
		bfd_boolean dyn;

d1502 1
a1502 2
		dyn = elf_hash_table (info)->dynamic_sections_created;
		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1504 2
a1505 4
			&& (info->symbolic
			    || h->dynindx == -1
			    || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
			&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)) != 0)
d1943 1
a1943 3
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
@


1.46.10.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a675 1
		  elf_section_data (sec)->sreloc = sreloc;
a1382 1
      bfd_boolean unresolved_reloc;
a1397 1
      unresolved_reloc = FALSE;
a1409 2

	  relocation = 0;
d1414 50
a1463 6
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
d1470 1
a1470 1
	    ;
d1474 1
a1474 1
	    ;
d1483 1
a1548 2
		else
		  unresolved_reloc = FALSE;
a1630 1
	  unresolved_reloc = FALSE;
a1646 1
	  unresolved_reloc = FALSE;
a1666 3
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
d1670 3
a1672 5
		  || (h != NULL
		      && h->dynindx != -1
		      && (!info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1682 20
d1717 2
d1720 1
a1720 6
		       && h->dynindx != -1
		       && (r_type == R_68K_PC8
			   || r_type == R_68K_PC16
			   || r_type == R_68K_PC32
			   || !info->shared
			   || !info->symbolic
d1724 1
d1726 1
a1726 1
		  outrel.r_addend = rel->r_addend;
a1729 1
		  /* This symbol is local, or marked to become local.  */
a1769 4
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

a1792 16
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     h->root.root.string);
	  return FALSE;
	}

d1799 1
a1799 5
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
d1801 6
a1806 8
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }
d1808 18
a1825 15
	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
d2191 1
a2191 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.46.10.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d430 1
a430 1
  if (info->relocatable)
d1361 1
a1361 1
  if (info->relocatable)
d2156 1
a2156 1
  BFD_ASSERT (! info->relocatable);
@


1.46.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a1400 1

d1409 4
a1412 1
	  bfd_boolean warned;
d1414 31
a1444 1
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
@


1.46.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1130 1
a1130 1
      if (info->executable)
d1406 1
a1406 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1660 10
a1669 1
		      if (bfd_is_abs_section (sec))
@


1.46.10.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d820 2
d826 4
a833 4
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

a839 3
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

@


1.45
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a182 2

#define USE_RELA
@


1.45.2.1
log
@Merge fixes from trunk.
@
text
@a281 3

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
a353 2
  ret->sym_sec.abfd = NULL;

d521 1
a521 2
		  if (h->dynindx == -1
		      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d598 1
a598 2
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
a624 1
		    || h->root.type == bfd_link_hash_defweak
d692 6
a697 7
	      /* We count the number of PC relative relocations we have
		 entered for this symbol, so that we can discard them
		 again if, in the -Bsymbolic case, the symbol is later
		 defined by a regular object, or, in the normal shared
		 case, the symbol is forced to be local.  Note that this
		 function is only called if we are using an m68kelf linker
		 hash table, which means that h is really a pointer to an
d699 4
a702 3
	      if (ELF32_R_TYPE (rel->r_info) == R_68K_PC8
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC16
		  || ELF32_R_TYPE (rel->r_info) == R_68K_PC32)
d704 1
a705 16
		  struct elf_m68k_pcrel_relocs_copied **head;

		  if (h != NULL)
		    {
		      struct elf_m68k_link_hash_entry *eh
			= (struct elf_m68k_link_hash_entry *) h;
		      head = &eh->pcrel_relocs_copied;
		    }
		  else
		    {
		      asection *s;
		      s = (bfd_section_from_r_symndx
			   (abfd, &elf_m68k_hash_table (info)->sym_sec,
			    sec, r_symndx));
		      if (s == NULL)
			return false;
d707 1
a707 3
		      head = ((struct elf_m68k_pcrel_relocs_copied **)
			      &elf_section_data (s)->local_dynrel);
		    }
d709 1
a709 1
		  for (p = *head; p != NULL; p = p->next)
d719 2
a720 2
		      p->next = *head;
		      *head = p;
d955 1
a955 2
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1126 5
a1130 7
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     For the normal shared case we discard the PC relative relocs
     against symbols that have become local due to visibility changes.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
d1133 1
a1133 1
				 (PTR) info);
d1260 4
a1263 7
   creating a shared object.  In the -Bsymbolic case it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal shared case, if
   discards space for pc-relative relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */
d1266 1
a1266 1
elf_m68k_discard_copies (h, inf)
d1268 1
a1268 1
     PTR inf;
a1269 1
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d1275 2
a1276 3
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      || (!info->symbolic
	  && (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
d1597 1
a1597 3
	  if (h == NULL
	      || (info->shared
		  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))
@


1.44
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d2114 2
a2115 6
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
a2127 34
  /* Read this BFD's symbols if we haven't done so already, or get the cached
     copy if it exists.  */
  if (symtab_hdr->contents != NULL)
    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
  else
    {
      /* Go get them off disk.  */
      amt = symtab_hdr->sh_info * sizeof (Elf32_External_Sym);
      if (info->keep_memory)
	extsyms = (Elf32_External_Sym *) bfd_alloc (abfd, amt);
      else
	extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
      if (extsyms == NULL)
	goto error_return;
      if (! info->keep_memory)
	free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (extsyms, amt, abfd) != amt)
	goto error_return;
      if (info->keep_memory)
	symtab_hdr->contents = (unsigned char *) extsyms;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
    {
      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	goto error_return;
    }
a2134 2
  if (! info->keep_memory)
    free_relocs = internal_relocs;
d2165 2
a2166 3
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  Elf_Internal_Sym isym;
d2168 11
a2178 5
	  /* A local symbol.  */
	  esym = extsyms + ELF32_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2180 2
a2181 1
	  targetsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d2205 5
a2209 6
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
  if (free_relocs != NULL)
    free (free_relocs);
d2213 5
a2217 6
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
  if (free_relocs != NULL)
    free (free_relocs);
@


1.43
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d40 1
a40 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d757 2
a758 2
elf_m68k_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d788 1
a788 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.42
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2214 2
a2215 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
@


1.41
log
@	* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Formatting.
@
text
@d2214 2
a2215 1
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
@


1.41.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2214 1
a2214 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
@


1.41.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d40 1
a40 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d757 2
a758 2
elf_m68k_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d788 3
a790 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d2116 6
a2121 2
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
d2134 34
d2175 2
d2207 4
d2212 4
a2215 13
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols if we haven't done so already.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }
d2217 1
a2217 2
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d2241 6
a2246 5
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
d2250 6
a2255 5
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
@


1.41.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d183 2
@


1.40
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d416 1
a416 1
    fprintf (file, _ (" [m68000]"));
@


1.40.2.1
log
@merge from trunk
@
text
@d416 1
a416 1
    fprintf (file, _(" [m68000]"));
d2214 1
a2214 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
@


1.39
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1311 3
a1345 20
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d2311 1
@


1.38
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d343 1
a343 1
  ret = (struct elf_m68k_link_hash_table *) bfd_alloc (abfd, amt);
d350 1
a350 1
      bfd_release (abfd, ret);
@


1.37
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d1273 3
@


1.36
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.


bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.


gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.


include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@d1657 1
d1664 2
d1670 1
a1670 4
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = false;
		}
a1678 1
		  relocate = false;
a1718 1
		      relocate = false;
@


1.35
log
@2002-02-08  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-arm.h: Fix formatting of _("...").
        * elf32-d10v.c: Likewise.
        * elf32-m68k.c: Likewise.
        * elf32-mips.c: Likewise.
@
text
@d415 3
@


1.35.2.1
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.

bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.

gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.

include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@a414 3
  if (elf_elfheader (abfd)->e_flags & EF_M68000)
    fprintf (file, _(" [m68000]"));

@


1.35.2.2
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1656 1
	      relocate = false;
a1662 2
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = true, relocate = true;
d1667 4
a1670 1
		memset (&outrel, 0, sizeof outrel);
d1679 1
d1720 1
@


1.35.2.3
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a1272 3

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_m68k_link_hash_entry *) h->root.root.u.i.link;
@


1.35.2.4
log
@Merge from mainline
@
text
@a1310 3
  if (info->relocateable)
    return true;

d1343 20
a2327 1
#define elf_backend_rela_normal		1
@


1.34
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d410 1
a410 1
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d413 1
a413 1
    fprintf (file, _ (" [cpu32]"));
@


1.33
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a59 2
static boolean elf32_m68k_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
a367 20
/* Copy m68k-specific data from one module to another */
static boolean
elf32_m68k_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword in_flags;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  in_flags = elf_elfheader (ibfd)->e_flags;

  elf_elfheader (obfd)->e_flags = in_flags;
  elf_flags_init (obfd) = true;

  return true;
}

a2309 2
#define bfd_elf32_bfd_copy_private_bfd_data \
                                        elf32_m68k_copy_private_bfd_data
@


1.32
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d808 1
a808 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
d2151 1
d2154 1
d2176 1
d2178 1
a2178 1
	extsyms = (Elf32_External_Sym *) bfd_alloc (abfd, symtab_hdr->sh_size);
d2180 1
a2180 1
	extsyms = (Elf32_External_Sym *) bfd_malloc (symtab_hdr->sh_size);
d2186 1
a2186 2
	  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
	      != symtab_hdr->sh_size))
d2192 12
d2242 2
d2247 3
a2249 3
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irel->r_info),
				    &isym);
d2275 2
d2284 2
@


1.31
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1683 5
a1687 16
	      if (elf_section_data (input_section)->stab_info == NULL)
		outrel.r_offset = rel->r_offset;
	      else
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &elf_hash_table (info)->stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

@


1.30
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1392 1
a1392 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.29
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d1647 1
@


1.28
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d2205 1
a2205 1
	symtab_hdr->contents = extsyms;
@


1.27
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d537 1
a537 1
	      if (h->got.refcount == -1)
a538 2
		  h->got.refcount = 1;

d551 1
a551 2
	      else
		h->got.refcount++;
d563 1
a563 1
					 bfd_alloc (abfd, size));
a566 1
		  memset (local_got_refcounts, -1, (size_t) size);
d568 1
a568 1
	      if (local_got_refcounts[r_symndx] == -1)
a569 2
		  local_got_refcounts[r_symndx] = 1;

d579 1
a579 2
	      else
		local_got_refcounts[r_symndx]++;
d599 1
a599 4
	  if (h->plt.refcount == -1)
	    h->plt.refcount = 1;
	  else
	    h->plt.refcount++;
d624 1
a624 4
	  if (h->plt.refcount == -1)
	    h->plt.refcount = 1;
	  else
	    h->plt.refcount++;
d652 1
a652 4
		  if (h->plt.refcount == -1)
		    h->plt.refcount = 1;
		  else
		    h->plt.refcount++;
d664 1
a664 4
	      if (h->plt.refcount == -1)
		h->plt.refcount = 1;
	      else
		h->plt.refcount++;
d2341 1
@


1.26
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d67 1
a67 1
  PARAMS ((int));
d2311 2
a2312 2
elf32_m68k_reloc_type_class (type)
     int type;
d2314 1
a2314 1
  switch (type)
@


1.25
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1477 2
a1478 1
	  else if (info->shared && !info->symbolic
@


1.24
log
@	* elf32-m68k.c (elf32_m68k_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_m68k_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_m68k_reloc_type_class): New function.
	(elf_backend_reloc_type_class): Define.
@
text
@d343 1
d345 1
a345 2
  ret = ((struct elf_m68k_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_m68k_link_hash_table)));
d561 1
a561 1
		  size_t size;
d563 2
a564 1
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
d570 1
a570 1
		  memset (local_got_refcounts, -1, size);
d754 1
a754 1
			   bfd_alloc (dynobj, sizeof *p));
d1268 3
d1273 1
a1273 1
	  if (!bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d1279 4
a1282 4
	  if (!bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || !bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || !bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || !bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d1288 3
a1290 4
	  if (!bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || !bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || !bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
					       sizeof (Elf32_External_Rela)))
d1296 1
a1296 1
	  if (!bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d1300 1
d1968 1
a1968 1
		       + (h->got.offset &~ 1));
d1982 1
a1982 1
					      + (h->got.offset & ~1)));
d1987 1
a1987 1
		      sgot->contents + (h->got.offset & ~1));
d2193 1
d2211 1
a2211 2
	extsyms = ((Elf32_External_Sym *)
		   bfd_alloc (abfd, symtab_hdr->sh_size));
d2213 1
a2213 2
	extsyms = ((Elf32_External_Sym *)
		   bfd_malloc (symtab_hdr->sh_size));
d2219 1
a2219 1
	  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d2235 2
a2236 1
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
@


1.23
log
@	* elf32-m68k.c (elf_m68k_relocate_section): Don't need the
	relocation value when resolving a reference from a debugging
	section.
@
text
@d66 2
d723 2
d1137 1
a1137 1
     bfd *output_bfd;
a1143 1
  boolean reltext;
a1184 1
  reltext = false;
d1230 1
a1230 22
	      asection *target;

	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  .rela.plt is actually associated with
		     .got.plt, which is never readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d1291 1
a1291 1
      if (reltext)
a1294 1
	  info->flags |= DF_TEXTREL;
d2305 17
d2352 1
@


1.22
log
@Update copyright notices
@
text
@d1466 8
a1473 1
		      && (input_section->flags & SEC_ALLOC) != 0
@


1.21
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
@


1.21.2.1
log
@	* elf32-m68k.c (elf_m68k_relocate_section): Don't need the
	relocation value when resolving a reference from a debugging
	section.
@
text
@d1465 1
a1465 8
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_68K_32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
@


1.21.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.20
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@a183 1

@


1.19
log
@2000-12-06  Kazu Hirata  <kazu@@hxi.com>

	* elf32-m32r.c: Fix formatting.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
@
text
@a1326 1
/*ARGSUSED*/
@


1.18
log
@Change the PLT entry 0 instruction sequence to actually work.
@
text
@d230 1
a230 1
  0, 0, 0, 0,             /* replace with offset to .got +8. */
d379 1
a379 1
 
d381 1
a381 1
 
d384 1
a384 1
 
a934 1

d2141 1
a2141 1
              elf_section_data (splt->output_section)->this_hdr.sh_entsize 
d2157 1
a2157 1
              elf_section_data (splt->output_section)->this_hdr.sh_entsize 
d2304 1
a2304 1
  
@


1.17
log
@add support for embedded relocs in m68k ELF port
@
text
@d227 2
d230 1
a230 1
  0, 0, 0, 0,             /* replaced with offset to .got + 4.  */
a231 2
  0, 0, 0, 0,             /* replace with offset to .got +8. */
  0, 0, 0, 0,             /* pad out to 24 bytes.  */
d2157 1
a2157 1
		          splt->contents + 10);
@


1.16
log
@Zero out the dynamic allocated content space.  Add a comment to remind us that
one day this ought to be fixed.
@
text
@d2182 138
@


1.15
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d1270 6
a1275 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
@


1.14
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d1310 1
@


1.13
log
@Reference count .plt and .got on x86 for garbage collection code.  Fix a
couple of m68k and ppc bugs discovered while testing x86 gc.
@
text
@d1482 3
a1484 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d1491 2
a1492 1
		     (!info->shared || info->no_undefined))))
@


1.12
log
@Fix building with --enable-targets=all
@
text
@d850 2
a851 2
  asection *sgot = NULL;
  asection *srelgot = NULL;
d858 5
a862 5
  if (dynobj)
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
    }
d890 1
a890 1
	  else
@


1.12.2.1
log
@Merge from mainline
@
text
@d1482 1
a1482 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1489 1
a1489 2
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
@


1.11
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d850 2
a851 2
  asection *sgot;
  asection *srelgot;
@


1.10
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d1488 2
a1489 1
		     input_section, rel->r_offset)))
@


1.9
log
@        * elf32-m68k.c (elf_cpu32_plt0_entry): Fix encoding.
        (elf_cpu32_plt_entry): Likewise.
@
text
@d1265 1
a1265 1
	  _bfd_strip_section_from_output (s);
@


1.8
log
@(elf_cpu32_plt0_entry): Use a1 instead of a0.
(elf_cpu32_plt_entry): Likewise.
 ----------------------------------------------------------------------
@
text
@d227 1
a227 1
  0x21, 0x7b, 0x01, 0x70, /* moveal %pc@@(0xc), %a0 */
d229 1
a229 1
  0x4e, 0xd1,             /* jmp %a0@@ */
d238 1
a238 1
  0x21, 0x7b, 0x01, 0x70,  /* moveal %pc@@(0xc), %a0 */
d240 1
a240 1
  0x4e, 0xd1,              /* jmp %a0@@ */
@


1.7
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d227 1
a227 1
  0x20, 0x7b, 0x01, 0x70, /* moveal %pc@@(0xc), %a0 */
d229 1
a229 1
  0x4e, 0xd0,             /* jmp %a0@@ */
d238 1
a238 1
  0x20, 0x7b, 0x01, 0x70,  /* moveal %pc@@(0xc), %a0 */
d240 1
a240 1
  0x4e, 0xd0,              /* jmp %a0@@ */
@


1.6
log
@	* elf32-m68k.c: Add some ATTRIBUTE_UNUSED.
	* m68klinux.c: Likewise.
@
text
@a45 2
static boolean elf_m68k_adjust_dynindx
  PARAMS ((struct elf_link_hash_entry *, PTR));
a1312 45
  /* If we are generating a shared library, we generate a section
     symbol for each output section for which we might need to copy
     relocs.  These are local symbols, which means that they must come
     first in the dynamic symbol table.  That means we must increment
     the dynamic symbol index of every other dynamic symbol.  */
  if (info->shared)
    {
      int c;

      c = 0;
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LINKER_CREATED) != 0
	      || (s->flags & SEC_ALLOC) == 0)
	    continue;

	  elf_section_data (s)->dynindx = c + 1;

	  /* These symbols will have no names, so we don't need to
             fiddle with dynstr_index.  */

	  ++c;
	}

      elf_link_hash_traverse (elf_hash_table (info),
			      elf_m68k_adjust_dynindx,
			      (PTR) &c);
      elf_hash_table (info)->dynsymcount += c;
    }

  return true;
}

/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
elf_m68k_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  int *cp = (int *) cparg;

  if (h->dynindx != -1)
    h->dynindx += *cp;
a2167 44

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;
      int c;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;

      c = 0;
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx;

	  if (elf_section_data (s)->dynindx == 0)
	    continue;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  BFD_ASSERT (indx > 0);
	  sym.st_shndx = indx;

	  bfd_elf32_swap_symbol_out (output_bfd, &sym,
				     (PTR) (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));

	  ++c;
	}

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info = c + 1;
    }
@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d124 1
a124 1
     bfd *abfd;
d169 1
a169 1
     bfd *abfd;
d794 1
a794 1
     struct bfd_link_info *info;
d1373 1
a1373 1
     PTR ignore;
@


1.4
log
@	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Avoid ambigous
	`else'.
@
text
@a2089 1
  int plt_entry0_size, plt_off1, plt_off2;
@


1.3
log
@Remove extra copy of elf32_m68k_copy_private_bfd_data.
@
text
@d1011 6
a1016 4
        if ( CPU32_FLAG (dynobj))
          s->_raw_size += PLT_CPU32_ENTRY_SIZE;
        else
	  s->_raw_size += PLT_ENTRY_SIZE;
@


1.2
log
@       * elf32-m68k.c (elf32_m68k_set_private_flags): New.
        (elf32_m68k_copy_private_bfd_data): New.
        (elf32_m68k_merge_private_bfd_data): New.
        (elf32_m68k_print_private_bfd_data): New.
        (CPU32_FLAG): Define.
        (PLT_CPU32_ENTRY_SIZE): Define.
        (elf_cpu32_plt0_entry): Declare.
        (elf_cpu32_plt_entry): Declare.
        (elf_m68k_adjust_dynamic_symbol): Generate cpu32 plt entries.
        (elf_m68k_finish_dynamic_symbol): Likewise.
        (elf_m68k_finish_dynamic_sections): Likewise.
        (elf_backend_plt_header_size): Remove definition.
        (bfd_elf32_bfd_copy_private_bfd_data): Define.
        (bfd_elf32_bfd_merge_private_bfd_data): Define.
        (bfd_elf32_bfd_set_private_flags): Define.
        (bfd_elf32_bfd_print_private_bfd_data): Define.
@
text
@a389 21
/* Copy backend specific data from one object module to another */
static boolean
elf32_m68k_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword in_flags;
  flagword out_flags;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  in_flags = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  elf_elfheader (obfd)->e_flags = in_flags;
  elf_flags_init (obfd) = true;

  return true;
}
@


1.1
log
@Initial revision
@
text
@d59 9
d223 27
d359 103
d1032 4
a1035 1
	s->_raw_size += PLT_ENTRY_SIZE;
d1052 4
a1055 1
      s->_raw_size += PLT_ENTRY_SIZE;
d1924 1
d1951 4
a1954 1
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d1961 19
a1979 3
      /* Fill in the entry in the procedure linkage table.  */
      memcpy (splt->contents + h->plt.offset, elf_m68k_plt_entry,
	      PLT_ENTRY_SIZE);
d1987 1
a1987 1
		  splt->contents + h->plt.offset + 4);
d1990 3
a1992 3
		  splt->contents + h->plt.offset + 10);
      bfd_put_32 (output_bfd, - (h->plt.offset + 16),
		  splt->contents + h->plt.offset + 16);
d2109 1
d2186 32
a2217 11
	  memcpy (splt->contents, elf_m68k_plt0_entry, PLT_ENTRY_SIZE);
	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset + 4
		       - (splt->output_section->vma + 2)),
		      splt->contents + 4);
	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset + 8
		       - (splt->output_section->vma + 10)),
		      splt->contents + 12);
a2218 3

      elf_section_data (splt->output_section)->this_hdr.sh_entsize
	= PLT_ENTRY_SIZE;
d2305 9
a2318 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

