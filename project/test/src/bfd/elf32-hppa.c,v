head	1.195;
access;
symbols
	sid-snapshot-20180601:1.195
	sid-snapshot-20180501:1.195
	sid-snapshot-20180401:1.195
	sid-snapshot-20180301:1.195
	sid-snapshot-20180201:1.195
	sid-snapshot-20180101:1.195
	sid-snapshot-20171201:1.195
	sid-snapshot-20171101:1.195
	sid-snapshot-20171001:1.195
	sid-snapshot-20170901:1.195
	sid-snapshot-20170801:1.195
	sid-snapshot-20170701:1.195
	sid-snapshot-20170601:1.195
	sid-snapshot-20170501:1.195
	sid-snapshot-20170401:1.195
	sid-snapshot-20170301:1.195
	sid-snapshot-20170201:1.195
	sid-snapshot-20170101:1.195
	sid-snapshot-20161201:1.195
	sid-snapshot-20161101:1.195
	sid-snapshot-20160901:1.195
	sid-snapshot-20160801:1.195
	sid-snapshot-20160701:1.195
	sid-snapshot-20160601:1.195
	sid-snapshot-20160501:1.195
	sid-snapshot-20160401:1.195
	sid-snapshot-20160301:1.195
	sid-snapshot-20160201:1.195
	sid-snapshot-20160101:1.195
	sid-snapshot-20151201:1.195
	sid-snapshot-20151101:1.195
	sid-snapshot-20151001:1.195
	sid-snapshot-20150901:1.195
	sid-snapshot-20150801:1.195
	sid-snapshot-20150701:1.195
	sid-snapshot-20150601:1.195
	sid-snapshot-20150501:1.195
	sid-snapshot-20150401:1.195
	sid-snapshot-20150301:1.195
	sid-snapshot-20150201:1.195
	sid-snapshot-20150101:1.195
	sid-snapshot-20141201:1.195
	sid-snapshot-20141101:1.195
	sid-snapshot-20141001:1.195
	sid-snapshot-20140901:1.195
	sid-snapshot-20140801:1.195
	sid-snapshot-20140701:1.195
	sid-snapshot-20140601:1.195
	sid-snapshot-20140501:1.195
	sid-snapshot-20140401:1.195
	sid-snapshot-20140301:1.195
	sid-snapshot-20140201:1.195
	sid-snapshot-20140101:1.195
	sid-snapshot-20131201:1.195
	sid-snapshot-20131101:1.195
	sid-snapshot-20131001:1.195
	binutils-2_24-branch:1.195.0.2
	binutils-2_24-branchpoint:1.195
	binutils-2_21_1:1.176
	sid-snapshot-20130901:1.195
	gdb_7_6_1-2013-08-30-release:1.192
	sid-snapshot-20130801:1.195
	sid-snapshot-20130701:1.195
	sid-snapshot-20130601:1.195
	sid-snapshot-20130501:1.195
	gdb_7_6-2013-04-26-release:1.192
	sid-snapshot-20130401:1.194
	binutils-2_23_2:1.187
	gdb_7_6-branch:1.192.0.2
	gdb_7_6-2013-03-12-branchpoint:1.192
	sid-snapshot-20130301:1.192
	sid-snapshot-20130201:1.189
	sid-snapshot-20130101:1.188
	sid-snapshot-20121201:1.188
	gdb_7_5_1-2012-11-29-release:1.187
	binutils-2_23_1:1.187
	sid-snapshot-20121101:1.188
	binutils-2_23:1.187
	sid-snapshot-20121001:1.188
	sid-snapshot-20120901:1.187
	gdb_7_5-2012-08-17-release:1.187
	sid-snapshot-20120801:1.187
	binutils-2_23-branch:1.187.0.4
	binutils-2_23-branchpoint:1.187
	gdb_7_5-branch:1.187.0.2
	gdb_7_5-2012-07-18-branchpoint:1.187
	sid-snapshot-20120701:1.187
	sid-snapshot-20120601:1.186
	sid-snapshot-20120501:1.185
	binutils-2_22_branch:1.179.0.4
	gdb_7_4_1-2012-04-26-release:1.183
	sid-snapshot-20120401:1.184
	sid-snapshot-20120301:1.183
	sid-snapshot-20120201:1.183
	gdb_7_4-2012-01-24-release:1.183
	sid-snapshot-20120101:1.183
	gdb_7_4-branch:1.183.0.2
	gdb_7_4-2011-12-13-branchpoint:1.183
	sid-snapshot-20111201:1.182
	binutils-2_22:1.179
	sid-snapshot-20111101:1.181
	sid-snapshot-20111001:1.179
	binutils-2_22-branch:1.179.0.2
	binutils-2_22-branchpoint:1.179
	gdb_7_3_1-2011-09-04-release:1.176
	sid-snapshot-20110901:1.179
	sid-snapshot-20110801:1.179
	gdb_7_3-2011-07-26-release:1.176
	sid-snapshot-20110701:1.178
	sid-snapshot-20110601:1.176
	sid-snapshot-20110501:1.176
	gdb_7_3-branch:1.176.0.4
	gdb_7_3-2011-04-01-branchpoint:1.176
	sid-snapshot-20110401:1.176
	sid-snapshot-20110301:1.176
	sid-snapshot-20110201:1.176
	sid-snapshot-20110101:1.176
	binutils-2_21:1.176
	sid-snapshot-20101201:1.176
	binutils-2_21-branch:1.176.0.2
	binutils-2_21-branchpoint:1.176
	sid-snapshot-20101101:1.176
	sid-snapshot-20101001:1.175
	binutils-2_20_1:1.168
	gdb_7_2-2010-09-02-release:1.172
	sid-snapshot-20100901:1.174
	sid-snapshot-20100801:1.172
	gdb_7_2-branch:1.172.0.2
	gdb_7_2-2010-07-07-branchpoint:1.172
	sid-snapshot-20100701:1.172
	sid-snapshot-20100601:1.171
	sid-snapshot-20100501:1.171
	sid-snapshot-20100401:1.171
	gdb_7_1-2010-03-18-release:1.171
	sid-snapshot-20100301:1.171
	gdb_7_1-branch:1.171.0.2
	gdb_7_1-2010-02-18-branchpoint:1.171
	sid-snapshot-20100201:1.170
	sid-snapshot-20100101:1.169
	gdb_7_0_1-2009-12-22-release:1.168
	sid-snapshot-20091201:1.169
	sid-snapshot-20091101:1.168
	binutils-2_20:1.168
	gdb_7_0-2009-10-06-release:1.168
	sid-snapshot-20091001:1.168
	gdb_7_0-branch:1.168.0.8
	gdb_7_0-2009-09-16-branchpoint:1.168
	arc-sim-20090309:1.162
	binutils-arc-20081103-branch:1.163.0.14
	binutils-arc-20081103-branchpoint:1.163
	binutils-2_20-branch:1.168.0.6
	binutils-2_20-branchpoint:1.168
	sid-snapshot-20090901:1.168
	sid-snapshot-20090801:1.168
	msnyder-checkpoint-072509-branch:1.168.0.4
	msnyder-checkpoint-072509-branchpoint:1.168
	sid-snapshot-20090701:1.168
	dje-cgen-play1-branch:1.168.0.2
	dje-cgen-play1-branchpoint:1.168
	sid-snapshot-20090601:1.166
	sid-snapshot-20090501:1.166
	sid-snapshot-20090401:1.166
	arc-20081103-branch:1.163.0.12
	arc-20081103-branchpoint:1.163
	arc-insight_6_8-branch:1.162.0.6
	arc-insight_6_8-branchpoint:1.162
	insight_6_8-branch:1.162.0.4
	insight_6_8-branchpoint:1.162
	sid-snapshot-20090301:1.164
	binutils-2_19_1:1.163
	sid-snapshot-20090201:1.164
	sid-snapshot-20090101:1.164
	reverse-20081226-branch:1.164.0.2
	reverse-20081226-branchpoint:1.164
	sid-snapshot-20081201:1.164
	multiprocess-20081120-branch:1.163.0.10
	multiprocess-20081120-branchpoint:1.163
	sid-snapshot-20081101:1.163
	binutils-2_19:1.163
	sid-snapshot-20081001:1.163
	reverse-20080930-branch:1.163.0.8
	reverse-20080930-branchpoint:1.163
	binutils-2_19-branch:1.163.0.6
	binutils-2_19-branchpoint:1.163
	sid-snapshot-20080901:1.163
	sid-snapshot-20080801:1.163
	reverse-20080717-branch:1.163.0.4
	reverse-20080717-branchpoint:1.163
	sid-snapshot-20080701:1.163
	msnyder-reverse-20080609-branch:1.163.0.2
	msnyder-reverse-20080609-branchpoint:1.163
	drow-reverse-20070409-branch:1.153.0.2
	drow-reverse-20070409-branchpoint:1.153
	sid-snapshot-20080601:1.163
	sid-snapshot-20080501:1.163
	sid-snapshot-20080403:1.163
	sid-snapshot-20080401:1.163
	gdb_6_8-2008-03-27-release:1.162
	sid-snapshot-20080301:1.162
	gdb_6_8-branch:1.162.0.2
	gdb_6_8-2008-02-26-branchpoint:1.162
	sid-snapshot-20080201:1.161
	sid-snapshot-20080101:1.160
	sid-snapshot-20071201:1.157
	sid-snapshot-20071101:1.157
	gdb_6_7_1-2007-10-29-release:1.156
	gdb_6_7-2007-10-10-release:1.156
	sid-snapshot-20071001:1.157
	gdb_6_7-branch:1.156.0.4
	gdb_6_7-2007-09-07-branchpoint:1.156
	binutils-2_18:1.156
	binutils-2_18-branch:1.156.0.2
	binutils-2_18-branchpoint:1.156
	insight_6_6-20070208-release:1.149
	binutils-csl-coldfire-4_1-32:1.144
	binutils-csl-sourcerygxx-4_1-32:1.144
	gdb_6_6-2006-12-18-release:1.149
	binutils-csl-innovasic-fido-3_4_4-33:1.144
	binutils-csl-sourcerygxx-3_4_4-32:1.127
	binutils-csl-coldfire-4_1-30:1.144
	binutils-csl-sourcerygxx-4_1-30:1.144
	binutils-csl-coldfire-4_1-28:1.144
	binutils-csl-sourcerygxx-4_1-29:1.144
	binutils-csl-sourcerygxx-4_1-28:1.144
	gdb_6_6-branch:1.149.0.2
	gdb_6_6-2006-11-15-branchpoint:1.149
	binutils-csl-arm-2006q3-27:1.144
	binutils-csl-sourcerygxx-4_1-27:1.144
	binutils-csl-arm-2006q3-26:1.144
	binutils-csl-sourcerygxx-4_1-26:1.144
	binutils-csl-sourcerygxx-4_1-25:1.144
	binutils-csl-sourcerygxx-4_1-24:1.144
	binutils-csl-sourcerygxx-4_1-23:1.144
	insight_6_5-20061003-release:1.144
	gdb-csl-symbian-6_4_50_20060226-12:1.142
	binutils-csl-sourcerygxx-4_1-21:1.144
	binutils-csl-arm-2006q3-21:1.144
	binutils-csl-sourcerygxx-4_1-22:1.144
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.144
	binutils-csl-sourcerygxx-4_1-20:1.144
	binutils-csl-arm-2006q3-19:1.144
	binutils-csl-sourcerygxx-4_1-19:1.144
	binutils-csl-sourcerygxx-4_1-18:1.144
	binutils-csl-renesas-4_1-9:1.144
	gdb-csl-sourcerygxx-3_4_4-25:1.140
	binutils-csl-sourcerygxx-3_4_4-25:1.127
	nickrob-async-20060828-mergepoint:1.145
	gdb-csl-symbian-6_4_50_20060226-11:1.142
	binutils-csl-renesas-4_1-8:1.144
	binutils-csl-renesas-4_1-7:1.144
	binutils-csl-renesas-4_1-6:1.144
	gdb-csl-sourcerygxx-4_1-17:1.142
	binutils-csl-sourcerygxx-4_1-17:1.144
	gdb-csl-20060226-branch-local-2:1.142
	gdb-csl-sourcerygxx-4_1-14:1.142
	binutils-csl-sourcerygxx-4_1-14:1.144
	binutils-csl-sourcerygxx-4_1-15:1.144
	gdb-csl-sourcerygxx-4_1-13:1.142
	binutils-csl-sourcerygxx-4_1-13:1.144
	binutils-2_17:1.144
	gdb-csl-sourcerygxx-4_1-12:1.142
	binutils-csl-sourcerygxx-4_1-12:1.144
	gdb-csl-sourcerygxx-3_4_4-21:1.142
	binutils-csl-sourcerygxx-3_4_4-21:1.144
	gdb_6_5-20060621-release:1.144
	binutils-csl-wrs-linux-3_4_4-24:1.127
	binutils-csl-wrs-linux-3_4_4-23:1.127
	gdb-csl-sourcerygxx-4_1-9:1.142
	binutils-csl-sourcerygxx-4_1-9:1.144
	gdb-csl-sourcerygxx-4_1-8:1.142
	binutils-csl-sourcerygxx-4_1-8:1.144
	gdb-csl-sourcerygxx-4_1-7:1.142
	binutils-csl-sourcerygxx-4_1-7:1.144
	gdb-csl-arm-2006q1-6:1.142
	binutils-csl-arm-2006q1-6:1.144
	gdb-csl-sourcerygxx-4_1-6:1.142
	binutils-csl-sourcerygxx-4_1-6:1.144
	binutils-csl-wrs-linux-3_4_4-22:1.127
	gdb-csl-symbian-6_4_50_20060226-10:1.142
	gdb-csl-symbian-6_4_50_20060226-9:1.142
	gdb-csl-symbian-6_4_50_20060226-8:1.142
	gdb-csl-coldfire-4_1-11:1.142
	binutils-csl-coldfire-4_1-11:1.144
	gdb-csl-sourcerygxx-3_4_4-19:1.142
	binutils-csl-sourcerygxx-3_4_4-19:1.144
	gdb-csl-coldfire-4_1-10:1.142
	gdb_6_5-branch:1.144.0.14
	gdb_6_5-2006-05-14-branchpoint:1.144
	binutils-csl-coldfire-4_1-10:1.144
	gdb-csl-sourcerygxx-4_1-5:1.142
	binutils-csl-sourcerygxx-4_1-5:1.144
	nickrob-async-20060513-branch:1.144.0.12
	nickrob-async-20060513-branchpoint:1.144
	gdb-csl-sourcerygxx-4_1-4:1.142
	binutils-csl-sourcerygxx-4_1-4:1.144
	msnyder-reverse-20060502-branch:1.144.0.10
	msnyder-reverse-20060502-branchpoint:1.144
	binutils-csl-wrs-linux-3_4_4-21:1.127
	gdb-csl-morpho-4_1-4:1.142
	binutils-csl-morpho-4_1-4:1.144
	gdb-csl-sourcerygxx-3_4_4-17:1.142
	binutils-csl-sourcerygxx-3_4_4-17:1.144
	binutils-csl-wrs-linux-3_4_4-20:1.127
	readline_5_1-import-branch:1.144.0.8
	readline_5_1-import-branchpoint:1.144
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.142
	binutils-2_17-branch:1.144.0.6
	binutils-2_17-branchpoint:1.144
	gdb-csl-symbian-20060226-branch:1.142.0.4
	gdb-csl-symbian-20060226-branchpoint:1.142
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.142
	msnyder-reverse-20060331-branch:1.144.0.4
	msnyder-reverse-20060331-branchpoint:1.144
	binutils-csl-2_17-branch:1.144.0.2
	binutils-csl-2_17-branchpoint:1.144
	gdb-csl-available-20060303-branch:1.143.0.2
	gdb-csl-available-20060303-branchpoint:1.143
	gdb-csl-20060226-branch:1.142.0.2
	gdb-csl-20060226-branchpoint:1.142
	gdb_6_4-20051202-release:1.140
	msnyder-fork-checkpoint-branch:1.140.0.6
	msnyder-fork-checkpoint-branchpoint:1.140
	gdb-csl-gxxpro-6_3-branch:1.140.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.140
	gdb_6_4-branch:1.140.0.2
	gdb_6_4-2005-11-01-branchpoint:1.140
	gdb-csl-arm-20051020-branch:1.139.0.2
	gdb-csl-arm-20051020-branchpoint:1.139
	binutils-csl-gxxpro-3_4-branch:1.127.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.127
	binutils-2_16_1:1.127
	msnyder-tracepoint-checkpoint-branch:1.132.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.132
	gdb-csl-arm-20050325-2005-q1b:1.127
	binutils-csl-arm-2005q1b:1.127
	binutils-2_16:1.127
	gdb-csl-arm-20050325-2005-q1a:1.127
	binutils-csl-arm-2005q1a:1.127
	csl-arm-20050325-branch:1.127.0.6
	csl-arm-20050325-branchpoint:1.127
	binutils-csl-arm-2005q1-branch:1.127.0.4
	binutils-csl-arm-2005q1-branchpoint:1.127
	binutils-2_16-branch:1.127.0.2
	binutils-2_16-branchpoint:1.127
	csl-arm-2004-q3d:1.123
	gdb_6_3-20041109-release:1.122
	gdb_6_3-branch:1.122.0.2
	gdb_6_3-20041019-branchpoint:1.122
	csl-arm-2004-q3:1.122
	drow_intercu-merge-20040921:1.122
	drow_intercu-merge-20040915:1.120
	jimb-gdb_6_2-e500-branch:1.117.0.6
	jimb-gdb_6_2-e500-branchpoint:1.117
	gdb_6_2-20040730-release:1.117
	gdb_6_2-branch:1.117.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.117
	gdb_6_1_1-20040616-release:1.111
	binutils-2_15:1.111.6.2
	binutils-2_15-branchpoint:1.111
	csl-arm-2004-q1a:1.116
	csl-arm-2004-q1:1.116
	gdb_6_1-2004-04-05-release:1.111
	drow_intercu-merge-20040402:1.116
	drow_intercu-merge-20040327:1.115
	ezannoni_pie-20040323-branch:1.114.0.2
	ezannoni_pie-20040323-branchpoint:1.114
	cagney_tramp-20040321-mergepoint:1.113
	cagney_tramp-20040309-branch:1.111.0.12
	cagney_tramp-20040309-branchpoint:1.111
	gdb_6_1-branch:1.111.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.111
	drow_intercu-20040221-branch:1.111.0.8
	drow_intercu-20040221-branchpoint:1.111
	binutils-2_15-branch:1.111.0.6
	cagney_bfdfile-20040213-branch:1.111.0.4
	cagney_bfdfile-20040213-branchpoint:1.111
	drow-cplus-merge-20040208:1.111
	carlton_dictionary-20040126-merge:1.111
	cagney_bigcore-20040122-branch:1.111.0.2
	cagney_bigcore-20040122-branchpoint:1.111
	drow-cplus-merge-20040113:1.111
	csl-arm-2003-q4:1.111
	drow-cplus-merge-20031224:1.111
	drow-cplus-merge-20031220:1.111
	carlton_dictionary-20031215-merge:1.111
	drow-cplus-merge-20031214:1.111
	carlton-dictionary-20031111-merge:1.109
	gdb_6_0-2003-10-04-release:1.99
	kettenis_sparc-20030918-branch:1.105.0.4
	kettenis_sparc-20030918-branchpoint:1.105
	carlton_dictionary-20030917-merge:1.105
	ezannoni_pie-20030916-branchpoint:1.105
	ezannoni_pie-20030916-branch:1.105.0.2
	cagney_x86i386-20030821-branch:1.104.0.2
	cagney_x86i386-20030821-branchpoint:1.104
	carlton_dictionary-20030805-merge:1.100
	carlton_dictionary-20030627-merge:1.100
	gdb_6_0-branch:1.99.0.6
	gdb_6_0-2003-06-23-branchpoint:1.99
	jimb-ppc64-linux-20030613-branch:1.99.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.99
	binutils-2_14:1.97.18.1
	cagney_convert-20030606-branch:1.99.0.2
	cagney_convert-20030606-branchpoint:1.99
	cagney_writestrings-20030508-branch:1.98.0.8
	cagney_writestrings-20030508-branchpoint:1.98
	jimb-ppc64-linux-20030528-branch:1.98.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.98
	carlton_dictionary-20030523-merge:1.98
	cagney_fileio-20030521-branch:1.98.0.4
	cagney_fileio-20030521-branchpoint:1.98
	kettenis_i386newframe-20030517-mergepoint:1.98
	jimb-ppc64-linux-20030509-branch:1.98.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.98
	kettenis_i386newframe-20030504-mergepoint:1.97
	carlton_dictionary-20030430-merge:1.97
	binutils-2_14-branch:1.97.0.18
	binutils-2_14-branchpoint:1.97
	kettenis_i386newframe-20030419-branch:1.97.0.16
	kettenis_i386newframe-20030419-branchpoint:1.97
	carlton_dictionary-20030416-merge:1.97
	cagney_frameaddr-20030409-mergepoint:1.97
	kettenis_i386newframe-20030406-branch:1.97.0.14
	kettenis_i386newframe-20030406-branchpoint:1.97
	cagney_frameaddr-20030403-branchpoint:1.97
	cagney_frameaddr-20030403-branch:1.97.0.12
	cagney_framebase-20030330-mergepoint:1.97
	cagney_framebase-20030326-branch:1.97.0.10
	cagney_framebase-20030326-branchpoint:1.97
	cagney_lazyid-20030317-branch:1.97.0.8
	cagney_lazyid-20030317-branchpoint:1.97
	kettenis-i386newframe-20030316-mergepoint:1.97
	offbyone-20030313-branch:1.97.0.6
	offbyone-20030313-branchpoint:1.97
	kettenis-i386newframe-20030308-branch:1.97.0.4
	kettenis-i386newframe-20030308-branchpoint:1.97
	carlton_dictionary-20030305-merge:1.97
	cagney_offbyone-20030303-branch:1.97.0.2
	cagney_offbyone-20030303-branchpoint:1.97
	carlton_dictionary-20030207-merge:1.93
	interps-20030202-branch:1.93.0.4
	interps-20030202-branchpoint:1.93
	cagney-unwind-20030108-branch:1.93.0.2
	cagney-unwind-20030108-branchpoint:1.93
	binutils-2_13_2_1:1.87.2.1
	binutils-2_13_2:1.87.2.1
	carlton_dictionary-20021223-merge:1.92
	gdb_5_3-2002-12-12-release:1.89
	carlton_dictionary-20021115-merge:1.89
	binutils-2_13_1:1.87.2.1
	kseitz_interps-20021105-merge:1.89
	kseitz_interps-20021103-merge:1.89
	drow-cplus-merge-20021020:1.89
	drow-cplus-merge-20021025:1.89
	carlton_dictionary-20021025-merge:1.89
	carlton_dictionary-20021011-merge:1.89
	drow-cplus-branch:1.89.0.12
	drow-cplus-branchpoint:1.89
	kseitz_interps-20020930-merge:1.89
	carlton_dictionary-20020927-merge:1.89
	carlton_dictionary-branch:1.89.0.10
	carlton_dictionary-20020920-branchpoint:1.89
	sid-20020905-branchpoint:1.89
	sid-20020905-branch:1.89.0.8
	gdb_5_3-branch:1.89.0.6
	gdb_5_3-2002-09-04-branchpoint:1.89
	kseitz_interps-20020829-merge:1.89
	cagney_sysregs-20020825-branch:1.89.0.4
	cagney_sysregs-20020825-branchpoint:1.89
	readline_4_3-import-branch:1.89.0.2
	readline_4_3-import-branchpoint:1.89
	binutils-2_13:1.87
	gdb_5_2_1-2002-07-23-release:1.72
	binutils-2_13-branchpoint:1.87
	binutils-2_13-branch:1.87.0.2
	kseitz_interps-20020528-branch:1.81.0.4
	kseitz_interps-20020528-branchpoint:1.81
	cagney_regbuf-20020515-branch:1.81.0.2
	cagney_regbuf-20020515-branchpoint:1.81
	binutils-2_12_1:1.70.2.5
	jimb-macro-020506-branch:1.80.0.2
	jimb-macro-020506-branchpoint:1.80
	gdb_5_2-2002-04-29-release:1.72
	binutils-2_12:1.70.2.2
	gdb_5_2-branch:1.72.0.2
	gdb_5_2-2002-03-03-branchpoint:1.72
	binutils-2_12-branch:1.70.0.2
	binutils-2_12-branchpoint:1.70
	gdb_5_1_1-2002-01-24-release:1.41
	gdb_5_1_0_1-2002-01-03-release:1.41
	cygnus_cvs_20020108_pre:1.68
	gdb_5_1_0_1-2002-01-03-branch:1.41.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.41
	gdb_5_1-2001-11-21-release:1.41
	gdb_s390-2001-09-26-branch:1.41.0.4
	gdb_s390-2001-09-26-branchpoint:1.41
	gdb_5_1-2001-07-29-branch:1.41.0.2
	gdb_5_1-2001-07-29-branchpoint:1.41
	binutils-2_11_2:1.25.2.6
	binutils-2_11_1:1.25.2.6
	binutils-2_11:1.25.2.3
	x86_64versiong3:1.27
	binutils-2_11-branch:1.25.0.2
	insight-precleanup-2001-01-01:1.22
	binutils-2_10_1:1.10
	binutils-2_10:1.10
	gdb-premipsmulti-2000-06-06-branch:1.12.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.12
	gdb_5_0-2000-05-19-release:1.10
	gdb_4_18_2-2000-05-18-release:1.10
	gdb_4_95_1-2000-05-11-snapshot:1.10
	gdb_4_95_0-2000-04-27-snapshot:1.10
	gdb_5_0-2000-04-10-branch:1.10.0.4
	gdb_5_0-2000-04-10-branchpoint:1.10
	binutils-2_10-branch:1.10.0.2
	binutils-2_10-branchpoint:1.10
	binutils_latest_snapshot:1.195
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.195
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.194;

1.194
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2013.02.10.04.36.31;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.188;

1.188
date	2012.09.02.12.17.25;	author hjl;	state Exp;
branches;
next	1.187;

1.187
date	2012.06.29.14.45.58;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.185;

1.185
date	2012.04.24.05.12.33;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2012.03.13.06.04.33;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2011.12.11.15.42.10;	author danglin;	state Exp;
branches;
next	1.182;

1.182
date	2011.11.06.20.25.17;	author danglin;	state Exp;
branches;
next	1.181;

1.181
date	2011.10.26.09.47.58;	author nickc;	state Exp;
branches;
next	1.180;

1.180
date	2011.10.20.16.27.04;	author nickc;	state Exp;
branches;
next	1.179;

1.179
date	2011.07.03.13.37.06;	author tschwinge;	state Exp;
branches
	1.179.2.1;
next	1.178;

1.178
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2011.06.10.14.04.23;	author nickc;	state Exp;
branches;
next	1.176;

1.176
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.174;

1.174
date	2010.08.25.14.53.41;	author hjl;	state Exp;
branches;
next	1.173;

1.173
date	2010.08.18.12.24.05;	author palves;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.170;

1.170
date	2010.01.30.16.09.43;	author danglin;	state Exp;
branches;
next	1.169;

1.169
date	2009.11.08.20.47.24;	author danglin;	state Exp;
branches;
next	1.168;

1.168
date	2009.06.18.14.18.28;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2009.06.17.18.08.34;	author hjl;	state Exp;
branches;
next	1.166;

1.166
date	2009.03.19.10.40.06;	author schwab;	state Exp;
branches;
next	1.165;

1.165
date	2009.03.01.18.15.53;	author danglin;	state Exp;
branches;
next	1.164;

1.164
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2008.02.15.08.27.18;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.160;

1.160
date	2007.12.31.11.01.54;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	2007.12.28.23.43.45;	author danglin;	state Exp;
branches;
next	1.158;

1.158
date	2007.12.28.14.45.34;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.156;

1.156
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2007.01.27.22.43.49;	author danglin;	state Exp;
branches;
next	1.149;

1.149
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.148;

1.148
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2006.05.24.11.05.42;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.142;

1.142
date	2006.02.21.01.51.58;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2005.12.27.22.50.08;	author danglin;	state Exp;
branches;
next	1.140;

1.140
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2005.10.06.19.21.13;	author drow;	state Exp;
branches;
next	1.138;

1.138
date	2005.08.18.01.28.22;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2005.07.29.02.46.02;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2005.07.08.06.19.58;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2005.06.27.23.43.43;	author danglin;	state Exp;
branches;
next	1.134;

1.134
date	2005.06.21.13.53.55;	author danglin;	state Exp;
branches;
next	1.133;

1.133
date	2005.06.20.13.06.27;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2005.05.19.08.26.53;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2005.05.05.14.33.47;	author hjl;	state Exp;
branches;
next	1.130;

1.130
date	2005.05.04.15.53.13;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2005.05.04.11.00.11;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2005.03.07.06.01.17;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2005.01.31.23.13.20;	author bje;	state Exp;
branches;
next	1.125;

1.125
date	2005.01.11.09.32.47;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2004.11.30.00.50.36;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.10.21.15.28.21;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2004.09.17.07.14.26;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.09.16.14.52.03;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2004.08.13.08.41.51;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.27.22.30.24;	author thorpej;	state Exp;
branches;
next	1.117;

1.117
date	2004.06.24.04.46.19;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2004.03.25.12.48.33;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.22.02.28.15;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2004.03.20.23.16.39;	author hjl;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.20.00.42.10;	author danglin;	state Exp;
branches;
next	1.111;

1.111
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches
	1.111.6.1
	1.111.8.1
	1.111.12.1;
next	1.110;

1.110
date	2003.11.17.21.31.10;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2003.11.11.13.32.37;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2003.11.04.23.52.58;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.10.17.16.43.14;	author danglin;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.10.18.46.08;	author danglin;	state Exp;
branches;
next	1.104;

1.104
date	2003.08.21.14.00.05;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.07.08.38.07;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2003.08.07.07.25.34;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.28.20.27.51;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2003.02.19.14.14.16;	author amodra;	state Exp;
branches
	1.97.16.1
	1.97.18.1;
next	1.96;

1.96
date	2003.02.17.18.24.38;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2003.02.08.08.18.41;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2003.02.08.01.10.30;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2003.01.08.02.19.23;	author danglin;	state Exp;
branches;
next	1.92;

1.92
date	2002.12.12.10.17.14;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2002.11.28.11.55.39;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.22.01.27.19;	author amodra;	state Exp;
branches
	1.89.10.1
	1.89.12.1;
next	1.88;

1.88
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2002.07.01.08.06.43;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.25.09.40.43;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.06.00.29.20;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.05.13.31.59;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.81;

1.81
date	2002.05.10.02.03.47;	author amodra;	state Exp;
branches
	1.81.2.1
	1.81.4.1;
next	1.80;

1.80
date	2002.05.04.02.06.22;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2002.04.28.12.29.46;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2002.04.23.05.11.23;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2002.04.08.11.01.42;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.04.04.19.53.36;	author drow;	state Exp;
branches;
next	1.75;

1.75
date	2002.03.28.03.27.42;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2002.03.05.17.55.55;	author law;	state Exp;
branches;
next	1.73;

1.73
date	2002.03.05.05.25.13;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2002.02.19.12.40.24;	author jakub;	state Exp;
branches;
next	1.71;

1.71
date	2002.02.12.11.08.27;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2002.02.05.00.00.23;	author amodra;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2002.01.21.10.29.08;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2001.12.17.00.52.34;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2001.12.07.11.12.17;	author jakub;	state Exp;
branches;
next	1.66;

1.66
date	2001.12.07.02.00.57;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2001.12.03.08.42.38;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.24.07.39.11;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.23.12.17.15;	author jakub;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.19.03.52.37;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.19.03.01.43;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.19.01.25.00;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.10.00.23.35;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.02.10.37.04;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.31.15.32.09;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.31.14.58.14;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.23.03.55.24;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.15.09.45.46;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.15.07.28.44;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.03.08.33.18;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.28.08.56.51;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.26.09.25.04;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.25.07.28.13;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.25.07.10.59;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.20.10.37.34;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.08.05.47.01;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.03.05.10.39;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.30.00.34.10;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.27.02.42.09;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.21.05.47.12;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.05.04.39.31;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.03.02.41.58;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.30.14.30.33;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.28.10.12.04;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.25.03.46.49;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.18.03.11.13;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.30.16.13.26;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.30.13.34.41;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.21.08.09.25;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.15.13.47.56;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.27.07.11.41;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.13.10.14.14;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.14.11.12.52;	author amodra;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.01.14.07.03.48;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.14.05.58.15;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.05.13.20.09;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.02.09.09.27;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.27.17.30.17;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.21.13.40.00;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.21.10.13.18;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.18.12.22.41;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.15.10.24.50;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.14.12.55.45;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.05.05.03.43;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.09.07.23.07;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.02.00.12.46;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.11.13.07.56;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	99.08.17.07.53.37;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.08.11.09.30.20;	author law;	state Exp;
branches;
next	1.7;

1.7
date	99.08.09.23.47.04;	author law;	state Exp;
branches;
next	1.6;

1.6
date	99.07.12.10.29.17;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.07.35.00;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.29.01.28.26;	author law;	state Exp;
branches;
next	1.3;

1.3
date	99.06.24.20.01.44;	author law;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.12.20.29;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.179.2.1
date	2012.01.28.02.22.00;	author danglin;	state Exp;
branches;
next	1.179.2.2;

1.179.2.2
date	2012.01.28.02.25.35;	author danglin;	state Exp;
branches;
next	1.179.2.3;

1.179.2.3
date	2012.05.11.12.24.23;	author nickc;	state Exp;
branches;
next	;

1.111.6.1
date	2004.04.08.12.41.40;	author amodra;	state Exp;
branches;
next	1.111.6.2;

1.111.6.2
date	2004.04.09.18.28.00;	author drow;	state Exp;
branches;
next	1.111.6.3;

1.111.6.3
date	2004.07.29.03.45.13;	author thorpej;	state Exp;
branches;
next	;

1.111.8.1
date	2004.03.27.17.37.32;	author drow;	state Exp;
branches;
next	1.111.8.2;

1.111.8.2
date	2004.04.02.16.47.34;	author drow;	state Exp;
branches;
next	1.111.8.3;

1.111.8.3
date	2004.09.16.17.00.22;	author drow;	state Exp;
branches;
next	1.111.8.4;

1.111.8.4
date	2004.09.21.20.44.01;	author drow;	state Exp;
branches;
next	;

1.111.12.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;

1.97.16.1
date	2003.05.18.09.43.40;	author kettenis;	state Exp;
branches;
next	;

1.97.18.1
date	2003.06.02.18.18.53;	author drow;	state Exp;
branches;
next	;

1.89.10.1
date	2002.12.23.19.37.40;	author carlton;	state Exp;
branches;
next	1.89.10.2;

1.89.10.2
date	2003.02.07.19.17.37;	author carlton;	state Exp;
branches;
next	1.89.10.3;

1.89.10.3
date	2003.03.06.00.56.14;	author carlton;	state Exp;
branches;
next	1.89.10.4;

1.89.10.4
date	2003.05.23.18.40.22;	author carlton;	state Exp;
branches;
next	1.89.10.5;

1.89.10.5
date	2003.06.27.21.49.14;	author carlton;	state Exp;
branches;
next	1.89.10.6;

1.89.10.6
date	2003.09.17.21.27.51;	author carlton;	state Exp;
branches;
next	1.89.10.7;

1.89.10.7
date	2003.11.11.23.50.16;	author carlton;	state Exp;
branches;
next	1.89.10.8;

1.89.10.8
date	2003.12.15.23.59.24;	author carlton;	state Exp;
branches;
next	;

1.89.12.1
date	2003.12.14.20.26.39;	author drow;	state Exp;
branches;
next	;

1.87.2.1
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	;

1.81.2.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.81.4.1
date	2002.06.20.01.30.07;	author kseitz;	state Exp;
branches;
next	1.81.4.2;

1.81.4.2
date	2002.07.22.21.46.43;	author kseitz;	state Exp;
branches;
next	1.81.4.3;

1.81.4.3
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	1.81.4.4;

1.81.4.4
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	;

1.70.2.1
date	2002.02.17.23.12.07;	author amodra;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2002.02.19.13.10.20;	author jakub;	state Exp;
branches;
next	1.70.2.3;

1.70.2.3
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	1.70.2.4;

1.70.2.4
date	2002.04.04.14.52.57;	author amodra;	state Exp;
branches;
next	1.70.2.5;

1.70.2.5
date	2002.04.27.08.30.10;	author amodra;	state Exp;
branches;
next	;

1.25.2.1
date	2001.02.13.10.27.39;	author amodra;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.03.16.05.23.11;	author amodra;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2001.03.21.08.09.51;	author amodra;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.04.30.13.36.04;	author amodra;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2001.05.23.03.41.09;	author amodra;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2001.06.11.10.04.10;	author amodra;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2001.06.21.06.03.45;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.195
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@/* BFD back-end for HP PA-RISC ELF files.
   Copyright 1990-2013 Free Software Foundation, Inc.

   Original code by
	Center for Software Science
	Department of Computer Science
	University of Utah
   Largely rewritten by Alan Modra <alan@@linuxcare.com.au>
   Naming cleanup by Carlos O'Donell <carlos@@systemhalted.org>
   TLS support written by Randolph Chung <tausq@@debian.org>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/hppa.h"
#include "libhppa.h"
#include "elf32-hppa.h"
#define ARCH_SIZE		32
#include "elf32-hppa.h"
#include "elf-hppa.h"

/* In order to gain some understanding of code in this file without
   knowing all the intricate details of the linker, note the
   following:

   Functions named elf32_hppa_* are called by external routines, other
   functions are only called locally.  elf32_hppa_* functions appear
   in this file more or less in the order in which they are called
   from external routines.  eg. elf32_hppa_check_relocs is called
   early in the link process, elf32_hppa_finish_dynamic_sections is
   one of the last functions.  */

/* We use two hash tables to hold information for linking PA ELF objects.

   The first is the elf32_hppa_link_hash_table which is derived
   from the standard ELF linker hash table.  We use this as a place to
   attach other hash tables and static information.

   The second is the stub hash table which is derived from the
   base BFD hash table.  The stub hash table holds the information
   necessary to build the linker stubs during a link.

   There are a number of different stubs generated by the linker.

   Long branch stub:
   :		ldil LR'X,%r1
   :		be,n RR'X(%sr4,%r1)

   PIC long branch stub:
   :		b,l .+8,%r1
   :		addil LR'X - ($PIC_pcrel$0 - 4),%r1
   :		be,n RR'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)

   Import stub to call shared library routine from normal object file
   (single sub-space version)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		bv %r0(%r21)
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from shared library
   (single sub-space version)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		bv %r0(%r21)
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from normal object file
   (multiple sub-space support)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Import stub to call shared library routine from shared library
   (multiple sub-space support)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Export stub to return from shared lib routine (multiple sub-space support)
   One of these is created for each exported procedure in a shared
   library (and stored in the shared lib).  Shared lib routines are
   called via the first instruction in the export stub so that we can
   do an inter-space return.  Not required for single sub-space.
   :		bl,n X,%rp			; trap the return
   :		nop
   :		ldw -24(%sp),%rp		; restore the original rp
   :		ldsid (%rp),%r1
   :		mtsp %r1,%sr0
   :		be,n 0(%sr0,%rp)		; inter-space return.  */


/* Variable names follow a coding style.
   Please follow this (Apps Hungarian) style:

   Structure/Variable         		Prefix
   elf_link_hash_table			"etab"
   elf_link_hash_entry			"eh"

   elf32_hppa_link_hash_table		"htab"
   elf32_hppa_link_hash_entry		"hh"

   bfd_hash_table			"btab"
   bfd_hash_entry			"bh"

   bfd_hash_table containing stubs	"bstab"
   elf32_hppa_stub_hash_entry		"hsh"

   elf32_hppa_dyn_reloc_entry		"hdh"

   Always remember to use GNU Coding Style. */

#define PLT_ENTRY_SIZE 8
#define GOT_ENTRY_SIZE 4
#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

static const bfd_byte plt_stub[] =
{
  0x0e, 0x80, 0x10, 0x96,  /* 1: ldw	0(%r20),%r22		*/
  0xea, 0xc0, 0xc0, 0x00,  /*    bv	%r0(%r22)		*/
  0x0e, 0x88, 0x10, 0x95,  /*    ldw	4(%r20),%r21		*/
#define PLT_STUB_ENTRY (3*4)
  0xea, 0x9f, 0x1f, 0xdd,  /*    b,l	1b,%r20			*/
  0xd6, 0x80, 0x1c, 0x1e,  /*    depi	0,31,2,%r20		*/
  0x00, 0xc0, 0xff, 0xee,  /* 9: .word	fixup_func		*/
  0xde, 0xad, 0xbe, 0xef   /*    .word	fixup_ltp		*/
};

/* Section name for stubs is the associated section name plus this
   string.  */
#define STUB_SUFFIX ".stub"

/* We don't need to copy certain PC- or GP-relative dynamic relocs
   into a shared object's dynamic section.  All the relocs of the
   limited class we are interested in, are absolute.  */
#ifndef RELATIVE_DYNRELOCS
#define RELATIVE_DYNRELOCS 0
#define IS_ABSOLUTE_RELOC(r_type) 1
#endif

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

enum elf32_hppa_stub_type
{
  hppa_stub_long_branch,
  hppa_stub_long_branch_shared,
  hppa_stub_import,
  hppa_stub_import_shared,
  hppa_stub_export,
  hppa_stub_none
};

struct elf32_hppa_stub_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry bh_root;

  /* The stub section.  */
  asection *stub_sec;

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;

  /* Given the symbol's value and its section we can determine its final
     value when building the stubs (so the stub knows where to jump.  */
  bfd_vma target_value;
  asection *target_section;

  enum elf32_hppa_stub_type stub_type;

  /* The symbol table entry, if any, that this was derived from.  */
  struct elf32_hppa_link_hash_entry *hh;

  /* Where this stub is being called from, or, in the case of combined
     stub sections, the first input section in the group.  */
  asection *id_sec;
};

struct elf32_hppa_link_hash_entry
{
  struct elf_link_hash_entry eh;

  /* A pointer to the most recently used stub hash entry against this
     symbol.  */
  struct elf32_hppa_stub_hash_entry *hsh_cache;

  /* Used to count relocations for delayed sizing of relocation
     sections.  */
  struct elf32_hppa_dyn_reloc_entry
  {
    /* Next relocation in the chain.  */
    struct elf32_hppa_dyn_reloc_entry *hdh_next;

    /* The input section of the reloc.  */
    asection *sec;

    /* Number of relocs copied in this section.  */
    bfd_size_type count;

#if RELATIVE_DYNRELOCS
  /* Number of relative relocs copied for the input section.  */
    bfd_size_type relative_count;
#endif
  } *dyn_relocs;

  enum
  {
    GOT_UNKNOWN = 0, GOT_NORMAL = 1, GOT_TLS_GD = 2, GOT_TLS_LDM = 4, GOT_TLS_IE = 8
  } tls_type;

  /* Set if this symbol is used by a plabel reloc.  */
  unsigned int plabel:1;
};

struct elf32_hppa_link_hash_table
{
  /* The main hash table.  */
  struct elf_link_hash_table etab;

  /* The stub hash table.  */
  struct bfd_hash_table bstab;

  /* Linker stub bfd.  */
  bfd *stub_bfd;

  /* Linker call-backs.  */
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);

  /* Array to keep track of which stub sections have been created, and
     information on stub grouping.  */
  struct map_stub
  {
    /* This is the section to which stubs in the group will be
       attached.  */
    asection *link_sec;
    /* The stub section.  */
    asection *stub_sec;
  } *stub_group;

  /* Assorted information used by elf32_hppa_size_stubs.  */
  unsigned int bfd_count;
  int top_index;
  asection **input_list;
  Elf_Internal_Sym **all_local_syms;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Used during a final link to store the base of the text and data
     segments so that we can perform SEGREL relocations.  */
  bfd_vma text_segment_base;
  bfd_vma data_segment_base;

  /* Whether we support multiple sub-spaces for shared libs.  */
  unsigned int multi_subspace:1;

  /* Flags set when various size branches are detected.  Used to
     select suitable defaults for the stub group size.  */
  unsigned int has_12bit_branch:1;
  unsigned int has_17bit_branch:1;
  unsigned int has_22bit_branch:1;

  /* Set if we need a .plt stub to support lazy dynamic linking.  */
  unsigned int need_plt_stub:1;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  /* Data for LDM relocations.  */
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;
};

/* Various hash macros and functions.  */
#define hppa_link_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == HPPA32_ELF_DATA ? ((struct elf32_hppa_link_hash_table *) ((p)->hash)) : NULL)

#define hppa_elf_hash_entry(ent) \
  ((struct elf32_hppa_link_hash_entry *)(ent))

#define hppa_stub_hash_entry(ent) \
  ((struct elf32_hppa_stub_hash_entry *)(ent))

#define hppa_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

#define hppa_elf_local_got_tls_type(abfd) \
  ((char *)(elf_local_got_offsets (abfd) + (elf_tdata (abfd)->symtab_hdr.sh_info * 2)))

#define hh_name(hh) \
  (hh ? hh->eh.root.root.string : "<undef>")

#define eh_name(eh) \
  (eh ? eh->root.root.string : "<undef>")

/* Assorted hash table functions.  */

/* Initialize an entry in the stub hash table.  */

static struct bfd_hash_entry *
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_stub_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_hppa_stub_hash_entry *hsh;

      /* Initialize the local fields.  */
      hsh = hppa_stub_hash_entry (entry);
      hsh->stub_sec = NULL;
      hsh->stub_offset = 0;
      hsh->target_value = 0;
      hsh->target_section = NULL;
      hsh->stub_type = hppa_stub_long_branch;
      hsh->hh = NULL;
      hsh->id_sec = NULL;
    }

  return entry;
}

/* Initialize an entry in the link hash table.  */

static struct bfd_hash_entry *
hppa_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_hppa_link_hash_entry *hh;

      /* Initialize the local fields.  */
      hh = hppa_elf_hash_entry (entry);
      hh->hsh_cache = NULL;
      hh->dyn_relocs = NULL;
      hh->plabel = 0;
      hh->tls_type = GOT_UNKNOWN;
    }

  return entry;
}

/* Create the derived linker hash table.  The PA ELF port uses the derived
   hash table to keep information specific to the PA ELF linker (without
   using static variables).  */

static struct bfd_link_hash_table *
elf32_hppa_link_hash_table_create (bfd *abfd)
{
  struct elf32_hppa_link_hash_table *htab;
  bfd_size_type amt = sizeof (*htab);

  htab = bfd_zmalloc (amt);
  if (htab == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&htab->etab, abfd, hppa_link_hash_newfunc,
				      sizeof (struct elf32_hppa_link_hash_entry),
				      HPPA32_ELF_DATA))
    {
      free (htab);
      return NULL;
    }

  /* Init the stub hash table too.  */
  if (!bfd_hash_table_init (&htab->bstab, stub_hash_newfunc,
			    sizeof (struct elf32_hppa_stub_hash_entry)))
    return NULL;

  htab->text_segment_base = (bfd_vma) -1;
  htab->data_segment_base = (bfd_vma) -1;
  return &htab->etab.root;
}

/* Free the derived linker hash table.  */

static void
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *btab)
{
  struct elf32_hppa_link_hash_table *htab
    = (struct elf32_hppa_link_hash_table *) btab;

  bfd_hash_table_free (&htab->bstab);
  _bfd_elf_link_hash_table_free (btab);
}

/* Build a name for an entry in the stub hash table.  */

static char *
hppa_stub_name (const asection *input_section,
		const asection *sym_sec,
		const struct elf32_hppa_link_hash_entry *hh,
		const Elf_Internal_Rela *rela)
{
  char *stub_name;
  bfd_size_type len;

  if (hh)
    {
      len = 8 + 1 + strlen (hh_name (hh)) + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	sprintf (stub_name, "%08x_%s+%x",
		 input_section->id & 0xffffffff,
		 hh_name (hh),
		 (int) rela->r_addend & 0xffffffff);
    }
  else
    {
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	sprintf (stub_name, "%08x_%x:%x+%x",
		 input_section->id & 0xffffffff,
		 sym_sec->id & 0xffffffff,
		 (int) ELF32_R_SYM (rela->r_info) & 0xffffffff,
		 (int) rela->r_addend & 0xffffffff);
    }
  return stub_name;
}

/* Look up an entry in the stub hash.  Stub entries are cached because
   creating the stub name takes a bit of time.  */

static struct elf32_hppa_stub_hash_entry *
hppa_get_stub_entry (const asection *input_section,
		     const asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hh,
		     const Elf_Internal_Rela *rela,
		     struct elf32_hppa_link_hash_table *htab)
{
  struct elf32_hppa_stub_hash_entry *hsh_entry;
  const asection *id_sec;

  /* If this input section is part of a group of sections sharing one
     stub section, then use the id of the first section in the group.
     Stub names need to include a section id, as there may well be
     more than one stub used to reach say, printf, and we need to
     distinguish between them.  */
  id_sec = htab->stub_group[input_section->id].link_sec;

  if (hh != NULL && hh->hsh_cache != NULL
      && hh->hsh_cache->hh == hh
      && hh->hsh_cache->id_sec == id_sec)
    {
      hsh_entry = hh->hsh_cache;
    }
  else
    {
      char *stub_name;

      stub_name = hppa_stub_name (id_sec, sym_sec, hh, rela);
      if (stub_name == NULL)
	return NULL;

      hsh_entry = hppa_stub_hash_lookup (&htab->bstab,
					  stub_name, FALSE, FALSE);
      if (hh != NULL)
	hh->hsh_cache = hsh_entry;

      free (stub_name);
    }

  return hsh_entry;
}

/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct elf32_hppa_stub_hash_entry *
hppa_add_stub (const char *stub_name,
	       asection *section,
	       struct elf32_hppa_link_hash_table *htab)
{
  asection *link_sec;
  asection *stub_sec;
  struct elf32_hppa_stub_hash_entry *hsh;

  link_sec = htab->stub_group[section->id].link_sec;
  stub_sec = htab->stub_group[section->id].stub_sec;
  if (stub_sec == NULL)
    {
      stub_sec = htab->stub_group[link_sec->id].stub_sec;
      if (stub_sec == NULL)
	{
	  size_t namelen;
	  bfd_size_type len;
	  char *s_name;

	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (htab->stub_bfd, len);
	  if (s_name == NULL)
	    return NULL;

	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
	  if (stub_sec == NULL)
	    return NULL;
	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
	}
      htab->stub_group[section->id].stub_sec = stub_sec;
    }

  /* Enter this entry into the linker stub hash table.  */
  hsh = hppa_stub_hash_lookup (&htab->bstab, stub_name,
				      TRUE, FALSE);
  if (hsh == NULL)
    {
      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
			     section->owner,
			     stub_name);
      return NULL;
    }

  hsh->stub_sec = stub_sec;
  hsh->stub_offset = 0;
  hsh->id_sec = link_sec;
  return hsh;
}

/* Determine the type of stub needed, if any, for a call.  */

static enum elf32_hppa_stub_type
hppa_type_of_stub (asection *input_sec,
		   const Elf_Internal_Rela *rela,
		   struct elf32_hppa_link_hash_entry *hh,
		   bfd_vma destination,
		   struct bfd_link_info *info)
{
  bfd_vma location;
  bfd_vma branch_offset;
  bfd_vma max_branch_offset;
  unsigned int r_type;

  if (hh != NULL
      && hh->eh.plt.offset != (bfd_vma) -1
      && hh->eh.dynindx != -1
      && !hh->plabel
      && (info->shared
	  || !hh->eh.def_regular
	  || hh->eh.root.type == bfd_link_hash_defweak))
    {
      /* We need an import stub.  Decide between hppa_stub_import
	 and hppa_stub_import_shared later.  */
      return hppa_stub_import;
    }

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + rela->r_offset);

  branch_offset = destination - location - 8;
  r_type = ELF32_R_TYPE (rela->r_info);

  /* Determine if a long branch stub is needed.  parisc branch offsets
     are relative to the second instruction past the branch, ie. +8
     bytes on from the branch instruction location.  The offset is
     signed and counts in units of 4 bytes.  */
  if (r_type == (unsigned int) R_PARISC_PCREL17F)
    max_branch_offset = (1 << (17 - 1)) << 2;

  else if (r_type == (unsigned int) R_PARISC_PCREL12F)
    max_branch_offset = (1 << (12 - 1)) << 2;

  else /* R_PARISC_PCREL22F.  */
    max_branch_offset = (1 << (22 - 1)) << 2;

  if (branch_offset + max_branch_offset >= 2*max_branch_offset)
    return hppa_stub_long_branch;

  return hppa_stub_none;
}

/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.
   IN_ARG contains the link info pointer.  */

#define LDIL_R1		0x20200000	/* ldil  LR'XXX,%r1		*/
#define BE_SR4_R1	0xe0202002	/* be,n  RR'XXX(%sr4,%r1)	*/

#define BL_R1		0xe8200000	/* b,l   .+8,%r1		*/
#define ADDIL_R1	0x28200000	/* addil LR'XXX,%r1,%r1		*/
#define DEPI_R1		0xd4201c1e	/* depi  0,31,2,%r1		*/

#define ADDIL_DP	0x2b600000	/* addil LR'XXX,%dp,%r1		*/
#define LDW_R1_R21	0x48350000	/* ldw   RR'XXX(%sr0,%r1),%r21	*/
#define BV_R0_R21	0xeaa0c000	/* bv    %r0(%r21)		*/
#define LDW_R1_R19	0x48330000	/* ldw   RR'XXX(%sr0,%r1),%r19	*/

#define ADDIL_R19	0x2a600000	/* addil LR'XXX,%r19,%r1	*/
#define LDW_R1_DP	0x483b0000	/* ldw   RR'XXX(%sr0,%r1),%dp	*/

#define LDSID_R21_R1	0x02a010a1	/* ldsid (%sr0,%r21),%r1	*/
#define MTSP_R1		0x00011820	/* mtsp  %r1,%sr0		*/
#define BE_SR0_R21	0xe2a00000	/* be    0(%sr0,%r21)		*/
#define STW_RP		0x6bc23fd1	/* stw   %rp,-24(%sr0,%sp)	*/

#define BL22_RP		0xe800a002	/* b,l,n XXX,%rp		*/
#define BL_RP		0xe8400002	/* b,l,n XXX,%rp		*/
#define NOP		0x08000240	/* nop				*/
#define LDW_RP		0x4bc23fd1	/* ldw   -24(%sr0,%sp),%rp	*/
#define LDSID_RP_R1	0x004010a1	/* ldsid (%sr0,%rp),%r1		*/
#define BE_SR0_RP	0xe0400002	/* be,n  0(%sr0,%rp)		*/

#ifndef R19_STUBS
#define R19_STUBS 1
#endif

#if R19_STUBS
#define LDW_R1_DLT	LDW_R1_R19
#else
#define LDW_R1_DLT	LDW_R1_DP
#endif

static bfd_boolean
hppa_build_one_stub (struct bfd_hash_entry *bh, void *in_arg)
{
  struct elf32_hppa_stub_hash_entry *hsh;
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value;
  bfd_vma insn;
  bfd_vma off;
  int val;
  int size;

  /* Massage our args to the form they really have.  */
  hsh = hppa_stub_hash_entry (bh);
  info = (struct bfd_link_info *)in_arg;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  stub_sec = hsh->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  hsh->stub_offset = stub_sec->size;
  loc = stub_sec->contents + hsh->stub_offset;

  stub_bfd = stub_sec->owner;

  switch (hsh->stub_type)
    {
    case hppa_stub_long_branch:
      /* Create the long branch.  A long branch is formed with "ldil"
	 loading the upper bits of the target address into a register,
	 then branching with "be" which adds in the lower bits.
	 The "be" has its delay slot nullified.  */
      sym_value = (hsh->target_value
		   + hsh->target_section->output_offset
		   + hsh->target_section->output_section->vma);

      val = hppa_field_adjust (sym_value, 0, e_lrsel);
      insn = hppa_rebuild_insn ((int) LDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);

      val = hppa_field_adjust (sym_value, 0, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      size = 8;
      break;

    case hppa_stub_long_branch_shared:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (hsh->target_value
		   + hsh->target_section->output_offset
		   + hsh->target_section->output_section->vma);

      /* And this is where we are coming from, more or less.  */
      sym_value -= (hsh->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      bfd_put_32 (stub_bfd, (bfd_vma) BL_R1, loc);
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_lrsel);
      insn = hppa_rebuild_insn ((int) ADDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 8);
      size = 12;
      break;

    case hppa_stub_import:
    case hppa_stub_import_shared:
      off = hsh->hh->eh.plt.offset;
      if (off >= (bfd_vma) -2)
	abort ();

      off &= ~ (bfd_vma) 1;
      sym_value = (off
		   + htab->splt->output_offset
		   + htab->splt->output_section->vma
		   - elf_gp (htab->splt->output_section->owner));

      insn = ADDIL_DP;
#if R19_STUBS
      if (hsh->stub_type == hppa_stub_import_shared)
	insn = ADDIL_R19;
#endif
      val = hppa_field_adjust (sym_value, 0, e_lrsel),
      insn = hppa_rebuild_insn ((int) insn, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);

      /* It is critical to use lrsel/rrsel here because we are using
	 two different offsets (+0 and +4) from sym_value.  If we use
	 lsel/rsel then with unfortunate sym_values we will round
	 sym_value+4 up to the next 2k block leading to a mis-match
	 between the lsel and rsel value.  */
      val = hppa_field_adjust (sym_value, 0, e_rrsel);
      insn = hppa_rebuild_insn ((int) LDW_R1_R21, val, 14);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      if (htab->multi_subspace)
	{
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 8);

	  bfd_put_32 (stub_bfd, (bfd_vma) LDSID_R21_R1, loc + 12);
	  bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,      loc + 16);
	  bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_R21,   loc + 20);
	  bfd_put_32 (stub_bfd, (bfd_vma) STW_RP,       loc + 24);

	  size = 28;
	}
      else
	{
	  bfd_put_32 (stub_bfd, (bfd_vma) BV_R0_R21, loc + 8);
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 12);

	  size = 16;
	}

      break;

    case hppa_stub_export:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (hsh->target_value
		   + hsh->target_section->output_offset
		   + hsh->target_section->output_section->vma);

      /* And this is where we are coming from.  */
      sym_value -= (hsh->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      if (sym_value - 8 + (1 << (17 + 1)) >= (1 << (17 + 2))
	  && (!htab->has_22bit_branch
	      || sym_value - 8 + (1 << (22 + 1)) >= (1 << (22 + 2))))
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	     hsh->target_section->owner,
	     stub_sec,
	     (long) hsh->stub_offset,
	     hsh->bh_root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_fsel) >> 2;
      if (!htab->has_22bit_branch)
	insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
      else
	insn = hppa_rebuild_insn ((int) BL22_RP, val, 22);
      bfd_put_32 (stub_bfd, insn, loc);

      bfd_put_32 (stub_bfd, (bfd_vma) NOP,         loc + 4);
      bfd_put_32 (stub_bfd, (bfd_vma) LDW_RP,      loc + 8);
      bfd_put_32 (stub_bfd, (bfd_vma) LDSID_RP_R1, loc + 12);
      bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,     loc + 16);
      bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_RP,   loc + 20);

      /* Point the function symbol at the stub.  */
      hsh->hh->eh.root.u.def.section = stub_sec;
      hsh->hh->eh.root.u.def.value = stub_sec->size;

      size = 24;
      break;

    default:
      BFD_FAIL ();
      return FALSE;
    }

  stub_sec->size += size;
  return TRUE;
}

#undef LDIL_R1
#undef BE_SR4_R1
#undef BL_R1
#undef ADDIL_R1
#undef DEPI_R1
#undef LDW_R1_R21
#undef LDW_R1_DLT
#undef LDW_R1_R19
#undef ADDIL_R19
#undef LDW_R1_DP
#undef LDSID_R21_R1
#undef MTSP_R1
#undef BE_SR0_R21
#undef STW_RP
#undef BV_R0_R21
#undef BL_RP
#undef NOP
#undef LDW_RP
#undef LDSID_RP_R1
#undef BE_SR0_RP

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
hppa_size_one_stub (struct bfd_hash_entry *bh, void *in_arg)
{
  struct elf32_hppa_stub_hash_entry *hsh;
  struct elf32_hppa_link_hash_table *htab;
  int size;

  /* Massage our args to the form they really have.  */
  hsh = hppa_stub_hash_entry (bh);
  htab = in_arg;

  if (hsh->stub_type == hppa_stub_long_branch)
    size = 8;
  else if (hsh->stub_type == hppa_stub_long_branch_shared)
    size = 12;
  else if (hsh->stub_type == hppa_stub_export)
    size = 24;
  else /* hppa_stub_import or hppa_stub_import_shared.  */
    {
      if (htab->multi_subspace)
	size = 28;
      else
	size = 16;
    }

  hsh->stub_sec->size += size;
  return TRUE;
}

/* Return nonzero if ABFD represents an HPPA ELF32 file.
   Additionally we set the default architecture and machine.  */

static bfd_boolean
elf32_hppa_object_p (bfd *abfd)
{
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;

  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      /* GCC on hppa-linux produces binaries with OSABI=GNU,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_GNU &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      /* GCC on hppa-netbsd produces binaries with OSABI=NetBSD,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NETBSD &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
  else
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
	return FALSE;
    }

  flags = i_ehdrp->e_flags;
  switch (flags & (EF_PARISC_ARCH | EF_PARISC_WIDE))
    {
    case EFA_PARISC_1_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 10);
    case EFA_PARISC_1_1:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 11);
    case EFA_PARISC_2_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
    case EFA_PARISC_2_0 | EF_PARISC_WIDE:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
    }
  return TRUE;
}

/* Create the .plt and .got sections, and set up our hash table
   short-cuts to various dynamic sections.  */

static bfd_boolean
elf32_hppa_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf32_hppa_link_hash_table *htab;
  struct elf_link_hash_entry *eh;

  /* Don't try to create the .plt and .got twice.  */
  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;
  if (htab->splt != NULL)
    return TRUE;

  /* Call the generic code to do most of the work.  */
  if (! _bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;

  htab->splt = bfd_get_linker_section (abfd, ".plt");
  htab->srelplt = bfd_get_linker_section (abfd, ".rela.plt");

  htab->sgot = bfd_get_linker_section (abfd, ".got");
  htab->srelgot = bfd_get_linker_section (abfd, ".rela.got");

  htab->sdynbss = bfd_get_linker_section (abfd, ".dynbss");
  htab->srelbss = bfd_get_linker_section (abfd, ".rela.bss");

  /* hppa-linux needs _GLOBAL_OFFSET_TABLE_ to be visible from the main
     application, because __canonicalize_funcptr_for_compare needs it.  */
  eh = elf_hash_table (info)->hgot;
  eh->forced_local = 0;
  eh->other = STV_DEFAULT;
  return bfd_elf_link_record_dynamic_symbol (info, eh);
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_hppa_copy_indirect_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *eh_dir,
				 struct elf_link_hash_entry *eh_ind)
{
  struct elf32_hppa_link_hash_entry *hh_dir, *hh_ind;

  hh_dir = hppa_elf_hash_entry (eh_dir);
  hh_ind = hppa_elf_hash_entry (eh_ind);

  if (hh_ind->dyn_relocs != NULL)
    {
      if (hh_dir->dyn_relocs != NULL)
	{
	  struct elf32_hppa_dyn_reloc_entry **hdh_pp;
	  struct elf32_hppa_dyn_reloc_entry *hdh_p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (hdh_pp = &hh_ind->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )
	    {
	      struct elf32_hppa_dyn_reloc_entry *hdh_q;

	      for (hdh_q = hh_dir->dyn_relocs;
		   hdh_q != NULL;
		   hdh_q = hdh_q->hdh_next)
		if (hdh_q->sec == hdh_p->sec)
		  {
#if RELATIVE_DYNRELOCS
		    hdh_q->relative_count += hdh_p->relative_count;
#endif
		    hdh_q->count += hdh_p->count;
		    *hdh_pp = hdh_p->hdh_next;
		    break;
		  }
	      if (hdh_q == NULL)
		hdh_pp = &hdh_p->hdh_next;
	    }
	  *hdh_pp = hh_dir->dyn_relocs;
	}

      hh_dir->dyn_relocs = hh_ind->dyn_relocs;
      hh_ind->dyn_relocs = NULL;
    }

  if (ELIMINATE_COPY_RELOCS
      && eh_ind->root.type != bfd_link_hash_indirect
      && eh_dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      eh_dir->ref_dynamic |= eh_ind->ref_dynamic;
      eh_dir->ref_regular |= eh_ind->ref_regular;
      eh_dir->ref_regular_nonweak |= eh_ind->ref_regular_nonweak;
      eh_dir->needs_plt |= eh_ind->needs_plt;
    }
  else
    {
      if (eh_ind->root.type == bfd_link_hash_indirect
          && eh_dir->got.refcount <= 0)
        {
          hh_dir->tls_type = hh_ind->tls_type;
          hh_ind->tls_type = GOT_UNKNOWN;
        }

      _bfd_elf_link_hash_copy_indirect (info, eh_dir, eh_ind);
    }
}

static int
elf32_hppa_optimized_tls_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				int r_type, int is_local ATTRIBUTE_UNUSED)
{
  /* For now we don't support linker optimizations.  */
  return r_type;
}

/* Return a pointer to the local GOT, PLT and TLS reference counts
   for ABFD.  Returns NULL if the storage allocation fails.  */

static bfd_signed_vma *
hppa32_elf_local_refcounts (bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  bfd_signed_vma *local_refcounts;

  local_refcounts = elf_local_got_refcounts (abfd);
  if (local_refcounts == NULL)
    {
      bfd_size_type size;

      /* Allocate space for local GOT and PLT reference
	 counts.  Done this way to save polluting elf_obj_tdata
	 with another target specific pointer.  */
      size = symtab_hdr->sh_info;
      size *= 2 * sizeof (bfd_signed_vma);
      /* Add in space to store the local GOT TLS types.  */
      size += symtab_hdr->sh_info;
      local_refcounts = bfd_zalloc (abfd, size);
      if (local_refcounts == NULL)
	return NULL;
      elf_local_got_refcounts (abfd) = local_refcounts;
      memset (hppa_elf_local_got_tls_type (abfd), GOT_UNKNOWN,
	      symtab_hdr->sh_info);
    }
  return local_refcounts;
}


/* Look through the relocs for a section during the first phase, and
   calculate needed space in the global offset table, procedure linkage
   table, and dynamic reloc sections.  At this point we haven't
   necessarily read all the input files.  */

static bfd_boolean
elf32_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **eh_syms;
  const Elf_Internal_Rela *rela;
  const Elf_Internal_Rela *rela_end;
  struct elf32_hppa_link_hash_table *htab;
  asection *sreloc;
  int tls_type = GOT_UNKNOWN, old_tls_type = GOT_UNKNOWN;

  if (info->relocatable)
    return TRUE;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  eh_syms = elf_sym_hashes (abfd);
  sreloc = NULL;

  rela_end = relocs + sec->reloc_count;
  for (rela = relocs; rela < rela_end; rela++)
    {
      enum {
	NEED_GOT = 1,
	NEED_PLT = 2,
	NEED_DYNREL = 4,
	PLT_PLABEL = 8
      };

      unsigned int r_symndx, r_type;
      struct elf32_hppa_link_hash_entry *hh;
      int need_entry = 0;

      r_symndx = ELF32_R_SYM (rela->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	hh = NULL;
      else
	{
	  hh =  hppa_elf_hash_entry (eh_syms[r_symndx - symtab_hdr->sh_info]);
	  while (hh->eh.root.type == bfd_link_hash_indirect
		 || hh->eh.root.type == bfd_link_hash_warning)
	    hh = hppa_elf_hash_entry (hh->eh.root.u.i.link);

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  hh->eh.root.non_ir_ref = 1;
	}

      r_type = ELF32_R_TYPE (rela->r_info);
      r_type = elf32_hppa_optimized_tls_reloc (info, r_type, hh == NULL);

      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  /* This symbol requires a global offset table entry.  */
	  need_entry = NEED_GOT;
	  break;

	case R_PARISC_PLABEL14R: /* "Official" procedure labels.  */
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  /* If the addend is non-zero, we break badly.  */
	  if (rela->r_addend != 0)
	    abort ();

	  /* If we are creating a shared library, then we need to
	     create a PLT entry for all PLABELs, because PLABELs with
	     local symbols may be passed via a pointer to another
	     object.  Additionally, output a dynamic relocation
	     pointing to the PLT entry.

	     For executables, the original 32-bit ABI allowed two
	     different styles of PLABELs (function pointers):  For
	     global functions, the PLABEL word points into the .plt
	     two bytes past a (function address, gp) pair, and for
	     local functions the PLABEL points directly at the
	     function.  The magic +2 for the first type allows us to
	     differentiate between the two.  As you can imagine, this
	     is a real pain when it comes to generating code to call
	     functions indirectly or to compare function pointers.
	     We avoid the mess by always pointing a PLABEL into the
	     .plt, even for local functions.  */
	  need_entry = PLT_PLABEL | NEED_PLT | NEED_DYNREL;
	  break;

	case R_PARISC_PCREL12F:
	  htab->has_12bit_branch = 1;
	  goto branch_common;

	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	  htab->has_17bit_branch = 1;
	  goto branch_common;

	case R_PARISC_PCREL22F:
	  htab->has_22bit_branch = 1;
	branch_common:
	  /* Function calls might need to go through the .plt, and
	     might require long branch stubs.  */
	  if (hh == NULL)
	    {
	      /* We know local syms won't need a .plt entry, and if
		 they need a long branch stub we can't guarantee that
		 we can reach the stub.  So just flag an error later
		 if we're doing a shared link and find we need a long
		 branch stub.  */
	      continue;
	    }
	  else
	    {
	      /* Global symbols will need a .plt entry if they remain
		 global, and in most cases won't need a long branch
		 stub.  Unfortunately, we have to cater for the case
		 where a symbol is forced local by versioning, or due
		 to symbolic linking, and we lose the .plt entry.  */
	      need_entry = NEED_PLT;
	      if (hh->eh.type == STT_PARISC_MILLI)
		need_entry = 0;
	    }
	  break;

	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
	case R_PARISC_SEGREL32: /* Relative reloc, used for unwind.  */
	case R_PARISC_PCREL14F: /* PC relative load/store.  */
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL17R: /* External branches.  */
	case R_PARISC_PCREL21L: /* As above, and for load/store too.  */
	case R_PARISC_PCREL32:
	  /* We don't need to propagate the relocation if linking a
	     shared object since these are section relative.  */
	  continue;

	case R_PARISC_DPREL14F: /* Used for gp rel data load/store.  */
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 abfd,
		 elf_hppa_howto_table[r_type].name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  /* Fall through.  */

	case R_PARISC_DIR17F: /* Used for external branches.  */
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F: /* Used for load/store from absolute locn.  */
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L: /* As above, and for ext branches too.  */
	case R_PARISC_DIR32: /* .word relocs.  */
	  /* We may want to output a dynamic relocation later.  */
	  need_entry = NEED_DYNREL;
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PARISC_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &hh->eh, rela->r_offset))
	    return FALSE;
	  continue;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PARISC_GNU_VTENTRY:
	  BFD_ASSERT (hh != NULL);
	  if (hh != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, &hh->eh, rela->r_addend))
	    return FALSE;
	  continue;

	case R_PARISC_TLS_GD21L:
	case R_PARISC_TLS_GD14R:
	case R_PARISC_TLS_LDM21L:
	case R_PARISC_TLS_LDM14R:
	  need_entry = NEED_GOT;
	  break;

	case R_PARISC_TLS_IE21L:
	case R_PARISC_TLS_IE14R:
	  if (info->shared)
            info->flags |= DF_STATIC_TLS;
	  need_entry = NEED_GOT;
	  break;

	default:
	  continue;
	}

      /* Now carry out our orders.  */
      if (need_entry & NEED_GOT)
	{
	  switch (r_type)
	    {
	    default:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_PARISC_TLS_GD21L:
	    case R_PARISC_TLS_GD14R:
	      tls_type |= GOT_TLS_GD;
	      break;
	    case R_PARISC_TLS_LDM21L:
	    case R_PARISC_TLS_LDM14R:
	      tls_type |= GOT_TLS_LDM;
	      break;
	    case R_PARISC_TLS_IE21L:
	    case R_PARISC_TLS_IE14R:
	      tls_type |= GOT_TLS_IE;
	      break;
	    }

	  /* Allocate space for a GOT entry, as well as a dynamic
	     relocation for this entry.  */
	  if (htab->sgot == NULL)
	    {
	      if (htab->etab.dynobj == NULL)
		htab->etab.dynobj = abfd;
	      if (!elf32_hppa_create_dynamic_sections (htab->etab.dynobj, info))
		return FALSE;
	    }

	  if (r_type == R_PARISC_TLS_LDM21L
	      || r_type == R_PARISC_TLS_LDM14R)
	    htab->tls_ldm_got.refcount += 1;
	  else
	    {
	      if (hh != NULL)
	        {
	          hh->eh.got.refcount += 1;
	          old_tls_type = hh->tls_type;
	        }
	      else
	        {
	          bfd_signed_vma *local_got_refcounts;

	          /* This is a global offset table entry for a local symbol.  */
	          local_got_refcounts = hppa32_elf_local_refcounts (abfd);
	          if (local_got_refcounts == NULL)
		    return FALSE;
	          local_got_refcounts[r_symndx] += 1;

	          old_tls_type = hppa_elf_local_got_tls_type (abfd) [r_symndx];
	        }

	      tls_type |= old_tls_type;

	      if (old_tls_type != tls_type)
	        {
	          if (hh != NULL)
		    hh->tls_type = tls_type;
	          else
		    hppa_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
	        }

	    }
	}

      if (need_entry & NEED_PLT)
	{
	  /* If we are creating a shared library, and this is a reloc
	     against a weak symbol or a global symbol in a dynamic
	     object, then we will be creating an import stub and a
	     .plt entry for the symbol.  Similarly, on a normal link
	     to symbols defined in a dynamic object we'll need the
	     import stub and a .plt entry.  We don't know yet whether
	     the symbol is defined or not, so make an entry anyway and
	     clean up later in adjust_dynamic_symbol.  */
	  if ((sec->flags & SEC_ALLOC) != 0)
	    {
	      if (hh != NULL)
		{
		  hh->eh.needs_plt = 1;
		  hh->eh.plt.refcount += 1;

		  /* If this .plt entry is for a plabel, mark it so
		     that adjust_dynamic_symbol will keep the entry
		     even if it appears to be local.  */
		  if (need_entry & PLT_PLABEL)
		    hh->plabel = 1;
		}
	      else if (need_entry & PLT_PLABEL)
		{
		  bfd_signed_vma *local_got_refcounts;
		  bfd_signed_vma *local_plt_refcounts;

		  local_got_refcounts = hppa32_elf_local_refcounts (abfd);
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  local_plt_refcounts = (local_got_refcounts
					 + symtab_hdr->sh_info);
		  local_plt_refcounts[r_symndx] += 1;
		}
	    }
	}

      if (need_entry & NEED_DYNREL)
	{
	  /* Flag this symbol as having a non-got, non-plt reference
	     so that we generate copy relocs if it turns out to be
	     dynamic.  */
	  if (hh != NULL && !info->shared)
	    hh->eh.non_got_ref = 1;

	  /* If we are creating a shared library then we need to copy
	     the reloc into the shared library.  However, if we are
	     linking with -Bsymbolic, we need only copy absolute
	     relocs or relocs against symbols that are not defined in
	     an object we are including in the link.  PC- or DP- or
	     DLT-relative relocs against any local sym or global sym
	     with DEF_REGULAR set, can be discarded.  At this point we
	     have not seen all the input files, so it is possible that
	     DEF_REGULAR is not set now but will be set later (it is
	     never cleared).  We account for that possibility below by
	     storing information in the dyn_relocs field of the
	     hash table entry.

	     A similar situation to the -Bsymbolic case occurs when
	     creating shared libraries and symbol visibility changes
	     render the symbol local.

	     As it turns out, all the relocs we will be creating here
	     are absolute, so we cannot remove them on -Bsymbolic
	     links or visibility changes anyway.  A STUB_REL reloc
	     is absolute too, as in that case it is the reloc in the
	     stub we will be creating, rather than copying the PCREL
	     reloc in the branch.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || (hh != NULL
		       && (!info->symbolic
			   || hh->eh.root.type == bfd_link_hash_defweak
			   || !hh->eh.def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && hh != NULL
		  && (hh->eh.root.type == bfd_link_hash_defweak
		      || !hh->eh.def_regular)))
	    {
	      struct elf32_hppa_dyn_reloc_entry *hdh_p;
	      struct elf32_hppa_dyn_reloc_entry **hdh_head;

	      /* Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  if (htab->etab.dynobj == NULL)
		    htab->etab.dynobj = abfd;

		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->etab.dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    {
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (hh != NULL)
		{
		  hdh_head = &hh->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  asection *sr;
		  void *vpp;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  sr = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (sr == NULL)
		    sr = sec;

		  vpp = &elf_section_data (sr)->local_dynrel;
		  hdh_head = (struct elf32_hppa_dyn_reloc_entry **) vpp;
		}

	      hdh_p = *hdh_head;
	      if (hdh_p == NULL || hdh_p->sec != sec)
		{
		  hdh_p = bfd_alloc (htab->etab.dynobj, sizeof *hdh_p);
		  if (hdh_p == NULL)
		    return FALSE;
		  hdh_p->hdh_next = *hdh_head;
		  *hdh_head = hdh_p;
		  hdh_p->sec = sec;
		  hdh_p->count = 0;
#if RELATIVE_DYNRELOCS
		  hdh_p->relative_count = 0;
#endif
		}

	      hdh_p->count += 1;
#if RELATIVE_DYNRELOCS
	      if (!IS_ABSOLUTE_RELOC (rtype))
		hdh_p->relative_count += 1;
#endif
	    }
	}
    }

  return TRUE;
}

/* Return the section that should be marked against garbage collection
   for a given relocation.  */

static asection *
elf32_hppa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info,
			 Elf_Internal_Rela *rela,
			 struct elf_link_hash_entry *hh,
			 Elf_Internal_Sym *sym)
{
  if (hh != NULL)
    switch ((unsigned int) ELF32_R_TYPE (rela->r_info))
      {
      case R_PARISC_GNU_VTINHERIT:
      case R_PARISC_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rela, hh, sym);
}

/* Update the got and plt entry reference counts for the section being
   removed.  */

static bfd_boolean
elf32_hppa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **eh_syms;
  bfd_signed_vma *local_got_refcounts;
  bfd_signed_vma *local_plt_refcounts;
  const Elf_Internal_Rela *rela, *relend;
  struct elf32_hppa_link_hash_table *htab;

  if (info->relocatable)
    return TRUE;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  eh_syms = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  local_plt_refcounts = local_got_refcounts;
  if (local_plt_refcounts != NULL)
    local_plt_refcounts += symtab_hdr->sh_info;

  relend = relocs + sec->reloc_count;
  for (rela = relocs; rela < relend; rela++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *eh = NULL;

      r_symndx = ELF32_R_SYM (rela->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf32_hppa_link_hash_entry *hh;
	  struct elf32_hppa_dyn_reloc_entry **hdh_pp;
	  struct elf32_hppa_dyn_reloc_entry *hdh_p;

	  eh = eh_syms[r_symndx - symtab_hdr->sh_info];
	  while (eh->root.type == bfd_link_hash_indirect
		 || eh->root.type == bfd_link_hash_warning)
	    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;
	  hh = hppa_elf_hash_entry (eh);

	  for (hdh_pp = &hh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; hdh_pp = &hdh_p->hdh_next)
	    if (hdh_p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*hdh_pp = hdh_p->hdh_next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rela->r_info);
      r_type = elf32_hppa_optimized_tls_reloc (info, r_type, eh != NULL);

      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	case R_PARISC_TLS_GD21L:
	case R_PARISC_TLS_GD14R:
	case R_PARISC_TLS_IE21L:
	case R_PARISC_TLS_IE14R:
	  if (eh != NULL)
	    {
	      if (eh->got.refcount > 0)
		eh->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_PARISC_TLS_LDM21L:
	case R_PARISC_TLS_LDM14R:
	  htab->tls_ldm_got.refcount -= 1;
	  break;

	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	  if (eh != NULL)
	    {
	      if (eh->plt.refcount > 0)
		eh->plt.refcount -= 1;
	    }
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (eh != NULL)
	    {
	      if (eh->plt.refcount > 0)
		eh->plt.refcount -= 1;
	    }
	  else if (local_plt_refcounts != NULL)
	    {
	      if (local_plt_refcounts[r_symndx] > 0)
		local_plt_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
elf32_hppa_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 396:		/* Linux/hppa */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 320;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf32_hppa_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 124:		/* Linux/hppa elf_prpsinfo.  */
	elf_tdata (abfd)->core->program
	  = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core->command
	  = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* Our own version of hide_symbol, so that we can keep plt entries for
   plabels.  */

static void
elf32_hppa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *eh,
			bfd_boolean force_local)
{
  if (force_local)
    {
      eh->forced_local = 1;
      if (eh->dynindx != -1)
	{
	  eh->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  eh->dynstr_index);
	}
    }

  /* STT_GNU_IFUNC symbol must go through PLT.  */
  if (! hppa_elf_hash_entry (eh)->plabel
      && eh->type != STT_GNU_IFUNC)
    {
      eh->needs_plt = 0;
      eh->plt = elf_hash_table (info)->init_plt_offset;
    }
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *eh)
{
  struct elf32_hppa_link_hash_table *htab;
  asection *sec;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later.  */
  if (eh->type == STT_FUNC
      || eh->needs_plt)
    {
      /* If the symbol is used by a plabel, we must allocate a PLT slot.
	 The refcounts are not reliable when it has been hidden since
	 hide_symbol can be called before the plabel flag is set.  */
      if (hppa_elf_hash_entry (eh)->plabel
	  && eh->plt.refcount <= 0)
	eh->plt.refcount = 1;

      if (eh->plt.refcount <= 0
	  || (eh->def_regular
	      && eh->root.type != bfd_link_hash_defweak
	      && ! hppa_elf_hash_entry (eh)->plabel
	      && (!info->shared || info->symbolic)))
	{
	  /* The .plt entry is not needed when:
	     a) Garbage collection has removed all references to the
	     symbol, or
	     b) We know for certain the symbol is defined in this
	     object, and it's not a weak definition, nor is the symbol
	     used by a plabel relocation.  Either this object is the
	     application or we are doing a shared symbolic link.  */

	  eh->plt.offset = (bfd_vma) -1;
	  eh->needs_plt = 0;
	}

      return TRUE;
    }
  else
    eh->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (eh->u.weakdef != NULL)
    {
      if (eh->u.weakdef->root.type != bfd_link_hash_defined
	  && eh->u.weakdef->root.type != bfd_link_hash_defweak)
	abort ();
      eh->root.u.def.section = eh->u.weakdef->root.u.def.section;
      eh->root.u.def.value = eh->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS)
	eh->non_got_ref = eh->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!eh->non_got_ref)
    return TRUE;

  if (ELIMINATE_COPY_RELOCS)
    {
      struct elf32_hppa_link_hash_entry *hh;
      struct elf32_hppa_dyn_reloc_entry *hdh_p;

      hh = hppa_elf_hash_entry (eh);
      for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->hdh_next)
	{
	  sec = hdh_p->sec->output_section;
	  if (sec != NULL && (sec->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (hdh_p == NULL)
	{
	  eh->non_got_ref = 0;
	  return TRUE;
	}
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* We must generate a COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  */
  if ((eh->root.u.def.section->flags & SEC_ALLOC) != 0 && eh->size != 0)
    {
      htab->srelbss->size += sizeof (Elf32_External_Rela);
      eh->needs_copy = 1;
    }

  sec = htab->sdynbss;

  return _bfd_elf_adjust_dynamic_copy (eh, sec);
}

/* Allocate space in the .plt for entries that won't have relocations.
   ie. plabel entries.  */

static bfd_boolean
allocate_plt_static (struct elf_link_hash_entry *eh, void *inf)
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  struct elf32_hppa_link_hash_entry *hh;
  asection *sec;

  if (eh->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  hh = hppa_elf_hash_entry (eh);
  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (htab->etab.dynamic_sections_created
      && eh->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (eh->dynindx == -1
	  && !eh->forced_local
	  && eh->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, eh))
	    return FALSE;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, eh))
	{
	  /* Allocate these later.  From this point on, h->plabel
	     means that the plt entry is only used by a plabel.
	     We'll be using a normal plt entry for this symbol, so
	     clear the plabel indicator.  */

	  hh->plabel = 0;
	}
      else if (hh->plabel)
	{
	  /* Make an entry in the .plt section for plabel references
	     that won't have a .plt entry for other reasons.  */
	  sec = htab->splt;
	  eh->plt.offset = sec->size;
	  sec->size += PLT_ENTRY_SIZE;
	}
      else
	{
	  /* No .plt entry needed.  */
	  eh->plt.offset = (bfd_vma) -1;
	  eh->needs_plt = 0;
	}
    }
  else
    {
      eh->plt.offset = (bfd_vma) -1;
      eh->needs_plt = 0;
    }

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *sec;
  struct elf32_hppa_link_hash_entry *hh;
  struct elf32_hppa_dyn_reloc_entry *hdh_p;

  if (eh->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = inf;
  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  hh = hppa_elf_hash_entry (eh);

  if (htab->etab.dynamic_sections_created
      && eh->plt.offset != (bfd_vma) -1
      && !hh->plabel
      && eh->plt.refcount > 0)
    {
      /* Make an entry in the .plt section.  */
      sec = htab->splt;
      eh->plt.offset = sec->size;
      sec->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      htab->srelplt->size += sizeof (Elf32_External_Rela);
      htab->need_plt_stub = 1;
    }

  if (eh->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (eh->dynindx == -1
	  && !eh->forced_local
	  && eh->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, eh))
	    return FALSE;
	}

      sec = htab->sgot;
      eh->got.offset = sec->size;
      sec->size += GOT_ENTRY_SIZE;
      /* R_PARISC_TLS_GD* needs two GOT entries */
      if ((hh->tls_type & (GOT_TLS_GD | GOT_TLS_IE)) == (GOT_TLS_GD | GOT_TLS_IE))
      	sec->size += GOT_ENTRY_SIZE * 2;
      else if ((hh->tls_type & GOT_TLS_GD) == GOT_TLS_GD)
      	sec->size += GOT_ENTRY_SIZE;
      if (htab->etab.dynamic_sections_created
	  && (info->shared
	      || (eh->dynindx != -1
		  && !eh->forced_local)))
	{
	  htab->srelgot->size += sizeof (Elf32_External_Rela);
	  if ((hh->tls_type & (GOT_TLS_GD | GOT_TLS_IE)) == (GOT_TLS_GD | GOT_TLS_IE))
	    htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
	  else if ((hh->tls_type & GOT_TLS_GD) == GOT_TLS_GD)
	    htab->srelgot->size += sizeof (Elf32_External_Rela);
	}
    }
  else
    eh->got.offset = (bfd_vma) -1;

  if (hh->dyn_relocs == NULL)
    return TRUE;

  /* If this is a -Bsymbolic shared link, then we need to discard all
     space allocated for dynamic pc-relative relocs against symbols
     defined in a regular object.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */
  if (info->shared)
    {
#if RELATIVE_DYNRELOCS
      if (SYMBOL_CALLS_LOCAL (info, eh))
	{
	  struct elf32_hppa_dyn_reloc_entry **hdh_pp;

	  for (hdh_pp = &hh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )
	    {
	      hdh_p->count -= hdh_p->relative_count;
	      hdh_p->relative_count = 0;
	      if (hdh_p->count == 0)
		*hdh_pp = hdh_p->hdh_next;
	      else
		hdh_pp = &hdh_p->hdh_next;
	    }
	}
#endif

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (hh->dyn_relocs != NULL
	  && eh->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (eh->other) != STV_DEFAULT)
	    hh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (eh->dynindx == -1
		   && !eh->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, eh))
		return FALSE;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!eh->non_got_ref
	  && ((ELIMINATE_COPY_RELOCS
	       && eh->def_dynamic
	       && !eh->def_regular)
	       || (htab->etab.dynamic_sections_created
		   && (eh->root.type == bfd_link_hash_undefweak
		       || eh->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (eh->dynindx == -1
	      && !eh->forced_local
	      && eh->type != STT_PARISC_MILLI)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, eh))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (eh->dynindx != -1)
	    goto keep;
	}

      hh->dyn_relocs = NULL;
      return TRUE;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->hdh_next)
    {
      asection *sreloc = elf_section_data (hdh_p->sec)->sreloc;
      sreloc->size += hdh_p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* This function is called via elf_link_hash_traverse to force
   millicode symbols local so they do not end up as globals in the
   dynamic symbol table.  We ought to be able to do this in
   adjust_dynamic_symbol, but our adjust_dynamic_symbol is not called
   for all dynamic symbols.  Arguably, this is a bug in
   elf_adjust_dynamic_symbol.  */

static bfd_boolean
clobber_millicode_symbols (struct elf_link_hash_entry *eh,
			   struct bfd_link_info *info)
{
  if (eh->type == STT_PARISC_MILLI
      && !eh->forced_local)
    {
      elf32_hppa_hide_symbol (info, eh, TRUE);
    }
  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *eh, void *inf)
{
  struct elf32_hppa_link_hash_entry *hh;
  struct elf32_hppa_dyn_reloc_entry *hdh_p;

  hh = hppa_elf_hash_entry (eh);
  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->hdh_next)
    {
      asection *sec = hdh_p->sec->output_section;

      if (sec != NULL && (sec->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
{
  struct elf32_hppa_link_hash_table *htab;
  bfd *dynobj;
  bfd *ibfd;
  asection *sec;
  bfd_boolean relocs;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->etab.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->etab.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  sec = bfd_get_linker_section (dynobj, ".interp");
	  if (sec == NULL)
	    abort ();
	  sec->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  sec->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Force millicode symbols local.  */
      elf_link_hash_traverse (&htab->etab,
			      clobber_millicode_symbols,
			      info);
    }

  /* Set up .got and .plt offsets for local syms, and space for local
     dynamic relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_signed_vma *local_plt;
      bfd_signed_vma *end_local_plt;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
      char *local_tls_type;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  struct elf32_hppa_dyn_reloc_entry *hdh_p;

	  for (hdh_p = ((struct elf32_hppa_dyn_reloc_entry *)
		    elf_section_data (sec)->local_dynrel);
	       hdh_p != NULL;
	       hdh_p = hdh_p->hdh_next)
	    {
	      if (!bfd_is_abs_section (hdh_p->sec)
		  && bfd_is_abs_section (hdh_p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (hdh_p->count != 0)
		{
		  srel = elf_section_data (hdh_p->sec)->sreloc;
		  srel->size += hdh_p->count * sizeof (Elf32_External_Rela);
		  if ((hdh_p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_tls_type = hppa_elf_local_got_tls_type (ibfd);
      sec = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
	{
	  if (*local_got > 0)
	    {
	      *local_got = sec->size;
	      sec->size += GOT_ENTRY_SIZE;
	      if ((*local_tls_type & (GOT_TLS_GD | GOT_TLS_IE)) == (GOT_TLS_GD | GOT_TLS_IE))
		sec->size += 2 * GOT_ENTRY_SIZE;
	      else if ((*local_tls_type & GOT_TLS_GD) == GOT_TLS_GD)
		sec->size += GOT_ENTRY_SIZE;
	      if (info->shared)
	        {
		  srel->size += sizeof (Elf32_External_Rela);
		  if ((*local_tls_type & (GOT_TLS_GD | GOT_TLS_IE)) == (GOT_TLS_GD | GOT_TLS_IE))
		    srel->size += 2 * sizeof (Elf32_External_Rela);
		  else if ((*local_tls_type & GOT_TLS_GD) == GOT_TLS_GD)
		    srel->size += sizeof (Elf32_External_Rela);
	        }
	    }
	  else
	    *local_got = (bfd_vma) -1;

	  ++local_tls_type;
	}

      local_plt = end_local_got;
      end_local_plt = local_plt + locsymcount;
      if (! htab->etab.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_plt < end_local_plt; ++local_plt)
	    *local_plt = (bfd_vma) -1;
	}
      else
	{
	  sec = htab->splt;
	  srel = htab->srelplt;
	  for (; local_plt < end_local_plt; ++local_plt)
	    {
	      if (*local_plt > 0)
		{
		  *local_plt = sec->size;
		  sec->size += PLT_ENTRY_SIZE;
		  if (info->shared)
		    srel->size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_plt = (bfd_vma) -1;
	    }
	}
    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for
         R_PARISC_TLS_DTPMOD32 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += (GOT_ENTRY_SIZE * 2);
      htab->srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Do all the .plt entries without relocs first.  The dynamic linker
     uses the last .plt reloc to find the end of the .plt (and hence
     the start of the .got) for lazy linking.  */
  elf_link_hash_traverse (&htab->etab, allocate_plt_static, info);

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->etab, allocate_dynrelocs, info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relocs = FALSE;
  for (sec = dynobj->sections; sec != NULL; sec = sec->next)
    {
      if ((sec->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (sec == htab->splt)
	{
	  if (htab->need_plt_stub)
	    {
	      /* Make space for the plt stub at the end of the .plt
		 section.  We want this stub right at the end, up
		 against the .got section.  */
	      int gotalign = bfd_section_alignment (dynobj, htab->sgot);
	      int pltalign = bfd_section_alignment (dynobj, sec);
	      bfd_size_type mask;

	      if (gotalign > pltalign)
		(void) bfd_set_section_alignment (dynobj, sec, gotalign);
	      mask = ((bfd_size_type) 1 << gotalign) - 1;
	      sec->size = (sec->size + sizeof (plt_stub) + mask) & ~mask;
	    }
	}
      else if (sec == htab->sgot
	       || sec == htab->sdynbss)
	;
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, sec), ".rela"))
	{
	  if (sec->size != 0)
	    {
	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (sec != htab->srelplt)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      sec->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (sec->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  sec->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((sec->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  Zero it, because
	 we may not fill in all the reloc sections.  */
      sec->contents = bfd_zalloc (dynobj, sec->size);
      if (sec->contents == NULL)
	return FALSE;
    }

  if (htab->etab.dynamic_sections_created)
    {
      /* Like IA-64 and HPPA64, always create a DT_PLTGOT.  It
	 actually has nothing to do with the PLT, it is how we
	 communicate the LTP value of a load module to the dynamic
	 linker.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!add_dynamic_entry (DT_PLTGOT, 0))
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_hppa_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->srelplt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->etab, readonly_dynrelocs, info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* External entry points for sizing and building linker stubs.  */

/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  */

int
elf32_hppa_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *input_bfd;
  unsigned int bfd_count;
  int top_id, top_index;
  asection *section;
  asection **input_list, **list;
  bfd_size_type amt;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (htab == NULL)
    return -1;

  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_count += 1;
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (top_id < section->id)
	    top_id = section->id;
	}
    }
  htab->bfd_count = bfd_count;

  amt = sizeof (struct map_stub) * (top_id + 1);
  htab->stub_group = bfd_zmalloc (amt);
  if (htab->stub_group == NULL)
    return -1;

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     strip_excluded_output_sections doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = bfd_malloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    {
      if ((section->flags & SEC_CODE) != 0)
	input_list[section->index] = NULL;
    }

  return 1;
}

/* The linker repeatedly calls this function for each input section,
   in the order that input sections are linked into output sections.
   Build lists of input sections to determine groupings between which
   we may insert linker stubs.  */

void
elf32_hppa_next_input_section (struct bfd_link_info *info, asection *isec)
{
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (htab == NULL)
    return;

  if (isec->output_section->index <= htab->top_index)
    {
      asection **list = htab->input_list + isec->output_section->index;
      if (*list != bfd_abs_section_ptr)
	{
	  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
	  /* This happens to make the list in reverse order,
	     which is what we want.  */
	  PREV_SEC (isec) = *list;
	  *list = isec;
	}
    }
}

/* See whether we can group stub sections together.  Grouping stub
   sections may result in fewer stubs.  More importantly, we need to
   put all .init* and .fini* stubs at the beginning of the .init or
   .fini output sections respectively, because glibc splits the
   _init and _fini functions into multiple parts.  Putting a stub in
   the middle of a function is not a good idea.  */

static void
group_sections (struct elf32_hppa_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
{
  asection **list = htab->input_list + htab->top_index;
  do
    {
      asection *tail = *list;
      if (tail == bfd_abs_section_ptr)
	continue;
      while (tail != NULL)
	{
	  asection *curr;
	  asection *prev;
	  bfd_size_type total;
	  bfd_boolean big_sec;

	  curr = tail;
	  total = tail->size;
	  big_sec = total >= stub_group_size;

	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
		     < stub_group_size))
	    curr = prev;

	  /* OK, the size from the start of CURR to the end is less
	     than 240000 bytes and thus can be handled by one stub
	     section.  (or the tail section is itself larger than
	     240000 bytes, in which case we may be toast.)
	     We should really be keeping track of the total size of
	     stubs added here, as stubs contribute to the final output
	     section size.  That's a little tricky, and this way will
	     only break if stubs added total more than 22144 bytes, or
	     2768 long branch stubs.  It seems unlikely for more than
	     2768 different functions to be called, especially from
	     code only 240000 bytes long.  This limit used to be
	     250000, but c++ code tends to generate lots of little
	     functions, and sometimes violated the assumption.  */
	  do
	    {
	      prev = PREV_SEC (tail);
	      /* Set up this stub group.  */
	      htab->stub_group[tail->id].link_sec = curr;
	    }
	  while (tail != curr && (tail = prev) != NULL);

	  /* But wait, there's more!  Input sections up to 240000
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
	    {
	      total = 0;
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
			 < stub_group_size))
		{
		  tail = prev;
		  prev = PREV_SEC (tail);
		  htab->stub_group[tail->id].link_sec = curr;
		}
	    }
	  tail = prev;
	}
    }
  while (list-- != htab->input_list);
  free (htab->input_list);
#undef PREV_SEC
}

/* Read in all local syms for all input bfds, and create hash entries
   for export stubs if we are building a multi-subspace shared lib.
   Returns -1 on error, 1 if export stubs created, 0 otherwise.  */

static int
get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
{
  unsigned int bfd_indx;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  int stub_changed = 0;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (htab == NULL)
    return -1;

  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
  all_local_syms = bfd_zmalloc (amt);
  htab->all_local_syms = all_local_syms;
  if (all_local_syms == NULL)
    return -1;

  /* Walk over all the input BFDs, swapping in local symbols.
     If we are creating a shared library, create hash entries for the
     export stubs.  */
  for (bfd_indx = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, bfd_indx++)
    {
      Elf_Internal_Shdr *symtab_hdr;

      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.  */
      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (local_syms == NULL)
	{
	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					     symtab_hdr->sh_info, 0,
					     NULL, NULL, NULL);
	  /* Cache them for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) local_syms;
	}
      if (local_syms == NULL)
	return -1;

      all_local_syms[bfd_indx] = local_syms;

      if (info->shared && htab->multi_subspace)
	{
	  struct elf_link_hash_entry **eh_syms;
	  struct elf_link_hash_entry **eh_symend;
	  unsigned int symcount;

	  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		      - symtab_hdr->sh_info);
	  eh_syms = (struct elf_link_hash_entry **) elf_sym_hashes (input_bfd);
	  eh_symend = (struct elf_link_hash_entry **) (eh_syms + symcount);

	  /* Look through the global syms for functions;  We need to
	     build export stubs for all globally visible functions.  */
	  for (; eh_syms < eh_symend; eh_syms++)
	    {
	      struct elf32_hppa_link_hash_entry *hh;

	      hh = hppa_elf_hash_entry (*eh_syms);

	      while (hh->eh.root.type == bfd_link_hash_indirect
		     || hh->eh.root.type == bfd_link_hash_warning)
		   hh = hppa_elf_hash_entry (hh->eh.root.u.i.link);

	      /* At this point in the link, undefined syms have been
		 resolved, so we need to check that the symbol was
		 defined in this BFD.  */
	      if ((hh->eh.root.type == bfd_link_hash_defined
		   || hh->eh.root.type == bfd_link_hash_defweak)
		  && hh->eh.type == STT_FUNC
		  && hh->eh.root.u.def.section->output_section != NULL
		  && (hh->eh.root.u.def.section->output_section->owner
		      == output_bfd)
		  && hh->eh.root.u.def.section->owner == input_bfd
		  && hh->eh.def_regular
		  && !hh->eh.forced_local
		  && ELF_ST_VISIBILITY (hh->eh.other) == STV_DEFAULT)
		{
		  asection *sec;
		  const char *stub_name;
		  struct elf32_hppa_stub_hash_entry *hsh;

		  sec = hh->eh.root.u.def.section;
		  stub_name = hh_name (hh);
		  hsh = hppa_stub_hash_lookup (&htab->bstab,
						      stub_name,
						      FALSE, FALSE);
		  if (hsh == NULL)
		    {
		      hsh = hppa_add_stub (stub_name, sec, htab);
		      if (!hsh)
			return -1;

		      hsh->target_value = hh->eh.root.u.def.value;
		      hsh->target_section = hh->eh.root.u.def.section;
		      hsh->stub_type = hppa_stub_export;
		      hsh->hh = hh;
		      stub_changed = 1;
		    }
		  else
		    {
		      (*_bfd_error_handler) (_("%B: duplicate export stub %s"),
					     input_bfd,
					     stub_name);
		    }
		}
	    }
	}
    }

  return stub_changed;
}

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

bfd_boolean
elf32_hppa_size_stubs
  (bfd *output_bfd, bfd *stub_bfd, struct bfd_link_info *info,
   bfd_boolean multi_subspace, bfd_signed_vma group_size,
   asection * (*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
{
  bfd_size_type stub_group_size;
  bfd_boolean stubs_always_before_branch;
  bfd_boolean stub_changed;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (htab == NULL)
    return FALSE;

  /* Stash our params away.  */
  htab->stub_bfd = stub_bfd;
  htab->multi_subspace = multi_subspace;
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      if (stubs_always_before_branch)
	{
	  stub_group_size = 7680000;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 240000;
	  if (htab->has_12bit_branch)
	    stub_group_size = 7500;
	}
      else
	{
	  stub_group_size = 6971392;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 217856;
	  if (htab->has_12bit_branch)
	    stub_group_size = 6808;
	}
    }

  group_sections (htab, stub_group_size, stubs_always_before_branch);

  switch (get_local_syms (output_bfd, info->input_bfds, info))
    {
    default:
      if (htab->all_local_syms)
	goto error_ret_free_local;
      return FALSE;

    case 0:
      stub_changed = FALSE;
      break;

    case 1:
      stub_changed = TRUE;
      break;
    }

  while (1)
    {
      bfd *input_bfd;
      unsigned int bfd_indx;
      asection *stub_sec;

      for (input_bfd = info->input_bfds, bfd_indx = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, bfd_indx++)
	{
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *section;
	  Elf_Internal_Sym *local_syms;

	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
	  if (symtab_hdr->sh_info == 0)
	    continue;

	  local_syms = htab->all_local_syms[bfd_indx];

	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next)
	    {
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	      /* If there aren't any relocs, then there's nothing more
		 to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || section->reloc_count == 0)
		continue;

	      /* If this section is a link-once section that will be
		 discarded, then don't create any stubs.  */
	      if (section->output_section == NULL
		  || section->output_section->owner != output_bfd)
		continue;

	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		goto error_ret_free_local;

	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  unsigned int r_type, r_indx;
		  enum elf32_hppa_stub_type stub_type;
		  struct elf32_hppa_stub_hash_entry *hsh;
		  asection *sym_sec;
		  bfd_vma sym_value;
		  bfd_vma destination;
		  struct elf32_hppa_link_hash_entry *hh;
		  char *stub_name;
		  const asection *id_sec;

		  r_type = ELF32_R_TYPE (irela->r_info);
		  r_indx = ELF32_R_SYM (irela->r_info);

		  if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
		    {
		      bfd_set_error (bfd_error_bad_value);
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
		    }

		  /* Only look for stubs on call instructions.  */
		  if (r_type != (unsigned int) R_PARISC_PCREL12F
		      && r_type != (unsigned int) R_PARISC_PCREL17F
		      && r_type != (unsigned int) R_PARISC_PCREL22F)
		    continue;

		  /* Now determine the call target, its name, value,
		     section.  */
		  sym_sec = NULL;
		  sym_value = 0;
		  destination = 0;
		  hh = NULL;
		  if (r_indx < symtab_hdr->sh_info)
		    {
		      /* It's a local symbol.  */
		      Elf_Internal_Sym *sym;
		      Elf_Internal_Shdr *hdr;
		      unsigned int shndx;

		      sym = local_syms + r_indx;
		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
			sym_value = sym->st_value;
		      shndx = sym->st_shndx;
		      if (shndx < elf_numsections (input_bfd))
			{
			  hdr = elf_elfsections (input_bfd)[shndx];
			  sym_sec = hdr->bfd_section;
			  destination = (sym_value + irela->r_addend
					 + sym_sec->output_offset
					 + sym_sec->output_section->vma);
			}
		    }
		  else
		    {
		      /* It's an external symbol.  */
		      int e_indx;

		      e_indx = r_indx - symtab_hdr->sh_info;
		      hh = hppa_elf_hash_entry (elf_sym_hashes (input_bfd)[e_indx]);

		      while (hh->eh.root.type == bfd_link_hash_indirect
			     || hh->eh.root.type == bfd_link_hash_warning)
			hh = hppa_elf_hash_entry (hh->eh.root.u.i.link);

		      if (hh->eh.root.type == bfd_link_hash_defined
			  || hh->eh.root.type == bfd_link_hash_defweak)
			{
			  sym_sec = hh->eh.root.u.def.section;
			  sym_value = hh->eh.root.u.def.value;
			  if (sym_sec->output_section != NULL)
			    destination = (sym_value + irela->r_addend
					   + sym_sec->output_offset
					   + sym_sec->output_section->vma);
			}
		      else if (hh->eh.root.type == bfd_link_hash_undefweak)
			{
			  if (! info->shared)
			    continue;
			}
		      else if (hh->eh.root.type == bfd_link_hash_undefined)
			{
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
				 && (ELF_ST_VISIBILITY (hh->eh.other)
				     == STV_DEFAULT)
				 && hh->eh.type != STT_PARISC_MILLI))
			    continue;
			}
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
		    }

		  /* Determine what (if any) linker stub is needed.  */
		  stub_type = hppa_type_of_stub (section, irela, hh,
						 destination, info);
		  if (stub_type == hppa_stub_none)
		    continue;

		  /* Support for grouping stub sections.  */
		  id_sec = htab->stub_group[section->id].link_sec;

		  /* Get the name of this stub.  */
		  stub_name = hppa_stub_name (id_sec, sym_sec, hh, irela);
		  if (!stub_name)
		    goto error_ret_free_internal;

		  hsh = hppa_stub_hash_lookup (&htab->bstab,
						      stub_name,
						      FALSE, FALSE);
		  if (hsh != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      continue;
		    }

		  hsh = hppa_add_stub (stub_name, section, htab);
		  if (hsh == NULL)
		    {
		      free (stub_name);
		      goto error_ret_free_internal;
		    }

		  hsh->target_value = sym_value;
		  hsh->target_section = sym_sec;
		  hsh->stub_type = stub_type;
		  if (info->shared)
		    {
		      if (stub_type == hppa_stub_import)
			hsh->stub_type = hppa_stub_import_shared;
		      else if (stub_type == hppa_stub_long_branch)
			hsh->stub_type = hppa_stub_long_branch_shared;
		    }
		  hsh->hh = hh;
		  stub_changed = TRUE;
		}

	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
	    }
	}

      if (!stub_changed)
	break;

      /* OK, we've added some stubs.  Find out the new size of the
	 stub sections.  */
      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	stub_sec->size = 0;

      bfd_hash_traverse (&htab->bstab, hppa_size_one_stub, htab);

      /* Ask the linker to do its stuff.  */
      (*htab->layout_sections_again) ();
      stub_changed = FALSE;
    }

  free (htab->all_local_syms);
  return TRUE;

 error_ret_free_local:
  free (htab->all_local_syms);
  return FALSE;
}

/* For a final link, this function is called after we have sized the
   stubs to provide a value for __gp.  */

bfd_boolean
elf32_hppa_set_gp (bfd *abfd, struct bfd_link_info *info)
{
  struct bfd_link_hash_entry *h;
  asection *sec = NULL;
  bfd_vma gp_val = 0;
  struct elf32_hppa_link_hash_table *htab;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  h = bfd_link_hash_lookup (&htab->etab.root, "$global$", FALSE, FALSE, FALSE);

  if (h != NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak))
    {
      gp_val = h->u.def.value;
      sec = h->u.def.section;
    }
  else
    {
      asection *splt = bfd_get_section_by_name (abfd, ".plt");
      asection *sgot = bfd_get_section_by_name (abfd, ".got");

      /* Choose to point our LTP at, in this order, one of .plt, .got,
	 or .data, if these sections exist.  In the case of choosing
	 .plt try to make the LTP ideal for addressing anywhere in the
	 .plt or .got with a 14 bit signed offset.  Typically, the end
	 of the .plt is the start of the .got, so choose .plt + 0x2000
	 if either the .plt or .got is larger than 0x2000.  If both
	 the .plt and .got are smaller than 0x2000, choose the end of
	 the .plt section.  */
      sec = strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0
	  ? NULL : splt;
      if (sec != NULL)
	{
	  gp_val = sec->size;
	  if (gp_val > 0x2000 || (sgot && sgot->size > 0x2000))
	    {
	      gp_val = 0x2000;
	    }
	}
      else
	{
	  sec = sgot;
	  if (sec != NULL)
	    {
	      if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") != 0)
		{
	          /* We know we don't have a .plt.  If .got is large,
		     offset our LTP.  */
	          if (sec->size > 0x2000)
		    gp_val = 0x2000;
		}
	    }
	  else
	    {
	      /* No .plt or .got.  Who cares what the LTP is?  */
	      sec = bfd_get_section_by_name (abfd, ".data");
	    }
	}

      if (h != NULL)
	{
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = gp_val;
	  if (sec != NULL)
	    h->u.def.section = sec;
	  else
	    h->u.def.section = bfd_abs_section_ptr;
	}
    }

  if (sec != NULL && sec->output_section != NULL)
    gp_val += sec->output_section->vma + sec->output_offset;

  elf_gp (abfd) = gp_val;
  return TRUE;
}

/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  We also set up the .plt entries for statically linked PIC
   functions here.  This function is called via hppaelf_finish in the
   linker.  */

bfd_boolean
elf32_hppa_build_stubs (struct bfd_link_info *info)
{
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_hppa_link_hash_table *htab;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    {
      bfd_size_type size;

      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->size;
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
      if (stub_sec->contents == NULL && size != 0)
	return FALSE;
      stub_sec->size = 0;
    }

  /* Build the stubs as directed by the stub hash table.  */
  table = &htab->bstab;
  bfd_hash_traverse (table, hppa_build_one_stub, info);

  return TRUE;
}

/* Return the base vma address which should be subtracted from the real
   address when resolving a dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for R_PARISC_TLS_TPOFF*..  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  /* hppa TLS ABI is variant I and static TLS block start just after
     tcbhead structure which has 2 pointer fields.  */
  return (address - htab->tls_sec->vma
	  + align_power ((bfd_vma) 8, htab->tls_sec->alignment_power));
}

/* Perform a final link.  */

static bfd_boolean
elf32_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
{
  /* Invoke the regular ELF linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  /* If we're producing a final executable, sort the contents of the
     unwind section.  */
  if (info->relocatable)
    return TRUE;

  return elf_hppa_sort_unwind (abfd);
}

/* Record the lowest address for the data and text segments.  */

static void
hppa_record_segment_addr (bfd *abfd, asection *section, void *data)
{
  struct elf32_hppa_link_hash_table *htab;

  htab = (struct elf32_hppa_link_hash_table*) data;
  if (htab == NULL)
    return;

  if ((section->flags & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
    {
      bfd_vma value;
      Elf_Internal_Phdr *p;

      p = _bfd_elf_find_segment_containing_section (abfd, section->output_section);
      BFD_ASSERT (p != NULL);
      value = p->p_vaddr;

      if ((section->flags & SEC_READONLY) != 0)
	{
	  if (value < htab->text_segment_base)
	    htab->text_segment_base = value;
	}
      else
	{
	  if (value < htab->data_segment_base)
	    htab->data_segment_base = value;
	}
    }
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
final_link_relocate (asection *input_section,
		     bfd_byte *contents,
		     const Elf_Internal_Rela *rela,
		     bfd_vma value,
		     struct elf32_hppa_link_hash_table *htab,
		     asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hh,
		     struct bfd_link_info *info)
{
  int insn;
  unsigned int r_type = ELF32_R_TYPE (rela->r_info);
  unsigned int orig_r_type = r_type;
  reloc_howto_type *howto = elf_hppa_howto_table + r_type;
  int r_format = howto->bitsize;
  enum hppa_reloc_field_selector_type_alt r_field;
  bfd *input_bfd = input_section->owner;
  bfd_vma offset = rela->r_offset;
  bfd_vma max_branch_offset = 0;
  bfd_byte *hit_data = contents + offset;
  bfd_signed_vma addend = rela->r_addend;
  bfd_vma location;
  struct elf32_hppa_stub_hash_entry *hsh = NULL;
  int val;

  if (r_type == R_PARISC_NONE)
    return bfd_reloc_ok;

  insn = bfd_get_32 (input_bfd, hit_data);

  /* Find out where we are and where we're going.  */
  location = (offset +
	      input_section->output_offset +
	      input_section->output_section->vma);

  /* If we are not building a shared library, convert DLTIND relocs to
     DPREL relocs.  */
  if (!info->shared)
    {
      switch (r_type)
	{
	  case R_PARISC_DLTIND21L:
	  case R_PARISC_TLS_GD21L:
	  case R_PARISC_TLS_LDM21L:
	  case R_PARISC_TLS_IE21L:
	    r_type = R_PARISC_DPREL21L;
	    break;

	  case R_PARISC_DLTIND14R:
	  case R_PARISC_TLS_GD14R:
	  case R_PARISC_TLS_LDM14R:
	  case R_PARISC_TLS_IE14R:
	    r_type = R_PARISC_DPREL14R;
	    break;

	  case R_PARISC_DLTIND14F:
	    r_type = R_PARISC_DPREL14F;
	    break;
	}
    }

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      /* If this call should go via the plt, find the import stub in
	 the stub hash.  */
      if (sym_sec == NULL
	  || sym_sec->output_section == NULL
	  || (hh != NULL
	      && hh->eh.plt.offset != (bfd_vma) -1
	      && hh->eh.dynindx != -1
	      && !hh->plabel
	      && (info->shared
		  || !hh->eh.def_regular
		  || hh->eh.root.type == bfd_link_hash_defweak)))
	{
	  hsh = hppa_get_stub_entry (input_section, sym_sec,
					    hh, rela, htab);
	  if (hsh != NULL)
	    {
	      value = (hsh->stub_offset
		       + hsh->stub_sec->output_offset
		       + hsh->stub_sec->output_section->vma);
	      addend = 0;
	    }
	  else if (sym_sec == NULL && hh != NULL
		   && hh->eh.root.type == bfd_link_hash_undefweak)
	    {
	      /* It's OK if undefined weak.  Calls to undefined weak
		 symbols behave as if the "called" function
		 immediately returns.  We can thus call to a weak
		 function without first checking whether the function
		 is defined.  */
	      value = location;
	      addend = 8;
	    }
	  else
	    return bfd_reloc_undefined;
	}
      /* Fall thru.  */

    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL14F:
    case R_PARISC_PCREL32:
      /* Make it a pc relative offset.  */
      value -= location;
      addend -= 8;
      break;

    case R_PARISC_DPREL21L:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14F:
      /* Convert instructions that use the linkage table pointer (r19) to
	 instructions that use the global data pointer (dp).  This is the
	 most efficient way of using PIC code in an incomplete executable,
	 but the user must follow the standard runtime conventions for
	 accessing data for this to work.  */
      if (orig_r_type != r_type)
	{
	  if (r_type == R_PARISC_DPREL21L)
	    {
	      /* GCC sometimes uses a register other than r19 for the
		 operation, so we must convert any addil instruction
		 that uses this relocation.  */
	      if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
		insn = ADDIL_DP;
	      else
		/* We must have a ldil instruction.  It's too hard to find
		   and convert the associated add instruction, so issue an
		   error.  */
		(*_bfd_error_handler)
		  (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
		   input_bfd,
		   input_section,
		   (long) offset,
		   howto->name,
		   insn);
	    }
	  else if (r_type == R_PARISC_DPREL14F)
	    {
	      /* This must be a format 1 load/store.  Change the base
		 register to dp.  */
	      insn = (insn & 0xfc1ffff) | (27 << 21);
	    }
	}

      /* For all the DP relative relocations, we need to examine the symbol's
	 section.  If it has no section or if it's a code section, then
	 "data pointer relative" makes no sense.  In that case we don't
	 adjust the "value", and for 21 bit addil instructions, we change the
	 source addend register from %dp to %r0.  This situation commonly
	 arises for undefined weak symbols and when a variable's "constness"
	 is declared differently from the way the variable is defined.  For
	 instance: "extern int foo" with foo defined as "const int foo".  */
      if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
	{
	  if ((insn & ((0x3f << 26) | (0x1f << 21)))
	      == (((int) OP_ADDIL << 26) | (27 << 21)))
	    {
	      insn &= ~ (0x1f << 21);
	    }
	  /* Now try to make things easy for the dynamic linker.  */

	  break;
	}
      /* Fall thru.  */

    case R_PARISC_DLTIND21L:
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14F:
    case R_PARISC_TLS_GD21L:
    case R_PARISC_TLS_LDM21L:
    case R_PARISC_TLS_IE21L:
    case R_PARISC_TLS_GD14R:
    case R_PARISC_TLS_LDM14R:
    case R_PARISC_TLS_IE14R:
      value -= elf_gp (input_section->output_section->owner);
      break;

    case R_PARISC_SEGREL32:
      if ((sym_sec->flags & SEC_CODE) != 0)
	value -= htab->text_segment_base;
      else
	value -= htab->data_segment_base;
      break;

    default:
      break;
    }

  switch (r_type)
    {
    case R_PARISC_DIR32:
    case R_PARISC_DIR14F:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL14F:
    case R_PARISC_PCREL32:
    case R_PARISC_DPREL14F:
    case R_PARISC_PLABEL32:
    case R_PARISC_DLTIND14F:
    case R_PARISC_SEGBASE:
    case R_PARISC_SEGREL32:
    case R_PARISC_TLS_DTPMOD32:
    case R_PARISC_TLS_DTPOFF32:
    case R_PARISC_TLS_TPREL32:
      r_field = e_fsel;
      break;

    case R_PARISC_DLTIND21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_PLABEL21L:
      r_field = e_lsel;
      break;

    case R_PARISC_DIR21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_TLS_GD21L:
    case R_PARISC_TLS_LDM21L:
    case R_PARISC_TLS_LDO21L:
    case R_PARISC_TLS_IE21L:
    case R_PARISC_TLS_LE21L:
      r_field = e_lrsel;
      break;

    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PLABEL14R:
    case R_PARISC_DLTIND14R:
      r_field = e_rsel;
      break;

    case R_PARISC_DIR17R:
    case R_PARISC_DIR14R:
    case R_PARISC_DPREL14R:
    case R_PARISC_TLS_GD14R:
    case R_PARISC_TLS_LDM14R:
    case R_PARISC_TLS_LDO14R:
    case R_PARISC_TLS_IE14R:
    case R_PARISC_TLS_LE14R:
      r_field = e_rrsel;
      break;

    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      r_field = e_fsel;

      if (r_type == (unsigned int) R_PARISC_PCREL17F)
	{
	  max_branch_offset = (1 << (17-1)) << 2;
	}
      else if (r_type == (unsigned int) R_PARISC_PCREL12F)
	{
	  max_branch_offset = (1 << (12-1)) << 2;
	}
      else
	{
	  max_branch_offset = (1 << (22-1)) << 2;
	}

      /* sym_sec is NULL on undefined weak syms or when shared on
	 undefined syms.  We've already checked for a stub for the
	 shared undefined case.  */
      if (sym_sec == NULL)
	break;

      /* If the branch is out of reach, then redirect the
	 call to the local stub for this function.  */
      if (value + addend + max_branch_offset >= 2*max_branch_offset)
	{
	  hsh = hppa_get_stub_entry (input_section, sym_sec,
					    hh, rela, htab);
	  if (hsh == NULL)
	    return bfd_reloc_undefined;

	  /* Munge up the value and addend so that we call the stub
	     rather than the procedure directly.  */
	  value = (hsh->stub_offset
		   + hsh->stub_sec->output_offset
		   + hsh->stub_sec->output_section->vma
		   - location);
	  addend = -8;
	}
      break;

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
    }

  /* Make sure we can reach the stub.  */
  if (max_branch_offset != 0
      && value + addend + max_branch_offset >= 2*max_branch_offset)
    {
      (*_bfd_error_handler)
	(_("%B(%A+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	 input_bfd,
	 input_section,
	 (long) offset,
	 hsh->bh_root.string);
      bfd_set_error (bfd_error_bad_value);
      return bfd_reloc_notsupported;
    }

  val = hppa_field_adjust (value, addend, r_field);

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL22F:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR17R:
      /* This is a branch.  Divide the offset by four.
	 Note that we need to decide whether it's a branch or
	 otherwise by inspecting the reloc.  Inspecting insn won't
	 work as insn might be from a .word directive.  */
      val >>= 2;
      break;

    default:
      break;
    }

  insn = hppa_rebuild_insn (insn, val, r_format);

  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, (bfd_vma) insn, hit_data);
  return bfd_reloc_ok;
}

/* Relocate an HPPA ELF section.  */

static bfd_boolean
elf32_hppa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  bfd_vma *local_got_offsets;
  struct elf32_hppa_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rela;
  Elf_Internal_Rela *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  local_got_offsets = elf_local_got_offsets (input_bfd);

  rela = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rela < relend; rela++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned int r_symndx;
      struct elf32_hppa_link_hash_entry *hh;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type rstatus;
      const char *sym_name;
      bfd_boolean plabel;
      bfd_boolean warned_undef;

      r_type = ELF32_R_TYPE (rela->r_info);
      if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      if (r_type == (unsigned int) R_PARISC_GNU_VTENTRY
	  || r_type == (unsigned int) R_PARISC_GNU_VTINHERIT)
	continue;

      r_symndx = ELF32_R_SYM (rela->r_info);
      hh = NULL;
      sym = NULL;
      sym_sec = NULL;
      warned_undef = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol, h defaults to NULL.  */
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rela);
	}
      else
	{
	  struct elf_link_hash_entry *eh;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rela,
				   r_symndx, symtab_hdr, sym_hashes,
				   eh, sym_sec, relocation,
				   unresolved_reloc, warned_undef);

	  if (!info->relocatable
	      && relocation == 0
	      && eh->root.type != bfd_link_hash_defined
	      && eh->root.type != bfd_link_hash_defweak
	      && eh->root.type != bfd_link_hash_undefweak)
	    {
	      if (info->unresolved_syms_in_objects == RM_IGNORE
		  && ELF_ST_VISIBILITY (eh->other) == STV_DEFAULT
		  && eh->type == STT_PARISC_MILLI)
		{
		  if (! info->callbacks->undefined_symbol
		      (info, eh_name (eh), input_bfd,
		       input_section, rela->r_offset, FALSE))
		    return FALSE;
		  warned_undef = TRUE;
		}
	    }
	  hh = hppa_elf_hash_entry (eh);
	}

      if (sym_sec != NULL && discarded_section (sym_sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rela, 1, relend,
					 elf_hppa_howto_table + r_type, 0,
					 contents);

      if (info->relocatable)
	continue;

      /* Do any required modifications to the relocation value, and
	 determine what types of dynamic info we need to output, if
	 any.  */
      plabel = 0;
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  {
	    bfd_vma off;
	    bfd_boolean do_got = 0;

	    /* Relocation is to the entry for this symbol in the
	       global offset table.  */
	    if (hh != NULL)
	      {
		bfd_boolean dyn;

		off = hh->eh.got.offset;
		dyn = htab->etab.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
						       &hh->eh))
		  {
		    /* If we aren't going to call finish_dynamic_symbol,
		       then we need to handle initialisation of the .got
		       entry and create needed relocs here.  Since the
		       offset must always be a multiple of 4, we use the
		       least significant bit to record whether we have
		       initialised it already.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			hh->eh.got.offset |= 1;
			do_got = 1;
		      }
		  }
	      }
	    else
	      {
		/* Local symbol case.  */
		if (local_got_offsets == NULL)
		  abort ();

		off = local_got_offsets[r_symndx];

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    local_got_offsets[r_symndx] |= 1;
		    do_got = 1;
		  }
	      }

	    if (do_got)
	      {
		if (info->shared)
		  {
		    /* Output a dynamic relocation for this GOT entry.
		       In this case it is relative to the base of the
		       object because the symbol index is zero.  */
		    Elf_Internal_Rela outrel;
		    bfd_byte *loc;
		    asection *sec = htab->srelgot;

		    outrel.r_offset = (off
				       + htab->sgot->output_offset
				       + htab->sgot->output_section->vma);
		    outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		    outrel.r_addend = relocation;
		    loc = sec->contents;
		    loc += sec->reloc_count++ * sizeof (Elf32_External_Rela);
		    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		  }
		else
		  bfd_put_32 (output_bfd, relocation,
			      htab->sgot->contents + off);
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    /* Add the base of the GOT to the relocation value.  */
	    relocation = (off
			  + htab->sgot->output_offset
			  + htab->sgot->output_section->vma);
	  }
	  break;

	case R_PARISC_SEGREL32:
	  /* If this is the first SEGREL relocation, then initialize
	     the segment base values.  */
	  if (htab->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd, hppa_record_segment_addr, htab);
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (htab->etab.dynamic_sections_created)
	    {
	      bfd_vma off;
	      bfd_boolean do_plt = 0;
	      /* If we have a global symbol with a PLT slot, then
		 redirect this relocation to it.  */
	      if (hh != NULL)
		{
		  off = hh->eh.plt.offset;
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared,
							 &hh->eh))
		    {
		      /* In a non-shared link, adjust_dynamic_symbols
			 isn't called for symbols forced local.  We
			 need to write out the plt entry here.  */
		      if ((off & 1) != 0)
			off &= ~1;
		      else
			{
			  hh->eh.plt.offset |= 1;
			  do_plt = 1;
			}
		    }
		}
	      else
		{
		  bfd_vma *local_plt_offsets;

		  if (local_got_offsets == NULL)
		    abort ();

		  local_plt_offsets = local_got_offsets + symtab_hdr->sh_info;
		  off = local_plt_offsets[r_symndx];

		  /* As for the local .got entry case, we use the last
		     bit to record whether we've already initialised
		     this local .plt entry.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      local_plt_offsets[r_symndx] |= 1;
		      do_plt = 1;
		    }
		}

	      if (do_plt)
		{
		  if (info->shared)
		    {
		      /* Output a dynamic IPLT relocation for this
			 PLT entry.  */
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
		      asection *s = htab->srelplt;

		      outrel.r_offset = (off
					 + htab->splt->output_offset
					 + htab->splt->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		  else
		    {
		      bfd_put_32 (output_bfd,
				  relocation,
				  htab->splt->contents + off);
		      bfd_put_32 (output_bfd,
				  elf_gp (htab->splt->output_section->owner),
				  htab->splt->contents + off + 4);
		    }
		}

	      if (off >= (bfd_vma) -2)
		abort ();

	      /* PLABELs contain function pointers.  Relocation is to
		 the entry for the function in the .plt.  The magic +2
		 offset signals to $$dyncall that the function pointer
		 is in the .plt and thus has a gp pointer too.
		 Exception:  Undefined PLABELs should have a value of
		 zero.  */
	      if (hh == NULL
		  || (hh->eh.root.type != bfd_link_hash_undefweak
		      && hh->eh.root.type != bfd_link_hash_undefined))
		{
		  relocation = (off
				+ htab->splt->output_offset
				+ htab->splt->output_section->vma
				+ 2);
		}
	      plabel = 1;
	    }
	  /* Fall through and possibly emit a dynamic relocation.  */

	case R_PARISC_DIR17F:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F:
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L:
	case R_PARISC_DPREL14F:
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	case R_PARISC_DIR32:
	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;

	  /* The reloc types handled here and this conditional
	     expression must match the code in ..check_relocs and
	     allocate_dynrelocs.  ie. We need exactly the same condition
	     as in ..check_relocs, with some extra conditions (dynindx
	     test in this case) to cater for relocs removed by
	     allocate_dynrelocs.  If you squint, the non-shared test
	     here does indeed match the one in ..check_relocs, the
	     difference being that here we test DEF_DYNAMIC as well as
	     !DEF_REGULAR.  All common syms end up with !DEF_REGULAR,
	     which is why we can't use just that test here.
	     Conversely, DEF_DYNAMIC can't be used in check_relocs as
	     there all files have not been loaded.  */
	  if ((info->shared
	       && (hh == NULL
		   || ELF_ST_VISIBILITY (hh->eh.other) == STV_DEFAULT
		   || hh->eh.root.type != bfd_link_hash_undefweak)
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || !SYMBOL_CALLS_LOCAL (info, &hh->eh)))
	      || (!info->shared
		  && hh != NULL
		  && hh->eh.dynindx != -1
		  && !hh->eh.non_got_ref
		  && ((ELIMINATE_COPY_RELOCS
		       && hh->eh.def_dynamic
		       && !hh->eh.def_regular)
		      || hh->eh.root.type == bfd_link_hash_undefweak
		      || hh->eh.root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip;
	      asection *sreloc;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      outrel.r_addend = rela->r_addend;
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rela->r_offset);
	      skip = (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2);
	      outrel.r_offset += (input_section->output_offset
				  + input_section->output_section->vma);

	      if (skip)
		{
		  memset (&outrel, 0, sizeof (outrel));
		}
	      else if (hh != NULL
		       && hh->eh.dynindx != -1
		       && (plabel
			   || !IS_ABSOLUTE_RELOC (r_type)
			   || !info->shared
			   || !info->symbolic
			   || !hh->eh.def_regular))
		{
		  outrel.r_info = ELF32_R_INFO (hh->eh.dynindx, r_type);
		}
	      else /* It's a local symbol, or one marked to become local.  */
		{
		  int indx = 0;

		  /* Add the absolute offset of the symbol.  */
		  outrel.r_addend += relocation;

		  /* Global plabels need to be processed by the
		     dynamic linker so that functions have at most one
		     fptr.  For this reason, we need to differentiate
		     between global and local plabels, which we do by
		     providing the function symbol for a global plabel
		     reloc, and no symbol for local plabels.  */
		  if (! plabel
		      && sym_sec != NULL
		      && sym_sec->output_section != NULL
		      && ! bfd_is_abs_section (sym_sec))
		    {
		      asection *osec;

		      osec = sym_sec->output_section;
		      indx = elf_section_data (osec)->dynindx;
		      if (indx == 0)
			{
			  osec = htab->etab.text_index_section;
			  indx = elf_section_data (osec)->dynindx;
			}
		      BFD_ASSERT (indx != 0);

		      /* We are turning this relocation into one
			 against a section symbol, so subtract out the
			 output section's address but not the offset
			 of the input section in the output section.  */
		      outrel.r_addend -= osec->vma;
		    }

		  outrel.r_info = ELF32_R_INFO (indx, r_type);
		}
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  break;

	case R_PARISC_TLS_LDM21L:
	case R_PARISC_TLS_LDM14R:
	  {
	    bfd_vma off;

	    off = htab->tls_ldm_got.offset;
	    if (off & 1)
	      off &= ~1;
	    else
	      {
		Elf_Internal_Rela outrel;
		bfd_byte *loc;

		outrel.r_offset = (off
				   + htab->sgot->output_section->vma
				   + htab->sgot->output_offset);
		outrel.r_addend = 0;
		outrel.r_info = ELF32_R_INFO (0, R_PARISC_TLS_DTPMOD32);
		loc = htab->srelgot->contents;
		loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);

		bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		htab->tls_ldm_got.offset |= 1;
	      }

	    /* Add the base of the GOT to the relocation value.  */
	    relocation = (off
			  + htab->sgot->output_offset
			  + htab->sgot->output_section->vma);

	    break;
	  }

	case R_PARISC_TLS_LDO21L:
	case R_PARISC_TLS_LDO14R:
	  relocation -= dtpoff_base (info);
	  break;

	case R_PARISC_TLS_GD21L:
	case R_PARISC_TLS_GD14R:
	case R_PARISC_TLS_IE21L:
	case R_PARISC_TLS_IE14R:
	  {
	    bfd_vma off;
	    int indx;
	    char tls_type;

	    indx = 0;
	    if (hh != NULL)
	      {
	        bfd_boolean dyn;
	        dyn = htab->etab.dynamic_sections_created;

		if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, &hh->eh)
		    && (!info->shared
			|| !SYMBOL_REFERENCES_LOCAL (info, &hh->eh)))
		  {
		    indx = hh->eh.dynindx;
		  }
		off = hh->eh.got.offset;
		tls_type = hh->tls_type;
	      }
	    else
	      {
		off = local_got_offsets[r_symndx];
		tls_type = hppa_elf_local_got_tls_type (input_bfd)[r_symndx];
	      }

	    if (tls_type == GOT_UNKNOWN)
	      abort ();

	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		bfd_boolean need_relocs = FALSE;
		Elf_Internal_Rela outrel;
		bfd_byte *loc = NULL;
		int cur_off = off;

	        /* The GOT entries have not been initialized yet.  Do it
	           now, and emit any relocations.  If both an IE GOT and a
	           GD GOT are necessary, we emit the GD first.  */

		if ((info->shared || indx != 0)
		    && (hh == NULL
			|| ELF_ST_VISIBILITY (hh->eh.other) == STV_DEFAULT
			|| hh->eh.root.type != bfd_link_hash_undefweak))
		  {
		    need_relocs = TRUE;
		    loc = htab->srelgot->contents;
		    /* FIXME (CAO): Should this be reloc_count++ ? */
		    loc += htab->srelgot->reloc_count * sizeof (Elf32_External_Rela);
		  }

		if (tls_type & GOT_TLS_GD)
		  {
		    if (need_relocs)
		      {
			outrel.r_offset = (cur_off
					   + htab->sgot->output_section->vma
					   + htab->sgot->output_offset);
			outrel.r_info = ELF32_R_INFO (indx,R_PARISC_TLS_DTPMOD32);
			outrel.r_addend = 0;
			bfd_put_32 (output_bfd, 0, htab->sgot->contents + cur_off);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
			htab->srelgot->reloc_count++;
			loc += sizeof (Elf32_External_Rela);

			if (indx == 0)
			  bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
				      htab->sgot->contents + cur_off + 4);
			else
			  {
			    bfd_put_32 (output_bfd, 0,
					htab->sgot->contents + cur_off + 4);
			    outrel.r_info = ELF32_R_INFO (indx, R_PARISC_TLS_DTPOFF32);
			    outrel.r_offset += 4;
			    bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
			    htab->srelgot->reloc_count++;
			    loc += sizeof (Elf32_External_Rela);
			  }
		      }
		    else
		      {
		        /* If we are not emitting relocations for a
		           general dynamic reference, then we must be in a
		           static link or an executable link with the
		           symbol binding locally.  Mark it as belonging
		           to module 1, the executable.  */
		        bfd_put_32 (output_bfd, 1,
				    htab->sgot->contents + cur_off);
		        bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
				    htab->sgot->contents + cur_off + 4);
		      }


		    cur_off += 8;
		  }

		if (tls_type & GOT_TLS_IE)
		  {
		    if (need_relocs)
		      {
			outrel.r_offset = (cur_off
					   + htab->sgot->output_section->vma
					   + htab->sgot->output_offset);
			outrel.r_info = ELF32_R_INFO (indx, R_PARISC_TLS_TPREL32);

			if (indx == 0)
			  outrel.r_addend = relocation - dtpoff_base (info);
			else
			  outrel.r_addend = 0;

			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
			htab->srelgot->reloc_count++;
			loc += sizeof (Elf32_External_Rela);
		      }
		    else
		      bfd_put_32 (output_bfd, tpoff (info, relocation),
				  htab->sgot->contents + cur_off);

		    cur_off += 4;
		  }

		if (hh != NULL)
		  hh->eh.got.offset |= 1;
		else
		  local_got_offsets[r_symndx] |= 1;
	      }

	    if ((tls_type & GOT_TLS_GD)
	  	&& r_type != R_PARISC_TLS_GD21L
	  	&& r_type != R_PARISC_TLS_GD14R)
	      off += 2 * GOT_ENTRY_SIZE;

	    /* Add the base of the GOT to the relocation value.  */
	    relocation = (off
			  + htab->sgot->output_offset
			  + htab->sgot->output_section->vma);

	    break;
	  }

	case R_PARISC_TLS_LE21L:
	case R_PARISC_TLS_LE14R:
	  {
	    relocation = tpoff (info, relocation);
	    break;
	  }
	  break;

	default:
	  break;
	}

      rstatus = final_link_relocate (input_section, contents, rela, relocation,
			       htab, sym_sec, hh, info);

      if (rstatus == bfd_reloc_ok)
	continue;

      if (hh != NULL)
	sym_name = hh_name (hh);
      else
	{
	  sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	  if (sym_name == NULL)
	    return FALSE;
	  if (*sym_name == '\0')
	    sym_name = bfd_section_name (input_bfd, sym_sec);
	}

      howto = elf_hppa_howto_table + r_type;

      if (rstatus == bfd_reloc_undefined || rstatus == bfd_reloc_notsupported)
	{
	  if (rstatus == bfd_reloc_notsupported || !warned_undef)
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): cannot handle %s for %s"),
		 input_bfd,
		 input_section,
		 (long) rela->r_offset,
		 howto->name,
		 sym_name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
      else
	{
	  if (!((*info->callbacks->reloc_overflow)
		(info, (hh ? &hh->eh.root : NULL), sym_name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rela->r_offset)))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *eh,
				  Elf_Internal_Sym *sym)
{
  struct elf32_hppa_link_hash_table *htab;
  Elf_Internal_Rela rela;
  bfd_byte *loc;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (eh->plt.offset != (bfd_vma) -1)
    {
      bfd_vma value;

      if (eh->plt.offset & 1)
	abort ();

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.

	 The format of a plt entry is
	 <funcaddr>
	 <__gp>
      */
      value = 0;
      if (eh->root.type == bfd_link_hash_defined
	  || eh->root.type == bfd_link_hash_defweak)
	{
	  value = eh->root.u.def.value;
	  if (eh->root.u.def.section->output_section != NULL)
	    value += (eh->root.u.def.section->output_offset
		      + eh->root.u.def.section->output_section->vma);
	}

      /* Create a dynamic IPLT relocation for this entry.  */
      rela.r_offset = (eh->plt.offset
		      + htab->splt->output_offset
		      + htab->splt->output_section->vma);
      if (eh->dynindx != -1)
	{
	  rela.r_info = ELF32_R_INFO (eh->dynindx, R_PARISC_IPLT);
	  rela.r_addend = 0;
	}
      else
	{
	  /* This symbol has been marked to become local, and is
	     used by a plabel so must be kept in the .plt.  */
	  rela.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rela.r_addend = value;
	}

      loc = htab->srelplt->contents;
      loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rela, loc);

      if (!eh->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (eh->got.offset != (bfd_vma) -1
      && (hppa_elf_hash_entry (eh)->tls_type & GOT_TLS_GD) == 0
      && (hppa_elf_hash_entry (eh)->tls_type & GOT_TLS_IE) == 0)
    {
      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      rela.r_offset = ((eh->got.offset &~ (bfd_vma) 1)
		      + htab->sgot->output_offset
		      + htab->sgot->output_section->vma);

      /* If this is a -Bsymbolic link and the symbol is defined
	 locally or was forced to be local because of a version file,
	 we just want to emit a RELATIVE reloc.  The entry in the
	 global offset table will already have been initialized in the
	 relocate_section function.  */
      if (info->shared
	  && (info->symbolic || eh->dynindx == -1)
	  && eh->def_regular)
	{
	  rela.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
	  rela.r_addend = (eh->root.u.def.value
			  + eh->root.u.def.section->output_offset
			  + eh->root.u.def.section->output_section->vma);
	}
      else
	{
	  if ((eh->got.offset & 1) != 0)
	    abort ();

	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + (eh->got.offset & ~1));
	  rela.r_info = ELF32_R_INFO (eh->dynindx, R_PARISC_DIR32);
	  rela.r_addend = 0;
	}

      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (eh->needs_copy)
    {
      asection *sec;

      /* This symbol needs a copy reloc.  Set it up.  */

      if (! (eh->dynindx != -1
	     && (eh->root.type == bfd_link_hash_defined
		 || eh->root.type == bfd_link_hash_defweak)))
	abort ();

      sec = htab->srelbss;

      rela.r_offset = (eh->root.u.def.value
		      + eh->root.u.def.section->output_offset
		      + eh->root.u.def.section->output_section->vma);
      rela.r_addend = 0;
      rela.r_info = ELF32_R_INFO (eh->dynindx, R_PARISC_COPY);
      loc = sec->contents + sec->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (eh == htab->etab.hdynamic || eh == htab->etab.hgot)
    {
      sym->st_shndx = SHN_ABS;
    }

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf32_hppa_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *rela)
{
  /* Handle TLS relocs first; we don't want them to be marked
     relative by the "if (ELF32_R_SYM (rela->r_info) == STN_UNDEF)"
     check below.  */
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
      case R_PARISC_TLS_DTPMOD32:
      case R_PARISC_TLS_DTPOFF32:
      case R_PARISC_TLS_TPREL32:
        return reloc_class_normal;
    }

  if (ELF32_R_SYM (rela->r_info) == STN_UNDEF)
    return reloc_class_relative;

  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_PARISC_IPLT:
      return reloc_class_plt;
    case R_PARISC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf32_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *htab;
  asection *sdyn;
  asection * sgot;

  htab = hppa_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->etab.dynobj;

  sgot = htab->sgot;
  /* A broken linker script might have discarded the dynamic sections.
     Catch this here so that we do not seg-fault later on.  */
  if (sgot != NULL && bfd_is_abs_section (sgot->output_section))
    return FALSE;

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->etab.dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL)
	abort ();

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PLTGOT:
	      /* Use PLTGOT to set the GOT register.  */
	      dyn.d_un.d_ptr = elf_gp (output_bfd);
	      break;

	    case DT_JMPREL:
	      s = htab->srelplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->srelplt;
	      dyn.d_un.d_val = s->size;
	      break;

	    case DT_RELASZ:
	      /* Don't count procedure linkage table relocs in the
		 overall reloc count.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->size;
	      break;
	    }

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	}
    }

  if (sgot != NULL && sgot->size != 0)
    {
      /* Fill in the first entry in the global offset table.
	 We use it to point to our dynamic section, if we have one.  */
      bfd_put_32 (output_bfd,
		  sdyn ? sdyn->output_section->vma + sdyn->output_offset : 0,
		  sgot->contents);

      /* The second entry is reserved for use by the dynamic linker.  */
      memset (sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);

      /* Set .got entry size.  */
      elf_section_data (sgot->output_section)
	->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
    }

  if (htab->splt != NULL && htab->splt->size != 0)
    {
      /* Set plt entry size.  */
      elf_section_data (htab->splt->output_section)
	->this_hdr.sh_entsize = PLT_ENTRY_SIZE;

      if (htab->need_plt_stub)
	{
	  /* Set up the .plt stub.  */
	  memcpy (htab->splt->contents
		  + htab->splt->size - sizeof (plt_stub),
		  plt_stub, sizeof (plt_stub));

	  if ((htab->splt->output_offset
	       + htab->splt->output_section->vma
	       + htab->splt->size)
	      != (sgot->output_offset
		  + sgot->output_section->vma))
	    {
	      (*_bfd_error_handler)
		(_(".got section not immediately after .plt section"));
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Called when writing out an object file to decide the type of a
   symbol.  */
static int
elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_PARISC_MILLI)
    return STT_PARISC_MILLI;
  else
    return type;
}

/* Misc BFD support code.  */
#define bfd_elf32_bfd_is_local_label_name    elf_hppa_is_local_label_name
#define bfd_elf32_bfd_reloc_type_lookup	     elf_hppa_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup      elf_hppa_reloc_name_lookup
#define elf_info_to_howto		     elf_hppa_info_to_howto
#define elf_info_to_howto_rel		     elf_hppa_info_to_howto_rel

/* Stuff for the BFD linker.  */
#define bfd_elf32_bfd_final_link	     elf32_hppa_final_link
#define bfd_elf32_bfd_link_hash_table_create elf32_hppa_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free   elf32_hppa_link_hash_table_free
#define elf_backend_adjust_dynamic_symbol    elf32_hppa_adjust_dynamic_symbol
#define elf_backend_copy_indirect_symbol     elf32_hppa_copy_indirect_symbol
#define elf_backend_check_relocs	     elf32_hppa_check_relocs
#define elf_backend_create_dynamic_sections  elf32_hppa_create_dynamic_sections
#define elf_backend_fake_sections	     elf_hppa_fake_sections
#define elf_backend_relocate_section	     elf32_hppa_relocate_section
#define elf_backend_hide_symbol		     elf32_hppa_hide_symbol
#define elf_backend_finish_dynamic_symbol    elf32_hppa_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections  elf32_hppa_finish_dynamic_sections
#define elf_backend_size_dynamic_sections    elf32_hppa_size_dynamic_sections
#define elf_backend_init_index_section	     _bfd_elf_init_1_index_section
#define elf_backend_gc_mark_hook	     elf32_hppa_gc_mark_hook
#define elf_backend_gc_sweep_hook	     elf32_hppa_gc_sweep_hook
#define elf_backend_grok_prstatus	     elf32_hppa_grok_prstatus
#define elf_backend_grok_psinfo		     elf32_hppa_grok_psinfo
#define elf_backend_object_p		     elf32_hppa_object_p
#define elf_backend_final_write_processing   elf_hppa_final_write_processing
#define elf_backend_post_process_headers     _bfd_elf_set_osabi
#define elf_backend_get_symbol_type	     elf32_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	     elf32_hppa_reloc_type_class
#define elf_backend_action_discarded	     elf_hppa_action_discarded

#define elf_backend_can_gc_sections	     1
#define elf_backend_can_refcount	     1
#define elf_backend_plt_alignment	     2
#define elf_backend_want_got_plt	     0
#define elf_backend_plt_readonly	     0
#define elf_backend_want_plt_sym	     0
#define elf_backend_got_header_size	     8
#define elf_backend_rela_normal		     1

#define TARGET_BIG_SYM		bfd_elf32_hppa_vec
#define TARGET_BIG_NAME		"elf32-hppa"
#define ELF_ARCH		bfd_arch_hppa
#define ELF_TARGET_ID		HPPA32_ELF_DATA
#define ELF_MACHINE_CODE	EM_PARISC
#define ELF_MAXPAGESIZE		0x1000
#define ELF_OSABI		ELFOSABI_HPUX
#define elf32_bed		elf32_hppa_hpux_bed

#include "elf32-target.h"

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM		bfd_elf32_hppa_linux_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-hppa-linux"
#undef ELF_OSABI
#define ELF_OSABI		ELFOSABI_GNU
#undef elf32_bed
#define elf32_bed		elf32_hppa_linux_bed

#include "elf32-target.h"

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM		bfd_elf32_hppa_nbsd_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-hppa-netbsd"
#undef ELF_OSABI
#define ELF_OSABI		ELFOSABI_NETBSD
#undef elf32_bed
#define elf32_bed		elf32_hppa_netbsd_bed

#include "elf32-target.h"
@


1.194
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d2371 1
a2371 1
		bfd_set_section_alignment (dynobj, sec, gotalign);
@


1.193
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d1172 4
@


1.192
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d4439 3
a4441 1
elf32_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.191
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d1709 1
a1709 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d1712 1
a1712 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d1735 1
a1735 1
	elf_tdata (abfd)->core_program
d1737 1
a1737 1
	elf_tdata (abfd)->core_command
d1745 1
a1745 1
    char *command = elf_tdata (abfd)->core_command;
@


1.190
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d453 1
a453 1
  _bfd_generic_link_hash_table_free (btab);
@


1.189
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d422 1
a422 1
  htab = bfd_malloc (amt);
a438 10
  htab->stub_bfd = NULL;
  htab->add_stub_section = NULL;
  htab->layout_sections_again = NULL;
  htab->stub_group = NULL;
  htab->sgot = NULL;
  htab->srelgot = NULL;
  htab->splt = NULL;
  htab->srelplt = NULL;
  htab->sdynbss = NULL;
  htab->srelbss = NULL;
a440 8
  htab->multi_subspace = 0;
  htab->has_12bit_branch = 0;
  htab->has_17bit_branch = 0;
  htab->has_22bit_branch = 0;
  htab->need_plt_stub = 0;
  htab->sym_cache.abfd = NULL;
  htab->tls_ldm_got.refcount = 0;

@


1.188
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d13 1
a13 1
 
d127 1
a127 1
   
d133 1
a133 1
   
d138 1
a138 1
   
d140 1
a140 1
					  
d1113 1
a1113 1
                  
d1381 1
a1381 1
		  
d1968 1
a1968 1
	  
d2016 1
a2016 1
  
d2117 1
a2117 1
      
d2304 1
a2304 1
	      if (info->shared) 
d2345 1
a2345 1
  
d2348 1
a2348 1
      /* Allocate 2 got entries and 1 dynamic reloc for 
d3223 1
a3223 1
   address when resolving a dtpoff relocation.  
d3245 1
a3245 1
  /* hppa TLS ABI is variant I and static TLS block start just after 
d3247 1
a3247 1
  return (address - htab->tls_sec->vma 
d3326 1
a3326 1
  int val;  
d4005 1
a4005 1
	      	      
d4067 1
a4067 1
	  
d4072 1
a4072 1
	
d4081 1
a4081 1
		outrel.r_offset = (off 
d4086 1
a4086 1
		loc = htab->srelgot->contents; 
d4158 1
a4158 1
		    loc = htab->srelgot->contents; 
@


1.187
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d4445 1
a4445 3
  if (eh_name (eh)[0] == '_'
      && (strcmp (eh_name (eh), "_DYNAMIC") == 0
	  || eh == htab->etab.hgot))
@


1.186
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1008 2
a1009 2
  htab->splt = bfd_get_section_by_name (abfd, ".plt");
  htab->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d1011 2
a1012 2
  htab->sgot = bfd_get_section_by_name (abfd, ".got");
  htab->srelgot = bfd_get_section_by_name (abfd, ".rela.got");
d1014 2
a1015 2
  htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
d2228 1
a2228 1
	  sec = bfd_get_section_by_name (dynobj, ".interp");
d4509 1
a4509 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.185
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3739 2
a3740 2
					 rela, relend,
					 elf_hppa_howto_table + r_type,
@


1.184
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3737 1
a3737 1
      if (sym_sec != NULL && elf_discarded_section (sym_sec))
@


1.183
log
@	PR binutils/13476
	* elf32-hppa.c (final_link_relocate): Convert R_PARISC_TLS_GD21L,
	R_PARISC_TLS_LDM21L and R_PARISC_TLS_IE21L relocations to
	R_PARISC_DPREL21L when not doing a shared link.  Likewise convert
	R_PARISC_TLS_GD14R, R_PARISC_TLS_LDM14R and R_PARISC_TLS_IE14R to
	R_PARISC_DPREL14R.  Handle R_PARISC_TLS_GD21L, R_PARISC_TLS_LDM21L
	and R_PARISC_TLS_IE21L with R_PARISC_DLTIND21L.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a1900 7
  if (eh->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     eh->root.root.string);
      return TRUE;
    }

d1918 1
a1918 1
  if ((eh->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.182
log
@	PR ld/13387
	* elf32-hppa.c (elf32_hppa_hide_symbol): Make STT_GNU_IFUNC symbol
	go through PLT.  Reset plt field with init_plt_offset.
	(elf32_hppa_adjust_dynamic_symbol): Ensure that a PLT slot is
	allocated for symbols referenced by a plabel.
@
text
@d3352 3
d3359 3
a3426 3
    case R_PARISC_TLS_GD21L:
    case R_PARISC_TLS_LDM21L:
    case R_PARISC_TLS_IE21L:
d3432 37
a3468 39
      if (orig_r_type == R_PARISC_DLTIND21L
	  || (!info->shared
	      && (r_type == R_PARISC_TLS_GD21L
		  || r_type == R_PARISC_TLS_LDM21L
		  || r_type == R_PARISC_TLS_IE21L)))
	{
	  /* Convert addil instructions if the original reloc was a
	     DLTIND21L.  GCC sometimes uses a register other than r19 for
	     the operation, so we must convert any addil instruction
	     that uses this relocation.  */
	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
	    insn = ADDIL_DP;
	  else
	    /* We must have a ldil instruction.  It's too hard to find
	       and convert the associated add instruction, so issue an
	       error.  */
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       input_bfd,
	       input_section,
	       (long) offset,
	       howto->name,
	       insn);
	}
      else if (orig_r_type == R_PARISC_DLTIND14F)
	{
	  /* This must be a format 1 load/store.  Change the base
	     register to dp.  */
	  insn = (insn & 0xfc1ffff) | (27 << 21);
	}

    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it has no section or if it's a code section, then
       "data pointer relative" makes no sense.  In that case we don't
       adjust the "value", and for 21 bit addil instructions, we change the
       source addend register from %dp to %r0.  This situation commonly
       arises for undefined weak symbols and when a variable's "constness"
       is declared differently from the way the variable is defined.  For
       instance: "extern int foo" with foo defined as "const int foo".  */
d3485 3
@


1.181
log
@	PR ld/13049
	* elf64-ppc.c (STUB_SUFFIX): Revert previous delta.
	* elf32-hppa.c (STUB_SUFFIX): Likewise.
@
text
@d1792 3
a1794 1
  if (! hppa_elf_hash_entry (eh)->plabel)
d1797 1
a1797 1
      eh->plt = elf_hash_table (info)->init_plt_refcount;
d1819 7
@


1.180
log
@	PR ld/13049
	* elf32-arm.c (STUB_SUFFIX): Avoid collision with user namespace
	symbol names.
	* elf64-ppc.c (STUB_SUFFIX): Likewise.
	* elf32-hppa.c (STUB_SUFFIX): Likewise.
@
text
@d158 2
a159 2
   string.  PR 13049: Use a name that is not a valid C identifier.  */
#define STUB_SUFFIX ".__stub"
@


1.179
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d158 2
a159 2
   string.  */
#define STUB_SUFFIX ".stub"
@


1.179.2.1
log
@	Backport from mainline:
	2011-11-06  John David Anglin  <dave.anglin@@nrc-cnrc.gc.ca>

	PR ld/13387
	* elf32-hppa.c (elf32_hppa_hide_symbol): Make STT_GNU_IFUNC symbol
	go through PLT.  Reset plt field with init_plt_offset.
	(elf32_hppa_adjust_dynamic_symbol): Ensure that a PLT slot is
	allocated for symbols referenced by a plabel.
@
text
@d1792 1
a1792 3
  /* STT_GNU_IFUNC symbol must go through PLT.  */
  if (! hppa_elf_hash_entry (eh)->plabel
      && eh->type != STT_GNU_IFUNC)
d1795 1
a1795 1
      eh->plt = elf_hash_table (info)->init_plt_offset;
a1816 7
      /* If the symbol is used by a plabel, we must allocate a PLT slot.
	 The refcounts are not reliable when it has been hidden since
	 hide_symbol can be called before the plabel flag is set.  */
      if (hppa_elf_hash_entry (eh)->plabel
	  && eh->plt.refcount <= 0)
	eh->plt.refcount = 1;

@


1.179.2.2
log
@	Backport from mainline:
	2011-12-11  John Davis Anglin  <dave.anglin@@nrc-cnrc.gc.ca>

	PR binutils/13476
	* elf32-hppa.c (final_link_relocate): Convert R_PARISC_TLS_GD21L,
	R_PARISC_TLS_LDM21L and R_PARISC_TLS_IE21L relocations to
	R_PARISC_DPREL21L when not doing a shared link.  Likewise convert
	R_PARISC_TLS_GD14R, R_PARISC_TLS_LDM14R and R_PARISC_TLS_IE14R to
	R_PARISC_DPREL14R.  Handle R_PARISC_TLS_GD21L, R_PARISC_TLS_LDM21L
	and R_PARISC_TLS_IE21L with R_PARISC_DLTIND21L.
@
text
@a3351 3
	  case R_PARISC_TLS_GD21L:
	  case R_PARISC_TLS_LDM21L:
	  case R_PARISC_TLS_IE21L:
a3355 3
	  case R_PARISC_TLS_GD14R:
	  case R_PARISC_TLS_LDM14R:
	  case R_PARISC_TLS_IE14R:
d3421 3
d3429 39
a3467 37
      if (orig_r_type != r_type)
	{
	  if (r_type == R_PARISC_DPREL21L)
	    {
	      /* GCC sometimes uses a register other than r19 for the
		 operation, so we must convert any addil instruction
		 that uses this relocation.  */
	      if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
		insn = ADDIL_DP;
	      else
		/* We must have a ldil instruction.  It's too hard to find
		   and convert the associated add instruction, so issue an
		   error.  */
		(*_bfd_error_handler)
		  (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
		   input_bfd,
		   input_section,
		   (long) offset,
		   howto->name,
		   insn);
	    }
	  else if (r_type == R_PARISC_DPREL14F)
	    {
	      /* This must be a format 1 load/store.  Change the base
		 register to dp.  */
	      insn = (insn & 0xfc1ffff) | (27 << 21);
	    }
	}

      /* For all the DP relative relocations, we need to examine the symbol's
	 section.  If it has no section or if it's a code section, then
	 "data pointer relative" makes no sense.  In that case we don't
	 adjust the "value", and for 21 bit addil instructions, we change the
	 source addend register from %dp to %r0.  This situation commonly
	 arises for undefined weak symbols and when a variable's "constness"
	 is declared differently from the way the variable is defined.  For
	 instance: "extern int foo" with foo defined as "const int foo".  */
a3483 3
    case R_PARISC_TLS_GD21L:
    case R_PARISC_TLS_LDM21L:
    case R_PARISC_TLS_IE21L:
@


1.179.2.3
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3744 1
a3744 1
      if (sym_sec != NULL && discarded_section (sym_sec))
@


1.178
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d953 1
a953 1
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
d955 1
a955 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
d4681 1
a4681 1
#define ELF_OSABI		ELFOSABI_LINUX
@


1.177
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): If the
	backend does not provide a function for creating dynamic sections
	then fail.
	(bfd_elf_final_link): Issue a warning message if a dynamic section
	has the SHT_NOTE type.
	(bfd_elf_final_link): Do not look for dynamic strings in a section
	that does not have the SHT_STRTAB type or the name .dynstr.
	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Fail if the got
	section is not in the output binary.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Likewise.

	* ld-elf/elf.exp: Add test for linking a shared library with a
	broken linker script that marks dynamic sections as being notes.
	* ld-elf/note-3.s: New test source file.
	* ld-elf/note-3.t: New test linker script.
	* ld-elf/note-3.l: Expected output from the linker.
	* lib/ld-lib.exp (run_ld_link_tests): Improve description.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
a1940 3
  if (eh->root.type == bfd_link_hash_warning)
    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

a2007 3
  if (eh->root.type == bfd_link_hash_warning)
    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

a2166 3
  if (eh->root.type == bfd_link_hash_warning)
    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

a2182 3
  if (eh->root.type == bfd_link_hash_warning)
    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

@


1.176
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d4501 1
d4509 6
d4579 1
a4579 1
  if (htab->sgot != NULL && htab->sgot->size != 0)
d4585 1
a4585 1
		  htab->sgot->contents);
d4588 1
a4588 1
      memset (htab->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);
d4591 1
a4591 1
      elf_section_data (htab->sgot->output_section)
d4611 2
a4612 2
	      != (htab->sgot->output_offset
		  + htab->sgot->output_section->vma))
@


1.175
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d3744 4
a3747 11
	{
	  /* For relocs against symbols from removed linkonce
	     sections, or sections discarded by a linker script,
	     we just want the section contents zeroed.  Avoid any
	     special processing.  */
	  _bfd_clear_contents (elf_hppa_howto_table + r_type, input_bfd,
			       contents + rela->r_offset);
	  rela->r_info = 0;
	  rela->r_addend = 0;
	  continue;
	}
@


1.174
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d4475 1
a4475 1
     relative by the "if (ELF32_R_SYM (rela->r_info) == 0)"
d4485 1
a4485 1
  if (ELF32_R_SYM (rela->r_info) == 0)
@


1.173
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@a338 9
/* Override the generic function because we want to mark our BFDs.  */

static bfd_boolean
elf32_hppa_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_obj_tdata),
				  HPPA32_ELF_DATA);
}

a4642 1
#define bfd_elf32_mkobject		     elf32_hppa_mkobject
d4680 1
@


1.172
log
@fix set but unused variable warnings
@
text
@d1739 1
a1739 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.171
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a1162 1
  asection *stubreloc;
a1173 1
  stubreloc = NULL;
@


1.170
log
@	* elf32-hppa.c (final_link_relocate): Convert R_PARISC_TLS_GD21L,
	R_PARISC_TLS_LDM21L and R_PARISC_TLS_IE21L relocations that use the
	linkage table pointer to use the global table pointer if not doing
	a shared link.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d317 2
a318 1
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))
d345 1
a345 1
				  HPPA_ELF_TDATA);
d436 2
a437 1
				      sizeof (struct elf32_hppa_link_hash_entry)))
d733 3
d1008 2
d1170 2
d1381 1
a1381 1
	    hppa_link_hash_table (info)->tls_ldm_got.refcount += 1;
d1613 1
d1618 4
d1686 1
a1686 1
	  hppa_link_hash_table (info)->tls_ldm_got.refcount -= 1;
d1921 2
d1958 3
d2027 3
d2237 3
d2533 3
d2603 3
d2713 3
d2844 3
d3132 3
d3219 2
d3297 2
d3680 3
d4350 2
d4521 3
@


1.169
log
@	* elf32-hppa.c (elf32_hppa_final_link): Don't sort unwind information
	in a relocatable link.
	* elf64-hppa.c (elf_hppa_final_link): Likewise.
@
text
@d3391 3
d3399 5
a3403 1
      if (orig_r_type == R_PARISC_DLTIND21L)
a3453 1
    case R_PARISC_TLS_GD21L:
a3454 1
    case R_PARISC_TLS_LDM21L:
a3455 1
    case R_PARISC_TLS_IE21L:
@


1.168
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d3241 3
@


1.167
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d304 2
a305 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d463 1
a463 1
  htab->sym_sec.abfd = NULL;
a1524 1

d1527 6
d1534 1
a1534 2
		  sr = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						       sec, r_symndx);
d1536 1
a1536 1
		    return FALSE;
@


1.166
log
@* elf32-hppa.c (final_link_relocate): Cast bfd_vma values to long
for format string.
@
text
@d1014 1
a1014 10
  htab->srelgot = bfd_make_section_with_flags (abfd, ".rela.got",
					       (SEC_ALLOC
						| SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (abfd, htab->srelgot, 2))
    return FALSE;
@


1.165
log
@	* elf32-hppa.c (hppa32_elf_local_refcounts): New function.
	(elf32_hppa_check_relocs): Use it.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008
d3414 1
a3414 1
	       offset,
d3578 1
a3578 1
	 offset,
@


1.164
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d1116 32
d1394 1
a1394 1
	          local_got_refcounts = elf_local_got_refcounts (abfd);
d1396 1
a1396 18
		    {
		      bfd_size_type size;

		      /* Allocate space for local got offsets and local
		         plt offsets.  Done this way to save polluting
		         elf_obj_tdata with another target specific
		         pointer.  */
		      size = symtab_hdr->sh_info;
		      size *= 2 * sizeof (bfd_signed_vma);
		      /* Add in space to store the local GOT TLS types.  */
		      size += symtab_hdr->sh_info;
		      local_got_refcounts = bfd_zalloc (abfd, size);
		      if (local_got_refcounts == NULL)
		        return FALSE;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		      memset (hppa_elf_local_got_tls_type (abfd),
		    	  GOT_UNKNOWN, symtab_hdr->sh_info);
		    }
d1443 1
a1443 1
		  local_got_refcounts = elf_local_got_refcounts (abfd);
d1445 1
a1445 14
		    {
		      bfd_size_type size;

		      /* Allocate space for local got offsets and local
			 plt offsets.  */
		      size = symtab_hdr->sh_info;
		      size *= 2 * sizeof (bfd_signed_vma);
		      /* Add in space to store the local GOT TLS types.  */
		      size += symtab_hdr->sh_info;
		      local_got_refcounts = bfd_zalloc (abfd, size);
		      if (local_got_refcounts == NULL)
			return FALSE;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		    }
@


1.163
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@a1507 16
		  char *name;
		  bfd *dynobj;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    {
		      (*_bfd_error_handler)
			(_("Could not find relocation section for %s"),
			 sec->name);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }

d1511 3
a1513 2
		  dynobj = htab->etab.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
d1516 2
a1517 12
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || !bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
a1518 2

		  elf_section_data (sec)->sreloc = sreloc;
@


1.162
log
@	* elf-bfd.h (enum elf_object_id): Add HPPA_ELF_TDATA.
	* elf.c (bfd_elf_allocate_object): Don't check for already allocated
	tdata.
	* elf32-hppa.c (elf32_hppa_mkobject): New function.
	(bfd_elf32_mkobject): Define.
	* elf32-ppc.c (is_ppc_elf_target): Delete.  Replace all uses with..
	(is_ppc_elf): ..this new macro.
	* elf64-ppc.c (is_ppc64_elf_target): Delete.  Replace all uses with..
	(is_ppc64_elf): ..this new macro.
@
text
@d3 2
a4 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d2980 1
a2982 2
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
d2985 9
a2993 3
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
@


1.161
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d337 9
d4614 1
a4614 1
#define bfd_elf32_bfd_reloc_name_lookup elf_hppa_reloc_name_lookup
d4619 1
@


1.160
log
@* elf.c (_bfd_elf_find_segment_containing_section): New function:
  Scan the segment map looking for the segment containing a
  specified function.
* elf-bfd.h: Prototype the new function.
* elf-hppa.h (elf_hppa_osec_to_segment): Delete.
  (elf_hppa_record_segment_addrs): Use new function.
* elf32-bfin.c (_bfdfdpic_osec_to_segment): Use new function.
* elf32-frv.c (_frvfdpic_osec_to_segment): Use new function.
* elf32-hppa.c (hppa_record_segment_addr): Use new function.
* elfxx-ia64.c (elfNN_ia64_relocate_section): Use new function.
@
text
@d1625 3
@


1.159
log
@	* elf-hppa.h (elf_hppa_osec_to_segment): New function.
	(elf_hppa_record_segment_addrs): Use elf_hppa_osec_to_segment.
	Remove ATTRIBUTE_UNUSED from abfd argument.
	* elf32-hppa.c (hppa_record_segment_addr): Likewise.
@
text
@d3259 1
a3259 3
hppa_record_segment_addr (bfd *abfd,
			  asection *section,
			  void *data)
d3267 6
a3272 2
      unsigned seg = elf_hppa_osec_to_segment (abfd, section->output_section);
      bfd_vma value = elf_tdata (abfd)->phdr[seg].p_vaddr;
@


1.158
log
@* elf32-hppa.c (hppa_record_segment_addr): Locate the segment
  containing the section using the segment map, rather than guessing
  based upon the section's vma and file position.
@
text
@d3259 1
a3259 1
hppa_record_segment_addr (bfd *abfd ATTRIBUTE_UNUSED,
d3269 2
a3270 21
      bfd_vma value;
      struct elf_segment_map *m;
      Elf_Internal_Phdr *p;

      /* Find the segment that contains the output_section for this section.  */
      for (m = elf_tdata (abfd)->segment_map,
	     p = elf_tdata (abfd)->phdr;
	   m != NULL;
	   m = m->next, p++)
	{
	  int i;

	  for (i = m->count - 1; i >= 0; i--)
	    if (m->sections[i] == section->output_section)
	      break;
	  if (i >= 0)
	    break;
	}

      if (m == NULL)
        return;
a3271 2
      value = p->p_vaddr;
      
@


1.157
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d3269 21
a3289 1
      bfd_vma value = section->vma - section->filepos;
d3291 2
@


1.156
log
@Switch sources over to use the GPL version 3
@
text
@d1281 3
a1283 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &hh->eh, rela->r_addend))
@


1.155
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d17 1
a17 1
   the Free Software Foundation; either version 2 of the License, or
d27 2
a28 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.154
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1821 1
  unsigned int power_of_two;
a1930 8
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how other ELF linkers handle this.  */

  power_of_two = bfd_log2 (eh->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
a1931 10
  sec->size = BFD_ALIGN (sec->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->etab.dynobj, sec))
    {
      if (! bfd_set_section_alignment (htab->etab.dynobj, sec, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  eh->root.u.def.section = sec;
  eh->root.u.def.value = sec->size;
d1933 1
a1933 4
  /* Increment the section size to make room for the symbol.  */
  sec->size += eh->size;

  return TRUE;
@


1.153
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d29 1
a30 1
#include "sysdep.h"
@


1.152
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d4618 1
@


1.151
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@a4603 24
/* Tweak the OSABI field of the elf header.  */

static void
elf32_hppa_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;

  i_ehdrp = elf_elfheader (abfd);

  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_LINUX;
    }
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NETBSD;
    }
  else
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
    }
}

d4642 1
a4642 1
#define elf_backend_post_process_headers     elf32_hppa_post_process_headers
d4661 1
d4670 2
d4681 2
@


1.150
log
@	* elf32-hppa.c (elf32_bed): Define for hpux, linux and netbsd.
	(INCLUDED_TARGET_FILE): Remove.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
a3653 3
  if (info->relocatable)
    return TRUE;

a3684 1
      /* This is a final link.  */
d3708 2
a3709 1
	  if (relocation == 0
d3728 16
a3954 10
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (elf_hppa_howto_table + r_type, input_bfd,
				   contents + rela->r_offset);
	      break;
	    }

@


1.149
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d4682 1
d4687 1
a4687 1
#define TARGET_BIG_SYM			bfd_elf32_hppa_linux_vec
d4689 3
a4691 1
#define TARGET_BIG_NAME			"elf32-hppa-linux"
a4692 1
#define INCLUDED_TARGET_FILE 1
d4696 1
a4696 1
#define TARGET_BIG_SYM			bfd_elf32_hppa_nbsd_vec
d4698 3
a4700 1
#define TARGET_BIG_NAME			"elf32-hppa-netbsd"
@


1.148
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d3945 8
a3952 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
@


1.147
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d4027 10
a4036 4
		      /* Skip this relocation if the output section has
			 been discarded.  */
		      if (bfd_is_abs_section (sym_sec->output_section))
			break;
a4037 1
		      indx = elf_section_data (sym_sec->output_section)->dynindx;
d4042 1
a4042 1
		      outrel.r_addend -= sym_sec->output_section->vma;
d4650 1
@


1.146
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1591 1
a1591 1
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
d1597 6
a1602 24
    {
      switch ((unsigned int) ELF32_R_TYPE (rela->r_info))
	{
	case R_PARISC_GNU_VTINHERIT:
	case R_PARISC_GNU_VTENTRY:
	  break;

	default:
	  switch (hh->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return hh->root.u.def.section;

	    case bfd_link_hash_common:
	      return hh->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1604 1
a1604 1
  return NULL;
@


1.145
log
@Add TLS support for hppa-linux
@
text
@d2445 1
a2445 1
      else if (strncmp (bfd_get_section_name (dynobj, sec), ".rela", 5) == 0)
@


1.144
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d10 3
a12 1

d173 2
a174 1
enum elf32_hppa_stub_type {
d183 2
a184 2
struct elf32_hppa_stub_hash_entry {

d209 2
a210 2
struct elf32_hppa_link_hash_entry {

d219 2
a220 2
  struct elf32_hppa_dyn_reloc_entry {

d236 5
d245 2
a246 2
struct elf32_hppa_link_hash_table {

d262 2
a263 1
  struct map_stub {
d304 7
d327 9
d403 1
d419 1
a419 1
  htab = (struct elf32_hppa_link_hash_table *) bfd_malloc (amt);
d453 1
d483 1
a483 1
      len = 8 + 1 + strlen (hh->eh.root.root.string) + 1 + 8 + 1;
d486 4
a489 6
	{
	  sprintf (stub_name, "%08x_%s+%x",
		   input_section->id & 0xffffffff,
		   hh->eh.root.root.string,
		   (int) rela->r_addend & 0xffffffff);
	}
d496 5
a500 7
	{
	  sprintf (stub_name, "%08x_%x:%x+%x",
		   input_section->id & 0xffffffff,
		   sym_sec->id & 0xffffffff,
		   (int) ELF32_R_SYM (rela->r_info) & 0xffffffff,
		   (int) rela->r_addend & 0xffffffff);
	}
d646 2
a647 3
    {
      max_branch_offset = (1 << (17-1)) << 2;
    }
d649 2
a650 3
    {
      max_branch_offset = (1 << (12-1)) << 2;
    }
d652 1
a652 3
    {
      max_branch_offset = (1 << (22-1)) << 2;
    }
d1085 18
a1102 1
   _bfd_elf_link_hash_copy_indirect (info, eh_dir, eh_ind);
d1123 1
d1161 1
d1284 14
d1305 19
d1334 3
a1336 4
	  if (hh != NULL)
	    {
	      hh->eh.got.refcount += 1;
	    }
d1339 44
a1382 6
	      bfd_signed_vma *local_got_refcounts;
              /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;
a1383 12
		  /* Allocate space for local got offsets and local
		     plt offsets.  Done this way to save polluting
		     elf_obj_tdata with another target specific
		     pointer.  */
		  size = symtab_hdr->sh_info;
		  size *= 2 * sizeof (bfd_signed_vma);
		  local_got_refcounts = bfd_zalloc (abfd, size);
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      local_got_refcounts[r_symndx] += 1;
d1424 2
d1679 2
d1686 4
d1702 5
d1821 1
a1821 1
  if (! hppa_elf_hash_entry(eh)->plabel)
d1994 1
a1994 1
  hh = hppa_elf_hash_entry(eh);
d2094 5
d2105 4
d2302 1
d2341 1
d2350 4
d2355 7
a2361 1
		srel->size += sizeof (Elf32_External_Rela);
d2365 2
d2395 11
d2816 1
a2816 1
		  stub_name = hh->eh.root.root.string;
d3250 29
d3490 6
d3523 3
d3537 5
d3555 5
d3740 1
a3740 1
		      (info, eh->root.root.string, input_bfd,
d4069 192
d4273 1
a4273 1
	sym_name = hh->eh.root.root.string;
d4382 3
a4384 1
  if (eh->got.offset != (bfd_vma) -1)
d4445 2
a4446 2
  if (eh->root.root.string[0] == '_'
      && (strcmp (eh->root.root.string, "_DYNAMIC") == 0
d4461 11
@


1.143
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d397 2
a398 1
  if (!_bfd_elf_link_hash_table_init (&htab->etab, abfd, hppa_link_hash_newfunc))
d405 2
a406 1
  if (!bfd_hash_table_init (&htab->bstab, stub_hash_newfunc))
@


1.142
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d4060 1
a4060 1
	  || strcmp (eh->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0))
@


1.141
log
@	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Use info->executable
	instead of !info->shared.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d2023 1
a2023 1
      if (ELF_ST_VISIBILITY (eh->other) != STV_DEFAULT
d2025 13
a2037 1
	hh->dyn_relocs = NULL;
@


1.140
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2350 1
a2350 1
      if (!info->shared)
@


1.139
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d1007 1
a1007 1
elf32_hppa_copy_indirect_symbol (const struct elf_backend_data *bed,
d1023 1
a1023 4
	  if (eh_ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d1029 3
a1031 1
	      for (hdh_q = hh_dir->dyn_relocs; hdh_q != NULL; hdh_q = hdh_q->hdh_next)
d1064 1
a1064 1
   _bfd_elf_link_hash_copy_indirect (bed, eh_dir, eh_ind);
@


1.138
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1449 2
d1456 2
a1457 2
		  hdh_head = ((struct elf32_hppa_dyn_reloc_entry **)
			  &elf_section_data (sr)->local_dynrel);
@


1.137
log
@	* elf-bfd.h (struct elf_backend_data): Add action_discarded.
	(enum action_discarded): Move from..
	* elflink.c (enum action_discarded): ..here.
	(_bfd_elf_default_action_discarded): Rename from elf_action_discarded.
	Remove target specific section checks.
	(elf_link_input_bfd): Adjust.
	* elfxx-target.h (elf_backend_action_discarded): Define.
	(elfNN_bed): Init new field.
	* bfd-in.h (_bfd_elf_default_action_discarded): Declare.
	* bfd-in2.h: Regenerate.
	* elf-hppa.h (elf_hppa_action_discarded): New function.
	* elf32-hppa.c (elf_backend_action_discarded): Define.
	* elf64-hppa.c (elf_backend_action_discarded): Define.
	* elf32-ppc.c (ppc_elf_action_discarded): New function.
	(elf_backend_action_discarded): Define.
@
text
@d1810 7
@


1.136
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d4254 1
@


1.135
log
@	* bfd/elf32-hppa.c (struct elf32_hppa_stub_hash_entry):
	Use bh_root, and hh.
	(struct elf32_hppa_link_hash_entry): Use eh, and hsh_cache.
	(struct elf32_hppa_dyn_reloc_entry): Use hdh_next.
	(struct elf32_hppa_link_hash_table): Use etab and bstab.
	(stub_hash_newfunc): Use hh.
	(hppa_link_hash_newfunc): Use hsh_cache.
	(elf32_hppa_link_hash_table_create): Use etab, and bstab.
	(elf32_hppa_link_hash_table_free): Use bstab.
	(hppa_stub_name): Use eh.
	(hppa_get_stub_entry): Use hh, hsh_entry, and hsh_cache.
	(hppa_add_stub): Use bstab.
	(hppa_type_of_stub): Use eh.
	(hppa_build_one_stub): Use hh and bh_root.
	(elf32_hppa_copy_indirect_symbol): Use hdh_next.
	(elf32_hppa_check_relocs): Use eh, etab, and hdh_next.
	(elf32_hppa_gc_sweep_hook): Use hdh_next.
	(elf32_hppa_adjust_dynamic_symbol): Use hdh_next, and etab.
	(allocate_plt_static): Use etab.
	(allocate_dynrelocs): Use etab, and hdh_next.
	(readonly_dynrelocs): Use hdh_next.
	(elf32_hppa_size_dynamic_sections): Use etab, and hdh_next.
	(get_local_syms): Use eh, bstab, and hh.
	(elf32_hppa_size_stubs): Use eh, bstab, and hh.
	(elf32_hppa_set_gp): Use etab.
	(elf32_hppa_build_stubs): Use bstab.
	(final_link_relocate): Use eh, bh_root.
	(elf32_hppa_relocate_section): Use elf, etab.
	(elf32_hppa_finish_dynamic_sections): Use etab.
@
text
@d2277 2
a2278 1
      else if (sec == htab->sgot)
d2315 3
d2321 1
a2321 1
      if (sec->contents == NULL && sec->size != 0)
@


1.134
log
@	* bfd/elf32-hppa.c (hppa_elf_hash_entry): Define.
	(hppa_stub_hash_entry): Define.
	(stub_hash_newfunc): Rename variables.
	(hppa_link_hash_newfunc): Likewise.
	(elf32_hppa_link_hash_table_free): Likewise.
	(hppa_stub_name): Likewise.
	(hppa_get_stub_entry): Likewise.
	(hppa_add_stub): Likewise.
	(hppa_type_of_stub): Likewise.
	(hppa_build_one_stub): Likewise.
	(hppa_size_one_stub): Likewise.
	(elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_copy_indirect_symbol): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	(elf32_hppa_gc_mark_hook): Likewise.
	(elf32_hppa_gc_sweep_hook): Likewise.
	(elf32_hppa_grok_psinfo): Likewise.
	(elf32_hppa_hide_symbol): Likewise.
	(elf32_hppa_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(clobber_millicode_symbols): Likewise.
	(readonly_dynrelocs): Likewise.
	(elf32_hppa_size_dynamic_sections): Likewise.
	(get_local_syms): Likewise.
	(elf32_hppa_size_stubs): Likewise.
	(hppa_record_segment_addr): Likewise.
	(final_link_relocate): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	(elf32_hppa_finish_dynamic_symbol): Likewise.
@
text
@d183 1
a183 1
  struct bfd_hash_entry root;
d199 1
a199 1
  struct elf32_hppa_link_hash_entry *h;
d208 1
a208 1
  struct elf_link_hash_entry elf;
d212 1
a212 1
  struct elf32_hppa_stub_hash_entry *stub_cache;
d219 1
a219 1
    struct elf32_hppa_dyn_reloc_entry *next;
d240 1
a240 1
  struct elf_link_hash_table elf;
d243 1
a243 1
  struct bfd_hash_table stub_hash_table;
d343 1
a343 1
      hsh->h = NULL;
d375 1
a375 1
      hh->stub_cache = NULL;
d397 1
a397 1
  if (!_bfd_elf_link_hash_table_init (&htab->elf, abfd, hppa_link_hash_newfunc))
d404 1
a404 1
  if (!bfd_hash_table_init (&htab->stub_hash_table, stub_hash_newfunc))
d426 1
a426 1
  return &htab->elf.root;
d437 1
a437 1
  bfd_hash_table_free (&htab->stub_hash_table);
d454 1
a454 1
      len = 8 + 1 + strlen (hh->elf.root.root.string) + 1 + 8 + 1;
d460 1
a460 1
		   hh->elf.root.root.string,
d490 1
a490 1
  struct elf32_hppa_stub_hash_entry *stub_entry;
d500 3
a502 3
  if (hh != NULL && hh->stub_cache != NULL
      && hh->stub_cache->h == hh
      && hh->stub_cache->id_sec == id_sec)
d504 1
a504 1
      stub_entry = hh->stub_cache;
d514 1
a514 1
      stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
d517 1
a517 1
	hh->stub_cache = stub_entry;
d522 1
a522 1
  return stub_entry;
d565 1
a565 1
  hsh = hppa_stub_hash_lookup (&htab->stub_hash_table, stub_name,
d596 2
a597 2
      && hh->elf.plt.offset != (bfd_vma) -1
      && hh->elf.dynindx != -1
d600 2
a601 2
	  || !hh->elf.def_regular
	  || hh->elf.root.type == bfd_link_hash_defweak))
d753 1
a753 1
      off = hsh->h->elf.plt.offset;
d826 1
a826 1
	     hsh->root.string);
d845 2
a846 2
      hsh->h->elf.root.u.def.section = stub_sec;
      hsh->h->elf.root.u.def.value = stub_sec->size;
d1032 1
a1032 1
	      for (hdh_q = hh_dir->dyn_relocs; hdh_q != NULL; hdh_q = hdh_q->next)
d1039 1
a1039 1
		    *hdh_pp = hdh_p->next;
d1043 1
a1043 1
		hdh_pp = &hdh_p->next;
d1117 3
a1119 3
	  while (hh->elf.root.type == bfd_link_hash_indirect
		 || hh->elf.root.type == bfd_link_hash_warning)
	    hh = hppa_elf_hash_entry (hh->elf.root.u.i.link);
d1191 1
a1191 1
	      if (hh->elf.type == STT_PARISC_MILLI)
d1234 1
a1234 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &hh->elf, rela->r_offset))
d1241 1
a1241 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &hh->elf, rela->r_addend))
d1256 3
a1258 3
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!elf32_hppa_create_dynamic_sections (htab->elf.dynobj, info))
d1264 1
a1264 1
	      hh->elf.got.refcount += 1;
d1304 2
a1305 2
		  hh->elf.needs_plt = 1;
		  hh->elf.plt.refcount += 1;
d1345 1
a1345 1
	    hh->elf.non_got_ref = 1;
d1380 2
a1381 2
			   || hh->elf.root.type == bfd_link_hash_defweak
			   || !hh->elf.def_regular))))
d1386 2
a1387 2
		  && (hh->elf.root.type == bfd_link_hash_defweak
		      || !hh->elf.def_regular)))
d1412 2
a1413 2
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;
d1415 1
a1415 1
		  dynobj = htab->elf.dynobj;
d1461 1
a1461 1
		  hdh_p = bfd_alloc (htab->elf.dynobj, sizeof *hdh_p);
d1464 1
a1464 1
		  hdh_p->next = *hdh_head;
d1568 1
a1568 1
	  for (hdh_pp = &hh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; hdh_pp = &hdh_p->next)
d1572 1
a1572 1
		*hdh_pp = hdh_p->next;
d1794 1
a1794 1
      for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)
d1841 1
a1841 1
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, sec))
d1843 1
a1843 1
      if (! bfd_set_section_alignment (htab->elf.dynobj, sec, power_of_two))
d1877 1
a1877 1
  if (htab->elf.dynamic_sections_created
d1945 1
a1945 1
  if (htab->elf.dynamic_sections_created
d1975 1
a1975 1
      if (htab->elf.dynamic_sections_created
d2006 1
a2006 1
		*hdh_pp = hdh_p->next;
d2008 1
a2008 1
		hdh_pp = &hdh_p->next;
d2029 1
a2029 1
	       || (htab->elf.dynamic_sections_created
d2056 1
a2056 1
  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)
d2099 1
a2099 1
  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)
d2129 1
a2129 1
  dynobj = htab->elf.dynobj;
d2133 1
a2133 1
  if (htab->elf.dynamic_sections_created)
d2146 1
a2146 1
      elf_link_hash_traverse (&htab->elf,
d2173 1
a2173 1
	       hdh_p = hdh_p->next)
d2217 1
a2217 1
      if (! htab->elf.dynamic_sections_created)
d2245 1
a2245 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, info);
d2249 1
a2249 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d2321 1
a2321 1
  if (htab->elf.dynamic_sections_created)
d2362 1
a2362 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d2624 3
a2626 3
	      while (hh->elf.root.type == bfd_link_hash_indirect
		     || hh->elf.root.type == bfd_link_hash_warning)
		   hh = hppa_elf_hash_entry (hh->elf.root.u.i.link);
d2631 5
a2635 5
	      if ((hh->elf.root.type == bfd_link_hash_defined
		   || hh->elf.root.type == bfd_link_hash_defweak)
		  && hh->elf.type == STT_FUNC
		  && hh->elf.root.u.def.section->output_section != NULL
		  && (hh->elf.root.u.def.section->output_section->owner
d2637 4
a2640 4
		  && hh->elf.root.u.def.section->owner == input_bfd
		  && hh->elf.def_regular
		  && !hh->elf.forced_local
		  && ELF_ST_VISIBILITY (hh->elf.other) == STV_DEFAULT)
d2646 3
a2648 3
		  sec = hh->elf.root.u.def.section;
		  stub_name = hh->elf.root.root.string;
		  hsh = hppa_stub_hash_lookup (&htab->stub_hash_table,
d2657 2
a2658 2
		      hsh->target_value = hh->elf.root.u.def.value;
		      hsh->target_section = hh->elf.root.u.def.section;
d2660 1
a2660 1
		      hsh->h = hh;
d2853 3
a2855 3
		      while (hh->elf.root.type == bfd_link_hash_indirect
			     || hh->elf.root.type == bfd_link_hash_warning)
			hh = hppa_elf_hash_entry (hh->elf.root.u.i.link);
d2857 2
a2858 2
		      if (hh->elf.root.type == bfd_link_hash_defined
			  || hh->elf.root.type == bfd_link_hash_defweak)
d2860 2
a2861 2
			  sym_sec = hh->elf.root.u.def.section;
			  sym_value = hh->elf.root.u.def.value;
d2867 1
a2867 1
		      else if (hh->elf.root.type == bfd_link_hash_undefweak)
d2872 1
a2872 1
		      else if (hh->elf.root.type == bfd_link_hash_undefined)
d2875 1
a2875 1
				 && (ELF_ST_VISIBILITY (hh->elf.other)
d2877 1
a2877 1
				 && hh->elf.type != STT_PARISC_MILLI))
d2901 1
a2901 1
		  hsh = hppa_stub_hash_lookup (&htab->stub_hash_table,
d2928 1
a2928 1
		  hsh->h = hh;
d2948 1
a2948 1
      bfd_hash_traverse (&htab->stub_hash_table, hppa_size_one_stub, htab);
d2975 1
a2975 1
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", FALSE, FALSE, FALSE);
d3075 1
a3075 1
  table = &htab->stub_hash_table;
d3190 2
a3191 2
	      && hh->elf.plt.offset != (bfd_vma) -1
	      && hh->elf.dynindx != -1
d3194 2
a3195 2
		  || !hh->elf.def_regular
		  || hh->elf.root.type == bfd_link_hash_defweak)))
d3207 1
a3207 1
		   && hh->elf.root.type == bfd_link_hash_undefweak)
d3403 1
a3403 1
	 hsh->root.string);
d3551 2
a3552 2
		off = hh->elf.got.offset;
		dyn = htab->elf.dynamic_sections_created;
d3554 1
a3554 1
						       &hh->elf))
d3566 1
a3566 1
			hh->elf.got.offset |= 1;
d3636 1
a3636 1
	  if (htab->elf.dynamic_sections_created)
d3644 1
a3644 1
		  off = hh->elf.plt.offset;
d3646 1
a3646 1
							 &hh->elf))
d3655 1
a3655 1
			  hh->elf.plt.offset |= 1;
d3722 2
a3723 2
		  || (hh->elf.root.type != bfd_link_hash_undefweak
		      && hh->elf.root.type != bfd_link_hash_undefined))
d3764 2
a3765 2
		   || ELF_ST_VISIBILITY (hh->elf.other) == STV_DEFAULT
		   || hh->elf.root.type != bfd_link_hash_undefweak)
d3767 1
a3767 1
		   || !SYMBOL_CALLS_LOCAL (info, &hh->elf)))
d3770 2
a3771 2
		  && hh->elf.dynindx != -1
		  && !hh->elf.non_got_ref
d3773 4
a3776 4
		       && hh->elf.def_dynamic
		       && !hh->elf.def_regular)
		      || hh->elf.root.type == bfd_link_hash_undefweak
		      || hh->elf.root.type == bfd_link_hash_undefined)))
d3801 1
a3801 1
		       && hh->elf.dynindx != -1
d3806 1
a3806 1
			   || !hh->elf.def_regular))
d3808 1
a3808 1
		  outrel.r_info = ELF32_R_INFO (hh->elf.dynindx, r_type);
d3864 1
a3864 1
	sym_name = hh->elf.root.root.string;
d3896 1
a3896 1
		(info, (hh ? &hh->elf.root : NULL), sym_name, howto->name,
d4075 1
a4075 1
  dynobj = htab->elf.dynobj;
d4079 1
a4079 1
  if (htab->elf.dynamic_sections_created)
@


1.133
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1022
	* elf32-hppa.c (elf32_hppa_check_relocs): Handle indirect
	symbol.
@
text
@d116 21
d301 6
d334 1
a334 1
      struct elf32_hppa_stub_hash_entry *eh;
d337 8
a344 8
      eh = (struct elf32_hppa_stub_hash_entry *) entry;
      eh->stub_sec = NULL;
      eh->stub_offset = 0;
      eh->target_value = 0;
      eh->target_section = NULL;
      eh->stub_type = hppa_stub_long_branch;
      eh->h = NULL;
      eh->id_sec = NULL;
d371 1
a371 1
      struct elf32_hppa_link_hash_entry *eh;
d374 4
a377 4
      eh = (struct elf32_hppa_link_hash_entry *) entry;
      eh->stub_cache = NULL;
      eh->dyn_relocs = NULL;
      eh->plabel = 0;
d390 2
a391 2
  struct elf32_hppa_link_hash_table *ret;
  bfd_size_type amt = sizeof (*ret);
d393 2
a394 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d397 1
a397 1
  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, hppa_link_hash_newfunc))
d399 1
a399 1
      free (ret);
d404 1
a404 1
  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc))
d407 18
a424 18
  ret->stub_bfd = NULL;
  ret->add_stub_section = NULL;
  ret->layout_sections_again = NULL;
  ret->stub_group = NULL;
  ret->sgot = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->text_segment_base = (bfd_vma) -1;
  ret->data_segment_base = (bfd_vma) -1;
  ret->multi_subspace = 0;
  ret->has_12bit_branch = 0;
  ret->has_17bit_branch = 0;
  ret->has_22bit_branch = 0;
  ret->need_plt_stub = 0;
  ret->sym_sec.abfd = NULL;
d426 1
a426 1
  return &ret->elf.root;
d432 1
a432 1
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *hash)
d434 2
a435 2
  struct elf32_hppa_link_hash_table *ret
    = (struct elf32_hppa_link_hash_table *) hash;
d437 2
a438 2
  bfd_hash_table_free (&ret->stub_hash_table);
  _bfd_generic_link_hash_table_free (hash);
d446 2
a447 2
		const struct elf32_hppa_link_hash_entry *hash,
		const Elf_Internal_Rela *rel)
d452 1
a452 1
  if (hash)
d454 1
a454 1
      len = 8 + 1 + strlen (hash->elf.root.root.string) + 1 + 8 + 1;
d460 2
a461 2
		   hash->elf.root.root.string,
		   (int) rel->r_addend & 0xffffffff);
d473 2
a474 2
		   (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
		   (int) rel->r_addend & 0xffffffff);
d486 2
a487 2
		     struct elf32_hppa_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
d500 3
a502 3
  if (hash != NULL && hash->stub_cache != NULL
      && hash->stub_cache->h == hash
      && hash->stub_cache->id_sec == id_sec)
d504 1
a504 1
      stub_entry = hash->stub_cache;
d510 1
a510 1
      stub_name = hppa_stub_name (id_sec, sym_sec, hash, rel);
d516 2
a517 2
      if (hash != NULL)
	hash->stub_cache = stub_entry;
d535 1
a535 1
  struct elf32_hppa_stub_hash_entry *stub_entry;
d565 1
a565 1
  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table, stub_name,
d567 1
a567 1
  if (stub_entry == NULL)
d575 4
a578 4
  stub_entry->stub_sec = stub_sec;
  stub_entry->stub_offset = 0;
  stub_entry->id_sec = link_sec;
  return stub_entry;
d585 2
a586 2
		   const Elf_Internal_Rela *rel,
		   struct elf32_hppa_link_hash_entry *hash,
d595 4
a598 4
  if (hash != NULL
      && hash->elf.plt.offset != (bfd_vma) -1
      && hash->elf.dynindx != -1
      && !hash->plabel
d600 2
a601 2
	  || !hash->elf.def_regular
	  || hash->elf.root.type == bfd_link_hash_defweak))
d611 1
a611 1
	      + rel->r_offset);
d614 1
a614 1
  r_type = ELF32_R_TYPE (rel->r_info);
d680 1
a680 1
hppa_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d682 1
a682 1
  struct elf32_hppa_stub_hash_entry *stub_entry;
d695 2
a696 2
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  info = in_arg;
d699 1
a699 1
  stub_sec = stub_entry->stub_sec;
d702 2
a703 2
  stub_entry->stub_offset = stub_sec->size;
  loc = stub_sec->contents + stub_entry->stub_offset;
d707 1
a707 1
  switch (stub_entry->stub_type)
d714 3
a716 3
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);
d731 3
a733 3
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);
d736 1
a736 1
      sym_value -= (stub_entry->stub_offset
d753 1
a753 1
      off = stub_entry->h->elf.plt.offset;
d765 1
a765 1
      if (stub_entry->stub_type == hppa_stub_import_shared)
d808 3
a810 3
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);
d813 1
a813 1
      sym_value -= (stub_entry->stub_offset
d823 1
a823 1
	     stub_entry->target_section->owner,
d825 2
a826 2
	     (long) stub_entry->stub_offset,
	     stub_entry->root.string);
d845 2
a846 2
      stub_entry->h->elf.root.u.def.section = stub_sec;
      stub_entry->h->elf.root.u.def.value = stub_sec->size;
d885 1
a885 1
hppa_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d887 1
a887 1
  struct elf32_hppa_stub_hash_entry *stub_entry;
d892 1
a892 1
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
d895 1
a895 1
  if (stub_entry->stub_type == hppa_stub_long_branch)
d897 1
a897 1
  else if (stub_entry->stub_type == hppa_stub_long_branch_shared)
d899 1
a899 1
  else if (stub_entry->stub_type == hppa_stub_export)
d909 1
a909 1
  stub_entry->stub_sec->size += size;
d967 1
a967 1
  struct elf_link_hash_entry *h;
d998 4
a1001 4
  h = elf_hash_table (info)->hgot;
  h->forced_local = 0;
  h->other = STV_DEFAULT;
  return bfd_elf_link_record_dynamic_symbol (info, h);
d1008 2
a1009 2
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
d1011 1
a1011 1
  struct elf32_hppa_link_hash_entry *edir, *eind;
d1013 2
a1014 2
  edir = (struct elf32_hppa_link_hash_entry *) dir;
  eind = (struct elf32_hppa_link_hash_entry *) ind;
d1016 1
a1016 1
  if (eind->dyn_relocs != NULL)
d1018 1
a1018 1
      if (edir->dyn_relocs != NULL)
d1020 2
a1021 2
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;
d1023 1
a1023 1
	  if (ind->root.type == bfd_link_hash_indirect)
d1028 1
a1028 1
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
d1030 1
a1030 1
	      struct elf32_hppa_dyn_reloc_entry *q;
d1032 2
a1033 2
	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
d1036 1
a1036 1
		    q->relative_count += p->relative_count;
d1038 2
a1039 2
		    q->count += p->count;
		    *pp = p->next;
d1042 2
a1043 2
	      if (q == NULL)
		pp = &p->next;
d1045 1
a1045 1
	  *pp = edir->dyn_relocs;
d1048 2
a1049 2
      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
d1053 2
a1054 2
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
d1059 4
a1062 4
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
d1065 1
a1065 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1080 3
a1082 3
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
d1092 1
a1092 1
  sym_hashes = elf_sym_hashes (abfd);
d1096 2
a1097 2
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
d1107 2
a1108 2
      struct elf32_hppa_link_hash_entry *h;
      int need_entry;
d1110 1
a1110 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d1113 1
a1113 1
	h = NULL;
d1116 4
a1119 5
	  h = ((struct elf32_hppa_link_hash_entry *)
	     sym_hashes[r_symndx - symtab_hdr->sh_info]);
	  while (h->elf.root.type == bfd_link_hash_indirect
		 || h->elf.root.type == bfd_link_hash_warning)
	    h = (struct elf32_hppa_link_hash_entry *) h->elf.root.u.i.link;
d1122 1
a1122 1
      r_type = ELF32_R_TYPE (rel->r_info);
d1137 1
a1137 1
	  if (rel->r_addend != 0)
d1145 1
d1174 1
a1174 1
	  if (h == NULL)
d1191 1
a1191 1
	      if (h->elf.type == STT_PARISC_MILLI)
d1234 1
a1234 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &h->elf, rel->r_offset))
d1241 1
a1241 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &h->elf, rel->r_addend))
d1262 1
a1262 1
	  if (h != NULL)
d1264 1
a1264 1
	      h->elf.got.refcount += 1;
d1269 1
a1269 2

	      /* This is a global offset table entry for a local symbol.  */
d1302 1
a1302 1
	      if (h != NULL)
d1304 2
a1305 2
		  h->elf.needs_plt = 1;
		  h->elf.plt.refcount += 1;
d1311 1
a1311 1
		    h->plabel = 1;
d1344 2
a1345 2
	  if (h != NULL && !info->shared)
	    h->elf.non_got_ref = 1;
d1378 1
a1378 1
		   || (h != NULL
d1380 2
a1381 2
			   || h->elf.root.type == bfd_link_hash_defweak
			   || !h->elf.def_regular))))
d1385 3
a1387 3
		  && h != NULL
		  && (h->elf.root.type == bfd_link_hash_defweak
		      || !h->elf.def_regular)))
d1389 2
a1390 2
	      struct elf32_hppa_dyn_reloc_entry *p;
	      struct elf32_hppa_dyn_reloc_entry **head;
d1438 1
a1438 1
	      if (h != NULL)
d1440 1
a1440 1
		  head = &h->dyn_relocs;
d1448 4
a1451 4
		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
d1454 2
a1455 2
		  head = ((struct elf32_hppa_dyn_reloc_entry **)
			  &elf_section_data (s)->local_dynrel);
d1458 2
a1459 2
	      p = *head;
	      if (p == NULL || p->sec != sec)
d1461 2
a1462 2
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
d1464 4
a1467 4
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
d1469 1
a1469 1
		  p->relative_count = 0;
d1473 1
a1473 1
	      p->count += 1;
d1476 1
a1476 1
		p->relative_count += 1;
d1491 2
a1492 2
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
d1495 1
a1495 1
  if (h != NULL)
d1497 1
a1497 1
      switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
d1504 1
a1504 1
	  switch (h->root.type)
d1508 1
a1508 1
	      return h->root.u.def.section;
d1511 1
a1511 1
	      return h->root.u.c.p->section;
d1534 1
a1534 1
  struct elf_link_hash_entry **sym_hashes;
d1537 1
a1537 1
  const Elf_Internal_Rela *rel, *relend;
d1542 1
a1542 1
  sym_hashes = elf_sym_hashes (abfd);
d1549 1
a1549 1
  for (rel = relocs; rel < relend; rel++)
d1553 1
a1553 1
      struct elf_link_hash_entry *h = NULL;
d1555 1
a1555 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d1558 9
a1566 9
	  struct elf32_hppa_link_hash_entry *eh;
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct elf32_hppa_link_hash_entry *) h;
d1568 2
a1569 2
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
d1572 1
a1572 1
		*pp = p->next;
d1577 1
a1577 1
      r_type = ELF32_R_TYPE (rel->r_info);
d1583 1
a1583 1
	  if (h != NULL)
d1585 2
a1586 2
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
d1599 1
a1599 1
	  if (h != NULL)
d1601 2
a1602 2
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
d1609 1
a1609 1
	  if (h != NULL)
d1611 2
a1612 2
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
d1695 1
a1695 1
			struct elf_link_hash_entry *h,
d1700 2
a1701 2
      h->forced_local = 1;
      if (h->dynindx != -1)
d1703 1
a1703 1
	  h->dynindx = -1;
d1705 1
a1705 1
				  h->dynstr_index);
d1709 1
a1709 1
  if (! ((struct elf32_hppa_link_hash_entry *) h)->plabel)
d1711 2
a1712 2
      h->needs_plt = 0;
      h->plt = elf_hash_table (info)->init_plt_refcount;
d1724 1
a1724 1
				  struct elf_link_hash_entry *h)
d1727 1
a1727 1
  asection *s;
d1732 2
a1733 2
  if (h->type == STT_FUNC
      || h->needs_plt)
d1735 4
a1738 4
      if (h->plt.refcount <= 0
	  || (h->def_regular
	      && h->root.type != bfd_link_hash_defweak
	      && ! ((struct elf32_hppa_link_hash_entry *) h)->plabel
d1749 2
a1750 2
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
d1756 1
a1756 1
    h->plt.offset = (bfd_vma) -1;
d1761 1
a1761 1
  if (h->u.weakdef != NULL)
d1763 2
a1764 2
      if (h->u.weakdef->root.type != bfd_link_hash_defined
	  && h->u.weakdef->root.type != bfd_link_hash_defweak)
d1766 2
a1767 2
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1769 1
a1769 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d1785 1
a1785 1
  if (!h->non_got_ref)
d1790 2
a1791 2
      struct elf32_hppa_link_hash_entry *eh;
      struct elf32_hppa_dyn_reloc_entry *p;
d1793 2
a1794 2
      eh = (struct elf32_hppa_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1796 2
a1797 2
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
d1803 1
a1803 1
      if (p == NULL)
d1805 1
a1805 1
	  h->non_got_ref = 0;
d1825 1
a1825 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
d1828 1
a1828 1
      h->needs_copy = 1;
d1834 1
a1834 1
  power_of_two = bfd_log2 (h->size);
d1839 3
a1841 3
  s = htab->sdynbss;
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
d1843 1
a1843 1
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
d1848 2
a1849 2
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;
d1852 1
a1852 1
  s->size += h->size;
d1861 1
a1861 1
allocate_plt_static (struct elf_link_hash_entry *h, void *inf)
d1865 2
a1866 1
  asection *s;
d1868 1
a1868 1
  if (h->root.type == bfd_link_hash_indirect)
d1871 2
a1872 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1874 2
a1875 1
  info = inf;
d1878 1
a1878 1
      && h->plt.refcount > 0)
d1882 3
a1884 3
      if (h->dynindx == -1
	  && !h->forced_local
	  && h->type != STT_PARISC_MILLI)
d1886 1
a1886 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1890 1
a1890 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d1896 2
a1897 1
	  ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
d1899 1
a1899 1
      else if (((struct elf32_hppa_link_hash_entry *) h)->plabel)
d1903 3
a1905 3
	  s = htab->splt;
	  h->plt.offset = s->size;
	  s->size += PLT_ENTRY_SIZE;
d1910 2
a1911 2
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
d1916 2
a1917 2
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
d1927 1
a1927 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d1931 3
a1933 3
  asection *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;
d1935 1
a1935 1
  if (h->root.type == bfd_link_hash_indirect)
d1938 2
a1939 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1943 2
d1946 3
a1948 2
      && h->plt.offset != (bfd_vma) -1
      && !((struct elf32_hppa_link_hash_entry *) h)->plabel)
d1951 3
a1953 3
      s = htab->splt;
      h->plt.offset = s->size;
      s->size += PLT_ENTRY_SIZE;
d1960 1
a1960 1
  if (h->got.refcount > 0)
d1964 3
a1966 3
      if (h->dynindx == -1
	  && !h->forced_local
	  && h->type != STT_PARISC_MILLI)
d1968 1
a1968 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1972 3
a1974 3
      s = htab->sgot;
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
d1977 2
a1978 2
	      || (h->dynindx != -1
		  && !h->forced_local)))
d1984 1
a1984 1
    h->got.offset = (bfd_vma) -1;
d1986 1
a1986 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
d1997 1
a1997 1
      if (SYMBOL_CALLS_LOCAL (info, h))
d1999 1
a1999 1
	  struct elf32_hppa_dyn_reloc_entry **pp;
d2001 1
a2001 1
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
d2003 4
a2006 4
	      p->count -= p->relative_count;
	      p->relative_count = 0;
	      if (p->count == 0)
		*pp = p->next;
d2008 1
a2008 1
		pp = &p->next;
d2015 3
a2017 3
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d2024 2
a2025 1
      if (!h->non_got_ref
d2027 5
a2031 5
	       && h->def_dynamic
	       && !h->def_regular)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
d2035 3
a2037 3
	  if (h->dynindx == -1
	      && !h->forced_local
	      && h->type != STT_PARISC_MILLI)
d2039 1
a2039 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2045 1
a2045 1
	  if (h->dynindx != -1)
d2049 1
a2049 1
      eh->dyn_relocs = NULL;
d2056 1
a2056 1
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d2058 2
a2059 2
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d2073 1
a2073 1
clobber_millicode_symbols (struct elf_link_hash_entry *h,
d2076 2
a2077 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2079 2
a2080 2
  if (h->type == STT_PARISC_MILLI
      && !h->forced_local)
d2082 1
a2082 1
      elf32_hppa_hide_symbol (info, h, TRUE);
d2090 1
a2090 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2092 2
a2093 2
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;
d2095 2
a2096 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2098 2
a2099 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d2101 1
a2101 1
      asection *s = p->sec->output_section;
d2103 1
a2103 1
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
d2125 1
a2125 1
  asection *s;
d2138 2
a2139 2
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  if (s == NULL)
d2141 2
a2142 2
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d2166 1
a2166 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d2168 1
a2168 1
	  struct elf32_hppa_dyn_reloc_entry *p;
d2170 4
a2173 4
	  for (p = ((struct elf32_hppa_dyn_reloc_entry *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d2175 2
a2176 2
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
d2183 1
a2183 1
	      else if (p->count != 0)
d2185 3
a2187 3
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
d2200 1
a2200 1
      s = htab->sgot;
d2206 3
a2208 3
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
	      if (info->shared)
d2225 1
a2225 1
	  s = htab->splt;
d2231 2
a2232 2
		  *local_plt = s->size;
		  s->size += PLT_ENTRY_SIZE;
d2255 1
a2255 1
  for (s = dynobj->sections; s != NULL; s = s->next)
d2257 1
a2257 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d2260 1
a2260 1
      if (s == htab->splt)
d2268 1
a2268 1
	      int pltalign = bfd_section_alignment (dynobj, s);
d2272 1
a2272 1
		bfd_set_section_alignment (dynobj, s, gotalign);
d2274 1
a2274 1
	      s->size = (s->size + sizeof (plt_stub) + mask) & ~mask;
d2277 1
a2277 1
      else if (s == htab->sgot)
d2279 1
a2279 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d2281 1
a2281 1
	  if (s->size != 0)
d2285 1
a2285 1
	      if (s != htab->srelplt)
d2290 1
a2290 1
	      s->reloc_count = 0;
d2299 1
a2299 1
      if (s->size == 0)
d2310 1
a2310 1
	  s->flags |= SEC_EXCLUDE;
d2316 2
a2317 2
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d2607 2
a2608 2
	  struct elf_link_hash_entry **sym_hashes;
	  struct elf_link_hash_entry **end_hashes;
d2613 2
a2614 2
	  sym_hashes = elf_sym_hashes (input_bfd);
	  end_hashes = sym_hashes + symcount;
d2618 1
a2618 1
	  for (; sym_hashes < end_hashes; sym_hashes++)
d2620 1
a2620 1
	      struct elf32_hppa_link_hash_entry *hash;
d2622 1
a2622 1
	      hash = (struct elf32_hppa_link_hash_entry *) *sym_hashes;
d2624 3
a2626 4
	      while (hash->elf.root.type == bfd_link_hash_indirect
		     || hash->elf.root.type == bfd_link_hash_warning)
		hash = ((struct elf32_hppa_link_hash_entry *)
			hash->elf.root.u.i.link);
d2631 5
a2635 5
	      if ((hash->elf.root.type == bfd_link_hash_defined
		   || hash->elf.root.type == bfd_link_hash_defweak)
		  && hash->elf.type == STT_FUNC
		  && hash->elf.root.u.def.section->output_section != NULL
		  && (hash->elf.root.u.def.section->output_section->owner
d2637 4
a2640 4
		  && hash->elf.root.u.def.section->owner == input_bfd
		  && hash->elf.def_regular
		  && !hash->elf.forced_local
		  && ELF_ST_VISIBILITY (hash->elf.other) == STV_DEFAULT)
d2644 1
a2644 1
		  struct elf32_hppa_stub_hash_entry *stub_entry;
d2646 3
a2648 3
		  sec = hash->elf.root.u.def.section;
		  stub_name = hash->elf.root.root.string;
		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
d2651 1
a2651 1
		  if (stub_entry == NULL)
d2653 2
a2654 2
		      stub_entry = hppa_add_stub (stub_name, sec, htab);
		      if (!stub_entry)
d2657 4
a2660 4
		      stub_entry->target_value = hash->elf.root.u.def.value;
		      stub_entry->target_section = hash->elf.root.u.def.section;
		      stub_entry->stub_type = hppa_stub_export;
		      stub_entry->h = hash;
d2798 1
a2798 1
		  struct elf32_hppa_stub_hash_entry *stub_entry;
d2802 1
a2802 1
		  struct elf32_hppa_link_hash_entry *hash;
d2829 1
a2829 1
		  hash = NULL;
d2851 1
a2851 2
		      hash = ((struct elf32_hppa_link_hash_entry *)
			      elf_sym_hashes (input_bfd)[e_indx]);
d2853 3
a2855 4
		      while (hash->elf.root.type == bfd_link_hash_indirect
			     || hash->elf.root.type == bfd_link_hash_warning)
			hash = ((struct elf32_hppa_link_hash_entry *)
				hash->elf.root.u.i.link);
d2857 2
a2858 2
		      if (hash->elf.root.type == bfd_link_hash_defined
			  || hash->elf.root.type == bfd_link_hash_defweak)
d2860 2
a2861 2
			  sym_sec = hash->elf.root.u.def.section;
			  sym_value = hash->elf.root.u.def.value;
d2867 1
a2867 1
		      else if (hash->elf.root.type == bfd_link_hash_undefweak)
d2872 1
a2872 1
		      else if (hash->elf.root.type == bfd_link_hash_undefined)
d2875 1
a2875 1
				 && (ELF_ST_VISIBILITY (hash->elf.other)
d2877 1
a2877 1
				 && hash->elf.type != STT_PARISC_MILLI))
d2888 1
a2888 1
		  stub_type = hppa_type_of_stub (section, irela, hash,
d2897 1
a2897 1
		  stub_name = hppa_stub_name (id_sec, sym_sec, hash, irela);
d2901 1
a2901 1
		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
d2904 1
a2904 1
		  if (stub_entry != NULL)
d2911 2
a2912 2
		  stub_entry = hppa_add_stub (stub_name, section, htab);
		  if (stub_entry == NULL)
d2918 3
a2920 3
		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = sym_sec;
		  stub_entry->stub_type = stub_type;
d2924 1
a2924 1
			stub_entry->stub_type = hppa_stub_import_shared;
d2926 1
a2926 1
			stub_entry->stub_type = hppa_stub_long_branch_shared;
d2928 1
a2928 1
		  stub_entry->h = hash;
d3104 1
a3104 1
  htab = (struct elf32_hppa_link_hash_table *) data;
d3128 1
a3128 1
		     const Elf_Internal_Rela *rel,
d3132 1
a3132 1
		     struct elf32_hppa_link_hash_entry *h,
d3136 1
a3136 1
  unsigned int r_type = ELF32_R_TYPE (rel->r_info);
d3142 1
a3142 1
  bfd_vma offset = rel->r_offset;
d3145 1
a3145 1
  bfd_signed_vma addend = rel->r_addend;
d3147 2
a3148 2
  struct elf32_hppa_stub_hash_entry *stub_entry = NULL;
  int val;
d3189 4
a3192 4
	  || (h != NULL
	      && h->elf.plt.offset != (bfd_vma) -1
	      && h->elf.dynindx != -1
	      && !h->plabel
d3194 2
a3195 2
		  || !h->elf.def_regular
		  || h->elf.root.type == bfd_link_hash_defweak)))
d3197 3
a3199 3
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, htab);
	  if (stub_entry != NULL)
d3201 3
a3203 3
	      value = (stub_entry->stub_offset
		       + stub_entry->stub_sec->output_offset
		       + stub_entry->stub_sec->output_section->vma);
d3206 2
a3207 2
	  else if (sym_sec == NULL && h != NULL
		   && h->elf.root.type == bfd_link_hash_undefweak)
d3257 1
a3257 1
	       (long) rel->r_offset,
d3374 3
a3376 3
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, htab);
	  if (stub_entry == NULL)
d3381 3
a3383 3
	  value = (stub_entry->stub_offset
		   + stub_entry->stub_sec->output_offset
		   + stub_entry->stub_sec->output_section->vma
d3402 2
a3403 2
	 (long) rel->r_offset,
	 stub_entry->root.string);
d3452 1
a3452 1
  Elf_Internal_Rela *rel;
d3463 1
a3463 1
  rel = relocs;
d3465 1
a3465 1
  for (; rel < relend; rel++)
d3470 1
a3470 1
      struct elf32_hppa_link_hash_entry *h;
d3474 1
a3474 1
      bfd_reloc_status_type r;
d3479 1
a3479 1
      r_type = ELF32_R_TYPE (rel->r_info);
d3490 2
a3491 2
      r_symndx = ELF32_R_SYM (rel->r_info);
      h = NULL;
d3500 1
a3500 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
d3504 1
a3504 1
	  struct elf_link_hash_entry *hh;
d3508 1
a3508 1
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
d3510 1
a3510 1
				   hh, sym_sec, relocation,
d3514 3
a3516 3
	      && hh->root.type != bfd_link_hash_defined
	      && hh->root.type != bfd_link_hash_defweak
	      && hh->root.type != bfd_link_hash_undefweak)
d3519 2
a3520 2
		  && ELF_ST_VISIBILITY (hh->other) == STV_DEFAULT
		  && hh->type == STT_PARISC_MILLI)
d3523 2
a3524 2
		      (info, hh->root.root.string, input_bfd,
		       input_section, rel->r_offset, FALSE))
d3529 1
a3529 1
	  h = (struct elf32_hppa_link_hash_entry *) hh;
d3547 1
a3547 1
	    if (h != NULL)
d3551 1
a3551 1
		off = h->elf.got.offset;
d3554 1
a3554 1
						       &h->elf))
d3566 1
a3566 1
			h->elf.got.offset |= 1;
d3600 1
a3600 1
		    asection *s = htab->srelgot;
d3607 2
a3608 2
		    loc = s->contents;
		    loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
a3639 1

d3642 1
a3642 1
	      if (h != NULL)
d3644 1
a3644 1
		  off = h->elf.plt.offset;
d3646 1
a3646 1
							 &h->elf))
d3655 1
a3655 1
			  h->elf.plt.offset |= 1;
d3721 3
a3723 3
	      if (h == NULL
		  || (h->elf.root.type != bfd_link_hash_undefweak
		      && h->elf.root.type != bfd_link_hash_undefined))
d3763 3
a3765 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
d3767 1
a3767 1
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
d3769 3
a3771 3
		  && h != NULL
		  && h->elf.dynindx != -1
		  && !h->elf.non_got_ref
d3773 4
a3776 4
		       && h->elf.def_dynamic
		       && !h->elf.def_regular)
		      || h->elf.root.type == bfd_link_hash_undefweak
		      || h->elf.root.type == bfd_link_hash_undefined)))
d3787 1
a3787 1
	      outrel.r_addend = rel->r_addend;
d3790 1
a3790 1
					 rel->r_offset);
d3795 1
a3795 1

d3800 2
a3801 2
	      else if (h != NULL
		       && h->elf.dynindx != -1
d3806 1
a3806 1
			   || !h->elf.def_regular))
d3808 1
a3808 1
		  outrel.r_info = ELF32_R_INFO (h->elf.dynindx, r_type);
d3857 2
a3858 2
      r = final_link_relocate (input_section, contents, rel, relocation,
			       htab, sym_sec, h, info);
d3860 1
a3860 1
      if (r == bfd_reloc_ok)
d3863 2
a3864 2
      if (h != NULL)
	sym_name = h->elf.root.root.string;
d3878 1
a3878 1
      if (r == bfd_reloc_undefined || r == bfd_reloc_notsupported)
d3880 1
a3880 1
	  if (r == bfd_reloc_notsupported || !warned_undef)
d3886 1
a3886 1
		 (long) rel->r_offset,
d3896 2
a3897 2
		(info, (h ? &h->elf.root : NULL), sym_name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
d3911 1
a3911 1
				  struct elf_link_hash_entry *h,
d3915 1
a3915 1
  Elf_Internal_Rela rel;
d3920 1
a3920 1
  if (h->plt.offset != (bfd_vma) -1)
d3924 1
a3924 1
      if (h->plt.offset & 1)
d3935 2
a3936 2
      if (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
d3938 4
a3941 4
	  value = h->root.u.def.value;
	  if (h->root.u.def.section->output_section != NULL)
	    value += (h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
d3945 1
a3945 1
      rel.r_offset = (h->plt.offset
d3948 1
a3948 1
      if (h->dynindx != -1)
d3950 2
a3951 2
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
d3957 2
a3958 2
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rel.r_addend = value;
d3963 1
a3963 1
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rel, loc);
d3965 1
a3965 1
      if (!h->def_regular)
d3973 1
a3973 1
  if (h->got.offset != (bfd_vma) -1)
d3978 1
a3978 1
      rel.r_offset = ((h->got.offset &~ (bfd_vma) 1)
d3988 2
a3989 2
	  && (info->symbolic || h->dynindx == -1)
	  && h->def_regular)
d3991 4
a3994 4
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
	  rel.r_addend = (h->root.u.def.value
			  + h->root.u.def.section->output_offset
			  + h->root.u.def.section->output_section->vma);
d3998 1
a3998 1
	  if ((h->got.offset & 1) != 0)
d4000 4
a4003 3
	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_DIR32);
	  rel.r_addend = 0;
d4008 1
a4008 1
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
d4011 1
a4011 1
  if (h->needs_copy)
d4013 1
a4013 1
      asection *s;
d4017 3
a4019 3
      if (! (h->dynindx != -1
	     && (h->root.type == bfd_link_hash_defined
		 || h->root.type == bfd_link_hash_defweak)))
d4022 1
a4022 1
      s = htab->srelbss;
d4024 7
a4030 7
      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
      rel.r_addend = 0;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_COPY);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
d4034 3
a4036 3
  if (h->root.root.string[0] == '_'
      && (strcmp (h->root.root.string, "_DYNAMIC") == 0
	  || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0))
@


1.132
log
@	* elf-bfd.h (struct elf_link_hash_table): Delete init_refcount and
	init_offset.  Add init_got_refcount, init_plt_refcount,
	init_got_offset and init_plt_offset.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust for above change.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	(_bfd_elf_link_hash_table_init): Likewise.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (GLINK_PLTRESOLVE): Now 16 insns.
	(LWZU_0_X_12, LWZ_0_4_30, LWZ_0_X_12, LWZ_11_X_11, LWZ_11_X_30,
	LWZ_12_4_12, LWZ_12_8_30, LWZ_12_X_12, SUB_11_11_30): Delete.
	(ADDIS_12_12, BCL_20_31, LWZU_0_12, LWZ_0_12, LWZ_11_11, LWZ_11_30,
	LWZ_12_12, MFLR_0, MFLR_12, MTLR_0, SUB_11_11_12): Define.
	(struct plt_entry): New.
	(ppc_elf_link_hash_table_create): Set new init_plt fields.
	(ppc_elf_copy_indirect_symbol): Handle merge of plt plist.  Don't
	use _bfd_elf_link_hash_copy_indirect.
	(update_plt_info, find_plt_ent): New functions.
	(ppc_elf_check_relocs): Handle R_PPC_PLTREL24 with non-zero addend
	and adjust for use of plt list rather than refcount.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_tls_optimize): Likewise.
	(ppc_elf_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.  Adjust R_PPC_PLTREL24 addends
	when performing a relocatable link.
	(ppc_elf_finish_dynamic_symbol): Likewise.  Write .glink stubs here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Use new
	pic resolver stub.
@
text
@d1088 2
a1089 1
	h = ((struct elf32_hppa_link_hash_entry *)
d1091 4
@


1.131
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d1681 1
a1681 1
      h->plt = elf_hash_table (info)->init_refcount;
@


1.130
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d955 7
a961 1
  htab->srelgot = bfd_make_section (abfd, ".rela.got");
a962 7
      || ! bfd_set_section_flags (abfd, htab->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
a1389 1
		      sreloc = bfd_make_section (dynobj, name);
d1394 3
a1397 1
			  || !bfd_set_section_flags (dynobj, sreloc, flags)
@


1.129
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d25 1
a25 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.128
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2273 1
a2273 1
	  _bfd_strip_section_from_output (info, s);
d2379 1
a2379 1
     _bfd_strip_section_from_output doesn't renumber the indices.  */
@


1.127
log
@	PR ld/778
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Reinstate
	_GLOBAL_OFFSET_TABLE_ as a normal dynamic symbol.
@
text
@d25 1
a25 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.126
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d940 1
d970 6
a975 1
  return TRUE;
d1845 1
a1845 1
	   && h->plt.refcount > 0)
@


1.125
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@a1188 14
#if 0
	  /* Help debug shared library creation.  Any of the above
	     relocs can be used in shared libs, but they may cause
	     pages to become unshared.  */
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation %s should not be used when making a shared object; recompile with -fPIC"),
		 abfd,
		 elf_hppa_howto_table[r_type].name);
	    }
	  /* Fall through.  */
#endif

a3241 8
#if 0 /* debug them.  */
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): fixing %s"),
		 input_bfd,
		 input_section,
		 (long) rel->r_offset,
		 howto->name);
#endif
a3803 7
#if 0
	      /* EH info can cause unaligned DIR32 relocs.
		 Tweak the reloc type for the dynamic linker.  */
	      if (r_type == R_PARISC_DIR32 && (outrel.r_offset & 3) != 0)
		outrel.r_info = ELF32_R_INFO (ELF32_R_SYM (outrel.r_info),
					      R_PARISC_DIR32U);
#endif
@


1.124
log
@	* elf32-hppa.c (elf32_hppa_grok_prstatus): New function.
	(elf32_hppa_grok_psinfo): New function.
	(elf_backend_grok_prstatus): Define.
	(elf_backend_grok_psinfo): Define.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d1540 3
@


1.123
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d1603 61
d4229 2
@


1.122
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d3822 2
a3823 2
		(info, sym_name, howto->name, 0, input_bfd, input_section,
		 rel->r_offset)))
@


1.121
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1674 1
a1674 1
  if (h->weakdef != NULL)
d1676 2
a1677 2
      if (h->weakdef->root.type != bfd_link_hash_defined
	  && h->weakdef->root.type != bfd_link_hash_defweak)
d1679 2
a1680 2
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d1682 1
a1682 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.120
log
@	PR 293
	* elf32-hppa.c (elf32_hppa_hide_symbol): Use init_refcount to
	zero the plt field.
@
text
@d573 1
a573 1
	  || !(hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d1022 10
a1031 9
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d1282 1
a1282 1
		  h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1323 1
a1323 1
	    h->elf.elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d1359 1
a1359 2
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1365 1
a1365 2
		      || (h->elf.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d1613 1
a1613 1
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
d1624 1
a1624 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1646 1
a1646 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1649 1
a1649 1
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
d1663 1
a1663 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1682 1
a1682 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1698 1
a1698 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d1718 1
a1718 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1741 1
a1741 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1794 1
a1794 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
d1821 1
a1821 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1827 1
a1827 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1872 1
a1872 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
d1885 1
a1885 1
		  && h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
d1932 1
a1932 1
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
d1934 2
a1935 2
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1943 1
a1943 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
d1987 1
a1987 1
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2546 2
a2547 2
		  && (hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  && !(hash->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d3104 1
a3104 1
		  || !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d3690 1
a3690 1
		  && (h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
d3692 2
a3693 4
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3725 1
a3725 2
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d3891 1
a3891 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3915 1
a3915 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3936 1
a3936 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.119
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1626 1
a1626 1
      h->plt.offset = (bfd_vma) -1;
@


1.118
log
@bfd:
* config.bfd (hppa*-*-netbsd*): Set targ_defvec to
bfd_elf32_hppa_nbsd_vec.  Add bfd_elf32_hppa_linux_vec
to targ_selvecs.
* configure.in (bfd_elf32_hppa_nbsd_vec): Add case.
* configure: Regenerate.
* elf32-hppa.c (elf32_hppa_object_p): Add "elf32-hppa-netbsd"
case that accepts OSABI=NetBSD and OSABI=SysV.
(elf32_hppa_set_gp): For "elf32-hppa-netbsd", set the GP to
the base of .got or .data (if .got does not exist).
(elf32_hppa_post_process_headers): For elf32-hppa-netbsd,
set OSABI=NetBSD.
(TARGET_BIG_SYM): Add bfd_elf32_hppa_nbsd_vec case.
(TARGET_BIG_NAME): Add "elf32-hppa-netbsd" case.
* targets.c (bfd_elf32_hppa_nbsd_vec): Add extern declaration.
(_bfd_target_vector): Add bfd_elf32_hppa_nbsd_vec.

gas:
* config/tc-hppa.h (TARGET_FORMAT): Set to "elf32-hppa-netbsd"
for TE_NetBSD.

ld:
* emulparams/hppanbsd.sh (OUTPUT_FORMAT): Set to "elf32-hppa-netbsd".
@
text
@d542 2
a543 2
      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
			     bfd_archive_filename (section->owner),
d795 3
a797 3
	    (_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	     bfd_archive_filename (stub_entry->target_section->owner),
	     stub_sec->name,
d1175 2
a1176 2
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
d1195 2
a1196 2
		(_("%s: relocation %s should not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
d2576 2
a2577 2
		      (*_bfd_error_handler) (_("%s: duplicate export stub %s"),
					     bfd_archive_filename (input_bfd),
d3167 3
a3169 3
	      (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
d3197 3
a3199 3
		(_("%s(%s+0x%lx): fixing %s"),
		 bfd_archive_filename (input_bfd),
		 input_section->name,
d3320 3
a3322 3
	(_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	 bfd_archive_filename (input_bfd),
	 input_section->name,
d3815 3
a3817 3
		(_("%s(%s+0x%lx): cannot handle %s for %s"),
		 bfd_archive_filename (input_bfd),
		 input_section->name,
@


1.117
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d904 8
d2910 2
a2911 1
      sec = splt;
d2925 7
a2931 4
	      /* We know we don't have a .plt.  If .got is large,
		 offset our LTP.  */
	      if (sec->size > 0x2000)
		gp_val = 0x2000;
d4131 4
d4204 7
@


1.116
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d675 1
a675 1
  stub_entry->stub_offset = stub_sec->_raw_size;
d819 1
a819 1
      stub_entry->h->elf.root.u.def.value = stub_sec->_raw_size;
d829 1
a829 1
  stub_sec->_raw_size += size;
d882 1
a882 1
  stub_entry->stub_sec->_raw_size += size;
d1735 1
a1735 1
      htab->srelbss->_raw_size += sizeof (Elf32_External_Rela);
d1748 1
a1748 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d1757 1
a1757 1
  h->root.u.def.value = s->_raw_size;
d1760 1
a1760 1
  s->_raw_size += h->size;
d1809 2
a1810 2
	  h->plt.offset = s->_raw_size;
	  s->_raw_size += PLT_ENTRY_SIZE;
d1854 2
a1855 2
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;
d1858 1
a1858 1
      htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
d1875 2
a1876 2
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
d1882 1
a1882 1
	  htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d1961 1
a1961 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2043 1
a2043 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d2088 1
a2088 1
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2108 2
a2109 2
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
d2111 1
a2111 1
		srel->_raw_size += sizeof (Elf32_External_Rela);
d2133 2
a2134 2
		  *local_plt = s->_raw_size;
		  s->_raw_size += PLT_ENTRY_SIZE;
d2136 1
a2136 1
		    srel->_raw_size += sizeof (Elf32_External_Rela);
d2176 1
a2176 1
	      s->_raw_size = (s->_raw_size + sizeof (plt_stub) + mask) & ~mask;
d2183 1
a2183 1
	  if (s->_raw_size != 0)
d2201 1
a2201 1
      if (s->_raw_size == 0)
d2218 2
a2219 2
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d2246 1
a2246 1
      if (htab->srelplt->_raw_size != 0)
d2403 1
a2403 4
	  if (tail->_cooked_size)
	    total = tail->_cooked_size;
	  else
	    total = tail->_raw_size;
d2851 1
a2851 4
	{
	  stub_sec->_raw_size = 0;
	  stub_sec->_cooked_size = 0;
	}
d2905 2
a2906 2
	  gp_val = sec->_raw_size;
	  if (gp_val > 0x2000 || (sgot && sgot->_raw_size > 0x2000))
d2918 1
a2918 1
	      if (sec->_raw_size > 0x2000)
d2968 1
a2968 1
      size = stub_sec->_raw_size;
d2972 1
a2972 1
      stub_sec->_raw_size = 0;
d4006 1
a4006 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d4031 1
a4031 1
	      dyn.d_un.d_val = s->_raw_size;
d4040 1
a4040 1
	      dyn.d_un.d_val -= s->_raw_size;
d4052 1
a4052 1
	      dyn.d_un.d_ptr += s->_raw_size;
d4060 1
a4060 1
  if (htab->sgot != NULL && htab->sgot->_raw_size != 0)
d4076 1
a4076 1
  if (htab->splt != NULL && htab->splt->_raw_size != 0)
d4086 1
a4086 1
		  + htab->splt->_raw_size - sizeof (plt_stub),
d4091 1
a4091 1
	       + htab->splt->_raw_size)
@


1.115
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d1202 1
a1202 2
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec,
					       &h->elf, rel->r_offset))
d1209 1
a1209 2
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec,
					     &h->elf, rel->r_addend))
a1621 11
/* This is the condition under which elf32_hppa_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_hppa_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1793 1
a1793 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1797 1
a1797 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1871 1
a1871 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1942 1
a1942 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d2995 1
a2995 1
  if (!bfd_elf32_bfd_final_link (abfd, info))
d3469 2
a3470 1
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
d3562 2
a3563 1
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, &h->elf))
@


1.114
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d2244 1
a2244 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.113
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d3435 1
d3437 4
a3440 3
	  RELOC_FOR_GLOBAL_SYMBOL (hh, elf_sym_hashes (input_bfd), r_symndx, symtab_hdr,
				   relocation, sym_sec, unresolved_reloc, info,
				   warned_undef);
@


1.112
log
@	* elf32-hppa.c (elf32_hppa_check_relocs): Handle R_PARISC_PCREL32.
	(final_link_relocate): Likewise.
@
text
@d2796 1
a2796 2
			  if (! (info->shared
				 && info->unresolved_syms_in_objects == RM_IGNORE
d3445 1
a3445 2
	      if (!info->executable
		  && info->unresolved_syms_in_objects == RM_IGNORE
d3451 1
a3451 3
		       input_section, rel->r_offset,
		       ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
			|| (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR))))
@


1.111
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d1150 1
a1150 1
	case R_PARISC_SEGBASE: /* Used to set segment base.  */
d1156 1
d3149 1
d3243 1
@


1.111.6.1
log
@Merge from mainline
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d1201 2
a1202 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &h->elf, rel->r_offset))
d1209 2
a1210 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &h->elf, rel->r_addend))
d1623 11
d1805 1
a1805 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1809 1
a1809 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d1883 1
a1883 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1954 1
a1954 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2243 1
a2243 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2795 2
a2796 1
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
d3008 1
a3008 1
  if (!bfd_elf_final_link (abfd, info))
a3432 1
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
d3434 3
a3436 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sym_sec, relocation,
				   unresolved_reloc, warned_undef);
d3443 2
a3444 1
	      if (info->unresolved_syms_in_objects == RM_IGNORE
d3450 3
a3452 1
		       input_section, rel->r_offset, FALSE))
d3481 1
a3481 2
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
						       &h->elf))
d3573 1
a3573 2
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared,
							 &h->elf))
@


1.111.6.2
log
@Merge to 2.15 branch.
@
text
@d1150 1
a1150 1
	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
a1155 1
	case R_PARISC_PCREL32:
a3133 1
    case R_PARISC_PCREL32:
a3226 1
    case R_PARISC_PCREL32:
@


1.111.6.3
log
@bfd:
* config.bfd (hppa*-*-netbsd*): Set targ_defvec to
bfd_elf32_hppa_nbsd_vec.  Add bfd_elf32_hppa_linux_vec
to targ_selvecs.
* configure.in (bfd_elf32_hppa_nbsd_vec): Add case.
* configure: Regenerate.
* elf32-hppa.c (elf32_hppa_object_p): Add "elf32-hppa-netbsd"
case that accepts OSABI=NetBSD and OSABI=SysV.
(elf32_hppa_set_gp): For "elf32-hppa-netbsd", set the GP to
the base of .got or .data (if .got does not exist).
(elf32_hppa_post_process_headers): For elf32-hppa-netbsd,
set OSABI=NetBSD.
(TARGET_BIG_SYM): Add bfd_elf32_hppa_nbsd_vec case.
(TARGET_BIG_NAME): Add "elf32-hppa-netbsd" case.
* targets.c (bfd_elf32_hppa_nbsd_vec): Add extern declaration.
(_bfd_target_vector): Add bfd_elf32_hppa_nbsd_vec.

gas:
* config/tc-hppa.h (TARGET_FORMAT): Set to "elf32-hppa-netbsd"
for TE_NetBSD.

ld:
* emulparams/hppanbsd.sh (OUTPUT_FORMAT): Set to "elf32-hppa-netbsd".
@
text
@a903 8
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      /* GCC on hppa-netbsd produces binaries with OSABI=NetBSD,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NETBSD &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
d2909 1
a2909 2
      sec = strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0
	  ? NULL : splt;
d2923 4
a2926 7
	      if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") != 0)
		{
	          /* We know we don't have a .plt.  If .got is large,
		     offset our LTP.  */
	          if (sec->_raw_size > 0x2000)
		    gp_val = 0x2000;
		}
a4125 4
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NETBSD;
    }
a4194 7

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf32_hppa_nbsd_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf32-hppa-netbsd"

#include "elf32-target.h"
@


1.111.8.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d1150 1
a1150 1
	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
a1155 1
	case R_PARISC_PCREL32:
d2243 1
a2243 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2795 2
a2796 1
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
a3147 1
    case R_PARISC_PCREL32:
a3240 1
    case R_PARISC_PCREL32:
a3432 1
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
d3434 3
a3436 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sym_sec, relocation,
				   unresolved_reloc, warned_undef);
d3443 2
a3444 1
	      if (info->unresolved_syms_in_objects == RM_IGNORE
d3450 3
a3452 1
		       input_section, rel->r_offset, FALSE))
@


1.111.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1202 2
a1203 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &h->elf, rel->r_offset))
d1210 2
a1211 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &h->elf, rel->r_addend))
d1624 11
d1806 1
a1806 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1810 1
a1810 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d1884 1
a1884 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1955 1
a1955 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3008 1
a3008 1
  if (!bfd_elf_final_link (abfd, info))
d3482 1
a3482 2
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
						       &h->elf))
d3574 1
a3574 2
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared,
							 &h->elf))
@


1.111.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d542 2
a543 2
      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
			     section->owner,
d675 1
a675 1
  stub_entry->stub_offset = stub_sec->size;
d795 3
a797 3
	    (_("%B(%A+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	     stub_entry->target_section->owner,
	     stub_sec,
d819 1
a819 1
      stub_entry->h->elf.root.u.def.value = stub_sec->size;
d829 1
a829 1
  stub_sec->size += size;
d882 1
a882 1
  stub_entry->stub_sec->size += size;
a903 8
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      /* GCC on hppa-netbsd produces binaries with OSABI=NetBSD,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NETBSD &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
d1167 2
a1168 2
		(_("%B: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 abfd,
d1187 2
a1188 2
		(_("%B: relocation %s should not be used when making a shared object; recompile with -fPIC"),
		 abfd,
d1618 1
a1618 1
      h->plt = elf_hash_table (info)->init_refcount;
d1735 1
a1735 1
      htab->srelbss->size += sizeof (Elf32_External_Rela);
d1748 2
a1749 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1758 1
a1758 1
  h->root.u.def.value = s->size;
d1761 1
a1761 1
  s->size += h->size;
d1810 2
a1811 2
	  h->plt.offset = s->size;
	  s->size += PLT_ENTRY_SIZE;
d1855 2
a1856 2
      h->plt.offset = s->size;
      s->size += PLT_ENTRY_SIZE;
d1859 1
a1859 1
      htab->srelplt->size += sizeof (Elf32_External_Rela);
d1876 2
a1877 2
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
d1883 1
a1883 1
	  htab->srelgot->size += sizeof (Elf32_External_Rela);
d1962 1
a1962 1
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d2044 1
a2044 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d2089 1
a2089 1
		  srel->size += p->count * sizeof (Elf32_External_Rela);
d2109 2
a2110 2
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
d2112 1
a2112 1
		srel->size += sizeof (Elf32_External_Rela);
d2134 2
a2135 2
		  *local_plt = s->size;
		  s->size += PLT_ENTRY_SIZE;
d2137 1
a2137 1
		    srel->size += sizeof (Elf32_External_Rela);
d2177 1
a2177 1
	      s->size = (s->size + sizeof (plt_stub) + mask) & ~mask;
d2184 1
a2184 1
	  if (s->size != 0)
d2202 1
a2202 1
      if (s->size == 0)
d2219 2
a2220 2
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d2247 1
a2247 1
      if (htab->srelplt->size != 0)
d2404 4
a2407 1
	  total = tail->size;
d2572 2
a2573 2
		      (*_bfd_error_handler) (_("%B: duplicate export stub %s"),
					     input_bfd,
d2855 4
a2858 1
	stub_sec->size = 0;
d2909 1
a2909 2
      sec = strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0
	  ? NULL : splt;
d2912 2
a2913 2
	  gp_val = sec->size;
	  if (gp_val > 0x2000 || (sgot && sgot->size > 0x2000))
d2923 4
a2926 7
	      if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") != 0)
		{
	          /* We know we don't have a .plt.  If .got is large,
		     offset our LTP.  */
	          if (sec->size > 0x2000)
		    gp_val = 0x2000;
		}
d2975 1
a2975 1
      size = stub_sec->size;
d2979 1
a2979 1
      stub_sec->size = 0;
d3162 3
a3164 3
	      (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       input_bfd,
	       input_section,
d3192 3
a3194 3
		(_("%B(%A+0x%lx): fixing %s"),
		 input_bfd,
		 input_section,
d3315 3
a3317 3
	(_("%B(%A+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	 input_bfd,
	 input_section,
d3810 3
a3812 3
		(_("%B(%A+0x%lx): cannot handle %s for %s"),
		 input_bfd,
		 input_section,
d4013 1
a4013 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d4038 1
a4038 1
	      dyn.d_un.d_val = s->size;
d4047 1
a4047 1
	      dyn.d_un.d_val -= s->size;
d4059 1
a4059 1
	      dyn.d_un.d_ptr += s->size;
d4067 1
a4067 1
  if (htab->sgot != NULL && htab->sgot->size != 0)
d4083 1
a4083 1
  if (htab->splt != NULL && htab->splt->size != 0)
d4093 1
a4093 1
		  + htab->splt->size - sizeof (plt_stub),
d4098 1
a4098 1
	       + htab->splt->size)
a4125 4
  else if (strcmp (bfd_get_target (abfd), "elf32-hppa-netbsd") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NETBSD;
    }
a4194 7

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf32_hppa_nbsd_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf32-hppa-netbsd"

#include "elf32-target.h"
@


1.111.8.4
log
@Merge from mainline.
@
text
@d573 1
a573 1
	  || !hash->elf.def_regular
d1022 9
a1030 10
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
d1281 1
a1281 1
		  h->elf.needs_plt = 1;
d1322 1
a1322 1
	    h->elf.non_got_ref = 1;
d1358 2
a1359 1
			   || !h->elf.def_regular))))
d1365 2
a1366 1
		      || !h->elf.def_regular)))
d1614 1
a1614 1
      h->forced_local = 1;
d1625 1
a1625 1
      h->needs_plt = 0;
d1647 1
a1647 1
      || h->needs_plt)
d1650 1
a1650 1
	  || (h->def_regular
d1664 1
a1664 1
	  h->needs_plt = 0;
d1675 1
a1675 1
  if (h->u.weakdef != NULL)
d1677 2
a1678 2
      if (h->u.weakdef->root.type != bfd_link_hash_defined
	  && h->u.weakdef->root.type != bfd_link_hash_defweak)
d1680 2
a1681 2
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1683 3
a1685 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d1701 1
a1701 1
  if (!h->non_got_ref)
d1721 1
a1721 1
	  h->non_got_ref = 0;
d1744 1
a1744 1
      h->needs_copy = 1;
d1797 1
a1797 1
	  && !h->forced_local
d1824 1
a1824 1
	  h->needs_plt = 0;
d1830 1
a1830 1
      h->needs_plt = 0;
d1875 1
a1875 1
	  && !h->forced_local
d1888 1
a1888 1
		  && !h->forced_local)))
d1935 1
a1935 1
      if (!h->non_got_ref
d1937 2
a1938 2
	       && h->def_dynamic
	       && !h->def_regular)
d1946 1
a1946 1
	      && !h->forced_local
d1990 1
a1990 1
      && !h->forced_local)
d2549 2
a2550 2
		  && hash->elf.def_regular
		  && !hash->elf.forced_local
d3107 1
a3107 1
		  || !h->elf.def_regular
d3693 1
a3693 1
		  && !h->elf.non_got_ref
d3695 4
a3698 2
		       && h->elf.def_dynamic
		       && !h->elf.def_regular)
d3730 2
a3731 1
			   || !h->elf.def_regular))
d3897 1
a3897 1
      if (!h->def_regular)
d3921 1
a3921 1
	  && h->def_regular)
d3942 1
a3942 1
  if (h->needs_copy)
@


1.111.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1150 1
a1150 1
	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
a1155 1
	case R_PARISC_PCREL32:
d2795 2
a2796 1
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
a3147 1
    case R_PARISC_PCREL32:
a3240 1
    case R_PARISC_PCREL32:
d3443 2
a3444 1
	      if (info->unresolved_syms_in_objects == RM_IGNORE
d3450 3
a3452 1
		       input_section, rel->r_offset, FALSE))
@


1.110
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@a2307 3
  if (htab->elf.root.creator->flavour != bfd_target_elf_flavour)
    return 0;

d2911 2
a2912 15
      asection *splt;
      asection *sgot;

      if (htab->elf.root.creator->flavour == bfd_target_elf_flavour)
	{
	  splt = htab->splt;
	  sgot = htab->sgot;
	}
      else
	{
	  /* If we're not elf, look up the output sections in the
	     hope we may actually find them.  */
	  splt = bfd_get_section_by_name (abfd, ".plt");
	  sgot = bfd_get_section_by_name (abfd, ".got");
	}
@


1.109
log
@Fix decision about when a .interp section should exist
@
text
@d1021 2
a1022 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.108
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d2050 1
a2050 1
      if (! info->shared)
@


1.107
log
@	* elf32-hppa.c (ELIMINATE_COPY_RELOCS): Define.
	(elf32_hppa_copy_indirect_symbol): Don't copy NON_GOT_REF on
	weakdefs.
	(elf32_hppa_check_relocs): Use ELIMINATE_COPY_RELOCS.
	(elf32_hppa_adjust_dynamic_symbol): Likewise.  Copy weakdef
	NON_GOT_REF.
	(allocate_dynrelocs): Use ELIMINATE_COPY_RELOCS and
	SYMBOL_CALLS_LOCAL.  Discard relocs for undef weak syms with
	non-default visibility.
	(elf32_hppa_relocate_section): Use ELIMINATE_COPY_RELOCS and
	SYMBOL_CALLS_LOCAL.
@
text
@d3442 1
a3442 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
@


1.106
log
@	* elf32-hppa.c (elf32_hppa_relocate_section): Skip relocation if
	output section has been discarded.
@
text
@d144 6
d1012 12
a1023 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1352 2
a1353 1
	      || (!info->shared
a1643 2
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;
d1685 4
d1707 1
a1707 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1709 10
a1718 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d1720 7
a1726 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
d1912 1
a1912 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d1927 6
d1940 2
a1941 1
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d3101 3
a3103 3
        {
          case R_PARISC_DLTIND21L:
            r_type = R_PARISC_DPREL21L;
d3106 2
a3107 2
          case R_PARISC_DLTIND14R:
            r_type = R_PARISC_DPREL14R;
d3110 2
a3111 2
          case R_PARISC_DLTIND14F:
            r_type = R_PARISC_DPREL14F;
d3189 1
a3189 1
              (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
d3457 1
a3457 1
	    {  
d3705 3
d3709 1
a3709 5
		   || (h != NULL
		       && h->elf.dynindx != -1
		       && (!info->symbolic
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d3714 3
a3716 2
		  && (((h->elf.elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
@


1.105
log
@	* elf32-hppa.c (struct elf32_hppa_link_hash_entry,
	hppa_link_hash_newfunc, hppa_build_one_stub,
	elf32_hppa_adjust_dynamic_symbol, mark_PIC_calls, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections,
	elf32_hppa_finish_dynamic_symbol): Remove pic_call field and all code
	for generating import stubs for calls to statically linked PIC
	functions.
	(hppa_type_of_stub): Don't generate an import stub for calls to
	statically linked pic functions.  Generate import stubs for calls
	in a shared object, to functions not in a regular file, and to
	defined weak functions.  Add new argument INFO.
	(hppa_build_one_stub): Don't undef ADDIL_DP.
	(elf32_hppa_check_relocs): Don't set SEC_HAS_GOT_REF flag.
	(elf32_hppa_size_stubs): Pass info to hppa_type_of_stub.
	(final_link_relocate): Change all DLTIND relocs to DPREL relocs in a
	non-shared link.  Convert instructions that use the the linkage table
	pointer, or a facsimile thereof, to use the global data pointer when
	the reloc has been changed.
@
text
@d3742 5
@


1.104
log
@For elf32-hppa-linux, objects can have OSABI=Linux or OSABI=SysV; check for
both.
@
text
@a205 4
  /* Set if the only reason we need a .plt entry is for a non-PIC to
     PIC function call.  */
  unsigned int pic_call:1;

a343 1
      eh->pic_call = 0;
d554 2
a555 1
		   bfd_vma destination)
d564 5
a568 2
      && (hash->elf.dynindx != -1 || hash->pic_call)
      && !hash->plabel)
a770 33
      if (!info->shared
	  && stub_entry->h != NULL
	  && stub_entry->h->pic_call)
	{
	  /* Build the .plt entry needed to call a PIC function from
	     statically linked code.  We don't need any relocs.  */
	  bfd *dynobj;
	  struct elf32_hppa_link_hash_entry *eh;
	  bfd_vma value;

	  dynobj = htab->elf.dynobj;
	  eh = (struct elf32_hppa_link_hash_entry *) stub_entry->h;

	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    abort ();

	  value = (eh->elf.root.u.def.value
		   + eh->elf.root.u.def.section->output_offset
		   + eh->elf.root.u.def.section->output_section->vma);

	  /* Fill in the entry in the procedure linkage table.

	     The format of a plt entry is
	     <funcaddr>
	     <__gp>.  */

	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off);
	  value = elf_gp (htab->splt->output_section->owner);
	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off + 4);
	}
a831 1
#undef ADDIL_DP
a1067 3

	  /* Mark this section as containing PIC code.  */
	  sec->flags |= SEC_HAS_GOT_REF;
d1650 2
a1651 12
	  /* As a special sop to the hppa ABI, we keep a .plt entry
	     for functions in sections containing PIC code.  */
	  if (!info->shared
	      && h->plt.refcount > 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	    ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;
	  else
	    {
	      h->plt.offset = (bfd_vma) -1;
	      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	    }
a1750 26
/* Called via elf_link_hash_traverse to create .plt entries for an
   application that uses statically linked PIC functions.  Similar to
   the first part of elf32_hppa_adjust_dynamic_symbol.  */

static bfd_boolean
mark_PIC_calls (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (! (h->plt.refcount > 0
	 && (h->root.type == bfd_link_hash_defined
	     || h->root.type == bfd_link_hash_defweak)
	 && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0))
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      return TRUE;
    }

  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
  ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;

  return TRUE;
}

d1752 1
a1752 1
   ie. pic_call and plabel entries.  */
d1769 1
a1769 10
  if (((struct elf32_hppa_link_hash_entry *) h)->pic_call)
    {
      /* Make an entry in the .plt section for non-pic code that is
	 calling pic code.  */
      ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
      s = htab->splt;
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;
    }
  else if (htab->elf.dynamic_sections_created
a1835 1
      && !((struct elf32_hppa_link_hash_entry *) h)->pic_call
a2032 8
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and mark them as needing .plt entries so that %r19 will
	 be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&htab->elf, mark_PIC_calls, info);
    }
d2782 1
a2782 1
						 destination);
d3037 2
a3038 1
		     struct elf32_hppa_link_hash_entry *h)
d3042 1
d3065 20
d3096 5
a3100 2
	      && (h->elf.dynindx != -1 || h->pic_call)
	      && !h->plabel))
d3140 32
d3774 1
a3774 1
			       htab, sym_sec, h);
d3831 2
d3860 5
a3864 1
      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
d3866 2
a3867 24
	  Elf_Internal_Rela rel;
	  bfd_byte *loc;

	  /* Create a dynamic IPLT relocation for this entry.  */
	  rel.r_offset = (h->plt.offset
			  + htab->splt->output_offset
			  + htab->splt->output_section->vma);
	  if (h->dynindx != -1)
	    {
	      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	      rel.r_addend = 0;
	    }
	  else
	    {
	      /* This symbol has been marked to become local, and is
		 used by a plabel so must be kept in the .plt.  */
	      rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	      rel.r_addend = value;
	    }

	  loc = htab->srelplt->contents;
	  loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_out (htab->splt->output_section->owner,
				     &rel, loc);
d3871 4
a3874 6
	  bfd_put_32 (htab->splt->owner,
		      value,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (htab->splt->owner,
		      elf_gp (htab->splt->output_section->owner),
		      htab->splt->contents + h->plt.offset + 4);
d3877 4
a3890 3
      Elf_Internal_Rela rel;
      bfd_byte *loc;

a3928 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
@


1.103
log
@Better handking for unresolved symbols
@
text
@d927 4
a930 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
@


1.102
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2856 1
a2856 1
				 && !info->no_undefined
d3447 2
a3448 1
	  int indx;
d3450 22
a3471 34
	  /* It's a global; Find its entry in the link hash.  */
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = ((struct elf32_hppa_link_hash_entry *)
	       elf_sym_hashes (input_bfd)[indx]);
	  while (h->elf.root.type == bfd_link_hash_indirect
		 || h->elf.root.type == bfd_link_hash_warning)
	    h = (struct elf32_hppa_link_hash_entry *) h->elf.root.u.i.link;

	  relocation = 0;
	  if (h->elf.root.type == bfd_link_hash_defined
	      || h->elf.root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->elf.root.u.def.section;
	      /* If sym_sec->output_section is NULL, then it's a
		 symbol defined in a shared library.  */
	      if (sym_sec->output_section != NULL)
		relocation = (h->elf.root.u.def.value
			      + sym_sec->output_offset
			      + sym_sec->output_section->vma);
	    }
	  else if (h->elf.root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   && h->elf.type != STT_PARISC_MILLI)
	    ;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->elf.root.root.string, input_bfd,
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      warned_undef = TRUE;
d3473 1
@


1.101
log
@	* elf-bfd.h: Remove PARAMS macro.  Replace PTR with void *.
	(NAME): Use ## rather than CONCAT4 macro.
	* elfcode.h: Remove one remaining PARAMS macro.
	* elf-eh-frame.c: Convert to C90, remove unneeded casts and prototypes.
	* elf-strtab.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf32-hppa.h: Likewise.
	* elf32-hppa.c: Likewise.
	(elf32_hppa_add_symbol_hook): Delete.
	(elf_backend_add_symbol_hook): Don't define.
	* libhppa.h: Convert to C90.  Replace INLINE with inline.
@
text
@d993 1
a993 1
elf32_hppa_copy_indirect_symbol (struct elf_backend_data *bed,
@


1.100
log
@Correct spelling of "relocatable".
@
text
@d226 2
a227 2
  asection * (*add_stub_section) PARAMS ((const char *, asection *));
  void (*layout_sections_again) PARAMS ((void));
a281 124
static struct bfd_hash_entry *stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static struct bfd_hash_entry *hppa_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static struct bfd_link_hash_table *elf32_hppa_link_hash_table_create
  PARAMS ((bfd *));

static void elf32_hppa_link_hash_table_free
  PARAMS ((struct bfd_link_hash_table *));

/* Stub handling functions.  */
static char *hppa_stub_name
  PARAMS ((const asection *, const asection *,
	   const struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *));

static struct elf32_hppa_stub_hash_entry *hppa_get_stub_entry
  PARAMS ((const asection *, const asection *,
	   struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_table *));

static struct elf32_hppa_stub_hash_entry *hppa_add_stub
  PARAMS ((const char *, asection *, struct elf32_hppa_link_hash_table *));

static enum elf32_hppa_stub_type hppa_type_of_stub
  PARAMS ((asection *, const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_entry *, bfd_vma));

static bfd_boolean hppa_build_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

static bfd_boolean hppa_size_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

/* BFD and elf backend functions.  */
static bfd_boolean elf32_hppa_object_p PARAMS ((bfd *));

static bfd_boolean elf32_hppa_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));

static bfd_boolean elf32_hppa_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));

static bfd_boolean elf32_hppa_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));

static asection *elf32_hppa_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean elf32_hppa_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));

static void elf32_hppa_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));

static bfd_boolean elf32_hppa_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));

static bfd_boolean mark_PIC_calls
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean allocate_plt_static
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean clobber_millicode_symbols
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));

static bfd_boolean elf32_hppa_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void group_sections
  PARAMS ((struct elf32_hppa_link_hash_table *, bfd_size_type, bfd_boolean));

static int get_local_syms
  PARAMS ((bfd *, bfd *, struct bfd_link_info *));

static bfd_boolean elf32_hppa_final_link
  PARAMS ((bfd *, struct bfd_link_info *));

static void hppa_record_segment_addr
  PARAMS ((bfd *, asection *, PTR));

static bfd_reloc_status_type final_link_relocate
  PARAMS ((asection *, bfd_byte *, const Elf_Internal_Rela *,
	   bfd_vma, struct elf32_hppa_link_hash_table *, asection *,
	   struct elf32_hppa_link_hash_entry *));

static bfd_boolean elf32_hppa_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static bfd_boolean elf32_hppa_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static enum elf_reloc_type_class elf32_hppa_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));

static bfd_boolean elf32_hppa_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static int elf32_hppa_elf_get_symbol_type
  PARAMS ((Elf_Internal_Sym *, int));

d287 3
a289 4
stub_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d324 3
a326 4
hppa_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d360 1
a360 2
elf32_hppa_link_hash_table_create (abfd)
     bfd *abfd;
d365 1
a365 1
  ret = (struct elf32_hppa_link_hash_table *) bfd_malloc (amt);
d404 1
a404 2
elf32_hppa_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d416 4
a419 5
hppa_stub_name (input_section, sym_sec, hash, rel)
     const asection *input_section;
     const asection *sym_sec;
     const struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
d456 5
a460 6
hppa_get_stub_entry (input_section, sym_sec, hash, rel, htab)
     const asection *input_section;
     const asection *sym_sec;
     struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_table *htab;
d501 3
a503 4
hppa_add_stub (stub_name, section, htab)
     const char *stub_name;
     asection *section;
     struct elf32_hppa_link_hash_table *htab;
d556 4
a559 5
hppa_type_of_stub (input_sec, rel, hash, destination)
     asection *input_sec;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_entry *hash;
     bfd_vma destination;
d648 1
a648 3
hppa_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d664 1
a664 1
  info = (struct bfd_link_info *) in_arg;
d686 1
a686 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel);
d690 1
a690 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel) >> 2;
d736 1
a736 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel),
d745 1
a745 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel);
d887 1
a887 3
hppa_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d895 1
a895 1
  htab = (struct elf32_hppa_link_hash_table *) in_arg;
d919 1
a919 2
elf32_hppa_object_p (abfd)
     bfd *abfd;
a950 17
/* Undo the generic ELF code's subtraction of section->vma from the
   value of each external symbol.  */

static bfd_boolean
elf32_hppa_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym *sym ATTRIBUTE_UNUSED;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  *valp += (*secp)->vma;
  return TRUE;
}

d955 1
a955 3
elf32_hppa_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d993 3
a995 3
elf32_hppa_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d1047 4
a1050 5
elf32_hppa_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1268 1
a1268 2
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
d1314 1
a1314 2
		      local_got_refcounts = ((bfd_signed_vma *)
					     bfd_zalloc (abfd, size));
d1448 1
a1448 3
		  p = ((struct elf32_hppa_dyn_reloc_entry *)
		       bfd_alloc (htab->elf.dynobj,
				  (bfd_size_type) sizeof *p));
d1476 5
a1480 6
elf32_hppa_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1515 4
a1518 5
elf32_hppa_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1617 3
a1619 4
elf32_hppa_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
d1657 2
a1658 3
elf32_hppa_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d1801 1
a1801 3
mark_PIC_calls (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf ATTRIBUTE_UNUSED;
d1826 1
a1826 3
allocate_plt_static (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1838 1
a1838 1
  info = (struct bfd_link_info *) inf;
d1898 1
a1898 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1912 1
a1912 1
  info = (struct bfd_link_info *) inf;
d2037 2
a2038 3
clobber_millicode_symbols (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
d2054 1
a2054 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d2069 1
a2069 1
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d2083 2
a2084 3
elf32_hppa_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d2120 1
a2120 1
	elf_link_hash_traverse (&htab->elf, mark_PIC_calls, (PTR) info);
d2217 1
a2217 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, (PTR) info);
d2221 1
a2221 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2288 1
a2288 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2334 1
a2334 2
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);
d2355 1
a2355 3
elf32_hppa_setup_section_lists (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d2385 1
a2385 1
  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
d2402 1
a2402 1
  input_list = (asection **) bfd_malloc (amt);
d2431 1
a2431 3
elf32_hppa_next_input_section (info, isec)
     struct bfd_link_info *info;
     asection *isec;
d2458 3
a2460 4
group_sections (htab, stub_group_size, stubs_always_before_branch)
     struct elf32_hppa_link_hash_table *htab;
     bfd_size_type stub_group_size;
     bfd_boolean stubs_always_before_branch;
d2538 1
a2538 4
get_local_syms (output_bfd, input_bfd, info)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
d2549 1
a2549 1
  all_local_syms = (Elf_Internal_Sym **) bfd_zmalloc (amt);
d2663 5
a2667 9
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
     bfd *output_bfd;
     bfd *stub_bfd;
     struct bfd_link_info *info;
     bfd_boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d2765 1
a2765 2
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
d2952 1
a2952 3
elf32_hppa_set_gp (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3046 1
a3046 2
elf32_hppa_build_stubs (info)
     struct bfd_link_info *info;
d3062 1
a3062 1
      stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
d3078 1
a3078 3
elf32_hppa_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3092 3
a3094 4
hppa_record_segment_addr (abfd, section, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR data;
d3120 7
a3126 8
final_link_relocate (input_section, contents, rel, value, htab, sym_sec, h)
     asection *input_section;
     bfd_byte *contents;
     const Elf_Internal_Rela *rel;
     bfd_vma value;
     struct elf32_hppa_link_hash_table *htab;
     asection *sym_sec;
     struct elf32_hppa_link_hash_entry *h;
d3383 8
a3390 10
elf32_hppa_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d3854 2
a3855 2
		(info, sym_name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset)))
d3867 4
a3870 5
elf32_hppa_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3975 1
a3975 2
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      htab->sgot->contents + h->got.offset);
d4024 1
a4024 2
elf32_hppa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d4043 2
a4044 3
elf32_hppa_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d4122 1
a4122 3
		  (sdyn != NULL
		   ? sdyn->output_section->vma + sdyn->output_offset
		   : (bfd_vma) 0),
d4165 2
a4166 3
elf32_hppa_post_process_headers (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d4185 1
a4185 3
elf32_hppa_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym *elf_sym;
     int type;
a4202 1
#define elf_backend_add_symbol_hook	     elf32_hppa_add_symbol_hook
@


1.99
log
@2003-05-28  Alan Modra  <amodra@@bigpond.net.au>

	* elf32-hppa.c (elf32_hppa_relocate_section): Delete bogus
	undefined_symbol call.
@
text
@d1217 1
a1217 1
  if (info->relocateable)
d3596 1
a3596 1
  if (info->relocateable)
@


1.98
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d3669 2
a3670 1
	  else if (info->shared && !info->no_undefined
d3673 1
a3673 7
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->elf.root.root.string, input_bfd,
		     input_section, rel->r_offset, FALSE)))
		return FALSE;
	      warned_undef = TRUE;
	    }
@


1.97
log
@	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Simplify dynamic reloc
	removal.  Localize vars.  Remove unnecessary dynobj test.
	* elf32-i386 (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead
	of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_gc_sweep_hook): Simplify dyn reloc removal.  Localize vars.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.  Remove
	local_dynrel for section too.  Don't touch HIPLT22, LOPLT10, PCPLT32
	or PCPLT10 relocs.  Don't subtract twice on PLT32 relocs.
	Formatting.
@
text
@d2953 3
a2955 3
		= _bfd_elf32_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
@


1.97.18.1
log
@	* elf32-hppa.c (elf32_hppa_relocate_section): Delete bogus
	undefined_symbol call.
@
text
@d3669 1
a3669 2
	  else if (info->shared
		   && !info->no_undefined
d3672 7
a3678 1
	    ;
@


1.97.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2953 3
a2955 3
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
@


1.96
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@a1687 4
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  struct elf32_hppa_link_hash_table *htab;
  bfd *dynobj;
a1696 4
  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    return TRUE;
d1700 72
a1771 99
    switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
      {
      case R_PARISC_DLTIND14F:
      case R_PARISC_DLTIND14R:
      case R_PARISC_DLTIND21L:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_PARISC_PCREL12F:
      case R_PARISC_PCREL17C:
      case R_PARISC_PCREL17F:
      case R_PARISC_PCREL22F:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      case R_PARISC_PLABEL14R:
      case R_PARISC_PLABEL21L:
      case R_PARISC_PLABEL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_hppa_link_hash_entry *eh;
	    struct elf32_hppa_dyn_reloc_entry **pp;
	    struct elf32_hppa_dyn_reloc_entry *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf32_hppa_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
#if RELATIVE_DYNRELOCS
		  if (!IS_ABSOLUTE_RELOC (rtype))
		    p->relative_count -= 1;
#endif
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	else if (local_plt_refcounts != NULL)
	  {
	    if (local_plt_refcounts[r_symndx] > 0)
	      local_plt_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_PARISC_DIR32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_hppa_link_hash_entry *eh;
	    struct elf32_hppa_dyn_reloc_entry **pp;
	    struct elf32_hppa_dyn_reloc_entry *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    eh = (struct elf32_hppa_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
#if RELATIVE_DYNRELOCS
		  if (!IS_ABSOLUTE_RELOC (R_PARISC_DIR32))
		    p->relative_count -= 1;
#endif
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      default:
	break;
      }
@


1.95
log
@	* elf32-hppa.c (group_sections): Don't share a stub section if
	stubs are for a large section.
@
text
@d11 1
a11 1
This file is part of BFD, the Binary File Descriptor library.
d13 13
a25 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d114 1
a114 1
   :		be,n 0(%sr0,%rp)		; inter-space return  */
d3708 5
a3712 8
	      if (info->symbolic && !info->allow_shlib_undefined)
		{
		  if (!((*info->callbacks->undefined_symbol)
			(info, h->elf.root.root.string, input_bfd,
			 input_section, rel->r_offset, FALSE)))
		    return FALSE;
		  warned_undef = TRUE;
		}
@


1.94
log
@	* elf32-hppa.c (elf32_hppa_size_stubs): Double the size left for
	stubs if !stubs_always_before_branch.
@
text
@d2689 1
d2696 2
d2725 5
a2729 2
	     bytes before the stub section can be handled by it too.  */
	  if (!stubs_always_before_branch)
@


1.93
log
@	* elf32-hppa.c (final_link_relocate): For all DP relative relocations,
	adjust addil instructions if the symbol has no section.
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d2904 16
a2919 5
      stub_group_size = 7680000;
      if (htab->has_17bit_branch || htab->multi_subspace)
	stub_group_size = 240000;
      if (htab->has_12bit_branch)
	stub_group_size = 7500;
@


1.92
log
@	* elf32-i386.c (elf_i386_finish_dynamic_sections): Add output_offset
	to DT_JMPREL.  Use srelplt input section size for DT_PLTRELSZ and
	DT_RELSZ adjustment, not output section.  Avoid writing tags when
	unchanged.  Don't assume linker script is sane, adjust DT_REL too.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Just use raw
	size of srelplt for DT_PLTRELSZ.  Use srelplt input section size for
	DT_RELASZ adjustment, not output section.  Avoid writing tags when
	unchanged.  Adjust DT_RELA.
	* elf64-ppc.c (ppc64_elf_finish_dynamic_sections): Tweaks for better
	formatting.  Avoid writing tags when unchanged.  Adjust DT_RELA.
@
text
@d3419 5
a3423 4
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  This situation commonly arises when a variable's "constness"
d3426 1
a3426 3
      if (sym_sec == NULL)
	break;
      if ((sym_sec->flags & SEC_CODE) != 0)
@


1.91
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d4317 1
a4317 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d4323 16
a4338 8
	      if (htab->srelplt != NULL)
		{
		  s = htab->srelplt->output_section;
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
@


1.90
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d313 1
a313 1
static boolean hppa_build_one_stub
d316 1
a316 1
static boolean hppa_size_one_stub
d320 1
a320 1
static boolean elf32_hppa_object_p PARAMS ((bfd *));
d322 1
a322 1
static boolean elf32_hppa_add_symbol_hook
d326 1
a326 1
static boolean elf32_hppa_create_dynamic_sections
d333 1
a333 1
static boolean elf32_hppa_check_relocs
d341 1
a341 1
static boolean elf32_hppa_gc_sweep_hook
d346 1
a346 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, boolean));
d348 1
a348 1
static boolean elf32_hppa_adjust_dynamic_symbol
d351 1
a351 1
static boolean mark_PIC_calls
d354 1
a354 1
static boolean allocate_plt_static
d357 1
a357 1
static boolean allocate_dynrelocs
d360 1
a360 1
static boolean readonly_dynrelocs
d363 1
a363 1
static boolean clobber_millicode_symbols
d366 1
a366 1
static boolean elf32_hppa_size_dynamic_sections
d370 1
a370 1
  PARAMS ((struct elf32_hppa_link_hash_table *, bfd_size_type, boolean));
d375 1
a375 1
static boolean elf32_hppa_final_link
d386 1
a386 1
static boolean elf32_hppa_relocate_section
d390 1
a390 1
static boolean elf32_hppa_finish_dynamic_symbol
d397 1
a397 1
static boolean elf32_hppa_finish_dynamic_sections
d617 1
a617 1
					  stub_name, false, false);
d669 1
a669 1
				      true, false);
d779 1
a779 1
static boolean
d963 1
a963 1
	  return false;
d988 1
a988 1
      return false;
d992 1
a992 1
  return true;
d1020 1
a1020 1
static boolean
d1048 1
a1048 1
  return true;
d1054 1
a1054 1
static boolean
d1065 1
a1065 1
	return false;
d1070 1
a1070 1
	return false;
d1085 1
a1085 1
  return true;
d1091 1
a1091 1
static boolean
d1102 1
a1102 1
  return true;
d1108 1
a1108 1
static boolean
d1118 1
a1118 1
    return true;
d1122 1
a1122 1
    return false;
d1138 1
a1138 1
    return false;
d1143 1
a1143 1
  return true;
d1202 1
a1202 1
static boolean
d1218 1
a1218 1
    return true;
d1344 1
a1344 1
	      return false;
d1377 1
a1377 1
	    return false;
d1385 1
a1385 1
	    return false;
d1402 1
a1402 1
		return false;
d1428 1
a1428 1
		    return false;
d1475 1
a1475 1
			return false;
d1556 1
a1556 1
		      return false;
d1576 1
a1576 1
			return false;
d1598 1
a1598 1
		    return false;
d1611 1
a1611 1
		    return false;
d1630 1
a1630 1
  return true;
d1676 1
a1676 1
static boolean
d1704 1
a1704 1
    return true;
d1808 1
a1808 1
  return true;
d1818 1
a1818 1
     boolean force_local;
d1855 1
a1855 1
static boolean
d1899 1
a1899 1
      return true;
d1914 1
a1914 1
      return true;
d1925 1
a1925 1
    return true;
d1930 1
a1930 1
    return true;
d1945 1
a1945 1
      return true;
d1983 1
a1983 1
	return false;
d1993 1
a1993 1
  return true;
d2000 1
a2000 1
static boolean
d2015 1
a2015 1
      return true;
d2021 1
a2021 1
  return true;
d2027 1
a2027 1
static boolean
d2037 1
a2037 1
    return true;
d2063 1
a2063 1
	    return false;
d2095 1
a2095 1
  return true;
d2101 1
a2101 1
static boolean
d2113 1
a2113 1
    return true;
d2144 1
a2144 1
	    return false;
d2163 1
a2163 1
    return true;
d2210 1
a2210 1
		return false;
d2220 1
a2220 1
      return true;
d2232 1
a2232 1
  return true;
d2242 1
a2242 1
static boolean
d2253 1
a2253 1
      elf32_hppa_hide_symbol (info, h, true);
d2255 1
a2255 1
  return true;
d2260 1
a2260 1
static boolean
d2283 1
a2283 1
	  return false;
d2286 1
a2286 1
  return true;
d2291 1
a2291 1
static boolean
d2300 1
a2300 1
  boolean relocs;
d2436 1
a2436 1
  relocs = false;
d2468 1
a2468 1
		relocs = true;
d2500 1
a2500 1
	return false;
d2513 1
a2513 1
	return false;
d2523 1
a2523 1
	    return false;
d2531 1
a2531 1
	    return false;
d2539 1
a2539 1
	    return false;
d2550 1
a2550 1
		return false;
d2556 1
a2556 1
  return true;
d2676 1
a2676 1
     boolean stubs_always_before_branch;
d2842 1
a2842 1
						      false, false);
d2875 1
a2875 1
boolean
d2881 1
a2881 1
     boolean multi_subspace;
d2887 2
a2888 2
  boolean stubs_always_before_branch;
  boolean stub_changed;
d2918 1
a2918 1
      return false;
d2921 1
a2921 1
      stub_changed = false;
d2925 1
a2925 1
      stub_changed = true;
d3092 1
a3092 1
						      false, false);
d3118 1
a3118 1
		  stub_changed = true;
d3144 1
a3144 1
      stub_changed = false;
d3148 1
a3148 1
  return true;
d3152 1
a3152 1
  return false;
d3158 1
a3158 1
boolean
d3169 1
a3169 1
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", false, false, false);
d3245 1
a3245 1
  return true;
d3254 1
a3254 1
boolean
d3274 1
a3274 1
	return false;
d3282 1
a3282 1
  return true;
d3287 1
a3287 1
static boolean
d3294 1
a3294 1
    return false;
d3597 1
a3597 1
static boolean
d3616 1
a3616 1
    return true;
d3636 2
a3637 2
      boolean plabel;
      boolean warned_undef;
d3643 1
a3643 1
	  return false;
d3654 1
a3654 1
      warned_undef = false;
d3696 3
a3698 3
			 input_section, rel->r_offset, false)))
		    return false;
		  warned_undef = true;
d3705 3
a3707 3
		     input_section, rel->r_offset, true)))
		return false;
	      warned_undef = true;
d3722 1
a3722 1
	    boolean do_got = 0;
d3728 1
a3728 1
		boolean dyn;
d3817 1
a3817 1
	      boolean do_plt = 0;
d3959 1
a3959 1
	      boolean skip;
d4054 1
a4054 1
	    return false;
d4073 1
a4073 1
	      return false;
d4081 1
a4081 1
	    return false;
d4085 1
a4085 1
  return true;
d4091 1
a4091 1
static boolean
d4244 1
a4244 1
  return true;
d4270 1
a4270 1
static boolean
d4380 1
a4380 1
	      return false;
d4385 1
a4385 1
  return true;
@


1.89
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d3777 2
a3778 2
		    asection *srelgot = htab->srelgot;
		    Elf32_External_Rela *loc;
d3785 2
a3786 2
		    loc = (Elf32_External_Rela *) srelgot->contents;
		    loc += srelgot->reloc_count++;
d3867 2
a3868 2
		      asection *srelplt = htab->srelplt;
		      Elf32_External_Rela *loc;
d3875 2
a3876 2
		      loc = (Elf32_External_Rela *) srelplt->contents;
		      loc += srelplt->reloc_count++;
d3961 1
a3961 1
	      Elf32_External_Rela *loc;
d4030 2
a4031 2
	      loc = (Elf32_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
d4129 1
a4129 1
	  Elf32_External_Rela *loc;
d4148 2
a4149 2
	  loc = (Elf32_External_Rela *) htab->srelplt->contents;
	  loc += htab->srelplt->reloc_count++;
d4174 1
a4174 1
      Elf32_External_Rela *loc;
d4207 2
a4208 2
      loc = (Elf32_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
d4216 1
a4216 1
      Elf32_External_Rela *loc;
d4232 1
a4232 1
      loc = (Elf32_External_Rela *) s->contents + s->reloc_count++;
@


1.89.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d11 1
a11 1
   This file is part of BFD, the Binary File Descriptor library.
d13 13
a25 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d114 1
a114 1
   :		be,n 0(%sr0,%rp)		; inter-space return.  */
a143 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d206 4
d226 2
a227 2
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);
d282 124
d411 4
a414 3
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
d449 4
a452 3
hppa_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
d474 1
d486 2
a487 1
elf32_hppa_link_hash_table_create (bfd *abfd)
d492 1
a492 1
  ret = bfd_malloc (amt);
d531 2
a532 1
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *hash)
d544 5
a548 4
hppa_stub_name (const asection *input_section,
		const asection *sym_sec,
		const struct elf32_hppa_link_hash_entry *hash,
		const Elf_Internal_Rela *rel)
d585 6
a590 5
hppa_get_stub_entry (const asection *input_section,
		     const asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
		     struct elf32_hppa_link_hash_table *htab)
d617 1
a617 1
					  stub_name, FALSE, FALSE);
d631 4
a634 3
hppa_add_stub (const char *stub_name,
	       asection *section,
	       struct elf32_hppa_link_hash_table *htab)
d669 1
a669 1
				      TRUE, FALSE);
d687 5
a691 5
hppa_type_of_stub (asection *input_sec,
		   const Elf_Internal_Rela *rel,
		   struct elf32_hppa_link_hash_entry *hash,
		   bfd_vma destination,
		   struct bfd_link_info *info)
d700 2
a701 5
      && hash->elf.dynindx != -1
      && !hash->plabel
      && (info->shared
	  || !(hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
	  || hash->elf.root.type == bfd_link_hash_defweak))
d779 4
a782 2
static bfd_boolean
hppa_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d798 1
a798 1
  info = in_arg;
d820 1
a820 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel);
d824 1
a824 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel) >> 2;
d870 1
a870 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel),
d879 1
a879 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel);
d906 33
d963 1
a963 1
	  return FALSE;
d988 1
a988 1
      return FALSE;
d992 1
a992 1
  return TRUE;
d1000 1
d1020 4
a1023 2
static bfd_boolean
hppa_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d1031 1
a1031 1
  htab = in_arg;
d1048 1
a1048 1
  return TRUE;
d1054 3
a1056 2
static bfd_boolean
elf32_hppa_object_p (bfd *abfd)
d1064 2
a1065 5
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
d1070 1
a1070 1
	return FALSE;
d1085 18
a1102 1
  return TRUE;
d1108 4
a1111 2
static bfd_boolean
elf32_hppa_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d1118 1
a1118 1
    return TRUE;
d1122 1
a1122 1
    return FALSE;
d1138 1
a1138 1
    return FALSE;
d1143 1
a1143 1
  return TRUE;
d1149 3
a1151 3
elf32_hppa_copy_indirect_symbol (const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
d1194 1
a1194 13
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1202 6
a1207 5
static bfd_boolean
elf32_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
d1217 2
a1218 2
  if (info->relocatable)
    return TRUE;
d1257 3
d1344 1
a1344 1
	      return FALSE;
d1377 1
a1377 1
	    return FALSE;
d1385 1
a1385 1
	    return FALSE;
d1402 1
a1402 1
		return FALSE;
d1425 2
a1426 1
		  local_got_refcounts = bfd_zalloc (abfd, size);
d1428 1
a1428 1
		    return FALSE;
d1472 2
a1473 1
		      local_got_refcounts = bfd_zalloc (abfd, size);
d1475 1
a1475 1
			return FALSE;
d1529 1
a1529 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1556 1
a1556 1
		      return FALSE;
d1576 1
a1576 1
			return FALSE;
d1598 1
a1598 1
		    return FALSE;
d1607 3
a1609 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d1611 1
a1611 1
		    return FALSE;
d1630 1
a1630 1
  return TRUE;
d1637 6
a1642 5
elf32_hppa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
d1676 6
a1681 5
static bfd_boolean
elf32_hppa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
d1688 4
d1701 4
d1708 46
a1753 4
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d1755 1
a1755 6
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf32_hppa_link_hash_entry *eh;
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;
d1757 19
a1775 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf32_hppa_link_hash_entry *) h;
d1777 7
a1783 8
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d1785 1
a1785 17
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1787 1
a1787 10
	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1789 14
a1802 14
	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  else if (local_plt_refcounts != NULL)
	    {
	      if (local_plt_refcounts[r_symndx] > 0)
		local_plt_refcounts[r_symndx] -= 1;
	    }
	  break;
d1804 3
a1806 4
	default:
	  break;
	}
    }
d1808 1
a1808 1
  return TRUE;
d1815 4
a1818 3
elf32_hppa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *h,
			bfd_boolean force_local)
d1855 4
a1858 3
static bfd_boolean
elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
d1861 2
d1885 12
a1896 2
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1899 1
a1899 1
      return TRUE;
d1914 1
a1914 5
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d1925 1
a1925 1
    return TRUE;
d1930 1
a1930 1
    return TRUE;
d1932 2
a1933 1
  if (ELIMINATE_COPY_RELOCS)
d1935 4
a1938 2
      struct elf32_hppa_link_hash_entry *eh;
      struct elf32_hppa_dyn_reloc_entry *p;
d1940 6
a1945 15
      eh = (struct elf32_hppa_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1983 1
a1983 1
	return FALSE;
d1993 29
a2021 1
  return TRUE;
d2025 1
a2025 1
   ie. plabel entries.  */
d2027 4
a2030 2
static bfd_boolean
allocate_plt_static (struct elf_link_hash_entry *h, void *inf)
d2037 1
a2037 1
    return TRUE;
d2042 1
a2042 1
  info = inf;
d2044 10
a2053 1
  if (htab->elf.dynamic_sections_created
d2063 1
a2063 1
	    return FALSE;
d2095 1
a2095 1
  return TRUE;
d2101 4
a2104 2
static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2113 1
a2113 1
    return TRUE;
d2118 1
a2118 1
  info = inf;
d2122 1
d2144 1
a2144 1
	    return FALSE;
d2163 1
a2163 1
    return TRUE;
d2173 3
a2175 1
      if (SYMBOL_CALLS_LOCAL (info, h))
a2189 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d2197 1
a2197 2
	  && ((ELIMINATE_COPY_RELOCS
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d2210 1
a2210 1
		return FALSE;
d2220 1
a2220 1
      return TRUE;
d2232 1
a2232 1
  return TRUE;
d2242 4
a2245 3
static bfd_boolean
clobber_millicode_symbols (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info)
d2253 1
a2253 1
      elf32_hppa_hide_symbol (info, h, TRUE);
d2255 1
a2255 1
  return TRUE;
d2260 4
a2263 2
static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2278 1
a2278 1
	  struct bfd_link_info *info = inf;
d2283 1
a2283 1
	  return FALSE;
d2286 1
a2286 1
  return TRUE;
d2291 4
a2294 3
static bfd_boolean
elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
d2300 1
a2300 1
  bfd_boolean relocs;
d2310 1
a2310 1
      if (info->executable)
d2324 8
d2427 1
a2427 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, info);
d2431 1
a2431 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d2436 1
a2436 1
  relocs = FALSE;
d2468 1
a2468 1
		relocs = TRUE;
d2498 1
a2498 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d2500 1
a2500 1
	return FALSE;
d2513 1
a2513 1
	return FALSE;
d2523 1
a2523 1
	    return FALSE;
d2531 1
a2531 1
	    return FALSE;
d2539 1
a2539 1
	    return FALSE;
d2544 2
a2545 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d2550 1
a2550 1
		return FALSE;
d2556 1
a2556 1
  return TRUE;
d2566 3
a2568 1
elf32_hppa_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d2578 3
d2598 1
a2598 1
  htab->stub_group = bfd_zmalloc (amt);
d2615 1
a2615 1
  input_list = bfd_malloc (amt);
d2644 3
a2646 1
elf32_hppa_next_input_section (struct bfd_link_info *info, asection *isec)
d2673 4
a2676 3
group_sections (struct elf32_hppa_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
a2688 1
	  bfd_boolean big_sec;
a2694 2
	  big_sec = total >= stub_group_size;

d2722 2
a2723 5
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
d2748 4
a2751 1
get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
d2762 1
a2762 1
  all_local_syms = bfd_zmalloc (amt);
d2842 1
a2842 1
						      FALSE, FALSE);
d2875 10
a2884 6
bfd_boolean
elf32_hppa_size_stubs
  (bfd *output_bfd, bfd *stub_bfd, struct bfd_link_info *info,
   bfd_boolean multi_subspace, bfd_signed_vma group_size,
   asection * (*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
d2887 2
a2888 2
  bfd_boolean stubs_always_before_branch;
  bfd_boolean stub_changed;
d2904 5
a2908 16
      if (stubs_always_before_branch)
	{
	  stub_group_size = 7680000;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 240000;
	  if (htab->has_12bit_branch)
	    stub_group_size = 7500;
	}
      else
	{
	  stub_group_size = 6971392;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 217856;
	  if (htab->has_12bit_branch)
	    stub_group_size = 6808;
	}
d2918 1
a2918 1
      return FALSE;
d2921 1
a2921 1
      stub_changed = FALSE;
d2925 1
a2925 1
      stub_changed = TRUE;
d2971 3
a2973 2
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
d3063 1
a3063 1
				 && info->unresolved_syms_in_objects == RM_IGNORE
d3078 1
a3078 1
						 destination, info);
d3092 1
a3092 1
						      FALSE, FALSE);
d3118 1
a3118 1
		  stub_changed = TRUE;
d3144 1
a3144 1
      stub_changed = FALSE;
d3148 1
a3148 1
  return TRUE;
d3152 1
a3152 1
  return FALSE;
d3158 4
a3161 2
bfd_boolean
elf32_hppa_set_gp (bfd *abfd, struct bfd_link_info *info)
d3169 1
a3169 1
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", FALSE, FALSE, FALSE);
d3180 15
a3194 2
      asection *splt = bfd_get_section_by_name (abfd, ".plt");
      asection *sgot = bfd_get_section_by_name (abfd, ".got");
d3245 1
a3245 1
  return TRUE;
d3254 3
a3256 2
bfd_boolean
elf32_hppa_build_stubs (struct bfd_link_info *info)
d3272 1
a3272 1
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
d3274 1
a3274 1
	return FALSE;
d3282 1
a3282 1
  return TRUE;
d3287 4
a3290 2
static bfd_boolean
elf32_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
d3294 1
a3294 1
    return FALSE;
d3304 4
a3307 3
hppa_record_segment_addr (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *section,
			  void *data)
d3333 8
a3340 8
final_link_relocate (asection *input_section,
		     bfd_byte *contents,
		     const Elf_Internal_Rela *rel,
		     bfd_vma value,
		     struct elf32_hppa_link_hash_table *htab,
		     asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *h,
		     struct bfd_link_info *info)
a3343 1
  unsigned int orig_r_type = r_type;
a3365 20
  /* If we are not building a shared library, convert DLTIND relocs to
     DPREL relocs.  */
  if (!info->shared)
    {
      switch (r_type)
	{
	  case R_PARISC_DLTIND21L:
	    r_type = R_PARISC_DPREL21L;
	    break;

	  case R_PARISC_DLTIND14R:
	    r_type = R_PARISC_DPREL14R;
	    break;

	  case R_PARISC_DLTIND14F:
	    r_type = R_PARISC_DPREL14F;
	    break;
	}
    }

d3377 2
a3378 5
	      && h->elf.dynindx != -1
	      && !h->plabel
	      && (info->shared
		  || !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  || h->elf.root.type == bfd_link_hash_defweak)))
a3417 32
      /* Convert instructions that use the linkage table pointer (r19) to
	 instructions that use the global data pointer (dp).  This is the
	 most efficient way of using PIC code in an incomplete executable,
	 but the user must follow the standard runtime conventions for
	 accessing data for this to work.  */
      if (orig_r_type == R_PARISC_DLTIND21L)
	{
	  /* Convert addil instructions if the original reloc was a
	     DLTIND21L.  GCC sometimes uses a register other than r19 for
	     the operation, so we must convert any addil instruction
	     that uses this relocation.  */
	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
	    insn = ADDIL_DP;
	  else
	    /* We must have a ldil instruction.  It's too hard to find
	       and convert the associated add instruction, so issue an
	       error.  */
	    (*_bfd_error_handler)
	      (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       howto->name,
	       insn);
	}
      else if (orig_r_type == R_PARISC_DLTIND14F)
	{
	  /* This must be a format 1 load/store.  Change the base
	     register to dp.  */
	  insn = (insn & 0xfc1ffff) | (27 << 21);
	}

d3419 4
a3422 5
       section.  If it has no section or if it's a code section, then
       "data pointer relative" makes no sense.  In that case we don't
       adjust the "value", and for 21 bit addil instructions, we change the
       source addend register from %dp to %r0.  This situation commonly
       arises for undefined weak symbols and when a variable's "constness"
d3425 3
a3427 1
      if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
d3597 11
a3607 9
static bfd_boolean
elf32_hppa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
d3615 2
a3616 2
  if (info->relocatable)
    return TRUE;
d3636 2
a3637 2
      bfd_boolean plabel;
      bfd_boolean warned_undef;
d3643 1
a3643 1
	  return FALSE;
d3654 1
a3654 1
      warned_undef = FALSE;
d3660 1
a3660 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
d3664 1
a3664 2
	  struct elf_link_hash_entry *hh;
	  bfd_boolean unresolved_reloc;
d3666 11
a3676 8
	  RELOC_FOR_GLOBAL_SYMBOL (hh, elf_sym_hashes (input_bfd), r_symndx, symtab_hdr,
				   relocation, sym_sec, unresolved_reloc, info,
				   warned_undef);

	  if (relocation == 0
	      && hh->root.type != bfd_link_hash_defined
	      && hh->root.type != bfd_link_hash_defweak
	      && hh->root.type != bfd_link_hash_undefweak)
d3678 15
a3692 4
	      if (!info->executable
		  && info->unresolved_syms_in_objects == RM_IGNORE
		  && ELF_ST_VISIBILITY (hh->other) == STV_DEFAULT
		  && hh->type == STT_PARISC_MILLI)
d3694 5
a3698 7
		  if (! info->callbacks->undefined_symbol
		      (info, hh->root.root.string, input_bfd,
		       input_section, rel->r_offset,
		       ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
			|| (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR))))
		    return FALSE;
		  warned_undef = TRUE;
d3701 8
a3708 1
	  h = (struct elf32_hppa_link_hash_entry *) hh;
d3722 1
a3722 1
	    bfd_boolean do_got = 0;
d3728 1
a3728 1
		bfd_boolean dyn;
d3777 2
a3778 2
		    bfd_byte *loc;
		    asection *s = htab->srelgot;
d3785 2
a3786 2
		    loc = s->contents;
		    loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
d3817 1
a3817 1
	      bfd_boolean do_plt = 0;
d3867 2
a3868 2
		      bfd_byte *loc;
		      asection *s = htab->srelplt;
d3875 2
a3876 2
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
a3940 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
d3942 5
a3946 1
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
d3951 2
a3952 3
		  && ((ELIMINATE_COPY_RELOCS
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d3959 1
a3959 1
	      bfd_boolean skip;
d3961 1
a3961 1
	      bfd_byte *loc;
a4008 5
		      /* Skip this relocation if the output section has
			 been discarded.  */
		      if (bfd_is_abs_section (sym_sec->output_section))
			break;

d4030 2
a4031 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
d4041 1
a4041 1
			       htab, sym_sec, h, info);
d4054 1
a4054 1
	    return FALSE;
d4073 1
a4073 1
	      return FALSE;
d4079 3
a4081 3
		(info, sym_name, howto->name, 0, input_bfd, input_section,
		 rel->r_offset)))
	    return FALSE;
d4085 1
a4085 1
  return TRUE;
d4091 6
a4096 5
static bfd_boolean
elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
a4098 2
  Elf_Internal_Rela rel;
  bfd_byte *loc;
d4126 1
a4126 5
      /* Create a dynamic IPLT relocation for this entry.  */
      rel.r_offset = (h->plt.offset
		      + htab->splt->output_offset
		      + htab->splt->output_section->vma);
      if (h->dynindx != -1)
d4128 24
a4151 2
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
d4155 6
a4160 4
	  /* This symbol has been marked to become local, and is
	     used by a plabel so must be kept in the .plt.  */
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rel.r_addend = value;
a4162 4
      loc = htab->srelplt->contents;
      loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rel, loc);

d4173 3
d4201 2
a4202 1
	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + h->got.offset);
d4207 2
a4208 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d4215 2
d4232 1
a4232 1
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
d4244 1
a4244 1
  return TRUE;
d4251 2
a4252 1
elf32_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
d4270 4
a4273 3
static bfd_boolean
elf32_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
d4317 4
a4320 1
	      dyn.d_un.d_val = s->_raw_size;
d4326 8
a4333 16
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
d4346 3
a4348 1
		  sdyn ? sdyn->output_section->vma + sdyn->output_offset : 0,
d4380 1
a4380 1
	      return FALSE;
d4385 1
a4385 1
  return TRUE;
d4391 3
a4393 2
elf32_hppa_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
d4412 3
a4414 1
elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
d4432 1
@


1.89.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d313 1
a313 1
static bfd_boolean hppa_build_one_stub
d316 1
a316 1
static bfd_boolean hppa_size_one_stub
d320 1
a320 1
static bfd_boolean elf32_hppa_object_p PARAMS ((bfd *));
d322 1
a322 1
static bfd_boolean elf32_hppa_add_symbol_hook
d326 1
a326 1
static bfd_boolean elf32_hppa_create_dynamic_sections
d333 1
a333 1
static bfd_boolean elf32_hppa_check_relocs
d341 1
a341 1
static bfd_boolean elf32_hppa_gc_sweep_hook
d346 1
a346 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
d348 1
a348 1
static bfd_boolean elf32_hppa_adjust_dynamic_symbol
d351 1
a351 1
static bfd_boolean mark_PIC_calls
d354 1
a354 1
static bfd_boolean allocate_plt_static
d357 1
a357 1
static bfd_boolean allocate_dynrelocs
d360 1
a360 1
static bfd_boolean readonly_dynrelocs
d363 1
a363 1
static bfd_boolean clobber_millicode_symbols
d366 1
a366 1
static bfd_boolean elf32_hppa_size_dynamic_sections
d370 1
a370 1
  PARAMS ((struct elf32_hppa_link_hash_table *, bfd_size_type, bfd_boolean));
d375 1
a375 1
static bfd_boolean elf32_hppa_final_link
d386 1
a386 1
static bfd_boolean elf32_hppa_relocate_section
d390 1
a390 1
static bfd_boolean elf32_hppa_finish_dynamic_symbol
d397 1
a397 1
static bfd_boolean elf32_hppa_finish_dynamic_sections
d617 1
a617 1
					  stub_name, FALSE, FALSE);
d669 1
a669 1
				      TRUE, FALSE);
d779 1
a779 1
static bfd_boolean
d963 1
a963 1
	  return FALSE;
d988 1
a988 1
      return FALSE;
d992 1
a992 1
  return TRUE;
d1020 1
a1020 1
static bfd_boolean
d1048 1
a1048 1
  return TRUE;
d1054 1
a1054 1
static bfd_boolean
d1065 1
a1065 1
	return FALSE;
d1070 1
a1070 1
	return FALSE;
d1085 1
a1085 1
  return TRUE;
d1091 1
a1091 1
static bfd_boolean
d1102 1
a1102 1
  return TRUE;
d1108 1
a1108 1
static bfd_boolean
d1118 1
a1118 1
    return TRUE;
d1122 1
a1122 1
    return FALSE;
d1138 1
a1138 1
    return FALSE;
d1143 1
a1143 1
  return TRUE;
d1202 1
a1202 1
static bfd_boolean
d1218 1
a1218 1
    return TRUE;
d1344 1
a1344 1
	      return FALSE;
d1377 1
a1377 1
	    return FALSE;
d1385 1
a1385 1
	    return FALSE;
d1402 1
a1402 1
		return FALSE;
d1428 1
a1428 1
		    return FALSE;
d1475 1
a1475 1
			return FALSE;
d1556 1
a1556 1
		      return FALSE;
d1576 1
a1576 1
			return FALSE;
d1598 1
a1598 1
		    return FALSE;
d1611 1
a1611 1
		    return FALSE;
d1630 1
a1630 1
  return TRUE;
d1676 1
a1676 1
static bfd_boolean
d1704 1
a1704 1
    return TRUE;
d1808 1
a1808 1
  return TRUE;
d1818 1
a1818 1
     bfd_boolean force_local;
d1855 1
a1855 1
static bfd_boolean
d1899 1
a1899 1
      return TRUE;
d1914 1
a1914 1
      return TRUE;
d1925 1
a1925 1
    return TRUE;
d1930 1
a1930 1
    return TRUE;
d1945 1
a1945 1
      return TRUE;
d1983 1
a1983 1
	return FALSE;
d1993 1
a1993 1
  return TRUE;
d2000 1
a2000 1
static bfd_boolean
d2015 1
a2015 1
      return TRUE;
d2021 1
a2021 1
  return TRUE;
d2027 1
a2027 1
static bfd_boolean
d2037 1
a2037 1
    return TRUE;
d2063 1
a2063 1
	    return FALSE;
d2095 1
a2095 1
  return TRUE;
d2101 1
a2101 1
static bfd_boolean
d2113 1
a2113 1
    return TRUE;
d2144 1
a2144 1
	    return FALSE;
d2163 1
a2163 1
    return TRUE;
d2210 1
a2210 1
		return FALSE;
d2220 1
a2220 1
      return TRUE;
d2232 1
a2232 1
  return TRUE;
d2242 1
a2242 1
static bfd_boolean
d2253 1
a2253 1
      elf32_hppa_hide_symbol (info, h, TRUE);
d2255 1
a2255 1
  return TRUE;
d2260 1
a2260 1
static bfd_boolean
d2283 1
a2283 1
	  return FALSE;
d2286 1
a2286 1
  return TRUE;
d2291 1
a2291 1
static bfd_boolean
d2300 1
a2300 1
  bfd_boolean relocs;
d2436 1
a2436 1
  relocs = FALSE;
d2468 1
a2468 1
		relocs = TRUE;
d2500 1
a2500 1
	return FALSE;
d2513 1
a2513 1
	return FALSE;
d2523 1
a2523 1
	    return FALSE;
d2531 1
a2531 1
	    return FALSE;
d2539 1
a2539 1
	    return FALSE;
d2550 1
a2550 1
		return FALSE;
d2556 1
a2556 1
  return TRUE;
d2676 1
a2676 1
     bfd_boolean stubs_always_before_branch;
d2842 1
a2842 1
						      FALSE, FALSE);
d2875 1
a2875 1
bfd_boolean
d2881 1
a2881 1
     bfd_boolean multi_subspace;
d2887 2
a2888 2
  bfd_boolean stubs_always_before_branch;
  bfd_boolean stub_changed;
d2918 1
a2918 1
      return FALSE;
d2921 1
a2921 1
      stub_changed = FALSE;
d2925 1
a2925 1
      stub_changed = TRUE;
d3092 1
a3092 1
						      FALSE, FALSE);
d3118 1
a3118 1
		  stub_changed = TRUE;
d3144 1
a3144 1
      stub_changed = FALSE;
d3148 1
a3148 1
  return TRUE;
d3152 1
a3152 1
  return FALSE;
d3158 1
a3158 1
bfd_boolean
d3169 1
a3169 1
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", FALSE, FALSE, FALSE);
d3245 1
a3245 1
  return TRUE;
d3254 1
a3254 1
bfd_boolean
d3274 1
a3274 1
	return FALSE;
d3282 1
a3282 1
  return TRUE;
d3287 1
a3287 1
static bfd_boolean
d3294 1
a3294 1
    return FALSE;
d3597 1
a3597 1
static bfd_boolean
d3616 1
a3616 1
    return TRUE;
d3636 2
a3637 2
      bfd_boolean plabel;
      bfd_boolean warned_undef;
d3643 1
a3643 1
	  return FALSE;
d3654 1
a3654 1
      warned_undef = FALSE;
d3696 3
a3698 3
			 input_section, rel->r_offset, FALSE)))
		    return FALSE;
		  warned_undef = TRUE;
d3705 3
a3707 3
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      warned_undef = TRUE;
d3722 1
a3722 1
	    bfd_boolean do_got = 0;
d3728 1
a3728 1
		bfd_boolean dyn;
d3777 2
a3778 2
		    bfd_byte *loc;
		    asection *s = htab->srelgot;
d3785 2
a3786 2
		    loc = s->contents;
		    loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
d3817 1
a3817 1
	      bfd_boolean do_plt = 0;
d3867 2
a3868 2
		      bfd_byte *loc;
		      asection *s = htab->srelplt;
d3875 2
a3876 2
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
d3959 1
a3959 1
	      bfd_boolean skip;
d3961 1
a3961 1
	      bfd_byte *loc;
d4030 2
a4031 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
d4054 1
a4054 1
	    return FALSE;
d4073 1
a4073 1
	      return FALSE;
d4081 1
a4081 1
	    return FALSE;
d4085 1
a4085 1
  return TRUE;
d4091 1
a4091 1
static bfd_boolean
d4129 1
a4129 1
	  bfd_byte *loc;
d4148 2
a4149 2
	  loc = htab->srelplt->contents;
	  loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
d4174 1
a4174 1
      bfd_byte *loc;
d4207 2
a4208 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d4216 1
a4216 1
      bfd_byte *loc;
d4232 1
a4232 1
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
d4244 1
a4244 1
  return TRUE;
d4270 1
a4270 1
static bfd_boolean
d4317 4
a4320 1
	      dyn.d_un.d_val = s->_raw_size;
d4326 8
a4333 16
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
d4380 1
a4380 1
	      return FALSE;
d4385 1
a4385 1
  return TRUE;
@


1.89.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3419 4
a3422 5
       section.  If it has no section or if it's a code section, then
       "data pointer relative" makes no sense.  In that case we don't
       adjust the "value", and for 21 bit addil instructions, we change the
       source addend register from %dp to %r0.  This situation commonly
       arises for undefined weak symbols and when a variable's "constness"
d3425 3
a3427 1
      if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
@


1.89.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d11 1
a11 1
   This file is part of BFD, the Binary File Descriptor library.
d13 13
a25 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d114 1
a114 1
   :		be,n 0(%sr0,%rp)		; inter-space return.  */
d1688 4
d1701 4
d1708 46
a1753 4
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d1755 1
a1755 6
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf32_hppa_link_hash_entry *eh;
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;
d1757 19
a1775 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf32_hppa_link_hash_entry *) h;
d1777 7
a1783 8
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d1785 1
a1785 17
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1787 1
a1787 10
	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1789 14
a1802 14
	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  else if (local_plt_refcounts != NULL)
	    {
	      if (local_plt_refcounts[r_symndx] > 0)
		local_plt_refcounts[r_symndx] -= 1;
	    }
	  break;
d1804 3
a1806 4
	default:
	  break;
	}
    }
a2688 1
	  bfd_boolean big_sec;
a2694 2
	  big_sec = total >= stub_group_size;

d2722 2
a2723 5
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
d2904 5
a2908 16
      if (stubs_always_before_branch)
	{
	  stub_group_size = 7680000;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 240000;
	  if (htab->has_12bit_branch)
	    stub_group_size = 7500;
	}
      else
	{
	  stub_group_size = 6971392;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 217856;
	  if (htab->has_12bit_branch)
	    stub_group_size = 6808;
	}
d3691 8
a3698 5
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->elf.root.root.string, input_bfd,
		     input_section, rel->r_offset, FALSE)))
		return FALSE;
	      warned_undef = TRUE;
@


1.89.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2953 3
a2955 3
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
@


1.89.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1217 1
a1217 1
  if (info->relocatable)
d3596 1
a3596 1
  if (info->relocatable)
d3669 1
a3669 2
	  else if (info->shared
		   && !info->no_undefined
d3672 7
a3678 1
	    ;
@


1.89.10.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d206 4
d226 2
a227 2
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);
d282 124
d411 4
a414 3
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
d449 4
a452 3
hppa_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
d474 1
d486 2
a487 1
elf32_hppa_link_hash_table_create (bfd *abfd)
d492 1
a492 1
  ret = bfd_malloc (amt);
d531 2
a532 1
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *hash)
d544 5
a548 4
hppa_stub_name (const asection *input_section,
		const asection *sym_sec,
		const struct elf32_hppa_link_hash_entry *hash,
		const Elf_Internal_Rela *rel)
d585 6
a590 5
hppa_get_stub_entry (const asection *input_section,
		     const asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
		     struct elf32_hppa_link_hash_table *htab)
d631 4
a634 3
hppa_add_stub (const char *stub_name,
	       asection *section,
	       struct elf32_hppa_link_hash_table *htab)
d687 5
a691 5
hppa_type_of_stub (asection *input_sec,
		   const Elf_Internal_Rela *rel,
		   struct elf32_hppa_link_hash_entry *hash,
		   bfd_vma destination,
		   struct bfd_link_info *info)
d700 2
a701 5
      && hash->elf.dynindx != -1
      && !hash->plabel
      && (info->shared
	  || !(hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
	  || hash->elf.root.type == bfd_link_hash_defweak))
d780 3
a782 1
hppa_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d798 1
a798 1
  info = in_arg;
d820 1
a820 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel);
d824 1
a824 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel) >> 2;
d870 1
a870 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel),
d879 1
a879 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel);
d906 33
d1000 1
d1021 3
a1023 1
hppa_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d1031 1
a1031 1
  htab = in_arg;
d1055 2
a1056 1
elf32_hppa_object_p (bfd *abfd)
d1064 1
a1064 4
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
d1088 17
d1109 3
a1111 1
elf32_hppa_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d1149 3
a1151 3
elf32_hppa_copy_indirect_symbol (const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
d1203 5
a1207 4
elf32_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
d1257 3
d1425 2
a1426 1
		  local_got_refcounts = bfd_zalloc (abfd, size);
d1472 2
a1473 1
		      local_got_refcounts = bfd_zalloc (abfd, size);
d1607 3
a1609 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d1637 6
a1642 5
elf32_hppa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
d1677 5
a1681 4
elf32_hppa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
d1780 4
a1783 3
elf32_hppa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *h,
			bfd_boolean force_local)
d1821 3
a1823 2
elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
d1850 12
a1861 2
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1961 28
d1990 1
a1990 1
   ie. plabel entries.  */
d1993 3
a1995 1
allocate_plt_static (struct elf_link_hash_entry *h, void *inf)
d2007 1
a2007 1
  info = inf;
d2009 10
a2018 1
  if (htab->elf.dynamic_sections_created
d2067 3
a2069 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2083 1
a2083 1
  info = inf;
d2087 1
d2208 3
a2210 2
clobber_millicode_symbols (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info)
d2226 3
a2228 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2243 1
a2243 1
	  struct bfd_link_info *info = inf;
d2257 3
a2259 2
elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
d2289 8
d2392 1
a2392 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, info);
d2396 1
a2396 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d2463 1
a2463 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d2509 2
a2510 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d2531 3
a2533 1
elf32_hppa_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d2563 1
a2563 1
  htab->stub_group = bfd_zmalloc (amt);
d2580 1
a2580 1
  input_list = bfd_malloc (amt);
d2609 3
a2611 1
elf32_hppa_next_input_section (struct bfd_link_info *info, asection *isec)
d2638 4
a2641 3
group_sections (struct elf32_hppa_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
d2719 4
a2722 1
get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
d2733 1
a2733 1
  all_local_syms = bfd_zmalloc (amt);
d2847 9
a2855 5
elf32_hppa_size_stubs
  (bfd *output_bfd, bfd *stub_bfd, struct bfd_link_info *info,
   bfd_boolean multi_subspace, bfd_signed_vma group_size,
   asection * (*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
d2953 2
a2954 1
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
d3045 1
a3045 1
				 && info->unresolved_syms_in_objects == RM_IGNORE
d3060 1
a3060 1
						 destination, info);
d3141 3
a3143 1
elf32_hppa_set_gp (bfd *abfd, struct bfd_link_info *info)
d3237 2
a3238 1
elf32_hppa_build_stubs (struct bfd_link_info *info)
d3254 1
a3254 1
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
d3270 3
a3272 1
elf32_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
d3286 4
a3289 3
hppa_record_segment_addr (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *section,
			  void *data)
d3315 8
a3322 8
final_link_relocate (asection *input_section,
		     bfd_byte *contents,
		     const Elf_Internal_Rela *rel,
		     bfd_vma value,
		     struct elf32_hppa_link_hash_table *htab,
		     asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *h,
		     struct bfd_link_info *info)
a3325 1
  unsigned int orig_r_type = r_type;
a3347 20
  /* If we are not building a shared library, convert DLTIND relocs to
     DPREL relocs.  */
  if (!info->shared)
    {
      switch (r_type)
        {
          case R_PARISC_DLTIND21L:
            r_type = R_PARISC_DPREL21L;
	    break;

          case R_PARISC_DLTIND14R:
            r_type = R_PARISC_DPREL14R;
	    break;

          case R_PARISC_DLTIND14F:
            r_type = R_PARISC_DPREL14F;
	    break;
	}
    }

d3359 2
a3360 5
	      && h->elf.dynindx != -1
	      && !h->plabel
	      && (info->shared
		  || !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  || h->elf.root.type == bfd_link_hash_defweak)))
a3399 32
      /* Convert instructions that use the linkage table pointer (r19) to
	 instructions that use the global data pointer (dp).  This is the
	 most efficient way of using PIC code in an incomplete executable,
	 but the user must follow the standard runtime conventions for
	 accessing data for this to work.  */
      if (orig_r_type == R_PARISC_DLTIND21L)
	{
	  /* Convert addil instructions if the original reloc was a
	     DLTIND21L.  GCC sometimes uses a register other than r19 for
	     the operation, so we must convert any addil instruction
	     that uses this relocation.  */
	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
	    insn = ADDIL_DP;
	  else
	    /* We must have a ldil instruction.  It's too hard to find
	       and convert the associated add instruction, so issue an
	       error.  */
	    (*_bfd_error_handler)
              (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       howto->name,
	       insn);
	}
      else if (orig_r_type == R_PARISC_DLTIND14F)
	{
	  /* This must be a format 1 load/store.  Change the base
	     register to dp.  */
	  insn = (insn & 0xfc1ffff) | (27 << 21);
	}

d3579 10
a3588 8
elf32_hppa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
d3645 1
a3645 2
	  struct elf_link_hash_entry *hh;
	  bfd_boolean unresolved_reloc;
d3647 34
a3680 22
	  RELOC_FOR_GLOBAL_SYMBOL (hh, elf_sym_hashes (input_bfd), r_symndx, symtab_hdr,
				   relocation, sym_sec, unresolved_reloc, info,
				   warned_undef);

	  if (relocation == 0
	      && hh->root.type != bfd_link_hash_defined
	      && hh->root.type != bfd_link_hash_defweak
	      && hh->root.type != bfd_link_hash_undefweak)
	    {  
	      if (!info->executable
		  && info->unresolved_syms_in_objects == RM_IGNORE
		  && ELF_ST_VISIBILITY (hh->other) == STV_DEFAULT
		  && hh->type == STT_PARISC_MILLI)
		{
		  if (! info->callbacks->undefined_symbol
		      (info, hh->root.root.string, input_bfd,
		       input_section, rel->r_offset,
		       ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
			|| (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR))))
		    return FALSE;
		  warned_undef = TRUE;
		}
a3681 1
	  h = (struct elf32_hppa_link_hash_entry *) hh;
d4014 1
a4014 1
			       htab, sym_sec, h, info);
d4052 2
a4053 2
		(info, sym_name, howto->name, 0, input_bfd, input_section,
		 rel->r_offset)))
d4065 5
a4069 4
elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
a4071 2
  Elf_Internal_Rela rel;
  bfd_byte *loc;
d4099 1
a4099 5
      /* Create a dynamic IPLT relocation for this entry.  */
      rel.r_offset = (h->plt.offset
		      + htab->splt->output_offset
		      + htab->splt->output_section->vma);
      if (h->dynindx != -1)
d4101 24
a4124 2
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
d4128 6
a4133 4
	  /* This symbol has been marked to become local, and is
	     used by a plabel so must be kept in the .plt.  */
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rel.r_addend = value;
a4135 4
      loc = htab->srelplt->contents;
      loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rel, loc);

d4146 3
d4174 2
a4175 1
	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + h->got.offset);
d4188 2
d4224 2
a4225 1
elf32_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
d4244 3
a4246 2
elf32_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
d4324 3
a4326 1
		  sdyn ? sdyn->output_section->vma + sdyn->output_offset : 0,
d4369 3
a4371 2
elf32_hppa_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
d4390 3
a4392 1
elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
d4410 1
@


1.89.10.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a143 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d1006 1
a1006 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1335 1
a1335 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1626 2
a1668 4
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1687 2
a1688 1
  if (ELIMINATE_COPY_RELOCS)
d1690 4
a1693 2
      struct elf32_hppa_link_hash_entry *eh;
      struct elf32_hppa_dyn_reloc_entry *p;
d1695 6
a1700 15
      eh = (struct elf32_hppa_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1886 3
a1888 1
      if (SYMBOL_CALLS_LOCAL (info, h))
a1902 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1910 1
a1910 2
	  && ((ELIMINATE_COPY_RELOCS
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d2019 1
a2019 1
      if (info->executable)
d3070 3
a3072 3
	{
	  case R_PARISC_DLTIND21L:
	    r_type = R_PARISC_DPREL21L;
d3075 2
a3076 2
	  case R_PARISC_DLTIND14R:
	    r_type = R_PARISC_DPREL14R;
d3079 2
a3080 2
	  case R_PARISC_DLTIND14F:
	    r_type = R_PARISC_DPREL14F;
d3158 1
a3158 1
	      (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
d3411 1
a3411 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
d3426 1
a3426 1
	    {
a3673 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
d3675 5
a3679 1
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
d3684 2
a3685 3
		  && ((ELIMINATE_COPY_RELOCS
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0
a3741 5
		      /* Skip this relocation if the output section has
			 been discarded.  */
		      if (bfd_is_abs_section (sym_sec->output_section))
			break;

@


1.89.10.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1021 1
a1021 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d2307 3
d2913 15
a2927 2
      asection *splt = bfd_get_section_by_name (abfd, ".plt");
      asection *sgot = bfd_get_section_by_name (abfd, ".got");
@


1.88
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d330 2
a331 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d1149 2
a1150 1
elf32_hppa_copy_indirect_symbol (dir, ind)
d1194 1
a1194 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.87
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d3613 3
d3647 1
a3648 20

      if (info->relocateable)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
	    }
	  continue;
	}

      /* This is a final link.  */
d4456 1
@


1.87.2.1
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d330 1
a330 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1148 1
a1148 2
elf32_hppa_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d1192 1
a1192 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.86
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a2772 5
      Elf_Internal_Shdr *shndx_hdr;
      Elf_Internal_Sym *isym;
      Elf32_External_Sym *ext_syms, *esym, *end_sy;
      Elf_External_Sym_Shndx *shndx_buf, *shndx;
      bfd_size_type sec_size;
d2779 10
a2788 5
      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      sec_size = symtab_hdr->sh_info;
      sec_size *= sizeof (Elf_Internal_Sym);
      local_syms = (Elf_Internal_Sym *) bfd_malloc (sec_size);
a2792 43
      sec_size = symtab_hdr->sh_info;
      sec_size *= sizeof (Elf32_External_Sym);
      ext_syms = (Elf32_External_Sym *) bfd_malloc (sec_size);
      if (ext_syms == NULL)
	return -1;

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) ext_syms, sec_size, input_bfd) != sec_size)
	{
	error_ret_free_ext_syms:
	  free (ext_syms);
	  return -1;
	}

      shndx_buf = NULL;
      shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
      if (shndx_hdr->sh_size != 0)
	{
	  sec_size = symtab_hdr->sh_info;
	  sec_size *= sizeof (Elf_External_Sym_Shndx);
	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (sec_size);
	  if (shndx_buf == NULL)
	    goto error_ret_free_ext_syms;

	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) shndx_buf, sec_size, input_bfd) != sec_size)
	    {
	      free (shndx_buf);
	      goto error_ret_free_ext_syms;
	    }
	}

      /* Swap the local symbols in.  */
      for (esym = ext_syms, end_sy = esym + symtab_hdr->sh_info,
	     isym = local_syms, shndx = shndx_buf;
	   esym < end_sy;
	   esym++, isym++, shndx = (shndx ? shndx + 1 : NULL))
	bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);

      /* Now we can free the external symbols.  */
      free (shndx_buf);
      free (ext_syms);
a2886 1
  boolean ret = 0;
d3145 2
a3146 1
  ret = true;
a3148 3
  while (htab->bfd_count-- > 0)
    if (htab->all_local_syms[htab->bfd_count])
      free (htab->all_local_syms[htab->bfd_count]);
d3150 1
a3150 2

  return ret;
@


1.85
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d337 1
a337 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d1635 2
a1636 2
elf32_hppa_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d1666 1
a1666 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
a2996 2
	      Elf_Internal_Shdr *input_rel_hdr;
	      Elf32_External_Rela *external_relocs, *erelaend, *erela;
a2997 1
	      bfd_size_type amt;
d3011 5
a3015 13
	      /* Allocate space for the external relocations.  */
	      amt = section->reloc_count;
	      amt *= sizeof (Elf32_External_Rela);
	      external_relocs = (Elf32_External_Rela *) bfd_malloc (amt);
	      if (external_relocs == NULL)
		{
		  goto error_ret_free_local;
		}

	      /* Likewise for the internal relocations.  */
	      amt = section->reloc_count;
	      amt *= sizeof (Elf_Internal_Rela);
	      internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
d3017 1
a3017 27
		{
		  free (external_relocs);
		  goto error_ret_free_local;
		}

	      /* Read in the external relocs.  */
	      input_rel_hdr = &elf_section_data (section)->rel_hdr;
	      if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) external_relocs,
				input_rel_hdr->sh_size,
				input_bfd) != input_rel_hdr->sh_size)
		{
		  free (external_relocs);
		error_ret_free_internal:
		  free (internal_relocs);
		  goto error_ret_free_local;
		}

	      /* Swap in the relocs.  */
	      erela = external_relocs;
	      erelaend = erela + section->reloc_count;
	      irela = internal_relocs;
	      for (; erela < erelaend; erela++, irela++)
		bfd_elf32_swap_reloca_in (input_bfd, erela, irela);

	      /* We're done with the external relocs, free them.  */
	      free (external_relocs);
d3040 4
a3043 1
		      goto error_ret_free_internal;
d3146 1
a3146 1
		      goto error_ret_free_local;
d3164 2
a3165 1
	      free (internal_relocs);
@


1.84
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d646 1
d650 2
a651 1
	  len = strlen (link_sec->name) + sizeof (STUB_SUFFIX);
d656 2
a657 2
	  strcpy (s_name, link_sec->name);
	  strcpy (s_name + len - sizeof (STUB_SUFFIX), STUB_SUFFIX);
@


1.83
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2830 2
a2831 2
	bfd_elf32_swap_symbol_in (input_bfd, (const PTR *) esym,
				  (const PTR *) shndx, isym);
@


1.82
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2830 2
a2831 1
	bfd_elf32_swap_symbol_in (input_bfd, esym, shndx, isym);
@


1.81
log
@	* elf32-hppa.c (elf32_hppa_size_stubs): Revert part of 2002-05-04,
	don't look for stubs on all undefined syms.
@
text
@d2561 1
a2561 1
   0 when no stubs will be needed, and 1 on success. */
@


1.81.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2561 1
a2561 1
   0 when no stubs will be needed, and 1 on success.  */
d2830 1
a2830 2
	bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);
@


1.81.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d337 1
a337 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
a645 1
	  size_t namelen;
d649 1
a649 2
	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
d654 2
a655 2
	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
d1633 2
a1634 2
elf32_hppa_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d1664 3
a1666 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d2773 5
d2784 5
a2788 2
      /* We need an array of the local symbols attached to the input bfd.  */
      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
d2790 11
d2802 3
a2804 5
	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					     symtab_hdr->sh_info, 0,
					     NULL, NULL, NULL);
	  /* Cache them for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) local_syms;
a2805 2
      if (local_syms == NULL)
	return -1;
d2807 29
a2835 1
      all_local_syms[bfd_indx] = local_syms;
d2930 1
d2997 2
d3000 1
d3014 13
a3026 5
	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf32_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
d3028 27
a3054 1
		goto error_ret_free_local;
d3077 1
a3077 4
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
d3180 1
a3180 1
		      goto error_ret_free_internal;
d3198 1
a3198 2
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
d3222 1
a3222 2
  free (htab->all_local_syms);
  return true;
d3225 3
d3229 2
a3230 1
  return false;
@


1.81.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a3612 3
  if (info->relocateable)
    return true;

d3644 20
a3664 1
      r_symndx = ELF32_R_SYM (rel->r_info);
a4471 1
#define elf_backend_rela_normal		     1
@


1.81.4.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d330 1
a330 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1148 1
a1148 2
elf32_hppa_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d1192 1
a1192 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.81.2.1
log
@merge from trunk
@
text
@d2561 1
a2561 1
   0 when no stubs will be needed, and 1 on success.  */
d2830 1
a2830 2
	bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);
@


1.80
log
@	* elf32-hppa.c (struct elf32_hppa_link_hash_table): Add
	bfd_count top_index, input_list, all_local_syms.
	(elf32_hppa_setup_section_lists): New function, split from
	elf32_hppa_size_stubs.
	(elf32_hppa_next_input_section): Likewise.
	(group_sections): Likewise.
	(get_local_syms): Likewise.
	(elf32_hppa_size_stubs): Adjust for split out functions.  Look for
	stubs on undefined syms too.
	(elf32_hppa_set_gp): Use bfd_link_hash* instead of elf_link_hash*.
	Only access htab elf fields when we have and elf hash table.
	* elf32-hppa.h (elf32_hppa_setup_section_lists): Declare.
	(elf32_hppa_next_input_section): Declare.
@
text
@d3131 4
a3134 1
			;
d3136 8
a3143 1
			;
@


1.79
log
@	* elf64-x86-64.c (struct elf64_x86_64_dyn_relocs): Comment typo.
	* elf32-hppa.c (elf32_hppa_final_link): Formatting.
@
text
@d239 6
d368 6
d2559 3
a2561 5
/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */
d2563 2
a2564 3
boolean
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
a2565 1
     bfd *stub_bfd;
a2566 4
     boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d2569 2
a2572 8
  Elf_Internal_Sym *local_syms, **all_local_syms;
  unsigned int bfd_indx, bfd_count;
  int top_id, top_index;
  struct elf32_hppa_link_hash_table *htab;
  bfd_size_type stub_group_size;
  boolean stubs_always_before_branch;
  boolean stub_changed = 0;
  boolean ret = 0;
d2574 1
d2576 2
a2577 21
  htab = hppa_link_hash_table (info);

  /* Stash our params away.  */
  htab->stub_bfd = stub_bfd;
  htab->multi_subspace = multi_subspace;
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      stub_group_size = 7680000;
      if (htab->has_17bit_branch || htab->multi_subspace)
	stub_group_size = 240000;
      if (htab->has_12bit_branch)
	stub_group_size = 7500;
    }
d2593 1
d2598 1
a2598 4
    return false;

  /* Make a list of input sections for each output section included in
     the link.
d2600 1
a2600 1
     We can't use output_bfd->section_count here to find the top output
d2611 1
d2614 1
d2616 1
a2616 1
    return false;
d2633 16
a2648 4
  /* Now actually build the lists.  */
  for (input_bfd = info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
d2650 2
a2651 3
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
d2653 1
a2653 8
	  if (section->output_section != NULL
	      && section->output_section->owner == output_bfd
	      && section->output_section->index <= top_index)
	    {
	      list = input_list + section->output_section->index;
	      if (*list != bfd_abs_section_ptr)
		{
		  /* Steal the link_sec pointer for our list.  */
d2655 4
a2658 6
		  /* This happens to make the list in reverse order,
		     which is what we want.  */
		  PREV_SEC (section) = *list;
		  *list = section;
		}
	    }
d2661 8
d2670 7
a2676 7
  /* See whether we can group stub sections together.  Grouping stub
     sections may result in fewer stubs.  More importantly, we need to
     put all .init* and .fini* stubs at the beginning of the .init or
     .fini output sections respectively, because glibc splits the
     _init and _fini functions into multiple parts.  Putting a stub in
     the middle of a function is not a good idea.  */
  list = input_list + top_index;
d2736 2
a2737 2
  while (list-- != input_list);
  free (input_list);
d2739 16
d2759 1
a2759 1
  amt = sizeof (Elf_Internal_Sym *) * bfd_count;
d2761 1
d2763 1
a2763 1
    return false;
d2768 1
a2768 1
  for (input_bfd = info->input_bfds, bfd_indx = 0;
d2790 1
a2790 1
	goto error_ret_free_local;
d2797 1
a2797 1
	goto error_ret_free_local;
d2804 1
a2804 1
	  goto error_ret_free_local;
d2887 1
a2887 1
			goto error_ret_free_local;
d2906 64
d2972 2
d2981 2
d2989 1
a2989 1
	  local_syms = all_local_syms[bfd_indx];
d2999 1
d3131 1
a3131 4
			{
			  if (! info->shared)
			    continue;
			}
d3133 1
a3133 8
			{
			  if (! (info->shared
				 && !info->no_undefined
				 && (ELF_ST_VISIBILITY (hash->elf.other)
				     == STV_DEFAULT)
				 && hash->elf.type != STT_PARISC_MILLI))
			    continue;
			}
d3183 1
a3183 1
		  stub_changed = 1;
d3208 1
a3208 1
      stub_changed = 0;
d3211 1
a3211 1
  ret = 1;
d3214 4
a3217 4
  while (bfd_count-- > 0)
    if (all_local_syms[bfd_count])
      free (all_local_syms[bfd_count]);
  free (all_local_syms);
d3230 3
a3233 3
  struct elf_link_hash_entry *h;
  asection *sec;
  bfd_vma gp_val;
d3236 1
a3236 1
  h = elf_link_hash_lookup (&htab->elf, "$global$", false, false, false);
d3239 2
a3240 2
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak))
d3242 2
a3243 2
      gp_val = h->root.u.def.value;
      sec = h->root.u.def.section;
d3247 16
d3271 1
a3271 2

      sec = htab->splt;
d3275 1
a3275 2
	  if (gp_val > 0x2000
	      || (htab->sgot && htab->sgot->_raw_size > 0x2000))
d3282 1
a3282 2
	  gp_val = 0;
	  sec = htab->sgot;
d3299 2
a3300 2
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.value = gp_val;
d3302 1
a3302 1
	    h->root.u.def.section = sec;
d3304 1
a3304 1
	    h->root.u.def.section = bfd_abs_section_ptr;
@


1.78
log
@	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.

	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.
@
text
@d3285 1
a3285 1
     unwind section. */
@


1.77
log
@	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@a205 3
  /* Set during a static link if we detect a function is PIC.  */
  unsigned int maybe_pic_call:1;

d255 1
a255 1
  /* Flags set when PCREL12F and PCREL17F branches detected.  Used to
d259 1
a460 1
      eh->maybe_pic_call = 0;
d508 1
d684 6
a689 15
      && (((hash->elf.root.type == bfd_link_hash_defined
	    || hash->elf.root.type == bfd_link_hash_defweak)
	   && hash->elf.root.u.def.section->output_section == NULL)
	  || (hash->elf.root.type == bfd_link_hash_defweak
	      && hash->elf.dynindx != -1
	      && hash->elf.plt.offset != (bfd_vma) -1)
	  || hash->elf.root.type == bfd_link_hash_undefweak
	  || hash->elf.root.type == bfd_link_hash_undefined
	  || (hash->maybe_pic_call && !(input_sec->flags & SEC_HAS_GOT_REF))))
    {
      /* If output_section is NULL, then it's a symbol defined in a
	 shared library.  We will need an import stub.  Decide between
	 hppa_stub_import and hppa_stub_import_shared later.  For
	 shared links we need stubs for undefined or weak syms too;
	 They will presumably be resolved by the dynamic linker.  */
d747 1
d937 3
a939 1
      if (sym_value - 8 + 0x40000 >= 0x80000)
d952 4
a955 1
      insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
d1274 2
a1275 1
	  /* Fall thru.  */
d1279 2
a1280 1
	  /* Fall thru.  */
d1282 2
d1337 1
a1337 1
#if 1
d1853 1
a1853 2
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
a1856 8
      if (!info->shared
	  && h->plt.refcount > 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	{
	  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
	}

d1873 4
a1876 1
	  if (((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call)
a2004 1
  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
d2034 1
d2054 5
a2058 1
	  /* Allocate these later.  */
d2109 1
a2109 1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d3359 2
a3360 5
      /* If this is a call to a function defined in another dynamic
	 library, or if it is a call to a PIC function in the same
	 object, or if this is a shared link and it is a call to a
	 weak symbol which may or may not be in the same object, then
	 find the import stub in the stub hash.  */
d3364 3
a3366 5
	      && ((h->maybe_pic_call
		   && !(input_section->flags & SEC_HAS_GOT_REF))
		  || (h->elf.root.type == bfd_link_hash_defweak
		      && h->elf.dynindx != -1
		      && h->elf.plt.offset != (bfd_vma) -1))))
d3421 1
a3421 1
#if 1 /* debug them.  */
@


1.76
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d74 1
a74 1
   :            bv %r0(%r21)
d81 1
a81 1
   :            bv %r0(%r21)
a378 3
static int hppa_unwind_entry_compare
  PARAMS ((const PTR, const PTR));

d1934 1
a1934 1
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */ 
a3282 2
  asection *s;

d3288 2
a3289 24
     unwind section.  Magic section names, but this is much safer than
     having elf32_hppa_relocate_section remember where SEGREL32 relocs
     occurred.  Consider what happens if someone inept creates a
     linker script that puts unwind information in .text.  */
  s = bfd_get_section_by_name (abfd, ".PARISC.unwind");
  if (s != NULL)
    {
      bfd_size_type size;
      char *contents;

      size = s->_raw_size;
      contents = bfd_malloc (size);
      if (contents == NULL)
	return false;

      if (! bfd_get_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;

      qsort (contents, (size_t) (size / 16), 16, hppa_unwind_entry_compare);

      if (! bfd_set_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;
    }
  return true;
a4097 26
}

/* Comparison function for qsort to sort unwind section during a
   final link.  */

static int
hppa_unwind_entry_compare (a, b)
     const PTR a;
     const PTR b;
{
  const bfd_byte *ap, *bp;
  unsigned long av, bv;

  ap = (const bfd_byte *) a;
  av = (unsigned long) ap[0] << 24;
  av |= (unsigned long) ap[1] << 16;
  av |= (unsigned long) ap[2] << 8;
  av |= (unsigned long) ap[3];

  bp = (const bfd_byte *) b;
  bv = (unsigned long) bp[0] << 24;
  bv |= (unsigned long) bp[1] << 16;
  bv |= (unsigned long) bp[2] << 8;
  bv |= (unsigned long) bp[3];

  return av < bv ? -1 : av > bv ? 1 : 0;
@


1.75
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d287 3
d485 1
a485 1
  ret = (struct elf32_hppa_link_hash_table *) bfd_alloc (abfd, amt);
d491 1
a491 1
      bfd_release (abfd, ret);
d520 13
d4496 1
@


1.74
log
@2002-02-26  John David Anglin  <dave@@hiauly1.hia.nrc.ca>

	* bfd/elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* bfd/elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.
@
text
@d1985 3
d2017 1
a2017 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d2020 3
d2088 1
a2088 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d2091 3
d2223 3
d2243 3
@


1.73
log
@	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
@
text
@d3474 6
a3480 1
    case R_PARISC_PCREL21L:
a3481 2
    case R_PARISC_PLABEL21L:
    case R_PARISC_DLTIND21L:
a3484 1
    case R_PARISC_DIR17R:
a3485 1
    case R_PARISC_DIR14R:
a3486 1
    case R_PARISC_DPREL14R:
d3489 6
@


1.72
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a2219 4

      /* ?!? We only want to remove these from the dynamic symbol table.
	 Therefore we do not leave ELF_LINK_FORCED_LOCAL set.  */
      h->elf_link_hash_flags &= ~ELF_LINK_FORCED_LOCAL;
@


1.71
log
@	* elf-hppa.h (elf_hppa_reloc_final_type): New function stripped
	from _bfd_elf_hppa_gen_reloc_type.
	(_bfd_elf_hppa_gen_reloc_type): Remove duplicate prototype.
	* elf32-hppa.h (elf32_hppa_reloc_final_type): Add protptype.
	* elf32-hppa.c: Include elf32-hppa.h before elf-hppa.h.
	* elf64-hppa.h (elf64_hppa_reloc_final_type): Add protptype.
@
text
@d3979 2
a3980 1
	      skip = (outrel.r_offset == (bfd_vma) -1);
@


1.70
log
@	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Check for relocs
	against section syms in readonly sections.  Don't do the global
	sym check if we find one.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_grok_prstatus): Add missing prototype.
@
text
@d35 1
a36 1
#include "elf32-hppa.h"
@


1.70.2.1
log
@John David Anglin's 2002-02-12 mainline changes
@
text
@d35 1
a36 1
#include "elf-hppa.h"
@


1.70.2.2
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3979 1
a3979 2
	      skip = (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2);
@


1.70.2.3
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d2220 4
d3478 1
a3478 1
    case R_PARISC_DLTIND21L:
d3480 1
d3482 1
a3482 5
      r_field = e_lsel;
      break;

    case R_PARISC_DIR21L:
    case R_PARISC_DPREL21L:
d3486 1
d3488 1
d3490 1
a3492 6
      r_field = e_rsel;
      break;

    case R_PARISC_DIR17R:
    case R_PARISC_DIR14R:
    case R_PARISC_DPREL14R:
@


1.70.2.4
log
@Merge from mainline.
@
text
@a1984 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d2014 2
a2015 1
  if (h->root.type == bfd_link_hash_indirect)
a2017 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d2083 2
a2084 1
  if (h->root.type == bfd_link_hash_indirect)
a2086 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a2215 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a2232 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.70.2.5
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d74 1
a74 1
   :		bv %r0(%r21)
d81 1
a81 1
   :		bv %r0(%r21)
d206 3
d258 1
a258 1
  /* Flags set when various size branches are detected.  Used to
a261 1
  unsigned int has_22bit_branch:1;
d376 3
d463 1
a510 1
  ret->has_22bit_branch = 0;
d673 15
a687 6
      && hash->elf.plt.offset != (bfd_vma) -1
      && (hash->elf.dynindx != -1 || hash->pic_call)
      && !hash->plabel)
    {
      /* We need an import stub.  Decide between hppa_stub_import
	 and hppa_stub_import_shared later.  */
a744 1
#define BL22_RP		0xe800a002	/* b,l,n XXX,%rp		*/
d934 1
a934 3
      if (sym_value - 8 + (1 << (17 + 1)) >= (1 << (17 + 2))
	  && (!htab->has_22bit_branch
	      || sym_value - 8 + (1 << (22 + 1)) >= (1 << (22 + 2))))
d947 1
a947 4
      if (!htab->has_22bit_branch)
	insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
      else
	insn = hppa_rebuild_insn ((int) BL22_RP, val, 22);
d1266 1
a1266 2
	  goto branch_common;

d1270 1
a1270 2
	  goto branch_common;

a1271 2
	  htab->has_22bit_branch = 1;
	branch_common:
d1325 1
a1325 1
#if 0
d1841 2
a1842 1
     will fill in the contents of the procedure linkage table later.  */
d1846 8
d1870 1
a1870 4
	  if (!info->shared
	      && h->plt.refcount > 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
d1921 1
a1921 1
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
d1999 1
a2028 1
      ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
d2048 1
a2048 5
	  /* Allocate these later.  From this point on, h->plabel
	     means that the plt entry is only used by a plabel.
	     We'll be using a normal plt entry for this symbol, so
	     clear the plabel indicator.  */
	  ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
d2099 1
a2099 1
      && !((struct elf32_hppa_link_hash_entry *) h)->plabel)
d3270 2
d3277 24
a3300 2
     unwind section.  */
  return elf_hppa_sort_unwind (abfd);
d3373 5
a3377 2
      /* If this call should go via the plt, find the import stub in
	 the stub hash.  */
d3381 5
a3385 3
	      && h->elf.plt.offset != (bfd_vma) -1
	      && (h->elf.dynindx != -1 || h->pic_call)
	      && !h->plabel))
d3440 1
a3440 1
#if 0 /* debug them.  */
d4109 26
@


1.69
log
@	* elf-bfd.h (elf_backend_data <elf_backend_hide_symbol>): Add
	boolean param.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_hide_symbol.
	(elf_fix_symbol_flags): Likewise.
	(elf_link_assign_sym_version): Likewise. Use bfd_malloc rather
	than bfd_alloc.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Add "force_local" param.
	Set ELF_LINK_FORCED_LOCAL and call _bfd_elf_strtab_delref.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	(clobber_millicode_symbols): Adjust to suit new hide_symbol.
	* elf32-cris.c (elf_cris_hide_symbol): Add "force_local" param
	and adjust to suit.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise, and call
	_bfd_elf_link_hash_hide_symbol rather than duplicating code.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.
@
text
@d2332 1
a2332 1
	      else
d2336 2
d2510 3
a2512 1
	  elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, (PTR) info);
@


1.68
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
d338 1
a338 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d1789 2
a1790 2
elf32_hppa_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1792 1
d1794 11
a1804 2
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
d2219 1
a2219 6
      struct elf32_hppa_link_hash_table *htab;

      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      elf32_hppa_hide_symbol (info, h);
      htab = hppa_link_hash_table (info);
      _bfd_elf_strtab_delref (htab->elf.dynstr, h->dynstr_index);
@


1.67
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d1641 1
a1641 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
d2738 1
d2741 1
d2755 2
a2756 3
	{
	  goto error_ret_free_local;
	}
d2762 1
a2762 3
	{
	  goto error_ret_free_local;
	}
d2765 1
a2765 1
	  || (bfd_bread (ext_syms, sec_size, input_bfd) != sec_size))
d2767 1
d2772 18
d2791 5
a2795 4
      isym = local_syms;
      esym = ext_syms;
      for (end_sy = esym + symtab_hdr->sh_info; esym < end_sy; esym++, isym++)
	bfd_elf32_swap_symbol_in (input_bfd, esym, isym);
d2798 1
d2931 3
a2933 3
		  || bfd_bread (external_relocs,
			       input_rel_hdr->sh_size,
			       input_bfd) != input_rel_hdr->sh_size)
@


1.66
log
@	* elf32-hppa.c (clobber_millicode_symbols): Don't do anything if
	already forced local.
@
text
@a3951 1
	      outrel.r_offset = rel->r_offset;
d3953 4
a3956 15
	      skip = false;
	      if (elf_section_data (input_section)->stab_info != NULL)
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &htab->elf.stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

@


1.65
log
@	* elf32-hppa.c (hppa_get_stub_entry): Remove debug message that
	happens to trigger on undefined symbols.
	(final_link_relocate): Return bfd_reloc_undefined for undefined
	stubs.
	(elf32_hppa_relocate_section): Don't say we can't handle a reloc
	if we have already warned about an undefined symbol.
@
text
@d2212 2
a2213 3
  /* We only want to remove these from the dynamic symbol table.
     Therefore we do not leave ELF_LINK_FORCED_LOCAL set.  */
  if (h->type == STT_PARISC_MILLI)
a2215 1
      unsigned short oldflags = h->elf_link_hash_flags;
d2221 3
a2224 1
      h->elf_link_hash_flags |= oldflags & ELF_LINK_FORCED_LOCAL;
@


1.64
log
@	* elf32-hppa.c (elf32_hppa_size_stubs): Decrease default stub
	group sizes to accomodate c++.
@
text
@d594 2
a595 14
      if (stub_entry == NULL)
	{
	  if (hash == NULL || hash->elf.root.type != bfd_link_hash_undefweak)
	    (*_bfd_error_handler) (_("%s(%s+0x%lx): cannot find stub entry %s"),
				   bfd_archive_filename (input_section->owner),
				   input_section->name,
				   (long) rel->r_offset,
				   stub_name);
	}
      else
	{
	  if (hash != NULL)
	    hash->stub_cache = stub_entry;
	}
d3376 1
a3376 1
	    return bfd_reloc_notsupported;
d3504 1
a3504 1
	    return bfd_reloc_notsupported;
d3603 1
d3639 1
d3678 7
a3684 4
		if (!((*info->callbacks->undefined_symbol)
		      (info, h->elf.root.root.string, input_bfd,
		       input_section, rel->r_offset, false)))
		  return false;
d3692 1
d4059 12
a4070 9
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): cannot handle %s for %s"),
	     bfd_archive_filename (input_bfd),
	     input_section->name,
	     (long) rel->r_offset,
	     howto->name,
	     sym_name);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
@


1.63
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d2582 1
a2582 1
      stub_group_size = 8000000;
d2584 1
a2584 1
	stub_group_size = 250000;
d2586 1
a2586 1
	stub_group_size = 7812;
d2699 1
a2699 1
	     than 250000 bytes and thus can be handled by one stub
d2701 1
a2701 1
	     250000 bytes, in which case we may be toast.)
d2705 6
a2710 4
	     only break if stubs added total more than 12144 bytes, or
	     1518 long branch stubs.  It seems unlikely for more than
	     1518 different functions to be called, especially from
	     code only 250000 bytes long.  */
d2719 1
a2719 1
	  /* But wait, there's more!  Input sections up to 250000
@


1.62
log
@	* elf32-hppa.c (clobber_millicode_symbols): Dec dynstr refcount.
@
text
@d3653 1
a3653 4
	  relocation = ((ELF_ST_TYPE (sym->st_info) == STT_SECTION
			   ? 0 : sym->st_value)
			 + sym_sec->output_offset
			 + sym_sec->output_section->vma);
@


1.61
log
@	* elf32-hppa.c (elf32_hppa_size_stubs): Don't consider undefined
	millicode syms as candidates for import stubs.
@
text
@d2228 1
d2230 1
d2233 2
@


1.60
log
@	* elf32-hppa.c (PLABEL_PLT_ENTRY_SIZE): Delete.
	(allocate_PIC_calls): Rename to allocate_plt_static.
	(allocate_dynrelocs): Move most of code handling .plt entries to..
	(allocate_plt_static): ..here.  Don't drop plabel entries.
@
text
@d3028 2
a3029 1
				     == STV_DEFAULT)))
@


1.59
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@a116 1
#define PLABEL_PLT_ENTRY_SIZE PLT_ENTRY_SIZE
d346 1
a346 1
static boolean allocate_PIC_calls
d2010 2
a2011 1
/* Allocate space in the .plt for pic_call entries.  */
d2014 1
a2014 1
allocate_PIC_calls (h, inf)
d2030 2
a2031 1
      /* Make an entry in the .plt section.  */
d2034 10
a2043 3
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2045 15
a2059 2
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
d2062 10
a2071 1
	s->_raw_size += PLT_ENTRY_SIZE;
d2097 4
a2100 3
  if ((htab->elf.dynamic_sections_created
       && h->plt.refcount > 0)
      || ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
d2102 4
a2105 29
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI
	  && !((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      if (((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  /* Already handled by allocate_PIC_calls.  */
	}
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  /* Make an entry in the .plt section.  */
	  s = htab->splt;
	  h->plt.offset = s->_raw_size;
	  if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	      && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      /* Add some extra space for the dynamic linker to use.  */
	      s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
	    }
	  else
	    s->_raw_size += PLT_ENTRY_SIZE;
d2107 3
a2109 14
	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  htab->need_plt_stub = 1;
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d2398 4
a2401 2
  if (! info->shared)
    elf_link_hash_traverse (&htab->elf, allocate_PIC_calls, (PTR) info);
@


1.58
log
@	* elf32-hppa.c (hppa_handle_PIC_calls): Rename to mark_PIC_calls.
	(allocate_PIC_calls): New function.
	(allocate_dynrelocs): Don't allocate pic_call plt entries here.
	(elf32_hppa_size_dynamic_sections): Call allocate_PIC_calls.
	(elf32_hppa_finish_dynamic_symbol): Remove dead code.
@
text
@d266 3
d513 1
d1521 3
d1571 13
a1583 1
		  struct elf32_hppa_dyn_reloc_entry *p;
d1585 16
a1600 12
		  p = h->dyn_relocs;
		  if (p == NULL || p->sec != sec)
		    {
		      p = ((struct elf32_hppa_dyn_reloc_entry *)
			   bfd_alloc (htab->elf.dynobj,
				      (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return false;
		      p->next = h->dyn_relocs;
		      h->dyn_relocs = p;
		      p->sec = sec;
		      p->count = 0;
d1602 1
a1602 1
		      p->relative_count = 0;
d1604 1
a1604 1
		    }
d1606 1
a1606 1
		  p->count += 1;
d1608 2
a1609 2
		  if (!IS_ABSOLUTE_RELOC (rtype))
		    p->relative_count += 1;
a1610 6
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.  */
		  elf_section_data (sec)->local_dynrel += 1;
		}
d1686 1
a1686 1
  elf_section_data (sec)->local_dynrel = 0;
d2204 1
a2204 1
    keep:
d2331 1
a2331 1
	  bfd_size_type count = elf_section_data (s)->local_dynrel;
d2333 18
a2350 4
	  if (count != 0)
	    {
	      srel = elf_section_data (s)->sreloc;
	      srel->_raw_size += count * sizeof (Elf32_External_Rela);
d3911 7
d3920 1
a3920 1
	     ..discard_relocs.  ie. We need exactly the same condition
d3923 1
a3923 1
	     ..discard_relocs.  If you squint, the non-shared test
a3930 1
	       && (input_section->flags & SEC_ALLOC) != 0
a3937 1
		  && (input_section->flags & SEC_ALLOC) != 0
@


1.57
log
@	Revert previous delta, instead do this.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Don't count
	.plt relocs in DT_RELASZ.
@
text
@d341 4
a344 1
static boolean hppa_handle_PIC_calls
d1973 1
a1973 1
hppa_handle_PIC_calls (h, inf)
d1994 36
d2065 5
a2069 2
      if (((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2084 3
a2086 6
	  if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	    {
	      /* We also need to make an entry in the .rela.plt section.  */
	      htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	      htab->need_plt_stub = 1;
	    }
d2291 2
a2292 2
	 PIC, and allocate space for the necessary .plt entries so
	 that %r19 will be set up.  */
d2294 1
a2294 3
	elf_link_hash_traverse (&htab->elf,
				hppa_handle_PIC_calls,
				info);
d2372 3
a4124 9
	      /* To support lazy linking, the function pointer is
		 initialised to point to a special stub stored at the
		 end of the .plt.  This is not done for plt entries
		 with a base-relative dynamic relocation.  */
	      value = (htab->splt->output_offset
		       + htab->splt->output_section->vma
		       + htab->splt->_raw_size
		       - sizeof (plt_stub)
		       + PLT_STUB_ENTRY);
@


1.56
log
@	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Set DT_RELASZ
	whenever DT_PLTRELSZ.
@
text
@d2371 4
a2374 2
	      /* Remember whether there are any reloc sections.  */
	      relocs = true;
d4278 13
@


1.55
log
@	* elflink.h (elf_link_input_bfd): Zero the reloc instead of doing
	bfd_reloc_type_lookup (bfd, BFD_RELOC_NONE) as bfd_reloc_type_lookup
	doesn't accept BFD_RELOC_* on some targets, eg. hppa.

	* elf32-hppa.c (elf32_hppa_link_hash_entry): Remove plt_abs.
	(hppa_link_hash_newfunc): Likewise.
	(elf32_hppa_finish_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Always allocate .got relocs if shared.
	(elf32_hppa_relocate_section): Output them too.  Similarly
	consolidate .plt reloc code, and no longer initialise .plt
	when a reloc is output.
	(elf32_hppa_finish_dynamic_symbol): Only initialise .plt entries
	when no reloc is output.

	From Herbert Xu <herbert@@gondor.apana.org.au>
	* elf32-hppa.c (final_link_relocate): Call bfd_set_error for
	unreachable branches.
@
text
@d2371 2
a2372 4
	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (s != htab->srelplt)
		relocs = true;
@


1.54
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Test ind->root.type
	rather than ind->weakdef.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
@
text
@a215 4

  /* Set if this symbol is an init or fini function and thus should
     use an absolute reloc.  */
  unsigned int plt_abs:1;
a460 1
      eh->plt_abs = 0;
a2062 2
      boolean dyn;

d2076 7
a2082 3
      dyn = htab->elf.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d3468 1
a3539 1
      bfd_vma off;
d3639 3
a3641 5
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (h != NULL)
	    {
	      boolean dyn;
d3643 44
a3686 31
	      off = h->elf.got.offset;
	      dyn = htab->elf.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  htab->sgot->contents + off);
		      h->elf.got.offset |= 1;
		    }
		}
	    }
	  else
	    {
	      /* Local symbol case.  */
	      if (local_got_offsets == NULL)
		abort ();
d3688 21
a3708 9
	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
d3711 1
d3713 2
a3714 9
		  if (info->shared)
		    {
		      /* Output a dynamic relocation for this GOT
			 entry.  In this case it is relative to the
			 base of the object because the symbol index
			 is zero.  */
		      Elf_Internal_Rela outrel;
		      asection *srelgot = htab->srelgot;
		      Elf32_External_Rela *loc;
d3716 5
a3720 21
		      outrel.r_offset = (off
					 + htab->sgot->output_offset
					 + htab->sgot->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		      outrel.r_addend = relocation;
		      loc = (Elf32_External_Rela *) srelgot->contents;
		      loc += srelgot->reloc_count++;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  /* Add the base of the GOT to the relocation value.  */
	  relocation = (off
			+ htab->sgot->output_offset
			+ htab->sgot->output_section->vma);
d3735 3
a3751 6
			  bfd_put_32 (output_bfd,
				      relocation,
				      htab->splt->contents + off);
			  bfd_put_32 (output_bfd,
				      elf_gp (htab->splt->output_section->owner),
				      htab->splt->contents + off + 4);
d3753 1
d3774 26
a3805 20

		      if (info->shared)
			{
			  /* Output a dynamic IPLT relocation for this
			     PLT entry.  */
			  Elf_Internal_Rela outrel;
			  asection *srelplt = htab->srelplt;
			  Elf32_External_Rela *loc;

			  outrel.r_offset = (off
					     + htab->splt->output_offset
					     + htab->splt->output_section->vma);
			  outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
			  outrel.r_addend = relocation;
			  loc = (Elf32_External_Rela *) srelplt->contents;
			  loc += srelplt->reloc_count++;
			  bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
			}

		      local_plt_offsets[r_symndx] |= 1;
d3886 2
d4083 1
a4083 2
	  if (! ((struct elf32_hppa_link_hash_entry *) h)->plt_abs
	      && h->dynindx != -1)
d4110 1
a4110 10

      bfd_put_32 (htab->splt->owner,
		  value,
		  htab->splt->contents + h->plt.offset);
      bfd_put_32 (htab->splt->owner,
		  elf_gp (htab->splt->output_section->owner),
		  htab->splt->contents + h->plt.offset + 4);
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && h->dynindx != -1)
d4112 6
a4117 2
	  memset (htab->splt->contents + h->plt.offset + 8,
		  0, PLABEL_PLT_ENTRY_SIZE - PLT_ENTRY_SIZE);
@


1.53
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d1152 1
a1152 1
	  if (dir != ind->weakdef)
@


1.52
log
@	* elflink.h (elf_fix_symbol_flags): Copy flags to weakdef using
	elf_backend_copy_indirect_symbol so that backend has a chance to
	copy other necessary fields.
	* elf-bfd.h (struct elf_backend_data): Update description of
	elf_backend_copy_indirect_symbol.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Bail out after
	copying flags if this is a weakdef.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_link_hash_lookup rather
	than bfd_link_hash_lookup.
	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Don't do copy
	reloc processing for weakdefs.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1145 1
a1145 1
  if (edir->dyn_relocs == NULL)
d1147 30
a1179 2
  else if (eind->dyn_relocs != NULL)
    abort ();
d1875 2
@


1.51
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d1858 1
@


1.50
log
@	* elf32-hppa.c (elf32_hppa_check_relocs): Update comment since we
	no longer allocate here.  Localise some vars to blocks where they
	are used.
	(elf32_hppa_adjust_dynamic_symbol): Correct a comment.  Delay
	setting of vars until needed.
	(allocate_dynrelocs): Don't create a .plt entry without a reloc
	when symbol visibilty makes a function local.
	(elf32_hppa_finish_dynamic_symbol): Move expressions out of
	swap_reloca_out function calls.
	(elf32_hppa_relocate_section): Likewies.  Comment typo fix.
	(elf32_hppa_finish_dynamic_sections): Migrate common code out of
	switch statement.
@
text
@d1136 1
a1136 1
void
d1362 1
a1362 4
	      if (h->elf.got.refcount == -1)
		h->elf.got.refcount = 1;
	      else
		h->elf.got.refcount += 1;
d1404 2
a1405 7
		  if (h->elf.plt.refcount == -1)
		    {
		      h->elf.plt.refcount = 1;
		      h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		    }
		  else
		    h->elf.plt.refcount += 1;
a3485 1
  bfd *dynobj;
a3494 1
  dynobj = htab->elf.dynobj;
a4011 1
  bfd *dynobj;
a4013 1
  dynobj = htab->elf.dynobj;
d4366 1
@


1.49
log
@	* elf32-i386 (elf_i386_copy_indirect_symbol): New function.
	(elf_backend_copy_indirect_symbol): Define.
	(struct elf_i386_link_hash_entry): Rename "root" to "elf".
	(struct elf_i386_link_hash_table): Likewise.
	(link_hash_newfunc): Get rid of unnecessary casts.
	(elf_i386_link_hash_table_create): Likewise.
	(elf_i386_check_relocs): Initialise local_got_refcounts to 0.
	Don't test input section SEC_READONLY here to try to avoid copy
	relocs, and keep dyn_relocs regardleas of ELF_LINK_NON_GOT_REF.
	(elf_i386_adjust_dynamic_symbol): Check output section SEC_READONLY
	here to properly test whether we need copy relocs.  Do so for weak
	syms too.

	* elf32-hppa (elf32_hppa_copy_indirect_symbol): New function.
	(elf_backend_copy_indirect_symbol): Define.
	(struct elf32_hppa_link_hash_table): Rename "root" to "elf".
	(stub_hash_newfunc): Get rid of unnecessary casts.
	(hppa_link_hash_newfunc): Likewise.
	(elf32_hppa_check_relocs): Initialise local_got_refcounts to 0.
	Don't test input section SEC_READONLY here to try to avoid copy
	relocs, and keep dyn_relocs regardleas of ELF_LINK_NON_GOT_REF.
	(elf32_hppa_adjust_dynamic_symbol): Check output section SEC_READONLY
	here to properly test whether we need copy relocs.  Do so for weak
	syms too.
@
text
@d1157 3
a1159 3
   allocate space in the global offset table or procedure linkage
   table.  At this point we haven't necessarily read all the input
   files.  */
a1167 1
  bfd *dynobj;
a1169 1
  bfd_signed_vma *local_got_refcounts;
a1179 1
  dynobj = htab->elf.dynobj;
a1181 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a1351 3
	  if (dynobj == NULL)
	    htab->elf.dynobj = dynobj = abfd;

d1354 3
a1356 1
	      if (! elf32_hppa_create_dynamic_sections (dynobj, info))
d1369 2
d1372 1
d1423 1
d1426 1
d1504 1
a1504 3

		  if (dynobj == NULL)
		    htab->elf.dynobj = dynobj = abfd;
d1519 4
d1552 2
a1553 1
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
a1807 1
  bfd *dynobj;
d1812 1
a1812 3

  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;
d1909 1
a1909 1
  s = htab->sdynbss;
d1913 1
a1913 2
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
d1916 10
a1925 1
      asection *srel;
d1927 8
a1934 3
      srel = htab->srelbss;
      srel->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
a1936 18
  {
    /* We need to figure out the alignment required for this symbol.  I
       have no idea how other ELF linkers handle this.  */
    unsigned int power_of_two;

    power_of_two = bfd_log2 (h->size);
    if (power_of_two > 3)
      power_of_two = 3;

    /* Apply the required alignment.  */
    s->_raw_size = BFD_ALIGN (s->_raw_size,
			      (bfd_size_type) (1 << power_of_two));
    if (power_of_two > bfd_get_section_alignment (dynobj, s))
      {
	if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	  return false;
      }
  }
d2008 2
a2009 6
      /* Make an entry in the .plt section.  */
      s = htab->splt;
      h->plt.offset = s->_raw_size;
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2011 19
a2029 2
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
a2031 4
	s->_raw_size += PLT_ENTRY_SIZE;

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2033 2
a2034 3
	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  htab->need_plt_stub = 1;
d3537 1
a3537 1
	  /* This is a relocateable link.  We don't have to change
d3679 1
d3686 3
a3688 5
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						 ((Elf32_External_Rela *)
						  srelgot->contents
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
d3770 1
d3777 3
a3779 5
			  bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						     ((Elf32_External_Rela *)
						      srelplt->contents
						      + srelplt->reloc_count));
			  ++srelplt->reloc_count;
d3930 2
a3931 3
	      loc = ((Elf32_External_Rela *) sreloc->contents
		     + sreloc->reloc_count);
	      sreloc->reloc_count += 1;
d4054 1
d4083 2
d4086 1
a4086 5
				     &rel,
				     ((Elf32_External_Rela *)
				      htab->srelplt->contents
				      + htab->srelplt->reloc_count));
	  htab->srelplt->reloc_count++;
d4114 1
d4147 3
a4149 5
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *)
				  htab->srelgot->contents
				  + htab->srelgot->reloc_count));
      ++htab->srelgot->reloc_count;
d4156 1
d4172 2
a4173 4
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d4243 1
a4243 1
	      break;
a4247 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a4252 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a4260 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4263 2
@


1.48
log
@	* elf32-hppa.c: Rename all occurrences of "hplink" to "htab"
	throughout file.
@
text
@d225 1
a225 1
  struct elf_link_hash_table root;
d324 3
a403 4
  struct elf32_hppa_stub_hash_entry *ret;

  ret = (struct elf32_hppa_stub_hash_entry *) entry;

d406 1
a406 1
  if (ret == NULL)
d408 4
a411 5
      ret = ((struct elf32_hppa_stub_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_stub_hash_entry)));
      if (ret == NULL)
	return NULL;
d415 4
a418 2
  ret = ((struct elf32_hppa_stub_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
a419 2
  if (ret)
    {
d421 8
a428 7
      ret->stub_sec = NULL;
      ret->stub_offset = 0;
      ret->target_value = 0;
      ret->target_section = NULL;
      ret->stub_type = hppa_stub_long_branch;
      ret->h = NULL;
      ret->id_sec = NULL;
d431 1
a431 1
  return (struct bfd_hash_entry *) ret;
a441 4
  struct elf32_hppa_link_hash_entry *ret;

  ret = (struct elf32_hppa_link_hash_entry *) entry;

d444 1
a444 1
  if (ret == NULL)
d446 4
a449 5
      ret = ((struct elf32_hppa_link_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_link_hash_entry)));
      if (ret == NULL)
	return NULL;
d453 4
a456 3
  ret = ((struct elf32_hppa_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
a457 2
  if (ret)
    {
d459 7
a465 6
      ret->stub_cache = NULL;
      ret->dyn_relocs = NULL;
      ret->maybe_pic_call = 0;
      ret->pic_call = 0;
      ret->plabel = 0;
      ret->plt_abs = 0;
d468 1
a468 1
  return (struct bfd_hash_entry *) ret;
d486 1
a486 1
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd, hppa_link_hash_newfunc))
d513 1
a513 1
  return &ret->root.root;
d909 1
a909 1
	  dynobj = htab->root.dynobj;
d1134 22
d1182 1
a1182 1
  dynobj = htab->root.dynobj;
d1357 1
a1357 1
	    htab->root.dynobj = dynobj = abfd;
d1386 1
a1386 1
					 bfd_alloc (abfd, size));
a1389 1
		  memset (local_got_refcounts, -1, (size_t) size);
d1391 1
a1391 4
	      if (local_got_refcounts[r_symndx] == -1)
		local_got_refcounts[r_symndx] = 1;
	      else
		local_got_refcounts[r_symndx] += 1;
d1436 1
a1436 1
					     bfd_alloc (abfd, size));
a1439 1
		      memset (local_got_refcounts, -1, (size_t) size);
d1443 1
a1443 4
		  if (local_plt_refcounts[r_symndx] == -1)
		    local_plt_refcounts[r_symndx] = 1;
		  else
		    local_plt_refcounts[r_symndx] += 1;
d1453 1
a1453 4
	  if (need_entry == NEED_DYNREL
	      && h != NULL
	      && !info->shared
	      && (sec->flags & SEC_READONLY) != 0)
a1494 1
		  && (h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
d1506 1
a1506 1
		    htab->root.dynobj = dynobj = abfd;
d1657 1
a1657 1
  dynobj = htab->root.dynobj;
d1807 2
d1812 1
a1812 1
  dynobj = htab->root.dynobj;
a1865 1
      return true;
d1883 16
d1998 1
a1998 1
  if ((htab->root.dynamic_sections_created
d2057 1
a2057 1
      dyn = htab->root.dynamic_sections_created;
d2102 1
a2102 1
	      || (htab->root.dynamic_sections_created
d2205 1
a2205 1
  dynobj = htab->root.dynobj;
d2209 1
a2209 1
  if (htab->root.dynamic_sections_created)
d2222 1
a2222 1
      elf_link_hash_traverse (&htab->root,
d2232 1
a2232 1
	elf_link_hash_traverse (&htab->root,
d2287 1
a2287 1
      if (! htab->root.dynamic_sections_created)
d2314 1
a2314 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d2386 1
a2386 1
  if (htab->root.dynamic_sections_created)
d2426 1
a2426 1
	  elf_link_hash_traverse (&htab->root, readonly_dynrelocs, (PTR) info);
d3042 1
a3042 1
  h = elf_link_hash_lookup (&htab->root, "$global$", false, false, false);
d3501 1
a3501 1
  dynobj = htab->root.dynobj;
d3625 1
a3625 1
	      dyn = htab->root.dynamic_sections_created;
d3712 1
a3712 1
	  if (htab->root.dynamic_sections_created)
d3863 1
a3863 1
			 (output_bfd, &htab->root.stab_info,
d4025 1
a4025 1
  dynobj = htab->root.dynobj;
d4223 1
a4223 1
  dynobj = htab->root.dynobj;
d4227 1
a4227 1
  if (htab->root.dynamic_sections_created)
d4364 1
@


1.47
log
@	* elf32-hppa.c: (LONG_BRANCH_PIC_IN_SHLIB): Delete.  Remove all
	code handling this option.
	(LONG_BRANCH_VIA_PLT): Likewise.
	(RELATIVE_DYNRELOCS): Define as zero.
	(struct elf32_hppa_dyn_reloc_entry): Add "sec", and
	"pc_count" fields.  Remove "section" field.
	(elf32_hppa_link_hash_entry): Rename reloc_entries to dyn_relocs.
	(elf32_hppa_check_relocs): Don't allocate space for dynamic
	relocs here.  Instead, record all needed dynamic relocs via
	dyn_relocs and local_dynrel.  Cache pointer to "sreloc" section
	in elf_section_data.
	(elf32_hppa_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
	(allocate_plt_and_got_and_discard_relocs): Rename to
	allocate_dynrelocs.  Allocate rather than discarding dyn relocs.
	(readonly_dynrelocs): New function.
	(elf32_hppa_size_dynamic_sections): Mark output_bfd unused.
	Call readonly_dynrelocs to determine need for DT_TEXTREL.
	Rename "i" to "ibfd".  Allocate space for local dyn relocs.
	(elf32_hppa_relocate_section): Make use of cached sreloc.
	(elf32_hppa_reloc_type_class): New function.
	(elf_backend_reloc_type_class): Define.
@
text
@d566 1
a566 1
hppa_get_stub_entry (input_section, sym_sec, hash, rel, hplink)
d571 1
a571 1
     struct elf32_hppa_link_hash_table *hplink;
d581 1
a581 1
  id_sec = hplink->stub_group[input_section->id].link_sec;
d597 1
a597 1
      stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
d624 1
a624 1
hppa_add_stub (stub_name, section, hplink)
d627 1
a627 1
     struct elf32_hppa_link_hash_table *hplink;
d633 2
a634 2
  link_sec = hplink->stub_group[section->id].link_sec;
  stub_sec = hplink->stub_group[section->id].stub_sec;
d637 1
a637 1
      stub_sec = hplink->stub_group[link_sec->id].stub_sec;
d644 1
a644 1
	  s_name = bfd_alloc (hplink->stub_bfd, len);
d650 1
a650 1
	  stub_sec = (*hplink->add_stub_section) (s_name, link_sec);
d653 1
a653 1
	  hplink->stub_group[link_sec->id].stub_sec = stub_sec;
d655 1
a655 1
      hplink->stub_group[section->id].stub_sec = stub_sec;
d659 1
a659 1
  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table, stub_name,
d785 1
a785 1
  struct elf32_hppa_link_hash_table *hplink;
d799 1
a799 1
  hplink = hppa_link_hash_table (info);
d860 3
a862 3
		   + hplink->splt->output_offset
		   + hplink->splt->output_section->vma
		   - elf_gp (hplink->splt->output_section->owner));
d882 1
a882 1
      if (hplink->multi_subspace)
d915 1
a915 1
	  dynobj = hplink->root.dynobj;
d932 5
a936 5
	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off);
	  value = elf_gp (hplink->splt->output_section->owner);
	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off + 4);
d1020 1
a1020 1
  struct elf32_hppa_link_hash_table *hplink;
d1025 1
a1025 1
  hplink = (struct elf32_hppa_link_hash_table *) in_arg;
d1035 1
a1035 1
      if (hplink->multi_subspace)
d1107 1
a1107 1
  struct elf32_hppa_link_hash_table *hplink;
d1110 2
a1111 2
  hplink = hppa_link_hash_table (info);
  if (hplink->splt != NULL)
d1118 2
a1119 2
  hplink->splt = bfd_get_section_by_name (abfd, ".plt");
  hplink->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d1121 4
a1124 4
  hplink->sgot = bfd_get_section_by_name (abfd, ".got");
  hplink->srelgot = bfd_make_section (abfd, ".rela.got");
  if (hplink->srelgot == NULL
      || ! bfd_set_section_flags (abfd, hplink->srelgot,
d1131 1
a1131 1
      || ! bfd_set_section_alignment (abfd, hplink->srelgot, 2))
d1134 2
a1135 2
  hplink->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  hplink->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
d1158 1
a1158 1
  struct elf32_hppa_link_hash_table *hplink;
d1165 2
a1166 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d1236 1
a1236 1
	  hplink->has_12bit_branch = 1;
d1240 1
a1240 1
	  hplink->has_17bit_branch = 1;
d1341 1
a1341 1
	    hplink->root.dynobj = dynobj = abfd;
d1343 1
a1343 1
	  if (hplink->sgot == NULL)
d1502 1
a1502 1
		    hplink->root.dynobj = dynobj = abfd;
d1641 1
a1641 1
  struct elf32_hppa_link_hash_table *hplink;
d1652 2
a1653 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d1802 1
a1802 1
  struct elf32_hppa_link_hash_table *hplink;
d1805 2
a1806 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d1888 1
a1888 1
  s = hplink->sdynbss;
d1898 1
a1898 1
      srel = hplink->srelbss;
d1966 1
a1966 1
  struct elf32_hppa_link_hash_table *hplink;
d1976 2
a1977 2
  hplink = hppa_link_hash_table (info);
  if ((hplink->root.dynamic_sections_created
d1993 1
a1993 1
      s = hplink->splt;
d2009 2
a2010 2
	  hplink->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  hplink->need_plt_stub = 1;
d2033 1
a2033 1
      s = hplink->sgot;
d2036 1
a2036 1
      dyn = hplink->root.dynamic_sections_created;
d2038 1
a2038 1
	hplink->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d2081 1
a2081 1
	      || (hplink->root.dynamic_sections_created
d2177 1
a2177 1
  struct elf32_hppa_link_hash_table *hplink;
d2183 2
a2184 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d2188 1
a2188 1
  if (hplink->root.dynamic_sections_created)
d2201 1
a2201 1
      elf_link_hash_traverse (&hplink->root,
d2211 1
a2211 1
	elf_link_hash_traverse (&hplink->root,
d2249 2
a2250 2
      s = hplink->sgot;
      srel = hplink->srelgot;
d2266 1
a2266 1
      if (! hplink->root.dynamic_sections_created)
d2274 2
a2275 2
	  s = hplink->splt;
	  srel = hplink->srelplt;
d2293 1
a2293 1
  elf_link_hash_traverse (&hplink->root, allocate_dynrelocs, (PTR) info);
d2304 1
a2304 1
      if (s == hplink->splt)
d2306 1
a2306 1
	  if (hplink->need_plt_stub)
d2311 1
a2311 1
	      int gotalign = bfd_section_alignment (dynobj, hplink->sgot);
d2321 1
a2321 1
      else if (s == hplink->sgot)
d2329 1
a2329 1
	      if (s != hplink->srelplt)
d2365 1
a2365 1
  if (hplink->root.dynamic_sections_created)
d2388 1
a2388 1
      if (hplink->srelplt->_raw_size != 0)
d2405 1
a2405 1
	  elf_link_hash_traverse (&hplink->root, readonly_dynrelocs, (PTR) info);
d2444 1
a2444 1
  struct elf32_hppa_link_hash_table *hplink;
d2451 1
a2451 1
  hplink = hppa_link_hash_table (info);
d2454 4
a2457 4
  hplink->stub_bfd = stub_bfd;
  hplink->multi_subspace = multi_subspace;
  hplink->add_stub_section = add_stub_section;
  hplink->layout_sections_again = layout_sections_again;
d2467 1
a2467 1
      if (hplink->has_17bit_branch || hplink->multi_subspace)
d2469 1
a2469 1
      if (hplink->has_12bit_branch)
d2489 2
a2490 2
  hplink->stub_group = (struct map_stub *) bfd_zmalloc (amt);
  if (hplink->stub_group == NULL)
d2544 1
a2544 1
#define PREV_SEC(sec) (hplink->stub_group[(sec)->id].link_sec)
d2597 1
a2597 1
	      hplink->stub_group[tail->id].link_sec = curr;
d2612 1
a2612 1
		  hplink->stub_group[tail->id].link_sec = curr;
d2681 1
a2681 1
      if (info->shared && hplink->multi_subspace)
d2725 1
a2725 1
		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
d2730 1
a2730 1
		      stub_entry = hppa_add_stub (stub_name, sec, hplink);
d2933 1
a2933 1
		  id_sec = hplink->stub_group[section->id].link_sec;
d2940 1
a2940 1
		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
d2950 1
a2950 1
		  stub_entry = hppa_add_stub (stub_name, section, hplink);
d2981 1
a2981 1
      for (stub_sec = hplink->stub_bfd->sections;
d2989 1
a2989 3
      bfd_hash_traverse (&hplink->stub_hash_table,
			 hppa_size_one_stub,
			 hplink);
d2992 1
a2992 1
      (*hplink->layout_sections_again) ();
d3015 1
a3015 1
  struct elf32_hppa_link_hash_table *hplink;
d3020 2
a3021 3
  hplink = hppa_link_hash_table (info);
  h = elf_link_hash_lookup (&hplink->root, "$global$",
			    false, false, false);
d3041 1
a3041 1
      sec = hplink->splt;
d3046 1
a3046 1
	      || (hplink->sgot && hplink->sgot->_raw_size > 0x2000))
d3054 1
a3054 1
	  sec = hplink->sgot;
d3099 1
a3099 1
  struct elf32_hppa_link_hash_table *hplink;
d3101 1
a3101 1
  hplink = hppa_link_hash_table (info);
d3103 1
a3103 1
  for (stub_sec = hplink->stub_bfd->sections;
d3111 1
a3111 2
      stub_sec->contents = (unsigned char *) bfd_zalloc (hplink->stub_bfd,
							 size);
d3118 1
a3118 1
  table = &hplink->stub_hash_table;
d3172 1
a3172 1
  struct elf32_hppa_link_hash_table *hplink;
d3174 1
a3174 1
  hplink = (struct elf32_hppa_link_hash_table *) data;
d3182 2
a3183 2
	  if (value < hplink->text_segment_base)
	    hplink->text_segment_base = value;
d3187 2
a3188 2
	  if (value < hplink->data_segment_base)
	    hplink->data_segment_base = value;
d3196 1
a3196 1
final_link_relocate (input_section, contents, rel, value, hplink, sym_sec, h)
d3201 1
a3201 1
     struct elf32_hppa_link_hash_table *hplink;
d3249 1
a3249 1
					    h, rel, hplink);
d3324 1
a3324 1
	value -= hplink->text_segment_base;
d3326 1
a3326 1
	value -= hplink->data_segment_base;
d3395 1
a3395 1
					    h, rel, hplink);
d3472 1
a3472 1
  struct elf32_hppa_link_hash_table *hplink;
d3479 2
a3480 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d3604 1
a3604 1
	      dyn = hplink->root.dynamic_sections_created;
d3624 1
a3624 1
				  hplink->sgot->contents + off);
d3645 1
a3645 1
			      hplink->sgot->contents + off);
d3654 1
a3654 1
		      asection *srelgot = hplink->srelgot;
d3657 2
a3658 2
					 + hplink->sgot->output_offset
					 + hplink->sgot->output_section->vma);
d3677 2
a3678 2
			+ hplink->sgot->output_offset
			+ hplink->sgot->output_section->vma);
d3684 2
a3685 4
	  if (hplink->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd,
				   hppa_record_segment_addr,
				   hplink);
d3691 1
a3691 1
	  if (hplink->root.dynamic_sections_created)
d3709 1
a3709 1
				      hplink->splt->contents + off);
d3711 2
a3712 2
				      elf_gp (hplink->splt->output_section->owner),
				      hplink->splt->contents + off + 4);
d3736 1
a3736 1
				  hplink->splt->contents + off);
d3738 2
a3739 2
				  elf_gp (hplink->splt->output_section->owner),
				  hplink->splt->contents + off + 4);
d3746 1
a3746 1
			  asection *srelplt = hplink->srelplt;
d3749 2
a3750 2
					     + hplink->splt->output_offset
					     + hplink->splt->output_section->vma);
d3778 2
a3779 2
				+ hplink->splt->output_offset
				+ hplink->splt->output_section->vma
d3842 1
a3842 1
			 (output_bfd, &hplink->root.stab_info,
d3920 1
a3920 1
			       hplink, sym_sec, h);
d4000 1
a4000 1
  struct elf32_hppa_link_hash_table *hplink;
d4003 2
a4004 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d4036 2
a4037 2
			  + hplink->splt->output_offset
			  + hplink->splt->output_section->vma);
d4045 3
a4047 3
	      value = (hplink->splt->output_offset
		       + hplink->splt->output_section->vma
		       + hplink->splt->_raw_size
d4061 1
a4061 1
	  bfd_elf32_swap_reloca_out (hplink->splt->output_section->owner,
d4064 3
a4066 3
				      hplink->srelplt->contents
				      + hplink->srelplt->reloc_count));
	  hplink->srelplt->reloc_count++;
d4069 1
a4069 1
      bfd_put_32 (hplink->splt->owner,
d4071 4
a4074 4
		  hplink->splt->contents + h->plt.offset);
      bfd_put_32 (hplink->splt->owner,
		  elf_gp (hplink->splt->output_section->owner),
		  hplink->splt->contents + h->plt.offset + 4);
d4079 1
a4079 1
	  memset (hplink->splt->contents + h->plt.offset + 8,
d4099 2
a4100 2
		      + hplink->sgot->output_offset
		      + hplink->sgot->output_section->vma);
d4121 1
a4121 1
		      hplink->sgot->contents + h->got.offset);
d4128 3
a4130 3
				  hplink->srelgot->contents
				  + hplink->srelgot->reloc_count));
      ++hplink->srelgot->reloc_count;
d4145 1
a4145 1
      s = hplink->srelbss;
d4198 1
a4198 1
  struct elf32_hppa_link_hash_table *hplink;
d4201 2
a4202 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d4206 1
a4206 1
  if (hplink->root.dynamic_sections_created)
d4234 1
a4234 1
	      s = hplink->srelplt;
d4240 1
a4240 1
	      s = hplink->srelplt;
d4251 1
a4251 1
  if (hplink->sgot != NULL && hplink->sgot->_raw_size != 0)
d4259 1
a4259 1
		  hplink->sgot->contents);
d4262 1
a4262 1
      memset (hplink->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);
d4265 1
a4265 1
      elf_section_data (hplink->sgot->output_section)
d4269 1
a4269 1
  if (hplink->splt != NULL && hplink->splt->_raw_size != 0)
d4272 1
a4272 1
      elf_section_data (hplink->splt->output_section)
d4275 1
a4275 1
      if (hplink->need_plt_stub)
d4278 2
a4279 2
	  memcpy (hplink->splt->contents
		  + hplink->splt->_raw_size - sizeof (plt_stub),
d4282 5
a4286 5
	  if ((hplink->splt->output_offset
	       + hplink->splt->output_section->vma
	       + hplink->splt->_raw_size)
	      != (hplink->sgot->output_offset
		  + hplink->sgot->output_section->vma))
@


1.46
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d137 5
a141 18
/* Setting the following non-zero makes all long branch stubs
   generated during a shared link of the PIC variety.  This saves on
   relocs, but costs one extra instruction per stub.  */
#ifndef LONG_BRANCH_PIC_IN_SHLIB
#define LONG_BRANCH_PIC_IN_SHLIB 1
#endif

/* Set this non-zero to use import stubs instead of long branch stubs
   where a .plt entry exists for the symbol.  This is a fairly useless
   option as import stubs are bigger than PIC long branch stubs.  */
#ifndef LONG_BRANCH_VIA_PLT
#define LONG_BRANCH_VIA_PLT 0
#endif

/* We don't need to copy any PC- or GP-relative dynamic relocs into a
   shared object's dynamic section.  All the relocs of the limited
   class we are interested in, are absolute.  See check_relocs.  */
#ifndef IS_ABSOLUTE_RELOC
a161 5
#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* It's associated reloc section.  */
  asection *reloc_sec;
#endif

a187 6
#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* Used to track whether we have allocated space for a long branch
     stub relocation for this symbol in the given section.  */
  asection *stub_reloc_sec;
#endif

d195 2
a196 2
    /* The section in dynobj.  */
    asection *section;
d200 6
a205 1
  } *reloc_entries;
a244 4
#if ! LONG_BRANCH_PIC_IN_SHLIB
    /* The stub section's reloc section.  */
    asection *reloc_sec;
#endif
d345 4
a348 1
static boolean allocate_plt_and_got_and_discard_relocs
d379 3
a423 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->reloc_sec = NULL;
#endif
a465 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->stub_reloc_sec = NULL;
#endif
d467 1
a467 1
      ret->reloc_entries = NULL;
a669 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
  stub_entry->reloc_sec = hplink->stub_group[section->id].reloc_sec;
#endif
d734 2
a735 15
    {
#if LONG_BRANCH_VIA_PLT
      if (hash != NULL
	  && hash->elf.dynindx != -1
	  && hash->elf.plt.offset != (bfd_vma) -1
	  && hash->elf.type != STT_PARISC_MILLI)
	{
	  /* If we are doing a shared link and find we need a long
	     branch stub, then go via the .plt if possible.  */
	  return hppa_stub_import;
	}
      else
#endif
	return hppa_stub_long_branch;
    }
a826 45
#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (info->shared)
	{
	  /* Output a dynamic relocation for this stub.  We only
	     output one PCREL21L reloc per stub, trusting that the
	     dynamic linker will also fix the implied PCREL17R for the
	     second instruction.  PCREL21L dynamic relocs had better
	     never be emitted for some other purpose...  */
	  asection *srel;
	  Elf_Internal_Rela outrel;

	  if (stub_entry->h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): cannot relocate %s, recompile with -ffunction-sections"),
		 bfd_archive_filename (stub_entry->target_section->owner),
		 stub_sec->name,
		 (long) stub_entry->stub_offset,
		 stub_entry->root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }

	  srel = stub_entry->reloc_sec;
	  if (srel == NULL)
	    {
	      (*_bfd_error_handler)
		(_("Could not find relocation section for %s"),
		 stub_sec->name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }

	  outrel.r_offset = (stub_entry->stub_offset
			     + stub_sec->output_offset
			     + stub_sec->output_section->vma);
	  outrel.r_info = ELF32_R_INFO (0, R_PARISC_PCREL21L);
	  outrel.r_addend = sym_value;
	  bfd_elf32_swap_reloca_out (stub_sec->output_section->owner,
				     &outrel,
				     ((Elf32_External_Rela *)
				      srel->contents + srel->reloc_count));
	  ++srel->reloc_count;
	}
#endif
d1028 1
a1028 7
    {
#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (stub_entry->reloc_sec != NULL)
	stub_entry->reloc_sec->_raw_size += sizeof (Elf32_External_Rela);
#endif
      size = 8;
    }
d1180 1
a1180 6
#if LONG_BRANCH_PIC_IN_SHLIB
	NEED_STUBREL = 0,  /* We won't be needing them in this case.  */
#else
	NEED_STUBREL = 8,
#endif
	PLT_PLABEL = 16
d1261 1
a1261 1
	      need_entry = NEED_PLT | NEED_STUBREL;
d1263 1
a1263 1
		need_entry = NEED_STUBREL;
d1440 1
a1440 1
      if (need_entry & (NEED_DYNREL | NEED_STUBREL))
d1461 1
a1461 1
	     storing information in the reloc_entries field of the
a1494 7
	      boolean doit;
	      asection *srel;

	      srel = sreloc;
	      if ((need_entry & NEED_STUBREL))
		srel = stubreloc;

d1497 1
a1497 1
	      if (srel == NULL)
d1504 4
a1507 4
		  name = bfd_elf_string_from_elf_section
		    (abfd,
		     elf_elfheader (abfd)->e_shstrndx,
		     elf_section_data (sec)->rel_hdr.sh_name);
d1517 2
a1518 15
		  if ((need_entry & NEED_STUBREL))
		    {
		      bfd_size_type len = strlen (name) + sizeof (STUB_SUFFIX);
		      char *newname = bfd_malloc (len);

		      if (newname == NULL)
			return false;
		      strcpy (newname, name);
		      strcpy (newname + len - sizeof (STUB_SUFFIX),
			      STUB_SUFFIX);
		      name = newname;
		    }

		  srel = bfd_get_section_by_name (dynobj, name);
		  if (srel == NULL)
d1522 1
a1522 1
		      srel = bfd_make_section (dynobj, name);
d1527 3
a1529 3
		      if (srel == NULL
			  || !bfd_set_section_flags (dynobj, srel, flags)
			  || !bfd_set_section_alignment (dynobj, srel, 2))
a1531 2
		  else if ((need_entry & NEED_STUBREL))
		    free (name);
d1533 1
a1533 4
		  if ((need_entry & NEED_STUBREL))
		    stubreloc = srel;
		  else
		    sreloc = srel;
d1536 3
a1538 8
#if ! LONG_BRANCH_PIC_IN_SHLIB
	      /* If this is a function call, we only need one dynamic
		 reloc for the stub as all calls to a particular
		 function will go through the same stub.  Actually, a
		 long branch stub needs two relocations, but we count
		 on some intelligence on the part of the dynamic
		 linker.  */
	      if ((need_entry & NEED_STUBREL))
d1540 1
a1540 6
		  doit = h->stub_reloc_sec != stubreloc;
		  h->stub_reloc_sec = stubreloc;
		}
	      else
#endif
		doit = 1;
d1542 2
a1543 11
	      if (doit)
		{
		  srel->_raw_size += sizeof (Elf32_External_Rela);

		  /* Keep track of relocations we have entered for
		     this global symbol, so that we can discard them
		     later if necessary.  */
		  if (!info->shared
		      || (h != NULL
			  && (! IS_ABSOLUTE_RELOC (rtype)
			      || (need_entry & NEED_STUBREL))))
d1545 2
a1546 6
		      struct elf32_hppa_dyn_reloc_entry *p;

		      for (p = h->reloc_entries; p != NULL; p = p->next)
			if (p->section == srel)
			  break;

d1548 9
a1556 10
			{
			  p = ((struct elf32_hppa_dyn_reloc_entry *)
			       bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
			  if (p == NULL)
			    return false;
			  p->next = h->reloc_entries;
			  h->reloc_entries = p;
			  p->section = srel;
			  p->count = 0;
			}
d1558 10
a1567 8
		      /* NEED_STUBREL and NEED_DYNREL are never both
			 set.  Leave the count at zero for the
			 NEED_STUBREL case as we only ever have one
			 stub reloc per section per symbol, and this
			 simplifies code to discard unneeded relocs.  */
		      if (! (need_entry & NEED_STUBREL))
			++p->count;
		    }
d1644 2
d1697 4
d1702 1
d1705 15
d1728 27
d1961 1
a1961 1
allocate_plt_and_got_and_discard_relocs (h, inf)
d1969 1
a2042 9
  /* If this is a -Bsymbolic shared link, then we need to discard all
     space allocated for dynamic relocs against symbols defined in a
     regular object.  For the normal shared case, discard space for
     relocs that have become local due to symbol visibility changes.
     For the non-shared case, discard space for symbols which turn out
     to need copy relocs or are not dynamic.  We also need to lose
     relocs we've allocated for long branch stubs if we know we won't
     be generating a stub.  */

d2044 1
a2044 1
  if (eh->reloc_entries == NULL)
d2047 6
a2052 8
  /* First handle the non-shared case.  */
  if (!info->shared
      && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
      && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	  || (hplink->root.dynamic_sections_created
	      && (h->root.type == bfd_link_hash_undefweak
		  || h->root.type == bfd_link_hash_undefined))))
d2054 4
a2057 5
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI)
d2059 40
a2098 2
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
d2101 4
a2104 19
      /* If that succeeded, we know we'll be keeping all the relocs.  */
      if (h->dynindx != -1)
	return true;
    }

#if ! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT
  /* Handle the stub reloc case.  If we have a plt entry for the
     function, we won't be needing long branch stubs.  c->count will
     only be zero for stub relocs, which provides a handy way of
     flagging these relocs, and means we need do nothing special for
     the forced local and symbolic link case.  */
  if (eh->stub_reloc_sec != NULL
      && eh->elf.plt.offset != (bfd_vma) -1)
    {
      struct elf32_hppa_dyn_reloc_entry *c;

      for (c = eh->reloc_entries; c != NULL; c = c->next)
	if (c->count == 0)
	  c->section->_raw_size -= sizeof (Elf32_External_Rela);
a2105 1
#endif
d2107 2
a2108 8
  /* Discard any relocs in the non-shared case.  For the shared case,
     if a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if (!info->shared
      || ((eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((eh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic)))
d2110 2
a2111 4
      struct elf32_hppa_dyn_reloc_entry *c;

      for (c = eh->reloc_entries; c != NULL; c = c->next)
	c->section->_raw_size -= c->count * sizeof (Elf32_External_Rela);
d2142 28
d2174 1
a2174 1
     bfd *output_bfd;
d2179 1
a2179 1
  bfd *i;
a2181 1
  boolean reltext;
d2216 3
a2218 2
  /* Set up .got and .plt offsets for local syms.  */
  for (i = info->input_bfds; i; i = i->link_next)
d2228 1
a2228 1
      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
d2231 12
a2242 1
      local_got = elf_local_got_refcounts (i);
d2246 1
a2246 1
      symtab_hdr = &elf_tdata (i)->symtab_hdr;
d2291 3
a2293 5
  /* Allocate global sym .plt and .got entries.  Also discard all
     unneeded relocs.  */
  elf_link_hash_traverse (&hplink->root,
			  allocate_plt_and_got_and_discard_relocs,
			  (PTR) info);
a2298 1
  reltext = false;
a2326 3
	      asection *target;
	      const char *outname;

a2331 10
	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

a2401 1
	}
d2403 9
a2411 5
      if (reltext)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
a2680 22
#if ! LONG_BRANCH_PIC_IN_SHLIB
      /* If this is a shared link, find all the stub reloc sections.  */
      if (info->shared)
	for (section = input_bfd->sections;
	     section != NULL;
	     section = section->next)
	  {
	    char *name;
	    asection *reloc_sec;

	    name = bfd_malloc ((bfd_size_type) strlen (section->name)
			       + sizeof STUB_SUFFIX
			       + 5);
	    if (name == NULL)
	      return false;
	    sprintf (name, ".rela%s%s", section->name, STUB_SUFFIX);
	    reloc_sec = bfd_get_section_by_name (hplink->root.dynobj, name);
	    hplink->stub_group[section->id].reloc_sec = reloc_sec;
	    free (name);
	  }
#endif

d2964 1
a2964 2
		      else if (stub_type == hppa_stub_long_branch
			       && (LONG_BRANCH_PIC_IN_SHLIB || hash == NULL))
a2987 16
#if ! LONG_BRANCH_PIC_IN_SHLIB
      {
	int i;

	for (i = top_id; i >= 0; --i)
	  {
	    /* This will probably hit the same section many times..  */
	    stub_sec = hplink->stub_group[i].reloc_sec;
	    if (stub_sec != NULL)
	      {
		stub_sec->_raw_size = 0;
		stub_sec->_cooked_size = 0;
	      }
	  }
      }
#endif
a3479 1
  asection *sreloc;
a3485 1
  sreloc = NULL;
d3835 2
a3841 15
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    abort ();
		}

d3910 8
a3917 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 ((Elf32_External_Rela *)
					  sreloc->contents
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d4175 21
d4363 1
@


1.45
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d626 1
a626 1
				   bfd_get_filename (input_section->owner),
d687 1
a687 1
			     bfd_get_filename (section->owner),
d881 1
a881 1
		 bfd_get_filename (stub_entry->target_section->owner),
d1039 1
a1039 1
	     bfd_get_filename (stub_entry->target_section->owner),
d1379 1
a1379 1
		 bfd_get_filename (abfd),
d1399 1
a1399 1
		 bfd_get_filename (abfd),
d2829 2
a2830 2
			     bfd_get_filename (input_bfd),
			     stub_name);
d3411 1
a3411 1
		 bfd_get_filename (input_bfd),
d3527 1
a3527 1
	 bfd_get_filename (input_bfd),
d4065 1
a4065 1
	     bfd_get_filename (input_bfd),
d4070 2
@


1.44
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3682 1
a3682 1
	      if (info->symbolic)
@


1.43
log
@	* elf32-i386.c (elf_i386_relocate_section): Check !DEF_REGULAR
	as well as DEF_DYNAMIC in test for avoided copy relocs.
	(allocate_plt_and_got_and_discard_relocs): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	(allocate_plt_and_got_and_discard_relocs): Likewise.
@
text
@d509 1
d511 1
a511 1
  ret = ((struct elf32_hppa_link_hash_table *) bfd_alloc (abfd, sizeof (*ret)));
d555 1
a555 1
  size_t len;
d663 1
a663 1
	  size_t len;
d1456 1
a1456 1
		  size_t size;
d1462 2
a1463 1
		  size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
d1469 1
a1469 1
		  memset (local_got_refcounts, -1, size);
d1512 1
a1512 1
		      size_t size;
d1516 2
a1517 1
		      size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
d1523 1
a1523 1
		      memset (local_got_refcounts, -1, size);
d1621 1
a1621 1
		      size_t len = strlen (name) + sizeof (STUB_SUFFIX);
d1693 1
a1693 1
			       bfd_alloc (dynobj, sizeof *p));
d2438 4
a2441 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
d2449 1
a2449 1
      if (! info->shared)
d2451 1
a2451 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d2457 3
a2459 3
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d2465 3
a2467 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf32_External_Rela)))
d2473 1
a2473 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d2478 1
d2513 1
d2552 2
a2553 2
  hplink->stub_group
    = (struct map_stub *) bfd_zmalloc (sizeof (struct map_stub) * (top_id + 1));
d2571 2
a2572 2
  input_list
    = (asection **) bfd_malloc (sizeof (asection *) * (top_index + 1));
d2689 2
a2690 3
  all_local_syms
    = (Elf_Internal_Sym **) bfd_zmalloc (sizeof (Elf_Internal_Sym *)
					 * bfd_count);
d2704 1
d2713 3
a2715 2
      local_syms = (Elf_Internal_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf_Internal_Sym));
d2721 3
a2723 2
      ext_syms = (Elf32_External_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf32_External_Sym));
d2730 1
a2730 4
	  || (bfd_read (ext_syms, 1,
			(symtab_hdr->sh_info * sizeof (Elf32_External_Sym)),
			input_bfd)
	      != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
d2755 1
a2755 1
	    name = bfd_malloc (strlen (section->name)
d2876 3
a2878 4
	      external_relocs
		= ((Elf32_External_Rela *)
		   bfd_malloc (section->reloc_count
			       * sizeof (Elf32_External_Rela)));
d2885 3
a2887 3
	      internal_relocs = ((Elf_Internal_Rela *)
				 bfd_malloc (section->reloc_count
					     * sizeof (Elf_Internal_Rela)));
d2897 1
a2897 1
		  || bfd_read (external_relocs, 1,
d3213 1
a3213 1
      size_t size;
d3263 1
a3263 1
      qsort (contents, size / 16, 16, hppa_unwind_entry_compare);
d3813 1
a3813 1
			 need to write out the plt entry here.  */ 
a3964 2
		  bfd_vma off;

@


1.42
log
@	* elf32-i386.c (allocate_plt_and_got_and_discard_relocs): Don't
	keep relocs for undefined syms if there are no dynamic sections in
	executable.
	* elf32-hppa.c (allocate_plt_and_got_and_discard_relocs): Likewise.
@
text
@d1565 6
a1570 1
	     reloc in the branch.  */
d2148 2
a2149 1
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d3902 11
a3912 11
	     expression must match the code in check_relocs and
	     hppa_discard_copies.  ie. We need exactly the same
	     condition as in check_relocs, with some extra conditions
	     (dynindx test in this case) to cater for relocs removed
	     by hppa_discard_copies.  If you squint, the non-shared
	     test here does indeed match the one in check_relocs, the
	     difference being that here we test DEF_DYNAMIC rather
	     than a maybe-DEF_DYNAMIC via !DEF_REGULAR.  Common syms
	     end up with !DEF_REGULAR, which is why we can't use that
	     here.  Conversely, DEF_DYNAMIC can't be used in
	     check_relocs as there all files have not been loaded.  */
d3926 4
a3929 2
		  && ((h->elf.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
@


1.41
log
@2001-06-29  H.J. Lu  <hjl@@gnu.org>

	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Check if
	hplink->sgot is NULL before filling GOT. Checck if hplink->splt
	is NULL before filling PLT.
@
text
@d2144 3
a2146 2
	  || h->root.type == bfd_link_hash_undefweak
	  || h->root.type == bfd_link_hash_undefined))
@


1.40
log
@	Avoid creating COPY relocs.
	* elf32-hppa.c (elf32_hppa_check_relocs): Don't make syms dynamic
	here..
	(elf32_hppa_adjust_dynamic_symbol): ..nor here..
	(allocate_plt_and_got_and_discard_relocs): .. instead do so here
	after gc has run.
	* elf32-hppa.c (RELATIVE_DYNAMIC_RELOCS): Delete.
	(IS_ABSOLUTE_RELOC): Define.
	(elf32_hppa_link_hash_entry): Always include reloc_entries field.
	(hppa_link_hash_newfunc): Always init it.
	(elf32_hppa_check_relocs): Mark symbols as ELF_LINK_NON_GOT_REF to
	create COPY relocs only when the reloc is in a read-only section.
	Instead, allocate space for a dynamic reloc to reference the
	library symbol directly.  Keep track of space we allocate using
	relocs_entries.
	(hppa_discard_copies): Delete, and move code to..
	(allocate_plt_and_got): ..here.  Rename to
	allocate_plt_and_got_and_discard_relocs.  Remove unneeded dynamic
	relocs for non-shared link.
	(elf32_hppa_size_dynamic_sections): Update calls to above.
	(elf32_hppa_relocate_section): Write out the dynamic relocs used
	in lieu of COPY relocs.
@
text
@d4337 1
a4337 1
  if (hplink->sgot->_raw_size != 0)
d4355 1
a4355 1
  if (hplink->splt->_raw_size != 0)
@


1.39
log
@	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Always
	allocate local .got space.  Use shortcuts from hash table for .got
	and .plt rather than comparing section names.
	(elf32_hppa_check_relocs): Use local_plt_refcounts var rather than
	adjusting index into local_got_refcounts to document what we are
	really doing.
	(elf32_hppa_relocate_section): Similarly for local_plt_offsets.
	Tidy .got and .plt error checking.
@
text
@d152 4
a155 3
   shared object's dynamic section.  */
#ifndef RELATIVE_DYNAMIC_RELOCS
#define RELATIVE_DYNAMIC_RELOCS 0
a211 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
a224 1
#endif
d368 1
a368 6
static boolean allocate_plt_and_got
  PARAMS ((struct elf_link_hash_entry *, PTR));

#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
static boolean hppa_discard_copies
a369 1
#endif
a489 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
a490 1
#endif
d1446 1
a1446 11
		{
		  h->elf.got.refcount = 1;

		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->elf.dynindx == -1)
		    {
		      if (! bfd_elf32_link_record_dynamic_symbol (info,
								  &h->elf))
			return false;
		    }
		}
d1537 4
a1540 1
	  if (h != NULL)
d1566 15
a1580 10
	  if ((sec->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (!info->symbolic
		  || is_absolute_reloc (r_type)
		  || (h != NULL
		      && ((h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
#endif
	      )
a1667 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
d1671 4
a1674 6
		  if (h != NULL
		      && (0
#if RELATIVE_DYNAMIC_RELOCS
			  || ! is_absolute_reloc (rtype)
#endif
			  || (need_entry & NEED_STUBREL)))
d1698 1
a1698 1
			 simplifies code in hppa_discard_copies.  */
a1701 1
#endif
a1928 12
	      return true;
	    }
	}

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
d2046 1
a2046 1
allocate_plt_and_got (h, inf)
d2053 1
d2065 11
d2107 10
d2127 8
a2134 2
  return true;
}
d2136 3
a2138 4
#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
/* This function is called via elf_link_hash_traverse to discard space
   we allocated for relocs that it turned out we didn't need.  */
d2140 16
a2155 8
static boolean
hppa_discard_copies (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf32_hppa_dyn_reloc_entry *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct bfd_link_info *info;
d2157 4
a2160 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  info = (struct bfd_link_info *) inf;
d2164 1
a2164 1
     function, we won't be needing long branch stubs.  s->count will
d2171 5
a2175 3
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	if (s->count == 0)
	  s->section->_raw_size -= sizeof (Elf32_External_Rela);
d2179 2
a2180 2
#if RELATIVE_DYNAMIC_RELOCS
  /* If a symbol has been forced local or we have found a regular
d2183 1
a2183 1
  if (eh->elf.dynindx == -1
d2185 2
a2186 2
	  && !is_absolute_reloc (r_type)
	  && info->symbolic))
d2188 4
a2191 2
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
a2192 1
#endif
a2195 1
#endif
a2242 1

d2332 2
a2333 1
  /* Allocate global sym .plt and .got entries.  */
d2335 2
a2336 14
			  allocate_plt_and_got,
			  info);

#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
  /* If this is a -Bsymbolic shared link, then we need to discard all
     relocs against symbols defined in a regular object.  We also need
     to lose relocs we've allocated for long branch stubs if we know
     we won't be generating a stub.  */
  if (info->shared)
    elf_link_hash_traverse (&hplink->root,
			    hppa_discard_copies,
			    info);
#endif
d3899 24
a3922 13
	     by hppa_discard_copies.  */
	  if ((input_section->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (is_absolute_reloc (r_type)
		  || ((!info->symbolic
		       || (h != NULL
			   && ((h->elf.elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0
			       || h->elf.root.type == bfd_link_hash_defweak)))
		      && (h == NULL || h->elf.dynindx != -1)))
#endif
	      )
d3973 2
@


1.38
log
@	* elf32-hppa.c (allocate_plt_and_got): Skip indirect and warning syms.
@
text
@d1525 1
a1525 1
		  int indx;
d1541 4
a1544 3
		  indx = r_symndx + symtab_hdr->sh_info;
		  if (local_got_refcounts[indx] == -1)
		    local_got_refcounts[indx] = 1;
d1546 1
a1546 1
		    local_got_refcounts[indx] += 1;
d2219 1
a2230 1
      bfd *i;
d2246 11
d2258 10
a2267 10
      /* Set up .got and .plt offsets for local syms.  */
      for (i = info->input_bfds; i; i = i->link_next)
	{
	  bfd_signed_vma *local_got;
	  bfd_signed_vma *end_local_got;
	  bfd_signed_vma *local_plt;
	  bfd_signed_vma *end_local_plt;
	  bfd_size_type locsymcount;
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *srel;
d2269 2
a2270 2
	  if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	    continue;
d2272 3
a2274 3
	  local_got = elf_local_got_refcounts (i);
	  if (!local_got)
	    continue;
d2276 8
a2283 6
	  symtab_hdr = &elf_tdata (i)->symtab_hdr;
	  locsymcount = symtab_hdr->sh_info;
	  end_local_got = local_got + locsymcount;
	  s = hplink->sgot;
	  srel = hplink->srelgot;
	  for (; local_got < end_local_got; ++local_got)
d2285 4
a2288 9
	      if (*local_got > 0)
		{
		  *local_got = s->_raw_size;
		  s->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_got = (bfd_vma) -1;
d2290 3
d2294 10
a2303 2
	  local_plt = end_local_got;
	  end_local_plt = local_plt + locsymcount;
a2319 10
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and allocate space for the necessary .plt entries so
	 that %r19 will be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&hplink->root,
				hppa_handle_PIC_calls,
				info);
    }
a2344 2
      const char *name;

d2348 10
a2357 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d2359 9
a2367 1
      if (strncmp (name, ".rela", 5) == 0)
d2376 1
a2376 1
	      if (strcmp (name+5, ".plt") != 0)
a2393 19
      else if (strcmp (name, ".plt") == 0)
	{
	  if (hplink->need_plt_stub)
	    {
	      /* Make space for the plt stub at the end of the .plt
		 section.  We want this stub right at the end, up
		 against the .got section.  */
	      int gotalign = bfd_section_alignment (dynobj, hplink->sgot);
	      int pltalign = bfd_section_alignment (dynobj, s);
	      bfd_size_type mask;

	      if (gotalign > pltalign)
		bfd_set_section_alignment (dynobj, s, gotalign);
	      mask = ((bfd_size_type) 1 << gotalign) - 1;
	      s->_raw_size = (s->_raw_size + sizeof (plt_stub) + mask) & ~mask;
	    }
	}
      else if (strcmp (name, ".got") == 0)
	;
d3594 1
a3697 1
	      bfd_vma off;
a3700 3
	      if (off == (bfd_vma) -1)
		abort ();

a3724 2

	      relocation = off;
d3729 2
a3730 1
	      bfd_vma off;
d3732 1
a3732 3
	      if (local_got_offsets == NULL
		  || (off = local_got_offsets[r_symndx]) == (bfd_vma) -1)
		abort ();
d3767 1
d3769 2
a3770 2
	      relocation = off;
	    }
d3773 3
a3775 2
	  relocation += (hplink->sgot->output_offset
			 + hplink->sgot->output_section->vma);
a3791 2
	      bfd_vma off;

d3818 4
a3821 1
		  int indx;
d3823 2
a3824 2
		  indx = r_symndx + symtab_hdr->sh_info;
		  off = local_got_offsets[indx];
d3859 1
a3859 1
		      local_got_offsets[indx] |= 1;
d3863 1
a3863 1
	      if (off >= (bfd_vma) -2 || (off & 1) != 0)
d3996 7
a4002 1

@


1.37
log
@2001-06-02  H.J. Lu  <hjl@@gnu.org>

	* elf32-hppa.c (elf32_hppa_object_p): Check ELFOSABI_LINUX
	and ELFOSABI_HPUX.
	* elf64-hppa.c (elf64_hppa_object_p): Likewise.
@
text
@d2080 4
@


1.36
log
@	* elf32-hppa.c (elf32_hppa_check_relocs): Don't NEED_PLT for
	millicode.  Don't allocate .got and .rela.got space here..
	(elf32_hppa_gc_sweep_hook): ..and no need to deallocate here..
	(elf32_hppa_adjust_dynamic_symbol): ..and don't allocate .plt and
	.rela.plt here..
	(hppa_handle_PIC_calls): ..nor here..
	(allocate_plt_and_got): ..instead do it all here.  New function.
	(elf32_hppa_size_dynamic_sections): Allocate local .got space and
	call allocate_plt_and_got.  No need to zap .got if not dynamic.
	(elf32_hppa_final_link): Call regular bfd_final_link instead of
	gc_common_final_link.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(elf32_hppa_relocate_section): Use it here.
	(elf32_hppa_finish_dynamic_symbol): Remove superfluous test of
	dynamic_sections_created.
	(hppa_type_of_stub): Don't LONG_BRANCH_VIA_PLT if millicode sym.
@
text
@d1150 2
a1151 1
  unsigned int flags = elf_elfheader (abfd)->e_flags;
d1153 13
@


1.35
log
@	* elf32-hppa.c (elf32_hppa_relocate_section): Set up .plt entries
	for symbols forced local that need plabels.
	(elf32_hppa_adjust_dynamic_symbol): Don't allocate space in
	.plt.rela for local syms if non-shared.
	(hppa_build_one_stub): Mask lsb of plt.offset.
	(elf32_hppa_finish_dynamic_symbol): Abort if lsb of plt.offset set.
	(clobber_millicode_symbols): Correct comment.
	(elf32_hppa_relocate_section): Likewise.
	(elf32_hppa_finish_dynamic_symbol): Likewise.
@
text
@d369 3
d772 2
a773 1
	  && hash->elf.plt.offset != (bfd_vma) -1)
d1309 12
a1320 1
	     pointing to the PLT entry.  */
d1351 2
a1450 3

		  hplink->sgot->_raw_size += GOT_ENTRY_SIZE;
		  hplink->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d1475 1
a1475 14
		{
		  local_got_refcounts[r_symndx] = 1;

		  hplink->sgot->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
			 output a reloc so that the dynamic linker can
			 adjust this GOT entry (because the address
			 the shared library is loaded at is not fixed).  */
		      hplink->srelgot->_raw_size +=
			sizeof (Elf32_External_Rela);
		    }
		}
a1776 2
  asection *sgot;
  asection *srelgot;
a1788 3
  sgot = hplink->sgot;
  srelgot = hplink->srelgot;

d1801 1
a1801 8
	      {
		h->got.refcount -= 1;
		if (h->got.refcount == 0)
		  {
		    sgot->_raw_size -= GOT_ENTRY_SIZE;
		    srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		  }
	      }
d1806 1
a1806 9
	      {
		local_got_refcounts[r_symndx] -= 1;
		if (local_got_refcounts[r_symndx] == 0)
		  {
		    sgot->_raw_size -= GOT_ENTRY_SIZE;
		    if (info->shared)
		      srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		  }
	      }
d1864 11
a1932 13
      /* Make an entry in the .plt section.  */
      s = hplink->splt;
      h->plt.offset = s->_raw_size;
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
	}
      else
	s->_raw_size += PLT_ENTRY_SIZE;

d1942 1
a1943 9
	  if (h->dynindx != -1 || info->shared)
	    {
	      /* We also need to make an entry in the .rela.plt section.  */
	      s = hplink->srelplt;
	      s->_raw_size += sizeof (Elf32_External_Rela);

	      hplink->need_plt_stub = 1;
	    }
	}
d2035 1
a2035 1
     PTR inf;
a2036 5
  struct bfd_link_info *info;
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *hplink;
  asection *s;

d2051 15
d2068 34
a2101 1
  dynobj = hplink->root.dynobj;
d2103 9
a2111 4
  /* Make an entry in the .plt section.  */
  s = hplink->splt;
  h->plt.offset = s->_raw_size;
  s->_raw_size += PLT_ENTRY_SIZE;
d2228 1
a2228 1
      /* Set up .plt offsets for local plabels.  */
d2231 2
d2237 4
d2242 2
a2243 2
	  local_plt = elf_local_got_refcounts (i);
	  if (!local_plt)
d2248 17
a2264 1
	  local_plt += locsymcount;
d2266 2
a2267 1

a2271 1
		  s = hplink->splt;
d2275 1
a2275 1
		    hplink->srelplt->_raw_size += sizeof (Elf32_External_Rela);
d2291 1
d2293 4
a2296 7
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.  */
      hplink->srelgot->_raw_size = 0;
    }
d3206 2
a3207 3
  /* Invoke the regular ELF garbage collecting linker to do all the
     work.  */
  if (!_bfd_elf32_gc_common_final_link (abfd, info))
d3676 1
d3682 2
a3683 5
	      if (! hplink->root.dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->elf.dynindx == -1)
		      && (h->elf.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0))
d3781 1
a3781 2
		  if (!info->shared
		      && (h->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d4171 8
a4178 9
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (! hplink->root.dynamic_sections_created
	  || (info->shared
	      && (info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
@


1.34
log
@	* elf32-hppa.c (elf32_hppa_relocate_section): Don't allow
	undefined millicode syms in shared libs.
	(hppa_build_one_stub): Turn BFD_ASSERTs into aborts.
	(elf32_hppa_check_relocs): Likewise.
	(elf32_hppa_adjust_dynamic_symbol): Likewise.
	(elf32_hppa_size_dynamic_sections): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	(elf32_hppa_finish_dynamic_symbol): Likewise.
	(elf32_hppa_finish_dynamic_sections): Likewise.
@
text
@d834 1
d942 2
a943 1
      if (stub_entry->h->elf.plt.offset >= (bfd_vma) -2)
d945 3
a947 1
      sym_value = (stub_entry->h->elf.plt.offset
d1021 1
a1021 1
		      hplink->splt->contents + eh->elf.plt.offset);
d1024 1
a1024 1
		      hplink->splt->contents + eh->elf.plt.offset + 4);
d1964 5
a1968 3
	  /* We also need to make an entry in the .rela.plt section.  */
	  s = hplink->srelplt;
	  s->_raw_size += sizeof (Elf32_External_Rela);
d1970 2
a1971 1
	  hplink->need_plt_stub = 1;
d2159 2
a2160 2
  /* Note!  We only want to remove these from the dynamic symbol
     table.  Therefore we do not set ELF_LINK_FORCED_LOCAL.  */
d3694 4
a3697 4
		      /* Output a dynamic *ABS* relocation for this
			 GOT entry.  In this case it is relative to
			 the base of the object because the symbol
			 index is zero.  */
d3745 19
d3809 1
a3809 1
	      if (off >= (bfd_vma) -2)
d4044 3
d4077 2
a4078 2
		 end of the .plt.  This is only done for plt entries
		 with a non-*ABS* dynamic relocation.  */
@


1.33
log
@	* elf32-hppa.c (clobber_millicode_symbols): Temporarily set
	ELF_LINK_FORCED_LOCAL to suit 2001-04-30 change.
	(hppa_build_one_stub): Add an assert to check plt.offset.
@
text
@d941 2
a942 1
      BFD_ASSERT (stub_entry->h->elf.plt.offset < (bfd_vma) -2);
d1002 3
a1004 2
	  BFD_ASSERT (eh->elf.root.type == bfd_link_hash_defined
		      || eh->elf.root.type == bfd_link_hash_defweak);
d1294 2
a1295 1
	  BFD_ASSERT (rel->r_addend == 0);
d1974 3
a1976 2
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
d2180 2
a2181 1
  BFD_ASSERT (dynobj != NULL);
d2191 2
a2192 1
	  BFD_ASSERT (s != NULL);
d3599 2
a3600 1
		   && ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT)
d3633 2
a3634 1
	      BFD_ASSERT (off != (bfd_vma) -1);
d3671 3
a3673 4
	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];
d3783 2
a3784 1
	      BFD_ASSERT (off < (bfd_vma) -2);
d3851 2
a3852 1
		  BFD_ASSERT (sreloc != NULL);
d4124 2
a4125 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
d4146 4
a4149 3
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));
d4195 2
a4196 1
      BFD_ASSERT (sdyn != NULL);
@


1.32
log
@2000-04-27  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_link_hash_hide_symbol): Set dynindx to -1
	only for ELF_LINK_FORCED_LOCAL.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.

	* elflink.h (elf_fix_symbol_flags): Set ELF_LINK_FORCED_LOCAL
	if the symbol has hidden or internal visibility.
@
text
@d941 1
d2151 7
a2157 1
    elf32_hppa_hide_symbol (info, h);
@


1.31
log
@	* elf32-hppa.c (final_link_relocate): Branch to .+8 for
	calls to undefined weak symbols.
@
text
@d1866 2
a1867 1
  h->dynindx = -1;
@


1.30
log
@Prevent NULL pointer dereference.
@
text
@d3274 5
a3278 2
	      /* It's OK if undefined weak.  Make undefined weak
		 branches go nowhere.  */
d3280 1
a3280 1
	      addend = 0;
@


1.29
log
@Don't assume non-PIC to PIC call stubs are unneeded just because
the function happens to have a plabel.
@
text
@d3092 1
a3092 1
  if (sec != NULL)
@


1.28
log
@Update copyright notices
@
text
@d228 4
d497 1
d729 1
a729 1
	  || hash->pic_call))
d1898 8
d1922 2
a1923 8
	  if (!info->shared
	      && h->plt.refcount > 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	    {
	      ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;
	    }
d2069 1
d3255 6
a3260 5
	  || (h != NULL &&
	      (h->pic_call
	       || (h->elf.root.type == bfd_link_hash_defweak
		   && h->elf.dynindx != -1
		   && h->elf.plt.offset != (bfd_vma) -1))))
@


1.27
log
@Fix some comments, and a formatting error.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.26
log
@(elf32_hppa_set_gp): Handle weak $global$.
If $global$ referenced but not defined, set its value here.
@
text
@d67 2
a68 2
   :		addil L'X - ($PIC_pcrel$0 - 4),%r1
   :		be,n R'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)
d72 2
a73 2
   :		addil L'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw R'lt_ptr+ltoff(%r1),%r21
d75 1
a75 1
   :		ldw R'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
d79 2
a80 2
   :		addil L'ltoff,%r19		; get procedure entry point
   :		ldw R'ltoff(%r1),%r21
d82 1
a82 1
   :		ldw R'ltoff+4(%r1),%r19		; get new dlt value.
d86 3
a88 3
   :		addil L'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw R'lt_ptr+ltoff(%r1),%r21
   :		ldw R'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
d96 3
a98 3
   :		addil L'ltoff,%r19		; get procedure entry point
   :		ldw R'ltoff(%r1),%r21
   :		ldw R'ltoff+4(%r1),%r19		; get new dlt value.
d784 1
a784 1
#define ADDIL_R1	0x28200000	/* addil L'XXX,%r1,%r1		*/
d787 2
a788 2
#define ADDIL_DP	0x2b600000	/* addil L'XXX,%dp,%r1		*/
#define LDW_R1_R21	0x48350000	/* ldw   R'XXX(%sr0,%r1),%r21	*/
d790 1
a790 1
#define LDW_R1_R19	0x48330000	/* ldw   R'XXX(%sr0,%r1),%r19	*/
d792 2
a793 2
#define ADDIL_R19	0x2a600000	/* addil L'XXX,%r19,%r1		*/
#define LDW_R1_DP	0x483b0000	/* ldw   R'XXX(%sr0,%r1),%dp	*/
d2141 1
a2141 1
    elf32_hppa_hide_symbol(info, h);
@


1.25
log
@Linux target variants for elfxx-hppa.
@
text
@d3027 3
a3029 1
  if (h != NULL && h->root.type == bfd_link_hash_defined)
d3071 10
@


1.25.2.1
log
@(elf32_hppa_set_gp): Handle weak $global$.
If $global$ referenced but not defined, set its value here.
@
text
@d3027 1
a3027 3
  if (h != NULL
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak))
a3068 10
	}

      if (h != NULL)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.value = gp_val;
	  if (sec != NULL)
	    h->root.u.def.section = sec;
	  else
	    h->root.u.def.section = bfd_abs_section_ptr;
@


1.25.2.2
log
@Copy elf32-hppa.c from trunk to get 2001-02-27 and 2001-03-15 patches.
Fix typos in gas/ChangeLog-9899
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
d67 2
a68 2
   :		addil LR'X - ($PIC_pcrel$0 - 4),%r1
   :		be,n RR'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)
d72 2
a73 2
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
d75 1
a75 1
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
d79 2
a80 2
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
d82 1
a82 1
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.
d86 3
a88 3
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
d96 3
a98 3
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.
a227 4
  unsigned int maybe_pic_call:1;

  /* Set if the only reason we need a .plt entry is for a non-PIC to
     PIC function call.  */
a492 1
      ret->maybe_pic_call = 0;
d724 1
a724 1
	  || (hash->maybe_pic_call && !(input_sec->flags & SEC_HAS_GOT_REF))))
d784 1
a784 1
#define ADDIL_R1	0x28200000	/* addil LR'XXX,%r1,%r1		*/
d787 2
a788 2
#define ADDIL_DP	0x2b600000	/* addil LR'XXX,%dp,%r1		*/
#define LDW_R1_R21	0x48350000	/* ldw   RR'XXX(%sr0,%r1),%r21	*/
d790 1
a790 1
#define LDW_R1_R19	0x48330000	/* ldw   RR'XXX(%sr0,%r1),%r19	*/
d792 2
a793 2
#define ADDIL_R19	0x2a600000	/* addil LR'XXX,%r19,%r1	*/
#define LDW_R1_DP	0x483b0000	/* ldw   RR'XXX(%sr0,%r1),%dp	*/
a1892 8
      if (!info->shared
	  && h->plt.refcount > 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	{
	  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
	}

d1909 8
a1916 2
	  if (((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call)
	    ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;
a2061 1
  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
d2141 1
a2141 1
    elf32_hppa_hide_symbol (info, h);
d3247 5
a3251 6
	  || (h != NULL
	      && ((h->maybe_pic_call
		   && !(input_section->flags & SEC_HAS_GOT_REF))
		  || (h->elf.root.type == bfd_link_hash_defweak
		      && h->elf.dynindx != -1
		      && h->elf.plt.offset != (bfd_vma) -1))))
@


1.25.2.3
log
@Prevent NULL pointer dereference.
@
text
@d3092 1
a3092 1
  if (sec != NULL && sec->output_section != NULL)
@


1.25.2.4
log
@	* elf32-hppa.c (final_link_relocate): Branch to .+8 for
	calls to undefined weak symbols.
@
text
@d3274 2
a3275 5
	      /* It's OK if undefined weak.  Calls to undefined weak
		 symbols behave as if the "called" function
		 immediately returns.  We can thus call to a weak
		 function without first checking whether the function
		 is defined.  */
d3277 1
a3277 1
	      addend = 8;
@


1.25.2.5
log
@Merge from mainline.
@
text
@a940 1
      BFD_ASSERT (stub_entry->h->elf.plt.offset < (bfd_vma) -2);
@


1.25.2.6
log
@Merge from mainline.
@
text
@a368 3
static boolean allocate_plt_and_got
  PARAMS ((struct elf_link_hash_entry *, PTR));

d769 1
a769 2
	  && hash->elf.plt.offset != (bfd_vma) -1
	  && hash->elf.type != STT_PARISC_MILLI)
a833 1
  bfd_vma off;
d941 2
a942 6
      off = stub_entry->h->elf.plt.offset;
      if (off >= (bfd_vma) -2)
	abort ();

      off &= ~ (bfd_vma) 1;
      sym_value = (off
d1001 2
a1002 3
	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    abort ();
d1015 1
a1015 1
		      hplink->splt->contents + off);
d1018 1
a1018 1
		      hplink->splt->contents + off + 4);
d1140 1
a1140 2
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;
a1141 13
  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
	return false;
    }
  else
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
	return false;
    }

  flags = i_ehdrp->e_flags;
d1292 1
a1292 2
	  if (rel->r_addend != 0)
	    abort ();
d1298 1
a1298 12
	     pointing to the PLT entry.
	     For executables, the original 32-bit ABI allowed two
	     different styles of PLABELs (function pointers):  For
	     global functions, the PLABEL word points into the .plt
	     two bytes past a (function address, gp) pair, and for
	     local functions the PLABEL points directly at the
	     function.  The magic +2 for the first type allows us to
	     differentiate between the two.  As you can imagine, this
	     is a real pain when it comes to generating code to call
	     functions indirectly or to compare function pointers.
	     We avoid the mess by always pointing a PLABEL into the
	     .plt, even for local functions.  */
a1328 2
	      if (h->elf.type == STT_PARISC_MILLI)
		need_entry = NEED_STUBREL;
d1427 3
d1454 14
a1467 1
		local_got_refcounts[r_symndx] = 1;
d1769 2
d1783 3
d1798 8
a1805 1
	      h->got.refcount -= 1;
d1810 9
a1818 1
	      local_got_refcounts[r_symndx] -= 1;
d1867 1
a1867 2
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
a1874 11
/* This is the condition under which elf32_hppa_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_hppa_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1933 13
d1955 6
a1961 1

d1970 2
a1971 3
      if (h->weakdef->root.type != bfd_link_hash_defined
	  && h->weakdef->root.type != bfd_link_hash_defweak)
	abort ();
d2052 1
a2052 1
     PTR inf ATTRIBUTE_UNUSED;
d2054 5
a2072 19
  return true;
}

/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */

static boolean
allocate_plt_and_got (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *hplink;
  asection *s;

  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
    return true;

d2075 1
a2075 16
  if ((hplink->root.dynamic_sections_created
       && h->plt.refcount > 0)
      || ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
    {
      /* Make an entry in the .plt section.  */
      s = hplink->splt;
      h->plt.offset = s->_raw_size;
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
	}
      else
	s->_raw_size += PLT_ENTRY_SIZE;
d2077 4
a2080 27
      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  /* We also need to make an entry in the .rela.plt section.  */
	  hplink->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  hplink->need_plt_stub = 1;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      boolean dyn;

      s = hplink->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
      dyn = hplink->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	hplink->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;
d2147 2
a2148 2
  /* We only want to remove these from the dynamic symbol table.
     Therefore we do not leave ELF_LINK_FORCED_LOCAL set.  */
d2150 1
a2150 7
    {
      unsigned short oldflags = h->elf_link_hash_flags;
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      elf32_hppa_hide_symbol (info, h);
      h->elf_link_hash_flags &= ~ELF_LINK_FORCED_LOCAL;
      h->elf_link_hash_flags |= oldflags & ELF_LINK_FORCED_LOCAL;
    }
d2169 1
a2169 2
  if (dynobj == NULL)
    abort ();
d2179 1
a2179 2
	  if (s == NULL)
	    abort ();
d2189 1
a2189 1
      /* Set up .got and .plt offsets for local syms.  */
a2191 2
	  bfd_signed_vma *local_got;
	  bfd_signed_vma *end_local_got;
a2195 4
	  asection *srel;

	  if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	    continue;
d2197 2
a2198 2
	  local_got = elf_local_got_refcounts (i);
	  if (!local_got)
d2203 2
a2204 15
	  end_local_got = local_got + locsymcount;
	  s = hplink->sgot;
	  srel = hplink->srelgot;
	  for (; local_got < end_local_got; ++local_got)
	    {
	      if (*local_got > 0)
		{
		  *local_got = s->_raw_size;
		  s->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_got = (bfd_vma) -1;
	    }
a2205 4
	  local_plt = end_local_got;
	  end_local_plt = local_plt + locsymcount;
	  s = hplink->splt;
	  srel = hplink->srelplt;
d2210 1
d2214 1
a2214 1
		    srel->_raw_size += sizeof (Elf32_External_Rela);
d2230 7
a2238 5
  /* Allocate global sym .plt and .got entries.  */
  elf_link_hash_traverse (&hplink->root,
			  allocate_plt_and_got,
			  info);

d3147 3
a3149 2
  /* Invoke the regular ELF linker to do all the work.  */
  if (!bfd_elf32_bfd_final_link (abfd, info))
d3586 1
a3586 2
		   && ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   && h->elf.type != STT_PARISC_MILLI)
a3616 1
	      boolean dyn;
d3619 1
a3619 2
	      if (off == (bfd_vma) -1)
		abort ();
d3621 5
a3625 2
	      dyn = hplink->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
d3656 4
a3659 3
	      if (local_got_offsets == NULL
		  || (off = local_got_offsets[r_symndx]) == (bfd_vma) -1)
		abort ();
d3673 4
a3676 4
		      /* Output a dynamic relocation for this GOT
			 entry.  In this case it is relative to the
			 base of the object because the symbol index
			 is zero.  */
a3723 18
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, &h->elf))
		    {
		      /* In a non-shared link, adjust_dynamic_symbols
			 isn't called for symbols forced local.  We
			 need to write out the plt entry here.  */ 
		      if ((off & 1) != 0)
			off &= ~1;
		      else
			{
			  bfd_put_32 (output_bfd,
				      relocation,
				      hplink->splt->contents + off);
			  bfd_put_32 (output_bfd,
				      elf_gp (hplink->splt->output_section->owner),
				      hplink->splt->contents + off + 4);
			  h->elf.plt.offset |= 1;
			}
		    }
d3769 1
a3769 2
	      if (off >= (bfd_vma) -2 || (off & 1) != 0)
		abort ();
d3836 1
a3836 2
		  if (sreloc == NULL)
		    abort ();
a4001 3
      if (h->plt.offset & 1)
	abort ();

d4032 2
a4033 2
		 end of the .plt.  This is not done for plt entries
		 with a base-relative dynamic relocation.  */
d4091 9
a4099 8
      /* If this is a -Bsymbolic link and the symbol is defined
	 locally or was forced to be local because of a version file,
	 we just want to emit a RELATIVE reloc.  The entry in the
	 global offset table will already have been initialized in the
	 relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d4108 1
a4108 2
	  if ((h->got.offset & 1) != 0)
	    abort ();
d4129 3
a4131 4
      if (! (h->dynindx != -1
	     && (h->root.type == bfd_link_hash_defined
		 || h->root.type == bfd_link_hash_defweak)))
	abort ();
d4177 1
a4177 2
      if (sdyn == NULL)
	abort ();
@


1.25.2.7
log
@	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Always
	allocate local .got space.  Use shortcuts from hash table for .got
	and .plt rather than comparing section names.
	(elf32_hppa_check_relocs): Use local_plt_refcounts var rather than
	adjusting index into local_got_refcounts to document what we are
	really doing.
	(elf32_hppa_relocate_section): Similarly for local_plt_offsets.
	Tidy .got and .plt error checking.
@
text
@d1525 1
a1525 1
		  bfd_signed_vma *local_plt_refcounts;
d1541 3
a1543 4
		  local_plt_refcounts = (local_got_refcounts
					 + symtab_hdr->sh_info);
		  if (local_plt_refcounts[r_symndx] == -1)
		    local_plt_refcounts[r_symndx] = 1;
d1545 1
a1545 1
		    local_plt_refcounts[r_symndx] += 1;
a2217 1
  bfd *i;
d2229 2
a2244 11
    }
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and allocate space for the necessary .plt entries so
	 that %r19 will be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&hplink->root,
				hppa_handle_PIC_calls,
				info);
    }
d2246 10
a2255 10
  /* Set up .got and .plt offsets for local syms.  */
  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_signed_vma *local_plt;
      bfd_signed_vma *end_local_plt;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d2257 2
a2258 2
      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	continue;
d2260 3
a2262 3
      local_got = elf_local_got_refcounts (i);
      if (!local_got)
	continue;
d2264 6
a2269 8
      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = hplink->sgot;
      srel = hplink->srelgot;
      for (; local_got < end_local_got; ++local_got)
	{
	  if (*local_got > 0)
d2271 9
a2279 4
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rela);
a2280 3
	  else
	    *local_got = (bfd_vma) -1;
	}
d2282 2
a2283 10
      local_plt = end_local_got;
      end_local_plt = local_plt + locsymcount;
      if (! hplink->root.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_plt < end_local_plt; ++local_plt)
	    *local_plt = (bfd_vma) -1;
	}
      else
	{
d2300 10
d2335 2
d2340 3
a2342 10
      if (s == hplink->splt)
	{
	  if (hplink->need_plt_stub)
	    {
	      /* Make space for the plt stub at the end of the .plt
		 section.  We want this stub right at the end, up
		 against the .got section.  */
	      int gotalign = bfd_section_alignment (dynobj, hplink->sgot);
	      int pltalign = bfd_section_alignment (dynobj, s);
	      bfd_size_type mask;
d2344 1
a2344 9
	      if (gotalign > pltalign)
		bfd_set_section_alignment (dynobj, s, gotalign);
	      mask = ((bfd_size_type) 1 << gotalign) - 1;
	      s->_raw_size = (s->_raw_size + sizeof (plt_stub) + mask) & ~mask;
	    }
	}
      else if (s == hplink->sgot)
	;
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d2353 1
a2353 1
	      if (s != hplink->srelplt)
d2371 19
a3589 1
      bfd_vma off;
d3693 1
d3697 3
d3724 2
d3730 4
a3733 1
	      if (local_got_offsets == NULL)
a3735 2
	      off = local_got_offsets[r_symndx];

d3769 2
a3772 3
	  if (off >= (bfd_vma) -2)
	    abort ();

d3774 2
a3775 3
	  relocation = (off
			+ hplink->sgot->output_offset
			+ hplink->sgot->output_section->vma);
d3792 2
d3820 1
a3820 4
		  bfd_vma *local_plt_offsets;

		  if (local_got_offsets == NULL)
		    abort ();
d3822 2
a3823 2
		  local_plt_offsets = local_got_offsets + symtab_hdr->sh_info;
		  off = local_plt_offsets[r_symndx];
d3858 1
a3858 1
		      local_plt_offsets[r_symndx] |= 1;
d3862 1
a3862 1
	      if (off >= (bfd_vma) -2)
@


1.24
log
@Use SEGREL32 relocs for elf32-hppa unwind.
@
text
@d402 3
d4239 21
d4296 1
d4312 8
@


1.23
log
@Correct DT_INIT/DT_FINI ABI violation
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
d275 5
d377 6
d392 3
d532 2
d1324 1
a1324 1
	case R_PARISC_SEGREL32: /* Relative reloc.  */
d1366 1
a1366 1
	case R_PARISC_DIR32: /* .word, PARISC.unwind relocs.  */
d3114 70
d3309 7
d3675 9
d3928 26
d4256 1
a4256 1
#define bfd_elf32_bfd_final_link	     _bfd_elf32_gc_common_final_link
@


1.22
log
@2000-12-05  Kazu Hirata  <kazu@@hxi.com>

	* elf32-fr30.c: Fix formatting.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-i960.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a2144 1
      const char *funcname;
a2160 48
      /* DT_INIT and DT_FINI need a .plt entry.  Make sure they have
	 one.  */
      funcname = info->init_function;
      while (1)
	{
	  if (funcname != NULL)
	    {
	      struct elf_link_hash_entry *h;

	      h = elf_link_hash_lookup (&hplink->root,
					funcname,
					false, false, false);
	      if (h != NULL
		  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
						| ELF_LINK_HASH_DEF_REGULAR)))
		{
		  if (h->plt.refcount <= 0)
		    {
		      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

		      /* Make an entry in the .plt section.  We know
			 the function doesn't have a plabel by the
			 refcount.  */
		      s = hplink->splt;
		      h->plt.offset = s->_raw_size;
		      s->_raw_size += PLT_ENTRY_SIZE;

		      /* Make sure this symbol is output as a dynamic
			 symbol.  */
		      if (h->dynindx == -1)
			{
			  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
			    return false;
			}

		      /* Make an entry for the reloc too.  */
		      s = hplink->srelplt;
		      s->_raw_size += sizeof (Elf32_External_Rela);
		    }

		  ((struct elf32_hppa_link_hash_entry *) h)->plt_abs = 1;
		}
	    }
	  if (funcname == info->fini_function)
	    break;
	  funcname = info->fini_function;
	}

a4056 25

	    case DT_INIT:
	    case DT_FINI:
	      {
		struct elf_link_hash_entry *h;
		const char *funcname;

		if (dyn.d_tag == DT_INIT)
		  funcname = info->init_function;
		else
		  funcname = info->fini_function;

		h = elf_link_hash_lookup (&hplink->root, funcname,
					  false, false, false);

		/* This is a function pointer.  The magic +2 offset
		   signals to $$dyncall that the function pointer
		   is in the .plt and thus has a gp pointer too.  */
		dyn.d_un.d_ptr = (h->plt.offset
				  + hplink->splt->output_offset
				  + hplink->splt->output_section->vma
				  + 2);
		bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		break;
	      }
@


1.21
log
@Correct call to _bfd_elf32_gc_record_vtable.
@
text
@a37 1

a48 1

a156 1

a165 1

a196 1

a237 1

a286 1

a303 1

a328 1

a390 1

a437 1

a483 1

a525 1

a565 1

a623 1

a681 1

a757 1

a1067 1

a1107 1

a1130 1

a1147 1

a1188 1

a1676 1

a1724 1

a1833 1

a1849 1

a2017 1

a2056 1

a2106 1

a2125 1

d2171 1
a2171 1
	      h = elf_link_hash_lookup (&hplink->root, 
a2409 1

a3039 1

a3108 1

a3146 1

a3398 1

d3730 1
a3730 1
			   && ((h->elf.elf_link_hash_flags 
a3874 1

a4049 1

d4112 1
a4112 1
 
a4181 1

a4193 1

@


1.20
log
@.plt stub for lazy linking, --stub-group-size=N ld switch,
import stub fix, extra DIR14F reloc to fix abort in tc_gen_reloc
@
text
@d1389 1
a1389 1
					     &h->elf, rel->r_offset))
d1492 3
a1494 4
		  /* If this .plt entry is for a plabel, we need an
		     extra word for ld.so.  adjust_dynamic_symbol will
		     also keep the entry even if it appears to be
		     local.  */
@


1.19
log
@Correct comments.  Don't check non-code output sections for stub
grouping.  (In the process, partly revert and fix bugs introduced
with the last change.  Oops.)
@
text
@d123 12
a254 3
  /* Whether we support multiple sub-spaces for shared libs.  */
  boolean multi_subspace;

d280 11
a520 1
  ret->multi_subspace = 0;
d530 4
d922 1
a922 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_lsel);
d926 1
a926 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_rsel) >> 2;
d944 1
a944 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lsel),
d948 6
a953 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rsel);
d959 1
a959 1
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rsel);
d973 1
a973 1
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rsel);
a1176 2
  flagword flags;
  asection *s;
d1188 1
a1188 8
  /* Our .plt just contains pointers.  I suppose we should be using
     .plt.got but .plt.got doesn't make too much sense without a .plt
     section.  Set the flags to say the .plt isn't executable.  */
  s = bfd_get_section_by_name (abfd, ".plt");
  flags = bfd_get_section_flags (abfd, s);
  if (! bfd_set_section_flags (abfd, s, flags & ~SEC_CODE))
    return false;
  hplink->splt = s;
d1300 2
d1304 2
d1307 2
a1308 2
	  /* Handle calls, and function pointers as they might need to
	     go through the .plt, and might require long branch stubs.  */
d1355 2
a1356 1
	case R_PARISC_DIR14R: /* Used for load/store from absolute locn.  */
d1959 2
d2324 1
d2329 1
a2329 4
		{
		  const char *outname;

		  relocs = true;
d2331 9
a2339 13
		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d2347 16
a2362 1
	;
d2451 1
a2451 1
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace,
d2457 1
d2468 2
d2480 14
d2545 1
a2545 1
      if ((section->flags & SEC_CODE) != 0 && section->index <= top_index)
d2601 1
a2601 1
		     < 250000))
d2625 1
a2625 4
	  total = 0;
	  while (prev != NULL
		 && ((total += tail->output_offset - prev->output_offset)
		     < 250000))
d2627 9
a2635 3
	      tail = prev;
	      prev = PREV_SEC (tail);
	      hplink->stub_group[tail->id].link_sec = curr;
d3314 1
d3747 1
a3930 1
      Elf_Internal_Rela rel;
d3938 1
a3938 9
	 <used by ld.so>

	 The last field is present only for plt entries that are used
	 by global plabels.  */

      /* We do not actually care about the value in the PLT entry if
	 we are creating a shared library and the symbol is still
	 undefined;  We create a dynamic relocation to fill in the
	 correct value.  */
d3949 1
a3949 9
      bfd_put_32 (hplink->splt->owner,
		  value,
		  hplink->splt->contents + h->plt.offset);
      bfd_put_32 (hplink->splt->owner,
		  elf_gp (hplink->splt->output_section->owner),
		  hplink->splt->contents + h->plt.offset + 4);
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && h->dynindx != -1)
d3951 1
a3951 3
	  memset (hplink->splt->contents + h->plt.offset + 8,
		  0, PLABEL_PLT_ENTRY_SIZE - PLT_ENTRY_SIZE);
	}
a3952 2
      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
d3960 9
d3988 14
d4184 1
a4184 1
      bfd_put_32 (output_bfd, (bfd_vma) 0, hplink->sgot->contents + 4);
a4190 1
  /* Set plt entry size.  */
d4192 24
a4215 2
    elf_section_data (hplink->splt->output_section)
      ->this_hdr.sh_entsize = PLT_ENTRY_SIZE;
@


1.18
log
@Fix a segfault caused by under-allocating an array.
@
text
@d2443 2
a2444 9
  /* Count the number of input BFDs, find the top input section id,
     and the top output section index.  We can't use output_bfd
     section_count here to find the top output section index as some
     sections may have been removed, and _bfd_strip_section_from_output
     doesn't renumber the indices.  Also, sections created by the
     linker aren't counted, and to make matters worse, aren't even on
     the output_bfd section list.  We could probably just ignore
     sections created by the linker, but this way seems safer.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0, top_index = 0;
a2454 4
	  if (section->output_section != NULL
	      && section->output_section->owner == output_bfd
	      && top_index < section->output_section->index)
	    top_index = section->output_section->index;
d2463 14
a2476 1
  /* Now make a list of input sections for each output section.  */
d2478 1
a2478 1
    = (asection **) bfd_zmalloc (sizeof (asection *) * (top_index + 1));
d2482 16
d2507 2
a2508 1
	      && section->output_section->owner == output_bfd)
d2511 3
a2513 1
	      /* Steal the link_sec pointer for our list.  */
d2515 5
a2519 4
	      /* This happens to make the list in reverse order, which
		 is what we want.  */
	      PREV_SEC (section) = *list;
	      *list = section;
d2531 1
a2531 1
  while (list-- != input_list)
d2534 2
d2585 1
d2587 1
@


1.17
log
@Group stub sections.
@
text
@d1540 1
a1540 2
			   & ELF_LINK_HASH_DEF_REGULAR) == 0
			  || h->elf.root.type == bfd_link_hash_defweak)))
d2098 1
a2098 1
	  && eh->elf.root.type != bfd_link_hash_defweak
d2443 9
a2451 2
  /* Count the number of input BFDs and find the top section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
d2462 4
d2474 1
a2474 12
  /* Now make a list of input sections for each output section.
     We can't use output_bfd->section_count here as some sections may
     have been removed, and _bfd_strip_section_from_output doesn't
     renumber the indices.  Sections may also be re-ordered, so the
     last section index isn't necessarily the biggest.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }
d2508 1
a2508 1
  list = input_list + output_bfd->section_count;
@


1.16
log
@Find the first .init and .fini sections correctly.
Clobber millicode syms via a hash traversal here.  elf_adjust_dynamic_symbol
really ought to let us look at all dynamic symbols, but it doesn't.
@
text
@d184 3
a186 2
  /* Where this stub is being called from.  */
  asection *input_section;
d250 8
a257 2
  /* Arrays to keep track of which stub sections have been created.  */
  asection **stub_section_created;
d259 2
a260 1
  asection **reloc_section_created;
d262 1
a262 2
  int first_init_sec;
  int first_fini_sec;
d301 2
a302 1
	   const Elf_Internal_Rela *, struct bfd_link_info *));
d305 1
a305 2
  PARAMS ((const char *, asection *, unsigned int,
	   struct bfd_link_info *));
d363 1
a363 1
	   bfd_vma, struct bfd_link_info *, asection *,
d422 1
a422 1
      ret->input_section = NULL;
d504 1
a504 6
  ret->stub_section_created = NULL;
#if ! LONG_BRANCH_PIC_IN_SHLIB
  ret->reloc_section_created = NULL;
#endif
  ret->first_init_sec = 0;
  ret->first_fini_sec = 0;
d561 1
a561 1
hppa_get_stub_entry (input_section, sym_sec, hash, rel, info)
d566 1
a566 1
     struct bfd_link_info *info;
d569 8
d580 1
a580 1
      && hash->stub_cache->input_section == input_section)
a585 1
      struct bfd_hash_table *stub_hash_table;
d588 1
a588 1
      stub_name = hppa_stub_name (input_section, sym_sec, hash, rel);
d592 2
a593 4
      stub_hash_table = &hppa_link_hash_table (info)->stub_hash_table;

      stub_entry = hppa_stub_hash_lookup (stub_hash_table, stub_name,
					  false, false);
d620 1
a620 1
hppa_add_stub (stub_name, section, sec_count, info)
d623 1
a623 2
     unsigned int sec_count;
     struct bfd_link_info *info;
d625 1
a627 1
  struct elf32_hppa_link_hash_table *hplink;
d629 2
a630 2
  hplink = hppa_link_hash_table (info);
  stub_sec = hplink->stub_section_created[sec_count];
d633 1
a633 5
      if (strncmp (section->name, ".init", 5) == 0)
	stub_sec = hplink->stub_section_created[hplink->first_init_sec - 1];
      else if (strncmp (section->name, ".fini", 5) == 0)
	stub_sec = hplink->stub_section_created[hplink->first_fini_sec - 1];

d639 1
a639 1
	  len = strlen (section->name) + sizeof (STUB_SUFFIX);
d644 1
a644 1
	  strcpy (s_name, section->name);
d646 1
a646 1
	  stub_sec = (*hplink->add_stub_section) (s_name, section);
d649 1
d651 1
a651 1
      hplink->stub_section_created[sec_count] = stub_sec;
d667 1
a667 1
  stub_entry->reloc_sec = hplink->reloc_section_created[sec_count];
d670 1
a670 1
  stub_entry->input_section = section;
d728 1
a728 1
  else /* R_PARISC_PCREL22F  */
d1377 1
a1377 1
             relocation for this entry.  */
d2124 2
d2127 1
a2127 4
    {
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      elf32_hppa_hide_symbol(info, h);
    }
d2190 1
a2190 1
			 refcount  */
d2417 1
a2417 1
elf32_hppa_size_stubs (stub_bfd, multi_subspace, info,
d2419 1
d2421 1
a2422 1
     struct bfd_link_info *info;
d2428 1
d2430 2
a2431 1
  unsigned int i, indx, bfd_count, sec_count;
d2434 1
d2444 2
a2445 2
  /* Count the number of input BFDs and the total number of input sections.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, sec_count = 0;
d2450 7
a2456 1
      sec_count += input_bfd->section_count;
d2459 20
a2478 3
  hplink->stub_section_created
    = (asection **) bfd_zmalloc (sizeof (asection *) * sec_count);
  if (hplink->stub_section_created == NULL)
d2481 82
a2562 6
#if ! LONG_BRANCH_PIC_IN_SHLIB
  hplink->reloc_section_created
    = (asection **) bfd_zmalloc (sizeof (asection *) * sec_count);
  if (hplink->reloc_section_created == NULL)
    goto error_ret_free_stub;
#endif
d2571 1
a2571 1
    goto error_ret_free_reloc;
d2576 1
a2576 1
  for (input_bfd = info->input_bfds, indx = 0, sec_count = 0;
d2578 1
a2578 1
       input_bfd = input_bfd->link_next, indx++)
d2582 1
a2582 1
      Elf32_External_Sym *ext_syms, *esym;
d2597 1
a2597 1
      all_local_syms[indx] = local_syms;
d2618 1
a2618 1
      for (i = 0; i < symtab_hdr->sh_info; i++, esym++, isym++)
a2623 23
      /* Go looking for .init and .fini sections.  We only want one
	 stub section for each of .init* and .fini* because glibc
	 splits the _init and _fini functions into multiple parts, and
	 putting a stub in the middle of a function is not a good idea.
	 It would be better to merge all the stub sections for an
	 output section if the output section + stubs is small enough.
	 This would fix the .init and .fini case and also allow stubs
	 to be merged.  It's more linker work though.  */
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next, sec_count++)
	{
	  if (hplink->first_init_sec == 0)
	    {
	      if (strncmp (section->name, ".init", 5) == 0)
		hplink->first_init_sec = sec_count + 1;
	    }
	  if (hplink->first_fini_sec == 0)
	    {
	      if (strncmp (section->name, ".fini", 5) == 0)
		hplink->first_fini_sec = sec_count + 1;
	    }

d2625 8
a2632 6
	  /* If this is a shared link, find all the stub reloc
	     sections.  */
	  if (info->shared)
	    {
	      char *name;
	      asection *reloc_sec;
d2634 10
a2643 10
	      name = bfd_malloc (strlen (section->name)
				 + sizeof STUB_SUFFIX
				 + 5);
	      if (name == NULL)
		return false;
	      sprintf (name, ".rela%s%s", section->name, STUB_SUFFIX);
	      reloc_sec = bfd_get_section_by_name (hplink->root.dynobj, name);
	      hplink->reloc_section_created[sec_count] = reloc_sec;
	      free (name);
	    }
a2644 1
	}
d2648 2
a2649 1
	  unsigned int symndx;
d2654 2
d2659 1
a2659 1
	  for (symndx = 0; symndx < symcount; symndx++)
d2663 1
a2663 2
	      hash = ((struct elf32_hppa_link_hash_entry *)
		      elf_sym_hashes (input_bfd)[symndx]);
d2677 2
d2695 1
a2695 5
		      stub_entry = hppa_add_stub (stub_name,
						  sec,
						  (sec_count + sec->index
						   - input_bfd->section_count),
						  info);
d2720 1
a2720 1
      for (input_bfd = info->input_bfds, indx = 0, sec_count = 0;
d2722 1
a2722 1
	   input_bfd = input_bfd->link_next, indx++)
d2731 1
a2731 1
	  local_syms = all_local_syms[indx];
d2736 1
a2736 1
	       section = section->next, sec_count++)
d2748 6
d2810 1
d2898 3
d2902 1
a2902 1
		  stub_name = hppa_stub_name (section, sym_sec, hash, irela);
d2916 1
a2916 2
		  stub_entry = hppa_add_stub (stub_name, section,
					      sec_count, info);
d2956 14
a2969 9
      for (i = 0; i < sec_count; i++)
	{
	  stub_sec = hplink->reloc_section_created[i];
	  if (stub_sec != NULL)
	    {
	      stub_sec->_raw_size = 0;
	      stub_sec->_cooked_size = 0;
	    }
	}
d2981 1
a2981 10
  /* We're done with the local symbols, free them.  */
  for (i = 0; i < bfd_count; i++)
    if (all_local_syms[i])
      free (all_local_syms[i]);
  free (all_local_syms);
#if ! LONG_BRANCH_PIC_IN_SHLIB
  free (hplink->reloc_section_created);
#endif
  free (hplink->stub_section_created);
  return true;
d2984 3
a2986 3
  for (i = 0; i < bfd_count; i++)
    if (all_local_syms[i])
      free (all_local_syms[i]);
d2989 1
a2989 7
 error_ret_free_reloc:
#if ! LONG_BRANCH_PIC_IN_SHLIB
  free (hplink->reloc_section_created);
 error_ret_free_stub:
#endif
  free (hplink->stub_section_created);
  return false;
d3105 1
a3105 1
final_link_relocate (input_section, contents, rel, value, info, sym_sec, h)
d3110 1
a3110 1
     struct bfd_link_info *info;
d3157 1
a3157 1
					    h, rel, info);
d3292 1
a3292 1
					    h, rel, info);
d3487 2
a3488 2
         determine what types of dynamic info we need to output, if
         any.  */
d3787 1
a3787 1
			       info, sym_sec, h);
@


1.15
log
@Lots of bug fixes.  .plt entries for DT_INIT, DT_FINI, and any
local function that has a plabel.  Size the stub reloc sections
as we size the stubs.
@
text
@d348 3
a626 9
      int special_sec = 0;

      /* We only want one stub for .init and .fini because glibc
	 splits the _init and _fini functions into two parts.  We
	 don't want to put a stub in the middle of a function.
	 It would be better to merge all the stub sections for an
	 output section if the output section + stubs is small enough.
	 This would fix the .init and .fini case and also allow stubs
	 to be merged.  It's more linker work though.  */
d628 1
a628 5
	{
	  if (hplink->first_init_sec != 0)
	    stub_sec = hplink->stub_section_created[hplink->first_init_sec-1];
	  special_sec = 1;
	}
d630 2
a631 5
	{
	  if (hplink->first_fini_sec != 0)
	    stub_sec = hplink->stub_section_created[hplink->first_fini_sec-1];
	  special_sec = 2;
	}
a646 8

	  if (special_sec != 0)
	    {
	      if (special_sec == 1)
		hplink->first_init_sec = sec_count + 1;
	      else
		hplink->first_fini_sec = sec_count + 1;
	    }
d2109 21
d2161 5
d2519 44
d2610 2
a2611 1
						  sec_count + sec->index,
a2630 24
#if LONG_BRANCH_PIC_IN_SHLIB
      sec_count += input_bfd->section_count;
#else
      if (! info->shared)
	sec_count += input_bfd->section_count;
      else
	for (section = input_bfd->sections;
	     section != NULL;
	     section = section->next, sec_count++)
	  {
	    char *name;
	    asection *reloc_sec;

	    name = bfd_malloc (strlen (section->name)
			       + sizeof STUB_SUFFIX
			       + 5);
	    if (name == NULL)
	      return false;
	    sprintf (name, ".rela%s%s", section->name, STUB_SUFFIX);
	    reloc_sec = bfd_get_section_by_name (hplink->root.dynobj, name);
	    hplink->reloc_section_created[sec_count] = reloc_sec;
	    free (name);
	  }
#endif
a3762 5

  /* Millicode symbols should not be put in the dynamic
     symbol table under any circumstances.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_PARISC_MILLI)
    h->dynindx = -1;
@


1.14
log
@Shared lib support.
@
text
@d39 12
d116 1
a116 2
   :		be,n 0(%sr0,%rp)		; inter-space return
*/
d119 1
d134 7
d220 8
a227 1
  boolean pic_call;
a256 3
  /* Current offsets in the stub sections.  */
  bfd_vma *offset;

a266 8
/* Functions named elf32_hppa_* are called by external routines, other
   functions are only called locally.  elf32_hppa_* functions appear
   in this file more or less in the order in which they are called
   from external routines.  eg. elf32_hppa_check_relocs is called
   early in the link process, elf32_hppa_finish_dynamic_sections is
   one of the last functions.  */


d333 3
d342 2
a343 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
d458 2
a499 1
  ret->offset = NULL;
d521 1
a521 1
  unsigned int len;
a616 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
  asection *reloc_sec;
#endif
d635 2
a636 1
	  stub_sec = hplink->stub_section_created[hplink->first_init_sec];
d641 2
a642 1
	  stub_sec = hplink->stub_section_created[hplink->first_fini_sec];
d647 1
a647 1
	  int len;
d664 1
a664 1
		hplink->first_init_sec = sec_count;
d666 1
a666 1
		hplink->first_fini_sec = sec_count;
a671 18
#if ! LONG_BRANCH_PIC_IN_SHLIB
  reloc_sec = hplink->reloc_section_created[sec_count];
  if (reloc_sec == NULL && info->shared)
    {
      char *name;

      name = bfd_malloc (sizeof ".rela" + strlen (stub_sec->name));
      if (name == NULL)
	return NULL;
      strcpy (name, ".rela");
      strcpy (name + sizeof ".rela" - 1, stub_sec->name);
      reloc_sec = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
					   name);
      hplink->reloc_section_created[sec_count] = reloc_sec;
      free (name);
    }
#endif

d685 1
a685 1
  stub_entry->reloc_sec = reloc_sec;
d709 5
a713 2
	       || hash->elf.root.type == bfd_link_hash_defweak)
	      && hash->elf.root.u.def.section->output_section == NULL)
d720 3
a722 3
	 hppa_stub_import and hppa_stub_import_shared later.
	 For shared links we need stubs for undefined syms too;  They
	 will presumably be resolved by the dynamic linker.  */
d746 1
a746 1
  else /* R_PARISC_PCREL22F */
d753 1
a753 1
#if 0
d821 2
a822 1
  unsigned int insn;
d833 1
a833 1
  stub_entry->stub_offset = hplink->offset[stub_sec->index];
d849 2
a850 3
      insn = hppa_rebuild_insn ((int) LDIL_R1,
				hppa_field_adjust (sym_value, 0, e_lrsel),
				21);
d853 2
a854 3
      insn = hppa_rebuild_insn ((int) BE_SR4_R1,
				hppa_field_adjust (sym_value, 0, e_rrsel) >> 2,
				17);
d916 3
a918 4
      bfd_put_32 (stub_bfd, (unsigned int) BL_R1, loc);
      insn = hppa_rebuild_insn ((int) ADDIL_R1,
				hppa_field_adjust (sym_value, -8, e_lsel),
				21);
d921 2
a922 3
      insn = hppa_rebuild_insn ((int) BE_SR4_R1,
				hppa_field_adjust (sym_value, -8, e_rsel) >> 2,
				17);
d939 2
a940 3
      insn = hppa_rebuild_insn ((int) insn,
				hppa_field_adjust (sym_value, 0, e_lsel),
				21);
d943 2
a944 3
      insn = hppa_rebuild_insn ((int) LDW_R1_R21,
				hppa_field_adjust (sym_value, 0, e_rsel),
				14);
d949 2
a950 3
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT,
				    hppa_field_adjust (sym_value, 4, e_rsel),
				    14);
d953 4
a956 4
	  bfd_put_32 (stub_bfd, (unsigned int) LDSID_R21_R1, loc + 12);
	  bfd_put_32 (stub_bfd, (unsigned int) MTSP_R1,      loc + 16);
	  bfd_put_32 (stub_bfd, (unsigned int) BE_SR0_R21,   loc + 20);
	  bfd_put_32 (stub_bfd, (unsigned int) STW_RP,       loc + 24);
d962 3
a964 4
	  bfd_put_32 (stub_bfd, (unsigned int) BV_R0_R21, loc + 8);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT,
				    hppa_field_adjust (sym_value, 4, e_rsel),
				    14);
d980 1
a980 1
	  dynobj = elf_hash_table (info)->dynobj;
d993 2
a994 1
	     <funcaddr> <__gp>.  */
d1027 2
a1028 3
      insn = hppa_rebuild_insn ((int) BL_RP,
				hppa_field_adjust (sym_value, -8, e_fsel) >> 2,
				17);
d1031 5
a1035 5
      bfd_put_32 (stub_bfd, (unsigned int) NOP,         loc + 4);
      bfd_put_32 (stub_bfd, (unsigned int) LDW_RP,      loc + 8);
      bfd_put_32 (stub_bfd, (unsigned int) LDSID_RP_R1, loc + 12);
      bfd_put_32 (stub_bfd, (unsigned int) MTSP_R1,     loc + 16);
      bfd_put_32 (stub_bfd, (unsigned int) BE_SR0_RP,   loc + 20);
d1039 1
a1039 1
      stub_entry->h->elf.root.u.def.value = hplink->offset[stub_sec->index];
d1049 1
a1049 1
  hplink->offset[stub_sec->index] += size;
d1093 7
a1099 1
    size = 8;
d1104 1
a1104 1
  else /* hppa_stub_import or hppa_stub_import_shared */
d1112 1
a1112 1
  hplink->offset[stub_entry->stub_sec->index] += size;
d1236 1
a1236 1
  dynobj = elf_hash_table (info)->dynobj;
d1251 1
a1251 1
	NEED_STUBREL = 0  /* We won't be needing them in this case.  */
d1253 1
a1253 1
	NEED_STUBREL = 8
d1255 1
d1287 9
a1295 15
	  if (h == NULL)
	    {
	      /* If this is a local symbol we do not need to create a
		 PLT entry, but if we are creating a shared object we
		 have to output a relocation for the PLABEL itself.  */
	      need_entry = NEED_DYNREL;
	    }
	  else
	    {
	      /* If it is a global symbol, then we do need to create a
		 PLT entry, and additionally, if we are creating a
		 shared object, we need to output a dynamic relocation
		 pointing to that PLT entry.  */
	      need_entry = NEED_PLT | NEED_DYNREL;
	    }
d1397 1
a1397 1
	    elf_hash_table (info)->dynobj = dynobj = abfd;
d1432 5
a1436 1
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
d1476 1
a1476 1
	      if (h->elf.plt.refcount == -1)
d1478 38
a1515 2
		  h->elf.plt.refcount = 1;
		  h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
a1516 2
	      else
		h->elf.plt.refcount += 1;
d1577 1
a1577 1
		    elf_hash_table (info)->dynobj = dynobj = abfd;
d1594 1
a1594 1
		      int len = strlen (name) + sizeof (STUB_SUFFIX);
d1758 1
d1762 1
d1770 5
a1774 2

  dynobj = elf_hash_table (info)->dynobj;
d1778 2
a1779 2
  sgot = hppa_link_hash_table (info)->sgot;
  srelgot = hppa_link_hash_table (info)->srelgot;
d1797 1
a1797 1
		    sgot->_raw_size -= 4;
d1809 1
a1809 1
		    sgot->_raw_size -= 4;
a1816 3
      case R_PARISC_PLABEL14R:
      case R_PARISC_PLABEL21L:
      case R_PARISC_PLABEL32:
d1830 17
d1855 17
a1886 1
  dynobj = elf_hash_table (info)->dynobj;
d1888 1
d1899 1
d1906 6
a1911 5
	     object, and it's not a weak definition.  Either this
	     object is the application or we are doing a shared
	     symbolic link.  As a special sop to the hppa ABI, we
	     keep a .plt entry for functions in sections containing
	     PIC code.  */
d1931 9
a1939 1
      s->_raw_size += PLT_ENTRY_SIZE;
d1944 2
a1945 1
	  if (h->dynindx == -1)
d2063 1
a2066 1
  dynobj = elf_hash_table (info)->dynobj;
d2068 1
d2079 2
a2080 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
d2096 1
a2096 1
#if ! LONG_BRANCH_PIC_IN_SHLIB
d2111 1
a2114 1
#if RELATIVE_DYNAMIC_RELOCS
d2144 1
a2144 1
  dynobj = elf_hash_table (info)->dynobj;
d2147 1
a2147 1
  if (elf_hash_table (info)->dynamic_sections_created)
d2149 3
d2160 80
d2259 2
a2260 1
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
d2352 1
a2352 1
  if (elf_hash_table (info)->dynamic_sections_created)
a2579 1
	  sec_count += input_bfd->section_count;
d2581 24
d2830 18
a2847 8
      hplink->offset = (bfd_vma *)
	bfd_realloc (hplink->offset,
		     hplink->stub_bfd->section_count * sizeof (bfd_vma));
      if (hplink->offset == NULL)
	goto error_ret_free_local;

      memset (hplink->offset, 0,
	      hplink->stub_bfd->section_count * sizeof (bfd_vma));
a2852 7
      for (stub_sec = hplink->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  bfd_set_section_size (hplink->stub_bfd, stub_sec,
				hplink->offset[stub_sec->index]);
	}
d2893 1
d2898 2
a2899 1
  h = elf_link_hash_lookup (elf_hash_table (info), "$global$",
d2909 20
a2928 12
      /* If $global$ isn't defined, we make one up ourselves
	 from the start of .data, .plt, or .got.  */
      struct elf32_hppa_link_hash_table *hplink;

      hplink = hppa_link_hash_table (info);
      gp_val = 0;
      sec = bfd_get_section_by_name (abfd, ".data");
      if (sec == NULL)
	sec = hplink->splt;
      if (sec == NULL)
	sec = hplink->sgot;
      if (sec == NULL)
d2930 14
a2943 3
	  (*info->callbacks->undefined_symbol)
	    (info, "$global$", abfd, NULL, 0, true);
	  return false;
d2947 4
a2950 3
  elf_gp (abfd) = (gp_val
		   + sec->output_section->vma
		   + sec->output_offset);
d2975 1
a2975 1
      unsigned int size;
d2978 1
a2978 1
      size = bfd_section_size (hplink->stub_bfd, stub_sec);
d2983 1
a2986 3
  memset (hplink->offset, 0,
	  hplink->stub_bfd->section_count * sizeof (bfd_vma));

d3037 3
a3039 1
	 object, then find the import stub in the stub hash.  */
d3042 5
a3046 1
	  || (h != NULL && h->pic_call))
d3098 1
a3098 1
#if 1 /* debug them */
d3111 1
a3111 1
      /* Fall thru */
d3241 1
a3241 1
  bfd_put_32 (input_bfd, (unsigned int) insn, hit_data);
d3270 2
a3271 1
  dynobj = elf_hash_table (info)->dynobj;
a3272 1
  hplink = hppa_link_hash_table (info);
d3288 1
a3288 1
      boolean pltrel;
d3381 1
a3381 1
      pltrel = 0;
d3396 1
a3396 1
	      if (! elf_hash_table (info)->dynamic_sections_created
d3448 1
a3448 1
		      /* Output a dynamic SEGREL32 relocation for this
d3458 1
a3458 1
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_SEGREL32);
d3481 72
a3552 16
	  /* If we have a global symbol with a PLT slot, then redirect
             this relocation to it.  */
	  if (h != NULL
	      && h->elf.dynindx != -1
	      && h->elf.plt.offset != (bfd_vma) -1)
	    {
	      /* PLABELs contain function pointers.  Relocation is
		 to the entry for the function in the .plt.  The
		 magic +2 offset signals to $$dyncall that the
		 function pointer is in the .plt and thus has a gp
		 pointer too.  */
	      relocation = (h->elf.plt.offset
			    + hplink->splt->output_offset
			    + hplink->splt->output_section->vma
			    + 2);
	      pltrel = 1;
d3612 1
a3612 1
			 (output_bfd, &elf_hash_table (info)->stab_info,
d3628 4
a3631 3
	      else if (!pltrel
		       && h != NULL
		       && ((!info->symbolic && h->elf.dynindx != -1)
d3644 8
a3651 1
		  if (sym_sec != NULL
d3736 1
a3736 1
  dynobj = elf_hash_table (info)->dynobj;
d3752 6
a3757 1
	 <funcaddr> <__gp>.  */
d3773 2
a3774 1
      bfd_put_32 (hplink->splt->owner, value,
d3776 2
a3777 2
      value = elf_gp (hplink->splt->output_section->owner);
      bfd_put_32 (hplink->splt->owner, value,
d3779 7
d3787 1
a3787 2
      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  && h->dynindx != -1)
d3793 13
a3805 2
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
d3839 1
a3839 1
      if (! elf_hash_table (info)->dynamic_sections_created
d3844 1
a3844 1
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_SEGREL32);
a3911 1
  dynobj = elf_hash_table (info)->dynobj;
d3913 1
d3917 1
a3917 1
  if (elf_hash_table (info)->dynamic_sections_created)
d3957 25
a3985 2
  /* Fill in the first entry in the global offset table.
     We use it to point to our dynamic section, if we have one.  */
d3988 2
d3996 3
d4000 2
a4001 1
      elf_section_data (hplink->sgot->output_section)->this_hdr.sh_entsize = 4;
d4006 2
a4007 1
    elf_section_data (hplink->splt->output_section)->this_hdr.sh_entsize = 8;
d4042 1
d4057 1
a4057 1
#define elf_backend_got_header_size	     4
@


1.13
log
@Restore hppa-elf32 to working order.
@
text
@d5 1
a5 2
   Written by

d9 1
d47 91
a137 1
   necessary to build the linker stubs during a link.  */
d139 1
a139 1
/* Hash table for linker stubs.  */
a140 2
struct elf32_hppa_stub_hash_entry
{
d147 5
d153 1
a153 1
  bfd_vma offset;
d157 1
a157 1
  symvalue target_value;
d159 8
d169 38
a206 2
struct elf32_hppa_link_hash_table
{
d213 18
d234 7
a240 2
  /* Global data pointer.  */
  bfd_vma global_value;
d244 7
a250 1
/* For linker stub hash tables.  */
d252 5
a256 1
#define elf32_hppa_stub_hash_lookup(table, string, create, copy) \
d260 2
a261 5
/* Get the PA ELF linker hash table from a link_info structure.  */

#define elf32_hppa_hash_table(p) \
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))

d263 1
a263 1
static struct bfd_hash_entry *elf32_hppa_stub_hash_newfunc
d269 67
a335 13
static char *elf32_hppa_stub_name
  PARAMS ((const char *, const asection *, const asection *,
	   bfd_vma, const struct elf_link_hash_entry *));

static int elf32_hppa_relocate_insn
  PARAMS ((int, bfd_vma, bfd_signed_vma, unsigned int, int,
	   enum hppa_reloc_field_selector_type_alt));

static bfd_reloc_status_type elf32_hppa_bfd_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *,
	   bfd_byte *, bfd_vma, bfd_vma, bfd_signed_vma,
	   struct bfd_link_info *, asection *, const char *,
	   struct elf_link_hash_entry *));
d341 3
a343 3
static boolean elf32_hppa_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d345 2
a346 2
static unsigned int elf32_hppa_size_of_stub
  PARAMS ((asection *, bfd_vma, bfd_vma));
d348 2
a349 2
static boolean elf32_hppa_build_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));
d357 1
a357 1
elf32_hppa_stub_hash_newfunc (entry, table, string)
d369 7
a375 5
    ret = ((struct elf32_hppa_stub_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_hppa_stub_hash_entry)));
  if (ret == NULL)
    return NULL;
d385 4
a388 1
      ret->offset = 0;
d391 48
d444 1
d459 1
a459 2
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      _bfd_elf_link_hash_newfunc))
d466 1
a466 2
  if (!bfd_hash_table_init (&ret->stub_hash_table,
			    elf32_hppa_stub_hash_newfunc))
d469 10
d480 6
a485 1
  ret->global_value = 0;
d490 3
a492 1
/* Build a name for a long branch stub.  */
d494 2
a495 2
elf32_hppa_stub_name (sym_name, sym_sec, input_section, addend, hash)
     const char *sym_name;
d497 2
a498 3
     const asection *input_section;
     bfd_vma addend;
     const struct elf_link_hash_entry *hash;
d501 1
a501 1
  int len;
d503 24
a526 17
  len = strlen (sym_name) + 19;
  if (hash == NULL)
    len += 9;

  stub_name = bfd_malloc (len);
  if (stub_name != NULL)
    {
      sprintf (stub_name, "%08x_%08x_%s",
	       input_section->id & 0xffffffff,
	       (int) addend & 0xffffffff,
	       sym_name);

      /* Tack on an ID so we can uniquely identify
	 this local symbol in the stub hash tables.  */
      if (hash == NULL)
	sprintf (stub_name + len - 10, "_%08x",
		 sym_sec->id & 0xffffffff);
a530 1
/* Relocate the given INSN given the various input parameters.  */
d532 12
a543 14
static int
elf32_hppa_relocate_insn (insn, sym_value, r_addend, r_type, r_format, r_field)
     int insn;
     bfd_vma sym_value;
     bfd_signed_vma r_addend;
     unsigned int r_type;
     int r_format;
     enum hppa_reloc_field_selector_type_alt r_field;
{
  int value;
#ifdef ELF_ARG_RELOC
#ifndef ELF_ARG_RELOC_INSN
  /* Ick.  Who would want to support this?  */
  int imm;
d545 7
a551 1
  switch (r_type)
d553 2
a554 32
      /* The offset is partly stored in the instruction for cases
	 where the top ten bits of the addend are used for arg_reloc.
         This is a little tricky, because the immediate value in the
	 instruction not only needs to be pieced together from
	 multiple bit fields, but also needs to be shifted left to
	 restore the original quantity.  Which bits of the offset
	 we can retrieve from the instruction depend on exactly which
	 instruction we are dealing with.  */
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17C:
    case R_PARISC_DIR17R:
    case R_PARISC_DIR17F:
      /* For these relocs, we choose to use the low 10 bits from the
	 instruction and store the high 22 bits in the reloc addend.
	 It doesn't matter that the bottom 2 bits of the value are
	 always zero, as branches must be to a location which is a
	 multiple of 4.  */
#if 0
      /* It isn't necessary to retrieve the whole immediate, but
	 this documents what we have in the instruction.  */
      imm = (((insn & 0x1f0000) >> 5)
	     | ((insn & 0x0004) << 8)
	     | ((insn & 0x1ff8) >> 3)) - ((insn & 1) << 17);
      imm <<= 2;
      imm = imm & 0x3ff;
#else
      imm = (insn & 0x7f8) >> 1;
#endif
      r_addend = (r_addend << (BFD_ARCH_SIZE-22)) >> (BFD_ARCH_SIZE-32);
      r_addend = r_addend | imm;
      break;
d556 22
a577 20
    case R_PARISC_PCREL21L:
    case R_PARISC_DIR21L:
      /* In this case, the instruction stores the high 21 bits of the
	 value, so we pick off the top 10 bits, and use the reloc
	 addend to store the low 22 bits.  */
#if 0
      /* It isn't necessary to retrieve the whole immediate, but
	 this documents what we have in the instruction.  */
      imm = ((  (insn & 0x000ffe) << 8)
	     | ((insn & 0x00c000) >> 7)
	     | ((insn & 0x1f0000) >> 14)
	     | ((insn & 0x003000) >> 12)) - ((insn & 1) << 20);
      imm <<= 11;
      imm = imm & ~ 0x3fffff;
#else
      /* Just pick off the 10 needed bits, ensuring we sign extend.  */
      imm = ((insn & 0x000ff8) << 19) - ((insn & 1) << 31);
#endif
      r_addend = imm | (r_addend & 0x3fffff);
      break;
d579 1
a579 2
    default:
      break;
d581 18
d600 2
a601 1
#endif
d603 3
a605 1
  switch (r_type)
d607 44
a650 10
    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
      /* Adjust PC relative offset.  */
      r_addend -= 8;
      break;
    default:
      break;
a651 1
  value = hppa_field_adjust (sym_value, r_addend, r_field);
d653 3
a655 1
  switch (r_type)
d657 13
a669 11
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR17R:
      /* This is a branch.  Divide the offset by four.
	 Note that we need to decide whether it's a branch or
	 otherwise by inspecting the reloc.  Inspecting insn won't
	 work as insn might be from a .word directive.  */
      value >>= 2;
      break;
d671 9
a679 2
    default:
      break;
d682 7
a688 1
  return hppa_rebuild_insn (insn, value, r_format);
a690 2
/* Actually perform a relocation as part of a final link.  This can get
   rather hairy when linker stubs are needed.  */
d692 8
a699 15
static bfd_reloc_status_type
elf32_hppa_bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, offset, value, addend,
				    info, sym_sec, sym_name, h)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_signed_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     const char *sym_name;
     struct elf_link_hash_entry *h;
a700 5
  int insn;
  unsigned int r_type = howto->type;
  int r_format = howto->bitsize;
  enum hppa_reloc_field_selector_type_alt r_field = e_fsel;
  bfd_byte *hit_data = contents + offset;
d702 19
d722 4
a725 2
  if (r_type == R_PARISC_NONE)
    return bfd_reloc_ok;
d727 2
a728 1
  insn = bfd_get_32 (input_bfd, hit_data);
d730 16
a745 4
  /* Find out where we are and where we're going.  */
  location = (offset +
	      input_section->output_offset +
	      input_section->output_section->vma);
d747 1
a747 1
  switch (r_type)
d749 12
a760 10
    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
      /* Make it a pc relative offset.  */
      value -= location;
      break;
    default:
      break;
d762 2
a764 7
  switch (r_type)
    {
    case R_PARISC_DIR32:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
      r_field = e_fsel;
      break;
d766 28
a793 4
    case R_PARISC_DIR21L:
    case R_PARISC_PCREL21L:
      r_field = e_lrsel;
      break;
d795 3
a797 6
    case R_PARISC_DIR17R:
    case R_PARISC_PCREL17R:
    case R_PARISC_DIR14R:
    case R_PARISC_PCREL14R:
      r_field = e_rrsel;
      break;
d799 5
a803 21
    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  */
    case R_PARISC_DPREL21L:
      r_field = e_lrsel;
      if (sym_sec != NULL)
	{
	  if ((sym_sec->flags & SEC_CODE) != 0)
	    {
	      if ((insn & ((0x3f << 26) | (0x1f << 21)))
		  == (((int) OP_ADDIL << 26) | (27 << 21)))
		{
		  insn &= ~ (0x1f << 21);
		}
	    }
	  else
	    value -= elf32_hppa_hash_table (info)->global_value;
	}
      break;
d805 14
a818 5
    case R_PARISC_DPREL14R:
      r_field = e_rrsel;
      if (sym_sec != NULL && (sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      break;
d820 3
a822 5
    case R_PARISC_DPREL14F:
      r_field = e_fsel;
      if (sym_sec != NULL && (sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      break;
d824 2
a825 3
    case R_PARISC_PLABEL32:
      r_field = e_fsel;
      break;
d827 3
a829 3
    case R_PARISC_PLABEL21L:
      r_field = e_lrsel;
      break;
d831 1
a831 3
    case R_PARISC_PLABEL14R:
      r_field = e_rrsel;
      break;
d833 20
a852 4
    /* This case is separate as it may involve a lot more work
       to deal with linker stubs.  */
    case R_PARISC_PCREL17F:
      r_field = e_fsel;
d854 10
a863 3
      /* bfd_link_hash_undefweak symbols have sym_sec == NULL.  */
      if (sym_sec == NULL)
	break;
d865 1
a865 26
      /* Any kind of linker stub needed?  */
      /* bfd_vma value is unsigned, so this is testing for offsets
	 outside the range -0x40000 to +0x3ffff  */
      if (value + addend - 8 + 0x40000 >= 0x80000)
	{
	  struct bfd_hash_table *stub_hash_table;
	  struct elf32_hppa_stub_hash_entry *stub_entry;
	  char *stub_name;

	  stub_name = elf32_hppa_stub_name (sym_name, sym_sec,
					    input_section, addend, h);
	  if (!stub_name)
	    {
	      (*_bfd_error_handler) ("%s: %s",
				     bfd_get_filename (input_bfd),
				     bfd_errmsg (bfd_get_error ()));
	      return bfd_reloc_notsupported;
	    }

	  stub_hash_table = &elf32_hppa_hash_table (info)->stub_hash_table;

	  stub_entry = elf32_hppa_stub_hash_lookup (stub_hash_table,
						    stub_name,
						    false,
						    false);
	  if (stub_entry == NULL)
d868 7
a874 5
		(_("%s: cannot find stub entry %s"),
		 bfd_get_filename (input_bfd),
		 stub_name);
	      free (stub_name);
	      return bfd_reloc_notsupported;
d877 2
a878 8
	  /* Munge up the value and addend for elf32_hppa_relocate_insn.  */
	  value = (stub_entry->offset
		   + stub_entry->stub_sec->output_offset
		   + stub_entry->stub_sec->output_section->vma
		   - location);
	  addend = 0;

	  if (value + addend - 8 + 0x40000 >= 0x80000)
d881 4
a884 5
		(_("%s: cannot reach stub %s, recompile with -ffunction-sections"),
		 bfd_get_filename (input_bfd),
		 stub_name);
	      free (stub_name);
	      return bfd_reloc_notsupported;
d887 10
a896 1
	  free (stub_name);
d898 2
d902 23
a924 4
    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
    }
d926 21
a946 6
  /* bfd_link_hash_undefweak symbols have sym_sec == NULL.  */
  if (sym_sec == NULL)
    {
      BFD_ASSERT (h != NULL && h->root.type == bfd_link_hash_undefweak);
      value = 0;
    }
d948 11
a958 2
  insn = elf32_hppa_relocate_insn (insn, value, addend,
				   r_type, r_format, r_field);
d960 9
a968 4
  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, insn, hit_data);
  return bfd_reloc_ok;
}
d970 2
a971 1
/* Relocate an HPPA ELF section.  */
d973 32
a1004 17
static boolean
elf32_hppa_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d1006 10
a1015 13
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned int r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *sym_name;
d1017 1
a1017 2
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
d1019 6
a1027 1
      howto = elf_hppa_howto_table + r_type;
d1029 14
a1042 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d1044 2
a1045 15
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
	    }
d1047 4
a1050 2
	  continue;
	}
d1052 3
a1054 16
      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sym_sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = ((ELF_ST_TYPE (sym->st_info) == STT_SECTION
			   ? 0 : sym->st_value)
			 + sym_sec->output_offset
			 + sym_sec->output_section->vma);
	}
      else
	{
	  int indx;
d1056 21
a1076 24
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (input_bfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sym_sec->output_offset
			    + sym_sec->output_section->vma);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
	      break;
	    }
	}
a1077 12
      if (h != NULL)
	sym_name = h->root.root.string;
      else
	{
	  sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	  if (sym_name == NULL)
	    return false;
	  if (*sym_name == '\0')
	    sym_name = bfd_section_name (input_bfd, sym_sec);
	}
d1079 2
a1080 5
      r = elf32_hppa_bfd_final_link_relocate (howto, input_bfd,
					      input_section, contents,
					      rel->r_offset, relocation,
					      rel->r_addend, info, sym_sec,
					      sym_name, h);
d1082 8
a1089 4
      switch (r)
	{
	case bfd_reloc_ok:
	  break;
d1091 3
a1093 10
	case bfd_reloc_undefined:
	case bfd_reloc_notsupported:
	  (*_bfd_error_handler)
	    (_("%s: cannot handle relocation %s for %s at 0x%x in %s"),
	     bfd_get_filename (input_bfd),
	     howto->name,
	     sym_name,
	     rel->r_offset,
	     input_section->name);
	  return false;
d1095 12
a1106 11
	default:
	case bfd_reloc_outofrange:
	case bfd_reloc_overflow:
	  {
	    if (!((*info->callbacks->reloc_overflow)
		  (info, sym_name, howto->name, (bfd_vma) 0,
		   input_bfd, input_section, rel->r_offset)))
	      return false;
	  }
	  break;
	}
d1109 1
a1112 2
/* Called after we have seen all the input files/sections, but before
   final symbol resolution and section placement has been determined.
d1114 2
a1115 2
   We use this hook to (possibly) provide a value for __gp, then we
   fall back to the generic ELF final link routine.  */
d1117 2
a1118 2
boolean
elf32_hppa_final_link (abfd, info)
a1119 1
     struct bfd_link_info *info;
d1121 3
a1123 1
  if (!info->relocateable)
d1125 8
a1132 26
      struct elf_link_hash_entry *h;
      asection *sec;
      bfd_vma gp_val;

      h = elf_link_hash_lookup (elf_hash_table (info), "$global$",
				false, false, false);

      if (h != NULL
	  && h->root.type == bfd_link_hash_defined)
	{
	  gp_val = h->root.u.def.value;
	  sec = h->root.u.def.section;
	}
      else
	{
	  /* If $global$ isn't defined, we could make one up ourselves
	     from the start of .plt, .dlt, or .data  For the time
	     being, just bomb.  */
	  (*info->callbacks->undefined_symbol)
	    (info, "$global$", abfd, NULL, 0, true);
	  return false;
	}

      elf32_hppa_hash_table (info)->global_value = (gp_val
						    + sec->output_section->vma
						    + sec->output_offset);
d1134 2
a1136 3
  /* Invoke the standard linker.  */
  return bfd_elf_bfd_final_link (abfd, info);
}
a1154 30
/* Compute the size of the stub needed to call from INPUT_SEC (OFFSET)
   to DESTINATION.  Return zero if no stub is needed to perform such a
   call.  */

static unsigned int
elf32_hppa_size_of_stub (input_sec, offset, destination)
     asection *input_sec;
     bfd_vma offset;
     bfd_vma destination;
{
  bfd_vma location;

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + offset);

  /* Determine if a long branch stub is needed.  parisc branch offsets
     are relative to the second instruction past the branch, ie. +8
     bytes on from the branch instruction location.  The offset is
     signed, 17 bits wide, and counts in units of 4 bytes.
     bfd_vma is unsigned, so this is testing for offsets outside the
     range -0x40000 to +0x3ffff  */
  if (destination - location - 8 + 0x40000 >= 0x80000)
    return 8;
  return 0;
}

/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.
   IN_ARG contains the link info pointer.  */
d1156 2
a1157 2
#define LDIL_R1		0x20200000	/* ldil LR'XXX,%r1	  */
#define BE_SR4_R1	0xe0202002	/* be,n RR'XXX(%sr4,%r1)  */
d1160 3
a1162 3
elf32_hppa_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d1164 8
a1171 7
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct elf32_hppa_link_hash_table *hppa_link_hash;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  symvalue sym_value;
  int insn;
d1173 3
a1175 3
  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  hppa_link_hash = (struct elf32_hppa_link_hash_table *) in_arg;
d1177 9
a1185 1
  stub_sec = stub_entry->stub_sec;
d1187 12
a1198 3
  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->offset = hppa_link_hash->offset[stub_sec->index];
  loc = stub_sec->contents + stub_entry->offset;
d1200 2
a1201 3
  sym_value = (stub_entry->target_value
	       + stub_entry->target_section->output_offset
	       + stub_entry->target_section->output_section->vma);
d1203 2
a1204 1
  stub_bfd = stub_sec->owner;
a1205 13
  /* Create the long branch.  A long branch is formed with "ldil"
     loading the upper bits of the target address into a register,
     then branching with "be" which adds in the lower bits.
     The "be" has its delay slot nullified.  */
  insn = hppa_rebuild_insn (LDIL_R1,
			    hppa_field_adjust (sym_value, 0, e_lrsel),
			    21);
  bfd_put_32 (stub_bfd, insn, loc);

  insn = hppa_rebuild_insn (BE_SR4_R1,
			    hppa_field_adjust (sym_value, 0, e_rrsel) >> 2,
			    17);
  bfd_put_32 (stub_bfd, insn, loc + 4);
d1207 448
a1654 1
  hppa_link_hash->offset[stub_sec->index] += 8;
d1659 52
a1710 2
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */
d1713 5
a1717 3
elf32_hppa_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d1719 56
a1774 2
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct elf32_hppa_link_hash_table *hppa_link_hash;
d1776 15
a1790 3
  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  hppa_link_hash = (struct elf32_hppa_link_hash_table *) in_arg;
d1792 3
a1794 1
  hppa_link_hash->offset[stub_entry->stub_sec->index] += 8;
a1798 1
/* External entry points for sizing and building linker stubs.  */
d1800 5
a1804 3
/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  This is called via hppaelf_finish in the linker.  */
d1806 4
a1809 4
boolean
elf32_hppa_build_stubs (stub_bfd, link_info)
     bfd *stub_bfd;
     struct bfd_link_info *link_info;
d1811 78
a1888 3
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_hppa_link_hash_table *hppa_link_hash;
d1890 29
a1918 1
  for (stub_sec = stub_bfd->sections; stub_sec; stub_sec = stub_sec->next)
d1920 1
a1920 1
      unsigned int size;
d1922 3
a1924 5
      /* Allocate memory to hold the linker stubs.  */
      size = bfd_section_size (stub_bfd, stub_sec);
      stub_sec->contents = (unsigned char *) bfd_zalloc (stub_bfd, size);
      if (stub_sec->contents == NULL && size != 0)
	return false;
d1927 21
a1947 4
  /* Build the stubs as directed by the stub hash table.  */
  hppa_link_hash = elf32_hppa_hash_table (link_info);
  memset (hppa_link_hash->offset, 0,
	  stub_bfd->section_count * sizeof (bfd_vma));
d1949 2
a1950 2
  table = &hppa_link_hash->stub_hash_table;
  bfd_hash_traverse (table, elf32_hppa_build_one_stub, hppa_link_hash);
a1954 1
/* Determine and set the size of the stub section for a final link.
d1956 3
a1958 5
   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction or calls where the caller and callee disagree on the
   location of their arguments or return value.  Currently, we don't
   support elf arg relocs.  */
d1960 4
a1963 7
boolean
elf32_hppa_size_stubs (stub_bfd, link_info,
		       add_stub_section, layout_sections_again)
     bfd *stub_bfd;
     struct bfd_link_info *link_info;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d1965 9
a1973 16
  bfd *input_bfd;
  asection *section;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  asection **stub_section_created;
  unsigned int i, indx, bfd_count, sec_count;
  asection *stub_sec;
  asection *first_init_sec = NULL;
  asection *first_fini_sec = NULL;
  struct elf32_hppa_link_hash_table *hppa_link_hash;
  struct bfd_hash_table *stub_hash_table;
  boolean stub_changed;

  /* Count the number of input BFDs and the total number of input sections.  */
  for (input_bfd = link_info->input_bfds, bfd_count = 0, sec_count = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
d1975 3
a1977 2
      bfd_count += 1;
      sec_count += input_bfd->section_count;
d1980 14
a1993 4
  stub_section_created
    = (asection **) bfd_zmalloc (sizeof (asection *) * sec_count);
  if (stub_section_created == NULL)
    return false;
d1995 3
a1997 8
  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  all_local_syms
    = (Elf_Internal_Sym **) bfd_zmalloc (sizeof (Elf_Internal_Sym *)
					 * bfd_count);
  if (all_local_syms == NULL)
    goto error_ret_free_stub;
d1999 299
a2297 3
  /* Walk over all the input BFDs adding entries to the args hash table
     for all the external functions.  */
  for (input_bfd = link_info->input_bfds, indx = 0;
d2307 1090
a3396 1
      if (symtab_hdr->sh_info == 0)
d3399 3
a3401 5
      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      local_syms = (Elf_Internal_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf_Internal_Sym));
      if (local_syms == NULL)
d3403 7
a3409 1
	  goto error_ret_free_local;
d3411 4
a3414 4
      all_local_syms[indx] = local_syms;
      ext_syms = (Elf32_External_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf32_External_Sym));
      if (ext_syms == NULL)
d3416 7
a3422 1
	  goto error_ret_free_local;
d3424 1
a3424 6

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
          || (bfd_read (ext_syms, 1,
			(symtab_hdr->sh_info * sizeof (Elf32_External_Sym)),
			input_bfd)
	      != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
d3426 4
a3429 2
	  free (ext_syms);
	  goto error_ret_free_local;
d3431 4
a3435 5
      /* Swap the local symbols in.  */
      isym = local_syms;
      esym = ext_syms;
      for (i = 0; i < symtab_hdr->sh_info; i++, esym++, isym++)
	bfd_elf32_swap_symbol_in (input_bfd, esym, isym);
d3437 15
a3451 3
      /* Now we can free the external symbols.  */
      free (ext_syms);
    }
d3453 4
a3456 1
  stub_hash_table = &elf32_hppa_hash_table (link_info)->stub_hash_table;
d3458 1
a3458 1
  while (1)
d3460 8
a3467 1
      stub_changed = 0;
d3469 7
a3475 5
      /* Now that we have argument location information for all the
	 global functions we can start looking for stubs.  */
      for (input_bfd = link_info->input_bfds, indx = 0, sec_count = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, indx++)
d3477 11
a3487 1
	  Elf_Internal_Shdr *symtab_hdr;
d3489 17
a3505 4
	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
	  if (symtab_hdr->sh_info == 0)
	    continue;
d3507 7
a3513 1
	  local_syms = all_local_syms[indx];
d3515 3
a3517 8
	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next, sec_count++)
	    {
	      Elf_Internal_Shdr *input_rel_hdr;
	      Elf32_External_Rela *external_relocs, *erelaend, *erela;
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;
d3519 2
a3520 4
	      /* If there aren't any relocs, then there's nothing to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || section->reloc_count == 0)
		continue;
d3522 27
a3548 9
	      /* Allocate space for the external relocations.  */
	      external_relocs
		= ((Elf32_External_Rela *)
		   bfd_malloc (section->reloc_count
			       * sizeof (Elf32_External_Rela)));
	      if (external_relocs == NULL)
		{
		  goto error_ret_free_local;
		}
d3550 6
a3555 9
	      /* Likewise for the internal relocations.  */
	      internal_relocs = ((Elf_Internal_Rela *)
				 bfd_malloc (section->reloc_count
					     * sizeof (Elf_Internal_Rela)));
	      if (internal_relocs == NULL)
		{
		  free (external_relocs);
		  goto error_ret_free_local;
		}
d3557 4
a3560 12
	      /* Read in the external relocs.  */
	      input_rel_hdr = &elf_section_data (section)->rel_hdr;
	      if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_read (external_relocs, 1,
			       input_rel_hdr->sh_size,
			       input_bfd) != input_rel_hdr->sh_size)
		{
		  free (external_relocs);
		error_ret_free_internal:
		  free (internal_relocs);
		  goto error_ret_free_local;
		}
d3562 1
a3562 6
	      /* Swap in the relocs.  */
	      erela = external_relocs;
	      erelaend = erela + section->reloc_count;
	      irela = internal_relocs;
	      for (; erela < erelaend; erela++, irela++)
		bfd_elf32_swap_reloca_in (input_bfd, erela, irela);
d3564 16
a3579 2
	      /* We're done with the external relocs, free them.  */
	      free (external_relocs);
d3581 7
a3587 13
	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  unsigned int r_type, r_indx, size_of_stub;
		  struct elf32_hppa_stub_hash_entry *stub_entry;
		  asection *sym_sec;
		  const char *sym_name;
		  symvalue sym_value;
		  bfd_vma destination;
		  struct elf_link_hash_entry *hash;
		  char *stub_name;
d3589 2
a3590 2
		  r_type = ELF32_R_TYPE (irela->r_info);
		  r_indx = ELF32_R_SYM (irela->r_info);
a3591 5
		  if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
		    {
		      bfd_set_error (bfd_error_bad_value);
		      goto error_ret_free_internal;
		    }
d3593 1
a3593 3
		  /* Only look for stubs on call instructions.  */
		  if (r_type != (unsigned int) R_PARISC_PCREL17F)
		    continue;
d3595 8
a3602 9
		  /* Now determine the call target, its name, value, section
		     and argument relocation bits.  */
		  sym_sec = NULL;
		  hash = NULL;
		  if (r_indx < symtab_hdr->sh_info)
		    {
		      /* It's a local symbol.  */
		      Elf_Internal_Sym *sym;
		      Elf_Internal_Shdr *hdr;
d3604 2
a3605 17
		      sym = local_syms + r_indx;
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
		      sym_name =
			bfd_elf_string_from_elf_section (input_bfd,
							 symtab_hdr->sh_link,
							 sym->st_name);
		      sym_value = (ELF_ST_TYPE (sym->st_info) == STT_SECTION
				   ? 0 : sym->st_value);
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		    }
		  else
		    {
		      /* It's an external symbol.  */
		      int e_indx;
d3607 1
a3607 2
		      e_indx = r_indx - symtab_hdr->sh_info;
		      hash = elf_sym_hashes (input_bfd)[e_indx];
d3609 3
a3611 8
		      while (hash->root.type == bfd_link_hash_indirect
			     || hash->root.type == bfd_link_hash_warning)
			hash = (struct elf_link_hash_entry *)
			  hash->root.u.i.link;

		      if (hash->root.type == bfd_link_hash_undefined
			  || hash->root.type == bfd_link_hash_undefweak)
			continue;
d3613 1
a3613 16
		      if (hash->root.type == bfd_link_hash_defined
			  || hash->root.type == bfd_link_hash_defweak)
			{
			  sym_sec = hash->root.u.def.section;
			  sym_name = hash->root.root.string;
			  sym_value = hash->root.u.def.value;
			  destination = (sym_value + irela->r_addend
					 + sym_sec->output_offset
					 + sym_sec->output_section->vma);
			}
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
		    }
d3615 6
a3620 7
		  /* Determine what (if any) linker stub is needed and its
		     size (in bytes).  */
		  size_of_stub = elf32_hppa_size_of_stub (section,
							  irela->r_offset,
							  destination);
		  if (size_of_stub == 0)
		    continue;
d3622 1
a3622 8
		  /* Get the name of this stub.  */
		  stub_name = elf32_hppa_stub_name (sym_name,
						    sym_sec,
						    section,
						    irela->r_addend,
						    hash);
		  if (!stub_name)
		    goto error_ret_free_internal;
d3624 4
a3627 10
		  stub_entry = elf32_hppa_stub_hash_lookup (stub_hash_table,
							    stub_name,
							    false,
							    false);
		  if (stub_entry != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      continue;
		    }
d3629 5
a3633 47
		  stub_sec = stub_section_created[sec_count];
		  if (stub_sec == NULL)
		    {
		      char *s_name;
		      int nstub;
		      int special_sec = 0;

		      /* We only want one stub for .init and .fini
			 because glibc splits the _init and _fini
			 functions into two parts.  We don't want to
			 put a stub in the middle of a function.  */ 
		      if (strncmp (section->name, ".init", 5) == 0)
			{
			  stub_sec = first_init_sec;
			  special_sec = 1;
			}
		      else if (strncmp (section->name, ".fini", 5) == 0)
			{
			  stub_sec = first_fini_sec;
			  special_sec = 2;
			}
		      if (stub_sec == NULL)
			{
			  s_name = bfd_alloc (stub_bfd, 16);
			  if (s_name == NULL)
			    {
			      free (stub_name);
			      goto error_ret_free_internal;
			    }
			  nstub = stub_bfd->section_count;
			  sprintf (s_name, ".stub_%x", nstub);
			  stub_sec = (*add_stub_section) (s_name, section);
			  if (stub_sec == NULL)
			    {
			      free (stub_name);
			      goto error_ret_free_internal;
			    }
			  if (special_sec != 0)
			    {
			      if (special_sec == 1)
				first_init_sec = stub_sec;
			      else
				first_fini_sec = stub_sec;
			    }
			}
		      stub_section_created[sec_count] = stub_sec;
		    }
d3635 5
a3639 15
		  /* Enter this entry into the linker stub
		     hash table.  */
		  stub_entry = elf32_hppa_stub_hash_lookup (stub_hash_table,
							    stub_name,
							    true,
							    false);
		  if (stub_entry == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%s: cannot find stub entry %s"),
			 bfd_get_filename (section->owner),
			 stub_name);
		      free (stub_name);
		      goto error_ret_free_internal;
		    }
d3641 8
a3648 10
		  /* We'll need these to determine the address
		     that the stub will branch to.  */
		  stub_entry->stub_sec = stub_sec;
		  stub_entry->offset = 0;
		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = sym_sec;
		  stub_changed = 1;
		}
	      /* We're done with the internal relocs, free them.  */
	      free (internal_relocs);
d3651 1
d3653 9
a3661 2
      if (!stub_changed)
	break;
d3663 3
a3665 11
      /* OK, we've added some stubs.  Find out the new size of the
	 stub sections.  */
      hppa_link_hash = elf32_hppa_hash_table (link_info);
      hppa_link_hash->offset = (bfd_vma *)
	bfd_realloc (hppa_link_hash->offset,
		     stub_bfd->section_count * sizeof (bfd_vma));
      if (hppa_link_hash->offset == NULL)
	goto error_ret_free_local;

      memset (hppa_link_hash->offset, 0,
	      stub_bfd->section_count * sizeof (bfd_vma));
d3667 3
a3669 14
      bfd_hash_traverse (stub_hash_table,
			 elf32_hppa_size_one_stub,
			 hppa_link_hash);

      for (stub_sec = stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  bfd_set_section_size (stub_bfd, stub_sec,
				hppa_link_hash->offset[stub_sec->index]);
	}
      /* Ask the linker to do its stuff.  */
      (*layout_sections_again) ();
    }
a3670 6
  /* We're done with the local symbols, free them.  */
  for (i = 0; i < bfd_count; i++)
    if (all_local_syms[i])
      free (all_local_syms[i]);
  free (all_local_syms);
  free (stub_section_created);
d3672 1
a3673 5
 error_ret_free_local:
  for (i = 0; i < bfd_count; i++)
    if (all_local_syms[i])
      free (all_local_syms[i]);
  free (all_local_syms);
d3675 11
a3685 3
 error_ret_free_stub:
  free (stub_section_created);
  return false;
d3688 1
d3690 4
a3693 4
#define bfd_elf32_bfd_reloc_type_lookup		elf_hppa_reloc_type_lookup
#define bfd_elf32_bfd_is_local_label_name	elf_hppa_is_local_label_name
#define elf_info_to_howto               	elf_hppa_info_to_howto
#define elf_info_to_howto_rel           	elf_hppa_info_to_howto_rel
d3696 23
a3718 10
#define elf_backend_relocate_section		elf32_hppa_relocate_section
#define elf_backend_add_symbol_hook		elf32_hppa_add_symbol_hook
#define bfd_elf32_bfd_final_link		elf32_hppa_final_link
#if 0
#define elf_backend_check_relocs		elf32_hppa_check_relocs
#endif
#define bfd_elf32_bfd_link_hash_table_create \
  elf32_hppa_link_hash_table_create
#define elf_backend_fake_sections		elf_hppa_fake_sections

@


1.12
log
@Assorted code cleanup and fixes for hppa.  Re-enable elf32-hppa as
it now compiles even if it doesn't work too well.
@
text
@d36 1
d39 1
a39 2
/* We use three different hash tables to hold information for
   linking PA ELF objects.
d53 1
a53 3
  /* Base hash table entry structure, we can get the name of the stub
     (and thus know exactly what actions it performs) from the base
     hash table entry.  */
d56 4
a59 1
  /* Offset of the beginning of this stub.  */
a67 21
struct elf32_hppa_stub_hash_table
{
  /* The hash table itself.  */
  struct bfd_hash_table root;

  /* The stub BFD.  */
  bfd *stub_bfd;

  /* Where to place the next stub.  */
  bfd_byte *location;

  /* Current offset in the stub section.  */
  unsigned int offset;

};

struct elf32_hppa_link_hash_entry
{
  struct elf_link_hash_entry root;
};

d74 1
a74 1
  struct elf32_hppa_stub_hash_table *stub_hash_table;
d76 2
a77 2
  /* A count of the number of output symbols.  */
  unsigned int output_symbol_count;
d79 2
a80 3
  /* Stuff so we can handle DP relative relocations.  */
  long global_value;
  int global_sym_defined;
a82 1
/* ELF32/HPPA relocation support
d84 1
a84 3
	This file contains ELF32/HPPA relocation support as specified
	in the Stratus FTX/Golf Object File Format (SED-1762) dated
	February 1994.  */
d86 5
a90 2
#include "elf32-hppa.h"
#include "hppa_stubs.h"
d92 2
a93 3
static unsigned long hppa_elf_relocate_insn
  PARAMS ((bfd *, asection *, unsigned long, unsigned long, long,
	   long, unsigned long, unsigned long, unsigned long));
a94 3
static boolean elf32_hppa_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d96 2
a97 4
static bfd_reloc_status_type elf32_hppa_bfd_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *,
	   bfd_byte *, bfd_vma, bfd_vma, bfd_vma, struct bfd_link_info *,
	   asection *, const char *, int));
d102 13
a114 3
static struct bfd_hash_entry *
elf32_hppa_stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d116 1
a116 2
static boolean
elf32_hppa_relocate_section
d120 3
a122 9
static boolean
elf32_hppa_stub_hash_table_init
  PARAMS ((struct elf32_hppa_stub_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *,
					       struct bfd_hash_table *,
					       const char *))));

static boolean
elf32_hppa_build_one_stub PARAMS ((struct bfd_hash_entry *, PTR));
d125 1
a125 4
  PARAMS ((bfd_vma, bfd_vma, const char *));

static void elf32_hppa_name_of_stub
  PARAMS ((bfd_vma, bfd_vma, char *));
d127 2
a128 28
/* For linker stub hash tables.  */
#define elf32_hppa_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_stub_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

#define elf32_hppa_stub_hash_traverse(table, func, info) \
  (bfd_hash_traverse \
   (&(table)->root, \
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \
    (info)))

/* For HPPA linker hash table.  */

#define elf32_hppa_link_hash_lookup(table, string, create, copy, follow)\
  ((struct elf32_hppa_link_hash_entry *)				\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

#define elf32_hppa_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the PA ELF linker hash table from a link_info structure.  */

#define elf32_hppa_hash_table(p) \
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))
d161 1
a169 16
/* Initialize a stub hash table.  */

static boolean
elf32_hppa_stub_hash_table_init (table, stub_bfd, newfunc)
     struct elf32_hppa_stub_hash_table *table;
     bfd *stub_bfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
{
  table->offset = 0;
  table->location = 0;
  table->stub_bfd = stub_bfd;
  return (bfd_hash_table_init (&table->root, newfunc));
}

d180 1
a180 2
  ret = ((struct elf32_hppa_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf32_hppa_link_hash_table)));
d183 1
d190 7
a196 2
  ret->stub_hash_table = NULL;
  ret->output_symbol_count = 0;
a197 1
  ret->global_sym_defined = 0;
d202 111
a312 1
/* Relocate the given INSN given the various input parameters.
d314 14
a327 1
   FIXME: endianness and sizeof (long) issues abound here.  */
d329 39
a367 12
static unsigned long
hppa_elf_relocate_insn (abfd, input_sect, insn, address, sym_value,
			r_addend, r_format, r_field, pcrel)
     bfd *abfd;
     asection *input_sect;
     unsigned long insn;
     unsigned long address;
     long sym_value;
     long r_addend;
     unsigned long r_format;
     unsigned long r_field;
     unsigned long pcrel;
d369 30
a398 2
  unsigned char opcode = get_opcode (insn);
  long constant_value;
d400 1
a400 1
  switch (opcode)
d402 26
a427 34
    case LDO:
    case LDB:
    case LDH:
    case LDW:
    case LDWM:
    case STB:
    case STH:
    case STW:
    case STWM:
    case COMICLR:
    case SUBI:
    case ADDIT:
    case ADDI:
    case LDIL:
    case ADDIL:
      constant_value = HPPA_R_CONSTANT (r_addend);

      if (pcrel)
	sym_value -= address;

      sym_value = hppa_field_adjust (sym_value, constant_value, r_field);
      return hppa_rebuild_insn (abfd, insn, sym_value, r_format);

    case BL:
    case BE:
    case BLE:
      /* XXX r_addend ignored ???.  */
      constant_value = assemble_17 ((insn & 0x001f0000) >> 16,
				    (insn & 0x00001ffc) >> 2,
				    insn & 1);

      constant_value = (constant_value << (BFD_ARCH_SIZE-17))
				       >> (BFD_ARCH_SIZE-17);
      if (pcrel)
d429 10
a438 3
	  sym_value -= (address + input_sect->output_offset
			+ input_sect->output_section->vma);
	  sym_value = hppa_field_adjust (sym_value, -8, r_field);
d440 25
a464 2
      else
	sym_value = hppa_field_adjust (sym_value, constant_value, r_field);
d466 4
a469 1
      return hppa_rebuild_insn (abfd, insn, sym_value >> 2, r_format);
d471 8
a478 2
    default:
      if (opcode == 0)
d480 29
a508 1
	  constant_value = HPPA_R_CONSTANT (r_addend);
d510 6
a515 2
	  if (pcrel)
	    sym_value -= address;
d517 11
a527 1
	  return hppa_field_adjust (sym_value, constant_value, r_field);
d529 12
a540 2
      else
	abort ();
d542 7
d556 1
a556 1
     bfd *output_bfd;
d575 1
a575 1
      int r_type;
d577 1
a577 1
      unsigned long r_symndx;
d586 1
a586 1
      if (r_type < 0 || r_type >= (int) R_PARISC_UNIMPLEMENTED)
d629 1
a629 1
	  long indx;
d669 1
a669 1
      r = elf32_hppa_bfd_final_link_relocate (howto, input_bfd, output_bfd,
d673 1
a673 1
					      sym_name, h == NULL);
d675 1
a675 1
      if (r != bfd_reloc_ok)
d677 21
a697 11
	  switch (r)
	    {
	    /* This can happen for DP relative relocs if $global$ is
	       undefined.  This is a panic situation so we don't try
	       to continue.  */
	    case bfd_reloc_undefined:
	    case bfd_reloc_notsupported:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, "$global$", input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
d699 2
a700 34
	    case bfd_reloc_dangerous:
	      {
		/* We use this return value to indicate that we performed
		   a "dangerous" relocation.  This doesn't mean we did
		   the wrong thing, it just means there may be some cleanup
		   that needs to be done here.

		   In particular we had to swap the last call insn and its
		   delay slot.  If the delay slot insn needed a relocation,
		   then we'll need to adjust the next relocation entry's
		   offset to account for the fact that the insn moved.

		   This hair wouldn't be necessary if we inserted stubs
		   between procedures and used a "bl" to get to the stub.  */
		if (rel != relend)
		  {
		    Elf_Internal_Rela *next_rel = rel + 1;

		    if (rel->r_offset + 4 == next_rel->r_offset)
		      next_rel->r_offset -= 4;
		  }
		break;
	      }
	    default:
	    case bfd_reloc_outofrange:
	    case bfd_reloc_overflow:
	      {
		if (!((*info->callbacks->reloc_overflow)
		      (info, sym_name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
	    }
d707 5
a711 2
/* Actually perform a relocation as part of a final link.  This can get
   rather hairy when linker stubs are needed.  */
d713 3
a715 12
static bfd_reloc_status_type
elf32_hppa_bfd_final_link_relocate (howto, input_bfd, output_bfd,
				    input_section, contents, offset, value,
				    addend, info, sym_sec, sym_name, is_local)
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
a716 3
     asection *sym_sec;
     const char *sym_name;
     int is_local;
d718 1
a718 13
  unsigned long insn;
  unsigned long r_type = howto->type;
  unsigned long r_format = howto->bitsize;
  unsigned long r_field = e_fsel;
  bfd_byte *hit_data = contents + offset;
  boolean r_pcrel = howto->pc_relative;

  insn = bfd_get_32 (input_bfd, hit_data);

  /* Make sure we have a value for $global$.  FIXME isn't this effectively
     just like the gp pointer on MIPS?  Can we use those routines for this
     purpose?  */
  if (!elf32_hppa_hash_table (info)->global_sym_defined)
d722 1
d724 2
a725 39
      h = elf_link_hash_lookup (elf_hash_table (info), "$global$", false,
				 false, false);

      /* If there isn't a $global$, then we're in deep trouble.  */
      if (h == NULL)
	return bfd_reloc_notsupported;

      /* If $global$ isn't a defined symbol, then we're still in deep
	 trouble.  */
      if (h->root.type != bfd_link_hash_defined)
	return bfd_reloc_undefined;

      sec = h->root.u.def.section;
      elf32_hppa_hash_table (info)->global_value = (h->root.u.def.value
						    + sec->output_section->vma
						    + sec->output_offset);
      elf32_hppa_hash_table (info)->global_sym_defined = 1;
    }

  switch (r_type)
    {
    case R_PARISC_NONE:
      break;

    case R_PARISC_DIR32:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
      r_field = e_fsel;
      goto do_basic_type_1;
    case R_PARISC_DIR21L:
    case R_PARISC_PCREL21L:
      r_field = e_lrsel;
      goto do_basic_type_1;
    case R_PARISC_DIR17R:
    case R_PARISC_PCREL17R:
    case R_PARISC_DIR14R:
    case R_PARISC_PCREL14R:
      r_field = e_rrsel;
      goto do_basic_type_1;
d727 2
a728 8
    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  */
    case R_PARISC_DPREL21L:
      r_field = e_lrsel;
      if (sym_sec->flags & SEC_CODE)
d730 2
a731 3
	  if ((insn & 0xfc000000) >> 26 == 0xa
	       && (insn & 0x03e00000) >> 21 == 0x1b)
	    insn &= ~0x03e00000;
d734 8
a741 12
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
    case R_PARISC_DPREL14R:
      r_field = e_rrsel;
      if ((sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
    case R_PARISC_DPREL14F:
      r_field = e_fsel;
      if ((sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
d743 3
a745 157
    /* These cases are separate as they may involve a lot more work
       to deal with linker stubs.  */
    case R_PARISC_PLABEL32:
    case R_PARISC_PLABEL21L:
    case R_PARISC_PLABEL14R:
    case R_PARISC_PCREL17F:
      {
	bfd_vma location;
	unsigned int len;
	char *new_name, *stub_name;

	/* Get the field selector right.  We'll need it in a minute.  */
	if (r_type == R_PARISC_PCREL17F
	    || r_type == R_PARISC_PLABEL32)
	  r_field = e_fsel;
	else if (r_type == R_PARISC_PLABEL21L)
	  r_field = e_lrsel;
	else if (r_type == R_PARISC_PLABEL14R)
	  r_field = e_rrsel;

	/* Find out where we are and where we're going.  */
	location = (offset +
		    input_section->output_offset +
		    input_section->output_section->vma);

	len = strlen (sym_name) + 1;
	if (is_local)
	  len += 9;
	new_name = bfd_malloc (len);
	if (!new_name)
	  return bfd_reloc_notsupported;
	strcpy (new_name, sym_name);

	/* Local symbols have unique IDs.  */
	if (is_local)
	  sprintf (new_name + len - 10, "_%08x", (int)sym_sec);

	/* Any kind of linker stub needed?  */
	if (((int)(value - location) > 0x3ffff)
	    || ((int)(value - location) < -0x40000))
	  {
	    struct elf32_hppa_stub_hash_table *stub_hash_table;
	    struct elf32_hppa_stub_hash_entry *stub_hash;
	    asection *stub_section;

	    /* Build a name for the stub.  */

	    len = strlen (new_name);
	    len += 23;
	    stub_name = bfd_malloc (len);
	    if (!stub_name)
	      return bfd_reloc_notsupported;
	    elf32_hppa_name_of_stub (location, value, stub_name);
	    strcat (stub_name, new_name);
	    free (new_name);

	    stub_hash_table = elf32_hppa_hash_table (info)->stub_hash_table;

	    stub_hash
	      = elf32_hppa_stub_hash_lookup (stub_hash_table, stub_name,
					     false, false);

	    /* We're done with that name.  */
	    free (stub_name);

	    /* The stub BFD only has one section.  */
	    stub_section = stub_hash_table->stub_bfd->sections;

	    if (stub_hash != NULL)
	      {
		if (r_type == R_PARISC_PCREL17F)
		  {
		    unsigned long delay_insn;
		    unsigned int opcode, rtn_reg, ldo_target_reg, ldo_src_reg;

		    /* We'll need to peek at the next insn.  */
		    delay_insn = bfd_get_32 (input_bfd, hit_data + 4);
		    opcode = get_opcode (delay_insn);

		    /* We also need to know the return register for this
		       call.  */
		    rtn_reg = (insn & 0x03e00000) >> 21;

		    ldo_src_reg = (delay_insn & 0x03e00000) >> 21;
		    ldo_target_reg = (delay_insn & 0x001f0000) >> 16;

		    /* Munge up the value and other parameters for
		       hppa_elf_relocate_insn.  */

		    value = (stub_hash->offset
			     + stub_section->output_offset
			     + stub_section->output_section->vma);

		    r_format = 17;
		    r_field = e_fsel;
		    r_pcrel = 0;
		    addend = 0;

		    /* We need to peek at the delay insn and determine if
		       we'll need to swap the branch and its delay insn.  */
		    if ((insn & 2)
			|| (opcode == LDO
			    && ldo_target_reg == rtn_reg)
			|| (delay_insn == 0x08000240))
		      {
			/* No need to swap the branch and its delay slot, but
			   we do need to make sure to jump past the return
			   pointer update in the stub.  */
			value += 4;

			/* If the delay insn does a return pointer adjustment,
			   then we have to make sure it stays valid.  */
			if (opcode == LDO
			    && ldo_target_reg == rtn_reg)
			  {
			    delay_insn &= 0xfc00ffff;
			    delay_insn |= ((31 << 21) | (31 << 16));
			    bfd_put_32 (input_bfd, delay_insn, hit_data + 4);
			  }
			/* Use a BLE to reach the stub.  */
			insn = BLE_SR4_R0;
		      }
		    else
		      {
			/* Wonderful, we have to swap the call insn and its
			   delay slot.  */
			bfd_put_32 (input_bfd, delay_insn, hit_data);
			/* Use a BLE,n to reach the stub.  */
			insn = (BLE_SR4_R0 | 0x2);
			bfd_put_32 (input_bfd, insn, hit_data + 4);
			insn = hppa_elf_relocate_insn (input_bfd,
						       input_section,
						       insn, offset + 4,
						       value, addend,
						       r_format, r_field,
						       r_pcrel);
			/* Update the instruction word.  */
			bfd_put_32 (input_bfd, insn, hit_data + 4);
			return bfd_reloc_dangerous;
		      }
		  }
	        else
		  return bfd_reloc_notsupported;
	      }
	  }
	goto do_basic_type_1;
      }

do_basic_type_1:
      insn = hppa_elf_relocate_insn (input_bfd, input_section, insn,
				     offset, value, addend, r_format,
				     r_field, r_pcrel);
      break;

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
d748 2
a749 3
  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, insn, hit_data);
  return (bfd_reloc_ok);
d769 3
a771 16
/* Determine the name of the stub needed to perform a call assuming the
   argument relocation bits for caller and callee are in CALLER and CALLEE
   for a call from LOCATION to DESTINATION.  Copy the name into STUB_NAME.  */

static void
elf32_hppa_name_of_stub (location, destination, stub_name)
     bfd_vma location ATTRIBUTE_UNUSED;
     bfd_vma destination ATTRIBUTE_UNUSED;
     char *stub_name;
{
  strcpy (stub_name, "_____long_branch_stub_");
}

/* Compute the size of the stub needed to call from LOCATION to DESTINATION
   (a function named SYM_NAME), with argument relocation bits CALLER and
   CALLEE.  Return zero if no stub is needed to perform such a call.  */
d774 4
a777 3
elf32_hppa_size_of_stub (location, destination, sym_name)
     bfd_vma location, destination;
     const char *sym_name;
d779 16
a794 10
  /* Determine if a long branch stub is needed.  */
  if (!(((int)(location - destination) > 0x3ffff)
	|| ((int)(location - destination) < -0x40000)))
    return 0;

  if (!strncmp ("$$", sym_name, 2)
      && strcmp ("$$dyncall", sym_name))
    return 12;
  else
    return 16;
d798 4
a801 1
   IN_ARGS contains the stub BFD and link info pointers.  */
d804 1
a804 1
elf32_hppa_build_one_stub (gen_entry, in_args)
d806 1
a806 1
     PTR in_args;
d808 4
a811 5
  void **args = (void **)in_args;
  bfd *stub_bfd = (bfd *)args[0];
  struct bfd_link_info *info = (struct bfd_link_info *)args[1];
  struct elf32_hppa_stub_hash_entry *entry;
  struct elf32_hppa_stub_hash_table *stub_hash_table;
d814 1
a814 1
  const char *sym_name;
d816 5
a820 6
  /* Initialize pointers to the stub hash table, the particular entry we
     are building a stub for, and where (in memory) we should place the stub
     instructions.  */
  entry = (struct elf32_hppa_stub_hash_entry *)gen_entry;
  stub_hash_table = elf32_hppa_hash_table(info)->stub_hash_table;
  loc = stub_hash_table->location;
d823 22
a844 1
  entry->offset = stub_hash_table->offset;
d846 1
a846 2
  /* The symbol's name starts at offset 22.  */
  sym_name = entry->root.string + 22;
d848 13
a860 3
  sym_value = (entry->target_value
	       + entry->target_section->output_offset
	       + entry->target_section->output_section->vma);
d862 3
a864 25
  if (1)
    {
      /* Create one of two variant long branch stubs.  One for $$dyncall and
	 normal calls, the other for calls to millicode.  */
      unsigned long insn;
      int millicode_call = 0;

      if (!strncmp ("$$", sym_name, 2) && strcmp ("$$dyncall", sym_name))
	millicode_call = 1;

      /* First the return pointer adjustment.  Depending on exact calling
	 sequence this instruction may be skipped.  */
      bfd_put_32 (stub_bfd, LDO_M4_R31_R31, loc);

      /* The next two instructions are the long branch itself.  A long branch
	 is formed with "ldil" loading the upper bits of the target address
	 into a register, then branching with "be" which adds in the lower bits.
	 Long branches to millicode nullify the delay slot of the "be".  */
      insn = hppa_rebuild_insn (stub_bfd, LDIL_R1,
				hppa_field_adjust (sym_value, 0, e_lrsel), 21);
      bfd_put_32 (stub_bfd, insn, loc + 4);
      insn = hppa_rebuild_insn (stub_bfd, BE_SR4_R1 | (millicode_call ? 2 : 0),
				hppa_field_adjust (sym_value, 0, e_rrsel) >> 2,
				17);
      bfd_put_32 (stub_bfd, insn, loc + 8);
d866 1
a866 17
      if (!millicode_call)
	{
	  /* The sequence to call this stub places the return pointer into %r31,
	     the final target expects the return pointer in %r2, so copy the
	      return pointer into the proper register.  */
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 12);

	  /* Update the location and offsets.  */
	  stub_hash_table->location += 16;
	  stub_hash_table->offset += 16;
	}
      else
	{
	  /* Update the location and offsets.  */
	  stub_hash_table->location += 12;
	  stub_hash_table->offset += 12;
	}
a867 1
    }
d878 1
a878 1
elf32_hppa_build_stubs (stub_bfd, info)
d880 1
a880 1
     struct bfd_link_info *info;
d882 14
a895 18
  /* The stub BFD only has one section.  */
  asection *stub_sec = stub_bfd->sections;
  struct elf32_hppa_stub_hash_table *table;
  unsigned int size;
  void *args[2];

  /* So we can pass both the BFD for the stubs and the link info
     structure to the routine which actually builds stubs.  */
  args[0] = stub_bfd;
  args[1] = info;

  /* Allocate memory to hold the linker stubs.  */
  size = bfd_section_size (stub_bfd, stub_sec);
  stub_sec->contents = (unsigned char *) bfd_zalloc (stub_bfd, size);
  if (stub_sec->contents == NULL)
    return false;
  table = elf32_hppa_hash_table(info)->stub_hash_table;
  table->location = stub_sec->contents;
d898 6
a903 1
  elf32_hppa_stub_hash_traverse (table, elf32_hppa_build_one_stub, args);
d913 2
a914 1
   location of their arguments or return value.  */
d917 2
a918 1
elf32_hppa_size_stubs (stub_bfd, output_bfd, link_info)
a919 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d921 2
d925 1
a925 2
  asection *section, *stub_sec = 0;
  Elf_Internal_Shdr *symtab_hdr;
d927 8
a934 12
  unsigned int i, index, bfd_count = 0;
  struct elf32_hppa_stub_hash_table *stub_hash_table = 0;

  /* Create and initialize the stub hash table.  */
  stub_hash_table = ((struct elf32_hppa_stub_hash_table *)
		     bfd_malloc (sizeof (struct elf32_hppa_stub_hash_table)));
  if (!stub_hash_table)
    goto error_return;

  if (!elf32_hppa_stub_hash_table_init (stub_hash_table, stub_bfd,
					elf32_hppa_stub_hash_newfunc))
    goto error_return;
d936 2
a937 5
  /* Attach the hash tables to the main hash table.  */
  elf32_hppa_hash_table(link_info)->stub_hash_table = stub_hash_table;

  /* Count the number of input BFDs.  */
  for (input_bfd = link_info->input_bfds;
a939 8
     bfd_count++;

  /* Magic as we know the stub bfd only has one section.  */
  stub_sec = stub_bfd->sections;

  /* If generating a relocateable output file, then we don't
     have to examine the relocs.  */
  if (link_info->relocateable)
d941 2
a942 5
      for (i = 0; i < bfd_count; i++)
	if (all_local_syms[i])
	  free (all_local_syms[i]);
      free (all_local_syms);
      return true;
d945 17
a961 3
  /* Now that we have argument location information for all the global
     functions we can start looking for stubs.  */
  for (input_bfd = link_info->input_bfds, index = 0;
d963 1
a963 1
       input_bfd = input_bfd->link_next, index++)
d965 4
d974 15
a988 1
      local_syms = all_local_syms[index];
d990 5
a994 4
      /* Walk over each section attached to the input bfd.  */
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
d996 31
a1026 7
	  Elf_Internal_Shdr *input_rel_hdr;
	  Elf32_External_Rela *external_relocs, *erelaend, *erela;
	  Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	  /* If there aren't any relocs, then there's nothing to do.  */
	  if ((section->flags & SEC_RELOC) == 0
	      || section->reloc_count == 0)
d1029 1
a1029 13
	  /* Allocate space for the external relocations.  */
	  external_relocs
	    = ((Elf32_External_Rela *)
	       bfd_malloc (section->reloc_count
			   * sizeof (Elf32_External_Rela)));
	  if (external_relocs == NULL)
	    {
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
	    }
d1031 4
a1034 5
	  /* Likewise for the internal relocations.  */
	  internal_relocs
	    = ((Elf_Internal_Rela *)
	       bfd_malloc (section->reloc_count * sizeof (Elf_Internal_Rela)));
	  if (internal_relocs == NULL)
d1036 8
a1043 7
	      free (external_relocs);
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
	    }
d1045 9
a1053 14
	  /* Read in the external relocs.  */
	  input_rel_hdr = &elf_section_data (section)->rel_hdr;
	  if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_read (external_relocs, 1, input_rel_hdr->sh_size,
			   input_bfd) != input_rel_hdr->sh_size)
	    {
	      free (external_relocs);
	      free (internal_relocs);
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
	    }
d1055 9
a1063 25
	  /* Swap in the relocs.  */
	  erela = external_relocs;
	  erelaend = erela + section->reloc_count;
	  irela = internal_relocs;
	  for (; erela < erelaend; erela++, irela++)
	    bfd_elf32_swap_reloca_in (input_bfd, erela, irela);

	  /* We're done with the external relocs, free them.  */
	  free (external_relocs);

	  /* Now examine each relocation.  */
	  irela = internal_relocs;
	  irelaend = irela + section->reloc_count;
	  for (; irela < irelaend; irela++)
	    {
	      long r_type, size_of_stub;
	      unsigned long r_index;
	      struct elf_link_hash_entry *hash;
	      struct elf32_hppa_stub_hash_entry *stub_hash;
	      Elf_Internal_Sym *sym;
	      asection *sym_sec;
	      const char *sym_name;
	      symvalue sym_value;
	      bfd_vma location, destination;
	      char *new_name = NULL;
d1065 6
a1070 4
	      r_type = ELF32_R_TYPE (irela->r_info);
	      r_index = ELF32_R_SYM (irela->r_info);

	      if (r_type < 0 || r_type >= (int) R_PARISC_UNIMPLEMENTED)
d1072 2
a1073 1
		  bfd_set_error (bfd_error_bad_value);
d1075 1
a1075 5
		  for (i = 0; i < bfd_count; i++)
		    if (all_local_syms[i])
		      free (all_local_syms[i]);
		  free (all_local_syms);
		  goto error_return;
d1078 9
a1086 7
	      /* Only look for stubs on call instructions or plabel
		 references.  */
	      if (r_type != R_PARISC_PCREL17F
		  && r_type != R_PARISC_PLABEL32
		  && r_type != R_PARISC_PLABEL21L
		  && r_type != R_PARISC_PLABEL14R)
		continue;
d1088 4
a1091 6
	      /* Now determine the call target, its name, value, section
		 and argument relocation bits.  */
	      hash = NULL;
	      sym = NULL;
	      sym_sec = NULL;
	      if (r_index < symtab_hdr->sh_info)
d1093 11
a1103 2
		  /* It's a local symbol.  */
		  Elf_Internal_Shdr *hdr;
d1105 1
a1105 16
		  sym = local_syms + r_index;
		  hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		  sym_sec = hdr->bfd_section;
		  sym_name = bfd_elf_string_from_elf_section (input_bfd,
							      symtab_hdr->sh_link,
							      sym->st_name);
		  sym_value = (ELF_ST_TYPE (sym->st_info) == STT_SECTION
			       ? 0 : sym->st_value);
		  destination = (sym_value
				 + sym_sec->output_offset
				 + sym_sec->output_section->vma);

		  /* Tack on an ID so we can uniquely identify this local
		     symbol in the stub or arg info hash tables.  */
		  new_name = bfd_malloc (strlen (sym_name) + 10);
		  if (new_name == 0)
d1107 2
a1108 6
		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
a1109 7
		  sprintf (new_name, "%s_%08x", sym_name, (int)sym_sec);
		  sym_name = new_name;
		}
	      else
		{
		  /* It's an external symbol.  */
		  long index;
d1111 9
a1119 4
		  index = r_index - symtab_hdr->sh_info;
		  hash = elf_sym_hashes (input_bfd)[index];
		  if (hash->root.type == bfd_link_hash_defined
		      || hash->root.type == bfd_link_hash_defweak)
d1121 14
a1134 4
		      sym_sec = hash->root.u.def.section;
		      sym_name = hash->root.root.string;
		      sym_value = hash->root.u.def.value;
		      destination = (sym_value
d1140 30
a1169 7
		      bfd_set_error (bfd_error_bad_value);
		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
a1170 1
		}
d1172 7
a1178 19
	      /* Now determine where the call point is.  */
	      location = (section->output_offset
			  + section->output_section->vma
			  + irela->r_offset);

	      /* We only care about the destination for PCREL function
		 calls (eg. we don't care for PLABELS).  */
	      if (r_type != R_PARISC_PCREL17F)
		location = destination;

	      /* Determine what (if any) linker stub is needed and its
		 size (in bytes).  */
	      size_of_stub = elf32_hppa_size_of_stub (location,
						      destination,
						      sym_name);
	      if (size_of_stub != 0)
		{
		  char *stub_name;
		  unsigned int len;
d1181 5
a1185 4
		  len = strlen (sym_name);
		  len += 23;

		  stub_name = bfd_malloc (len);
d1187 1
a1187 15
		    {
		      /* Because sym_name was mallocd above for local
			 symbols.  */
		      if (r_index < symtab_hdr->sh_info)
			free (new_name);

		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
		    }
		  elf32_hppa_name_of_stub (location, destination, stub_name);
		  strcat (stub_name + 22, sym_name);
d1189 5
a1193 8
		  /* Because sym_name was malloced above for local symbols.  */
		  if (r_index < symtab_hdr->sh_info)
		    free (new_name);

		  stub_hash
		    = elf32_hppa_stub_hash_lookup (stub_hash_table, stub_name,
						   false, false);
		  if (stub_hash != NULL)
d1195 1
a1195 2
		      /* The proper stub has already been created, nothing
			 else to do.  */
d1197 1
d1199 3
a1201 1
		  else
d1203 14
a1216 10
		      bfd_set_section_size (stub_bfd, stub_sec,
					    (bfd_section_size (stub_bfd,
							       stub_sec)
					     + size_of_stub));

		      /* Enter this entry into the linker stub hash table.  */
		      stub_hash
			= elf32_hppa_stub_hash_lookup (stub_hash_table,
						       stub_name, true, true);
		      if (stub_hash == NULL)
d1218 2
a1219 7
			  free (stub_name);
			  free (internal_relocs);
			  for (i = 0; i < bfd_count; i++)
			    if (all_local_syms[i])
			      free (all_local_syms[i]);
			  free (all_local_syms);
			  goto error_return;
d1221 26
d1248 14
a1261 4
		      /* We'll need these to determine the address that the
			 stub will branch to.  */
		      stub_hash->target_value = sym_value;
		      stub_hash->target_section = sym_sec;
d1263 8
a1270 1
		  free (stub_name);
d1272 2
a1274 2
	  /* We're done with the internal relocs, free them.  */
	  free (internal_relocs);
d1276 29
d1306 1
d1312 1
d1315 8
a1322 11
error_return:
  /* Return gracefully, avoiding dangling references to the hash tables.  */
  if (stub_hash_table)
    {
      elf32_hppa_hash_table(link_info)->stub_hash_table = NULL;
      free (stub_hash_table);
    }
  /* Set the size of the stub section to zero since we're never going
     to create them.   Avoids losing when we try to get its contents
     too.  */
  bfd_set_section_size (stub_bfd, stub_sec, 0);
d1335 4
@


1.11
log
@Fit 64-bit nits.
@
text
@d314 1
a314 1
      /* XXX computing constant_value is not needed??? */
d319 2
a320 1
      constant_value = (constant_value << 15) >> 15;
d323 2
a324 3
	  sym_value -=
	    address + input_sect->output_offset
	    + input_sect->output_section->vma;
@


1.10
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d668 1
a668 1
	    || ((int)(value - location) < (int)0xfffc0000))
d834 1
a834 1
	|| ((int)(location - destination) < (int)0xfffc0000)))
@


1.9
log
@1999-08-17  H.J. Lu  <hjl@@gnu.org>

	* elf32-hppa.c (bfd_elf32_bfd_is_local_label_name): Fix typo in
	macro definition.
@
text
@d446 1
a446 1
		     input_section, rel->r_offset)))
d482 1
a482 1
		     input_section, rel->r_offset)))
@


1.8
log
@        * elf-hppa.h (elf_hppa_fake_sections): New function.
        * elf32-hppa.c (elf_backend_fake_sections): Define.
@
text
@d1311 1
a1311 1
#define bfd_elf32_bfd_is_local_label_name	elf_hppa_is_lcoal_label_name
@


1.7
log
@
        * elf-hppa.h (_bfd_elf_hppa_gen_reloc_type, case 32): When in
        64bit mode, generate a section relative relocation for a 32bit
        wide relocation.
        (elf_hppa_is_local_label_name): New function.
        * elf32-hppa.c (elf_hppa_is_local_label_name): Deleted.  To be
        shared between 32bit and 64bit port.
@
text
@d1320 2
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@a116 2
static boolean hppa_elf_is_local_label_name PARAMS ((bfd *, const char *));

a792 10
/* Return true if SYM represents a local label symbol.  */

static boolean
hppa_elf_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return (name[0] == 'L' && name[1] == '$');
}

d1311 1
a1311 1
#define bfd_elf32_bfd_is_local_label_name	hppa_elf_is_local_label_name
@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d536 1
a536 1
     bfd *output_bfd;
d799 1
a799 1
     bfd *abfd;
d810 5
a814 5
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp;
d828 2
a829 1
     bfd_vma location, destination;
d984 1
a984 1
     bfd *output_bfd;
@


1.4
log
@
        * elf-hppa.c (elf_hppa_howto_table): Use bfd_elf_generic_reloc as
        relocation function.
        * elf32-hppa.c (hppa_elf_reloc): Kill unused/unwanted function.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
d639 1
a639 1
	unsigned int len, caller_args, callee_args;
d989 1
a989 2
  Elf_Internal_Sym *local_syms, *isym, **all_local_syms;
  Elf32_External_Sym *ext_syms, *esym;
@


1.3
log
@
        * elf-hppa.c (elf_hppa_final_write_processing): New function.
        * elf32-hppa.c: Remove everything related to symbol extension
        sections & records.  Use the common elf_hppa_final_write_processing.
@
text
@a112 3
static bfd_reloc_status_type hppa_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

a116 3
static bfd_reloc_status_type hppa_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd*, char **));

a524 35
}

/* Actually perform a relocation.  NOTE this is (mostly) superceeded
   by elf32_hppa_bfd_final_link_relocate which is called by the new
   fast linker.  */

static bfd_reloc_status_type
hppa_elf_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
		error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* It is no longer valid to call hppa_elf_reloc when creating
     a final executable.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;

      /* Work around lossage in generic elf code to write relocations.
	 (maps different section symbols into the same symbol index).  */
      if ((symbol_in->flags & BSF_SECTION_SYM)
	  && symbol_in->section)
	reloc_entry->addend += symbol_in->section->output_offset;
      return bfd_reloc_ok;
    }
  else
    {
      *error_message = (char *) _("Unsupported call to hppa_elf_reloc");
      return bfd_reloc_notsupported;
    }
@


1.2
log
@        * elf-hppa.h: New file.  Common stuff for elf32 and elf64 PA
        support.
        * elf32-hppa.c: Include elf-hppa.h.
        (ARCH_SIZE): Define.
        (elf_hppa_reloc_type_lookup): Delete.  Found in the common code
        now.
        (elf32_hppa_info_to_howto): Similarly.
        (elf_hppa_howto_table): Similarly.
        (elf_hppa_reloc_type_lookup): Similarly.
        (hppa_elf_gen_reloc_type): Similarly.
        * elf32-hppa.h (ELF_HOWTO_TALBE, N_PARISC_RELOCS): Delete.
@
text
@a37 44
/* The internal type of a symbol table extension entry.  */
typedef unsigned long symext_entryS;

/* The external type of a symbol table extension entry.  */
#define ELF32_PARISC_SX_SIZE (4)
#define ELF32_PARISC_SX_GET(bfd, addr) bfd_h_get_32 ((bfd), (addr))
#define ELF32_PARISC_SX_PUT(bfd, val, addr) \
  bfd_h_put_32 ((bfd), (val), (addr))

/* HPPA symbol table extension entry types */
enum elf32_hppa_symextn_types
{
  PARISC_SXT_NULL,
  PARISC_SXT_SYMNDX,
  PARISC_SXT_ARG_RELOC,
};

/* These macros compose and decompose the value of a symextn entry:

   entry_type = ELF32_PARISC_SX_TYPE(word);
   entry_value = ELF32_PARISC_SX_VAL(word);
   word = ELF32_PARISC_SX_WORD(type,val);  */

#define ELF32_PARISC_SX_TYPE(p)		((p) >> 24)
#define ELF32_PARISC_SX_VAL(p)		((p) & 0xFFFFFF)
#define ELF32_PARISC_SX_WORD(type,val)	(((type) << 24) + (val & 0xFFFFFF))

/* The following was added facilitate implementation of the .hppa_symextn
   section.  This section is built after the symbol table is built in the
   elf_write_object_contents routine (called from bfd_close).  It is built
   so late because it requires information that is not known until
   the symbol and string table sections have been allocated, and
   the symbol table has been built. */

#define SYMEXTN_SECTION_NAME ".PARISC.symext"

struct symext_chain
  {
    symext_entryS entry;
    struct symext_chain *next;
  };

typedef struct symext_chain symext_chainS;

d47 1
a47 5
   necessary to build the linker stubs during a link.

   The last hash table keeps track of argument location information needed
   to build hash tables.  Each function with nonzero argument location
   bits will have an entry in this table.  */
a82 17
/* Hash table for argument location information.  */

struct elf32_hppa_args_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  /* The argument location bits for this entry.  */
  int arg_bits;
};

struct elf32_hppa_args_hash_table
{
  /* The hash table itself.  */
  struct bfd_hash_table root;
};

a95 3
  /* The argument relocation bits hash table.  */
  struct elf32_hppa_args_hash_table *args_hash_table;

a103 26
/* FIXME.  */
#define ARGUMENTS	0
#define RETURN_VALUE	1

/* The various argument relocations that may be performed.  */
typedef enum
{
  /* No relocation.  */
  NO,
  /* Relocate 32 bits from GR to FP register.  */
  GF,
  /* Relocate 64 bits from a GR pair to FP pair.  */
  GD,
  /* Relocate 32 bits from FP to GR.  */
  FG,
  /* Relocate 64 bits from FP pair to GR pair.  */
  DG,
} arg_reloc_type;

/* What is being relocated (eg which argument or the return value).  */
typedef enum
{
  ARG0, ARG1, ARG2, ARG3, RET,
} arg_reloc_location;


a122 19
static boolean elf32_hppa_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));

static boolean elf32_hppa_backend_symbol_table_processing
  PARAMS ((bfd *, elf_symbol_type *, unsigned int));

static void elf32_hppa_backend_begin_write_processing
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_backend_final_write_processing
  PARAMS ((bfd *, boolean));

static void add_entry_to_symext_chain
  PARAMS ((bfd *, unsigned int, unsigned int, symext_chainS **,
	   symext_chainS **));

static void
elf_hppa_tc_make_sections PARAMS ((bfd *, symext_chainS *));

a140 4
static struct bfd_hash_entry *
elf32_hppa_args_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

a155 5
static boolean
elf32_hppa_read_symext_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, struct elf32_hppa_args_hash_table *,
	   Elf_Internal_Sym *));

d157 1
a157 4
  PARAMS ((unsigned int, unsigned int, bfd_vma, bfd_vma, const char *));

static boolean elf32_hppa_arg_reloc_needed
  PARAMS ((unsigned int, unsigned int, arg_reloc_type []));
d160 1
a160 53
  PARAMS ((unsigned int, unsigned int, bfd_vma, bfd_vma, char *));

static boolean elf32_hppa_size_symext PARAMS ((struct bfd_hash_entry *, PTR));

static boolean elf32_hppa_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *));

/* Where (what register type) is an argument comming from?  */
typedef enum
{
  AR_NO,
  AR_GR,
  AR_FR,
  AR_FU,
  AR_FPDBL1,
  AR_FPDBL2,
} arg_location;

/* Horizontal represents the callee's argument location information,
   vertical represents caller's argument location information.  Value at a
   particular X,Y location represents what (if any) argument relocation
   needs to be performed to make caller and callee agree.  */

static CONST arg_reloc_type arg_mismatches[6][6] =
{
  {NO, NO, NO, NO, NO, NO},
  {NO, NO, GF, NO, GD, NO},
  {NO, FG, NO, NO, NO, NO},
  {NO, NO, NO, NO, NO, NO},
  {NO, DG, NO, NO, NO, NO},
  {NO, DG, NO, NO, NO, NO},
};

/* Likewise, but reversed for the return value.  */
static CONST arg_reloc_type ret_mismatches[6][6] =
{
  {NO, NO, NO, NO, NO, NO},
  {NO, NO, FG, NO, DG, NO},
  {NO, GF, NO, NO, NO, NO},
  {NO, NO, NO, NO, NO, NO},
  {NO, GD, NO, NO, NO, NO},
  {NO, GD, NO, NO, NO, NO},
};

/* Misc static crud for symbol extension records.  */
static symext_chainS *symext_rootP;
static symext_chainS *symext_lastP;
static bfd_size_type symext_chain_size;

/* FIXME: We should be able to try this static variable!  */
static bfd_byte *symextn_contents;

a172 18
/* For linker args hash tables.  */
#define elf32_hppa_args_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_args_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

#define elf32_hppa_args_hash_traverse(table, func, info) \
  (bfd_hash_traverse \
   (&(table)->root, \
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \
    (info)))

#define elf32_hppa_args_hash_table_init(table, newfunc) \
  (bfd_hash_table_init \
   (&(table)->root, \
    (struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *, \
					 struct bfd_hash_table *, \
					 const char *))) (newfunc)))

a191 4
/* Extract specific argument location bits for WHICH from
   the full argument location in AR.  */
#define EXTRACT_ARBITS(ar, which) ((ar) >> (8 - ((which) * 2))) & 3

a245 32
/* Initialize an entry in the argument location hash table.  */

static struct bfd_hash_entry *
elf32_hppa_args_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elf32_hppa_args_hash_entry *ret;

  ret = (struct elf32_hppa_args_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct elf32_hppa_args_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_hppa_args_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_hppa_args_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  /* Initialize the local fields.  */
  if (ret)
    ret->arg_bits = 0;

  return (struct bfd_hash_entry *) ret;
}

a266 1
  ret->args_hash_table = NULL;
a472 7
      /* If args_hash_table is NULL, then we have encountered some
	 kind of link error (ex. undefined symbols).  Do not try to
	 apply any relocations, continue the loop so we can notify
	 the user of several errors in a single attempted link.  */
      if (elf32_hppa_hash_table (info)->args_hash_table == NULL)
	continue;

a532 19
/* Set the contents of a particular section at a particular location.  */

static boolean
elf32_hppa_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  /* Ignore write requests for the symbol extension section until we've
     had the chance to rebuild it ourselves.  */
  if (!strcmp (section->name, ".PARISC.symextn") && !symext_chain_size)
    return true;
  else
    return _bfd_elf_set_section_contents (abfd, section, location,
					  offset, count);
}

a680 3
	arg_reloc_type arg_reloc_types[5];
	struct elf32_hppa_args_hash_table *args_hash_table;
	struct elf32_hppa_args_hash_entry *args_hash;
a696 2
	/* Now look for the argument relocation bits associated with the
	   target.  */
a708 21
	args_hash_table = elf32_hppa_hash_table (info)->args_hash_table;

	args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						 new_name, false, false);
	if (args_hash == NULL)
	  callee_args = 0;
	else
	  callee_args = args_hash->arg_bits;

	/* If this is a CALL relocation, then get the caller's bits
	   from the addend.  Else use the magic 0x155 value for PLABELS.

	   Also we don't care about the destination (value) for PLABELS.  */
	if (r_type == R_PARISC_PCREL17F)
	  caller_args = HPPA_R_ARG_RELOC (addend);
	else
	  {
	    caller_args = 0x155;
	    location = value;
	  }

d711 1
a711 3
	    || ((int)(value - location) < (int)0xfffc0000)
	    || elf32_hppa_arg_reloc_needed (caller_args, callee_args,
					    arg_reloc_types))
d724 1
a724 2
	    elf32_hppa_name_of_stub (caller_args, callee_args,
				     location, value, stub_name);
a741 1

d813 3
a815 22
		else
		  {
		    /* PLABEL stuff is easy.  */

		    value = (stub_hash->offset
			     + stub_section->output_offset
			     + stub_section->output_section->vma);
		    /* We don't need the RP adjustment for PLABELs.  */
		    value += 4;
		    if (r_type == R_PARISC_PLABEL32)
		      r_format = 32;
		    else if (r_type == R_PARISC_PLABEL21L)
		      r_format = 21;
		    else if (r_type == R_PARISC_PLABEL14R)
		      r_format = 14;

		    r_pcrel = 0;
		    addend = 0;
		  }
		}
	      else
		return bfd_reloc_notsupported;
a845 484
/* Do any backend specific processing when beginning to write an object
   file.  For PA ELF we need to determine the size of the symbol extension
   section *before* any other output processing happens.  */

static void
elf32_hppa_backend_begin_write_processing (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  unsigned int i;
  asection *symextn_sec;

  /* Size up the symbol extension section.  */
  if ((abfd->outsymbols == NULL
       && info == NULL)
      || symext_chain_size != 0)
    return;

  if (info == NULL)
    {
      /* We were not called from the BFD ELF linker code, so we need
	 to examine the output BFD's outsymbols.

	 Note we can not build the symbol extensions now as the symbol
	 map hasn't been set up.  */
      for (i = 0; i < abfd->symcount; i++)
	{
	  elf_symbol_type *symbol = (elf_symbol_type *)abfd->outsymbols[i];

	  /* Only functions ever need an entry in the symbol extension
	     section.  */
	  if (!(symbol->symbol.flags & BSF_FUNCTION))
	    continue;

	  /* And only if they specify the locations of their arguments.  */
	  if (symbol->tc_data.hppa_arg_reloc == 0)
	    continue;

	  /* Yup.  This function symbol needs an entry.  */
	  symext_chain_size += 2 * ELF32_PARISC_SX_SIZE;
	}
    }
  else if (info->relocateable == true)
    {
      struct elf32_hppa_args_hash_table *table;
      table = elf32_hppa_hash_table (info)->args_hash_table;

      /* Determine the size of the symbol extension section.  */
      elf32_hppa_args_hash_traverse (table,
				     elf32_hppa_size_symext,
				     &symext_chain_size);
    }

  /* Now create the section and set its size.  We'll fill in the
     contents later.  */
  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == NULL)
    symextn_sec = bfd_make_section (abfd, SYMEXTN_SECTION_NAME);

  bfd_set_section_flags (abfd, symextn_sec,
			 SEC_LOAD | SEC_HAS_CONTENTS | SEC_DATA);
  symextn_sec->output_section = symextn_sec;
  symextn_sec->output_offset = 0;
  bfd_set_section_alignment (abfd, symextn_sec, 2);
  bfd_set_section_size (abfd, symextn_sec, symext_chain_size);
}

/* Called for each entry in the args location hash table.  For each
   entry we bump the size pointer by 2 records (16 bytes).  */

static boolean
elf32_hppa_size_symext (gen_entry, in_args)
     struct bfd_hash_entry *gen_entry;
     PTR in_args;
{
  bfd_size_type *sizep = (bfd_size_type *)in_args;

  *sizep += 2 * ELF32_PARISC_SX_SIZE;
  return true;
}

/* Backend routine called by the linker for each output symbol.

   For PA ELF we use this opportunity to add an appropriate entry
   to the symbol extension chain for function symbols.  */

static boolean
elf32_hppa_link_output_symbol_hook (abfd, info, name, sym, section)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection *section;
{
  char *new_name;
  unsigned int len, index;
  struct elf32_hppa_args_hash_table *args_hash_table;
  struct elf32_hppa_args_hash_entry *args_hash;

  /* If the args hash table is NULL, then we've encountered an error
     of some sorts (for example, an undefined symbol).  In that case
     we've got nothing else to do.

     NOTE: elf_link_output_symbol will abort if we return false here!  */
  if (elf32_hppa_hash_table (info)->args_hash_table == NULL)
    return true;

  index = elf32_hppa_hash_table (info)->output_symbol_count++;

  /* We need to look up this symbol in the args hash table to see if
     it has argument relocation bits.  */
  if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    return true;

  /* We know it's a function symbol of some kind.  */
  len = strlen (name) + 1;
  if (ELF_ST_BIND (sym->st_info) == STB_LOCAL)
    len += 9;

  new_name = bfd_malloc (len);
  if (new_name == NULL)
    return false;

  strcpy (new_name, name);
  if (ELF_ST_BIND (sym->st_info) == STB_LOCAL)
    sprintf (new_name + len - 10, "_%08x", (int)section);

  /* Now that we have the unique name, we can look it up in the
     args hash table.  */
  args_hash_table = elf32_hppa_hash_table (info)->args_hash_table;
  args_hash = elf32_hppa_args_hash_lookup (args_hash_table, new_name,
					   false, false);
  free (new_name);
  if (args_hash == NULL)
    return true;

  /* We know this symbol has arg reloc bits.  */
  add_entry_to_symext_chain (abfd, args_hash->arg_bits,
			     index, &symext_rootP, &symext_lastP);
  return true;
}

/* Perform any processing needed late in the object file writing process.
   For PA ELF we build and set the contents of the symbol extension
   section.  */

static void
elf32_hppa_backend_final_write_processing (abfd, linker)
     bfd *abfd;
     boolean linker;
{
  asection *symextn_sec;
  unsigned int i;

  /* Now build the symbol extension section.  */
  if (symext_chain_size == 0)
    return;

  if (! linker)
    {
      /* We were not called from the backend linker, so we still need
	 to build the symbol extension chain.

         Look at each symbol, adding the appropriate information to the
	 symbol extension section list as necessary.  */
      for (i = 0; i < abfd->symcount; i++)
	{
	  elf_symbol_type *symbol = (elf_symbol_type *) abfd->outsymbols[i];

	  /* Only functions ever need an entry in the symbol extension
	     section.  */
	  if (!(symbol->symbol.flags & BSF_FUNCTION))
	    continue;

	  /* And only if they specify the locations of their arguments.  */
	  if (symbol->tc_data.hppa_arg_reloc == 0)
	    continue;

	  /* Add this symbol's information to the chain.  */
	  add_entry_to_symext_chain (abfd, symbol->tc_data.hppa_arg_reloc,
				     symbol->symbol.udata.i, &symext_rootP,
				     &symext_lastP);
	}
    }

  /* Now fill in the contents of the symbol extension section.  */
  elf_hppa_tc_make_sections (abfd, symext_rootP);

  /* And attach that as the section's contents.  */
  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == (asection *) 0)
    abort();

  symextn_sec->contents = (void *)symextn_contents;

  bfd_set_section_contents (abfd, symextn_sec, symextn_sec->contents,
			    symextn_sec->output_offset, symextn_sec->_raw_size);
}

/* Update the symbol extention chain to include the symbol pointed to
   by SYMBOLP if SYMBOLP is a function symbol.  Used internally and by GAS.  */

static void
add_entry_to_symext_chain (abfd, arg_reloc, sym_idx, symext_root, symext_last)
     bfd *abfd;
     unsigned int arg_reloc;
     unsigned int sym_idx;
     symext_chainS **symext_root;
     symext_chainS **symext_last;
{
  symext_chainS *symextP;

  /* Allocate memory and initialize this entry.  */
  symextP = (symext_chainS *) bfd_alloc (abfd, sizeof (symext_chainS) * 2);
  if (!symextP)
    abort();			/* FIXME */

  symextP[0].entry = ELF32_PARISC_SX_WORD (PARISC_SXT_SYMNDX, sym_idx);
  symextP[0].next = &symextP[1];

  symextP[1].entry = ELF32_PARISC_SX_WORD (PARISC_SXT_ARG_RELOC, arg_reloc);
  symextP[1].next = NULL;

  /* Now update the chain itself so it can be walked later to build
     the symbol extension section.  */
  if (*symext_root == NULL)
    {
      *symext_root = &symextP[0];
      *symext_last = &symextP[1];
    }
  else
    {
      (*symext_last)->next = &symextP[0];
      *symext_last = &symextP[1];
    }
}

/* Build the symbol extension section.  */

static void
elf_hppa_tc_make_sections (abfd, symext_root)
     bfd *abfd;
     symext_chainS *symext_root;
{
  symext_chainS *symextP;
  unsigned int i;
  asection *symextn_sec;

  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);

  /* Grab some memory for the contents of the symbol extension section
     itself.  */
  symextn_contents = (bfd_byte *) bfd_zalloc (abfd,
					      symextn_sec->_raw_size);
  if (!symextn_contents)
    abort();			/* FIXME */

  /* Fill in the contents of the symbol extension chain.  */
  for (i = 0, symextP = symext_root; symextP; symextP = symextP->next, ++i)
    ELF32_PARISC_SX_PUT (abfd, (bfd_vma) symextP->entry,
			 symextn_contents + i * ELF32_PARISC_SX_SIZE);

  return;
}

/* Do some PA ELF specific work after reading in the symbol table.
   In particular attach the argument relocation from the
   symbol extension section to the appropriate symbols.  */

static boolean
elf32_hppa_backend_symbol_table_processing (abfd, esyms,symcnt)
     bfd *abfd;
     elf_symbol_type *esyms;
     unsigned int symcnt;
{
  Elf32_Internal_Shdr *symextn_hdr =
    bfd_elf_find_section (abfd, SYMEXTN_SECTION_NAME);
  unsigned int i, current_sym_idx = 0;

  /* If no symbol extension existed, then all symbol extension information
     is assumed to be zero.  */
  if (symextn_hdr == NULL)
    {
      for (i = 0; i < symcnt; i++)
	esyms[i].tc_data.hppa_arg_reloc = 0;
      return (true);
    }

  /* FIXME:  Why not use bfd_get_section_contents here?  Also should give
     memory back when we're done.  */
  /* Allocate a buffer of the appropriate size for the symextn section.  */
  symextn_hdr->contents = bfd_zalloc(abfd,symextn_hdr->sh_size);
  if (!symextn_hdr->contents)
    return false;

  /* Read in the symextn section.  */
  if (bfd_seek (abfd, symextn_hdr->sh_offset, SEEK_SET) == -1)
    return false;
  if (bfd_read ((PTR) symextn_hdr->contents, 1, symextn_hdr->sh_size, abfd)
      != symextn_hdr->sh_size)
    return false;

  /* Parse entries in the symbol extension section, updating the symtab
     entries as we go */
  for (i = 0; i < symextn_hdr->sh_size / ELF32_PARISC_SX_SIZE; i++)
    {
      symext_entryS se =
	ELF32_PARISC_SX_GET (abfd,
			     ((unsigned char *)symextn_hdr->contents
			      + i * ELF32_PARISC_SX_SIZE));
      unsigned int se_value = ELF32_PARISC_SX_VAL (se);
      unsigned int se_type = ELF32_PARISC_SX_TYPE (se);

      switch (se_type)
	{
	case PARISC_SXT_NULL:
	  break;

	case PARISC_SXT_SYMNDX:
	  if (se_value >= symcnt)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return (false);
	    }
	  current_sym_idx = se_value - 1;
	  break;

	case PARISC_SXT_ARG_RELOC:
	  esyms[current_sym_idx].tc_data.hppa_arg_reloc = se_value;
	  break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  return (false);
	}
    }
  return (true);
}

/* Read and attach the symbol extension information for the symbols
   in INPUT_BFD to the argument location hash table.  Handle locals
   if DO_LOCALS is true; likewise for globals when DO_GLOBALS is true.  */

static boolean
elf32_hppa_read_symext_info (input_bfd, symtab_hdr, args_hash_table, local_syms)
     bfd *input_bfd;
     Elf_Internal_Shdr *symtab_hdr;
     struct elf32_hppa_args_hash_table *args_hash_table;
     Elf_Internal_Sym *local_syms;
{
  asection *symextn_sec;
  bfd_byte *contents;
  unsigned int i, n_entries, current_index = 0;

  /* Get the symbol extension section for this BFD.  If no section exists
     then there's nothing to do.  Likewise if the section exists, but
     has no contents.  */
  symextn_sec = bfd_get_section_by_name (input_bfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == NULL)
    return true;

  /* Done separately so we can turn off SEC_HAS_CONTENTS (see below).  */
  if (symextn_sec->_raw_size == 0)
    {
      symextn_sec->flags &= ~SEC_HAS_CONTENTS;
      return true;
    }

  contents = (bfd_byte *) bfd_malloc ((size_t) symextn_sec->_raw_size);
  if (contents == NULL)
    return false;

  /* How gross.  We turn off SEC_HAS_CONTENTS for the input symbol extension
     sections to keep the generic ELF/BFD code from trying to do anything
     with them.  We have to undo that hack temporarily so that we can read
     in the contents with the generic code.  */
  symextn_sec->flags |= SEC_HAS_CONTENTS;
  if (bfd_get_section_contents (input_bfd, symextn_sec, contents,
				0, symextn_sec->_raw_size) == false)
    {
      symextn_sec->flags &= ~SEC_HAS_CONTENTS;
      free (contents);
      return false;
    }

  /* Gross.  Turn off SEC_HAS_CONTENTS for the input symbol extension
     sections (see above).  */
  symextn_sec->flags &= ~SEC_HAS_CONTENTS;

  n_entries = symextn_sec->_raw_size / ELF32_PARISC_SX_SIZE;
  for (i = 0; i < n_entries; i++)
    {
      symext_entryS entry =
	ELF32_PARISC_SX_GET (input_bfd, contents + i * ELF32_PARISC_SX_SIZE);
      unsigned int value = ELF32_PARISC_SX_VAL (entry);
      unsigned int type = ELF32_PARISC_SX_TYPE (entry);
      struct elf32_hppa_args_hash_entry *args_hash;

      switch (type)
	{
	case PARISC_SXT_NULL:
	  break;

	case PARISC_SXT_SYMNDX:
	  if (value >= symtab_hdr->sh_size / sizeof (Elf32_External_Sym))
	    {
	      bfd_set_error (bfd_error_bad_value);
	      free (contents);
	      return false;
	    }
	  current_index = value;
	  break;

	case PARISC_SXT_ARG_RELOC:
	  if (current_index < symtab_hdr->sh_info)
	    {
	      Elf_Internal_Shdr *hdr;
	      char *new_name;
	      const char *sym_name;
	      asection *sym_sec;
	      unsigned int len;

	      hdr = elf_elfsections (input_bfd)[local_syms[current_index].st_shndx];
	      sym_sec = hdr->bfd_section;
	      sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
	 			        local_syms[current_index].st_name);
	      len = strlen (sym_name) + 10;
	      new_name = bfd_malloc (len);
	      if (new_name == NULL)
		{
		  free (contents);
		  return false;
		}
	      strcpy (new_name, sym_name);
	      sprintf (new_name + len - 10, "_%08x", (int)sym_sec);

	      /* This is a global symbol with argument location info.
		 We need to enter it into the hash table.  */
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       new_name, true,
						       true);
	      free (new_name);
	      if (args_hash == NULL)
		{
		  free (contents);
		  return false;
		}
	      args_hash->arg_bits = value;
	      break;
	    }
	  else if (current_index >= symtab_hdr->sh_info)
	    {
	      struct elf_link_hash_entry *h;

	      current_index -= symtab_hdr->sh_info;
	      h = elf_sym_hashes(input_bfd)[current_index];
	      /* This is a global symbol with argument location
		 information.  We need to enter it into the hash table.  */
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       h->root.root.string,
						       true, true);
	      if (args_hash == NULL)
		{
		  bfd_set_error (bfd_error_bad_value);
		  free (contents);
		  return false;
		}
	      args_hash->arg_bits = value;
	      break;
	    }
	  else
	    break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  free (contents);
	  return false;
	}
    }
  free (contents);
  return true;
}

d868 1
a868 2
elf32_hppa_name_of_stub (caller, callee, location, destination, stub_name)
     unsigned int caller, callee;
d872 1
a872 106
  arg_reloc_type arg_reloc_types[5];

  if (elf32_hppa_arg_reloc_needed (caller, callee, arg_reloc_types))
    {
      arg_reloc_location i;
      /* Fill in the basic template.  */
      strcpy (stub_name, "__XX_XX_XX_XX_XX_stub_");

      /* Now fix the specifics.  */
      for (i = ARG0; i <= RET; i++)
	switch (arg_reloc_types[i])
	  {
	    case NO:
	      stub_name[3 * i + 2] = 'N';
	      stub_name[3 * i + 3] = 'O';
	      break;
	    case GF:
	      stub_name[3 * i + 2] = 'G';
	      stub_name[3 * i + 3] = 'F';
	      break;
	    case FG:
	      stub_name[3 * i + 2] = 'F';
	      stub_name[3 * i + 3] = 'G';
	      break;
	    case GD:
	      stub_name[3 * i + 2] = 'G';
	      stub_name[3 * i + 3] = 'D';
	      break;
	    case DG:
	      stub_name[3 * i + 2] = 'D';
	      stub_name[3 * i + 3] = 'G';
	      break;
	  }
    }
  else
    strcpy (stub_name, "_____long_branch_stub_");
}

/* Determine if an argument relocation stub is needed to perform a
   call assuming the argument relocation bits for caller and callee
   are in CALLER and CALLEE.  Place the type of relocations (if any)
   into stub_types_p.  */

static boolean
elf32_hppa_arg_reloc_needed (caller, callee, stub_types)
     unsigned int caller, callee;
     arg_reloc_type stub_types[5];
{
  /* Special case for no relocations.  */
  if (caller == 0 || callee == 0)
    return 0;
  else
    {
      arg_location caller_loc[5];
      arg_location callee_loc[5];

      /* Extract the location information for the argument and return
	 value on both the caller and callee sides.  */
      caller_loc[ARG0] = EXTRACT_ARBITS (caller, ARG0);
      callee_loc[ARG0] = EXTRACT_ARBITS (callee, ARG0);
      caller_loc[ARG1] = EXTRACT_ARBITS (caller, ARG1);
      callee_loc[ARG1] = EXTRACT_ARBITS (callee, ARG1);
      caller_loc[ARG2] = EXTRACT_ARBITS (caller, ARG2);
      callee_loc[ARG2] = EXTRACT_ARBITS (callee, ARG2);
      caller_loc[ARG3] = EXTRACT_ARBITS (caller, ARG3);
      callee_loc[ARG3] = EXTRACT_ARBITS (callee, ARG3);
      caller_loc[RET] = EXTRACT_ARBITS (caller, RET);
      callee_loc[RET] = EXTRACT_ARBITS (callee, RET);

      /* Check some special combinations.  This is necessary to
	 deal with double precision FP arguments.  */
      if (caller_loc[ARG0] == AR_FU || caller_loc[ARG1] == AR_FU)
	{
	  caller_loc[ARG0] = AR_FPDBL1;
	  caller_loc[ARG1] = AR_NO;
	}
      if (caller_loc[ARG2] == AR_FU || caller_loc[ARG3] == AR_FU)
	{
	  caller_loc[ARG2] = AR_FPDBL2;
	  caller_loc[ARG3] = AR_NO;
	}
      if (callee_loc[ARG0] == AR_FU || callee_loc[ARG1] == AR_FU)
	{
	  callee_loc[ARG0] = AR_FPDBL1;
	  callee_loc[ARG1] = AR_NO;
	}
      if (callee_loc[ARG2] == AR_FU || callee_loc[ARG3] == AR_FU)
	{
	  callee_loc[ARG2] = AR_FPDBL2;
	  callee_loc[ARG3] = AR_NO;
	}

      /* Now look up any relocation needed for each argument and the
	 return value.  */
      stub_types[ARG0] = arg_mismatches[caller_loc[ARG0]][callee_loc[ARG0]];
      stub_types[ARG1] = arg_mismatches[caller_loc[ARG1]][callee_loc[ARG1]];
      stub_types[ARG2] = arg_mismatches[caller_loc[ARG2]][callee_loc[ARG2]];
      stub_types[ARG3] = arg_mismatches[caller_loc[ARG3]][callee_loc[ARG3]];
      stub_types[RET] = ret_mismatches[caller_loc[RET]][callee_loc[RET]];

      return (stub_types[ARG0] != NO
	      || stub_types[ARG1] != NO
	      || stub_types[ARG2] != NO
	      || stub_types[ARG3] != NO
	      || stub_types[RET] != NO);
    }
d880 1
a880 2
elf32_hppa_size_of_stub (callee, caller, location, destination, sym_name)
     unsigned int callee, caller;
d884 1
a884 5
  arg_reloc_type arg_reloc_types[5];

  /* Determine if a long branch or argument relocation stub is needed.
     If an argument relocation stub is needed, the relocation will be
     stored into arg_reloc_types.  */
d886 1
a886 2
	|| ((int)(location - destination) < (int)0xfffc0000)
	|| elf32_hppa_arg_reloc_needed (caller, callee, arg_reloc_types)))
d889 1
a889 41
  /* Some kind of stub is needed.  Determine how big it needs to be.
     First check for argument relocation stubs as they also handle
     long calls.  Then check for long calls to millicode and finally
     the normal long calls.  */
  if (arg_reloc_types[ARG0] != NO
      || arg_reloc_types[ARG1] != NO
      || arg_reloc_types[ARG2] != NO
      || arg_reloc_types[ARG3] != NO
      || arg_reloc_types[RET] != NO)
    {
      /* Some kind of argument relocation stub is needed.  */
      unsigned int len = 16;
      arg_reloc_location i;

      /* Each GR or FG relocation takes 2 insns, each GD or DG
	 relocation takes 3 insns.  Plus 4 more insns for the
         RP adjustment, ldil & (be | ble) and copy.  */
      for (i = ARG0; i <= RET; i++)
	switch (arg_reloc_types[i])
	  {
	    case GF:
	    case FG:
	      len += 8;
	      break;

	    case GD:
	    case DG:
	      len += 12;
	      break;

	    default:
	      break;
	  }

      /* Extra instructions are needed if we're relocating a return value.  */
      if (arg_reloc_types[RET] != NO)
	len += 12;

      return len;
    }
  else if (!strncmp ("$$", sym_name, 2)
d930 1
a930 125
  if (strncmp ("_____long_branch_stub_", entry->root.string, 22))
    {
      /* This must be an argument or return value relocation stub.  */
      unsigned long insn;
      arg_reloc_location i;
      bfd_byte *begin_loc = loc;

      /* First the return pointer adjustment.  Depending on exact calling
	 sequence this instruction may be skipped.  */
      bfd_put_32 (stub_bfd, LDO_M4_R31_R31, loc);
      loc += 4;

      /* If we are relocating a return value, then we're going to have
	 to return into the stub.  So we have to save off the user's
	 return pointer into the stack at RP'.  */
      if (strncmp (entry->root.string + 14, "NO", 2))
	{
	  bfd_put_32 (stub_bfd, STW_R31_M8R30, loc);
	  loc += 4;
	}

      /* Iterate over the argument relocations, emitting instructions
	 to move them around as necessary.  */
      for (i = ARG0; i <= ARG3; i++)
	{
	  if (!strncmp (entry->root.string + 3 * i + 2, "GF", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | ((26 - i) << 16), loc);
	      bfd_put_32 (stub_bfd, FLDW_M16R30_FARG | (4 + i), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "FG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTW_FARG_M16R30 | (4 + i), loc);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | ((26 - i) << 16), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "GD", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M12R30 | ((26 - i) << 16), loc);
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | ((25 - i) << 16), loc + 4);
	      bfd_put_32 (stub_bfd, FLDD_M16R30_FARG | (5 + i), loc + 8);
	      loc += 12;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "DG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTD_FARG_M16R30 | (5 + i), loc);
	      bfd_put_32 (stub_bfd, LDW_M12R30_ARG | ((26 - i) << 16), loc + 4);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | ((25 - i) << 16), loc + 8);
	      loc += 12;
	    }
	}

      /* Load the high bits of the target address into %r1.  */
      insn = hppa_rebuild_insn (stub_bfd, LDIL_R1,
				hppa_field_adjust (sym_value, 0, e_lrsel), 21);
      bfd_put_32 (stub_bfd, insn, loc);
      loc += 4;

      /* If we are relocating a return value, then we're going to have
	 to return into the stub, then perform the return value relocation.  */
      if (strncmp (entry->root.string + 14, "NO", 2))
	{
	  /* To return to the stub we "ble" to the target and copy the return
	     pointer from %r31 into %r2.  */
	  insn = hppa_rebuild_insn (stub_bfd,
				    BLE_SR4_R1,
				    hppa_field_adjust (sym_value, 0,
						       e_rrsel) >> 2,
				    17);
	  bfd_put_32 (stub_bfd, insn, loc);
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 4);

	  /* Reload the return pointer for our caller from the stack.  */
	  bfd_put_32 (stub_bfd, LDW_M8R30_R31, loc + 8);
	  loc += 12;

	  /* Perform the return value relocation.  */
	  if (!strncmp (entry->root.string + 14, "GF", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | (28 << 16), loc);
	      bfd_put_32 (stub_bfd, FLDW_M16R30_FARG | 4, loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 14, "FG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTW_FARG_M16R30 | 4, loc);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | (28 << 16), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 2, "GD", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M12R30 | (28 << 16), loc);
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | (29 << 16), loc + 4);
	      bfd_put_32 (stub_bfd, FLDD_M16R30_FARG | 4, loc + 8);
	      loc += 12;
	    }
	  else if (!strncmp (entry->root.string + 2, "DG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTD_FARG_M16R30 | 4, loc);
	      bfd_put_32 (stub_bfd, LDW_M12R30_ARG | (28 << 16), loc + 4);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | (29 << 16), loc + 8);
	      loc += 12;
	    }
	  /* Branch back to the user's code now.  */
	  bfd_put_32 (stub_bfd, BV_N_0_R31, loc);
	  loc += 4;
	}
      else
	{
	  /* No return value relocation, so we can simply "be" to the
	     target and copy out return pointer into %r2.  */
	  insn = hppa_rebuild_insn (stub_bfd, BE_SR4_R1,
				    hppa_field_adjust (sym_value, 0,
						       e_rrsel) >> 2, 17);
	  bfd_put_32 (stub_bfd, insn, loc);
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 4);
	  loc += 8;
	}

      /* Update the location and offsets.  */
      stub_hash_table->location += (loc - begin_loc);
      stub_hash_table->offset += (loc - begin_loc);
    }
  else
a1033 1
  struct elf32_hppa_args_hash_table *args_hash_table = 0;
a1044 10
  /* Likewise for the argument location hash table.  */
  args_hash_table = ((struct elf32_hppa_args_hash_table *)
		     bfd_malloc (sizeof (struct elf32_hppa_args_hash_table)));
  if (!args_hash_table)
    goto error_return;

  if (!elf32_hppa_args_hash_table_init (args_hash_table,
					elf32_hppa_args_hash_newfunc))
    goto error_return;

a1046 1
  elf32_hppa_hash_table(link_info)->args_hash_table = args_hash_table;
a1053 82
  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  all_local_syms
    = (Elf_Internal_Sym **) bfd_malloc (sizeof (Elf_Internal_Sym *)
					* bfd_count);
  if (all_local_syms == NULL)
    goto error_return;
  memset (all_local_syms, 0, sizeof (Elf_Internal_Sym *) * bfd_count);

  /* Walk over all the input BFDs adding entries to the args hash table
     for all the external functions.  */
  for (input_bfd = link_info->input_bfds, index = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, index++)
    {
      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      local_syms
	= (Elf_Internal_Sym *) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (Elf_Internal_Sym));
      if (local_syms == NULL)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}
      all_local_syms[index] = local_syms;

      ext_syms
	= (Elf32_External_Sym *) bfd_malloc (symtab_hdr->sh_info
					     * sizeof (Elf32_External_Sym));
      if (ext_syms == NULL)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_read (ext_syms, 1,
		       (symtab_hdr->sh_info
			* sizeof (Elf32_External_Sym)), input_bfd)
	  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym)))
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  free (ext_syms);
	  goto error_return;
	}

      /* Swap the local symbols in.  */
      isym = local_syms;
      esym = ext_syms;
      for (i = 0; i < symtab_hdr->sh_info; i++, esym++, isym++)
	 bfd_elf32_swap_symbol_in (input_bfd, esym, isym);

      /* Now we can free the external symbols.  */
      free (ext_syms);

      if (elf32_hppa_read_symext_info (input_bfd, symtab_hdr, args_hash_table,
				       local_syms) == false)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}
    }

d1153 1
a1153 1
	      long r_type, callee_args, caller_args, size_of_stub;
a1156 1
	      struct elf32_hppa_args_hash_entry *args_hash;
a1251 18
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       sym_name, false, false);

	      /* Get both caller and callee argument information.  */
	      if (args_hash == NULL)
		callee_args = 0;
	      else
		callee_args = args_hash->arg_bits;

	      /* For calls get the caller's bits from the addend of
		 the call relocation.  For PLABELS the caller's bits
		 are assumed to have all args & return values in general
		 registers (0x155).  */
	      if (r_type == R_PARISC_PCREL17F)
		caller_args = HPPA_R_ARG_RELOC (irela->r_addend);
	      else
		caller_args = 0x155;

d1264 1
a1264 3
	      size_of_stub = elf32_hppa_size_of_stub (callee_args,
						      caller_args,
						      location,
d1291 1
a1291 2
		  elf32_hppa_name_of_stub (caller_args, callee_args,
					   location, destination, stub_name);
a1354 5
  if (args_hash_table)
    {
      elf32_hppa_hash_table(link_info)->args_hash_table = NULL;
      free (args_hash_table);
    }
a1367 9
/* Symbol extension stuff.  */
#define bfd_elf32_set_section_contents		elf32_hppa_set_section_contents
#define elf_backend_symbol_table_processing \
  elf32_hppa_backend_symbol_table_processing
#define elf_backend_begin_write_processing \
  elf32_hppa_backend_begin_write_processing
#define elf_backend_final_write_processing \
  elf32_hppa_backend_final_write_processing

a1370 2
#define elf_backend_link_output_symbol_hook \
  elf32_hppa_link_output_symbol_hook
@


1.1
log
@Initial revision
@
text
@a28 1
#include "bfdlink.h"
d31 6
a216 3
static reloc_howto_type * elf_hppa_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));

a219 3
static void elf32_hppa_info_to_howto
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));

a292 167
/* ELF/PA relocation howto entries.  */

static reloc_howto_type elf_hppa_howto_table[ELF_HOWTO_TABLE_SIZE] =
{
  {R_PARISC_NONE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_NONE"},
  /* The values in DIR32 are to placate the check in
     _bfd_stab_section_find_nearest_line.  */
  {R_PARISC_DIR32, 0, 2, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR32", false, 0, 0xffffffff, false},
  {R_PARISC_DIR21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR21L"},
  {R_PARISC_DIR17R, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR17R"},
  {R_PARISC_DIR17F, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR17F"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DIR14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR14R"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PCREL21L, 0, 0, 21, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL21L"},
  {R_PARISC_PCREL17R, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17R"},
  {R_PARISC_PCREL17F, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17F"},
  {R_PARISC_PCREL17C, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17C"},
  {R_PARISC_PCREL14R, 0, 0, 14, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL14R"},
  {R_PARISC_PCREL14F, 0, 0, 14, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DPREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DPREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL14R"},
  {R_PARISC_DPREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL14R"},
  {R_PARISC_DLTREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTIND21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTIND14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND14R"},
  {R_PARISC_DLTIND14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND14F"},

  {R_PARISC_SETBASE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_SETBASE"},
  {R_PARISC_BASEREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL32"},
  {R_PARISC_BASEREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL21L"},
  {R_PARISC_BASEREL17R, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL17R"},
  {R_PARISC_BASEREL17F, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL17F"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_BASEREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL14R"},
  {R_PARISC_BASEREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_TEXTREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_TEXTREL32"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DATAREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},


  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLABEL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL32"},
  {R_PARISC_PLABEL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLABEL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL14R"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},


  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLTIND21L, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLTIND14R, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND14R"},
  {R_PARISC_PLTIND14F, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND14F"},


  {R_PARISC_COPY, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_COPY"},
  {R_PARISC_GLOB_DAT, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_GLOB_DAT"},
  {R_PARISC_JMP_SLOT, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_JMP_SLOT"},
  {R_PARISC_RELATIVE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_RELATIVE"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_dont, NULL, "R_PARISC_UNIMPLEMENTED"},
};

a771 213
/* Return one (or more) BFD relocations which implement the base
   relocation with modifications based on format and field.  */

elf32_hppa_reloc_type **
hppa_elf_gen_reloc_type (abfd, base_type, format, field, ignore, sym)
     bfd *abfd;
     elf32_hppa_reloc_type base_type;
     int format;
     int field;
     int ignore;
     asymbol *sym;
{
  elf32_hppa_reloc_type *finaltype;
  elf32_hppa_reloc_type **final_types;

  /* Allocate slots for the BFD relocation.  */
  final_types = ((elf32_hppa_reloc_type **)
		 bfd_alloc (abfd, sizeof (elf32_hppa_reloc_type *) * 2));
  if (final_types == NULL)
    return NULL;

  /* Allocate space for the relocation itself.  */
  finaltype = ((elf32_hppa_reloc_type *)
	       bfd_alloc (abfd, sizeof (elf32_hppa_reloc_type)));
  if (finaltype == NULL)
    return NULL;

  /* Some reasonable defaults.  */
  final_types[0] = finaltype;
  final_types[1] = NULL;

#define final_type finaltype[0]

  final_type = base_type;

  /* Just a tangle of nested switch statements to deal with the braindamage
     that a different field selector means a completely different relocation
     for PA ELF.  */
  switch (base_type)
    {
    case R_HPPA:
    case R_HPPA_ABS_CALL:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DIR14R;
	      break;
	    case e_rtsel:
	      final_type = R_PARISC_DLTREL14R;
	      break;
	    case e_tsel:
	      final_type = R_PARISC_DLTREL14F;
	      break;
	    case e_rpsel:
	      final_type = R_PARISC_PLABEL14R;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 17:
	  switch (field)
	    {
	    case e_fsel:
	      final_type = R_PARISC_DIR17F;
	      break;
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DIR17R;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lsel:
	    case e_lrsel:
	      final_type = R_PARISC_DIR21L;
	      break;
	    case e_ltsel:
	      final_type = R_PARISC_DLTREL21L;
	      break;
	    case e_lpsel:
	      final_type = R_PARISC_PLABEL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 32:
	  switch (field)
	    {
	    case e_fsel:
	      final_type = R_PARISC_DIR32;
	      break;
	    case e_psel:
	      final_type = R_PARISC_PLABEL32;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;


    case R_HPPA_GOTOFF:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DPREL14R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_DPREL14F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lrsel:
	    case e_lsel:
	      final_type = R_PARISC_DPREL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;


    case R_HPPA_PCREL_CALL:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_PCREL14R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_PCREL14F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 17:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_PCREL17R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_PCREL17F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lsel:
	    case e_lrsel:
	      final_type = R_PARISC_PCREL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;

    default:
      return NULL;
    }

  return final_types;
}

#undef final_type

a790 13
/* Translate from an elf into field into a howto relocation pointer.  */

static void
elf32_hppa_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rela *dst;
{
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_PARISC_UNIMPLEMENTED);
  cache_ptr->howto = &elf_hppa_howto_table[ELF32_R_TYPE (dst->r_info)];
}


a1142 16
/* Return the address of the howto table entry to perform the CODE
   relocation for an ARCH machine.  */

static reloc_howto_type *
elf_hppa_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
  if ((int) code < (int) R_PARISC_UNIMPLEMENTED)
    {
      BFD_ASSERT ((int) elf_hppa_howto_table[(int) code].type == (int) code);
      return &elf_hppa_howto_table[(int) code];
    }
  return NULL;
}

d2553 2
a2557 1
#define elf_info_to_howto			elf32_hppa_info_to_howto
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

