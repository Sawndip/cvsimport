head	1.92;
access;
symbols
	sid-snapshot-20180601:1.92
	sid-snapshot-20180501:1.92
	sid-snapshot-20180401:1.92
	sid-snapshot-20180301:1.92
	sid-snapshot-20180201:1.92
	sid-snapshot-20180101:1.92
	sid-snapshot-20171201:1.92
	sid-snapshot-20171101:1.92
	sid-snapshot-20171001:1.92
	sid-snapshot-20170901:1.92
	sid-snapshot-20170801:1.92
	sid-snapshot-20170701:1.92
	sid-snapshot-20170601:1.92
	sid-snapshot-20170501:1.92
	sid-snapshot-20170401:1.92
	sid-snapshot-20170301:1.92
	sid-snapshot-20170201:1.92
	sid-snapshot-20170101:1.92
	sid-snapshot-20161201:1.92
	sid-snapshot-20161101:1.92
	sid-snapshot-20160901:1.92
	sid-snapshot-20160801:1.92
	sid-snapshot-20160701:1.92
	sid-snapshot-20160601:1.92
	sid-snapshot-20160501:1.92
	sid-snapshot-20160401:1.92
	sid-snapshot-20160301:1.92
	sid-snapshot-20160201:1.92
	sid-snapshot-20160101:1.92
	sid-snapshot-20151201:1.92
	sid-snapshot-20151101:1.92
	sid-snapshot-20151001:1.92
	sid-snapshot-20150901:1.92
	sid-snapshot-20150801:1.92
	sid-snapshot-20150701:1.92
	sid-snapshot-20150601:1.92
	sid-snapshot-20150501:1.92
	sid-snapshot-20150401:1.92
	sid-snapshot-20150301:1.92
	sid-snapshot-20150201:1.92
	sid-snapshot-20150101:1.92
	sid-snapshot-20141201:1.92
	sid-snapshot-20141101:1.92
	sid-snapshot-20141001:1.92
	sid-snapshot-20140901:1.92
	sid-snapshot-20140801:1.92
	sid-snapshot-20140701:1.92
	sid-snapshot-20140601:1.92
	sid-snapshot-20140501:1.92
	sid-snapshot-20140401:1.92
	sid-snapshot-20140301:1.92
	sid-snapshot-20140201:1.92
	sid-snapshot-20140101:1.92
	sid-snapshot-20131201:1.92
	sid-snapshot-20131101:1.92
	sid-snapshot-20131001:1.92
	binutils-2_24-branch:1.92.0.4
	binutils-2_24-branchpoint:1.92
	binutils-2_21_1:1.84.4.1
	sid-snapshot-20130901:1.92
	gdb_7_6_1-2013-08-30-release:1.92
	sid-snapshot-20130801:1.92
	sid-snapshot-20130701:1.92
	sid-snapshot-20130601:1.92
	sid-snapshot-20130501:1.92
	gdb_7_6-2013-04-26-release:1.92
	sid-snapshot-20130401:1.92
	binutils-2_23_2:1.90
	gdb_7_6-branch:1.92.0.2
	gdb_7_6-2013-03-12-branchpoint:1.92
	sid-snapshot-20130301:1.92
	sid-snapshot-20130201:1.90
	sid-snapshot-20130101:1.90
	sid-snapshot-20121201:1.90
	gdb_7_5_1-2012-11-29-release:1.90
	binutils-2_23_1:1.90
	sid-snapshot-20121101:1.90
	binutils-2_23:1.90
	sid-snapshot-20121001:1.90
	sid-snapshot-20120901:1.90
	gdb_7_5-2012-08-17-release:1.90
	sid-snapshot-20120801:1.90
	binutils-2_23-branch:1.90.0.4
	binutils-2_23-branchpoint:1.90
	gdb_7_5-branch:1.90.0.2
	gdb_7_5-2012-07-18-branchpoint:1.90
	sid-snapshot-20120701:1.90
	sid-snapshot-20120601:1.90
	sid-snapshot-20120501:1.88
	binutils-2_22_branch:1.87.0.6
	gdb_7_4_1-2012-04-26-release:1.87
	sid-snapshot-20120401:1.87
	sid-snapshot-20120301:1.87
	sid-snapshot-20120201:1.87
	gdb_7_4-2012-01-24-release:1.87
	sid-snapshot-20120101:1.87
	gdb_7_4-branch:1.87.0.4
	gdb_7_4-2011-12-13-branchpoint:1.87
	sid-snapshot-20111201:1.87
	binutils-2_22:1.87
	sid-snapshot-20111101:1.87
	sid-snapshot-20111001:1.87
	binutils-2_22-branch:1.87.0.2
	binutils-2_22-branchpoint:1.87
	gdb_7_3_1-2011-09-04-release:1.85
	sid-snapshot-20110901:1.87
	sid-snapshot-20110801:1.87
	gdb_7_3-2011-07-26-release:1.85
	sid-snapshot-20110701:1.87
	sid-snapshot-20110601:1.85
	sid-snapshot-20110501:1.85
	gdb_7_3-branch:1.85.0.2
	gdb_7_3-2011-04-01-branchpoint:1.85
	sid-snapshot-20110401:1.85
	sid-snapshot-20110301:1.85
	sid-snapshot-20110201:1.85
	sid-snapshot-20110101:1.85
	binutils-2_21:1.84
	sid-snapshot-20101201:1.85
	binutils-2_21-branch:1.84.0.4
	binutils-2_21-branchpoint:1.84
	sid-snapshot-20101101:1.84
	sid-snapshot-20101001:1.84
	binutils-2_20_1:1.77.2.1
	gdb_7_2-2010-09-02-release:1.84
	sid-snapshot-20100901:1.84
	sid-snapshot-20100801:1.84
	gdb_7_2-branch:1.84.0.2
	gdb_7_2-2010-07-07-branchpoint:1.84
	sid-snapshot-20100701:1.84
	sid-snapshot-20100601:1.84
	sid-snapshot-20100501:1.84
	sid-snapshot-20100401:1.82
	gdb_7_1-2010-03-18-release:1.82
	sid-snapshot-20100301:1.82
	gdb_7_1-branch:1.82.0.2
	gdb_7_1-2010-02-18-branchpoint:1.82
	sid-snapshot-20100201:1.82
	sid-snapshot-20100101:1.82
	gdb_7_0_1-2009-12-22-release:1.78
	sid-snapshot-20091201:1.81
	sid-snapshot-20091101:1.81
	binutils-2_20:1.77.2.1
	gdb_7_0-2009-10-06-release:1.78
	sid-snapshot-20091001:1.81
	gdb_7_0-branch:1.78.0.2
	gdb_7_0-2009-09-16-branchpoint:1.78
	arc-sim-20090309:1.70
	binutils-arc-20081103-branch:1.73.0.10
	binutils-arc-20081103-branchpoint:1.73
	binutils-2_20-branch:1.77.0.2
	binutils-2_20-branchpoint:1.77
	sid-snapshot-20090901:1.76
	sid-snapshot-20090801:1.75
	msnyder-checkpoint-072509-branch:1.75.0.2
	msnyder-checkpoint-072509-branchpoint:1.75
	sid-snapshot-20090701:1.74
	dje-cgen-play1-branch:1.74.0.2
	dje-cgen-play1-branchpoint:1.74
	sid-snapshot-20090601:1.74
	sid-snapshot-20090501:1.74
	sid-snapshot-20090401:1.74
	arc-20081103-branch:1.73.0.8
	arc-20081103-branchpoint:1.73
	arc-insight_6_8-branch:1.70.0.10
	arc-insight_6_8-branchpoint:1.70
	insight_6_8-branch:1.70.0.8
	insight_6_8-branchpoint:1.70
	sid-snapshot-20090301:1.74
	binutils-2_19_1:1.72.2.1
	sid-snapshot-20090201:1.74
	sid-snapshot-20090101:1.73
	reverse-20081226-branch:1.73.0.6
	reverse-20081226-branchpoint:1.73
	sid-snapshot-20081201:1.73
	multiprocess-20081120-branch:1.73.0.4
	multiprocess-20081120-branchpoint:1.73
	sid-snapshot-20081101:1.73
	binutils-2_19:1.72.2.1
	sid-snapshot-20081001:1.73
	reverse-20080930-branch:1.73.0.2
	reverse-20080930-branchpoint:1.73
	binutils-2_19-branch:1.72.0.2
	binutils-2_19-branchpoint:1.72
	sid-snapshot-20080901:1.72
	sid-snapshot-20080801:1.71
	reverse-20080717-branch:1.70.0.6
	reverse-20080717-branchpoint:1.70
	sid-snapshot-20080701:1.70
	msnyder-reverse-20080609-branch:1.70.0.4
	msnyder-reverse-20080609-branchpoint:1.70
	drow-reverse-20070409-branch:1.54.0.2
	drow-reverse-20070409-branchpoint:1.54
	sid-snapshot-20080601:1.70
	sid-snapshot-20080501:1.70
	sid-snapshot-20080403:1.70
	sid-snapshot-20080401:1.70
	gdb_6_8-2008-03-27-release:1.70
	sid-snapshot-20080301:1.70
	gdb_6_8-branch:1.70.0.2
	gdb_6_8-2008-02-26-branchpoint:1.70
	sid-snapshot-20080201:1.70
	sid-snapshot-20080101:1.69
	sid-snapshot-20071201:1.63
	sid-snapshot-20071101:1.62
	gdb_6_7_1-2007-10-29-release:1.62
	gdb_6_7-2007-10-10-release:1.62
	sid-snapshot-20071001:1.62
	gdb_6_7-branch:1.62.0.4
	gdb_6_7-2007-09-07-branchpoint:1.62
	binutils-2_18:1.62
	binutils-2_18-branch:1.62.0.2
	binutils-2_18-branchpoint:1.62
	insight_6_6-20070208-release:1.52
	binutils-csl-coldfire-4_1-32:1.48.4.1
	binutils-csl-sourcerygxx-4_1-32:1.48.4.1
	gdb_6_6-2006-12-18-release:1.52
	binutils-csl-innovasic-fido-3_4_4-33:1.48.4.1
	binutils-csl-sourcerygxx-3_4_4-32:1.44
	binutils-csl-coldfire-4_1-30:1.48.4.1
	binutils-csl-sourcerygxx-4_1-30:1.48.4.1
	binutils-csl-coldfire-4_1-28:1.48.4.1
	binutils-csl-sourcerygxx-4_1-29:1.48.4.1
	binutils-csl-sourcerygxx-4_1-28:1.48.4.1
	gdb_6_6-branch:1.52.0.2
	gdb_6_6-2006-11-15-branchpoint:1.52
	binutils-csl-arm-2006q3-27:1.48.4.1
	binutils-csl-sourcerygxx-4_1-27:1.48.4.1
	binutils-csl-arm-2006q3-26:1.48.4.1
	binutils-csl-sourcerygxx-4_1-26:1.48.4.1
	binutils-csl-sourcerygxx-4_1-25:1.48.4.1
	binutils-csl-sourcerygxx-4_1-24:1.48.4.1
	binutils-csl-sourcerygxx-4_1-23:1.48.4.1
	insight_6_5-20061003-release:1.49
	gdb-csl-symbian-6_4_50_20060226-12:1.47
	binutils-csl-sourcerygxx-4_1-21:1.48.4.1
	binutils-csl-arm-2006q3-21:1.48.4.1
	binutils-csl-sourcerygxx-4_1-22:1.48.4.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48.4.1
	binutils-csl-sourcerygxx-4_1-20:1.48.4.1
	binutils-csl-arm-2006q3-19:1.48.4.1
	binutils-csl-sourcerygxx-4_1-19:1.48.4.1
	binutils-csl-sourcerygxx-4_1-18:1.48.4.1
	binutils-csl-renesas-4_1-9:1.48.4.1
	gdb-csl-sourcerygxx-3_4_4-25:1.47
	binutils-csl-sourcerygxx-3_4_4-25:1.44
	nickrob-async-20060828-mergepoint:1.51
	gdb-csl-symbian-6_4_50_20060226-11:1.47
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	gdb-csl-sourcerygxx-4_1-17:1.47
	binutils-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.47
	gdb-csl-sourcerygxx-4_1-14:1.47
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	gdb-csl-sourcerygxx-4_1-13:1.47
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48.8.1
	gdb-csl-sourcerygxx-4_1-12:1.47
	binutils-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.47
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.49
	binutils-csl-wrs-linux-3_4_4-24:1.44
	binutils-csl-wrs-linux-3_4_4-23:1.44
	gdb-csl-sourcerygxx-4_1-9:1.47
	binutils-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.47
	binutils-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.47
	binutils-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.47
	binutils-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.47
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.44
	gdb-csl-symbian-6_4_50_20060226-10:1.47
	gdb-csl-symbian-6_4_50_20060226-9:1.47
	gdb-csl-symbian-6_4_50_20060226-8:1.47
	gdb-csl-coldfire-4_1-11:1.47
	binutils-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.47
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.47
	gdb_6_5-branch:1.49.0.4
	gdb_6_5-2006-05-14-branchpoint:1.49
	binutils-csl-coldfire-4_1-10:1.48
	gdb-csl-sourcerygxx-4_1-5:1.47
	binutils-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.49.0.2
	nickrob-async-20060513-branchpoint:1.49
	gdb-csl-sourcerygxx-4_1-4:1.47
	binutils-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.12
	msnyder-reverse-20060502-branchpoint:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.44
	gdb-csl-morpho-4_1-4:1.47
	binutils-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.47
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.44
	readline_5_1-import-branch:1.48.0.10
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.47
	binutils-2_17-branch:1.48.0.8
	binutils-2_17-branchpoint:1.48
	gdb-csl-symbian-20060226-branch:1.47.0.14
	gdb-csl-symbian-20060226-branchpoint:1.47
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.47
	msnyder-reverse-20060331-branch:1.48.0.6
	msnyder-reverse-20060331-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.4
	binutils-csl-2_17-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.2
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.47.0.12
	gdb-csl-20060226-branchpoint:1.47
	gdb_6_4-20051202-release:1.47
	msnyder-fork-checkpoint-branch:1.47.0.10
	msnyder-fork-checkpoint-branchpoint:1.47
	gdb-csl-gxxpro-6_3-branch:1.47.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.47
	gdb_6_4-branch:1.47.0.6
	gdb_6_4-2005-11-01-branchpoint:1.47
	gdb-csl-arm-20051020-branch:1.47.0.4
	gdb-csl-arm-20051020-branchpoint:1.47
	binutils-csl-gxxpro-3_4-branch:1.44.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.44
	binutils-2_16_1:1.44
	msnyder-tracepoint-checkpoint-branch:1.47.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.47
	gdb-csl-arm-20050325-2005-q1b:1.44
	binutils-csl-arm-2005q1b:1.44
	binutils-2_16:1.44
	gdb-csl-arm-20050325-2005-q1a:1.44
	binutils-csl-arm-2005q1a:1.44
	csl-arm-20050325-branch:1.44.0.6
	csl-arm-20050325-branchpoint:1.44
	binutils-csl-arm-2005q1-branch:1.44.0.4
	binutils-csl-arm-2005q1-branchpoint:1.44
	binutils-2_16-branch:1.44.0.2
	binutils-2_16-branchpoint:1.44
	csl-arm-2004-q3d:1.35
	gdb_6_3-20041109-release:1.35
	gdb_6_3-branch:1.35.0.2
	gdb_6_3-20041019-branchpoint:1.35
	csl-arm-2004-q3:1.32
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.28
	binutils-2_15:1.27.6.1
	binutils-2_15-branchpoint:1.27
	csl-arm-2004-q1a:1.28
	csl-arm-2004-q1:1.28
	gdb_6_1-2004-04-05-release:1.28
	drow_intercu-merge-20040402:1.28
	drow_intercu-merge-20040327:1.28
	ezannoni_pie-20040323-branch:1.28.0.6
	ezannoni_pie-20040323-branchpoint:1.28
	cagney_tramp-20040321-mergepoint:1.28
	cagney_tramp-20040309-branch:1.28.0.4
	cagney_tramp-20040309-branchpoint:1.28
	gdb_6_1-branch:1.28.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.28
	drow_intercu-20040221-branch:1.27.0.8
	drow_intercu-20040221-branchpoint:1.27
	binutils-2_15-branch:1.27.0.6
	cagney_bfdfile-20040213-branch:1.27.0.4
	cagney_bfdfile-20040213-branchpoint:1.27
	drow-cplus-merge-20040208:1.27
	carlton_dictionary-20040126-merge:1.27
	cagney_bigcore-20040122-branch:1.27.0.2
	cagney_bigcore-20040122-branchpoint:1.27
	drow-cplus-merge-20040113:1.27
	csl-arm-2003-q4:1.27
	drow-cplus-merge-20031224:1.27
	drow-cplus-merge-20031220:1.27
	carlton_dictionary-20031215-merge:1.27
	drow-cplus-merge-20031214:1.27
	carlton-dictionary-20031111-merge:1.27
	gdb_6_0-2003-10-04-release:1.23
	kettenis_sparc-20030918-branch:1.25.0.6
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.4
	cagney_x86i386-20030821-branch:1.25.0.2
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.24
	carlton_dictionary-20030627-merge:1.24
	gdb_6_0-branch:1.23.0.22
	gdb_6_0-2003-06-23-branchpoint:1.23
	jimb-ppc64-linux-20030613-branch:1.23.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.23
	binutils-2_14:1.23
	cagney_convert-20030606-branch:1.23.0.18
	cagney_convert-20030606-branchpoint:1.23
	cagney_writestrings-20030508-branch:1.23.0.16
	cagney_writestrings-20030508-branchpoint:1.23
	jimb-ppc64-linux-20030528-branch:1.23.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.23
	carlton_dictionary-20030523-merge:1.23
	cagney_fileio-20030521-branch:1.23.0.12
	cagney_fileio-20030521-branchpoint:1.23
	kettenis_i386newframe-20030517-mergepoint:1.23
	jimb-ppc64-linux-20030509-branch:1.23.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.23
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	binutils-2_14-branch:1.23.0.8
	binutils-2_14-branchpoint:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.6
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.4
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.2
	cagney_framebase-20030330-mergepoint:1.22
	cagney_framebase-20030326-branch:1.22.0.10
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.22.0.8
	cagney_lazyid-20030317-branchpoint:1.22
	kettenis-i386newframe-20030316-mergepoint:1.22
	offbyone-20030313-branch:1.22.0.6
	offbyone-20030313-branchpoint:1.22
	kettenis-i386newframe-20030308-branch:1.22.0.4
	kettenis-i386newframe-20030308-branchpoint:1.22
	carlton_dictionary-20030305-merge:1.22
	cagney_offbyone-20030303-branch:1.22.0.2
	cagney_offbyone-20030303-branchpoint:1.22
	carlton_dictionary-20030207-merge:1.22
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	binutils-2_13_2_1:1.11.4.2
	binutils-2_13_2:1.11.4.2
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.18
	binutils-2_13_1:1.11.4.2
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.2
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.14.0.10
	carlton_dictionary-20020920-branchpoint:1.14
	sid-20020905-branchpoint:1.14
	sid-20020905-branch:1.14.0.8
	gdb_5_3-branch:1.14.0.6
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	binutils-2_13:1.11
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.4
	kseitz_interps-20020528-branch:1.11.0.2
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.10.0.4
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.7.2.2
	jimb-macro-020506-branch:1.10.0.2
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.7.2.1
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.6
	binutils_latest_snapshot:1.92;
locks; strict;
comment	@ * @;


1.92
date	2013.02.21.02.29.08;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2012.05.25.01.12.19;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2012.05.23.04.38.08;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2012.04.24.05.12.30;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2011.06.20.13.18.47;	author jakub;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2011.06.14.12.57.18;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2010.11.23.23.30.04;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.09.14.40.15;	author nickc;	state Exp;
branches
	1.84.4.1;
next	1.83;

1.83
date	2010.04.05.19.32.01;	author jakub;	state Exp;
branches;
next	1.82;

1.82
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2009.09.21.19.07.43;	author rsandifo;	state Exp;
branches;
next	1.80;

1.80
date	2009.09.21.18.55.06;	author rsandifo;	state Exp;
branches;
next	1.79;

1.79
date	2009.09.19.08.06.10;	author rsandifo;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2009.08.11.02.21.34;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2009.07.10.15.26.56;	author tromey;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.01.12.05.25;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2008.09.17.07.50.28;	author jkratoch;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.24.21.43.00;	author schwab;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2008.07.21.07.49.58;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.09.09.36.11;	author rsandifo;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.15.09.42.02;	author rsandifo;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.15.09.41.15;	author rsandifo;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.15.09.35.58;	author rsandifo;	state Exp;
branches;
next	1.66;

1.66
date	2007.12.15.09.34.48;	author rsandifo;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.15.09.33.51;	author rsandifo;	state Exp;
branches;
next	1.64;

1.64
date	2007.12.15.09.32.38;	author rsandifo;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.30.09.01.35;	author rsandifo;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.12.07.16.41;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.02.06.51.57;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.25.23.06.11;	author echristo;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.12.14.27.34;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.10.15.08.02;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.24.04.28.38;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.04.13.30.39;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.21.11.25.16;	author jakub;	state Exp;
branches;
next	1.52;

1.52
date	2006.10.03.13.15.39;	author jakub;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.24.02.37.47;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2006.02.27.23.07.05;	author jakub;	state Exp;
branches
	1.48.4.1
	1.48.8.1;
next	1.47;

1.47
date	2005.05.04.15.53.07;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.04.11.00.09;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.17.12.39.17;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.31.20.39.08;	author rsandifo;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.17.17.44.35;	author rsandifo;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.17.17.41.47;	author rsandifo;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.17.17.39.27;	author rsandifo;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.17.17.12.00;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.16.10.16.28;	author rsandifo;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.15.09.09.13;	author rsandifo;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.14.23.38.08;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.10.13.02.01;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.10.07.58.07;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.01.00.51.37;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.24.04.46.17;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.13.15.16.00;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.13.14.41.17;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.28.00.35.45;	author aoliva;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.16.21.04.04;	author hjl;	state Exp;
branches
	1.27.6.1
	1.27.8.1;
next	1.26;

1.26
date	2003.10.06.18.10.48;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.07.07.25.34;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.06.23.01.04;	author schwab;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.26.11.53.59;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.12.07.35.26;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.12.06.21.05;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.31.09.18.48;	author obrien;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.23.10.52.03;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.08.23.09.42.21;	author nickc;	state Exp;
branches
	1.14.10.1;
next	1.13;

1.13
date	2002.08.22.20.00.14;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.20.23.45.41;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.15.00.18.56;	author amodra;	state Exp;
branches
	1.11.2.1
	1.11.4.1;
next	1.10;

1.10
date	2002.04.22.21.37.48;	author jakub;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2002.04.22.12.06.01;	author jakub;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.12.40.23;	author jakub;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.25.06.24.34;	author amodra;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.01.04.17.02.30;	author jakub;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.31.11.49.10;	author jakub;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.19.11.48.15;	author jakub;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.18.11.49.52;	author jakub;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.15.08.54.13;	author jakub;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	;

1.87.2.1
date	2012.05.11.12.24.19;	author nickc;	state Exp;
branches;
next	;

1.84.4.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.77.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.72.2.1
date	2008.09.17.08.18.20;	author jkratoch;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2009.03.02.13.53.31;	author amodra;	state Exp;
branches;
next	;

1.48.4.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;

1.48.8.1
date	2006.06.02.02.29.19;	author drow;	state Exp;
branches;
next	;

1.27.6.1
date	2004.05.06.01.58.12;	author aoliva;	state Exp;
branches;
next	;

1.27.8.1
date	2004.03.27.17.37.31;	author drow;	state Exp;
branches;
next	1.27.8.2;

1.27.8.2
date	2004.09.16.17.00.19;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	;

1.14.10.1
date	2002.09.27.20.02.53;	author carlton;	state Exp;
branches;
next	1.14.10.2;

1.14.10.2
date	2002.11.15.19.18.25;	author carlton;	state Exp;
branches;
next	1.14.10.3;

1.14.10.3
date	2002.12.23.19.37.37;	author carlton;	state Exp;
branches;
next	1.14.10.4;

1.14.10.4
date	2003.02.07.19.17.37;	author carlton;	state Exp;
branches;
next	1.14.10.5;

1.14.10.5
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.14.10.6;

1.14.10.6
date	2003.06.27.21.49.11;	author carlton;	state Exp;
branches;
next	1.14.10.7;

1.14.10.7
date	2003.09.17.21.27.49;	author carlton;	state Exp;
branches;
next	1.14.10.8;

1.14.10.8
date	2003.11.11.23.50.12;	author carlton;	state Exp;
branches;
next	;

1.11.2.1
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.01.00.45.45;	author kseitz;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.11.4.1
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.31.09.33.40;	author obrien;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.7.2.1
date	2002.02.19.13.10.18;	author jakub;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.04.26.07.34.41;	author jakub;	state Exp;
branches;
next	;


desc
@@


1.92
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@/* .eh_frame section optimization.
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012 Free Software Foundation, Inc.
   Written by Jakub Jelinek <jakub@@redhat.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "dwarf2.h"

#define EH_FRAME_HDR_SIZE 8

struct cie
{
  unsigned int length;
  unsigned int hash;
  unsigned char version;
  unsigned char local_personality;
  char augmentation[20];
  bfd_vma code_align;
  bfd_signed_vma data_align;
  bfd_vma ra_column;
  bfd_vma augmentation_size;
  union {
    struct elf_link_hash_entry *h;
    bfd_vma val;
    unsigned int reloc_index;
  } personality;
  asection *output_sec;
  struct eh_cie_fde *cie_inf;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  unsigned char fde_encoding;
  unsigned char initial_insn_length;
  unsigned char can_make_lsda_relative;
  unsigned char initial_instructions[50];
};



/* If *ITER hasn't reached END yet, read the next byte into *RESULT and
   move onto the next byte.  Return true on success.  */

static inline bfd_boolean
read_byte (bfd_byte **iter, bfd_byte *end, unsigned char *result)
{
  if (*iter >= end)
    return FALSE;
  *result = *((*iter)++);
  return TRUE;
}

/* Move *ITER over LENGTH bytes, or up to END, whichever is closer.
   Return true it was possible to move LENGTH bytes.  */

static inline bfd_boolean
skip_bytes (bfd_byte **iter, bfd_byte *end, bfd_size_type length)
{
  if ((bfd_size_type) (end - *iter) < length)
    {
      *iter = end;
      return FALSE;
    }
  *iter += length;
  return TRUE;
}

/* Move *ITER over an leb128, stopping at END.  Return true if the end
   of the leb128 was found.  */

static bfd_boolean
skip_leb128 (bfd_byte **iter, bfd_byte *end)
{
  unsigned char byte;
  do
    if (!read_byte (iter, end, &byte))
      return FALSE;
  while (byte & 0x80);
  return TRUE;
}

/* Like skip_leb128, but treat the leb128 as an unsigned value and
   store it in *VALUE.  */

static bfd_boolean
read_uleb128 (bfd_byte **iter, bfd_byte *end, bfd_vma *value)
{
  bfd_byte *start, *p;

  start = *iter;
  if (!skip_leb128 (iter, end))
    return FALSE;

  p = *iter;
  *value = *--p;
  while (p > start)
    *value = (*value << 7) | (*--p & 0x7f);

  return TRUE;
}

/* Like read_uleb128, but for signed values.  */

static bfd_boolean
read_sleb128 (bfd_byte **iter, bfd_byte *end, bfd_signed_vma *value)
{
  bfd_byte *start, *p;

  start = *iter;
  if (!skip_leb128 (iter, end))
    return FALSE;

  p = *iter;
  *value = ((*--p & 0x7f) ^ 0x40) - 0x40;
  while (p > start)
    *value = (*value << 7) | (*--p & 0x7f);

  return TRUE;
}

/* Return 0 if either encoding is variable width, or not yet known to bfd.  */

static
int get_DW_EH_PE_width (int encoding, int ptr_size)
{
  /* DW_EH_PE_ values of 0x60 and 0x70 weren't defined at the time .eh_frame
     was added to bfd.  */
  if ((encoding & 0x60) == 0x60)
    return 0;

  switch (encoding & 7)
    {
    case DW_EH_PE_udata2: return 2;
    case DW_EH_PE_udata4: return 4;
    case DW_EH_PE_udata8: return 8;
    case DW_EH_PE_absptr: return ptr_size;
    default:
      break;
    }

  return 0;
}

#define get_DW_EH_PE_signed(encoding) (((encoding) & DW_EH_PE_signed) != 0)

/* Read a width sized value from memory.  */

static bfd_vma
read_value (bfd *abfd, bfd_byte *buf, int width, int is_signed)
{
  bfd_vma value;

  switch (width)
    {
    case 2:
      if (is_signed)
	value = bfd_get_signed_16 (abfd, buf);
      else
	value = bfd_get_16 (abfd, buf);
      break;
    case 4:
      if (is_signed)
	value = bfd_get_signed_32 (abfd, buf);
      else
	value = bfd_get_32 (abfd, buf);
      break;
    case 8:
      if (is_signed)
	value = bfd_get_signed_64 (abfd, buf);
      else
	value = bfd_get_64 (abfd, buf);
      break;
    default:
      BFD_FAIL ();
      return 0;
    }

  return value;
}

/* Store a width sized value to memory.  */

static void
write_value (bfd *abfd, bfd_byte *buf, bfd_vma value, int width)
{
  switch (width)
    {
    case 2: bfd_put_16 (abfd, value, buf); break;
    case 4: bfd_put_32 (abfd, value, buf); break;
    case 8: bfd_put_64 (abfd, value, buf); break;
    default: BFD_FAIL ();
    }
}

/* Return one if C1 and C2 CIEs can be merged.  */

static int
cie_eq (const void *e1, const void *e2)
{
  const struct cie *c1 = (const struct cie *) e1;
  const struct cie *c2 = (const struct cie *) e2;

  if (c1->hash == c2->hash
      && c1->length == c2->length
      && c1->version == c2->version
      && c1->local_personality == c2->local_personality
      && strcmp (c1->augmentation, c2->augmentation) == 0
      && strcmp (c1->augmentation, "eh") != 0
      && c1->code_align == c2->code_align
      && c1->data_align == c2->data_align
      && c1->ra_column == c2->ra_column
      && c1->augmentation_size == c2->augmentation_size
      && memcmp (&c1->personality, &c2->personality,
		 sizeof (c1->personality)) == 0
      && c1->output_sec == c2->output_sec
      && c1->per_encoding == c2->per_encoding
      && c1->lsda_encoding == c2->lsda_encoding
      && c1->fde_encoding == c2->fde_encoding
      && c1->initial_insn_length == c2->initial_insn_length
      && memcmp (c1->initial_instructions,
		 c2->initial_instructions,
		 c1->initial_insn_length) == 0)
    return 1;

  return 0;
}

static hashval_t
cie_hash (const void *e)
{
  const struct cie *c = (const struct cie *) e;
  return c->hash;
}

static hashval_t
cie_compute_hash (struct cie *c)
{
  hashval_t h = 0;
  h = iterative_hash_object (c->length, h);
  h = iterative_hash_object (c->version, h);
  h = iterative_hash (c->augmentation, strlen (c->augmentation) + 1, h);
  h = iterative_hash_object (c->code_align, h);
  h = iterative_hash_object (c->data_align, h);
  h = iterative_hash_object (c->ra_column, h);
  h = iterative_hash_object (c->augmentation_size, h);
  h = iterative_hash_object (c->personality, h);
  h = iterative_hash_object (c->output_sec, h);
  h = iterative_hash_object (c->per_encoding, h);
  h = iterative_hash_object (c->lsda_encoding, h);
  h = iterative_hash_object (c->fde_encoding, h);
  h = iterative_hash_object (c->initial_insn_length, h);
  h = iterative_hash (c->initial_instructions, c->initial_insn_length, h);
  c->hash = h;
  return h;
}

/* Return the number of extra bytes that we'll be inserting into
   ENTRY's augmentation string.  */

static INLINE unsigned int
extra_augmentation_string_bytes (struct eh_cie_fde *entry)
{
  unsigned int size = 0;
  if (entry->cie)
    {
      if (entry->add_augmentation_size)
	size++;
      if (entry->u.cie.add_fde_encoding)
	size++;
    }
  return size;
}

/* Likewise ENTRY's augmentation data.  */

static INLINE unsigned int
extra_augmentation_data_bytes (struct eh_cie_fde *entry)
{
  unsigned int size = 0;
  if (entry->add_augmentation_size)
    size++;
  if (entry->cie && entry->u.cie.add_fde_encoding)
    size++;
  return size;
}

/* Return the size that ENTRY will have in the output.  ALIGNMENT is the
   required alignment of ENTRY in bytes.  */

static unsigned int
size_of_output_cie_fde (struct eh_cie_fde *entry, unsigned int alignment)
{
  if (entry->removed)
    return 0;
  if (entry->size == 4)
    return 4;
  return (entry->size
	  + extra_augmentation_string_bytes (entry)
	  + extra_augmentation_data_bytes (entry)
	  + alignment - 1) & -alignment;
}

/* Assume that the bytes between *ITER and END are CFA instructions.
   Try to move *ITER past the first instruction and return true on
   success.  ENCODED_PTR_WIDTH gives the width of pointer entries.  */

static bfd_boolean
skip_cfa_op (bfd_byte **iter, bfd_byte *end, unsigned int encoded_ptr_width)
{
  bfd_byte op;
  bfd_vma length;

  if (!read_byte (iter, end, &op))
    return FALSE;

  switch (op & 0xc0 ? op & 0xc0 : op)
    {
    case DW_CFA_nop:
    case DW_CFA_advance_loc:
    case DW_CFA_restore:
    case DW_CFA_remember_state:
    case DW_CFA_restore_state:
    case DW_CFA_GNU_window_save:
      /* No arguments.  */
      return TRUE;

    case DW_CFA_offset:
    case DW_CFA_restore_extended:
    case DW_CFA_undefined:
    case DW_CFA_same_value:
    case DW_CFA_def_cfa_register:
    case DW_CFA_def_cfa_offset:
    case DW_CFA_def_cfa_offset_sf:
    case DW_CFA_GNU_args_size:
      /* One leb128 argument.  */
      return skip_leb128 (iter, end);

    case DW_CFA_val_offset:
    case DW_CFA_val_offset_sf:
    case DW_CFA_offset_extended:
    case DW_CFA_register:
    case DW_CFA_def_cfa:
    case DW_CFA_offset_extended_sf:
    case DW_CFA_GNU_negative_offset_extended:
    case DW_CFA_def_cfa_sf:
      /* Two leb128 arguments.  */
      return (skip_leb128 (iter, end)
	      && skip_leb128 (iter, end));

    case DW_CFA_def_cfa_expression:
      /* A variable-length argument.  */
      return (read_uleb128 (iter, end, &length)
	      && skip_bytes (iter, end, length));

    case DW_CFA_expression:
    case DW_CFA_val_expression:
      /* A leb128 followed by a variable-length argument.  */
      return (skip_leb128 (iter, end)
	      && read_uleb128 (iter, end, &length)
	      && skip_bytes (iter, end, length));

    case DW_CFA_set_loc:
      return skip_bytes (iter, end, encoded_ptr_width);

    case DW_CFA_advance_loc1:
      return skip_bytes (iter, end, 1);

    case DW_CFA_advance_loc2:
      return skip_bytes (iter, end, 2);

    case DW_CFA_advance_loc4:
      return skip_bytes (iter, end, 4);

    case DW_CFA_MIPS_advance_loc8:
      return skip_bytes (iter, end, 8);

    default:
      return FALSE;
    }
}

/* Try to interpret the bytes between BUF and END as CFA instructions.
   If every byte makes sense, return a pointer to the first DW_CFA_nop
   padding byte, or END if there is no padding.  Return null otherwise.
   ENCODED_PTR_WIDTH is as for skip_cfa_op.  */

static bfd_byte *
skip_non_nops (bfd_byte *buf, bfd_byte *end, unsigned int encoded_ptr_width,
	       unsigned int *set_loc_count)
{
  bfd_byte *last;

  last = buf;
  while (buf < end)
    if (*buf == DW_CFA_nop)
      buf++;
    else
      {
	if (*buf == DW_CFA_set_loc)
	  ++*set_loc_count;
	if (!skip_cfa_op (&buf, end, encoded_ptr_width))
	  return 0;
	last = buf;
      }
  return last;
}

/* Convert absolute encoding ENCODING into PC-relative form.
   SIZE is the size of a pointer.  */

static unsigned char
make_pc_relative (unsigned char encoding, unsigned int ptr_size)
{
  if ((encoding & 0x7f) == DW_EH_PE_absptr)
    switch (ptr_size)
      {
      case 2:
	encoding |= DW_EH_PE_sdata2;
	break;
      case 4:
	encoding |= DW_EH_PE_sdata4;
	break;
      case 8:
	encoding |= DW_EH_PE_sdata8;
	break;
      }
  return encoding | DW_EH_PE_pcrel;
}

/* Called before calling _bfd_elf_parse_eh_frame on every input bfd's
   .eh_frame section.  */

void
_bfd_elf_begin_eh_frame_parsing (struct bfd_link_info *info)
{
  struct eh_frame_hdr_info *hdr_info;

  hdr_info = &elf_hash_table (info)->eh_info;
  hdr_info->merge_cies = !info->relocatable;
}

/* Try to parse .eh_frame section SEC, which belongs to ABFD.  Store the
   information in the section's sec_info field on success.  COOKIE
   describes the relocations in SEC.  */

void
_bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
			 asection *sec, struct elf_reloc_cookie *cookie)
{
#define REQUIRE(COND)					\
  do							\
    if (!(COND))					\
      goto free_no_table;				\
  while (0)

  bfd_byte *ehbuf = NULL, *buf, *end;
  bfd_byte *last_fde;
  struct eh_cie_fde *this_inf;
  unsigned int hdr_length, hdr_id;
  unsigned int cie_count;
  struct cie *cie, *local_cies = NULL;
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;
  struct eh_frame_sec_info *sec_info = NULL;
  unsigned int ptr_size;
  unsigned int num_cies;
  unsigned int num_entries;
  elf_gc_mark_hook_fn gc_mark_hook;

  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->parsed_eh_frames)
    return;

  if (sec->size == 0
      || sec->sec_info_type != SEC_INFO_TYPE_NONE)
    {
      /* This file does not contain .eh_frame information.  */
      return;
    }

  if (bfd_is_abs_section (sec->output_section))
    {
      /* At least one of the sections is being discarded from the
	 link, so we should just ignore them.  */
      return;
    }

  /* Read the frame unwind information from abfd.  */

  REQUIRE (bfd_malloc_and_get_section (abfd, sec, &ehbuf));

  if (sec->size >= 4
      && bfd_get_32 (abfd, ehbuf) == 0
      && cookie->rel == cookie->relend)
    {
      /* Empty .eh_frame section.  */
      free (ehbuf);
      return;
    }

  /* If .eh_frame section size doesn't fit into int, we cannot handle
     it (it would need to use 64-bit .eh_frame format anyway).  */
  REQUIRE (sec->size == (unsigned int) sec->size);

  ptr_size = (get_elf_backend_data (abfd)
	      ->elf_backend_eh_frame_address_size (abfd, sec));
  REQUIRE (ptr_size != 0);

  /* Go through the section contents and work out how many FDEs and
     CIEs there are.  */
  buf = ehbuf;
  end = ehbuf + sec->size;
  num_cies = 0;
  num_entries = 0;
  while (buf != end)
    {
      num_entries++;

      /* Read the length of the entry.  */
      REQUIRE (skip_bytes (&buf, end, 4));
      hdr_length = bfd_get_32 (abfd, buf - 4);

      /* 64-bit .eh_frame is not supported.  */
      REQUIRE (hdr_length != 0xffffffff);
      if (hdr_length == 0)
	break;

      REQUIRE (skip_bytes (&buf, end, 4));
      hdr_id = bfd_get_32 (abfd, buf - 4);
      if (hdr_id == 0)
	num_cies++;

      REQUIRE (skip_bytes (&buf, end, hdr_length - 4));
    }

  sec_info = (struct eh_frame_sec_info *)
      bfd_zmalloc (sizeof (struct eh_frame_sec_info)
                   + (num_entries - 1) * sizeof (struct eh_cie_fde));
  REQUIRE (sec_info);

  /* We need to have a "struct cie" for each CIE in this section.  */
  local_cies = (struct cie *) bfd_zmalloc (num_cies * sizeof (*local_cies));
  REQUIRE (local_cies);

  /* FIXME: octets_per_byte.  */
#define ENSURE_NO_RELOCS(buf)				\
  REQUIRE (!(cookie->rel < cookie->relend		\
	     && (cookie->rel->r_offset			\
		 < (bfd_size_type) ((buf) - ehbuf))	\
	     && cookie->rel->r_info != 0))

  /* FIXME: octets_per_byte.  */
#define SKIP_RELOCS(buf)				\
  while (cookie->rel < cookie->relend			\
	 && (cookie->rel->r_offset			\
	     < (bfd_size_type) ((buf) - ehbuf)))	\
    cookie->rel++

  /* FIXME: octets_per_byte.  */
#define GET_RELOC(buf)					\
  ((cookie->rel < cookie->relend			\
    && (cookie->rel->r_offset				\
	== (bfd_size_type) ((buf) - ehbuf)))		\
   ? cookie->rel : NULL)

  buf = ehbuf;
  cie_count = 0;
  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
  while ((bfd_size_type) (buf - ehbuf) != sec->size)
    {
      char *aug;
      bfd_byte *start, *insns, *insns_end;
      bfd_size_type length;
      unsigned int set_loc_count;

      this_inf = sec_info->entry + sec_info->count;
      last_fde = buf;

      /* Read the length of the entry.  */
      REQUIRE (skip_bytes (&buf, ehbuf + sec->size, 4));
      hdr_length = bfd_get_32 (abfd, buf - 4);

      /* The CIE/FDE must be fully contained in this input section.  */
      REQUIRE ((bfd_size_type) (buf - ehbuf) + hdr_length <= sec->size);
      end = buf + hdr_length;

      this_inf->offset = last_fde - ehbuf;
      this_inf->size = 4 + hdr_length;
      this_inf->reloc_index = cookie->rel - cookie->rels;

      if (hdr_length == 0)
	{
	  /* A zero-length CIE should only be found at the end of
	     the section.  */
	  REQUIRE ((bfd_size_type) (buf - ehbuf) == sec->size);
	  ENSURE_NO_RELOCS (buf);
	  sec_info->count++;
	  break;
	}

      REQUIRE (skip_bytes (&buf, end, 4));
      hdr_id = bfd_get_32 (abfd, buf - 4);

      if (hdr_id == 0)
	{
	  unsigned int initial_insn_length;

	  /* CIE  */
	  this_inf->cie = 1;

	  /* Point CIE to one of the section-local cie structures.  */
	  cie = local_cies + cie_count++;

	  cie->cie_inf = this_inf;
	  cie->length = hdr_length;
	  cie->output_sec = sec->output_section;
	  start = buf;
	  REQUIRE (read_byte (&buf, end, &cie->version));

	  /* Cannot handle unknown versions.  */
	  REQUIRE (cie->version == 1
		   || cie->version == 3
		   || cie->version == 4);
	  REQUIRE (strlen ((char *) buf) < sizeof (cie->augmentation));

	  strcpy (cie->augmentation, (char *) buf);
	  buf = (bfd_byte *) strchr ((char *) buf, '\0') + 1;
	  ENSURE_NO_RELOCS (buf);
	  if (buf[0] == 'e' && buf[1] == 'h')
	    {
	      /* GCC < 3.0 .eh_frame CIE */
	      /* We cannot merge "eh" CIEs because __EXCEPTION_TABLE__
		 is private to each CIE, so we don't need it for anything.
		 Just skip it.  */
	      REQUIRE (skip_bytes (&buf, end, ptr_size));
	      SKIP_RELOCS (buf);
	    }
	  if (cie->version >= 4)
	    {
	      REQUIRE (buf + 1 < end);
	      REQUIRE (buf[0] == ptr_size);
	      REQUIRE (buf[1] == 0);
	      buf += 2;
	    }
	  REQUIRE (read_uleb128 (&buf, end, &cie->code_align));
	  REQUIRE (read_sleb128 (&buf, end, &cie->data_align));
	  if (cie->version == 1)
	    {
	      REQUIRE (buf < end);
	      cie->ra_column = *buf++;
	    }
	  else
	    REQUIRE (read_uleb128 (&buf, end, &cie->ra_column));
	  ENSURE_NO_RELOCS (buf);
	  cie->lsda_encoding = DW_EH_PE_omit;
	  cie->fde_encoding = DW_EH_PE_omit;
	  cie->per_encoding = DW_EH_PE_omit;
	  aug = cie->augmentation;
	  if (aug[0] != 'e' || aug[1] != 'h')
	    {
	      if (*aug == 'z')
		{
		  aug++;
		  REQUIRE (read_uleb128 (&buf, end, &cie->augmentation_size));
	  	  ENSURE_NO_RELOCS (buf);
		}

	      while (*aug != '\0')
		switch (*aug++)
		  {
		  case 'L':
		    REQUIRE (read_byte (&buf, end, &cie->lsda_encoding));
		    ENSURE_NO_RELOCS (buf);
		    REQUIRE (get_DW_EH_PE_width (cie->lsda_encoding, ptr_size));
		    break;
		  case 'R':
		    REQUIRE (read_byte (&buf, end, &cie->fde_encoding));
		    ENSURE_NO_RELOCS (buf);
		    REQUIRE (get_DW_EH_PE_width (cie->fde_encoding, ptr_size));
		    break;
		  case 'S':
		    break;
		  case 'P':
		    {
		      int per_width;

		      REQUIRE (read_byte (&buf, end, &cie->per_encoding));
		      per_width = get_DW_EH_PE_width (cie->per_encoding,
						      ptr_size);
		      REQUIRE (per_width);
		      if ((cie->per_encoding & 0x70) == DW_EH_PE_aligned)
			{
			  length = -(buf - ehbuf) & (per_width - 1);
			  REQUIRE (skip_bytes (&buf, end, length));
			}
		      this_inf->u.cie.personality_offset = buf - start;
		      ENSURE_NO_RELOCS (buf);
		      /* Ensure we have a reloc here.  */
		      REQUIRE (GET_RELOC (buf));
		      cie->personality.reloc_index
			= cookie->rel - cookie->rels;
		      /* Cope with MIPS-style composite relocations.  */
		      do
			cookie->rel++;
		      while (GET_RELOC (buf) != NULL);
		      REQUIRE (skip_bytes (&buf, end, per_width));
		    }
		    break;
		  default:
		    /* Unrecognized augmentation. Better bail out.  */
		    goto free_no_table;
		  }
	    }

	  /* For shared libraries, try to get rid of as many RELATIVE relocs
	     as possible.  */
	  if (info->shared
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_relative_eh_frame
		  (abfd, info, sec)))
	    {
	      if ((cie->fde_encoding & 0x70) == DW_EH_PE_absptr)
		this_inf->make_relative = 1;
	      /* If the CIE doesn't already have an 'R' entry, it's fairly
		 easy to add one, provided that there's no aligned data
		 after the augmentation string.  */
	      else if (cie->fde_encoding == DW_EH_PE_omit
		       && (cie->per_encoding & 0x70) != DW_EH_PE_aligned)
		{
		  if (*cie->augmentation == 0)
		    this_inf->add_augmentation_size = 1;
		  this_inf->u.cie.add_fde_encoding = 1;
		  this_inf->make_relative = 1;
		}

	      if ((cie->lsda_encoding & 0x70) == DW_EH_PE_absptr)
		cie->can_make_lsda_relative = 1;
	    }

	  /* If FDE encoding was not specified, it defaults to
	     DW_EH_absptr.  */
	  if (cie->fde_encoding == DW_EH_PE_omit)
	    cie->fde_encoding = DW_EH_PE_absptr;

	  initial_insn_length = end - buf;
	  if (initial_insn_length <= sizeof (cie->initial_instructions))
	    {
	      cie->initial_insn_length = initial_insn_length;
	      memcpy (cie->initial_instructions, buf, initial_insn_length);
	    }
	  insns = buf;
	  buf += initial_insn_length;
	  ENSURE_NO_RELOCS (buf);

	  if (hdr_info->merge_cies)
	    this_inf->u.cie.u.full_cie = cie;
	  this_inf->u.cie.per_encoding_relative
	    = (cie->per_encoding & 0x70) == DW_EH_PE_pcrel;
	}
      else
	{
	  /* Find the corresponding CIE.  */
	  unsigned int cie_offset = this_inf->offset + 4 - hdr_id;
	  for (cie = local_cies; cie < local_cies + cie_count; cie++)
	    if (cie_offset == cie->cie_inf->offset)
	      break;

	  /* Ensure this FDE references one of the CIEs in this input
	     section.  */
	  REQUIRE (cie != local_cies + cie_count);
	  this_inf->u.fde.cie_inf = cie->cie_inf;
	  this_inf->make_relative = cie->cie_inf->make_relative;
	  this_inf->add_augmentation_size
	    = cie->cie_inf->add_augmentation_size;

	  ENSURE_NO_RELOCS (buf);
	  if ((sec->flags & SEC_LINKER_CREATED) == 0 || cookie->rels != NULL)
	    {
	      asection *rsec;

	      REQUIRE (GET_RELOC (buf));

	      /* Chain together the FDEs for each section.  */
	      rsec = _bfd_elf_gc_mark_rsec (info, sec, gc_mark_hook, cookie);
	      /* RSEC will be NULL if FDE was cleared out as it was belonging to
		 a discarded SHT_GROUP.  */
	      if (rsec)
		{
		  REQUIRE (rsec->owner == abfd);
		  this_inf->u.fde.next_for_section = elf_fde_list (rsec);
		  elf_fde_list (rsec) = this_inf;
		}
	    }

	  /* Skip the initial location and address range.  */
	  start = buf;
	  length = get_DW_EH_PE_width (cie->fde_encoding, ptr_size);
	  REQUIRE (skip_bytes (&buf, end, 2 * length));

	  /* Skip the augmentation size, if present.  */
	  if (cie->augmentation[0] == 'z')
	    REQUIRE (read_uleb128 (&buf, end, &length));
	  else
	    length = 0;

	  /* Of the supported augmentation characters above, only 'L'
	     adds augmentation data to the FDE.  This code would need to
	     be adjusted if any future augmentations do the same thing.  */
	  if (cie->lsda_encoding != DW_EH_PE_omit)
	    {
	      SKIP_RELOCS (buf);
	      if (cie->can_make_lsda_relative && GET_RELOC (buf))
		cie->cie_inf->u.cie.make_lsda_relative = 1;
	      this_inf->lsda_offset = buf - start;
	      /* If there's no 'z' augmentation, we don't know where the
		 CFA insns begin.  Assume no padding.  */
	      if (cie->augmentation[0] != 'z')
		length = end - buf;
	    }

	  /* Skip over the augmentation data.  */
	  REQUIRE (skip_bytes (&buf, end, length));
	  insns = buf;

	  buf = last_fde + 4 + hdr_length;

	  /* For NULL RSEC (cleared FDE belonging to a discarded section)
	     the relocations are commonly cleared.  We do not sanity check if
	     all these relocations are cleared as (1) relocations to
	     .gcc_except_table will remain uncleared (they will get dropped
	     with the drop of this unused FDE) and (2) BFD already safely drops
	     relocations of any type to .eh_frame by
	     elf_section_ignore_discarded_relocs.
	     TODO: The .gcc_except_table entries should be also filtered as
	     .eh_frame entries; or GCC could rather use COMDAT for them.  */
	  SKIP_RELOCS (buf);
	}

      /* Try to interpret the CFA instructions and find the first
	 padding nop.  Shrink this_inf's size so that it doesn't
	 include the padding.  */
      length = get_DW_EH_PE_width (cie->fde_encoding, ptr_size);
      set_loc_count = 0;
      insns_end = skip_non_nops (insns, end, length, &set_loc_count);
      /* If we don't understand the CFA instructions, we can't know
	 what needs to be adjusted there.  */
      if (insns_end == NULL
	  /* For the time being we don't support DW_CFA_set_loc in
	     CIE instructions.  */
	  || (set_loc_count && this_inf->cie))
	goto free_no_table;
      this_inf->size -= end - insns_end;
      if (insns_end != end && this_inf->cie)
	{
	  cie->initial_insn_length -= end - insns_end;
	  cie->length -= end - insns_end;
	}
      if (set_loc_count
	  && ((cie->fde_encoding & 0x70) == DW_EH_PE_pcrel
	      || this_inf->make_relative))
	{
	  unsigned int cnt;
	  bfd_byte *p;

	  this_inf->set_loc = (unsigned int *)
              bfd_malloc ((set_loc_count + 1) * sizeof (unsigned int));
	  REQUIRE (this_inf->set_loc);
	  this_inf->set_loc[0] = set_loc_count;
	  p = insns;
	  cnt = 0;
	  while (p < end)
	    {
	      if (*p == DW_CFA_set_loc)
		this_inf->set_loc[++cnt] = p + 1 - start;
	      REQUIRE (skip_cfa_op (&p, end, length));
	    }
	}

      this_inf->removed = 1;
      this_inf->fde_encoding = cie->fde_encoding;
      this_inf->lsda_encoding = cie->lsda_encoding;
      sec_info->count++;
    }
  BFD_ASSERT (sec_info->count == num_entries);
  BFD_ASSERT (cie_count == num_cies);

  elf_section_data (sec)->sec_info = sec_info;
  sec->sec_info_type = SEC_INFO_TYPE_EH_FRAME;
  if (hdr_info->merge_cies)
    {
      sec_info->cies = local_cies;
      local_cies = NULL;
    }
  goto success;

 free_no_table:
  (*info->callbacks->einfo)
    (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
     abfd, sec);
  hdr_info->table = FALSE;
  if (sec_info)
    free (sec_info);
 success:
  if (ehbuf)
    free (ehbuf);
  if (local_cies)
    free (local_cies);
#undef REQUIRE
}

/* Finish a pass over all .eh_frame sections.  */

void
_bfd_elf_end_eh_frame_parsing (struct bfd_link_info *info)
{
  struct eh_frame_hdr_info *hdr_info;

  hdr_info = &elf_hash_table (info)->eh_info;
  hdr_info->parsed_eh_frames = TRUE;
}

/* Mark all relocations against CIE or FDE ENT, which occurs in
   .eh_frame section SEC.  COOKIE describes the relocations in SEC;
   its "rel" field can be changed freely.  */

static bfd_boolean
mark_entry (struct bfd_link_info *info, asection *sec,
	    struct eh_cie_fde *ent, elf_gc_mark_hook_fn gc_mark_hook,
	    struct elf_reloc_cookie *cookie)
{
  /* FIXME: octets_per_byte.  */
  for (cookie->rel = cookie->rels + ent->reloc_index;
       cookie->rel < cookie->relend
	 && cookie->rel->r_offset < ent->offset + ent->size;
       cookie->rel++)
    if (!_bfd_elf_gc_mark_reloc (info, sec, gc_mark_hook, cookie))
      return FALSE;

  return TRUE;
}

/* Mark all the relocations against FDEs that relate to code in input
   section SEC.  The FDEs belong to .eh_frame section EH_FRAME, whose
   relocations are described by COOKIE.  */

bfd_boolean
_bfd_elf_gc_mark_fdes (struct bfd_link_info *info, asection *sec,
		       asection *eh_frame, elf_gc_mark_hook_fn gc_mark_hook,
		       struct elf_reloc_cookie *cookie)
{
  struct eh_cie_fde *fde, *cie;

  for (fde = elf_fde_list (sec); fde; fde = fde->u.fde.next_for_section)
    {
      if (!mark_entry (info, eh_frame, fde, gc_mark_hook, cookie))
	return FALSE;

      /* At this stage, all cie_inf fields point to local CIEs, so we
	 can use the same cookie to refer to them.  */
      cie = fde->u.fde.cie_inf;
      if (!cie->u.cie.gc_mark)
	{
	  cie->u.cie.gc_mark = 1;
	  if (!mark_entry (info, eh_frame, cie, gc_mark_hook, cookie))
	    return FALSE;
	}
    }
  return TRUE;
}

/* Input section SEC of ABFD is an .eh_frame section that contains the
   CIE described by CIE_INF.  Return a version of CIE_INF that is going
   to be kept in the output, adding CIE_INF to the output if necessary.

   HDR_INFO is the .eh_frame_hdr information and COOKIE describes the
   relocations in REL.  */

static struct eh_cie_fde *
find_merged_cie (bfd *abfd, struct bfd_link_info *info, asection *sec,
		 struct eh_frame_hdr_info *hdr_info,
		 struct elf_reloc_cookie *cookie,
		 struct eh_cie_fde *cie_inf)
{
  unsigned long r_symndx;
  struct cie *cie, *new_cie;
  Elf_Internal_Rela *rel;
  void **loc;

  /* Use CIE_INF if we have already decided to keep it.  */
  if (!cie_inf->removed)
    return cie_inf;

  /* If we have merged CIE_INF with another CIE, use that CIE instead.  */
  if (cie_inf->u.cie.merged)
    return cie_inf->u.cie.u.merged_with;

  cie = cie_inf->u.cie.u.full_cie;

  /* Assume we will need to keep CIE_INF.  */
  cie_inf->removed = 0;
  cie_inf->u.cie.u.sec = sec;

  /* If we are not merging CIEs, use CIE_INF.  */
  if (cie == NULL)
    return cie_inf;

  if (cie->per_encoding != DW_EH_PE_omit)
    {
      bfd_boolean per_binds_local;

      /* Work out the address of personality routine, either as an absolute
	 value or as a symbol.  */
      rel = cookie->rels + cie->personality.reloc_index;
      memset (&cie->personality, 0, sizeof (cie->personality));
#ifdef BFD64
      if (elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64)
	r_symndx = ELF64_R_SYM (rel->r_info);
      else
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= cookie->locsymcount
	  || ELF_ST_BIND (cookie->locsyms[r_symndx].st_info) != STB_LOCAL)
	{
	  struct elf_link_hash_entry *h;

	  r_symndx -= cookie->extsymoff;
	  h = cookie->sym_hashes[r_symndx];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  cie->personality.h = h;
	  per_binds_local = SYMBOL_REFERENCES_LOCAL (info, h);
	}
      else
	{
	  Elf_Internal_Sym *sym;
	  asection *sym_sec;

	  sym = &cookie->locsyms[r_symndx];
	  sym_sec = bfd_section_from_elf_index (abfd, sym->st_shndx);
	  if (sym_sec == NULL)
	    return cie_inf;

	  if (sym_sec->kept_section != NULL)
	    sym_sec = sym_sec->kept_section;
	  if (sym_sec->output_section == NULL)
	    return cie_inf;

	  cie->local_personality = 1;
	  cie->personality.val = (sym->st_value
				  + sym_sec->output_offset
				  + sym_sec->output_section->vma);
	  per_binds_local = TRUE;
	}

      if (per_binds_local
	  && info->shared
	  && (cie->per_encoding & 0x70) == DW_EH_PE_absptr
	  && (get_elf_backend_data (abfd)
	      ->elf_backend_can_make_relative_eh_frame (abfd, info, sec)))
	{
	  cie_inf->u.cie.make_per_encoding_relative = 1;
	  cie_inf->u.cie.per_encoding_relative = 1;
	}
    }

  /* See if we can merge this CIE with an earlier one.  */
  cie->output_sec = sec->output_section;
  cie_compute_hash (cie);
  if (hdr_info->cies == NULL)
    {
      hdr_info->cies = htab_try_create (1, cie_hash, cie_eq, free);
      if (hdr_info->cies == NULL)
	return cie_inf;
    }
  loc = htab_find_slot_with_hash (hdr_info->cies, cie, cie->hash, INSERT);
  if (loc == NULL)
    return cie_inf;

  new_cie = (struct cie *) *loc;
  if (new_cie == NULL)
    {
      /* Keep CIE_INF and record it in the hash table.  */
      new_cie = (struct cie *) malloc (sizeof (struct cie));
      if (new_cie == NULL)
	return cie_inf;

      memcpy (new_cie, cie, sizeof (struct cie));
      *loc = new_cie;
    }
  else
    {
      /* Merge CIE_INF with NEW_CIE->CIE_INF.  */
      cie_inf->removed = 1;
      cie_inf->u.cie.merged = 1;
      cie_inf->u.cie.u.merged_with = new_cie->cie_inf;
      if (cie_inf->u.cie.make_lsda_relative)
	new_cie->cie_inf->u.cie.make_lsda_relative = 1;
    }
  return new_cie->cie_inf;
}

/* This function is called for each input file before the .eh_frame
   section is relocated.  It discards duplicate CIEs and FDEs for discarded
   functions.  The function returns TRUE iff any entries have been
   deleted.  */

bfd_boolean
_bfd_elf_discard_section_eh_frame
   (bfd *abfd, struct bfd_link_info *info, asection *sec,
    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),
    struct elf_reloc_cookie *cookie)
{
  struct eh_cie_fde *ent;
  struct eh_frame_sec_info *sec_info;
  struct eh_frame_hdr_info *hdr_info;
  unsigned int ptr_size, offset;

  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
    return FALSE;

  sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
  if (sec_info == NULL)
    return FALSE;

  ptr_size = (get_elf_backend_data (sec->owner)
	      ->elf_backend_eh_frame_address_size (sec->owner, sec));

  hdr_info = &elf_hash_table (info)->eh_info;
  for (ent = sec_info->entry; ent < sec_info->entry + sec_info->count; ++ent)
    if (ent->size == 4)
      /* There should only be one zero terminator, on the last input
	 file supplying .eh_frame (crtend.o).  Remove any others.  */
      ent->removed = sec->map_head.s != NULL;
    else if (!ent->cie)
      {
	bfd_boolean keep;
	if ((sec->flags & SEC_LINKER_CREATED) != 0 && cookie->rels == NULL)
	  {
	    unsigned int width
	      = get_DW_EH_PE_width (ent->fde_encoding, ptr_size);
	    bfd_vma value
	      = read_value (abfd, sec->contents + ent->offset + 8 + width,
			    width, get_DW_EH_PE_signed (ent->fde_encoding));
	    keep = value != 0;
	  }
	else
	  {
	    cookie->rel = cookie->rels + ent->reloc_index;
	    /* FIXME: octets_per_byte.  */
	    BFD_ASSERT (cookie->rel < cookie->relend
			&& cookie->rel->r_offset == ent->offset + 8);
	    keep = !(*reloc_symbol_deleted_p) (ent->offset + 8, cookie);
	  }
	if (keep)
	  {
	    if (info->shared
		&& (((ent->fde_encoding & 0x70) == DW_EH_PE_absptr
		     && ent->make_relative == 0)
		    || (ent->fde_encoding & 0x70) == DW_EH_PE_aligned))
	      {
		/* If a shared library uses absolute pointers
		   which we cannot turn into PC relative,
		   don't create the binary search table,
		   since it is affected by runtime relocations.  */
		hdr_info->table = FALSE;
		(*info->callbacks->einfo)
		  (_("%P: fde encoding in %B(%A) prevents .eh_frame_hdr"
		     " table being created.\n"), abfd, sec);
	      }
	    ent->removed = 0;
	    hdr_info->fde_count++;
	    ent->u.fde.cie_inf = find_merged_cie (abfd, info, sec, hdr_info,
						  cookie, ent->u.fde.cie_inf);
	  }
      }

  if (sec_info->cies)
    {
      free (sec_info->cies);
      sec_info->cies = NULL;
    }

  offset = 0;
  for (ent = sec_info->entry; ent < sec_info->entry + sec_info->count; ++ent)
    if (!ent->removed)
      {
	ent->new_offset = offset;
	offset += size_of_output_cie_fde (ent, ptr_size);
      }

  sec->rawsize = sec->size;
  sec->size = offset;
  return offset != sec->rawsize;
}

/* This function is called for .eh_frame_hdr section after
   _bfd_elf_discard_section_eh_frame has been called on all .eh_frame
   input sections.  It finalizes the size of .eh_frame_hdr section.  */

bfd_boolean
_bfd_elf_discard_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;
  asection *sec;

  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;

  if (hdr_info->cies != NULL)
    {
      htab_delete (hdr_info->cies);
      hdr_info->cies = NULL;
    }

  sec = hdr_info->hdr_sec;
  if (sec == NULL)
    return FALSE;

  sec->size = EH_FRAME_HDR_SIZE;
  if (hdr_info->table)
    sec->size += 4 + hdr_info->fde_count * 8;

  elf_eh_frame_hdr (abfd) = sec;
  return TRUE;
}

/* Return true if there is at least one non-empty .eh_frame section in
   input files.  Can only be called after ld has mapped input to
   output sections, and before sections are stripped.  */
bfd_boolean
_bfd_elf_eh_frame_present (struct bfd_link_info *info)
{
  asection *eh = bfd_get_section_by_name (info->output_bfd, ".eh_frame");

  if (eh == NULL)
    return FALSE;

  /* Count only sections which have at least a single CIE or FDE.
     There cannot be any CIE or FDE <= 8 bytes.  */
  for (eh = eh->map_head.s; eh != NULL; eh = eh->map_head.s)
    if (eh->size > 8)
      return TRUE;

  return FALSE;
}

/* This function is called from size_dynamic_sections.
   It needs to decide whether .eh_frame_hdr should be output or not,
   because when the dynamic symbol table has been sized it is too late
   to strip sections.  */

bfd_boolean
_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)
{
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;

  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->hdr_sec == NULL)
    return TRUE;

  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section)
      || !info->eh_frame_hdr
      || !_bfd_elf_eh_frame_present (info))
    {
      hdr_info->hdr_sec->flags |= SEC_EXCLUDE;
      hdr_info->hdr_sec = NULL;
      return TRUE;
    }

  hdr_info->table = TRUE;
  return TRUE;
}

/* Adjust an address in the .eh_frame section.  Given OFFSET within
   SEC, this returns the new offset in the adjusted .eh_frame section,
   or -1 if the address refers to a CIE/FDE which has been removed
   or to offset with dynamic relocation which is no longer needed.  */

bfd_vma
_bfd_elf_eh_frame_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  asection *sec,
				  bfd_vma offset)
{
  struct eh_frame_sec_info *sec_info;
  unsigned int lo, hi, mid;

  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
    return offset;
  sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;

  if (offset >= sec->rawsize)
    return offset - sec->rawsize + sec->size;

  lo = 0;
  hi = sec_info->count;
  mid = 0;
  while (lo < hi)
    {
      mid = (lo + hi) / 2;
      if (offset < sec_info->entry[mid].offset)
	hi = mid;
      else if (offset
	       >= sec_info->entry[mid].offset + sec_info->entry[mid].size)
	lo = mid + 1;
      else
	break;
    }

  BFD_ASSERT (lo < hi);

  /* FDE or CIE was removed.  */
  if (sec_info->entry[mid].removed)
    return (bfd_vma) -1;

  /* If converting personality pointers to DW_EH_PE_pcrel, there will be
     no need for run-time relocation against the personality field.  */
  if (sec_info->entry[mid].cie
      && sec_info->entry[mid].u.cie.make_per_encoding_relative
      && offset == (sec_info->entry[mid].offset + 8
		    + sec_info->entry[mid].u.cie.personality_offset))
    return (bfd_vma) -2;

  /* If converting to DW_EH_PE_pcrel, there will be no need for run-time
     relocation against FDE's initial_location field.  */
  if (!sec_info->entry[mid].cie
      && sec_info->entry[mid].make_relative
      && offset == sec_info->entry[mid].offset + 8)
    return (bfd_vma) -2;

  /* If converting LSDA pointers to DW_EH_PE_pcrel, there will be no need
     for run-time relocation against LSDA field.  */
  if (!sec_info->entry[mid].cie
      && sec_info->entry[mid].u.fde.cie_inf->u.cie.make_lsda_relative
      && offset == (sec_info->entry[mid].offset + 8
		    + sec_info->entry[mid].lsda_offset))
    return (bfd_vma) -2;

  /* If converting to DW_EH_PE_pcrel, there will be no need for run-time
     relocation against DW_CFA_set_loc's arguments.  */
  if (sec_info->entry[mid].set_loc
      && sec_info->entry[mid].make_relative
      && (offset >= sec_info->entry[mid].offset + 8
		    + sec_info->entry[mid].set_loc[1]))
    {
      unsigned int cnt;

      for (cnt = 1; cnt <= sec_info->entry[mid].set_loc[0]; cnt++)
	if (offset == sec_info->entry[mid].offset + 8
		      + sec_info->entry[mid].set_loc[cnt])
	  return (bfd_vma) -2;
    }

  /* Any new augmentation bytes go before the first relocation.  */
  return (offset + sec_info->entry[mid].new_offset
	  - sec_info->entry[mid].offset
	  + extra_augmentation_string_bytes (sec_info->entry + mid)
	  + extra_augmentation_data_bytes (sec_info->entry + mid));
}

/* Write out .eh_frame section.  This is called with the relocated
   contents.  */

bfd_boolean
_bfd_elf_write_section_eh_frame (bfd *abfd,
				 struct bfd_link_info *info,
				 asection *sec,
				 bfd_byte *contents)
{
  struct eh_frame_sec_info *sec_info;
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;
  unsigned int ptr_size;
  struct eh_cie_fde *ent;

  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
    /* FIXME: octets_per_byte.  */
    return bfd_set_section_contents (abfd, sec->output_section, contents,
				     sec->output_offset, sec->size);

  ptr_size = (get_elf_backend_data (abfd)
	      ->elf_backend_eh_frame_address_size (abfd, sec));
  BFD_ASSERT (ptr_size != 0);

  sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;

  if (hdr_info->table && hdr_info->array == NULL)
    hdr_info->array = (struct eh_frame_array_ent *)
        bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
  if (hdr_info->array == NULL)
    hdr_info = NULL;

  /* The new offsets can be bigger or smaller than the original offsets.
     We therefore need to make two passes over the section: one backward
     pass to move entries up and one forward pass to move entries down.
     The two passes won't interfere with each other because entries are
     not reordered  */
  for (ent = sec_info->entry + sec_info->count; ent-- != sec_info->entry;)
    if (!ent->removed && ent->new_offset > ent->offset)
      memmove (contents + ent->new_offset, contents + ent->offset, ent->size);

  for (ent = sec_info->entry; ent < sec_info->entry + sec_info->count; ++ent)
    if (!ent->removed && ent->new_offset < ent->offset)
      memmove (contents + ent->new_offset, contents + ent->offset, ent->size);

  for (ent = sec_info->entry; ent < sec_info->entry + sec_info->count; ++ent)
    {
      unsigned char *buf, *end;
      unsigned int new_size;

      if (ent->removed)
	continue;

      if (ent->size == 4)
	{
	  /* Any terminating FDE must be at the end of the section.  */
	  BFD_ASSERT (ent == sec_info->entry + sec_info->count - 1);
	  continue;
	}

      buf = contents + ent->new_offset;
      end = buf + ent->size;
      new_size = size_of_output_cie_fde (ent, ptr_size);

      /* Update the size.  It may be shrinked.  */
      bfd_put_32 (abfd, new_size - 4, buf);

      /* Filling the extra bytes with DW_CFA_nops.  */
      if (new_size != ent->size)
	memset (end, 0, new_size - ent->size);

      if (ent->cie)
	{
	  /* CIE */
	  if (ent->make_relative
	      || ent->u.cie.make_lsda_relative
	      || ent->u.cie.per_encoding_relative)
	    {
	      char *aug;
	      unsigned int action, extra_string, extra_data;
	      unsigned int per_width, per_encoding;

	      /* Need to find 'R' or 'L' augmentation's argument and modify
		 DW_EH_PE_* value.  */
	      action = ((ent->make_relative ? 1 : 0)
			| (ent->u.cie.make_lsda_relative ? 2 : 0)
			| (ent->u.cie.per_encoding_relative ? 4 : 0));
	      extra_string = extra_augmentation_string_bytes (ent);
	      extra_data = extra_augmentation_data_bytes (ent);

	      /* Skip length, id and version.  */
	      buf += 9;
	      aug = (char *) buf;
	      buf += strlen (aug) + 1;
	      skip_leb128 (&buf, end);
	      skip_leb128 (&buf, end);
	      skip_leb128 (&buf, end);
	      if (*aug == 'z')
		{
		  /* The uleb128 will always be a single byte for the kind
		     of augmentation strings that we're prepared to handle.  */
		  *buf++ += extra_data;
		  aug++;
		}

	      /* Make room for the new augmentation string and data bytes.  */
	      memmove (buf + extra_string + extra_data, buf, end - buf);
	      memmove (aug + extra_string, aug, buf - (bfd_byte *) aug);
	      buf += extra_string;
	      end += extra_string + extra_data;

	      if (ent->add_augmentation_size)
		{
		  *aug++ = 'z';
		  *buf++ = extra_data - 1;
		}
	      if (ent->u.cie.add_fde_encoding)
		{
		  BFD_ASSERT (action & 1);
		  *aug++ = 'R';
		  *buf++ = make_pc_relative (DW_EH_PE_absptr, ptr_size);
		  action &= ~1;
		}

	      while (action)
		switch (*aug++)
		  {
		  case 'L':
		    if (action & 2)
		      {
			BFD_ASSERT (*buf == ent->lsda_encoding);
			*buf = make_pc_relative (*buf, ptr_size);
			action &= ~2;
		      }
		    buf++;
		    break;
		  case 'P':
		    if (ent->u.cie.make_per_encoding_relative)
		      *buf = make_pc_relative (*buf, ptr_size);
		    per_encoding = *buf++;
		    per_width = get_DW_EH_PE_width (per_encoding, ptr_size);
		    BFD_ASSERT (per_width != 0);
		    BFD_ASSERT (((per_encoding & 0x70) == DW_EH_PE_pcrel)
				== ent->u.cie.per_encoding_relative);
		    if ((per_encoding & 0x70) == DW_EH_PE_aligned)
		      buf = (contents
			     + ((buf - contents + per_width - 1)
				& ~((bfd_size_type) per_width - 1)));
		    if (action & 4)
		      {
			bfd_vma val;

			val = read_value (abfd, buf, per_width,
					  get_DW_EH_PE_signed (per_encoding));
			if (ent->u.cie.make_per_encoding_relative)
			  val -= (sec->output_section->vma
				  + sec->output_offset
				  + (buf - contents));
			else
			  {
			    val += (bfd_vma) ent->offset - ent->new_offset;
			    val -= extra_string + extra_data;
			  }
			write_value (abfd, buf, val, per_width);
			action &= ~4;
		      }
		    buf += per_width;
		    break;
		  case 'R':
		    if (action & 1)
		      {
			BFD_ASSERT (*buf == ent->fde_encoding);
			*buf = make_pc_relative (*buf, ptr_size);
			action &= ~1;
		      }
		    buf++;
		    break;
		  case 'S':
		    break;
		  default:
		    BFD_FAIL ();
		  }
	    }
	}
      else
	{
	  /* FDE */
	  bfd_vma value, address;
	  unsigned int width;
	  bfd_byte *start;
	  struct eh_cie_fde *cie;

	  /* Skip length.  */
	  cie = ent->u.fde.cie_inf;
	  buf += 4;
	  value = ((ent->new_offset + sec->output_offset + 4)
		   - (cie->new_offset + cie->u.cie.u.sec->output_offset));
	  bfd_put_32 (abfd, value, buf);
	  buf += 4;
	  width = get_DW_EH_PE_width (ent->fde_encoding, ptr_size);
	  value = read_value (abfd, buf, width,
			      get_DW_EH_PE_signed (ent->fde_encoding));
	  address = value;
	  if (value)
	    {
	      switch (ent->fde_encoding & 0x70)
		{
		case DW_EH_PE_textrel:
		  BFD_ASSERT (hdr_info == NULL);
		  break;
		case DW_EH_PE_datarel:
		  {
		    switch (abfd->arch_info->arch)
		      {
		      case bfd_arch_ia64:
			BFD_ASSERT (elf_gp (abfd) != 0);
			address += elf_gp (abfd);
			break;
		      default:
			(*info->callbacks->einfo)
			  (_("%P: DW_EH_PE_datarel unspecified"
			     " for this architecture.\n"));
			/* Fall thru */
		      case bfd_arch_frv:
		      case bfd_arch_i386:
			BFD_ASSERT (htab->hgot != NULL
				    && ((htab->hgot->root.type
					 == bfd_link_hash_defined)
					|| (htab->hgot->root.type
					    == bfd_link_hash_defweak)));
			address
			  += (htab->hgot->root.u.def.value
			      + htab->hgot->root.u.def.section->output_offset
			      + (htab->hgot->root.u.def.section->output_section
				 ->vma));
			break;
		      }
		  }
		  break;
		case DW_EH_PE_pcrel:
		  value += (bfd_vma) ent->offset - ent->new_offset;
		  address += (sec->output_section->vma
			      + sec->output_offset
			      + ent->offset + 8);
		  break;
		}
	      if (ent->make_relative)
		value -= (sec->output_section->vma
			  + sec->output_offset
			  + ent->new_offset + 8);
	      write_value (abfd, buf, value, width);
	    }

	  start = buf;

	  if (hdr_info)
	    {
	      /* The address calculation may overflow, giving us a
		 value greater than 4G on a 32-bit target when
		 dwarf_vma is 64-bit.  */
	      if (sizeof (address) > 4 && ptr_size == 4)
		address &= 0xffffffff;
	      hdr_info->array[hdr_info->array_count].initial_loc = address;
	      hdr_info->array[hdr_info->array_count++].fde
		= (sec->output_section->vma
		   + sec->output_offset
		   + ent->new_offset);
	    }

	  if ((ent->lsda_encoding & 0x70) == DW_EH_PE_pcrel
	      || cie->u.cie.make_lsda_relative)
	    {
	      buf += ent->lsda_offset;
	      width = get_DW_EH_PE_width (ent->lsda_encoding, ptr_size);
	      value = read_value (abfd, buf, width,
				  get_DW_EH_PE_signed (ent->lsda_encoding));
	      if (value)
		{
		  if ((ent->lsda_encoding & 0x70) == DW_EH_PE_pcrel)
		    value += (bfd_vma) ent->offset - ent->new_offset;
		  else if (cie->u.cie.make_lsda_relative)
		    value -= (sec->output_section->vma
			      + sec->output_offset
			      + ent->new_offset + 8 + ent->lsda_offset);
		  write_value (abfd, buf, value, width);
		}
	    }
	  else if (ent->add_augmentation_size)
	    {
	      /* Skip the PC and length and insert a zero byte for the
		 augmentation size.  */
	      buf += width * 2;
	      memmove (buf + 1, buf, end - buf);
	      *buf = 0;
	    }

	  if (ent->set_loc)
	    {
	      /* Adjust DW_CFA_set_loc.  */
	      unsigned int cnt;
	      bfd_vma new_offset;

	      width = get_DW_EH_PE_width (ent->fde_encoding, ptr_size);
	      new_offset = ent->new_offset + 8
			   + extra_augmentation_string_bytes (ent)
			   + extra_augmentation_data_bytes (ent);

	      for (cnt = 1; cnt <= ent->set_loc[0]; cnt++)
		{
		  buf = start + ent->set_loc[cnt];

		  value = read_value (abfd, buf, width,
				      get_DW_EH_PE_signed (ent->fde_encoding));
		  if (!value)
		    continue;

		  if ((ent->fde_encoding & 0x70) == DW_EH_PE_pcrel)
		    value += (bfd_vma) ent->offset + 8 - new_offset;
		  if (ent->make_relative)
		    value -= (sec->output_section->vma
			      + sec->output_offset
			      + new_offset + ent->set_loc[cnt]);
		  write_value (abfd, buf, value, width);
		}
	    }
	}
    }

  /* We don't align the section to its section alignment since the
     runtime library only expects all CIE/FDE records aligned at
     the pointer size. _bfd_elf_discard_section_eh_frame should
     have padded CIE/FDE records to multiple of pointer size with
     size_of_output_cie_fde.  */
  if ((sec->size % ptr_size) != 0)
    abort ();

  /* FIXME: octets_per_byte.  */
  return bfd_set_section_contents (abfd, sec->output_section,
				   contents, (file_ptr) sec->output_offset,
				   sec->size);
}

/* Helper function used to sort .eh_frame_hdr search table by increasing
   VMA of FDE initial location.  */

static int
vma_compare (const void *a, const void *b)
{
  const struct eh_frame_array_ent *p = (const struct eh_frame_array_ent *) a;
  const struct eh_frame_array_ent *q = (const struct eh_frame_array_ent *) b;
  if (p->initial_loc > q->initial_loc)
    return 1;
  if (p->initial_loc < q->initial_loc)
    return -1;
  return 0;
}

/* Write out .eh_frame_hdr section.  This must be called after
   _bfd_elf_write_section_eh_frame has been called on all input
   .eh_frame sections.
   .eh_frame_hdr format:
   ubyte version		(currently 1)
   ubyte eh_frame_ptr_enc  	(DW_EH_PE_* encoding of pointer to start of
				 .eh_frame section)
   ubyte fde_count_enc		(DW_EH_PE_* encoding of total FDE count
				 number (or DW_EH_PE_omit if there is no
				 binary search table computed))
   ubyte table_enc		(DW_EH_PE_* encoding of binary search table,
				 or DW_EH_PE_omit if not present.
				 DW_EH_PE_datarel is using address of
				 .eh_frame_hdr section start as base)
   [encoded] eh_frame_ptr	(pointer to start of .eh_frame section)
   optionally followed by:
   [encoded] fde_count		(total number of FDEs in .eh_frame section)
   fde_count x [encoded] initial_loc, fde
				(array of encoded pairs containing
				 FDE initial_location field and FDE address,
				 sorted by increasing initial_loc).  */

bfd_boolean
_bfd_elf_write_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;
  asection *sec;
  bfd_boolean retval = TRUE;

  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  sec = hdr_info->hdr_sec;

  if (info->eh_frame_hdr && sec != NULL)
    {
      bfd_byte *contents;
      asection *eh_frame_sec;
      bfd_size_type size;
      bfd_vma encoded_eh_frame;

      size = EH_FRAME_HDR_SIZE;
      if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)
	size += 4 + hdr_info->fde_count * 8;
      contents = (bfd_byte *) bfd_malloc (size);
      if (contents == NULL)
	return FALSE;

      eh_frame_sec = bfd_get_section_by_name (abfd, ".eh_frame");
      if (eh_frame_sec == NULL)
	{
	  free (contents);
	  return FALSE;
	}

      memset (contents, 0, EH_FRAME_HDR_SIZE);
      /* Version.  */
      contents[0] = 1;
      /* .eh_frame offset.  */
      contents[1] = get_elf_backend_data (abfd)->elf_backend_encode_eh_address
	(abfd, info, eh_frame_sec, 0, sec, 4, &encoded_eh_frame);

      if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)
	{
	  /* FDE count encoding.  */
	  contents[2] = DW_EH_PE_udata4;
	  /* Search table encoding.  */
	  contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4;
	}
      else
	{
	  contents[2] = DW_EH_PE_omit;
	  contents[3] = DW_EH_PE_omit;
	}
      bfd_put_32 (abfd, encoded_eh_frame, contents + 4);

      if (contents[2] != DW_EH_PE_omit)
	{
	  unsigned int i;

	  bfd_put_32 (abfd, hdr_info->fde_count, contents + EH_FRAME_HDR_SIZE);
	  qsort (hdr_info->array, hdr_info->fde_count,
		 sizeof (*hdr_info->array), vma_compare);
	  for (i = 0; i < hdr_info->fde_count; i++)
	    {
	      bfd_put_32 (abfd,
			  hdr_info->array[i].initial_loc
			  - sec->output_section->vma,
			  contents + EH_FRAME_HDR_SIZE + i * 8 + 4);
	      bfd_put_32 (abfd,
			  hdr_info->array[i].fde - sec->output_section->vma,
			  contents + EH_FRAME_HDR_SIZE + i * 8 + 8);
	    }
	}

      /* FIXME: octets_per_byte.  */
      retval = bfd_set_section_contents (abfd, sec->output_section, contents,
					 (file_ptr) sec->output_offset,
					 sec->size);
      free (contents);
    }
  if (hdr_info->array != NULL)
    free (hdr_info->array);
  return retval;
}

/* Return the width of FDE addresses.  This is the default implementation.  */

unsigned int
_bfd_elf_eh_frame_address_size (bfd *abfd, asection *sec ATTRIBUTE_UNUSED)
{
  return elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64 ? 8 : 4;
}

/* Decide whether we can use a PC-relative encoding within the given
   EH frame section.  This is the default implementation.  */

bfd_boolean
_bfd_elf_can_make_relative (bfd *input_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Select an encoding for the given address.  Preference is given to
   PC-relative addressing modes.  */

bfd_byte
_bfd_elf_encode_eh_address (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *osec, bfd_vma offset,
			    asection *loc_sec, bfd_vma loc_offset,
			    bfd_vma *encoded)
{
  *encoded = osec->vma + offset -
    (loc_sec->output_section->vma + loc_sec->output_offset + loc_offset);
  return DW_EH_PE_pcrel | DW_EH_PE_sdata4;
}
@


1.91
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d1246 1
a1246 1
  elf_tdata (abfd)->eh_frame_hdr = sec;
@


1.90
log
@	PR ld/13909
	* elf-eh-frame.c (_bfd_elf_eh_frame_present): New function.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Use it here.
	* elf-bfd.h (_bfd_elf_eh_frame_present): Declare.
	* elflink.c (bfd_elf_size_dynamic_sections): Let the backend
	size dynamic sections before stripping eh_frame_hdr.
	(bfd_elf_gc_sections): Handle multiple .eh_frame sections.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Drop glink_eh_frame
	if no other .eh_frame sections exist.
	* elf64-ppc.c (ppc64_elf_size_stubs): Likewise.
	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_i386_size_dynamic_sections): ..do it here instead.  Don't
	specially keep sgotplt, iplt, tgotplt, sdynbss for symbols.
	(elf_i386_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_x86_64_size_dynamic_sections): ..do it here instead.
	(elf_x86_64_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
@
text
@d1773 1
a1773 5
  bfd_byte *contents;
  asection *eh_frame_sec;
  bfd_size_type size;
  bfd_boolean retval;
  bfd_vma encoded_eh_frame;
a1777 2
  if (sec == NULL)
    return TRUE;
d1779 1
a1779 9
  size = EH_FRAME_HDR_SIZE;
  if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)
    size += 4 + hdr_info->fde_count * 8;
  contents = (bfd_byte *) bfd_malloc (size);
  if (contents == NULL)
    return FALSE;

  eh_frame_sec = bfd_get_section_by_name (abfd, ".eh_frame");
  if (eh_frame_sec == NULL)
d1781 11
a1791 3
      free (contents);
      return FALSE;
    }
d1793 6
a1798 5
  memset (contents, 0, EH_FRAME_HDR_SIZE);
  contents[0] = 1;				/* Version.  */
  contents[1] = get_elf_backend_data (abfd)->elf_backend_encode_eh_address
    (abfd, info, eh_frame_sec, 0, sec, 4,
     &encoded_eh_frame);			/* .eh_frame offset.  */
d1800 6
a1805 11
  if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)
    {
      contents[2] = DW_EH_PE_udata4;		/* FDE count encoding.  */
      contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4; /* Search table enc.  */
    }
  else
    {
      contents[2] = DW_EH_PE_omit;
      contents[3] = DW_EH_PE_omit;
    }
  bfd_put_32 (abfd, encoded_eh_frame, contents + 4);
d1807 13
a1819 3
  if (contents[2] != DW_EH_PE_omit)
    {
      unsigned int i;
d1821 1
a1821 4
      bfd_put_32 (abfd, hdr_info->fde_count, contents + EH_FRAME_HDR_SIZE);
      qsort (hdr_info->array, hdr_info->fde_count, sizeof (*hdr_info->array),
	     vma_compare);
      for (i = 0; i < hdr_info->fde_count; i++)
d1823 15
a1837 7
	  bfd_put_32 (abfd,
		      hdr_info->array[i].initial_loc
		      - sec->output_section->vma,
		      contents + EH_FRAME_HDR_SIZE + i * 8 + 4);
	  bfd_put_32 (abfd,
		      hdr_info->array[i].fde - sec->output_section->vma,
		      contents + EH_FRAME_HDR_SIZE + i * 8 + 8);
d1839 6
d1846 2
a1847 6

  /* FIXME: octets_per_byte.  */
  retval = bfd_set_section_contents (abfd, sec->output_section,
				     contents, (file_ptr) sec->output_offset,
				     sec->size);
  free (contents);
@


1.89
log
@	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Handle
        BFDs with multiple .eh_frame sections.
@
text
@d1250 20
a1277 2
  asection *o;
  bfd *abfd;
d1286 3
a1288 22
  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section))
    {
      hdr_info->hdr_sec = NULL;
      return TRUE;
    }

  abfd = NULL;
  if (info->eh_frame_hdr)
    for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
      {
	/* Count only sections which have at least a single CIE or FDE.
	   There cannot be any CIE or FDE <= 8 bytes.  */
	o = bfd_get_section_by_name (abfd, ".eh_frame");
	while (o != NULL
	       && (o->size <= 8
		   || bfd_is_abs_section (o->output_section)))
	  o = bfd_get_next_section_by_name (o);
	if (o != NULL)
	  break;
      }

  if (abfd == NULL)
@


1.88
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1281 5
a1285 1
	if (o && o->size > 8 && !bfd_is_abs_section (o->output_section))
@


1.87
log
@	PR ld/12570
include/
	* bfdlink.h (struct bfd_link_info): Add no_ld_generated_unwind_info
	option.
ld/
	* emultempl/elf32.em (OPTION_LD_GENERATED_UNWIND_INFO,
	OPTION_NO_LD_GENERATED_UNWIND_INFO): Define.
	(gld${EMULATION_NAME}_handle_option): Handle
	--ld-generated-unwind-info and --no-ld-generated-unwind-info.
	* ld.texinfo (--ld-generated-unwind-info,
	--no-ld-generated-unwind-info): Document.
bfd/
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Allow no relocations
	at all for linker created .eh_frame sections.
	(_bfd_elf_discard_section_eh_frame): Handle linker created
	.eh_frame sections with no relocations.
	* elf64-x86-64.c: Include dwarf2.h.
	(elf_x86_64_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_x86_64_link_hash_table): Add plt_eh_frame field.
	(elf_x86_64_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_x86_64_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_x86_64_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
	* elf32-i386.c: Include dwarf2.h.
	(elf_i386_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_i386_link_hash_table): Add plt_eh_frame field.
	(elf_i386_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_i386_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_i386_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
ld/testsuite/
	* ld-x86-64/x86-64.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-x86-64/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsdesc.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsdesc.pd: Likewise.
	* ld-x86-64/tlsdesc.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsgdesc.rd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.
	* ld-x86-64/tlsgdesc.dd: Add --no-ld-generated-unwind-info to ld
	comment.  Adjust.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsgd6.dd: Adjust.
	* ld-x86-64/tlsgd5.dd: Likewise.
	* ld-i386/i386.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-i386/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment..
	* ld-i386/tlsdesc.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlsdesc.sd: Likewise.
	* ld-i386/tlsgdesc.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-i386/tlsdesc.rd: Likewise.
	* ld-i386/tlsbindesc.rd: Likewise.
	* ld-i386/tlsbindesc.sd: Likewise.
	* ld-i386/tlsbin.td: Likewise.
	* ld-i386/tlsdesc.td: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsbindesc.dd: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsgdesc.rd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsbindesc.td: Likewise.
	* ld-i386/tlspic.td: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
@
text
@d2 2
a3 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d494 1
a494 1
      || sec->sec_info_type != ELF_INFO_TYPE_NONE)
d907 1
a907 1
  sec->sec_info_type = ELF_INFO_TYPE_EH_FRAME;
d1140 1
a1140 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d1310 1
a1310 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d1398 1
a1398 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
@


1.87.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d494 1
a494 1
      || sec->sec_info_type != SEC_INFO_TYPE_NONE)
d907 1
a907 1
  sec->sec_info_type = SEC_INFO_TYPE_EH_FRAME;
d1140 1
a1140 1
  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
d1310 1
a1310 1
  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
d1398 1
a1398 1
  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
@


1.86
log
@	PR ld/12887
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Check sec_info_type
	before doing anything.
	(_bfd_elf_discard_section_eh_frame): Likewise.
@
text
@a780 2
	  asection *rsec;

d796 3
a798 1
	  REQUIRE (GET_RELOC (buf));
d800 12
a811 9
	  /* Chain together the FDEs for each section.  */
	  rsec = _bfd_elf_gc_mark_rsec (info, sec, gc_mark_hook, cookie);
	  /* RSEC will be NULL if FDE was cleared out as it was belonging to
	     a discarded SHT_GROUP.  */
	  if (rsec)
	    {
	      REQUIRE (rsec->owner == abfd);
	      this_inf->u.fde.next_for_section = elf_fde_list (rsec);
	      elf_fde_list (rsec) = this_inf;
d1147 3
d1158 19
a1176 5
	cookie->rel = cookie->rels + ent->reloc_index;
	/* FIXME: octets_per_byte.  */
	BFD_ASSERT (cookie->rel < cookie->relend
		    && cookie->rel->r_offset == ent->offset + 8);
	if (!(*reloc_symbol_deleted_p) (ent->offset + 8, cookie))
a1204 2
  ptr_size = (get_elf_backend_data (sec->owner)
	      ->elf_backend_eh_frame_address_size (sec->owner, sec));
@


1.85
log
@	PR ld/12253
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Correct
	DW_EH_PE_datarel handling.  Truncate .eh_frame_hdr address to
	ptr_size.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d493 2
a494 1
  if (sec->size == 0)
d1137 3
@


1.84
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d1575 25
a1599 4
		    asection *got = bfd_get_section_by_name (abfd, ".got");

		    BFD_ASSERT (got != NULL);
		    address += got->vma;
d1620 5
@


1.84.4.1
log
@backport from mainline
@
text
@d1575 4
a1578 25
		    switch (abfd->arch_info->arch)
		      {
		      case bfd_arch_ia64:
			BFD_ASSERT (elf_gp (abfd) != 0);
			address += elf_gp (abfd);
			break;
		      default:
			(*info->callbacks->einfo)
			  (_("%P: DW_EH_PE_datarel unspecified"
			     " for this architecture.\n"));
			/* Fall thru */
		      case bfd_arch_frv:
		      case bfd_arch_i386:
			BFD_ASSERT (htab->hgot != NULL
				    && ((htab->hgot->root.type
					 == bfd_link_hash_defined)
					|| (htab->hgot->root.type
					    == bfd_link_hash_defweak)));
			address
			  += (htab->hgot->root.u.def.value
			      + htab->hgot->root.u.def.section->output_offset
			      + (htab->hgot->root.u.def.section->output_section
				 ->vma));
			break;
		      }
a1598 5
	      /* The address calculation may overflow, giving us a
		 value greater than 4G on a 32-bit target when
		 dwarf_vma is 64-bit.  */
	      if (sizeof (address) > 4 && ptr_size == 4)
		address &= 0xffffffff;
@


1.83
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Handle CIE version 4
	provided that it has the expected address size and zero segment
	length.
binutils/
	* dwarf.c (struct Frame_Chunk): Add ptr_size and segment_size
	fields.
	(display_debug_frames): Handle CIE version 4.
@
text
@d1281 1
a1281 1
				  struct bfd_link_info *info,
a1285 2
  struct elf_link_hash_table *htab;
  struct eh_frame_hdr_info *hdr_info;
a1294 3
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;

@


1.82
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d639 3
a641 1
	  REQUIRE (cie->version == 1 || cie->version == 3);
d656 7
@


1.81
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Extend previous
	patch to handle the new personality relaxation.

ld/testsuite/
	* ld-mips-elf/eh-frame5.d: Expect PC-relative encodings
	to include DW_EH_PE_sdata4.
@
text
@d1632 1
a1632 1
	      unsigned int cnt, width;
a1641 1
		  bfd_vma value;
@


1.80
log
@bfd/
	* elf-eh-frame.c (make_pc_relative): New function.
	(_bfd_elf_write_section_eh_frame): Use it.

ld/testsuite/
	* ld-mips-elf/eh-frame1-n32.d: Expect PC-relative encodings
	to include DW_EH_PE_sdata4.
	* ld-mips-elf/eh-frame2-n32.d: Likewise.
	* ld-mips-elf/eh-frame1-n64.d: Expect PC-relative encodings
	to include DW_EH_PE_sdata8.
	* ld-mips-elf/eh-frame2-n64.d: Likewise.
@
text
@d1497 1
a1497 1
		      *buf |= DW_EH_PE_pcrel;
@


1.79
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add personality_offset and
	make_per_encoding_relative to the CIE structure.  Add a padding field.
	* elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Use 0x70
	rather than 0xf0 when masking out the base address encoding
	Record the offset of personality data from the start of the CIE.
	Remove a repeated elf_backend_can_make_relative_eh_frame check.
	(find_merged_cie): Take an info argument.  If the personality
	binds locally, try converting an absolute personality into
	a local one.
	(_bfd_elf_discard_section_eh_frame): Use 0x70 rather than 0xf0
	when masking out the base address encoding.  Update the call to
	find_merged_cie.
	(_bfd_elf_eh_frame_section_offset): Discard relocations against
	the personality data if we are converting into PC-relative form.
	(_bfd_elf_write_section_eh_frame): Use 0x70 rather than 0xf0
	when masking out the base address encoding.  Handle
	make_per_encoding_relative.

ld/testsuite/
	* ld-mips-elf/eh-frame5.s, ld-mips-elf/eh-frame5.ld,
	ld-mips-elf/eh-frame5.d: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@d426 22
d1479 1
a1479 1
		  *buf++ = DW_EH_PE_pcrel;
d1490 1
a1490 1
			*buf |= DW_EH_PE_pcrel;
d1531 1
a1531 1
			*buf |= DW_EH_PE_pcrel;
@


1.78
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d678 1
a678 1
		      if ((cie->per_encoding & 0xf0) == DW_EH_PE_aligned)
d683 1
d709 1
a709 1
	      if ((cie->fde_encoding & 0xf0) == DW_EH_PE_absptr)
d715 1
a715 1
		       && (cie->per_encoding & 0xf0) != DW_EH_PE_aligned)
d722 3
a726 7
	  if (info->shared
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_lsda_relative_eh_frame
		  (abfd, info, sec))
	      && (cie->lsda_encoding & 0xf0) == DW_EH_PE_absptr)
	    cie->can_make_lsda_relative = 1;

d843 1
a843 1
	  && ((cie->fde_encoding & 0xf0) == DW_EH_PE_pcrel
d963 1
a963 1
find_merged_cie (bfd *abfd, asection *sec,
d993 2
d1018 1
d1039 11
d1124 1
a1124 1
		&& (((ent->fde_encoding & 0xf0) == DW_EH_PE_absptr
d1126 1
a1126 1
		    || (ent->fde_encoding & 0xf0) == DW_EH_PE_aligned))
d1139 2
a1140 2
	    ent->u.fde.cie_inf = find_merged_cie (abfd, sec, hdr_info, cookie,
						  ent->u.fde.cie_inf);
d1290 8
d1474 2
d1481 1
a1481 1
		    if ((per_encoding & 0xf0) == DW_EH_PE_aligned)
d1491 9
a1499 2
			val += (bfd_vma) ent->offset - ent->new_offset;
			val -= extra_string + extra_data;
d1542 1
a1542 1
	      switch (ent->fde_encoding & 0xf0)
a1543 1
		case DW_EH_PE_indirect:
d1580 1
a1580 1
	  if ((ent->lsda_encoding & 0xf0) == DW_EH_PE_pcrel
d1589 1
a1589 1
		  if ((ent->lsda_encoding & 0xf0) == DW_EH_PE_pcrel)
d1628 1
a1628 1
		  if ((ent->fde_encoding & 0xf0) == DW_EH_PE_pcrel)
@


1.77
log
@update copyright dates
@
text
@d218 2
a219 2
  const struct cie *c1 = e1;
  const struct cie *c2 = e2;
d249 1
a249 1
  const struct cie *c = e;
d532 3
a534 2
  sec_info = bfd_zmalloc (sizeof (struct eh_frame_sec_info)
			  + (num_entries - 1) * sizeof (struct eh_cie_fde));
d538 1
a538 1
  local_cies = bfd_zmalloc (num_cies * sizeof (*local_cies));
d852 2
a853 2
	  this_inf->set_loc = bfd_malloc ((set_loc_count + 1)
					  * sizeof (unsigned int));
d1059 1
a1059 1
      new_cie = malloc (sizeof (struct cie));
d1250 1
a1250 1
  sec_info = elf_section_data (sec)->sec_info;
d1340 1
a1340 1
  sec_info = elf_section_data (sec)->sec_info;
d1345 2
a1346 2
    hdr_info->array
      = bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
d1633 2
a1634 2
  const struct eh_frame_array_ent *p = a;
  const struct eh_frame_array_ent *q = b;
d1685 1
a1685 1
  contents = bfd_malloc (size);
@


1.77.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d218 2
a219 2
  const struct cie *c1 = (const struct cie *) e1;
  const struct cie *c2 = (const struct cie *) e2;
d249 1
a249 1
  const struct cie *c = (const struct cie *) e;
d532 2
a533 3
  sec_info = (struct eh_frame_sec_info *)
      bfd_zmalloc (sizeof (struct eh_frame_sec_info)
                   + (num_entries - 1) * sizeof (struct eh_cie_fde));
d537 1
a537 1
  local_cies = (struct cie *) bfd_zmalloc (num_cies * sizeof (*local_cies));
d851 2
a852 2
	  this_inf->set_loc = (unsigned int *)
              bfd_malloc ((set_loc_count + 1) * sizeof (unsigned int));
d1058 1
a1058 1
      new_cie = (struct cie *) malloc (sizeof (struct cie));
d1249 1
a1249 1
  sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
d1339 1
a1339 1
  sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
d1344 2
a1345 2
    hdr_info->array = (struct eh_frame_array_ent *)
        bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
d1632 2
a1633 2
  const struct eh_frame_array_ent *p = (const struct eh_frame_array_ent *) a;
  const struct eh_frame_array_ent *q = (const struct eh_frame_array_ent *) b;
d1684 1
a1684 1
  contents = (bfd_byte *) bfd_malloc (size);
@


1.76
log
@	* elflink.c: Add FIXMEs for some places that require octets_per_byte
	adjustments.
	* elf-eh-frame.c: Likewise.
	* merge.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.75
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d540 1
d547 1
d554 1
d917 1
d1106 1
d1331 1
d1620 1
d1732 1
@


1.74
log
@bfd/
	* elf-eh-frame.c (REQUIRE_CLEARED_RELOCS) Remove.
	(_bfd_elf_parse_eh_frame): Do not check relocations for removed FDEs.

ld/testsuite/
	* ld-elf/eh-group2.s: New `.cfi_lsda' referencing `.gcc_except_table'.
	* ld-elf/eh-group.exp: New test and conditional defininiton of `ELF64'.
@
text
@d27 1
a27 1
#include "elf/dwarf2.h"
@


1.73
log
@bfd/
	PR 6893 - Do not consider FDEs for discarded sections as invalid.
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): New REQUIRE_CLEARED_RELOCS.
	Consider FDEs with cleared relocations as valid and ignorable.

ld/testsuite/
	* ld-elf/eh-group.exp, ld-elf/eh-group1.s, ld-elf/eh-group2.s: New test.

binutils/
	Suppress warnings on NONE relocations to discarded sections.
	* readelf.c (is_none_reloc): New function.
	(debug_apply_relocations): Ignore is_none_reloc() relocations.
@
text
@a551 10
#define REQUIRE_CLEARED_RELOCS(buf)			\
  while (cookie->rel < cookie->relend			\
	 && (cookie->rel->r_offset			\
	     < (bfd_size_type) ((buf) - ehbuf)))	\
    {							\
      REQUIRE (cookie->rel->r_info == 0);		\
      REQUIRE (cookie->rel->r_addend == 0);		\
      cookie->rel++;					\
    }

d810 10
a819 10
	  /* Cleared FDE?  The instructions will not be cleared but verify all
	     the relocation entries for them are cleared.  */
	  if (rsec == NULL)
	    {
	      REQUIRE_CLEARED_RELOCS (buf);
	    }
	  else
	    {
	      SKIP_RELOCS (buf);
	    }
@


1.72
log
@(_bfd_elf_write_section_eh_frame): Do proper
extension when calculating difference of offsets.
@
text
@d552 10
d779 8
a786 3
	  REQUIRE (rsec && rsec->owner == abfd);
	  this_inf->u.fde.next_for_section = elf_fde_list (rsec);
	  elf_fde_list (rsec) = this_inf;
d819 11
a829 1
	  SKIP_RELOCS (buf);
@


1.72.2.1
log
@bfd/
	PR 6893 - Do not consider FDEs for discarded sections as invalid.
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): New REQUIRE_CLEARED_RELOCS.
	Consider FDEs with cleared relocations as valid and ignorable.

ld/testsuite/
	* ld-elf/eh-group.exp, ld-elf/eh-group1.s, ld-elf/eh-group2.s: New test.

binutils/
	Suppress warnings on NONE relocations to discarded sections.
	* readelf.c (is_none_reloc): New function.
	(debug_apply_relocations): Ignore is_none_reloc() relocations.
@
text
@a551 10
#define REQUIRE_CLEARED_RELOCS(buf)			\
  while (cookie->rel < cookie->relend			\
	 && (cookie->rel->r_offset			\
	     < (bfd_size_type) ((buf) - ehbuf)))	\
    {							\
      REQUIRE (cookie->rel->r_info == 0);		\
      REQUIRE (cookie->rel->r_addend == 0);		\
      cookie->rel++;					\
    }

d769 3
a771 8
	  /* RSEC will be NULL if FDE was cleared out as it was belonging to
	     a discarded SHT_GROUP.  */
	  if (rsec)
	    {
	      REQUIRE (rsec->owner == abfd);
	      this_inf->u.fde.next_for_section = elf_fde_list (rsec);
	      elf_fde_list (rsec) = this_inf;
	    }
d804 1
a804 11

	  /* Cleared FDE?  The instructions will not be cleared but verify all
	     the relocation entries for them are cleared.  */
	  if (rsec == NULL)
	    {
	      REQUIRE_CLEARED_RELOCS (buf);
	    }
	  else
	    {
	      SKIP_RELOCS (buf);
	    }
@


1.72.2.2
log
@backport 2009-02-01  Jan Kratochvil  <jan.kratochvil@@redhat.com>
@
text
@d552 10
d820 10
a829 10
	  /* For NULL RSEC (cleared FDE belonging to a discarded section)
	     the relocations are commonly cleared.  We do not sanity check if
	     all these relocations are cleared as (1) relocations to
	     .gcc_except_table will remain uncleared (they will get dropped
	     with the drop of this unused FDE) and (2) BFD already safely drops
	     relocations of any type to .eh_frame by
	     elf_section_ignore_discarded_relocs.
	     TODO: The .gcc_except_table entries should be also filtered as
	     .eh_frame entries; or GCC could rather use COMDAT for them.  */
	  SKIP_RELOCS (buf);
@


1.71
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Drop
	unwanted zero terminators.
@
text
@d1448 1
a1448 1
			val += ent->offset - ent->new_offset;
d1507 1
a1507 1
		  value += ent->offset - ent->new_offset;
d1541 1
a1541 1
		    value += ent->offset - ent->new_offset;
d1580 1
a1580 1
		    value += ent->offset + 8 - new_offset;
@


1.70
log
@bfd/
	PR ld/5526
	* elf-bfd.h (eh_cie_fde): Add u.cie.u.full_cie and u.cie.merged
	fields.  Rename u.cie.u.merged to u.cie.u.merged_with.
	(eh_frame_sec_info): Add a cies field.
	(eh_frame_hdr_info): Add a merge_cies field.
	* elf-eh-frame.c (cie): Add a reloc_index member to the personality
	union.
	(_bfd_elf_begin_eh_frame_parsing): Set hdr_info->merge_cies instead
	of hdr_info->cies.
	(_bfd_elf_parse_eh_frame): Remove tmp_cie.  Ccreate an array of
	cie structures in all cases and use it instead of extended_cies.
	If merging, store the cie array in sec_info->cies and point each
	CIE's eh_fde_cie at the associated element.  Do not try to
	calculate the value of the personality routine here; record the
	offset of the relocation instead.  Do not merge CIEs here.
	(_bfd_elf_end_eh_frame_parsing): Do not free hdr_info->cies here...
	(_bfd_elf_discard_section_eh_frame_hdr): ...do it here instead.
	(_bfd_elf_gc_mark_fdes): Mark the original (unmerged) CIE.
	(find_merged_cie): New function.
	(_bfd_elf_gc_mark_fdes): Use it.  Free sec_info->cies.

ld/testsuite/
	PR ld/5526
	* ld-elf/eh6.s, ld-elf/eh6.d: New test.
@
text
@d1080 5
a1084 1
    if (!ent->cie)
@


1.69
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Replace u.cie.merged with a union of
	a merged field and a sec field.
	(eh_frame_hdr_info): Remove offsets_adjusted.
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Update accesses to
	the CIE merged field.
	(_bfd_elf_gc_mark_fdes): Likewise.
	(_bfd_elf_discard_section_eh_frame): Likewise.  Set u.cie.u.sec
	when clearing the removed flag.
	(_bfd_elf_eh_frame_section_offset): Remove offsets_adjusted handling.
	(_bfd_elf_write_section_eh_frame): Likewise.  Apply output_offsets
	where appropriate.
@
text
@d45 1
d435 1
a435 2
  if (!hdr_info->parsed_eh_frames && !info->relocatable)
    hdr_info->cies = htab_try_create (1, cie_hash, cie_eq, free);
d456 2
a457 7
  struct extended_cie
    {
      struct cie *cie;
      struct eh_cie_fde *local_cie;
    } *ecies = NULL, *ecie;
  unsigned int ecie_count;
  struct cie *cie, *local_cies = NULL, tmp_cie;
d536 3
a538 10
  ecies = bfd_zmalloc (num_cies * sizeof (*ecies));
  REQUIRE (ecies);

  /* If we're not merging CIE entries (such as for a relocatable link),
     we need to have a "struct cie" for each CIE in this section.  */
  if (hdr_info->cies == NULL)
    {
      local_cies = bfd_zmalloc (num_cies * sizeof (*local_cies));
      REQUIRE (local_cies);
    }
d559 1
a559 1
  ecie_count = 0;
d603 3
a605 10
	  /* If we're merging CIEs, construct the struct cie in TMP_CIE;
	     we'll enter it into the global pool later.  Otherwise point
	     CIE to one of the section-local cie structures.  */
	  if (local_cies)
	    cie = local_cies + ecie_count;
	  else
	    {
	      cie = &tmp_cie;
	      memset (cie, 0, sizeof (*cie));
	    }
d681 7
a687 56
		      if (GET_RELOC (buf) != NULL)
			{
			  unsigned long r_symndx;

#ifdef BFD64
			  if (elf_elfheader (abfd)->e_ident[EI_CLASS]
			      == ELFCLASS64)
			    r_symndx = ELF64_R_SYM (cookie->rel->r_info);
			  else
#endif
			    r_symndx = ELF32_R_SYM (cookie->rel->r_info);
			  if (r_symndx >= cookie->locsymcount
			      || ELF_ST_BIND (cookie->locsyms[r_symndx]
					      .st_info) != STB_LOCAL)
			    {
			      struct elf_link_hash_entry *h;

			      r_symndx -= cookie->extsymoff;
			      h = cookie->sym_hashes[r_symndx];

			      while (h->root.type == bfd_link_hash_indirect
				     || h->root.type == bfd_link_hash_warning)
				h = (struct elf_link_hash_entry *)
				    h->root.u.i.link;

			      cie->personality.h = h;
			    }
			  else
			    {
			      Elf_Internal_Sym *sym;
			      asection *sym_sec;
			      bfd_vma val;

			      sym = &cookie->locsyms[r_symndx];
			      sym_sec = (bfd_section_from_elf_index
					 (abfd, sym->st_shndx));
			      if (sym_sec != NULL)
				{
				  if (sym_sec->kept_section != NULL)
				    sym_sec = sym_sec->kept_section;
				  if (sym_sec->output_section != NULL)
				    {
				      val = (sym->st_value
					     + sym_sec->output_offset
					     + sym_sec->output_section->vma);
				      cie->personality.val = val;
				      cie->local_personality = 1;
				    }
				}
			    }

			  /* Cope with MIPS-style composite relocations.  */
			  do
			    cookie->rel++;
			  while (GET_RELOC (buf) != NULL);
			}
a688 1
		      REQUIRE (cie->local_personality || cie->personality.h);
d741 2
d752 2
a753 2
	  for (ecie = ecies; ecie < ecies + ecie_count; ++ecie)
	    if (cie_offset == ecie->local_cie->offset)
d758 3
a760 4
	  REQUIRE (ecie != ecies + ecie_count);
	  cie = ecie->cie;
	  this_inf->u.fde.cie_inf = ecie->local_cie;
	  this_inf->make_relative = ecie->local_cie->make_relative;
d762 1
a762 1
	    = ecie->local_cie->add_augmentation_size;
a849 24
      if (this_inf->cie)
	{
	  /* We have now finished constructing the struct cie.  */
	  if (hdr_info->cies != NULL)
	    {
	      /* See if we can merge this CIE with an earlier one.  */
	      void **loc;

	      cie_compute_hash (cie);
	      loc = htab_find_slot_with_hash (hdr_info->cies, cie,
					      cie->hash, INSERT);
	      REQUIRE (loc);
	      if (*loc == HTAB_EMPTY_ENTRY)
		{
		  *loc = malloc (sizeof (struct cie));
		  REQUIRE (*loc);
		  memcpy (*loc, cie, sizeof (struct cie));
		}
	      cie = (struct cie *) *loc;
	    }
	  this_inf->u.cie.u.merged = cie->cie_inf;
	  ecies[ecie_count].cie = cie;
	  ecies[ecie_count++].local_cie = this_inf;
	}
d853 1
a853 1
  BFD_ASSERT (ecie_count == num_cies);
d857 5
a873 2
  if (ecies)
    free (ecies);
a886 5
  if (hdr_info->cies != NULL)
    {
      htab_delete (hdr_info->cies);
      hdr_info->cies = NULL;
    }
d918 1
a918 1
  struct eh_cie_fde *fde, *cie, *merged;
d928 1
a928 2
      merged = cie->u.cie.u.merged;
      if (!merged->u.cie.gc_mark)
d930 1
a930 1
	  merged->u.cie.gc_mark = 1;
d938 120
d1069 1
a1069 1
  struct eh_cie_fde *ent, *cie, *merged;
d1103 2
a1104 22

	    cie = ent->u.fde.cie_inf;
	    if (cie->removed)
	      {
		merged = cie->u.cie.u.merged;
		if (!merged->removed)
		  /* We have decided to keep the group representative.  */
		  ent->u.fde.cie_inf = merged;
		else if (merged->u.cie.u.merged != merged)
		  /* We didn't keep the original group representative,
		     but we did keep an alternative.  */
		  ent->u.fde.cie_inf = merged->u.cie.u.merged;
		else
		  {
		    /* Make the local CIE represent the merged group.  */
		    merged->u.cie.u.merged = cie;
		    cie->removed = 0;
		    cie->u.cie.u.sec = sec;
		    cie->u.cie.make_lsda_relative
		      = merged->u.cie.make_lsda_relative;
		  }
	      }
d1108 6
d1143 6
@


1.68
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Move add_fde_encoding and
	per_encoding_relative to u.cie.  Add commentary.
	* elf-eh-frame.c (cie): Remove make_relative.
	(extra_augmentation_string_bytes): Update use of add_fde_encoding.
	(extra_augmentation_data_bytes): Likewise.  Use an FDE's own
	add_augmentation_size field, rather than referring to the CIE.
	(_bfd_elf_parse_eh_frame): Don't set the struct cie
	make_relative field; set the eh_cie_fde field directly.
	Update setting of add_fde_encoding and per_encoding_relative.
	Copy make_relative and add_augmentation_size from the CIE
	to the FDE.
	(_bfd_elf_discard_section_eh_frame): Use the FDE's own
	make_relative field.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Update accesses to
	add_fde_encoding and per_encoding_relative.  Use the FDE's
	own make_relative and add_augmentation_size fields.
@
text
@d938 1
a938 1
	  this_inf->u.cie.merged = cie->cie_inf;
d1022 1
a1022 1
      merged = cie->u.cie.merged;
d1082 1
a1082 1
		merged = cie->u.cie.merged;
d1086 1
a1086 1
		else if (merged->u.cie.merged != merged)
d1089 1
a1089 1
		  ent->u.fde.cie_inf = merged->u.cie.merged;
d1093 1
a1093 1
		    merged->u.cie.merged = cie;
d1095 1
a1214 2
  if (hdr_info->offsets_adjusted)
    offset += sec->output_offset;
a1266 2
  if (hdr_info->offsets_adjusted)
    offset -= sec->output_offset;
a1300 32
  /* First convert all offsets to output section offsets, so that a
     CIE offset is valid if the CIE is used by a FDE from some other
     section.  This can happen when duplicate CIEs are deleted in
     _bfd_elf_discard_section_eh_frame.  We do all sections here because
     this function might not be called on sections in the same order as
     _bfd_elf_discard_section_eh_frame.  */
  if (!hdr_info->offsets_adjusted)
    {
      bfd *ibfd;
      asection *eh;
      struct eh_frame_sec_info *eh_inf;

      for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
	{
	  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
	      || (ibfd->flags & DYNAMIC) != 0)
	    continue;

	  eh = bfd_get_section_by_name (ibfd, ".eh_frame");
	  if (eh == NULL || eh->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
	    continue;

	  eh_inf = elf_section_data (eh)->sec_info;
	  for (ent = eh_inf->entry; ent < eh_inf->entry + eh_inf->count; ++ent)
	    {
	      ent->offset += eh->output_offset;
	      ent->new_offset += eh->output_offset;
	    }
	}
      hdr_info->offsets_adjusted = TRUE;
    }

d1314 1
a1314 2
      memmove (contents + ent->new_offset - sec->output_offset,
	       contents + ent->offset - sec->output_offset, ent->size);
d1318 1
a1318 2
      memmove (contents + ent->new_offset - sec->output_offset,
	       contents + ent->offset - sec->output_offset, ent->size);
d1335 1
a1335 1
      buf = contents + ent->new_offset - sec->output_offset;
d1461 2
a1462 1
	  value = ent->new_offset + 4 - cie->new_offset;
d1487 3
a1489 1
		  address += sec->output_section->vma + ent->offset + 8;
d1493 3
a1495 1
		value -= sec->output_section->vma + ent->new_offset + 8;
d1505 3
a1507 1
		= sec->output_section->vma + ent->new_offset;
d1522 3
a1524 2
		    value -= (sec->output_section->vma + ent->new_offset + 8
			      + ent->lsda_offset);
d1561 3
a1563 2
		    value -= sec->output_section->vma + new_offset
			     + ent->set_loc[cnt];
@


1.67
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Remove need_lsda_relative.
	Move make_lsda_relative to u.cie.
	* elf-eh-frame.c (cie): Rename make_lsda_relative to
	can_make_lsda_relative.
	(_bfd_elf_parse_eh_frame): Don't set the old eh_cie_fde
	make_lsda_relative field.  Update after cie renaming.
	Set u.cie.make_lsda_relative if can_make_lsda_relative
	and if we find a relocation against the LSDA.
	(_bfd_elf_discard_section_eh_frame): Copy make_lsda_relative when
	changing a CIE's group representative.
	(_bfd_elf_eh_frame_section_offset): Don't set need_ldsa_relative here.
	(_bfd_elf_write_section_eh_frame): Check u.cie.make_lsda_relative
	rather than need_lsda_relative.
@
text
@a51 1
  unsigned char make_relative;
d285 1
a285 1
      if (entry->add_fde_encoding)
d297 4
a300 12
  if (entry->cie)
    {
      if (entry->add_augmentation_size)
	size++;
      if (entry->add_fde_encoding)
	size++;
    }
  else
    {
      if (entry->u.fde.cie_inf->add_augmentation_size)
	size++;
    }
d774 1
a774 1
		cie->make_relative = 1;
d783 2
a784 2
		  this_inf->add_fde_encoding = 1;
		  cie->make_relative = 1;
d810 1
a810 2
	  this_inf->make_relative = cie->make_relative;
	  this_inf->per_encoding_relative
d828 3
d896 1
a896 1
	      || cie->make_relative))
d1064 1
a1064 1
		     && ent->u.fde.cie_inf->make_relative == 0)
d1241 1
a1241 1
      && sec_info->entry[mid].u.fde.cie_inf->make_relative
d1256 1
a1256 3
      && (sec_info->entry[mid].cie
	  ? sec_info->entry[mid].make_relative
	  : sec_info->entry[mid].u.fde.cie_inf->make_relative)
d1388 1
a1388 1
	      || ent->per_encoding_relative)
d1398 1
a1398 1
			| (ent->per_encoding_relative ? 4 : 0));
d1428 1
a1428 1
	      if (ent->add_fde_encoding)
d1453 1
a1453 1
				== ent->per_encoding_relative);
d1526 1
a1526 1
	      if (cie->make_relative)
d1557 1
a1557 1
	  else if (cie->add_augmentation_size)
d1589 1
a1589 1
		  if (cie->make_relative)
@


1.66
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add u.fde.next_for_section and
	u.cie.gc_mark.
	(bfd_elf_section_data): Add fde_list.
	(elf_fde_list): New macro.
	(elf_obj_tdata): Add eh_frame_section.
	(elf_eh_frame_section): New macro.
	(_bfd_elf_gc_mark_reloc): Remove last parameter.
	(_bfd_elf_gc_mark_fdes): Declare.
	* elf-eh-frame.c (_bfd_elf_get_eh_frame_sec_info): Chain the FDEs
	for each input section.
	(mark_entry, _bfd_elf_gc_mark_fdes): New functions.
	* elflink.c (_bfd_elf_gc_mark_reloc): Remove is_eh parameter.
	(_bfd_elf_gc_mark): Update call accordingly.  Mark the relocations
	againts the section's FDEs.  Don't mark the bfd's elf_eh_frame_section.
	(bfd_elf_gc_sections): Parse each input bfd's .eh_frame before
	marking any input sections.  Remove the current EH handling.
	* section.c (bfd_section): Remove gc_mark_from_eh.
	* ecoff.c (bfd_debug_section): Update initializer accordingly.
@
text
@d53 1
a53 1
  unsigned char make_lsda_relative;
d802 1
a802 1
	    cie->make_lsda_relative = 1;
a819 1
	  this_inf->make_lsda_relative = cie->make_lsda_relative;
d864 3
d1102 2
d1255 4
a1258 9
      && sec_info->entry[mid].u.fde.cie_inf->make_lsda_relative
      && (offset == (sec_info->entry[mid].offset + 8
		     + sec_info->entry[mid].lsda_offset))
      && (sec_info->entry[mid].u.fde.cie_inf->need_lsda_relative
	  || !hdr_info->offsets_adjusted))
    {
      sec_info->entry[mid].u.fde.cie_inf->need_lsda_relative = 1;
      return (bfd_vma) -2;
    }
d1396 1
a1396 1
	      || ent->need_lsda_relative
d1406 1
a1406 1
			| (ent->need_lsda_relative ? 2 : 0)
d1550 1
a1550 1
	      || cie->need_lsda_relative)
d1560 1
a1560 1
		  else if (cie->need_lsda_relative)
@


1.65
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add u.cie.  Document how u.fde.cie_inf
	changes when removed == 0.
	(eh_frame_hdr_info): Add parsed_eh_frames.
	(_bfd_elf_begin_eh_frame_parsing): Declare.
	(_bfd_elf_parse_eh_frame): Declare.
	(_bfd_elf_end_eh_frame_parsing): Declare.
	* elf-eh-frame.c (_bfd_elf_begin_eh_frame_parsing): New function.
	(_bfd_elf_parse_eh_frame): New function, split out from
	_bfd_elf_discard_section_eh_frame.  Make a first pass through the
	buffer to calculate the number of entries and CIEs.  Allocate memory
	for them before the main loop.  Replace current extended cie
	representation with a pair of pointers, one to the local eh_cie_fde
	and one to the full struct cie.  Allocate a separate array of struct
	cies if not merging.  Merge CIEs during the main loop and set up each
	u.cie.merged field.  Point an FDE's cie_inf field directly at the
	local CIE.  Initially assume that all entries should be removed.
	(_bfd_elf_end_eh_frame_parsing): New function.
	(_bfd_elf_discard_section_eh_frame): Assume that the section has
	already been parsed.  Use a separate pass to mark entries that
	need to be kept.  Use the u.cie.merged field to track a CIE's
	group representative.
	* elflink.c (bfd_elf_discard_info): Call _bfd_elf_parse_eh_frame
	before _bfd_elf_discard_section_eh_frame.  Wrap loop with calls to
	_bfd_elf_begin_eh_frame_parsing and _bfd_elf_end_eh_frame_parsing.
@
text
@d478 1
d581 1
d826 2
d843 6
d989 49
@


1.64
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Put cie_inf in a union.  Add a reloc_index
	field.  Use bitfields for fde_encoding, lsda_encoding and lsda_offset.
	* elf-eh-frame.c (extra_augmentation_data_bytes): Adjust cie_inf
	accesses after the above change.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_discard_section_eh_frame): Likewise.  Set up reloc_index.
@
text
@d434 12
a445 4
/* This function is called for each input file before the .eh_frame
   section is relocated.  It discards duplicate CIEs and FDEs for discarded
   functions.  The function returns TRUE iff any entries have been
   deleted.  */
d447 7
a453 5
bfd_boolean
_bfd_elf_discard_section_eh_frame
   (bfd *abfd, struct bfd_link_info *info, asection *sec,
    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),
    struct elf_reloc_cookie *cookie)
d461 1
a461 1
  bfd_byte *ehbuf = NULL, *buf;
d463 1
a463 1
  struct eh_cie_fde *ent, *this_inf;
d467 2
a468 4
      struct cie cie;
      unsigned int offset;
      unsigned int usage_count;
      unsigned int entry;
d470 2
a471 2
  unsigned int ecie_count = 0, ecie_alloced = 0;
  struct cie *cie;
a474 1
  unsigned int offset;
d476 7
a482 1
  unsigned int entry_alloced;
d487 1
a487 1
      return FALSE;
d494 1
a494 1
      return FALSE;
a496 6
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;

  if (hdr_info->cies == NULL && !info->relocatable)
    hdr_info->cies = htab_try_create (1, cie_hash, cie_eq, free);

d507 1
a507 1
      return FALSE;
d518 2
d521 24
d546 1
a546 1
			  + 99 * sizeof (struct eh_cie_fde));
d549 10
a558 1
  entry_alloced = 100;
d578 3
a580 1
  for (;;)
d583 1
a583 1
      bfd_byte *start, *end, *insns, *insns_end;
a586 13
      if (sec_info->count == entry_alloced)
	{
	  sec_info = bfd_realloc (sec_info,
				  sizeof (struct eh_frame_sec_info)
				  + ((entry_alloced + 99)
				     * sizeof (struct eh_cie_fde)));
	  REQUIRE (sec_info);

	  memset (&sec_info->entry[entry_alloced], 0,
		  100 * sizeof (struct eh_cie_fde));
	  entry_alloced += 100;
	}

a589 3
      if ((bfd_size_type) (buf - ehbuf) == sec->size)
	break;

a593 3
      /* 64-bit .eh_frame is not supported.  */
      REQUIRE (hdr_length != 0xffffffff);

d622 6
a627 1
	  if (ecie_count == ecie_alloced)
d629 2
a630 5
	      ecies = bfd_realloc (ecies,
				   (ecie_alloced + 20) * sizeof (*ecies));
	      REQUIRE (ecies);
	      memset (&ecies[ecie_alloced], 0, 20 * sizeof (*ecies));
	      ecie_alloced += 20;
d632 1
a632 4

	  cie = &ecies[ecie_count].cie;
	  ecies[ecie_count].offset = this_inf->offset;
	  ecies[ecie_count++].entry = sec_info->count;
d634 1
d816 5
d827 1
a827 1
	    if (cie_offset == ecie->offset)
d833 2
a834 1
	  cie = &ecie->cie;
a838 25
	  if ((*reloc_symbol_deleted_p) (buf - ehbuf, cookie))
	    /* This is a FDE against a discarded section.  It should
	       be deleted.  */
	    this_inf->removed = 1;
	  else
	    {
	      if (info->shared
		  && (((cie->fde_encoding & 0xf0) == DW_EH_PE_absptr
		       && cie->make_relative == 0)
		      || (cie->fde_encoding & 0xf0) == DW_EH_PE_aligned))
		{
		  /* If a shared library uses absolute pointers
		     which we cannot turn into PC relative,
		     don't create the binary search table,
		     since it is affected by runtime relocations.  */
		  hdr_info->table = FALSE;
		  (*info->callbacks->einfo)
		    (_("%P: fde encoding in %B(%A) prevents .eh_frame_hdr"
		       " table being created.\n"), abfd, sec);
		}
	      ecie->usage_count++;
	      hdr_info->fde_count++;
	      this_inf->u.fde.cie_inf = (void *) (ecie - ecies);
	    }

d910 1
d913 24
d939 2
d944 20
d965 7
a971 4
  /* Look at all CIEs in this section and determine which can be
     removed as unused, which can be merged with previous duplicate
     CIEs and which need to be kept.  */
  for (ecie = ecies; ecie < ecies + ecie_count; ++ecie)
d973 25
a997 20
      if (ecie->usage_count == 0)
	{
	  sec_info->entry[ecie->entry].removed = 1;
	  continue;
	}
      ecie->cie.output_sec = sec->output_section;
      ecie->cie.cie_inf = sec_info->entry + ecie->entry;
      cie_compute_hash (&ecie->cie);
      if (hdr_info->cies != NULL)
	{
	  void **loc = htab_find_slot_with_hash (hdr_info->cies, &ecie->cie,
						 ecie->cie.hash, INSERT);
	  if (loc != NULL)
	    {
	      if (*loc != HTAB_EMPTY_ENTRY)
		{
		  sec_info->entry[ecie->entry].removed = 1;
		  ecie->cie.cie_inf = ((struct cie *) *loc)->cie_inf;
		  continue;
		}
d999 46
a1044 12
	      *loc = malloc (sizeof (struct cie));
	      if (*loc == NULL)
		*loc = HTAB_DELETED_ENTRY;
	      else
		memcpy (*loc, &ecie->cie, sizeof (struct cie));
	    }
	}
      ecie->cie.cie_inf->make_relative = ecie->cie.make_relative;
      ecie->cie.cie_inf->make_lsda_relative = ecie->cie.make_lsda_relative;
      ecie->cie.cie_inf->per_encoding_relative
	= (ecie->cie.per_encoding & 0x70) == DW_EH_PE_pcrel;
    }
d1046 2
a1047 1
  /* Ok, now we can assign new offsets.  */
a1051 5
	if (!ent->cie)
	  {
	    ecie = ecies + (bfd_hostptr_t) ent->u.fde.cie_inf;
	    ent->u.fde.cie_inf = ecie->cie.cie_inf;
	  }
a1055 1
  /* Resize the sec as needed.  */
a1057 4

  free (ehbuf);
  if (ecies)
    free (ecies);
a1058 15

free_no_table:
  (*info->callbacks->einfo)
    (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
     abfd, sec);
  if (ehbuf)
    free (ehbuf);
  if (sec_info)
    free (sec_info);
  if (ecies)
    free (ecies);
  hdr_info->table = FALSE;
  return FALSE;

#undef REQUIRE
a1074 6
  if (hdr_info->cies != NULL)
    {
      htab_delete (hdr_info->cies);
      hdr_info->cies = NULL;
    }

@


1.63
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use the
	ELF header to choose between 32-bit and 64-bit relocation structures.
@
text
@d307 1
a307 1
      if (entry->cie_inf->add_augmentation_size)
d575 1
d830 1
a830 1
	      this_inf->cie_inf = (void *) (ecie - ecies);
d958 2
a959 2
	    ecie = ecies + (bfd_hostptr_t) ent->cie_inf;
	    ent->cie_inf = ecie->cie.cie_inf;
d1120 1
a1120 1
      && sec_info->entry[mid].cie_inf->make_relative
d1127 1
a1127 1
      && sec_info->entry[mid].cie_inf->make_lsda_relative
d1130 1
a1130 1
      && (sec_info->entry[mid].cie_inf->need_lsda_relative
d1133 1
a1133 1
      sec_info->entry[mid].cie_inf->need_lsda_relative = 1;
d1142 1
a1142 1
	  : sec_info->entry[mid].cie_inf->make_relative)
d1379 1
d1382 1
d1384 1
a1384 1
	  value = ent->new_offset + 4 - ent->cie_inf->new_offset;
d1412 1
a1412 1
	      if (ent->cie_inf->make_relative)
d1427 1
a1427 1
	      || ent->cie_inf->need_lsda_relative)
d1437 1
a1437 1
		  else if (ent->cie_inf->need_lsda_relative)
d1443 1
a1443 1
	  else if (ent->cie_inf->add_augmentation_size)
d1475 1
a1475 1
		  if (ent->cie_inf->make_relative)
@


1.62
log
@Add support for building on a 64-bit Windows host.
@
text
@d686 2
a687 1
			  if (ptr_size == 8)
@


1.61
log
@Switch sources over to use the GPL version 3
@
text
@d956 1
a956 1
	    ecie = ecies + (unsigned long) ent->cie_inf;
@


1.60
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Tidy
	symsec != NULL tests.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.59
log
@2007-05-25  Eric Christopher  <echristo@@apple.com>

        * elf-eh-frame.c (_bfd_elf_discard_section_eh_frame):
        Check that sym_sec isn't NULL before accessing.
@
text
@d715 1
a715 5
			      if (sym_sec != NULL
				  && sym_sec->kept_section != NULL)
				sym_sec = sym_sec->kept_section;
			      if (sym_sec != NULL
				  && sym_sec->output_section != NULL)
d717 10
a726 5
				  val = (sym->st_value
					 + sym_sec->output_offset
					 + sym_sec->output_section->vma);
				  cie->personality.val = val;
				  cie->local_personality = 1;
@


1.58
log
@	PR 4497
	* elf-eh-frame.c (struct cie): Add "local_personality".  Make
	"personality" a union.
	(cie_eq): Compare local_personality too.  Adjust personality
	comparison.
	(_bfd_elf_discard_section_eh_frame): Check binding on personality
	reloc sym to allow for bad symtab.  Use stashed local syms rather
	than reading personality local sym.  Handle discarded sections.
@
text
@d715 2
a716 1
			      if (sym_sec->kept_section != NULL)
d1480 1
a1480 1
     the pointer size. _bfd_elf_discard_section_eh_frame should 
@


1.57
log
@	PR 4454
	* elf-eh-frame.c (struct cie): Make "personality" a bfd_vma.
	(_bfd_elf_discard_section_eh_frame): Handle local syms on
	personality relocation.
@
text
@d35 1
d41 4
a44 1
  bfd_vma personality;
d223 1
d230 2
a231 1
      && c1->personality == c2->personality
d679 1
a679 2
		      /* Ensure we have a reloc here, against
			 a global symbol.  */
a682 1
			  asection *sym_sec = NULL;
d690 3
a692 1
			  if (r_symndx >= cookie->locsymcount)
d704 1
a704 6
			      if (h->root.type == bfd_link_hash_defined
				  || h->root.type == bfd_link_hash_defweak)
				{
				  cie->personality = h->root.u.def.value;
				  sym_sec = h->root.u.def.section;
				}
a707 1
			      Elf_Internal_Shdr *symtab_hdr;
d709 2
d712 7
a718 5
			      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
			      sym = bfd_elf_get_elf_syms (abfd, symtab_hdr,
							  1, r_symndx,
							  NULL, NULL, NULL);
			      if (sym != NULL)
d720 5
a724 4
				  cie->personality = sym->st_value;
				  sym_sec = (bfd_section_from_elf_index
					     (abfd, sym->st_shndx));
				  free (sym);
a726 3
			  if (sym_sec != NULL)
			    cie->personality += (sym_sec->output_section->vma
						 + sym_sec->output_offset);
d734 1
a734 1
		      REQUIRE (cie->personality);
@


1.56
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d40 1
a40 1
  struct elf_link_hash_entry *personality;
d678 1
d698 6
a703 1
			      cie->personality = h;
d705 21
@


1.55
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Warn if
	eh_frame_hdr table won't be created.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.54
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't set
	SEC_EXCLUDE on zero size .eh_frame.
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d790 3
d941 3
@


1.53
log
@	* elf-eh-frame.c (struct cie): New type.
	(cie_compare): Removed.
	(cie_eq, cie_hash, cie_compute_hash): New functions.
	(_bfd_elf_discard_section_eh_frame): Rewrite not to rely on FDEs
	pointing only to last CIE and allow merging of any duplicate CIEs,
	not just duplicate consecutive CIEs.
	(_bfd_elf_discard_section_eh_frame_hdr): Delete cies hash table.
	* elf-bfd.h (struct cie_header, struct cie): Removed.
	(struct eh_frame_sec_info): Remove alloced field.
	(struct eh_frame_hdr_info): Remove last_cie, last_cie_sec
	and last_cie_inf fields.  Add cies field.

	* ld-elf/eh5.d: New test.
	* ld-elf/eh5.s: New file.
	* ld-elf/eh5a.s: New file.
	* ld-elf/eh5b.s: New file.
@
text
@a929 2
  if (sec->size == 0)
    sec->flags |= SEC_EXCLUDE;
@


1.52
log
@	* elf-bfd.h (struct eh_cie_fde): Add set_loc pointer.
	* elf-eh-frame.c (skip_cfa_op): Fix handling of DW_CFA_advance_loc.
	Handle DW_CFA_{remember,restore}_state, DW_CFA_GNU_window_save,
	DW_CFA_val_{offset{,_sf},expression}.
	(skip_non_nops): Record number of DW_CFA_set_loc ops.
	(_bfd_elf_discard_section_eh_frame): Require skip_non_nops recognizes
	all ops.  If there are any DW_CFA_set_loc ops and they are pcrel
	or going to be pcrel, compute set_loc array.
	(_bfd_elf_eh_frame_section_offset): If make_relative, kill relocations
	against DW_CFA_set_loc operands.
	(_bfd_elf_write_section_eh_frame): Handle DW_CFA_set_loc adjusting.

	* ld-elf/eh4.d: New test.
	* ld-elf/eh4.s: New file.
	* ld-elf/eh4a.s: New file.
@
text
@d29 24
d207 1
a207 1
/* Return zero if C1 and C2 CIEs can be merged.  */
d209 2
a210 2
static
int cie_compare (struct cie *c1, struct cie *c2)
d212 5
a216 1
  if (c1->hdr.length == c2->hdr.length
d225 1
d233 11
a243 1
    return 0;
d245 20
a264 1
  return 1;
d444 12
a455 4
  bfd_byte *last_cie, *last_fde;
  struct eh_cie_fde *ent, *last_cie_inf, *this_inf;
  struct cie_header hdr;
  struct cie cie;
d459 1
a459 1
  unsigned int cie_usage_count, offset;
d461 1
d479 3
a503 4
  last_cie = NULL;
  last_cie_inf = NULL;
  memset (&cie, 0, sizeof (cie));
  cie_usage_count = 0;
d508 1
a508 1
  sec_info->alloced = 100;
d535 1
a535 1
      if (sec_info->count == sec_info->alloced)
a536 1
	  struct eh_cie_fde *old_entry = sec_info->entry;
d539 1
a539 1
				  + ((sec_info->alloced + 99)
d543 1
a543 1
	  memset (&sec_info->entry[sec_info->alloced], 0,
d545 1
a545 6
	  sec_info->alloced += 100;

	  /* Now fix any pointers into the array.  */
	  if (last_cie_inf >= old_entry
	      && last_cie_inf < old_entry + sec_info->count)
	    last_cie_inf = sec_info->entry + (last_cie_inf - old_entry);
d550 1
a550 2
      /* If we are at the end of the section, we still need to decide
	 on whether to output or discard last encountered CIE (if any).  */
d552 5
a556 10
	{
	  hdr.length = 0;
	  hdr.id = (unsigned int) -1;
	  end = buf;
	}
      else
	{
	  /* Read the length of the entry.  */
	  REQUIRE (skip_bytes (&buf, ehbuf + sec->size, 4));
	  hdr.length = bfd_get_32 (abfd, buf - 4);
d558 2
a559 2
	  /* 64-bit .eh_frame is not supported.  */
	  REQUIRE (hdr.length != 0xffffffff);
d561 3
a563 3
	  /* The CIE/FDE must be fully contained in this input section.  */
	  REQUIRE ((bfd_size_type) (buf - ehbuf) + hdr.length <= sec->size);
	  end = buf + hdr.length;
d565 2
a566 2
	  this_inf->offset = last_fde - ehbuf;
	  this_inf->size = 4 + hdr.length;
d568 8
a575 17
	  if (hdr.length == 0)
	    {
	      /* A zero-length CIE should only be found at the end of
		 the section.  */
	      REQUIRE ((bfd_size_type) (buf - ehbuf) == sec->size);
	      ENSURE_NO_RELOCS (buf);
	      sec_info->count++;
	      /* Now just finish last encountered CIE processing and break
		 the loop.  */
	      hdr.id = (unsigned int) -1;
	    }
	  else
	    {
	      REQUIRE (skip_bytes (&buf, end, 4));
	      hdr.id = bfd_get_32 (abfd, buf - 4);
	      REQUIRE (hdr.id != (unsigned int) -1);
	    }
d578 4
a581 1
      if (hdr.id == 0 || hdr.id == (unsigned int) -1)
d586 3
a588 1
	  if (last_cie != NULL)
d590 5
a594 20
	      /* Now check if this CIE is identical to the last CIE,
		 in which case we can remove it provided we adjust
		 all FDEs.  Also, it can be removed if we have removed
		 all FDEs using it.  */
	      if ((!info->relocatable
		   && hdr_info->last_cie_sec
		   && (sec->output_section
		       == hdr_info->last_cie_sec->output_section)
		   && cie_compare (&cie, &hdr_info->last_cie) == 0)
		  || cie_usage_count == 0)
		last_cie_inf->removed = 1;
	      else
		{
		  hdr_info->last_cie = cie;
		  hdr_info->last_cie_sec = sec;
		  last_cie_inf->make_relative = cie.make_relative;
		  last_cie_inf->make_lsda_relative = cie.make_lsda_relative;
		  last_cie_inf->per_encoding_relative
		    = (cie.per_encoding & 0x70) == DW_EH_PE_pcrel;
		}
d597 4
a600 9
	  if (hdr.id == (unsigned int) -1)
	    break;

	  last_cie_inf = this_inf;
	  this_inf->cie = 1;

	  cie_usage_count = 0;
	  memset (&cie, 0, sizeof (cie));
	  cie.hdr = hdr;
d602 1
a602 1
	  REQUIRE (read_byte (&buf, end, &cie.version));
d605 2
a606 2
	  REQUIRE (cie.version == 1 || cie.version == 3);
	  REQUIRE (strlen ((char *) buf) < sizeof (cie.augmentation));
d608 1
a608 1
	  strcpy (cie.augmentation, (char *) buf);
d620 3
a622 3
	  REQUIRE (read_uleb128 (&buf, end, &cie.code_align));
	  REQUIRE (read_sleb128 (&buf, end, &cie.data_align));
	  if (cie.version == 1)
d625 1
a625 1
	      cie.ra_column = *buf++;
d628 1
a628 1
	    REQUIRE (read_uleb128 (&buf, end, &cie.ra_column));
d630 4
a633 4
	  cie.lsda_encoding = DW_EH_PE_omit;
	  cie.fde_encoding = DW_EH_PE_omit;
	  cie.per_encoding = DW_EH_PE_omit;
	  aug = cie.augmentation;
d639 1
a639 1
		  REQUIRE (read_uleb128 (&buf, end, &cie.augmentation_size));
d647 1
a647 1
		    REQUIRE (read_byte (&buf, end, &cie.lsda_encoding));
d649 1
a649 1
		    REQUIRE (get_DW_EH_PE_width (cie.lsda_encoding, ptr_size));
d652 1
a652 1
		    REQUIRE (read_byte (&buf, end, &cie.fde_encoding));
d654 1
a654 1
		    REQUIRE (get_DW_EH_PE_width (cie.fde_encoding, ptr_size));
d662 2
a663 2
		      REQUIRE (read_byte (&buf, end, &cie.per_encoding));
		      per_width = get_DW_EH_PE_width (cie.per_encoding,
d666 1
a666 1
		      if ((cie.per_encoding & 0xf0) == DW_EH_PE_aligned)
d696 1
a696 1
			      cie.personality = h;
d704 1
d720 2
a721 2
	      if ((cie.fde_encoding & 0xf0) == DW_EH_PE_absptr)
		cie.make_relative = 1;
d725 2
a726 2
	      else if (cie.fde_encoding == DW_EH_PE_omit
		       && (cie.per_encoding & 0xf0) != DW_EH_PE_aligned)
d728 1
a728 1
		  if (*cie.augmentation == 0)
d731 1
a731 1
		  cie.make_relative = 1;
d739 2
a740 2
	      && (cie.lsda_encoding & 0xf0) == DW_EH_PE_absptr)
	    cie.make_lsda_relative = 1;
d744 2
a745 2
	  if (cie.fde_encoding == DW_EH_PE_omit)
	    cie.fde_encoding = DW_EH_PE_absptr;
d748 1
a748 1
	  if (initial_insn_length <= 50)
d750 2
a751 2
	      cie.initial_insn_length = initial_insn_length;
	      memcpy (cie.initial_instructions, buf, initial_insn_length);
a755 1
	  last_cie = last_fde;
d759 10
a768 3
	  /* Ensure this FDE uses the last CIE encountered.  */
	  REQUIRE (last_cie);
	  REQUIRE (hdr.id == (unsigned int) (buf - 4 - last_cie));
d780 3
a782 3
		  && (((cie.fde_encoding & 0xf0) == DW_EH_PE_absptr
		       && cie.make_relative == 0)
		      || (cie.fde_encoding & 0xf0) == DW_EH_PE_aligned))
d790 1
a790 1
	      cie_usage_count++;
d792 1
d794 1
d797 1
a797 1
	  length = get_DW_EH_PE_width (cie.fde_encoding, ptr_size);
d801 1
a801 1
	  if (cie.augmentation[0] == 'z')
d809 1
a809 1
	  if (cie.lsda_encoding != DW_EH_PE_omit)
d814 1
a814 1
	      if (cie.augmentation[0] != 'z')
d822 1
a822 1
	  buf = last_fde + 4 + hdr.length;
d829 1
a829 1
      length = get_DW_EH_PE_width (cie.fde_encoding, ptr_size);
d840 5
d846 2
a847 2
	  && ((cie.fde_encoding & 0xf0) == DW_EH_PE_pcrel
	      || cie.make_relative))
d866 2
a867 2
      this_inf->fde_encoding = cie.fde_encoding;
      this_inf->lsda_encoding = cie.lsda_encoding;
d874 39
a914 1
  last_cie_inf = hdr_info->last_cie_inf;
d918 5
a922 4
	if (ent->cie)
	  last_cie_inf = ent;
	else
	  ent->cie_inf = last_cie_inf;
a925 1
  hdr_info->last_cie_inf = last_cie_inf;
d934 2
d943 2
a945 1
  hdr_info->last_cie.hdr.length = 0;
d964 7
@


1.51
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d276 1
a276 1
  switch (op & 0x80 ? op & 0xc0 : op)
d281 3
d298 2
d316 1
d348 2
a349 1
skip_non_nops (bfd_byte *buf, bfd_byte *end, unsigned int encoded_ptr_width)
d359 2
d465 1
a465 1
      bfd_byte *start, *end, *insns;
d467 1
d571 1
d789 1
a789 1
	 including the padding.  */
d791 30
a820 3
      insns = skip_non_nops (insns, end, length);
      if (insns != 0)
	this_inf->size -= end - insns;
d1006 17
d1247 1
d1284 2
d1318 30
@


1.50
log
@2006-05-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2655
	PR ld/2657
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Properly
	update CIE/FDE length.  Don't pad to the section alignment.
@
text
@a848 2
  /* Request program headers to be recalculated.  */
  elf_tdata (abfd)->program_header_size = 0;
@


1.49
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d1078 4
a1081 1
      /* Install the new size, filling the extra bytes with DW_CFA_nops.  */
d1083 1
a1083 4
	{
	  memset (end, 0, new_size - ent->size);
	  bfd_put_32 (abfd, new_size - 4, buf);
	}
d1265 7
a1271 34
    {
      unsigned int alignment = 1 << sec->alignment_power;
      unsigned int pad = sec->size % alignment;

      /* Don't pad beyond the raw size of the output section. It
	 can happen at the last input section.  */
      if (pad
	  && ((sec->output_offset + sec->size + pad)
	      <= sec->output_section->size))
	{
	  bfd_byte *buf;
	  unsigned int new_size;

	  /* Find the last CIE/FDE.  */
	  ent = sec_info->entry + sec_info->count;
	  while (--ent != sec_info->entry)
	    if (!ent->removed)
	      break;

	  /* The size of the last CIE/FDE must be at least 4.  */
	  if (ent->removed || ent->size < 4)
	    abort ();

	  pad = alignment - pad;
	  buf = contents + ent->new_offset - sec->output_offset;
	  new_size = size_of_output_cie_fde (ent, ptr_size);

	  /* Pad it with DW_CFA_nop  */
	  memset (buf + new_size, 0, pad);
	  bfd_put_32 (abfd, new_size + pad - 4, buf);

	  sec->size += pad;
	}
    }
@


1.48
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Handle S flag.
	(_bfd_elf_write_section_eh_frame): Likewise.
gas/
	* dw2gencfi.c (struct fde_entry, struct cie_entry): Add signal_frame
	field.
	(CFI_signal_frame): Define.
	(cfi_pseudo_table): Add .cfi_signal_frame.
	(dot_cfi): Handle CFI_signal_frame.
	(output_cie): Handle cie->signal_frame.
	(select_cie_for_fde): Don't share CIE if signal_frame flag is
	different.  Copy signal_frame from FDE to newly created CIE.
	* doc/as.texinfo: Document .cfi_signal_frame.
@
text
@d393 1
a393 2
  if ((sec->output_section != NULL
       && bfd_is_abs_section (sec->output_section)))
@


1.48.4.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d1079 1
a1079 4
      /* Update the size.  It may be shrinked.  */
      bfd_put_32 (abfd, new_size - 4, buf);

      /* Filling the extra bytes with DW_CFA_nops.  */
d1081 4
a1084 1
	memset (end, 0, new_size - ent->size);
d1266 34
a1299 7
  /* We don't align the section to its section alignment since the
     runtime library only expects all CIE/FDE records aligned at
     the pointer size. _bfd_elf_discard_section_eh_frame should 
     have padded CIE/FDE records to multiple of pointer size with
     size_of_output_cie_fde.  */
  if ((sec->size % ptr_size) != 0)
    abort ();
@


1.48.8.1
log
@bfd/
	Backport:
	2006-05-23  H.J. Lu  <hongjiu.lu@@intel.com>
	PR ld/2655
	PR ld/2657
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Properly
	update CIE/FDE length.  Don't pad to the section alignment.
ld/testsuite/
	Backport:
	2006-05-23  H.J. Lu  <hongjiu.lu@@intel.com>
	PR ld/2655
	PR ld/2657
	* ld-elf/eh1.d: New file.
	* ld-elf/eh1.s: Likewise.
	* ld-elf/eh1a.s: Likewise.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh2a.s: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh3.s: Likewise.
	* ld-elf/eh3a.s: Likewise.
@
text
@d1079 1
a1079 4
      /* Update the size.  It may be shrinked.  */
      bfd_put_32 (abfd, new_size - 4, buf);

      /* Filling the extra bytes with DW_CFA_nops.  */
d1081 4
a1084 1
	memset (end, 0, new_size - ent->size);
d1266 34
a1299 7
  /* We don't align the section to its section alignment since the
     runtime library only expects all CIE/FDE records aligned at
     the pointer size. _bfd_elf_discard_section_eh_frame should 
     have padded CIE/FDE records to multiple of pointer size with
     size_of_output_cie_fde.  */
  if ((sec->size % ptr_size) != 0)
    abort ();
@


1.47
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d616 2
d1183 2
@


1.46
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.45
log
@Update the FSF address in the copyright/GPL notice
@
text
@d856 2
a857 2
   because later on it is too late for calling _bfd_strip_section_from_output,
   since dynamic symbol table has been sized.  */
d891 1
a891 1
      _bfd_strip_section_from_output (info, hdr_info->hdr_sec);
@


1.44
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.43
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Fix warning.
@
text
@d456 1
a456 1
      unsigned char *aug;
d566 1
a566 1
	  REQUIRE (strlen (buf) < sizeof (cie.augmentation));
d568 2
a569 2
	  strcpy (cie.augmentation, buf);
	  buf = strchr (buf, '\0') + 1;
d1091 1
a1091 1
	      unsigned char *aug;
d1105 2
a1106 2
	      aug = buf;
	      buf = strchr (buf, '\0') + 1;
d1120 1
a1120 1
	      memmove (aug + extra_string, aug, buf - aug);
@


1.42
log
@	* elf-bfd.h (elf_backend_data): Add elf_backend_eh_frame_address_size.
	(_bfd_elf_eh_frame_address_size): Declare.
	* elfxx-target.h (elf_backend_eh_frame_address_size): Define a default.
	(elfNN_bed): Initialize elf_backend_eh_frame_address_size.
	* elfxx-mips.h (_bfd_mips_elf_eh_frame_address_size): Declare.
	(elf_backend_eh_frame_address_size): Define.
	* elfxx-mips.c (_bfd_mips_elf_eh_frame_address_size): New function.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Get the address
	size from the new backend hook.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_eh_frame_address_size): New function.
@
text
@d485 1
@


1.41
log
@	* elf-eh-frame.c (skip_cfa_op, skip_non_nops): New functions.
	(_bfd_elf_discard_section_eh_frame): Use them to interpret the CFA
	instructions.  If the amount of padding is known, reduce the size
	of the CIE or FDE by that amount.
@
text
@d421 4
a424 2
  ptr_size = (elf_elfheader (abfd)->e_ident[EI_CLASS]
	      == ELFCLASS64) ? 8 : 4;
a991 3
  ptr_size = (elf_elfheader (sec->owner)->e_ident[EI_CLASS]
	      == ELFCLASS64) ? 8 : 4;

d995 5
d1414 8
@


1.40
log
@	* elf-bfd.h (struct cie): Use bfd_vmas for code_align, ra_column and
	augmentation_size.  Use bfd_signed_vmas for data_align.
	* elf-eh-frame.c (read_uleb128, read_sleb128): Delete in favor of...
	(read_byte, skip_leb128, read_uleb128, read_sleb128): ...these new
	functions.  Don't read past the end of the enclosing CIE or FDE.
	(skip_bytes): New utility function.
	(_bfd_elf_discard_section_eh_frame): Use new functions, adding more
	sanity checking.
	(_bfd_elf_write_section_eh_frame): Use new functions.
@
text
@d263 96
d455 1
a455 1
      bfd_byte *start, *end;
d701 1
a701 1
	  initial_insn_length = cie.hdr.length - (buf - last_fde - 4);
d707 1
d748 3
a750 1
	    REQUIRE (skip_leb128 (&buf, end));
d756 11
a766 1
	    this_inf->lsda_offset = buf - start;
d772 8
@


1.39
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use an
	assert-style REQUIRE() macro to handle sanity checks.
@
text
@d29 79
a107 15
#define read_uleb128(VAR, BUF)					\
do								\
  {								\
    (VAR) = read_unsigned_leb128 (abfd, buf, &leb128_tmp);	\
    (BUF) += leb128_tmp;					\
  }								\
while (0)

#define read_sleb128(VAR, BUF)					\
do								\
  {								\
    (VAR) = read_signed_leb128 (abfd, buf, &leb128_tmp);	\
    (BUF) += leb128_tmp;					\
  }								\
while (0)
a287 1
  unsigned int leb128_tmp;
d359 2
d386 4
a389 1
	hdr.id = (unsigned int) -1;
d393 2
a394 3
	  REQUIRE ((bfd_size_type) (buf - ehbuf) + 4 <= sec->size);
	  hdr.length = bfd_get_32 (abfd, buf);
	  buf += 4;
d401 1
d419 2
a420 2
	      hdr.id = bfd_get_32 (abfd, buf);
	      buf += 4;
d463 1
a463 1
	  cie.version = *buf++;
d478 1
a478 1
	      buf += ptr_size;
d481 2
a482 2
	  read_uleb128 (cie.code_align, buf);
	  read_sleb128 (cie.data_align, buf);
d484 4
a487 1
	    cie.ra_column = *buf++;
d489 1
a489 1
	    read_uleb128 (cie.ra_column, buf);
d500 1
a500 1
		  read_uleb128 (cie.augmentation_size, buf);
d508 1
a508 1
		    cie.lsda_encoding = *buf++;
d513 1
a513 1
		    cie.fde_encoding = *buf++;
d521 1
a521 1
		      cie.per_encoding = *buf++;
d526 4
a529 3
			buf = (ehbuf
			       + ((buf - ehbuf + per_width - 1)
				  & ~((bfd_size_type) per_width - 1)));
d562 1
a562 1
		      buf += per_width;
d644 12
d657 1
a657 2
	    {
	      unsigned int dummy;
a658 8
	      aug = buf;
	      buf += 2 * get_DW_EH_PE_width (cie.fde_encoding, ptr_size);
	      if (cie.augmentation[0] == 'z')
		read_uleb128 (dummy, buf);
	      /* If some new augmentation data is added before LSDA
		 in FDE augmentation area, this need to be adjusted.  */
	      this_inf->lsda_offset = (buf - aug);
	    }
a869 1
  unsigned int leb128_tmp;
d971 1
a971 1
	      unsigned int dummy, per_width, per_encoding;
d985 3
a987 3
	      read_uleb128 (dummy, buf);
	      read_sleb128 (dummy, buf);
	      read_uleb128 (dummy, buf);
d1000 1
@


1.38
log
@2005-01-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (dwarf2_debug): Move info_ptr_unit to ...
	(comp_unit): Here.
	(read_unsigned_leb128): Removed.
	(read_signed_leb128): Removed.
	(find_abstract_instance_name): Updated.
	(parse_comp_unit): Accept info_ptr_unit.
	(_bfd_dwarf2_find_nearest_line): Set info_ptr_unit for each
	comp unit and pass it to parse_comp_unit.

	* elf-eh-frame.c (read_unsigned_leb128): Moved to ...
	(read_signed_leb128): Moved to ...
	* libbfd.c: Here.

	* libbfd-in.h (read_unsigned_leb128): New prototype.
	(read_signed_leb128): Likewise.
	* libbfd.h: Regenerated.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d210 6
d247 1
a247 2
  if (!bfd_malloc_and_get_section (abfd, sec, &ehbuf))
    goto free_no_table;
d260 1
a260 2
  if (sec->size != (unsigned int) sec->size)
    goto free_no_table;
d271 1
a271 2
  if (sec_info == NULL)
    goto free_no_table;
d276 4
a279 5
  if (cookie->rel < cookie->relend			\
      && (cookie->rel->r_offset				\
	  < (bfd_size_type) ((buf) - ehbuf))		\
      && cookie->rel->r_info != 0)			\
    goto free_no_table
d304 1
a304 2
	  if (sec_info == NULL)
	    goto free_no_table;
d324 2
a325 4
	  if ((bfd_size_type) (buf + 4 - ehbuf) > sec->size)
	    /* No space for CIE/FDE header length.  */
	    goto free_no_table;

a326 3
	  if (hdr.length == 0xffffffff)
	    /* 64-bit .eh_frame is not supported.  */
	    goto free_no_table;
d328 6
a333 3
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->size)
	    /* CIE/FDE not contained fully in this .eh_frame input section.  */
	    goto free_no_table;
d340 3
a342 3
	      /* CIE with length 0 must be only the last in the section.  */
	      if ((bfd_size_type) (buf - ehbuf) < sec->size)
		goto free_no_table;
d353 1
a353 2
	      if (hdr.id == (unsigned int) -1)
		goto free_no_table;
d398 2
a399 4
	  if (cie.version != 1 && cie.version != 3)
	    goto free_no_table;
	  if (strlen (buf) > sizeof (cie.augmentation) - 1)
	    goto free_no_table;
d439 1
a439 2
		    if (get_DW_EH_PE_width (cie.lsda_encoding, ptr_size) == 0)
		      goto free_no_table;
d444 1
a444 2
		    if (get_DW_EH_PE_width (cie.fde_encoding, ptr_size) == 0)
		      goto free_no_table;
d453 1
a453 2
		      if (per_width == 0)
			goto free_no_table;
d546 2
a547 3
	  if (last_cie == NULL
	      || hdr.id != (unsigned int) (buf - 4 - last_cie))
	    goto free_no_table;
d550 1
a550 3
	  if (GET_RELOC (buf) == NULL)
	    /* This should not happen.  */
	    goto free_no_table;
d628 2
@


1.37
log
@	* elf-bfd.h (eh_cie_fde): Add new fields: add_augmentation_size and
	add_fde_encoding.  Remove need_relative.
	* elf-eh-frame.c (extra_augmentation_string_bytes)
	(extra_augmentation_data_bytes, size_of_output_cie_fde): New functions.
	(_bfd_elf_discard_section_eh_frame): Consider changing the FDE encoding
	in cases where the CIE has no existing 'R' augmentation.  Use
	size_of_output_cie_fde when assigning offsets.  Use the final offset
	as the new section size.
	(_bfd_elf_eh_frame_section_offset): Remove need_relative handling.
	Account for any extra augmentation bytes in the returned offset.
	(_bfd_elf_write_section_eh_frame): Rework so that the entries are
	moved before being modified.  Pad growing entries with DW_CFA_nops.
	Add 'z' and 'R' augmentations as directed by add_augmentation_size
	and add_fde_encoding.
@
text
@a28 58
/* Helper function for reading uleb128 encoded data.  */

static bfd_vma
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
{
  bfd_vma result;
  unsigned int num_read;
  int shift;
  unsigned char byte;

  result = 0;
  shift = 0;
  num_read = 0;
  do
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf++;
      num_read++;
      result |= (((bfd_vma) byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);
  *bytes_read_ptr = num_read;
  return result;
}

/* Helper function for reading sleb128 encoded data.  */

static bfd_signed_vma
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
{
  bfd_vma result;
  int shift;
  int num_read;
  unsigned char byte;

  result = 0;
  shift = 0;
  num_read = 0;
  do
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf ++;
      num_read ++;
      result |= (((bfd_vma) byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);
  if (byte & 0x40)
    result |= (((bfd_vma) -1) << (shift - 7)) << 7;
  *bytes_read_ptr = num_read;
  return result;
}

@


1.36
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Deal with
	composite relocations against the personality data.
@
text
@d203 54
a277 1
  bfd_size_type new_size;
a322 1
  new_size = sec->size;
d434 1
a434 4
		{
		  new_size -= cie.hdr.length + 4;
		  last_cie_inf->removed = 1;
		}
d569 16
a584 3
		  (abfd, info, sec))
	      && (cie.fde_encoding & 0xf0) == DW_EH_PE_absptr)
	    cie.make_relative = 1;
d621 3
a623 6
	    {
	      /* This is a FDE against a discarded section.  It should
		 be deleted.  */
	      new_size -= hdr.length + 4;
	      this_inf->removed = 1;
	    }
a669 2
	ent->new_offset = offset;
	offset += ent->size;
d674 2
d679 1
a679 1
  /* Shrink the sec as needed.  */
d681 1
a681 1
  sec->size = new_size;
d686 1
a686 1
  return new_size != sec->rawsize;
d824 2
a825 7
      && offset == sec_info->entry[mid].offset + 8
      && (sec_info->entry[mid].cie_inf->need_relative
	  || !hdr_info->offsets_adjusted))
    {
      sec_info->entry[mid].cie_inf->need_relative = 1;
      return (bfd_vma) -2;
    }
d842 1
d844 3
a846 1
	  - sec_info->entry[mid].offset);
a860 1
  bfd_byte *p, *buf;
d913 15
a927 1
  p = contents;
d930 3
d936 18
d957 1
a957 1
	  if (ent->need_relative
d962 1
a962 1
	      unsigned int action;
d967 1
a967 1
	      action = ((ent->need_relative ? 1 : 0)
d970 3
a972 1
	      buf = contents + ent->offset - sec->output_offset;
d982 3
a984 1
		  read_uleb128 (dummy, buf);
d988 18
d1035 1
d1055 1
a1055 1
      else if (ent->size > 4)
a1060 1
	  buf = contents + ent->offset - sec->output_offset;
d1091 1
a1091 1
	      if (ent->cie_inf->need_relative)
d1120 8
a1128 7
      else
	/* Terminating FDE must be at the end of .eh_frame section only.  */
	BFD_ASSERT (ent == sec_info->entry + sec_info->count - 1);

      BFD_ASSERT (p == contents + ent->new_offset - sec->output_offset);
      memmove (p, contents + ent->offset - sec->output_offset, ent->size);
      p += ent->size;
d1141 3
a1154 1

d1156 1
a1156 4

	  /* Update length.  */
	  ent->size += pad;
	  bfd_put_32 (abfd, ent->size - 4, buf);
d1159 2
a1160 2
	  memset (p, 0, pad);
	  p += pad;
a1165 2
  BFD_ASSERT ((bfd_size_type) (p - contents) == sec->size);

@


1.35
log
@	* elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Add "info"
	parameter.  If called after _bfd_elf_write_section_eh_frame,
	don't allow a -2 return unless need_* bit is already set, and
	handle offsets adjusted for output_offset.
	* elf-bfd.h (_bfd_elf_eh_frame_section_offset): Update prototype.
	* elf.c (_bfd_elf_section_offset): Update call.
@
text
@d501 4
a504 1
			  cookie->rel++;
@


1.34
log
@	* elf-bfd.h (struct eh_frame_hdr_info): Add offsets_adjusted.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Adjust
	offsets stored in struct eh_cie_fde entries before doing other
	work.
@
text
@d716 1
d721 2
d732 5
d762 3
a764 1
      && offset == sec_info->entry[mid].offset + 8)
d775 3
a777 1
		     + sec_info->entry[mid].lsda_offset)))
d783 2
@


1.33
log
@	* elf-bfd.h (struct eh_cie_fde): Add cie_inf, remove sec.
	(struct eh_frame_hdr_info): Add last_cie_inf, remove last_cie_offset.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete code
	setting offsets for removed CIEs.  Don't set "sec", instead set
	cie_inf for FDEs.  Keep a pointer to last struct eh_cie_fde for a
	CIE in hdr_info.  Only set make_relative and make_lsda_relative
	for CIEs.  Use pointers rather than array indices.
	(_bfd_elf_eh_frame_section_offset): Test/set make_relative,
	make_lsda_relative, need_* on cie_inf for FDEs.
	(_bfd_elf_write_section_eh_frame): Adjust offset and new_offset for
	section output_offset.  Delete cie_offset, instead use cie_inf
	pointer to CIE entry.  Use need_relative and need_lsda_relative on
	CIE entry for FDEs.  Use pointers rather than array indices.
@
text
@d237 1
a237 1
         link, so we should just ignore them.  */
d287 1
a287 1
         && (cookie->rel->r_offset			\
d294 1
a294 1
        == (bfd_size_type) ((buf) - ehbuf)))		\
d514 1
a514 1
          if (info->shared
d801 33
a845 10
      /* First convert all offsets to output section offsets, so that a
	 CIE offset is valid if the CIE is used by a FDE from some other
	 section.  This can happen when duplicate CIEs are deleted in
	 _bfd_elf_discard_section_eh_frame.
	 FIXME: This assumes that _bfd_elf_discard_section_eh_frame is
	 called on sections in the same order as this function, which
	 isn't necessarily so.  */
      ent->offset += sec->output_offset;
      ent->new_offset += sec->output_offset;

d890 1
a890 1
                    per_width = get_DW_EH_PE_width (per_encoding, ptr_size);
d1039 2
a1040 2
                                   contents, (file_ptr) sec->output_offset,
                                   sec->size);
@


1.32
log
@	* elf-bfd.h (struct eh_cie_fde): Add need_relative and
	need_lsda_relative.
	* elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Set
	need_relative or need_lsda_relative if we are processing an
	offset for a reloc on a FDE initial loc or LSDA field
	respectively.
	(_bfd_elf_write_section_eh_frame): Test need_relative and
	need_lsda_relative in place of corresponding make_* field
	when deciding to use pc-relative encodings.
@
text
@d216 1
d223 1
a223 2
  unsigned int cie_usage_count, last_cie_ndx, i, offset;
  unsigned int make_relative, make_lsda_relative;
d267 1
a267 1
  last_cie_ndx = 0;
a270 2
  make_relative = hdr_info->last_cie.make_relative;
  make_lsda_relative = hdr_info->last_cie.make_lsda_relative;
d303 1
d306 2
a307 2
				  + (sec_info->alloced + 99)
				     * sizeof (struct eh_cie_fde));
d314 5
d321 1
d342 2
a343 2
	  sec_info->entry[sec_info->count].offset = last_fde - ehbuf;
	  sec_info->entry[sec_info->count].size = 4 + hdr.length;
d384 1
a384 4
		  sec_info->entry[last_cie_ndx].removed = 1;
		  sec_info->entry[last_cie_ndx].sec = hdr_info->last_cie_sec;
		  sec_info->entry[last_cie_ndx].new_offset
		    = hdr_info->last_cie_offset;
d390 3
a392 6
		  hdr_info->last_cie_offset = last_cie - ehbuf;
		  sec_info->entry[last_cie_ndx].make_relative
		    = cie.make_relative;
		  sec_info->entry[last_cie_ndx].make_lsda_relative
		    = cie.make_lsda_relative;
		  sec_info->entry[last_cie_ndx].per_encoding_relative
d400 2
a401 2
	  last_cie_ndx = sec_info->count;
	  sec_info->entry[sec_info->count].cie = 1;
d554 1
d560 1
a560 1
	      sec_info->entry[sec_info->count].removed = 1;
d588 1
a588 1
	      sec_info->entry[sec_info->count].lsda_offset = (buf - aug);
d594 2
a595 2
      sec_info->entry[sec_info->count].fde_encoding = cie.fde_encoding;
      sec_info->entry[sec_info->count].lsda_encoding = cie.lsda_encoding;
d604 12
a615 35
  last_cie_ndx = 0;
  for (i = 0; i < sec_info->count; i++)
    {
      if (! sec_info->entry[i].removed)
	{
	  sec_info->entry[i].new_offset = offset;
	  offset += sec_info->entry[i].size;
	  if (sec_info->entry[i].cie)
	    {
	      last_cie_ndx = i;
	      make_relative = sec_info->entry[i].make_relative;
	      make_lsda_relative = sec_info->entry[i].make_lsda_relative;
	    }
	  else
	    {
	      sec_info->entry[i].make_relative = make_relative;
	      sec_info->entry[i].make_lsda_relative = make_lsda_relative;
	      sec_info->entry[i].per_encoding_relative = 0;
	    }
	}
      else if (sec_info->entry[i].cie && sec_info->entry[i].sec == sec)
	{
	  /* Need to adjust new_offset too.  */
	  BFD_ASSERT (sec_info->entry[last_cie_ndx].offset
		      == sec_info->entry[i].new_offset);
	  sec_info->entry[i].new_offset
	    = sec_info->entry[last_cie_ndx].new_offset;
	}
    }
  if (hdr_info->last_cie_sec == sec)
    {
      BFD_ASSERT (sec_info->entry[last_cie_ndx].offset
		  == hdr_info->last_cie_offset);
      hdr_info->last_cie_offset = sec_info->entry[last_cie_ndx].new_offset;
    }
d752 2
a753 2
  if (sec_info->entry[mid].make_relative
      && ! sec_info->entry[mid].cie
d756 1
a756 1
      sec_info->entry[mid].need_relative = 1;
d762 2
a763 2
  if (sec_info->entry[mid].make_lsda_relative
      && ! sec_info->entry[mid].cie
d767 1
a767 1
      sec_info->entry[mid].need_lsda_relative = 1;
a786 1
  unsigned int i;
a788 1
  unsigned int cie_offset = 0;
d790 1
d808 1
a808 1
  for (i = 0; i < sec_info->count; ++i)
d810 12
a821 20
      if (sec_info->entry[i].removed)
	{
	  if (sec_info->entry[i].cie)
	    {
	      /* If CIE is removed due to no remaining FDEs referencing it
		 and there were no CIEs kept before it, sec_info->entry[i].sec
		 will be zero.  */
	      if (sec_info->entry[i].sec == NULL)
		cie_offset = 0;
	      else
		{
		  cie_offset = sec_info->entry[i].new_offset;
		  cie_offset += (sec_info->entry[i].sec->output_section->vma
				 + sec_info->entry[i].sec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset);
		}
	    }
	  continue;
	}
d823 1
a823 1
      if (sec_info->entry[i].cie)
d826 3
a828 4
	  cie_offset = sec_info->entry[i].new_offset;
	  if (sec_info->entry[i].need_relative
	      || sec_info->entry[i].need_lsda_relative
	      || sec_info->entry[i].per_encoding_relative)
d836 4
a839 4
	      action = (sec_info->entry[i].need_relative ? 1 : 0)
		       | (sec_info->entry[i].need_lsda_relative ? 2 : 0)
		       | (sec_info->entry[i].per_encoding_relative ? 4 : 0);
	      buf = contents + sec_info->entry[i].offset;
d859 1
a859 1
			BFD_ASSERT (*buf == sec_info->entry[i].lsda_encoding);
d867 1
a867 2
                    per_width = get_DW_EH_PE_width (per_encoding,
						    ptr_size);
d870 1
a870 1
				== sec_info->entry[i].per_encoding_relative);
d877 1
a877 1
			bfd_vma value;
d879 4
a882 6
			value = read_value (abfd, buf, per_width,
					    get_DW_EH_PE_signed
					    (per_encoding));
			value += (sec_info->entry[i].offset
				  - sec_info->entry[i].new_offset);
			write_value (abfd, buf, value, per_width);
d890 1
a890 1
			BFD_ASSERT (*buf == sec_info->entry[i].fde_encoding);
d901 1
a901 1
      else if (sec_info->entry[i].size > 4)
d904 1
a904 1
	  bfd_vma value = 0, address;
d907 1
a907 1
	  buf = contents + sec_info->entry[i].offset;
d910 2
a911 2
	  bfd_put_32 (abfd,
		      sec_info->entry[i].new_offset + 4 - cie_offset, buf);
d913 4
a916 5
	  width = get_DW_EH_PE_width (sec_info->entry[i].fde_encoding,
				      ptr_size);
	  address = value = read_value (abfd, buf, width,
					get_DW_EH_PE_signed
					(sec_info->entry[i].fde_encoding));
d919 1
a919 1
	      switch (sec_info->entry[i].fde_encoding & 0xf0)
d934 2
a935 4
		  value += (sec_info->entry[i].offset
			    - sec_info->entry[i].new_offset);
		  address += (sec->output_section->vma + sec->output_offset
			      + sec_info->entry[i].offset + 8);
d938 2
a939 3
	      if (sec_info->entry[i].need_relative)
		value -= (sec->output_section->vma + sec->output_offset
			  + sec_info->entry[i].new_offset + 8);
d947 1
a947 2
		= (sec->output_section->vma + sec->output_offset
		   + sec_info->entry[i].new_offset);
d950 2
a951 2
	  if ((sec_info->entry[i].lsda_encoding & 0xf0) == DW_EH_PE_pcrel
	      || sec_info->entry[i].need_lsda_relative)
d953 2
a954 3
	      buf += sec_info->entry[i].lsda_offset;
	      width = get_DW_EH_PE_width (sec_info->entry[i].lsda_encoding,
					  ptr_size);
d956 1
a956 2
				  get_DW_EH_PE_signed
				  (sec_info->entry[i].lsda_encoding));
d959 5
a963 8
		  if ((sec_info->entry[i].lsda_encoding & 0xf0)
		      == DW_EH_PE_pcrel)
		    value += (sec_info->entry[i].offset
			      - sec_info->entry[i].new_offset);
		  else if (sec_info->entry[i].need_lsda_relative)
		    value -= (sec->output_section->vma + sec->output_offset
			      + sec_info->entry[i].new_offset + 8
			      + sec_info->entry[i].lsda_offset);
d970 1
a970 1
	BFD_ASSERT (i == sec_info->count - 1);
d972 3
a974 4
      BFD_ASSERT (p == contents + sec_info->entry[i].new_offset);
      memmove (p, contents + sec_info->entry[i].offset,
	       sec_info->entry[i].size);
      p += sec_info->entry[i].size;
d988 3
a990 2
	  for (i = sec_info->count - 1; i > 0; i--)
	    if (! sec_info->entry[i].removed)
d994 1
a994 2
	  if (sec_info->entry[i].removed
	      || sec_info->entry[i].size < 4)
d999 1
a999 1
	  buf = contents + sec_info->entry[i].new_offset;
d1002 2
a1003 2
	  sec_info->entry[i].size += pad;
	  bfd_put_32 (abfd, sec_info->entry[i].size - 4, buf);
@


1.31
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d778 4
a781 1
    return (bfd_vma) -2;
d789 4
a792 1
    return (bfd_vma) -2;
d859 2
a860 2
	  if (sec_info->entry[i].make_relative
	      || sec_info->entry[i].make_lsda_relative
d869 2
a870 2
	      action = (sec_info->entry[i].make_relative ? 1 : 0)
		       | (sec_info->entry[i].make_lsda_relative ? 2 : 0)
d977 1
a977 1
	      if (sec_info->entry[i].make_relative)
d992 1
a992 1
	      || sec_info->entry[i].make_lsda_relative)
d1006 1
a1006 1
		  else if (sec_info->entry[i].make_lsda_relative)
@


1.30
log
@Remove comment rendered obsolete by previous delta
@
text
@d227 1
a227 1
  if (sec->_raw_size == 0)
d246 1
a246 2
  ehbuf = bfd_malloc (sec->_raw_size);
  if (ehbuf == NULL)
d249 1
a249 4
  if (! bfd_get_section_contents (abfd, sec, ehbuf, 0, sec->_raw_size))
    goto free_no_table;

  if (sec->_raw_size >= 4
d260 1
a260 1
  if (sec->_raw_size != (unsigned int) sec->_raw_size)
d270 1
a270 1
  new_size = sec->_raw_size;
d277 1
d320 1
a320 1
      if ((bfd_size_type) (buf - ehbuf) == sec->_raw_size)
d324 1
a324 1
	  if ((bfd_size_type) (buf + 4 - ehbuf) > sec->_raw_size)
d333 1
a333 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->_raw_size)
d343 1
a343 1
	      if ((bfd_size_type) (buf - ehbuf) < sec->_raw_size)
a639 5
  /* FIXME: Currently it is not possible to shrink sections to zero size at
     this point, so build a fake minimal CIE.  */
  if (new_size == 0)
    new_size = 16;

d641 3
a643 2
  sec->_cooked_size = new_size;
  if (sec->_cooked_size == 0)
d647 1
a647 1
  return new_size != sec->_raw_size;
d676 1
a676 1
  sec->_cooked_size = EH_FRAME_HDR_SIZE;
d678 1
a678 1
    sec->_cooked_size += 4 + hdr_info->fde_count * 8;
d717 1
a717 1
	if (o && o->_raw_size > 8 && !bfd_is_abs_section (o->output_section))
d749 2
a750 2
  if (offset >= sec->_raw_size)
    return offset - (sec->_cooked_size - sec->_raw_size);
d815 1
a815 1
				     sec->output_offset, sec->_raw_size);
a1017 12
  /* FIXME: Once _bfd_elf_discard_section_eh_frame will be able to
     shrink sections to zero size, this won't be needed any more.  */
  if (p == contents && sec->_cooked_size == 16)
    {
      bfd_put_32 (abfd, 12, p);		/* Fake CIE length */
      bfd_put_32 (abfd, 0, p + 4);	/* Fake CIE id */
      p[8] = 1;				/* Fake CIE version */
      memset (p + 9, 0, 7);		/* Fake CIE augmentation, 3xleb128
					   and 3xDW_CFA_nop as pad  */
      p += 16;
    }
  else
d1020 1
a1020 1
      unsigned int pad = sec->_cooked_size % alignment;
d1025 2
a1026 2
	  && ((sec->output_offset + sec->_cooked_size + pad)
	      <= sec->output_section->_raw_size))
d1050 1
a1050 1
	  sec->_cooked_size += pad;
d1054 1
a1054 1
  BFD_ASSERT ((bfd_size_type) (p - contents) == sec->_cooked_size);
d1058 1
a1058 1
                                   sec->_cooked_size);
d1169 1
a1169 1
				     sec->_cooked_size);
@


1.29
log
@Handle dwarf3 format CIE entries.
@
text
@a431 5
	  /* Note - in DWARF2 the return address column is an unsigned byte.
	     In DWARF3 it is a ULEB128.  We are following DWARF3.  For most
	     ports this will not matter as the value will be less than 128.
	     For the others (eg FRV, SH, MMIX, IA64) they need a fixed GCC
	     which conforms to the DWARF3 standard.  */
@


1.28
log
@* elf-bfd.h (struct elf_backend_data): Added
elf_backend_can_make_relative_eh_frame,
elf_backend_can_make_lsda_relative_eh_frame and
elf_backend_encode_eh_address.
(_bfd_elf_encode_eh_address): Declare.
(_bfd_elf_can_make_relative): Declare.
* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use new
hooks to decide whether to attempt to make_relative and
make_lsda_relative.
(_bfd_elf_write_section_eh_frame_hdr): Call encode_eh_address.
(_bfd_elf_can_make_relative): New.
(_bfd_elf_encode_eh_address): New.
* elf32-frv.c (frv_elf_use_relative_eh_frame): New.
(frv_elf_encode_eh_address): New.
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
* elfxx-target.h
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
(elfNN_bed): Add them.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d413 1
a413 1
	  if (cie.version != 1)
d437 4
a440 1
	  read_uleb128 (cie.ra_column, buf);
@


1.27
log
@2003-10-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't
	use the last CIE from a different section.
	(_bfd_elf_write_section_eh_frame): Don't pad beyond the raw
	size of the output section.
@
text
@d521 3
d528 3
d1129 1
d1153 4
a1156 1
  contents[1] = DW_EH_PE_pcrel | DW_EH_PE_sdata4; /* .eh_frame offset.  */
d1167 2
a1168 2
  bfd_put_32 (abfd, eh_frame_sec->vma - sec->output_section->vma - 4,
	      contents + 4);
d1193 26
@


1.27.6.1
log
@Merge from mainline:
2004-02-27  Alexandre Oliva  <aoliva@@redhat.com>
* elf-bfd.h (struct elf_backend_data): Added
elf_backend_can_make_relative_eh_frame,
elf_backend_can_make_lsda_relative_eh_frame and
elf_backend_encode_eh_address.
(_bfd_elf_encode_eh_address): Declare.
(_bfd_elf_can_make_relative): Declare.
* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use new
hooks to decide whether to attempt to make_relative and
make_lsda_relative.
(_bfd_elf_write_section_eh_frame_hdr): Call encode_eh_address.
(_bfd_elf_can_make_relative): New.
(_bfd_elf_encode_eh_address): New.
* elf32-frv.c (frv_elf_use_relative_eh_frame): New.
(frv_elf_encode_eh_address): New.
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
* elfxx-target.h
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
(elfNN_bed): Add them.
@
text
@a520 3
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_relative_eh_frame
		  (abfd, info, sec))
a524 3
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_lsda_relative_eh_frame
		  (abfd, info, sec))
a1122 1
  bfd_vma encoded_eh_frame;
d1146 1
a1146 4
  contents[1] = get_elf_backend_data (abfd)->elf_backend_encode_eh_address
    (abfd, info, eh_frame_sec, 0, sec, 4,
     &encoded_eh_frame);			/* .eh_frame offset.  */

d1157 2
a1158 2
  bfd_put_32 (abfd, encoded_eh_frame, contents + 4);

a1182 26
}

/* Decide whether we can use a PC-relative encoding within the given
   EH frame section.  This is the default implementation.  */

bfd_boolean
_bfd_elf_can_make_relative (bfd *input_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Select an encoding for the given address.  Preference is given to
   PC-relative addressing modes.  */

bfd_byte
_bfd_elf_encode_eh_address (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *osec, bfd_vma offset,
			    asection *loc_sec, bfd_vma loc_offset,
			    bfd_vma *encoded)
{
  *encoded = osec->vma + offset -
    (loc_sec->output_section->vma + loc_sec->output_offset + loc_offset);
  return DW_EH_PE_pcrel | DW_EH_PE_sdata4;
@


1.27.8.1
log
@Merge mainline to intercu branch.
@
text
@a520 3
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_relative_eh_frame
		  (abfd, info, sec))
a524 3
	      && (get_elf_backend_data (abfd)
		  ->elf_backend_can_make_lsda_relative_eh_frame
		  (abfd, info, sec))
a1122 1
  bfd_vma encoded_eh_frame;
d1146 1
a1146 4
  contents[1] = get_elf_backend_data (abfd)->elf_backend_encode_eh_address
    (abfd, info, eh_frame_sec, 0, sec, 4,
     &encoded_eh_frame);			/* .eh_frame offset.  */

d1157 2
a1158 2
  bfd_put_32 (abfd, encoded_eh_frame, contents + 4);

a1182 26
}

/* Decide whether we can use a PC-relative encoding within the given
   EH frame section.  This is the default implementation.  */

bfd_boolean
_bfd_elf_can_make_relative (bfd *input_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Select an encoding for the given address.  Preference is given to
   PC-relative addressing modes.  */

bfd_byte
_bfd_elf_encode_eh_address (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    asection *osec, bfd_vma offset,
			    asection *loc_sec, bfd_vma loc_offset,
			    bfd_vma *encoded)
{
  *encoded = osec->vma + offset -
    (loc_sec->output_section->vma + loc_sec->output_offset + loc_offset);
  return DW_EH_PE_pcrel | DW_EH_PE_sdata4;
@


1.27.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 1
  if (sec->size == 0)
d246 2
a247 1
  if (!bfd_malloc_and_get_section (abfd, sec, &ehbuf))
d250 4
a253 1
  if (sec->size >= 4
d264 1
a264 1
  if (sec->size != (unsigned int) sec->size)
d274 1
a274 1
  new_size = sec->size;
a280 1

d323 1
a323 1
      if ((bfd_size_type) (buf - ehbuf) == sec->size)
d327 1
a327 1
	  if ((bfd_size_type) (buf + 4 - ehbuf) > sec->size)
d336 1
a336 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->size)
d346 1
a346 1
	      if ((bfd_size_type) (buf - ehbuf) < sec->size)
d413 1
a413 1
	  if (cie.version != 1 && cie.version != 3)
d432 6
a437 4
	  if (cie.version == 1)
	    cie.ra_column = *buf++;
	  else
	    read_uleb128 (cie.ra_column, buf);
d645 5
d651 2
a652 3
  sec->rawsize = sec->size;
  sec->size = new_size;
  if (sec->size == 0)
d656 1
a656 1
  return new_size != sec->rawsize;
d685 1
a685 1
  sec->size = EH_FRAME_HDR_SIZE;
d687 1
a687 1
    sec->size += 4 + hdr_info->fde_count * 8;
d726 1
a726 1
	if (o && o->size > 8 && !bfd_is_abs_section (o->output_section))
d758 2
a759 2
  if (offset >= sec->rawsize)
    return offset - sec->rawsize + sec->size;
d824 1
a824 1
				     sec->output_offset, sec->size);
d1027 12
d1041 1
a1041 1
      unsigned int pad = sec->size % alignment;
d1046 2
a1047 2
	  && ((sec->output_offset + sec->size + pad)
	      <= sec->output_section->size))
d1071 1
a1071 1
	  sec->size += pad;
d1075 1
a1075 1
  BFD_ASSERT ((bfd_size_type) (p - contents) == sec->size);
d1079 1
a1079 1
                                   sec->size);
d1190 1
a1190 1
				     sec->size);
@


1.26
log
@2003-10-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Pad the
	last CIE/FDE if needed.
@
text
@d375 3
d1037 5
a1041 1
      if (pad)
@


1.25
log
@	* elf-bfd.h: Remove PARAMS macro.  Replace PTR with void *.
	(NAME): Use ## rather than CONCAT4 macro.
	* elfcode.h: Remove one remaining PARAMS macro.
	* elf-eh-frame.c: Convert to C90, remove unneeded casts and prototypes.
	* elf-strtab.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf32-hppa.h: Likewise.
	* elf32-hppa.c: Likewise.
	(elf32_hppa_add_symbol_hook): Delete.
	(elf_backend_add_symbol_hook): Don't define.
	* libhppa.h: Convert to C90.  Replace INLINE with inline.
@
text
@d1029 32
@


1.24
log
@Correct spelling of "relocatable".
@
text
@a28 15
static bfd_vma read_unsigned_leb128
  PARAMS ((bfd *, char *, unsigned int *));
static bfd_signed_vma read_signed_leb128
  PARAMS ((bfd *, char *, unsigned int *));
static int get_DW_EH_PE_width
  PARAMS ((int, int));
static bfd_vma read_value
  PARAMS ((bfd *, bfd_byte *, int, int));
static void write_value
  PARAMS ((bfd *, bfd_byte *, bfd_vma, int));
static int cie_compare
  PARAMS ((struct cie *, struct cie *));
static int vma_compare
  PARAMS ((const PTR, const PTR));

d32 3
a34 4
read_unsigned_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int *bytes_read_ptr;
d36 3
a38 3
  bfd_vma  result;
  unsigned int  num_read;
  int           shift;
d41 2
a42 2
  result   = 0;
  shift    = 0;
d47 2
a48 2
      buf ++;
      num_read ++;
d53 1
a53 1
  * bytes_read_ptr = num_read;
d60 3
a62 4
read_signed_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int * bytes_read_ptr;
d64 3
a66 3
  bfd_vma	result;
  int           shift;
  int           num_read;
d83 1
a83 1
  * bytes_read_ptr = num_read;
d106 1
a106 2
int get_DW_EH_PE_width (encoding, ptr_size)
     int encoding, ptr_size;
d131 1
a131 5
read_value (abfd, buf, width, is_signed)
     bfd *abfd;
     bfd_byte *buf;
     int width;
     int is_signed;
d166 1
a166 5
write_value (abfd, buf, value, width)
     bfd *abfd;
     bfd_byte *buf;
     bfd_vma value;
     int width;
d180 1
a180 2
int cie_compare (c1, c2)
     struct cie *c1, *c2;
d194 1
a194 2
      && (c1->initial_insn_length
	  == c2->initial_insn_length)
d209 4
a212 7
_bfd_elf_discard_section_eh_frame (abfd, info, sec,
				   reloc_symbol_deleted_p, cookie)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     bfd_boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
     struct elf_reloc_cookie *cookie;
d246 1
a246 1
  ehbuf = (bfd_byte *) bfd_malloc (sec->_raw_size);
d250 1
a250 2
  if (! bfd_get_section_contents (abfd, sec, ehbuf, (bfd_vma) 0,
				  sec->_raw_size))
d664 1
a664 3
_bfd_elf_discard_section_eh_frame_hdr (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d692 1
a692 2
_bfd_elf_maybe_strip_eh_frame_hdr (info)
     struct bfd_link_info *info;
d738 3
a740 4
_bfd_elf_eh_frame_section_offset (output_bfd, sec, offset)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma offset;
d747 1
a747 2
  sec_info = (struct eh_frame_sec_info *)
	     elf_section_data (sec)->sec_info;
d796 4
a799 5
_bfd_elf_write_section_eh_frame (abfd, info, sec, contents)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     bfd_byte *contents;
d814 3
a816 6
    return bfd_set_section_contents (abfd, sec->output_section,
				     contents,
				     (file_ptr) sec->output_offset,
				     sec->_raw_size);
  sec_info = (struct eh_frame_sec_info *)
	     elf_section_data (sec)->sec_info;
d1041 1
a1041 3
vma_compare (a, b)
     const PTR a;
     const PTR b;
d1043 2
a1044 2
  struct eh_frame_array_ent *p = (struct eh_frame_array_ent *) a;
  struct eh_frame_array_ent *q = (struct eh_frame_array_ent *) b;
d1075 1
a1075 3
_bfd_elf_write_section_eh_frame_hdr (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
@


1.23
log
@Fix memory leaks
@
text
@d406 1
a406 1
	      if ((!info->relocateable
@


1.22
log
@	* elf-eh-frame.c (get_DW_EH_PE_signed): Define.
	(read_value): Add parameter is_signed, use signed extraction if
	the value is signed.
	(_bfd_elf_write_section_eh_frame): Pass signed flag of the
	encoding to read_value.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d42 1
a42 1
  PARAMS ((const PTR a, const PTR b));
d1115 1
a1115 1
				 sorted by increasing initial_loc)  */
d1128 1
d1145 4
a1148 1
    return FALSE;
d1151 2
a1152 2
  contents[0] = 1;				/* Version  */
  contents[1] = DW_EH_PE_pcrel | DW_EH_PE_sdata4; /* .eh_frame offset  */
d1155 2
a1156 2
      contents[2] = DW_EH_PE_udata4;		/* FDE count encoding  */
      contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4; /* search table enc  */
d1184 5
a1188 3
  return bfd_set_section_contents (abfd, sec->output_section,
				   contents, (file_ptr) sec->output_offset,
                                   sec->_cooked_size);
@


1.21
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d36 1
a36 1
  PARAMS ((bfd *, bfd_byte *, int));
d144 2
d149 1
a149 1
read_value (abfd, buf, width)
d153 1
d159 21
a179 4
    case 2: value = bfd_get_16 (abfd, buf); break;
    case 4: value = bfd_get_32 (abfd, buf); break;
    case 8: value = bfd_get_64 (abfd, buf); break;
    default: BFD_FAIL (); return 0;
d948 3
a950 1
			value = read_value (abfd, buf, per_width);
d986 3
a988 1
	  address = value = read_value (abfd, buf, width);
d1032 3
a1034 1
	      value = read_value (abfd, buf, width);
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d608 1
a608 1
  elf_section_data (sec)->sec_info_type = ELF_INFO_TYPE_EH_FRAME;
d761 1
a761 1
  if (elf_section_data (sec)->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d831 1
a831 1
  if (elf_section_data (sec)->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
@


1.19
log
@	* elf-eh-frame.c (ENSURE_NO_RELOCS): Disregard R_*_NONE relocs.
	(_bfd_elf_discard_section_eh_frame): Don't discard duplicate CIEs
	on a relocatable link.  Comment typos.
	* elf.c (_bfd_elf_link_hash_newfunc): Assign elements of structure
	in the order they are declared.  Clear elf_hash_value too.
	(_bfd_elf_link_hash_table_init): Likewise assign in order.  Clear
	eh_info and tls_segment.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Keep reloc offsets
	sorted when discarding relocs by turning them into R_*_NONE.

	* libbfd.c (warn_deprecated): Comment spelling.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d164 1
a164 1
    
d213 1
a213 1
   functions.  The function returns true iff any entries have been
d216 1
a216 1
boolean
d222 1
a222 1
     boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
d241 1
a241 1
      return false;
d249 1
a249 1
      return false;
d271 1
a271 1
      return false;
d581 1
a581 1
		  hdr_info->table = false;
d666 1
a666 1
  hdr_info->table = false;
d668 1
a668 1
  return false;
d675 1
a675 1
boolean
d688 1
a688 1
    return false;
d697 1
a697 1
  return true;
d705 1
a705 1
boolean
d717 1
a717 1
    return true;
d722 1
a722 1
      return true;
d740 1
a740 1
      return true;
d743 2
a744 2
  hdr_info->table = true;
  return true;
d812 1
a812 1
boolean
d957 1
a957 1
	  /* Skip length.  */	
d1091 1
a1091 1
boolean
d1107 1
a1107 1
    return true;
d1114 1
a1114 1
    return false;
d1118 1
a1118 1
    return false;
@


1.18
log
@	* elf-bfd.h (struct cie_header): Move from elf_eh-frame.c.
	(struct cie, struct eh_cie_fde, struct eh_frame_sec_info): Likewise.
	(struct eh_frame_array_ent, struct eh_frame_hdr_info): Likewise.
	(enum elf_link_info_type): Remove ELF_INFO_TYPE_EH_FRAME_HDR.
	(struct eh_frame_hdr_info): Add "hdr_sec", remove "split".
	(struct elf_link_hash_table): Add eh_info.
	(struct elf_obj_tdata): Change eh_frame_hdr to an asection *.
	(_bfd_elf_discard_section_eh_frame): Update prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Remove "ehdrsec"
	param.  Get "hdr_info" from link hash table.
	(_bfd_elf_discard_section_eh_frame_hdr): Remove "sec" param.  Get
	header section from link hash table.  Save header section to elf_tdata.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Remove local "sec".  Use
	header section from link hash table.  Don't alloc hdr_info.  Clear
	hdr_sec instead of setting "strip".
	(_bfd_elf_eh_frame_section_offset): Formatting.
	(_bfd_elf_write_section_eh_frame): Remove "ehdrsec", add "info" param.
	Get header section from link hash table.
	(_bfd_elf_write_section_eh_frame_hdr): Remove "sec", add "info" param.
	Get header section from link hash table.
	* elf.c (map_sections_to_segments): Use cached eh_frame_hdr.
	(get_program_header_size): Likewise.
	(_bfd_elf_section_offset): Formatting.
	* elflink.h (elf_link_create_dynamic_sections): Stash eh frame header
	section pointer in link hash table.
	(elf_bfd_final_link): Adjust _bfd_elf_write_section_eh_frame_hdr
	and _bfd_elf_write_section_eh_frame calls.  Update comment about
	eh_frame entries.
	(elf_bfd_discard_info): Adjust _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr calls.  Remove "ehdr".

	* po/SRC-POTFILES.in: Regenerate.
@
text
@d298 2
a299 1
	  < (bfd_size_type) ((buf) - ehbuf)))		\
d382 6
a387 5
	      /* Now check if this CIE is identical to last CIE, in which case
		 we can remove it, provided we adjust all FDEs.
		 Also, it can be removed if we have removed all FDEs using
		 that. */
	      if (cie_compare (&cie, &hdr_info->last_cie) == 0
d565 1
a565 1
	      /* This is a FDE against discarded section, it should
d577 1
a577 1
		  /* If shared library uses absolute pointers
@


1.17
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't zero
	relocs for discarded FDEs.  Remove dead code.
	(_bfd_elf_write_section_eh_frame_hdr): Remove dead code.
	* elflink.h (elf_bfd_discard_info): Don't save edited relocs.
	Tidy conditions under which stabs are edited.  Formatting.
	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from discarded relocs.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Add reloc output
	section adjustments after testing magic values.
@
text
@a28 68
struct cie_header
{
  unsigned int length;
  unsigned int id;
};

struct cie
{
  struct cie_header hdr;
  unsigned char version;
  unsigned char augmentation[20];
  unsigned int code_align;
  int data_align;
  unsigned int ra_column;
  unsigned int augmentation_size;
  struct elf_link_hash_entry *personality;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  unsigned char fde_encoding;
  unsigned char initial_insn_length;
  unsigned char make_relative;
  unsigned char make_lsda_relative;
  unsigned char initial_instructions[50];
};

struct eh_cie_fde
{
  unsigned int offset;
  unsigned int size;
  asection *sec;
  unsigned int new_offset;
  unsigned char fde_encoding;
  unsigned char lsda_encoding;
  unsigned char lsda_offset;
  unsigned char cie : 1;
  unsigned char removed : 1;
  unsigned char make_relative : 1;
  unsigned char make_lsda_relative : 1;
  unsigned char per_encoding_relative : 1;
};

struct eh_frame_sec_info
{
  unsigned int count;
  unsigned int alloced;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_vma fde;
};

struct eh_frame_hdr_info
{
  struct cie last_cie;
  asection *last_cie_sec;
  unsigned int last_cie_offset;
  unsigned int fde_count, array_count;
  struct eh_frame_array_ent *array;
  /* TRUE if .eh_frame_hdr should contain the sorted search table.
     We build it if we successfully read all .eh_frame input sections
     and recognize them.  */
  boolean table;
  boolean strip;
};

d217 1
a217 1
_bfd_elf_discard_section_eh_frame (abfd, info, sec, ehdrsec,
d221 1
a221 1
     asection *sec, *ehdrsec;
d229 1
d252 2
a253 4
  BFD_ASSERT (elf_section_data (ehdrsec)->sec_info_type
	      == ELF_INFO_TYPE_EH_FRAME_HDR);
  hdr_info = (struct eh_frame_hdr_info *)
	     elf_section_data (ehdrsec)->sec_info;
d674 1
a674 1
_bfd_elf_discard_section_eh_frame_hdr (abfd, info, sec)
a676 1
     asection *sec;
d678 1
d680 1
d682 5
a686 7
  if ((elf_section_data (sec)->sec_info_type
       != ELF_INFO_TYPE_EH_FRAME_HDR)
      || ! info->eh_frame_hdr)
    {
      _bfd_strip_section_from_output (info, sec);
      return false;
    }
a687 4
  hdr_info = (struct eh_frame_hdr_info *)
	     elf_section_data (sec)->sec_info;
  if (hdr_info->strip)
    return false;
d694 1
a694 1
  elf_tdata (abfd)->eh_frame_hdr = true;
d707 1
a707 1
  asection *sec, *o;
d709 1
d712 3
a714 2
  sec = bfd_get_section_by_name (elf_hash_table (info)->dynobj, ".eh_frame_hdr");
  if (sec == NULL || bfd_is_abs_section (sec->output_section))
d717 5
a721 7
  hdr_info
    = bfd_zmalloc (sizeof (struct eh_frame_hdr_info));
  if (hdr_info == NULL)
    return false;

  elf_section_data (sec)->sec_info = hdr_info;
  elf_section_data (sec)->sec_info_type = ELF_INFO_TYPE_EH_FRAME_HDR;
d736 3
a738 2
      _bfd_strip_section_from_output (info, sec);
      hdr_info->strip = true;
d740 2
a741 2
  else
    hdr_info->table = true;
d799 2
a800 3
      && (offset
	  == (sec_info->entry[mid].offset + 8
	      + sec_info->entry[mid].lsda_offset)))
d811 1
a811 1
_bfd_elf_write_section_eh_frame (abfd, sec, ehdrsec, contents)
d813 2
a814 1
     asection *sec, *ehdrsec;
d818 1
d836 7
a842 13
  hdr_info = NULL;
  if (ehdrsec
      && (elf_section_data (ehdrsec)->sec_info_type
	  == ELF_INFO_TYPE_EH_FRAME_HDR))
    {
      hdr_info = (struct eh_frame_hdr_info *)
		 elf_section_data (ehdrsec)->sec_info;
      if (hdr_info->table && hdr_info->array == NULL)
	hdr_info->array
	  = bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
      if (hdr_info->array == NULL)
        hdr_info = NULL;
    }
d1090 1
a1090 1
_bfd_elf_write_section_eh_frame_hdr (abfd, sec)
d1092 1
a1092 1
     asection *sec;
d1094 1
d1096 1
d1101 4
a1104 5
  BFD_ASSERT (elf_section_data (sec)->sec_info_type
	      == ELF_INFO_TYPE_EH_FRAME_HDR);
  hdr_info = (struct eh_frame_hdr_info *)
	     elf_section_data (sec)->sec_info;
  if (hdr_info->strip)
@


1.16
log
@2002-10-31  David O'Brien  <obrien@@FreeBSD.org>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't mix
	signed and unsigned in comparison.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20021012185224.Y979@@bubble.sa.bigpond.net.au>
@
text
@a301 1
  Elf_Internal_Rela *rel;
a556 1
		      rel = GET_RELOC (buf);
d559 1
a559 1
		      if (rel != NULL)
d627 1
a627 2
	  rel = GET_RELOC (buf);
	  if (rel == NULL)
a635 1
	      memset (rel, 0, sizeof (*rel));
a652 1
	  cookie->rel = rel;
a748 4
  unsigned int ptr_size;

  ptr_size = (elf_elfheader (abfd)->e_ident[EI_CLASS]
	      == ELFCLASS64) ? 8 : 4;
a1172 1
  unsigned int ptr_size;
a1175 3

  ptr_size = (elf_elfheader (sec->owner)->e_ident[EI_CLASS]
	      == ELFCLASS64) ? 8 : 4;
@


1.15
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.
@
text
@d417 1
a417 1
	  if ((buf - ehbuf) + hdr.length > sec->_raw_size)
@


1.15.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 83
d115 4
a118 3
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d120 3
a122 3
  bfd_vma result;
  unsigned int num_read;
  int shift;
d125 2
a126 2
  result = 0;
  shift = 0;
d131 2
a132 2
      buf++;
      num_read++;
d137 1
a137 1
  *bytes_read_ptr = num_read;
d144 4
a147 3
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
d149 3
a151 3
  bfd_vma result;
  int shift;
  int num_read;
d168 1
a168 1
  *bytes_read_ptr = num_read;
d191 2
a192 1
int get_DW_EH_PE_width (int encoding, int ptr_size)
a211 2
#define get_DW_EH_PE_signed(encoding) (((encoding) & DW_EH_PE_signed) != 0)

d215 4
a218 1
read_value (bfd *abfd, bfd_byte *buf, int width, int is_signed)
d224 4
a227 21
    case 2:
      if (is_signed)
	value = bfd_get_signed_16 (abfd, buf);
      else
	value = bfd_get_16 (abfd, buf);
      break;
    case 4:
      if (is_signed)
	value = bfd_get_signed_32 (abfd, buf);
      else
	value = bfd_get_32 (abfd, buf);
      break;
    case 8:
      if (is_signed)
	value = bfd_get_signed_64 (abfd, buf);
      else
	value = bfd_get_64 (abfd, buf);
      break;
    default:
      BFD_FAIL ();
      return 0;
d232 1
a232 1

d236 5
a240 1
write_value (bfd *abfd, bfd_byte *buf, bfd_vma value, int width)
d254 2
a255 1
int cie_compare (struct cie *c1, struct cie *c2)
d269 2
a270 1
      && c1->initial_insn_length == c2->initial_insn_length
d281 1
a281 1
   functions.  The function returns TRUE iff any entries have been
d284 8
a291 5
bfd_boolean
_bfd_elf_discard_section_eh_frame
   (bfd *abfd, struct bfd_link_info *info, asection *sec,
    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),
    struct elf_reloc_cookie *cookie)
a296 1
  struct elf_link_hash_table *htab;
d302 1
d309 1
a309 1
      return FALSE;
d317 1
a317 1
      return FALSE;
d320 4
a323 2
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
d327 1
a327 1
  ehbuf = bfd_malloc (sec->_raw_size);
d331 2
a332 1
  if (! bfd_get_section_contents (abfd, sec, ehbuf, 0, sec->_raw_size))
d341 1
a341 1
      return FALSE;
d368 1
a368 2
	  < (bfd_size_type) ((buf) - ehbuf))		\
      && cookie->rel->r_info != 0)			\
d417 1
a417 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->_raw_size)
d451 5
a455 9
	      /* Now check if this CIE is identical to the last CIE,
		 in which case we can remove it provided we adjust
		 all FDEs.  Also, it can be removed if we have removed
		 all FDEs using it.  */
	      if ((!info->relocatable
		   && hdr_info->last_cie_sec
		   && (sec->output_section
		       == hdr_info->last_cie_sec->output_section)
		   && cie_compare (&cie, &hdr_info->last_cie) == 0)
d558 1
d561 1
a561 1
		      if (GET_RELOC (buf) != NULL)
d629 2
a630 1
	  if (GET_RELOC (buf) == NULL)
d635 1
a635 1
	      /* This is a FDE against a discarded section.  It should
d639 1
d648 1
a648 1
		  /* If a shared library uses absolute pointers
d652 1
a652 1
		  hdr_info->table = FALSE;
d657 1
d680 1
a680 1
  sec->sec_info_type = ELF_INFO_TYPE_EH_FRAME;
d738 1
a738 1
  hdr_info->table = FALSE;
d740 1
a740 1
  return FALSE;
d747 5
a751 2
bfd_boolean
_bfd_elf_discard_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
a752 1
  struct elf_link_hash_table *htab;
d754 4
a757 1
  asection *sec;
d759 7
a765 5
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  sec = hdr_info->hdr_sec;
  if (sec == NULL)
    return FALSE;
d767 4
d777 2
a778 2
  elf_tdata (abfd)->eh_frame_hdr = sec;
  return TRUE;
d786 3
a788 2
bfd_boolean
_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)
d790 1
a790 1
  asection *o;
a791 1
  struct elf_link_hash_table *htab;
d794 8
a801 4
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->hdr_sec == NULL)
    return TRUE;
d803 2
a804 5
  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section))
    {
      hdr_info->hdr_sec = NULL;
      return TRUE;
    }
d819 2
a820 3
      _bfd_strip_section_from_output (info, hdr_info->hdr_sec);
      hdr_info->hdr_sec = NULL;
      return TRUE;
d822 3
a824 3

  hdr_info->table = TRUE;
  return TRUE;
d833 4
a836 3
_bfd_elf_eh_frame_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED,
				  asection *sec,
				  bfd_vma offset)
d841 1
a841 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d843 2
a844 1
  sec_info = elf_section_data (sec)->sec_info;
d881 3
a883 2
      && (offset == (sec_info->entry[mid].offset + 8
		     + sec_info->entry[mid].lsda_offset)))
d893 5
a897 5
bfd_boolean
_bfd_elf_write_section_eh_frame (bfd *abfd,
				 struct bfd_link_info *info,
				 asection *sec,
				 bfd_byte *contents)
a899 1
  struct elf_link_hash_table *htab;
d910 20
a929 11
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
    return bfd_set_section_contents (abfd, sec->output_section, contents,
				     sec->output_offset, sec->_raw_size);
  sec_info = elf_section_data (sec)->sec_info;
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->table && hdr_info->array == NULL)
    hdr_info->array
      = bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
  if (hdr_info->array == NULL)
    hdr_info = NULL;
d1013 1
a1013 3
			value = read_value (abfd, buf, per_width,
					    get_DW_EH_PE_signed
					    (per_encoding));
d1042 1
a1042 1
	  /* Skip length.  */
d1049 1
a1049 3
	  address = value = read_value (abfd, buf, width,
					get_DW_EH_PE_signed
					(sec_info->entry[i].fde_encoding));
d1093 1
a1093 3
	      value = read_value (abfd, buf, width,
				  get_DW_EH_PE_signed
				  (sec_info->entry[i].lsda_encoding));
a1128 36
  else
    {
      unsigned int alignment = 1 << sec->alignment_power;
      unsigned int pad = sec->_cooked_size % alignment;

      /* Don't pad beyond the raw size of the output section. It
	 can happen at the last input section.  */
      if (pad
	  && ((sec->output_offset + sec->_cooked_size + pad)
	      <= sec->output_section->_raw_size))
	{
	  /* Find the last CIE/FDE.  */
	  for (i = sec_info->count - 1; i > 0; i--)
	    if (! sec_info->entry[i].removed)
	      break;

	  /* The size of the last CIE/FDE must be at least 4.  */
	  if (sec_info->entry[i].removed
	      || sec_info->entry[i].size < 4)
	    abort ();

	  pad = alignment - pad;

	  buf = contents + sec_info->entry[i].new_offset;

	  /* Update length.  */
	  sec_info->entry[i].size += pad;
	  bfd_put_32 (abfd, sec_info->entry[i].size - 4, buf);

	  /* Pad it with DW_CFA_nop  */
	  memset (p, 0, pad);
	  p += pad;

	  sec->_cooked_size += pad;
	}
    }
d1141 3
a1143 1
vma_compare (const void *a, const void *b)
d1145 2
a1146 2
  const struct eh_frame_array_ent *p = a;
  const struct eh_frame_array_ent *q = b;
d1174 1
a1174 1
				 sorted by increasing initial_loc).  */
d1176 4
a1179 2
bfd_boolean
_bfd_elf_write_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
a1180 1
  struct elf_link_hash_table *htab;
d1182 1
a1182 1
  asection *sec;
a1185 1
  bfd_boolean retval;
d1187 9
a1195 5
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  sec = hdr_info->hdr_sec;
  if (sec == NULL)
    return TRUE;
d1202 1
a1202 1
    return FALSE;
d1206 1
a1206 4
    {
      free (contents);
      return FALSE;
    }
d1209 2
a1210 2
  contents[0] = 1;				/* Version.  */
  contents[1] = DW_EH_PE_pcrel | DW_EH_PE_sdata4; /* .eh_frame offset.  */
d1213 2
a1214 2
      contents[2] = DW_EH_PE_udata4;		/* FDE count encoding.  */
      contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4; /* Search table enc.  */
d1242 3
a1244 5
  retval = bfd_set_section_contents (abfd, sec->output_section,
				     contents, (file_ptr) sec->output_offset,
				     sec->_cooked_size);
  free (contents);
  return retval;
@


1.14
log
@Undo previous delta.  Add comment explaining why.
@
text
@a634 1
	      cookie->rel = rel;
d639 1
@


1.14.10.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d635 1
a639 1
	      memset (rel, 0, sizeof (*rel));
@


1.14.10.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d29 68
d285 1
a285 1
_bfd_elf_discard_section_eh_frame (abfd, info, sec,
d289 1
a289 1
     asection *sec;
a296 1
  struct elf_link_hash_table *htab;
d302 1
d320 4
a323 2
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
d417 1
a417 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->_raw_size)
d558 1
d561 1
a561 1
		      if (GET_RELOC (buf) != NULL)
d629 2
a630 1
	  if (GET_RELOC (buf) == NULL)
d639 1
d657 1
d748 1
a748 1
_bfd_elf_discard_section_eh_frame_hdr (abfd, info)
d751 1
a752 1
  struct elf_link_hash_table *htab;
d754 12
a765 1
  asection *sec;
d767 3
a769 4
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  sec = hdr_info->hdr_sec;
  if (sec == NULL)
a770 1

d777 1
a777 1
  elf_tdata (abfd)->eh_frame_hdr = sec;
d790 1
a790 1
  asection *o;
a791 1
  struct elf_link_hash_table *htab;
d794 2
a795 3
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->hdr_sec == NULL)
d798 7
a804 5
  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section))
    {
      hdr_info->hdr_sec = NULL;
      return true;
    }
d819 2
a820 3
      _bfd_strip_section_from_output (info, hdr_info->hdr_sec);
      hdr_info->hdr_sec = NULL;
      return true;
d822 2
a823 2

  hdr_info->table = true;
d881 3
a883 2
      && (offset == (sec_info->entry[mid].offset + 8
		     + sec_info->entry[mid].lsda_offset)))
d894 1
a894 1
_bfd_elf_write_section_eh_frame (abfd, info, sec, contents)
d896 1
a896 2
     struct bfd_link_info *info;
     asection *sec;
a899 1
  struct elf_link_hash_table *htab;
d917 13
a929 7
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  if (hdr_info->table && hdr_info->array == NULL)
    hdr_info->array
      = bfd_malloc (hdr_info->fde_count * sizeof(*hdr_info->array));
  if (hdr_info->array == NULL)
    hdr_info = NULL;
d1177 1
a1177 1
_bfd_elf_write_section_eh_frame_hdr (abfd, info)
d1179 1
a1179 1
     struct bfd_link_info *info;
a1180 1
  struct elf_link_hash_table *htab;
d1182 1
a1182 1
  asection *sec;
d1187 8
a1194 4
  htab = elf_hash_table (info);
  hdr_info = &htab->eh_info;
  sec = hdr_info->hdr_sec;
  if (sec == NULL)
@


1.14.10.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d164 1
a164 1

d213 1
a213 1
   functions.  The function returns TRUE iff any entries have been
d216 1
a216 1
bfd_boolean
d222 1
a222 1
     bfd_boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
d241 1
a241 1
      return FALSE;
d249 1
a249 1
      return FALSE;
d271 1
a271 1
      return FALSE;
d298 1
a298 2
	  < (bfd_size_type) ((buf) - ehbuf))		\
      && cookie->rel->r_info != 0)			\
d381 5
a385 6
	      /* Now check if this CIE is identical to the last CIE,
		 in which case we can remove it provided we adjust
		 all FDEs.  Also, it can be removed if we have removed
		 all FDEs using it.  */
	      if ((!info->relocateable
		   && cie_compare (&cie, &hdr_info->last_cie) == 0)
d563 1
a563 1
	      /* This is a FDE against a discarded section.  It should
d575 1
a575 1
		  /* If a shared library uses absolute pointers
d579 1
a579 1
		  hdr_info->table = FALSE;
d664 1
a664 1
  hdr_info->table = FALSE;
d666 1
a666 1
  return FALSE;
d673 1
a673 1
bfd_boolean
d686 1
a686 1
    return FALSE;
d695 1
a695 1
  return TRUE;
d703 1
a703 1
bfd_boolean
d715 1
a715 1
    return TRUE;
d720 1
a720 1
      return TRUE;
d738 1
a738 1
      return TRUE;
d741 2
a742 2
  hdr_info->table = TRUE;
  return TRUE;
d810 1
a810 1
bfd_boolean
d955 1
a955 1
	  /* Skip length.  */
d1089 1
a1089 1
bfd_boolean
d1105 1
a1105 1
    return TRUE;
d1112 1
a1112 1
    return FALSE;
d1116 1
a1116 1
    return FALSE;
@


1.14.10.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d36 1
a36 1
  PARAMS ((bfd *, bfd_byte *, int, int));
a143 2
#define get_DW_EH_PE_signed(encoding) (((encoding) & DW_EH_PE_signed) != 0)

d147 1
a147 1
read_value (abfd, buf, width, is_signed)
a150 1
     int is_signed;
d156 4
a159 21
    case 2:
      if (is_signed)
	value = bfd_get_signed_16 (abfd, buf);
      else
	value = bfd_get_16 (abfd, buf);
      break;
    case 4:
      if (is_signed)
	value = bfd_get_signed_32 (abfd, buf);
      else
	value = bfd_get_32 (abfd, buf);
      break;
    case 8:
      if (is_signed)
	value = bfd_get_signed_64 (abfd, buf);
      else
	value = bfd_get_64 (abfd, buf);
      break;
    default:
      BFD_FAIL ();
      return 0;
d608 1
a608 1
  sec->sec_info_type = ELF_INFO_TYPE_EH_FRAME;
d761 1
a761 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d831 1
a831 1
  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
d928 1
a928 3
			value = read_value (abfd, buf, per_width,
					    get_DW_EH_PE_signed
					    (per_encoding));
d964 1
a964 3
	  address = value = read_value (abfd, buf, width,
					get_DW_EH_PE_signed
					(sec_info->entry[i].fde_encoding));
d1008 1
a1008 3
	      value = read_value (abfd, buf, width,
				  get_DW_EH_PE_signed
				  (sec_info->entry[i].lsda_encoding));
@


1.14.10.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d42 1
a42 1
  PARAMS ((const PTR, const PTR));
d1115 1
a1115 1
				 sorted by increasing initial_loc).  */
a1127 1
  bfd_boolean retval;
d1144 1
a1144 4
    {
      free (contents);
      return FALSE;
    }
d1147 2
a1148 2
  contents[0] = 1;				/* Version.  */
  contents[1] = DW_EH_PE_pcrel | DW_EH_PE_sdata4; /* .eh_frame offset.  */
d1151 2
a1152 2
      contents[2] = DW_EH_PE_udata4;		/* FDE count encoding.  */
      contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4; /* Search table enc.  */
d1180 3
a1182 5
  retval = bfd_set_section_contents (abfd, sec->output_section,
				     contents, (file_ptr) sec->output_offset,
				     sec->_cooked_size);
  free (contents);
  return retval;
@


1.14.10.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d406 1
a406 1
	      if ((!info->relocatable
@


1.14.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d29 15
d47 4
a50 3
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d52 3
a54 3
  bfd_vma result;
  unsigned int num_read;
  int shift;
d57 2
a58 2
  result = 0;
  shift = 0;
d63 2
a64 2
      buf++;
      num_read++;
d69 1
a69 1
  *bytes_read_ptr = num_read;
d76 4
a79 3
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
d81 3
a83 3
  bfd_vma result;
  int shift;
  int num_read;
d100 1
a100 1
  *bytes_read_ptr = num_read;
d123 2
a124 1
int get_DW_EH_PE_width (int encoding, int ptr_size)
d149 5
a153 1
read_value (bfd *abfd, bfd_byte *buf, int width, int is_signed)
d188 5
a192 1
write_value (bfd *abfd, bfd_byte *buf, bfd_vma value, int width)
d206 2
a207 1
int cie_compare (struct cie *c1, struct cie *c2)
d221 2
a222 1
      && c1->initial_insn_length == c2->initial_insn_length
d237 7
a243 4
_bfd_elf_discard_section_eh_frame
   (bfd *abfd, struct bfd_link_info *info, asection *sec,
    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),
    struct elf_reloc_cookie *cookie)
d277 1
a277 1
  ehbuf = bfd_malloc (sec->_raw_size);
d281 2
a282 1
  if (! bfd_get_section_contents (abfd, sec, ehbuf, 0, sec->_raw_size))
d696 3
a698 1
_bfd_elf_discard_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
d726 2
a727 1
_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)
d773 4
a776 3
_bfd_elf_eh_frame_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED,
				  asection *sec,
				  bfd_vma offset)
d783 2
a784 1
  sec_info = elf_section_data (sec)->sec_info;
d833 5
a837 4
_bfd_elf_write_section_eh_frame (bfd *abfd,
				 struct bfd_link_info *info,
				 asection *sec,
				 bfd_byte *contents)
d852 6
a857 3
    return bfd_set_section_contents (abfd, sec->output_section, contents,
				     sec->output_offset, sec->_raw_size);
  sec_info = elf_section_data (sec)->sec_info;
d1082 3
a1084 1
vma_compare (const void *a, const void *b)
d1086 2
a1087 2
  const struct eh_frame_array_ent *p = a;
  const struct eh_frame_array_ent *q = b;
d1118 3
a1120 1
_bfd_elf_write_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
@


1.14.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a374 3
		   && hdr_info->last_cie_sec
		   && (sec->output_section
		       == hdr_info->last_cie_sec->output_section)
a1027 36
    }
  else
    {
      unsigned int alignment = 1 << sec->alignment_power;
      unsigned int pad = sec->_cooked_size % alignment;

      /* Don't pad beyond the raw size of the output section. It
	 can happen at the last input section.  */
      if (pad
	  && ((sec->output_offset + sec->_cooked_size + pad)
	      <= sec->output_section->_raw_size))
	{
	  /* Find the last CIE/FDE.  */
	  for (i = sec_info->count - 1; i > 0; i--)
	    if (! sec_info->entry[i].removed)
	      break;

	  /* The size of the last CIE/FDE must be at least 4.  */
	  if (sec_info->entry[i].removed
	      || sec_info->entry[i].size < 4)
	    abort ();

	  pad = alignment - pad;

	  buf = contents + sec_info->entry[i].new_offset;

	  /* Update length.  */
	  sec_info->entry[i].size += pad;
	  bfd_put_32 (abfd, sec_info->entry[i].size - 4, buf);

	  /* Pad it with DW_CFA_nop  */
	  memset (p, 0, pad);
	  p += pad;

	  sec->_cooked_size += pad;
	}
@


1.13
log
@Use a simple byte read when reading the return address register column.
@
text
@d509 6
a514 1
	  cie.ra_column = *buf++;
@


1.12
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Add PARAMS to
	argument declaration.
@
text
@d509 1
a509 1
	  read_uleb128 (cie.ra_column, buf);
@


1.11
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d290 1
a290 1
     boolean (*reloc_symbol_deleted_p) (bfd_vma, PTR);
@


1.11.4.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d630 1
a634 1
	      memset (rel, 0, sizeof (*rel));
@


1.11.4.2
log
@2002-10-31  David O'Brien  <obrien@@FreeBSD.org>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't mix
	signed and unsigned in comparison.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20021012185224.Y979@@bubble.sa.bigpond.net.au>
@
text
@d417 1
a417 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->_raw_size)
@


1.11.2.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d290 1
a290 1
     boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
a508 5
	  /* Note - in DWARF2 the return address column is an unsigned byte.
	     In DWARF3 it is a ULEB128.  We are following DWARF3.  For most
	     ports this will not matter as the value will be less than 128.
	     For the others (eg FRV, SH, MMIX, IA64) they need a fixed GCC
	     which conforms to the DWARF3 standard.  */
@


1.11.2.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d635 1
a639 1
	      memset (rel, 0, sizeof (*rel));
@


1.11.2.3
log
@merge from mainline
@
text
@d417 1
a417 1
	  if ((bfd_size_type) (buf - ehbuf) + hdr.length > sec->_raw_size)
@


1.10
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't build
	search table if some FDE is DW_EH_PE_aligned encoded either.
	(_bfd_elf_write_section_eh_frame): Handle terminating FDE specially.
@
text
@d790 1
a790 1
  if (sec == NULL)
d808 1
a808 1
	if (o && o->_raw_size > 8)
@


1.10.4.1
log
@merge from trunk
@
text
@d790 1
a790 1
  if (sec == NULL || bfd_is_abs_section (sec->output_section))
d808 1
a808 1
	if (o && o->_raw_size > 8 && !bfd_is_abs_section (o->output_section))
@


1.9
log
@	* elf-eh-frame.c (struct eh_cie_fde): Add per_encoding_relative.
	(_bfd_elf_discard_section_eh_frame): Set it for CIEs with pcrel
	encoded personality.
	(_bfd_elf_write_section_eh_frame): Adjust pcrel encoded personality
	for CIE/FDE removal.
@
text
@d639 3
a641 2
		  && (cie.fde_encoding & 0xf0) == DW_EH_PE_absptr
		  && cie.make_relative == 0)
d1030 1
a1030 1
      else
d1103 3
@


1.8
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d67 1
d473 2
d695 1
d954 2
a955 1
	      || sec_info->entry[i].make_lsda_relative)
d964 2
a965 1
		       | (sec_info->entry[i].make_lsda_relative ? 2 : 0);
d997 2
d1003 10
@


1.7
log
@	* elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Avoid
	unsigned overflow when new_offset < old_offset.
@
text
@d589 2
a590 5
	     as possible.
	     FIXME: For this to work, ELF backends need to perform the
	     relocation if omitting dynamic relocs, not skip it.  */
          if (0
	      && info->shared
d594 1
a594 2
	  if (0
	      && info->shared
d635 10
d865 1
a865 1
    return (bfd_vma) -1;
d874 1
a874 1
    return (bfd_vma) -1;
@


1.7.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d589 5
a593 2
	     as possible.  */
          if (info->shared
d597 2
a598 1
	  if (info->shared
a638 10
	      if (info->shared
		  && (cie.fde_encoding & 0xf0) == DW_EH_PE_absptr
		  && cie.make_relative == 0)
		{
		  /* If shared library uses absolute pointers
		     which we cannot turn into PC relative,
		     don't create the binary search table,
		     since it is affected by runtime relocations.  */
		  hdr_info->table = false;
		}
d859 1
a859 1
    return (bfd_vma) -2;
d868 1
a868 1
    return (bfd_vma) -2;
@


1.7.2.2
log
@	* elf-eh-frame.c (struct eh_cie_fde): Add per_encoding_relative.
	(_bfd_elf_discard_section_eh_frame): Set it for CIEs with pcrel
	encoded personality.
	(_bfd_elf_write_section_eh_frame): Adjust pcrel encoded personality
	for CIE/FDE removal.

	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't build
	search table if some FDE is DW_EH_PE_aligned encoded either.
	(_bfd_elf_write_section_eh_frame): Handle terminating FDE specially.
@
text
@a66 1
  unsigned char per_encoding_relative : 1;
a471 2
		  sec_info->entry[last_cie_ndx].per_encoding_relative
		    = (cie.per_encoding & 0x70) == DW_EH_PE_pcrel;
d636 2
a637 3
		  && (((cie.fde_encoding & 0xf0) == DW_EH_PE_absptr
		       && cie.make_relative == 0)
		      || (cie.fde_encoding & 0xf0) == DW_EH_PE_aligned))
a691 1
	      sec_info->entry[i].per_encoding_relative = 0;
d950 1
a950 2
	      || sec_info->entry[i].make_lsda_relative
	      || sec_info->entry[i].per_encoding_relative)
d959 1
a959 2
		       | (sec_info->entry[i].make_lsda_relative ? 2 : 0)
		       | (sec_info->entry[i].per_encoding_relative ? 4 : 0);
a990 2
		    BFD_ASSERT (((per_encoding & 0x70) == DW_EH_PE_pcrel)
				== sec_info->entry[i].per_encoding_relative);
a994 10
		    if (action & 4)
		      {
			bfd_vma value;

			value = read_value (abfd, buf, per_width);
			value += (sec_info->entry[i].offset
				  - sec_info->entry[i].new_offset);
			write_value (abfd, buf, value, per_width);
			action &= ~4;
		      }
d1011 1
a1011 1
      else if (sec_info->entry[i].size > 4)
a1083 3
      else
	/* Terminating FDE must be at the end of .eh_frame section only.  */
	BFD_ASSERT (i == sec_info->count - 1);
@


1.6
log
@	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame): Don't crash if
	CIE at .eh_frame start is removed due to no FDEs referencing it.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d870 2
a871 2
  return (offset
	  + (sec_info->entry[mid].new_offset - sec_info->entry[mid].offset));
@


1.5
log
@	* elflink.h (elf_bfd_final_link): Check if dynobj is not NULL
	before looking for .eh_frame_hdr section.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): If
	.eh_frame_hdr section is being stripped from output, don't do
	anything.
@
text
@d922 13
a934 5
	      cie_offset = sec_info->entry[i].new_offset;
	      cie_offset += (sec_info->entry[i].sec->output_section->vma
			     + sec_info->entry[i].sec->output_offset
			     - sec->output_section->vma
			     - sec->output_offset);
d938 1
@


1.4
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): If new_size
	is 0, temporarily grow it to minimal CIE size.
	(_bfd_elf_write_section_eh_frame): If input .eh_frame section would
	end up empty, build a fake minimal CIE.
@
text
@d1152 3
@


1.3
log
@	* elf-eh-frame.c (struct cie): Add make_lsda_relative.
	(struct eh_cie_fde): Add lsda_encoding, lsda_offset,
	make_lsda_relative.
	(read_value, write_value): New.
	(_bfd_elf_discard_section_eh_frame): Inicialize
	lsda_encoding, lsda_offset and make_lsda_relative.
	(_bfd_elf_eh_frame_section_offset): If make_lsda_relative,
	request no dynamic reloc for LSDA field of FDE.
	(_bfd_elf_write_section_eh_frame): Handle make_lsda_relative.
	If a non-DW_EH_PE_absptr value is 0, don't adjust it by base
	or pcrel.  Fix address computation for DW_EH_PE_pcrel relocs.
	Update LSDA field if LSDA encoding is DW_EH_PE_pcrel, because
	. might have changed due to deleted FDE or CIEs.
@
text
@d704 5
a709 1
  
d1074 12
@


1.2
log
@	* elf-bfd.h (_bfd_elf_maybe_strip_eh_frame_hdr): New prototype.
	* elf-eh-frame.c (struct eh_frame_hdr_info): Add strip.
	(_bfd_elf_discard_section_eh_frame): Don't create .eh_frame_hdr
	sec_info here.  Free ehbuf.
	(_bfd_elf_discard_section_eh_frame_hdr): Don't size the section
	if hdr_info->strip.
	(_bfd_elf_maybe_strip_eh_frame_hdr): New.
	* elflink.h (size_dynamic_sections): Call it.
@
text
@d50 1
d61 2
d66 1
d102 4
d211 39
d299 2
a300 1
  unsigned int cie_usage_count, last_cie_ndx, i, offset, make_relative;
d357 1
d470 2
d597 5
d643 12
d660 1
d680 1
d683 4
a686 1
	    sec_info->entry[i].make_relative = make_relative;
d857 9
d930 2
a931 1
	  if (sec_info->entry[i].make_relative)
d934 1
d937 1
a937 1
	      /* Need to find 'R' augmentation's argument and modify
d939 2
d955 1
a955 1
	      while (*aug != 'R')
d959 6
d978 9
a989 3

	      BFD_ASSERT (*buf == sec_info->entry[i].fde_encoding);
	      *buf |= DW_EH_PE_pcrel;
d996 1
a996 1
	  unsigned int fde_width;
d1004 4
a1007 3
	  fde_width = get_DW_EH_PE_width (sec_info->entry[i].fde_encoding,
					  ptr_size);
	  switch (fde_width)
d1009 23
a1031 24
	    case 2: value = bfd_get_16 (abfd, buf); break;
	    case 4: value = bfd_get_32 (abfd, buf); break;
	    case 8: value = bfd_get_64 (abfd, buf); break;
	    default: BFD_FAIL ();
	    }
	  address = value;
	  switch (sec_info->entry[i].fde_encoding & 0xf0)
	    {
	    case DW_EH_PE_indirect:
	    case DW_EH_PE_textrel:
	      BFD_ASSERT (hdr_info == NULL);
	      break;
	    case DW_EH_PE_datarel:
	      {
		asection *got = bfd_get_section_by_name (abfd, ".got");

	        BFD_ASSERT (got != NULL);
		address += got->vma;
	      }
	      break;
	    case DW_EH_PE_pcrel:
	      value += (sec_info->entry[i].offset
		        - sec_info->entry[i].new_offset);
	      address += (sec->output_section->vma + sec->output_offset
d1033 1
a1033 10
	      break;
	    }
	  if (sec_info->entry[i].make_relative)
	    value -= (sec->output_section->vma + sec->output_offset
		      + sec_info->entry[i].new_offset + 8);
	  switch (fde_width)
	    {
	    case 2: bfd_put_16 (abfd, value, buf); break;
	    case 4: bfd_put_32 (abfd, value, buf); break;
	    case 8: bfd_put_64 (abfd, value, buf); break;
d1042 21
@


1.1
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d89 1
d250 1
a250 1
  struct eh_frame_sec_info *sec_info;
d271 5
d279 6
a284 14
  if (ehbuf == NULL
      || ! bfd_get_section_contents (abfd, sec, ehbuf, (bfd_vma) 0,
				     sec->_raw_size))
    {
      if (elf_section_data (ehdrsec)->sec_info_type
	  != ELF_INFO_TYPE_EH_FRAME_HDR)
	{
	  elf_section_data (ehdrsec)->sec_info
	    = bfd_zmalloc (sizeof (struct eh_frame_hdr_info));
	  elf_section_data (ehdrsec)->sec_info_type
	    = ELF_INFO_TYPE_EH_FRAME_HDR;
	}
      return false;
    }
a294 14
  if (elf_section_data (ehdrsec)->sec_info_type
      != ELF_INFO_TYPE_EH_FRAME_HDR)
    {
      hdr_info = (struct eh_frame_hdr_info *)      
		 bfd_zmalloc (sizeof (struct eh_frame_hdr_info));
      hdr_info->table = true;
      elf_section_data (ehdrsec)->sec_info = hdr_info;
      elf_section_data (ehdrsec)->sec_info_type
	= ELF_INFO_TYPE_EH_FRAME_HDR;
    }
  else
    hdr_info = (struct eh_frame_hdr_info *)
	       elf_section_data (ehdrsec)->sec_info;

d298 1
a298 1
    return false;
d637 1
d641 2
d676 2
d685 46
@

