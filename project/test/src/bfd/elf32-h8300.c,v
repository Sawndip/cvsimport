head	1.64;
access;
symbols
	sid-snapshot-20180601:1.64
	sid-snapshot-20180501:1.64
	sid-snapshot-20180401:1.64
	sid-snapshot-20180301:1.64
	sid-snapshot-20180201:1.64
	sid-snapshot-20180101:1.64
	sid-snapshot-20171201:1.64
	sid-snapshot-20171101:1.64
	sid-snapshot-20171001:1.64
	sid-snapshot-20170901:1.64
	sid-snapshot-20170801:1.64
	sid-snapshot-20170701:1.64
	sid-snapshot-20170601:1.64
	sid-snapshot-20170501:1.64
	sid-snapshot-20170401:1.64
	sid-snapshot-20170301:1.64
	sid-snapshot-20170201:1.64
	sid-snapshot-20170101:1.64
	sid-snapshot-20161201:1.64
	sid-snapshot-20161101:1.64
	sid-snapshot-20160901:1.64
	sid-snapshot-20160801:1.64
	sid-snapshot-20160701:1.64
	sid-snapshot-20160601:1.64
	sid-snapshot-20160501:1.64
	sid-snapshot-20160401:1.64
	sid-snapshot-20160301:1.64
	sid-snapshot-20160201:1.64
	sid-snapshot-20160101:1.64
	sid-snapshot-20151201:1.64
	sid-snapshot-20151101:1.64
	sid-snapshot-20151001:1.64
	sid-snapshot-20150901:1.64
	sid-snapshot-20150801:1.64
	sid-snapshot-20150701:1.64
	sid-snapshot-20150601:1.64
	sid-snapshot-20150501:1.64
	sid-snapshot-20150401:1.64
	sid-snapshot-20150301:1.64
	sid-snapshot-20150201:1.64
	sid-snapshot-20150101:1.64
	sid-snapshot-20141201:1.64
	sid-snapshot-20141101:1.64
	sid-snapshot-20141001:1.64
	sid-snapshot-20140901:1.64
	sid-snapshot-20140801:1.64
	sid-snapshot-20140701:1.64
	sid-snapshot-20140601:1.64
	sid-snapshot-20140501:1.64
	sid-snapshot-20140401:1.64
	sid-snapshot-20140301:1.64
	sid-snapshot-20140201:1.64
	sid-snapshot-20140101:1.64
	sid-snapshot-20131201:1.64
	sid-snapshot-20131101:1.64
	sid-snapshot-20131001:1.64
	binutils-2_24-branch:1.64.0.2
	binutils-2_24-branchpoint:1.64
	binutils-2_21_1:1.58
	sid-snapshot-20130901:1.64
	gdb_7_6_1-2013-08-30-release:1.62
	sid-snapshot-20130801:1.64
	sid-snapshot-20130701:1.64
	sid-snapshot-20130601:1.64
	sid-snapshot-20130501:1.64
	gdb_7_6-2013-04-26-release:1.62
	sid-snapshot-20130401:1.64
	binutils-2_23_2:1.61
	gdb_7_6-branch:1.62.0.2
	gdb_7_6-2013-03-12-branchpoint:1.62
	sid-snapshot-20130301:1.62
	sid-snapshot-20130201:1.62
	sid-snapshot-20130101:1.61
	sid-snapshot-20121201:1.61
	gdb_7_5_1-2012-11-29-release:1.61
	binutils-2_23_1:1.61
	sid-snapshot-20121101:1.61
	binutils-2_23:1.61
	sid-snapshot-20121001:1.61
	sid-snapshot-20120901:1.61
	gdb_7_5-2012-08-17-release:1.61
	sid-snapshot-20120801:1.61
	binutils-2_23-branch:1.61.0.4
	binutils-2_23-branchpoint:1.61
	gdb_7_5-branch:1.61.0.2
	gdb_7_5-2012-07-18-branchpoint:1.61
	sid-snapshot-20120701:1.60
	sid-snapshot-20120601:1.60
	sid-snapshot-20120501:1.59
	binutils-2_22_branch:1.58.0.10
	gdb_7_4_1-2012-04-26-release:1.58
	sid-snapshot-20120401:1.58
	sid-snapshot-20120301:1.58
	sid-snapshot-20120201:1.58
	gdb_7_4-2012-01-24-release:1.58
	sid-snapshot-20120101:1.58
	gdb_7_4-branch:1.58.0.8
	gdb_7_4-2011-12-13-branchpoint:1.58
	sid-snapshot-20111201:1.58
	binutils-2_22:1.58
	sid-snapshot-20111101:1.58
	sid-snapshot-20111001:1.58
	binutils-2_22-branch:1.58.0.6
	binutils-2_22-branchpoint:1.58
	gdb_7_3_1-2011-09-04-release:1.58
	sid-snapshot-20110901:1.58
	sid-snapshot-20110801:1.58
	gdb_7_3-2011-07-26-release:1.58
	sid-snapshot-20110701:1.58
	sid-snapshot-20110601:1.58
	sid-snapshot-20110501:1.58
	gdb_7_3-branch:1.58.0.4
	gdb_7_3-2011-04-01-branchpoint:1.58
	sid-snapshot-20110401:1.58
	sid-snapshot-20110301:1.58
	sid-snapshot-20110201:1.58
	sid-snapshot-20110101:1.58
	binutils-2_21:1.58
	sid-snapshot-20101201:1.58
	binutils-2_21-branch:1.58.0.2
	binutils-2_21-branchpoint:1.58
	sid-snapshot-20101101:1.58
	sid-snapshot-20101001:1.57
	binutils-2_20_1:1.55
	gdb_7_2-2010-09-02-release:1.57
	sid-snapshot-20100901:1.57
	sid-snapshot-20100801:1.57
	gdb_7_2-branch:1.57.0.2
	gdb_7_2-2010-07-07-branchpoint:1.57
	sid-snapshot-20100701:1.57
	sid-snapshot-20100601:1.55
	sid-snapshot-20100501:1.55
	sid-snapshot-20100401:1.55
	gdb_7_1-2010-03-18-release:1.55
	sid-snapshot-20100301:1.55
	gdb_7_1-branch:1.55.0.6
	gdb_7_1-2010-02-18-branchpoint:1.55
	sid-snapshot-20100201:1.55
	sid-snapshot-20100101:1.55
	gdb_7_0_1-2009-12-22-release:1.55
	sid-snapshot-20091201:1.55
	sid-snapshot-20091101:1.55
	binutils-2_20:1.55
	gdb_7_0-2009-10-06-release:1.55
	sid-snapshot-20091001:1.55
	gdb_7_0-branch:1.55.0.4
	gdb_7_0-2009-09-16-branchpoint:1.55
	arc-sim-20090309:1.53
	binutils-arc-20081103-branch:1.53.0.26
	binutils-arc-20081103-branchpoint:1.53
	binutils-2_20-branch:1.55.0.2
	binutils-2_20-branchpoint:1.55
	sid-snapshot-20090901:1.54
	sid-snapshot-20090801:1.54
	msnyder-checkpoint-072509-branch:1.54.0.4
	msnyder-checkpoint-072509-branchpoint:1.54
	sid-snapshot-20090701:1.54
	dje-cgen-play1-branch:1.54.0.2
	dje-cgen-play1-branchpoint:1.54
	sid-snapshot-20090601:1.54
	sid-snapshot-20090501:1.54
	sid-snapshot-20090401:1.53
	arc-20081103-branch:1.53.0.24
	arc-20081103-branchpoint:1.53
	arc-insight_6_8-branch:1.53.0.22
	arc-insight_6_8-branchpoint:1.53
	insight_6_8-branch:1.53.0.20
	insight_6_8-branchpoint:1.53
	sid-snapshot-20090301:1.53
	binutils-2_19_1:1.53
	sid-snapshot-20090201:1.53
	sid-snapshot-20090101:1.53
	reverse-20081226-branch:1.53.0.18
	reverse-20081226-branchpoint:1.53
	sid-snapshot-20081201:1.53
	multiprocess-20081120-branch:1.53.0.16
	multiprocess-20081120-branchpoint:1.53
	sid-snapshot-20081101:1.53
	binutils-2_19:1.53
	sid-snapshot-20081001:1.53
	reverse-20080930-branch:1.53.0.14
	reverse-20080930-branchpoint:1.53
	binutils-2_19-branch:1.53.0.12
	binutils-2_19-branchpoint:1.53
	sid-snapshot-20080901:1.53
	sid-snapshot-20080801:1.53
	reverse-20080717-branch:1.53.0.10
	reverse-20080717-branchpoint:1.53
	sid-snapshot-20080701:1.53
	msnyder-reverse-20080609-branch:1.53.0.8
	msnyder-reverse-20080609-branchpoint:1.53
	drow-reverse-20070409-branch:1.51.0.2
	drow-reverse-20070409-branchpoint:1.51
	sid-snapshot-20080601:1.53
	sid-snapshot-20080501:1.53
	sid-snapshot-20080403:1.53
	sid-snapshot-20080401:1.53
	gdb_6_8-2008-03-27-release:1.53
	sid-snapshot-20080301:1.53
	gdb_6_8-branch:1.53.0.6
	gdb_6_8-2008-02-26-branchpoint:1.53
	sid-snapshot-20080201:1.53
	sid-snapshot-20080101:1.53
	sid-snapshot-20071201:1.53
	sid-snapshot-20071101:1.53
	gdb_6_7_1-2007-10-29-release:1.53
	gdb_6_7-2007-10-10-release:1.53
	sid-snapshot-20071001:1.53
	gdb_6_7-branch:1.53.0.4
	gdb_6_7-2007-09-07-branchpoint:1.53
	binutils-2_18:1.53
	binutils-2_18-branch:1.53.0.2
	binutils-2_18-branchpoint:1.53
	insight_6_6-20070208-release:1.49
	binutils-csl-coldfire-4_1-32:1.48
	binutils-csl-sourcerygxx-4_1-32:1.48
	gdb_6_6-2006-12-18-release:1.49
	binutils-csl-innovasic-fido-3_4_4-33:1.48
	binutils-csl-sourcerygxx-3_4_4-32:1.46
	binutils-csl-coldfire-4_1-30:1.48
	binutils-csl-sourcerygxx-4_1-30:1.48
	binutils-csl-coldfire-4_1-28:1.48
	binutils-csl-sourcerygxx-4_1-29:1.48
	binutils-csl-sourcerygxx-4_1-28:1.48
	gdb_6_6-branch:1.49.0.2
	gdb_6_6-2006-11-15-branchpoint:1.49
	binutils-csl-arm-2006q3-27:1.48
	binutils-csl-sourcerygxx-4_1-27:1.48
	binutils-csl-arm-2006q3-26:1.48
	binutils-csl-sourcerygxx-4_1-26:1.48
	binutils-csl-sourcerygxx-4_1-25:1.48
	binutils-csl-sourcerygxx-4_1-24:1.48
	binutils-csl-sourcerygxx-4_1-23:1.48
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.48
	binutils-csl-sourcerygxx-4_1-21:1.48
	binutils-csl-arm-2006q3-21:1.48
	binutils-csl-sourcerygxx-4_1-22:1.48
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48
	binutils-csl-sourcerygxx-4_1-20:1.48
	binutils-csl-arm-2006q3-19:1.48
	binutils-csl-sourcerygxx-4_1-19:1.48
	binutils-csl-sourcerygxx-4_1-18:1.48
	binutils-csl-renesas-4_1-9:1.48
	gdb-csl-sourcerygxx-3_4_4-25:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.46
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.48
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	gdb-csl-sourcerygxx-4_1-17:1.48
	binutils-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.48
	gdb-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	gdb-csl-sourcerygxx-4_1-13:1.48
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48
	gdb-csl-sourcerygxx-4_1-12:1.48
	binutils-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.48
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.46
	binutils-csl-wrs-linux-3_4_4-23:1.46
	gdb-csl-sourcerygxx-4_1-9:1.48
	binutils-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.48
	binutils-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.48
	binutils-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.48
	binutils-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.46
	gdb-csl-symbian-6_4_50_20060226-10:1.48
	gdb-csl-symbian-6_4_50_20060226-9:1.48
	gdb-csl-symbian-6_4_50_20060226-8:1.48
	gdb-csl-coldfire-4_1-11:1.48
	binutils-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.48
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.48
	gdb_6_5-branch:1.48.0.30
	gdb_6_5-2006-05-14-branchpoint:1.48
	binutils-csl-coldfire-4_1-10:1.48
	gdb-csl-sourcerygxx-4_1-5:1.48
	binutils-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.48.0.28
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.48
	binutils-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.26
	msnyder-reverse-20060502-branchpoint:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.46
	gdb-csl-morpho-4_1-4:1.48
	binutils-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.46
	readline_5_1-import-branch:1.48.0.24
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.48
	binutils-2_17-branch:1.48.0.22
	binutils-2_17-branchpoint:1.48
	gdb-csl-symbian-20060226-branch:1.48.0.20
	gdb-csl-symbian-20060226-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.48
	msnyder-reverse-20060331-branch:1.48.0.18
	msnyder-reverse-20060331-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.16
	binutils-csl-2_17-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.14
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.48.0.12
	gdb-csl-20060226-branchpoint:1.48
	gdb_6_4-20051202-release:1.48
	msnyder-fork-checkpoint-branch:1.48.0.10
	msnyder-fork-checkpoint-branchpoint:1.48
	gdb-csl-gxxpro-6_3-branch:1.48.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.48
	gdb_6_4-branch:1.48.0.6
	gdb_6_4-2005-11-01-branchpoint:1.48
	gdb-csl-arm-20051020-branch:1.48.0.4
	gdb-csl-arm-20051020-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.46.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.46
	binutils-2_16_1:1.46
	msnyder-tracepoint-checkpoint-branch:1.48.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.48
	gdb-csl-arm-20050325-2005-q1b:1.46
	binutils-csl-arm-2005q1b:1.46
	binutils-2_16:1.46
	gdb-csl-arm-20050325-2005-q1a:1.46
	binutils-csl-arm-2005q1a:1.46
	csl-arm-20050325-branch:1.46.0.6
	csl-arm-20050325-branchpoint:1.46
	binutils-csl-arm-2005q1-branch:1.46.0.4
	binutils-csl-arm-2005q1-branchpoint:1.46
	binutils-2_16-branch:1.46.0.2
	binutils-2_16-branchpoint:1.46
	csl-arm-2004-q3d:1.46
	gdb_6_3-20041109-release:1.45
	gdb_6_3-branch:1.45.0.4
	gdb_6_3-20041019-branchpoint:1.45
	csl-arm-2004-q3:1.45
	drow_intercu-merge-20040921:1.45
	drow_intercu-merge-20040915:1.45
	jimb-gdb_6_2-e500-branch:1.45.0.6
	jimb-gdb_6_2-e500-branchpoint:1.45
	gdb_6_2-20040730-release:1.45
	gdb_6_2-branch:1.45.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.45
	gdb_6_1_1-20040616-release:1.41
	binutils-2_15:1.41.4.1
	binutils-2_15-branchpoint:1.41
	csl-arm-2004-q1a:1.44
	csl-arm-2004-q1:1.44
	gdb_6_1-2004-04-05-release:1.41
	drow_intercu-merge-20040402:1.44
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.43.0.2
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.42
	cagney_tramp-20040309-branch:1.41.0.10
	cagney_tramp-20040309-branchpoint:1.41
	gdb_6_1-branch:1.41.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.41
	drow_intercu-20040221-branch:1.41.0.6
	drow_intercu-20040221-branchpoint:1.41
	binutils-2_15-branch:1.41.0.4
	cagney_bfdfile-20040213-branch:1.41.0.2
	cagney_bfdfile-20040213-branchpoint:1.41
	drow-cplus-merge-20040208:1.40
	carlton_dictionary-20040126-merge:1.40
	cagney_bigcore-20040122-branch:1.40.0.2
	cagney_bigcore-20040122-branchpoint:1.40
	drow-cplus-merge-20040113:1.37
	csl-arm-2003-q4:1.34
	drow-cplus-merge-20031224:1.34
	drow-cplus-merge-20031220:1.34
	carlton_dictionary-20031215-merge:1.34
	drow-cplus-merge-20031214:1.34
	carlton-dictionary-20031111-merge:1.33
	gdb_6_0-2003-10-04-release:1.27
	kettenis_sparc-20030918-branch:1.31.0.6
	kettenis_sparc-20030918-branchpoint:1.31
	carlton_dictionary-20030917-merge:1.31
	ezannoni_pie-20030916-branchpoint:1.31
	ezannoni_pie-20030916-branch:1.31.0.4
	cagney_x86i386-20030821-branch:1.31.0.2
	cagney_x86i386-20030821-branchpoint:1.31
	carlton_dictionary-20030805-merge:1.31
	carlton_dictionary-20030627-merge:1.28
	gdb_6_0-branch:1.27.0.4
	gdb_6_0-2003-06-23-branchpoint:1.27
	jimb-ppc64-linux-20030613-branch:1.27.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.27
	binutils-2_14:1.22
	cagney_convert-20030606-branch:1.26.0.6
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.24.0.4
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.26.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.2
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.24.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	binutils-2_14-branch:1.22.0.2
	binutils-2_14-branchpoint:1.22
	kettenis_i386newframe-20030419-branch:1.21.0.2
	kettenis_i386newframe-20030419-branchpoint:1.21
	carlton_dictionary-20030416-merge:1.21
	cagney_frameaddr-20030409-mergepoint:1.20
	kettenis_i386newframe-20030406-branch:1.20.0.18
	kettenis_i386newframe-20030406-branchpoint:1.20
	cagney_frameaddr-20030403-branchpoint:1.20
	cagney_frameaddr-20030403-branch:1.20.0.16
	cagney_framebase-20030330-mergepoint:1.20
	cagney_framebase-20030326-branch:1.20.0.14
	cagney_framebase-20030326-branchpoint:1.20
	cagney_lazyid-20030317-branch:1.20.0.12
	cagney_lazyid-20030317-branchpoint:1.20
	kettenis-i386newframe-20030316-mergepoint:1.20
	offbyone-20030313-branch:1.20.0.10
	offbyone-20030313-branchpoint:1.20
	kettenis-i386newframe-20030308-branch:1.20.0.8
	kettenis-i386newframe-20030308-branchpoint:1.20
	carlton_dictionary-20030305-merge:1.20
	cagney_offbyone-20030303-branch:1.20.0.6
	cagney_offbyone-20030303-branchpoint:1.20
	carlton_dictionary-20030207-merge:1.20
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	binutils-2_13_2_1:1.14.2.2
	binutils-2_13_2:1.14.2.2
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.18
	binutils-2_13_1:1.14.2.1
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.4
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.2
	carlton_dictionary-20020920-branchpoint:1.16
	sid-20020905-branchpoint:1.15
	sid-20020905-branch:1.15.0.8
	gdb_5_3-branch:1.15.0.6
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.4
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.2
	readline_4_3-import-branchpoint:1.15
	binutils-2_13:1.14
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.14
	binutils-2_13-branch:1.14.0.2
	kseitz_interps-20020528-branch:1.10.0.10
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.8
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.10.0.6
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	cygnus_cvs_20020108_pre:1.10
	binutils_latest_snapshot:1.64;
locks; strict;
comment	@ * @;


1.64
date	2013.03.22.15.53.36;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.21.16.08.06;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.25.14.22.10;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.24.05.12.33;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches
	1.58.6.1;
next	1.57;

1.57
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.14.18.43.46;	author kevinb;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.07.18.21.21;	author dj;	state Exp;
branches;
next	1.53;

1.53
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.04.15.53.13;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.21.15.28.21;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.24.04.46.19;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.22.02.28.15;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.20.23.16.39;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.09.12.15.57;	author nickc;	state Exp;
branches
	1.41.4.1
	1.41.6.1
	1.41.10.1;
next	1.40;

1.40
date	2004.01.19.17.02.45;	author kazu;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.16.23.50.20;	author kazu;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.16.23.35.49;	author kazu;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.12.15.02.18;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.11.08.05.10;	author kazu;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.01.10.01.45;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.15.19.08.10;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.11.14.59.40;	author rsandifo;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.11.11.08.30;	author rsandifo;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.04.10.25.14;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.10.07.09.30;	author rsandifo;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.16.23.39.24;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.12.08.50.19;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.09.02.27.02;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.30.12.03.58;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.24.12.36.06;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.28.11.55.39;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.15.11.18.47;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.11.05.05.22;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.11.19.19.11;	author law;	state Exp;
branches
	1.16.2.1
	1.16.4.1;
next	1.15;

1.15
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.06.06.21.33.11;	author law;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.06.00.29.20;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.05.13.31.59;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.17.00.52.34;	author amodra;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2001.11.23.12.17.15;	author jakub;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.04.21.06.01;	author law;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.04.17.29.36;	author law;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.30.02.15.58;	author law;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.30.00.08.12;	author law;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.29.17.23.16;	author law;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.29.01.33.52;	author amylaar;	state Exp;
branches;
next	;

1.58.6.1
date	2012.05.11.12.24.23;	author nickc;	state Exp;
branches;
next	;

1.41.4.1
date	2004.04.08.12.41.40;	author amodra;	state Exp;
branches;
next	;

1.41.6.1
date	2004.03.27.17.37.32;	author drow;	state Exp;
branches;
next	1.41.6.2;

1.41.6.2
date	2004.04.02.16.47.34;	author drow;	state Exp;
branches;
next	1.41.6.3;

1.41.6.3
date	2004.09.16.17.00.22;	author drow;	state Exp;
branches;
next	;

1.41.10.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;

1.21.2.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.05.18.09.43.40;	author kettenis;	state Exp;
branches;
next	;

1.16.2.1
date	2002.11.15.19.18.26;	author carlton;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.12.23.19.37.40;	author carlton;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2003.05.01.00.46.40;	author carlton;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2003.05.23.18.40.22;	author carlton;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.06.27.21.49.13;	author carlton;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.08.05.17.12.46;	author carlton;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2003.11.11.23.50.16;	author carlton;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2003.12.15.23.59.23;	author carlton;	state Exp;
branches;
next	1.16.2.10;

1.16.2.10
date	2004.01.26.19.11.04;	author carlton;	state Exp;
branches;
next	;

1.16.4.1
date	2003.12.14.20.26.39;	author drow;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2004.01.13.16.11.36;	author drow;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.14.2.1
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.12.16.03.52.33;	author kazu;	state Exp;
branches;
next	;

1.10.8.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.10.10.1
date	2002.06.20.01.30.07;	author kseitz;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2002.07.22.21.46.43;	author kseitz;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	1.10.10.4;

1.10.10.4
date	2002.10.01.00.45.46;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.64
log
@	PR ld/14902
	* elf32-h8300.c (elf32_h8_relax_delete_bytes): Fix off by one
	errors adjusting relocs and symbols.
@
text
@/* BFD back-end for Renesas H8/300 ELF binaries.
   Copyright 1993-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/h8.h"

static reloc_howto_type *elf32_h8_reloc_type_lookup
  (bfd *abfd, bfd_reloc_code_real_type code);
static void elf32_h8_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);
static void elf32_h8_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);
static unsigned long elf32_h8_mach (flagword);
static void elf32_h8_final_write_processing (bfd *, bfd_boolean);
static bfd_boolean elf32_h8_object_p (bfd *);
static bfd_boolean elf32_h8_merge_private_bfd_data (bfd *, bfd *);
static bfd_boolean elf32_h8_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean elf32_h8_relax_delete_bytes
  (bfd *, asection *, bfd_vma, int);
static bfd_boolean elf32_h8_symbol_address_p (bfd *, asection *, bfd_vma);
static bfd_byte *elf32_h8_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
   bfd_byte *, bfd_boolean, asymbol **);
static bfd_reloc_status_type elf32_h8_final_link_relocate
  (unsigned long, bfd *, bfd *, asection *,
   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
   struct bfd_link_info *, asection *, int);
static bfd_boolean elf32_h8_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *,
   bfd_byte *, Elf_Internal_Rela *,
   Elf_Internal_Sym *, asection **);
static bfd_reloc_status_type special
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);

/* This does not include any relocation information, but should be
   good enough for GDB or objdump to read the file.  */

static reloc_howto_type h8_elf_howto_table[] =
{
#define R_H8_NONE_X 0
  HOWTO (R_H8_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR32_X (R_H8_NONE_X + 1)
  HOWTO (R_H8_DIR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR16_X (R_H8_DIR32_X + 1)
  HOWTO (R_H8_DIR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR8_X (R_H8_DIR16_X + 1)
  HOWTO (R_H8_DIR8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR16A8_X (R_H8_DIR8_X + 1)
  HOWTO (R_H8_DIR16A8,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR16A8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR16R8_X (R_H8_DIR16A8_X + 1)
  HOWTO (R_H8_DIR16R8,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR16R8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR24A8_X (R_H8_DIR16R8_X + 1)
  HOWTO (R_H8_DIR24A8,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR24A8",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff000000,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR24R8_X (R_H8_DIR24A8_X + 1)
  HOWTO (R_H8_DIR24R8,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR24R8",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff000000,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DIR32A16_X (R_H8_DIR24R8_X + 1)
  HOWTO (R_H8_DIR32A16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR32A16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_DISP32A16_X (R_H8_DIR32A16_X + 1)
  HOWTO (R_H8_DISP32A16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DISP32A16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#define R_H8_PCREL16_X (R_H8_DISP32A16_X + 1)
  HOWTO (R_H8_PCREL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_PCREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
#define R_H8_PCREL8_X (R_H8_PCREL16_X + 1)
  HOWTO (R_H8_PCREL8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_PCREL8",		/* name */
	 FALSE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */
};

/* This structure is used to map BFD reloc codes to H8 ELF relocs.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char howto_index;
};

/* An array mapping BFD reloc codes to H8 ELF relocs.  */

static const struct elf_reloc_map h8_reloc_map[] = {
  { BFD_RELOC_NONE, R_H8_NONE_X },
  { BFD_RELOC_32, R_H8_DIR32_X },
  { BFD_RELOC_16, R_H8_DIR16_X },
  { BFD_RELOC_8, R_H8_DIR8_X },
  { BFD_RELOC_H8_DIR16A8, R_H8_DIR16A8_X },
  { BFD_RELOC_H8_DIR16R8, R_H8_DIR16R8_X },
  { BFD_RELOC_H8_DIR24A8, R_H8_DIR24A8_X },
  { BFD_RELOC_H8_DIR24R8, R_H8_DIR24R8_X },
  { BFD_RELOC_H8_DIR32A16, R_H8_DIR32A16_X },
  { BFD_RELOC_H8_DISP32A16, R_H8_DISP32A16_X },
  { BFD_RELOC_16_PCREL, R_H8_PCREL16_X },
  { BFD_RELOC_8_PCREL, R_H8_PCREL8_X },
};


static reloc_howto_type *
elf32_h8_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < sizeof (h8_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (h8_reloc_map[i].bfd_reloc_val == code)
	return &h8_elf_howto_table[(int) h8_reloc_map[i].howto_index];
    }
  return NULL;
}

static reloc_howto_type *
elf32_h8_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (h8_elf_howto_table) / sizeof (h8_elf_howto_table[0]);
       i++)
    if (h8_elf_howto_table[i].name != NULL
	&& strcasecmp (h8_elf_howto_table[i].name, r_name) == 0)
      return &h8_elf_howto_table[i];

  return NULL;
}

static void
elf32_h8_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			Elf_Internal_Rela *elf_reloc)
{
  unsigned int r;
  unsigned int i;

  r = ELF32_R_TYPE (elf_reloc->r_info);
  for (i = 0; i < sizeof (h8_elf_howto_table) / sizeof (reloc_howto_type); i++)
    if (h8_elf_howto_table[i].type == r)
      {
	bfd_reloc->howto = &h8_elf_howto_table[i];
	return;
      }
  abort ();
}

static void
elf32_h8_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			    Elf_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED)
{
  unsigned int r;

  abort ();
  r = ELF32_R_TYPE (elf_reloc->r_info);
  bfd_reloc->howto = &h8_elf_howto_table[r];
}

/* Special handling for H8/300 relocs.
   We only come here for pcrel stuff and return normally if not an -r link.
   When doing -r, we can't do any arithmetic for the pcrel stuff, because
   we support relaxing on the H8/300 series chips.  */
static bfd_reloc_status_type
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 void * data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  /* Adjust the reloc address to that in the output section.  */
  reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* Perform a relocation as part of a final link.  */
static bfd_reloc_status_type
elf32_h8_final_link_relocate (unsigned long r_type, bfd *input_bfd,
			      bfd *output_bfd ATTRIBUTE_UNUSED,
			      asection *input_section ATTRIBUTE_UNUSED,
			      bfd_byte *contents, bfd_vma offset,
			      bfd_vma value, bfd_vma addend,
			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
			      asection *sym_sec ATTRIBUTE_UNUSED,
			      int is_local ATTRIBUTE_UNUSED)
{
  bfd_byte *hit_data = contents + offset;

  switch (r_type)
    {
    case R_H8_NONE:
      return bfd_reloc_ok;

    case R_H8_DIR32:
    case R_H8_DIR32A16:
    case R_H8_DISP32A16:
    case R_H8_DIR24A8:
      value += addend;
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_H8_DIR16:
    case R_H8_DIR16A8:
    case R_H8_DIR16R8:
      value += addend;
      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    /* AKA R_RELBYTE */
    case R_H8_DIR8:
      value += addend;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_H8_DIR24R8:
      value += addend;

      /* HIT_DATA is the address for the first byte for the relocated
	 value.  Subtract 1 so that we can manipulate the data in 32-bit
	 hunks.  */
      hit_data--;

      /* Clear out the top byte in value.  */
      value &= 0xffffff;

      /* Retrieve the type byte for value from the section contents.  */
      value |= (bfd_get_32 (input_bfd, hit_data) & 0xff000000);

      /* Now scribble it out in one 32-bit hunk.  */
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_H8_PCREL16:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      value += addend;

      /* The value is relative to the start of the instruction,
	 not the relocation offset.  Subtract 2 to account for
	 this minor issue.  */
      value -= 2;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_H8_PCREL8:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      value += addend;

      /* The value is relative to the start of the instruction,
	 not the relocation offset.  Subtract 1 to account for
	 this minor issue.  */
      value -= 1;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    default:
      return bfd_reloc_notsupported;
    }
}

/* Relocate an H8 ELF section.  */
static bfd_boolean
elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			   bfd *input_bfd, asection *input_section,
			   bfd_byte *contents, Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      arelent bfd_reloc;
      reloc_howto_type *howto;

      elf32_h8_info_to_howto (input_bfd, &bfd_reloc, rel);
      howto = bfd_reloc.howto;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      r = elf32_h8_final_link_relocate (r_type, input_bfd, output_bfd,
					input_section,
					contents, rel->r_offset,
					relocation, rel->r_addend,
					info, sec, h == NULL);

      if (r != bfd_reloc_ok)
	{
	  const char *name;
	  const char *msg = (const char *) 0;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
	      if (name == NULL || *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, name, input_bfd, input_section,
		      rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous error");
	      goto common_error;

	    default:
	      msg = _("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

/* Object files encode the specific H8 model they were compiled
   for in the ELF flags field.

   Examine that field and return the proper BFD machine type for
   the object file.  */
static unsigned long
elf32_h8_mach (flagword flags)
{
  switch (flags & EF_H8_MACH)
    {
    case E_H8_MACH_H8300:
    default:
      return bfd_mach_h8300;

    case E_H8_MACH_H8300H:
      return bfd_mach_h8300h;

    case E_H8_MACH_H8300S:
      return bfd_mach_h8300s;

    case E_H8_MACH_H8300HN:
      return bfd_mach_h8300hn;

    case E_H8_MACH_H8300SN:
      return bfd_mach_h8300sn;

    case E_H8_MACH_H8300SX:
      return bfd_mach_h8300sx;

    case E_H8_MACH_H8300SXN:
      return bfd_mach_h8300sxn;
    }
}

/* The final processing done just before writing out a H8 ELF object
   file.  We use this opportunity to encode the BFD machine type
   into the flags field in the object file.  */

static void
elf32_h8_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_h8300:
      val = E_H8_MACH_H8300;
      break;

    case bfd_mach_h8300h:
      val = E_H8_MACH_H8300H;
      break;

    case bfd_mach_h8300s:
      val = E_H8_MACH_H8300S;
      break;

    case bfd_mach_h8300hn:
      val = E_H8_MACH_H8300HN;
      break;

    case bfd_mach_h8300sn:
      val = E_H8_MACH_H8300SN;
      break;

    case bfd_mach_h8300sx:
      val = E_H8_MACH_H8300SX;
      break;

    case bfd_mach_h8300sxn:
      val = E_H8_MACH_H8300SXN;
      break;
    }

  elf_elfheader (abfd)->e_flags &= ~ (EF_H8_MACH);
  elf_elfheader (abfd)->e_flags |= val;
}

/* Return nonzero if ABFD represents a valid H8 ELF object file; also
   record the encoded machine type found in the ELF flags.  */

static bfd_boolean
elf32_h8_object_p (bfd *abfd)
{
  bfd_default_set_arch_mach (abfd, bfd_arch_h8300,
			     elf32_h8_mach (elf_elfheader (abfd)->e_flags));
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  The only data we need to copy at this
   time is the architecture/machine information.  */

static bfd_boolean
elf32_h8_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
      && bfd_get_mach (obfd) < bfd_get_mach (ibfd))
    {
      if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
			       bfd_get_mach (ibfd)))
	return FALSE;
    }

  return TRUE;
}

/* This function handles relaxing for the H8..

   There are a few relaxing opportunities available on the H8:

     jmp/jsr:24    ->    bra/bsr:8		2 bytes
     The jmp may be completely eliminated if the previous insn is a
     conditional branch to the insn after the jump.  In that case
     we invert the branch and delete the jump and save 4 bytes.

     bCC:16          ->    bCC:8                  2 bytes
     bsr:16          ->    bsr:8                  2 bytes

     bset:16	     ->    bset:8                 2 bytes
     bset:24/32	     ->    bset:8                 4 bytes
     (also applicable to other bit manipulation instructions)

     mov.b:16	     ->    mov.b:8                2 bytes
     mov.b:24/32     ->    mov.b:8                4 bytes

     bset:24/32	     ->    bset:16                2 bytes
     (also applicable to other bit manipulation instructions)

     mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes

     mov.[bwl] @@(displ:24/32+ERx) -> mov.[bwl] @@(displ:16+ERx)  4 bytes.  */

static bfd_boolean
elf32_h8_relax_section (bfd *abfd, asection *sec,
			struct bfd_link_info *link_info, bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  static asection *last_input_section = NULL;
  static Elf_Internal_Rela *last_reloc = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  if (sec != last_input_section)
    last_reloc = NULL;

  last_input_section = sec;

  /* Walk through the relocs looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      {
	arelent bfd_reloc;

	elf32_h8_info_to_howto (abfd, &bfd_reloc, irel);
      }
      /* Keep track of the previous reloc so that we can delete
	 some long jumps created by the compiler.  */
      if (irel != internal_relocs)
	last_reloc = irel - 1;
      
      switch(ELF32_R_TYPE (irel->r_info))
	{
	case R_H8_DIR24R8:
	case R_H8_PCREL16:
	case R_H8_DIR16A8:
	case R_H8_DIR24A8:
	case R_H8_DIR32A16:
	case R_H8_DISP32A16:
	  break;
	default:
	  continue;
	}

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = isym->st_value;
	  /* If the reloc is absolute, it will not have
	     a symbol or section associated with it.  */
	  if (sym_sec)
	    symval += sym_sec->output_section->vma
	      + sym_sec->output_offset;
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */
      switch (ELF32_R_TYPE (irel->r_info))
	{
	  /* Try to turn a 24-bit absolute branch/call into an 8-bit
	     pc-relative branch/call.  */
	case R_H8_DIR24R8:
	  {
	    bfd_vma value = symval + irel->r_addend;
	    bfd_vma dot, gap;

	    /* Get the address of this instruction.  */
	    dot = (sec->output_section->vma
		   + sec->output_offset + irel->r_offset - 1);

	    /* Compute the distance from this insn to the branch target.  */
	    gap = value - dot;

	    /* If the distance is within -126..+130 inclusive, then we can
	       relax this jump.  +130 is valid since the target will move
	       two bytes closer if we do relax this branch.  */
	    if ((int) gap >= -126 && (int) gap <= 130)
	      {
		unsigned char code;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		/* Get the instruction code being relaxed.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		/* If the previous instruction conditionally jumped around
		   this instruction, we may be able to reverse the condition
		   and redirect the previous instruction to the target of
		   this instruction.

		   Such sequences are used by the compiler to deal with
		   long conditional branches.

		   Only perform this optimisation for jumps (code 0x5a) not
		   subroutine calls, as otherwise it could transform:

		   mov.w   r0,r0
		   beq     .L1
		   jsr     @@_bar
		   .L1:   rts
		   _bar:  rts
		   into:
		   mov.w   r0,r0
		   bne     _bar
		   rts
		   _bar:  rts

		   which changes the call (jsr) into a branch (bne).  */
		if (code == 0x5a	/* jmp24.  */
		    && (int) gap <= 130
		    && (int) gap >= -128
		    && last_reloc
		    && ELF32_R_TYPE (last_reloc->r_info) == R_H8_PCREL8
		    && ELF32_R_SYM (last_reloc->r_info) < symtab_hdr->sh_info)
		  {
		    bfd_vma last_value;
		    asection *last_sym_sec;
		    Elf_Internal_Sym *last_sym;

		    /* We will need to examine the symbol used by the
		       previous relocation.  */

		    last_sym = isymbuf + ELF32_R_SYM (last_reloc->r_info);
		    last_sym_sec
		      = bfd_section_from_elf_index (abfd, last_sym->st_shndx);
		    last_value = (last_sym->st_value
				  + last_sym_sec->output_section->vma
				  + last_sym_sec->output_offset);

		    /* Verify that the previous relocation was for a
		       branch around this instruction and that no symbol
		       exists at the current location.  */
		    if (last_value == dot + 4
			&& last_reloc->r_offset + 2 == irel->r_offset
			&& ! elf32_h8_symbol_address_p (abfd, sec, dot))
		      {
			/* We can eliminate this jump.  Twiddle the
			   previous relocation as necessary.  */
			irel->r_info
			  = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					  ELF32_R_TYPE (R_H8_NONE));

			last_reloc->r_info
			  = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					  ELF32_R_TYPE (R_H8_PCREL8));
			last_reloc->r_addend = irel->r_addend;

			code = bfd_get_8 (abfd,
					  contents + last_reloc->r_offset - 1);
			code ^= 1;
			bfd_put_8 (abfd,
				   code,
				   contents + last_reloc->r_offset - 1);

			/* Delete four bytes of data.  */
			if (!elf32_h8_relax_delete_bytes (abfd, sec,
							  irel->r_offset - 1,
							  4))
			  goto error_return;

			*again = TRUE;
			break;
		      }
		  }

		if (code == 0x5e)
		  /* This is jsr24  */
		  bfd_put_8 (abfd, 0x55, contents + irel->r_offset - 1);	/* bsr8. */
		else if (code == 0x5a)
		  /* This is jmp24  */
		  bfd_put_8 (abfd, 0x40, contents + irel->r_offset - 1);	/* bra8. */
		else
		  abort ();

		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_PCREL8);

		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 2))
		  goto error_return;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
	      }
	    break;
	  }

	  /* Try to turn a 16-bit pc-relative branch into a 8-bit pc-relative
	     branch.  */
	case R_H8_PCREL16:
	  {
	    bfd_vma value = symval + irel->r_addend;
	    bfd_vma dot;
	    bfd_vma gap;

	    /* Get the address of this instruction.  */
	    dot = (sec->output_section->vma
		   + sec->output_offset
		   + irel->r_offset - 2);

	    gap = value - dot;

	    /* If the distance is within -126..+130 inclusive, then we can
	       relax this jump.  +130 is valid since the target will move
	       two bytes closer if we do relax this branch.  */
	    if ((int) gap >= -126 && (int) gap <= 130)
	      {
		unsigned char code;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);

		if (code == 0x58)
		  {
		    /* bCC:16 -> bCC:8 */
		    /* Get the second byte of the original insn, which
		       contains the condition code.  */
		    code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		    /* Compute the first byte of the relaxed
		       instruction.  The original sequence 0x58 0xX0
		       is relaxed to 0x4X, where X represents the
		       condition code.  */
		    code &= 0xf0;
		    code >>= 4;
		    code |= 0x40;
		    bfd_put_8 (abfd, code, contents + irel->r_offset - 2); /* bCC:8.  */
		  }
		else if (code == 0x5c)	/* bsr16.  */
		  /* This is bsr.  */
		  bfd_put_8 (abfd, 0x55, contents + irel->r_offset - 2);  /* bsr8.  */
		else
		  /* Might be MOVSD.  */
		  break;

		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_PCREL8);
		irel->r_offset--;

		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 2))
		  goto error_return;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
	      }
	    break;
	  }

	  /* This is a 16-bit absolute address in one of the following
	     instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	     We may relax this into an 8-bit absolute address if it's in
	     the right range.  */
	case R_H8_DIR16A8:
	  {
	    bfd_vma value;

	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
	      {
		unsigned char code;
		unsigned char temp_code;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);

		/* All instructions with R_H8_DIR16A8 start with
		   0x6a.  */
		if (code != 0x6a)
		  abort ();

		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
		if ((temp_code & 0x10) != 0x10)
		  temp_code &= 0xf0;

		switch (temp_code)
		  {
		  case 0x00:
		    /* This is mov.b @@aa:16,Rd.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x80:
		    /* This is mov.b Rs,@@aa:16.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x18:
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x10:
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
		  default:
		    abort ();
		  }

		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_DIR8);

		/* Move the relocation.  */
		irel->r_offset--;

		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 2))
		  goto error_return;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
	      }
	    break;
	  }

	  /* This is a 24-bit absolute address in one of the following
	     instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	     We may relax this into an 8-bit absolute address if it's in
	     the right range.  */
	case R_H8_DIR24A8:
	  {
	    bfd_vma value;

	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
	      {
		unsigned char code;
		unsigned char temp_code;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);

		/* All instructions with R_H8_DIR24A8 start with
		   0x6a.  */
		if (code != 0x6a)
		  abort ();

		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
		if ((temp_code & 0x30) != 0x30)
		  temp_code &= 0xf0;

		switch (temp_code)
		  {
		  case 0x20:
		    /* This is mov.b @@aa:24/32,Rd.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0xa0:
		    /* This is mov.b Rs,@@aa:24/32.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x38:
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x30:
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
		  default:
		    abort();
		  }

		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_DIR8);
		irel->r_offset--;

		/* Delete four bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 4))
		  goto error_return;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
		break;
	      }
	  }

	  /* Fall through.  */

	  /* This is a 24-/32-bit absolute address in one of the
	     following instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist",
	     "bixor", "bld", "bnot", "bor", "bset", "bst", "btst",
	     "bxor", "ldc.w", "stc.w" and "mov.[bwl]"

	     We may relax this into an 16-bit absolute address if it's
	     in the right range.  */
	case R_H8_DIR32A16:
	  {
	    bfd_vma value;

	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value <= 0x7fff || value >= 0xffff8000u)
	      {
		unsigned char code;
		unsigned char op0, op1, op2, op3;
		unsigned char *op_ptr;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		if (irel->r_offset >= 4)
		  {
		    /* Check for 4-byte MOVA relaxation (SH-specific).  */
		    int second_reloc = 0;

		    op_ptr = contents + irel->r_offset - 4;

		    if (last_reloc)
		      {
			arelent bfd_reloc;
			reloc_howto_type *h;
			bfd_vma last_reloc_size;

			elf32_h8_info_to_howto (abfd, &bfd_reloc, last_reloc);
			h = bfd_reloc.howto;
			last_reloc_size = 1 << h->size;
			if (last_reloc->r_offset + last_reloc_size
			    == irel->r_offset)
			  {
			    op_ptr -= last_reloc_size;
			    second_reloc = 1;
			  }
		      }

		    if (irel + 1 < irelend)
		      {
			Elf_Internal_Rela *next_reloc = irel + 1;
			arelent bfd_reloc;
			reloc_howto_type *h;
			bfd_vma next_reloc_size;

			elf32_h8_info_to_howto (abfd, &bfd_reloc, next_reloc);
			h = bfd_reloc.howto;
			next_reloc_size = 1 << h->size;
			if (next_reloc->r_offset + next_reloc_size
			    == irel->r_offset)
			  {
			    op_ptr -= next_reloc_size;
			    second_reloc = 1;
			  }
		      }

		    op0 = bfd_get_8 (abfd, op_ptr + 0);
		    op1 = bfd_get_8 (abfd, op_ptr + 1);
		    op2 = bfd_get_8 (abfd, op_ptr + 2);
		    op3 = bfd_get_8 (abfd, op_ptr + 3);

		    if (op0 == 0x01
			&& (op1 & 0xdf) == 0x5f
			&& (op2 & 0x40) == 0x40
			&& (op3 & 0x80) == 0x80)
		      {
			if ((op2 & 0x08) == 0)
			  second_reloc = 1;

			if (second_reloc)
			  {
			    op3 &= ~0x08;
			    bfd_put_8 (abfd, op3, op_ptr + 3);
			  }
			else
			  {
			    op2 &= ~0x08;
			    bfd_put_8 (abfd, op2, op_ptr + 2);
			  }
			goto r_h8_dir32a16_common;
		      }
		  }

		/* Now check for short version of MOVA.  (SH-specific) */
		op_ptr = contents + irel->r_offset - 2;
		op0 = bfd_get_8 (abfd, op_ptr + 0);
		op1 = bfd_get_8 (abfd, op_ptr + 1);

		if (op0 == 0x7a
		    && (op1 & 0x88) == 0x80)
		  {
		    op1 |= 0x08;
		    bfd_put_8 (abfd, op1, op_ptr + 1);
		    goto r_h8_dir32a16_common;
		  }

		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		/* Fix the opcode.  For all the instructions that
		   belong to this relaxation, we simply need to turn
		   off bit 0x20 in the previous byte.  */
		code &= ~0x20;

		bfd_put_8 (abfd, code, contents + irel->r_offset - 1);

	      r_h8_dir32a16_common:
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_DIR16);

		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 2))
		  goto error_return;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
	      }
	    break;	/* case R_H8_DIR32A16 */
	  }

	case R_H8_DISP32A16:
	  /* mov.[bwl] @@(displ:24/32+ERx) -> mov.[bwl] @@(displ:16+ERx)  4 bytes
	     It is assured that instruction uses at least 4 bytes opcode before
	     reloc entry addressing mode "register indirect with displacement"
	     relaxing options (all saving 4 bytes):
	     0x78 0sss0000 0x6A 0010dddd disp:32  mov.b @@(d:32,ERs),Rd  ->
	     0x6E 0sssdddd disp:16  mov.b @@(d:16,ERs),Rd
	     0x78 0sss0000 0x6B 0010dddd disp:32  mov.w @@(d:32,ERs),Rd  ->
	     0x6F 0sssdddd disp:16  mov.w @@(d:16,ERs),Rd
	     0x01 0x00 0x78 0sss0000 0x6B 00100ddd disp:32  mov.l @@(d:32,ERs),ERd ->
	     0x01 0x00 0x6F 0sss0ddd disp:16  mov.l @@(d:16,ERs),ERd

	     0x78 0ddd0000 0x6A 1010ssss disp:32  mov.b Rs,@@(d:32,ERd)  ->
	     0x6E 1dddssss disp:16  mov.b Rs,@@(d:16,ERd)
	     0x78 0ddd0000 0x6B 1010ssss disp:32  mov.w Rs,@@(d:32,ERd)  ->
	     0x6F 1dddssss disp:16  mov.w Rs,@@(d:16,ERd)
	     0x01 0x00 0x78 xddd0000 0x6B 10100sss disp:32  mov.l ERs,@@(d:32,ERd) ->
	     0x01 0x00 0x6F 1ddd0sss disp:16  mov.l ERs,@@(d:16,ERd)
	     mov.l prefix 0x01 0x00 can be left as is and mov.l handled same
	     as mov.w/  */
	  {
	    bfd_vma value;

	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value <= 0x7fff || value >= 0xffff8000u)
	      {
		unsigned char op0, op1, op2, op3, op0n, op1n;
		int relax = 0;

		/* Note that we've changed the relocs, section contents,
		   etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		if (irel->r_offset >= 4)
		  {
		    op0 = bfd_get_8 (abfd, contents + irel->r_offset - 4);
		    op1 = bfd_get_8 (abfd, contents + irel->r_offset - 3);
		    op2 = bfd_get_8 (abfd, contents + irel->r_offset - 2);
		    op3 = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		    if (op0 == 0x78)
		      {
			switch(op2)
			  {
			  case 0x6A:
			    if ((op1 & 0x8F) == 0x00 && (op3 & 0x70) == 0x20)
			      {
				/* mov.b.  */
				op0n = 0x6E;
				relax = 1;
			      }
			    break;
			  case 0x6B:
			    if ((op1 & 0x0F) == 0x00 && (op3 & 0x70) == 0x20)
			      {
				/* mov.w/l.  */
				op0n = 0x6F;
				relax = 1;
			      }
			    break;
			  default:
			    break;
			  }
		      }
		  }

		if (relax)
		  {
		    op1n = (op3 & 0x8F) | (op1 & 0x70);
		    bfd_put_8 (abfd, op0n, contents + irel->r_offset - 4);
		    bfd_put_8 (abfd, op1n, contents + irel->r_offset - 3);

		    /* Fix the relocation's type.  */
		    irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_H8_DIR16);
		    irel->r_offset -= 2;

		    /* Delete four bytes of data.  */
		    if (!elf32_h8_relax_delete_bytes (abfd, sec, irel->r_offset + 2, 4))
		      goto error_return;

		    /* That will change things, so, we should relax again.
		       Note that this is not required, and it may be slow.  */
		    *again = TRUE;
		  }
	      }
	  }
	  break;

	default:
	  break;
	}
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	symtab_hdr->contents = (unsigned char *) isymbuf;
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
elf32_h8_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  bfd_vma toaddr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset <= toaddr))
	irel->r_offset -= count;
    }

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value <= toaddr)
	isym->st_value -= count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value <= toaddr)
	sym_hash->root.u.def.value -= count;
    }

  return TRUE;
}

/* Return TRUE if a symbol exists at the given address, else return
   FALSE.  */
static bfd_boolean
elf32_h8_symbol_address_p (bfd *abfd, asection *sec, bfd_vma addr)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  /* Examine all the symbols.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value == addr)
	return TRUE;
    }

  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value == addr)
	return TRUE;
    }

  return FALSE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses elf32_h8_relocate_section.  */

static bfd_byte *
elf32_h8_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  (size_t) input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      asection **secpp;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
      if (internal_relocs == NULL)
	goto error_return;

      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL && amt != 0)
	goto error_return;

      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
	{
	  asection *isec;

	  if (isym->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);

	  *secpp = isec;
	}

      if (! elf32_h8_relocate_section (output_bfd, link_info, input_bfd,
				       input_section, data, internal_relocs,
				       isymbuf, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
	free (internal_relocs);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
  return NULL;
}


#define TARGET_BIG_SYM			bfd_elf32_h8300_vec
#define TARGET_BIG_NAME			"elf32-h8300"
#define ELF_ARCH			bfd_arch_h8300
#define ELF_MACHINE_CODE		EM_H8_300
#define ELF_MAXPAGESIZE			0x1
#define bfd_elf32_bfd_reloc_type_lookup elf32_h8_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup elf32_h8_reloc_name_lookup
#define elf_info_to_howto		elf32_h8_info_to_howto
#define elf_info_to_howto_rel		elf32_h8_info_to_howto_rel

/* So we can set/examine bits in e_flags to get the specific
   H8 architecture in use.  */
#define elf_backend_final_write_processing \
  elf32_h8_final_write_processing
#define elf_backend_object_p \
  elf32_h8_object_p
#define bfd_elf32_bfd_merge_private_bfd_data \
  elf32_h8_merge_private_bfd_data

/* ??? when elf_backend_relocate_section is not defined, elf32-target.h
   defaults to using _bfd_generic_link_hash_table_create, but
   bfd_elf_size_dynamic_sections uses
   dynobj = elf_hash_table (info)->dynobj;
   and thus requires an elf hash table.  */
#define bfd_elf32_bfd_link_hash_table_create _bfd_elf_link_hash_table_create

/* Use an H8 specific linker, not the ELF generic linker.  */
#define elf_backend_relocate_section elf32_h8_relocate_section
#define elf_backend_rela_normal		1
#define elf_backend_can_gc_sections	1

/* And relaxing stuff.  */
#define bfd_elf32_bfd_relax_section     elf32_h8_relax_section
#define bfd_elf32_bfd_get_relocated_section_contents \
                                elf32_h8_get_relocated_section_contents

#define elf_symbol_leading_char '_'

#include "elf32-target.h"
@


1.63
log
@	* elf32-h8300 (h8_relax_section): Add new relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx).
	(R_H8_DISP32A16): New reloc.
	Comments added and corrected.
	* reloc.c (BFD_RELOC_H8_DISP32A16): New reloc.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* ld.texinfo (H8/300): Add description of relaxation of
	mov @@(disp:32,ERx) to mov @@(disp:16,ERx).

	* ld-h8300/h8300.exp: Add new relax-7 test on ELF.
	* ld-h8300/relax-2.s: Add other direction and .w/.l variants of
	mov insns.
	* ld-h8300/relax-2.d: Update expected disassembly.
	* ld-h8300/relax-7a.s: New: tests for mov @@(disp:32,ERx) -> mov
	@@(disp:16,ERx).
	* ld-h8300/relax-7b.s: New: Likewise.
	* ld-h8300/relax-7.d: New: expected disassembly.

	* config/tc-h8300.c (do_a_fix_imm): Add relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx) insns by new reloc
	R_H8_DISP32A16.
	* config/tc-h8300.h: Remove duplicated defines.
@
text
@d1521 1
a1521 1
	   && irel->r_offset < toaddr))
d1533 1
a1533 1
	  && isym->st_value < toaddr)
d1545 1
d1550 2
a1551 4
	  && sym_hash->root.u.def.value < toaddr)
	{
	  sym_hash->root.u.def.value -= count;
	}
@


1.62
log
@	* elf32-h8300.c (elf32_h8_relax_section): When checking for a
	second reloc, make sure that the reloc potentially exists first.
@
text
@d2 1
a2 2
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2012 Free Software Foundation, Inc.
d187 15
a201 1
#define R_H8_PCREL16_X (R_H8_DIR32A16_X + 1)
d250 1
d355 1
d688 3
a690 1
     mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes */
d745 13
a757 7

      if (ELF32_R_TYPE (irel->r_info) != R_H8_DIR24R8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_PCREL16
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR16A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR24A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR32A16)
	continue;
d833 2
a834 2
        /* Try to turn a 24-bit absolute branch/call into an 8-bit
	   pc-relative branch/call.  */
d874 5
a878 5
		   	             mov.w   r0,r0
		   	             beq     .L1
		         	     jsr     @@_bar
		              .L1:   rts
		              _bar:  rts
d880 4
a883 4
		   	             mov.w   r0,r0
			             bne     _bar
			             rts
			      _bar:  rts
d886 1
a886 1
		if (code == 0x5a
d930 1
a930 1
			contents + last_reloc->r_offset - 1);
d944 2
a945 2
		  /* This is jsr.  */
		  bfd_put_8 (abfd, 0x55, contents + irel->r_offset - 1);
d947 2
a948 2
		  /* This is jmp.  */
		  bfd_put_8 (abfd, 0x40, contents + irel->r_offset - 1);
d968 2
a969 2
	/* Try to turn a 16-bit pc-relative branch into a 8-bit pc-relative
	   branch.  */
d1006 1
a1006 1
		    /* Compute the fisrt byte of the relaxed
d1013 1
a1013 1
		    bfd_put_8 (abfd, code, contents + irel->r_offset - 2);
d1015 1
a1015 1
		else if (code == 0x5c)
d1017 1
a1017 1
		  bfd_put_8 (abfd, 0x55, contents + irel->r_offset - 2);
d1039 2
a1040 2
	/* This is a 16-bit absolute address in one of the following
	   instructions:
d1046 2
a1047 2
	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
d1127 2
a1128 2
	/* This is a 24-bit absolute address in one of the following
	   instructions:
d1134 2
a1135 2
	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
d1202 1
a1202 1
		/* Delete two bytes of data.  */
d1219 3
a1221 3
	       "band", "bclr", "biand", "bild", "bior", "bist",
	       "bixor", "bld", "bnot", "bor", "bset", "bst", "btst",
	       "bxor", "ldc.w", "stc.w" and "mov.[bwl]"
d1244 1
a1244 1
		    /* Check for 4-byte MOVA relaxation.  */
d1265 1
d1311 1
a1311 1
		/* Now check for short version of MOVA.  */
d1348 90
a1437 1
	    break;
d1439 1
@


1.61
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d1242 1
a1242 1
		    if (irel < irelend)
@


1.60
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d55 1
a55 1
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
d60 2
a61 1
static reloc_howto_type h8_elf_howto_table[] = {
d308 1
a308 1
	 PTR data ATTRIBUTE_UNUSED,
d703 1
a703 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d1527 1
a1527 1
			 (input_bfd, input_section, (PTR) NULL,
@


1.59
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d465 1
a465 1
					 rel, relend, howto, contents);
@


1.58
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2007, 2009, 2010 Free Software Foundation, Inc.
d463 1
a463 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.58.6.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d463 1
a463 1
      if (sec != NULL && discarded_section (sec))
@


1.57
log
@fix set but unused variable warnings
@
text
@d464 2
a465 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.56
log
@	* elf32-h8300.c (elf_symbol_leading_char): Define.
@
text
@d3 1
a3 1
   2007, 2009 Free Software Foundation, Inc.
a726 1
	reloc_howto_type *h;
a728 1
	h = bfd_reloc.howto;
a1386 1
  Elf_Internal_Rela *irelalign;
a1397 4
  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
@


1.55
log
@update copyright dates
@
text
@d1644 1
@


1.54
log
@[bfd]
	* elf32-h8300.c (elf32_h8_relax_section): Relax MOVA opcodes.
[gas]
	* tc-h8300.c (do_a_fix_imm): Pass the insn, force relocs for MOVA
	immediates.
	(build_bytes): Pass insn to do_a_fix_imm.
[include/opcode]
	* h8300.h: Add relaxation attributes to MOVA opcodes.
@
text
@d3 1
a3 1
   2007 Free Software Foundation, Inc.
@


1.53
log
@Switch sources over to use the GPL version 3
@
text
@d725 7
d1004 2
a1005 1
		  abort ();
d1218 2
d1227 81
d1318 1
@


1.52
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.51
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.50
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d254 16
d1521 1
@


1.49
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
a404 3
  if (info->relocatable)
    return TRUE;

d419 5
a424 1
      /* This is a final link.  */
d446 14
a469 5
	  arelent bfd_reloc;
	  reloc_howto_type *howto;

	  elf32_h8_info_to_howto (input_bfd, &bfd_reloc, rel);
	  howto = bfd_reloc.howto;
@


1.48
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004
a44 5
static asection *elf32_h8_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean elf32_h8_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
a1487 36
static asection *
elf32_h8_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (h->root.type)
        {
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
          return h->root.u.def.section;

	case bfd_link_hash_common:
          return h->root.u.c.p->section;

	default:
          break;
        }
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
  return NULL;
}

static bfd_boolean
elf32_h8_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
}

a1505 2
#define elf_backend_gc_mark_hook        elf32_h8_gc_mark_hook
#define elf_backend_gc_sweep_hook       elf32_h8_gc_sweep_hook
@


1.47
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.46
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.45
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d480 3
a482 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.44
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@a681 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d723 1
a723 6
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d1290 1
a1290 1
  toaddr = sec->_cooked_size;
d1298 1
a1298 1
  sec->_cooked_size -= count;
d1415 1
a1415 1
	  (size_t) input_section->_raw_size);
@


1.43
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d1561 1
a1561 1
   elflink.h:bfd_elf32_size_dynamic_sections uses
@


1.42
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d444 4
a447 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.41
log
@Add support for relaxing the 32bit ldc/stc instructions.
@
text
@d442 5
a446 22
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
@


1.41.4.1
log
@Merge from mainline
@
text
@d442 22
a463 6
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d1577 1
a1577 1
   bfd_elf_size_dynamic_sections uses
@


1.41.6.1
log
@Merge mainline to intercu branch.
@
text
@d442 22
a463 6
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.41.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1561 1
a1561 1
   bfd_elf_size_dynamic_sections uses
@


1.41.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d682 5
d728 6
a733 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d1300 1
a1300 1
  toaddr = sec->size;
d1308 1
a1308 1
  sec->size -= count;
d1425 1
a1425 1
	  (size_t) input_section->size);
@


1.41.10.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d442 22
a463 5
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.40
log
@	* coff-h8300.c: Add and adjust comments about relaxation.
	* elf32-h8300.c: Likewise.
@
text
@d1201 1
a1201 1
	       "bxor", and "mov.[bwl]"
@


1.39
log
@	* coff-h8300.c: Fix comment typos.
	* elf32-h8300.c: Likewise.
@
text
@d669 3
d925 1
d928 1
d983 2
a984 1
		    /* Get the condition code from the original insn.  */
d986 5
d997 1
d1194 8
a1201 1
	/* Fall through.  */
d1203 2
a1204 3
	/* This is a 24-/32-bit absolute address in a "mov" insn,
	   which may become a 16-bit absolute address if it is in the
	   right range.  */
d1223 3
a1225 1
		/* We just need to turn off bit 0x20.  */
@


1.38
log
@	* coff-h8300.c: Add comments about relaxation.
	* elf32-h8300.c: Likewise.
@
text
@d351 1
a351 1
	 value.  Subtract 1 so that we can manipulate the data in 32bit
d361 1
a361 1
      /* Now scribble it out in one 32bit hunk.  */
d811 1
a811 1
        /* Try to turn a 24 bit absolute branch/call into an 8 bit
d944 1
a944 1
	/* Try to turn a 16bit pc-relative branch into a 8bit pc-relative
d1184 3
a1186 2
	/* This is a 24/32bit absolute address in a "mov" insn, which may
	   become a 16-bit absolute address if it is in the right range.  */
@


1.37
log
@Add support for relaxation of bit manipulation instructions.
@
text
@d662 4
d1007 9
a1015 2
	/* This is a 16 bit absolute address in a "mov.b" insn, which may
	   become an 8 bit absolute address if its in the right range.  */
d1035 2
a1036 1
		/* Sanity check.  */
d1041 3
d1050 1
d1055 1
d1060 3
d1066 4
d1095 9
a1103 2
	/* This is a 24 bit absolute address in a "mov.b" insn, which may
	   become an 8 bit absolute address if its in the right range.  */
d1123 2
a1124 1
		/* Sanity check.  */
d1130 3
d1139 1
d1144 1
d1149 3
d1155 4
@


1.36
log
@	* elf32-h8300.c: Fix formatting.
@
text
@d1013 1
d1028 3
a1030 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1032 19
a1050 10
		if ((code & 0xf0) == 0x00)
		  bfd_put_8 (abfd,
			     (code & 0xf) | 0x20,
			     contents + irel->r_offset - 2);
		else if ((code & 0xf0) == 0x80)
		  bfd_put_8 (abfd,
			     (code & 0xf) | 0x30,
			     contents + irel->r_offset - 2);
		else
		  abort ();
d1081 1
d1096 1
a1096 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1098 4
a1101 1
		switch (code & 0xf0)
d1111 6
d1118 1
a1118 1
		    abort ();
d1138 1
a1138 1
	/* FALLTHRU */
@


1.35
log
@	* elflink.h (elf_gc_sections): Warn when gc-sections option is ignored.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): New function.
	(elf32_h8_gc_sweep_hook): New function.
	(elf_backend_gc_mark_hook): Define.
	(elf_backend_gc_sweep_hook): Define.
	(elf_backend_can_gc_sections): Define.
@
text
@d33 4
a36 8
static unsigned long elf32_h8_mach
  (flagword);
static void elf32_h8_final_write_processing
  (bfd *, bfd_boolean);
static bfd_boolean elf32_h8_object_p
  (bfd *);
static bfd_boolean elf32_h8_merge_private_bfd_data
  (bfd *, bfd *);
d41 1
a41 2
static bfd_boolean elf32_h8_symbol_address_p
  (bfd *, asection *, bfd_vma);
d45 1
a45 1
static asection * elf32_h8_gc_mark_hook
d643 2
a644 2
                               bfd_get_mach (ibfd)))
        return FALSE;
d1442 2
a1443 2
         case bfd_link_hash_defined:
         case bfd_link_hash_defweak:
d1445 2
a1446 2
          
         case bfd_link_hash_common:
d1448 2
a1449 2
          
         default:
d1454 1
a1454 1
    return bfd_section_from_elf_index(sec->owner, sym->st_shndx);
d1461 1
a1461 1
                        asection *sec ATTRIBUTE_UNUSED,
@


1.34
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003
d50 5
d1436 36
d1490 2
d1503 1
@


1.33
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d652 1
a652 1
   There's a few relaxing opportunites available on the H8:
d1119 1
a1119 1
	   become a 16bit absoulte address if it is in the right range.  */
@


1.32
log
@	* elf32-h8300.c (elf_reloc_map): Fix a comment typo.
@
text
@d438 1
a438 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.31
log
@bfd/
	* bfd-in.h (bfd_h8300_pad_address): Declare.
	* bfd-in2.h: Regenerate.
	* cpu-h8300.c (bfd_h8300_pad_address): New function.
	* coff-h8300.c (h8300_reloc16_estimate): Use it to canonicalize
	addresses before checking whether they can be relaxed.
	(h8300_reloc16_extra_cases): Likewise for the R_MOVL2 sanity check.
	Don't complain about overflows in general 8-bit relocations.
	* elf32-h8300.c (elf32_h8_relax_section): Use bfd_h8300_pad_address.
	Fix handling of R_H8_DIR24A8.

ld/testsuite/
	* ld-h8300/relax-3{.s,.d,-coff.d}: New test.
	* ld-h8300/h8300.exp: Run it.
@
text
@d228 1
a228 1
/* An array mapping BFD reloc codes to SH ELF relocs.  */
@


1.30
log
@	* elf32-h8300.c: Convert function prototypes and definitions
	to C90 syntax.
	* coff-h8300.c: Likewise.
	* cpu-h8300.c: Likewise.
@
text
@d1007 1
a1007 1
	    bfd_vma value = symval + irel->r_addend;
d1009 2
a1010 10
	    if ((bfd_get_mach (abfd) == bfd_mach_h8300
		 && value >= 0xff00
		 && value <= 0xffff)
		|| ((bfd_get_mach (abfd) == bfd_mach_h8300h
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
		    && value >= 0xffff00
		    && value <= 0xffffff))
d1063 1
a1063 1
	    bfd_vma value = symval + irel->r_addend;
d1065 2
a1066 10
	    if ((bfd_get_mach (abfd) == bfd_mach_h8300
		 && value >= 0xff00
		 && value <= 0xffff)
		|| ((bfd_get_mach (abfd) == bfd_mach_h8300h
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
		    && value >= 0xffff00
		    && value <= 0xffffff))
a1067 1
		bfd_boolean skip = FALSE;
d1087 1
a1087 1
		  case 0x00:
d1091 1
a1091 1
		  case 0x80:
a1094 5
		  case 0x20:
		  case 0xa0:
		    /* Skip 32bit versions.  */
		    skip = TRUE;
		    break;
a1098 3
		if (skip)
		  break;

d1102 1
d1105 2
a1106 1
		if (!elf32_h8_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
d1112 1
d1122 1
a1122 1
	    bfd_vma value = symval + irel->r_addend;
d1124 2
a1125 1
	    if (value <= 0x7fff || value >= 0xff8000)
@


1.29
log
@* elf32-h8300.c (R_H8_DIR32A16): Fix name field.
(elf32_h8_relax_section) <R_H8_DIR16A8>: Adjust position of relocation.
<R_H8_DIR32A16>: Fix type of relocation.

* ld-h8300/h8300.exp: Replace loop with explicit list.  Run relax.d
unconditionally.  Run relax-2.d for *-elf targets.
* ld-h8300/relax.d: Fix typo.
* ld-h8300/relax.s: Add 0x prefixes.
* ld-h8300/relad-2.[sd]: New test.
@
text
@d28 1
a28 1
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d34 1
a34 1
  PARAMS ((flagword));
d36 1
a36 1
  PARAMS ((bfd *, bfd_boolean));
d38 1
a38 1
  PARAMS ((bfd *));
d40 1
a40 1
  PARAMS ((bfd *, bfd *));
d42 1
a42 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d44 1
a44 1
  PARAMS ((bfd *, asection *, bfd_vma, int));
d46 1
a46 1
  PARAMS ((bfd *, asection *, bfd_vma));
d48 2
a49 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
d51 3
a53 3
  PARAMS ((unsigned long, bfd *, bfd *, asection *,
	   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
	   struct bfd_link_info *, asection *, int));
d55 3
a57 3
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *,
	   Elf_Internal_Sym *, asection **));
d59 1
a59 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d246 2
a247 3
elf32_h8_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d260 2
a261 4
elf32_h8_info_to_howto (abfd, bfd_reloc, elf_reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *bfd_reloc;
     Elf_Internal_Rela *elf_reloc;
d277 2
a278 4
elf32_h8_info_to_howto_rel (abfd, bfd_reloc, elf_reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *bfd_reloc;
     Elf_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED;
d292 7
a298 9
special (abfd, reloc_entry, symbol, data, input_section, output_bfd,
	 error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d310 8
a317 14
elf32_h8_final_link_relocate (r_type, input_bfd, output_bfd,
			      input_section, contents, offset, value,
			      addend, info, sym_sec, is_local)
     unsigned long r_type;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sym_sec ATTRIBUTE_UNUSED;
     int is_local ATTRIBUTE_UNUSED;
a322 1

d400 5
a404 10
elf32_h8_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d543 1
a543 2
elf32_h8_mach (flags)
     flagword flags;
d576 2
a577 3
elf32_h8_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d621 1
a621 2
elf32_h8_object_p (abfd)
     bfd *abfd;
d633 1
a633 3
elf32_h8_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d668 2
a669 5
elf32_h8_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d1228 1
a1228 5
elf32_h8_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
d1305 1
a1305 4
elf32_h8_symbol_address_p (abfd, sec, addr)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
d1349 6
a1354 8
elf32_h8_get_relocated_section_contents (output_bfd, link_info, link_order,
					 data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
@


1.28
log
@Correct spelling of "relocatable".
@
text
@d186 1
a186 1
	 "R_H8_DIR32",		/* name */
d1079 3
d1193 1
a1193 1
					     R_H8_DIR16A8);
@


1.27
log
@include/elf/
	* h8.h (E_H8_MACH_H8300SXN): New flag.

bfd/
	* archures.c (bfd_mach_h8300sxn): New architecture.
	* bfd-in2.h: Regenerate.
	* cpu-h8300.c (h8300_scan): Check for 'sxn'.
	(h8300sxn_info_struct): New.
	(h8300sx_info_struct): Link to it.
	* elf32-h8300.c (elf32_h8_mach): Add h8300sxn case.
	(elf32_h8_final_write_processing): Likewise.

gas/
	* config/tc-h8300.c (h8300sxnmode): New.
	(md_pseudo_table): Add .h8300sxn entry.  Sync others with FSF version.

ld/
	* configure.tgt (h8300*): Add h8300sxn emulations.
	* Makefile.am (ALL_EMULATIONS): Add eh8300sxn.o and eh8300sxnelf.o.
	(eh8300sxn.c, eh8300sxnelf.c): New rules.
	* Makefile.in: Regenerate.
	* emulparams/h8300sxnelf.sh, emulparams/h8300sxn.sh: New files.
@
text
@d429 1
a429 1
  if (info->relocateable)
d709 1
a709 1
  /* We don't have to do anything for a relocateable link, if
d712 1
a712 1
  if (link_info->relocateable
d1381 1
a1381 1
					 data, relocateable, symbols)
d1386 1
a1386 1
     bfd_boolean relocateable;
d1398 1
a1398 1
  if (relocateable
d1402 1
a1402 1
						       relocateable,
@


1.26
log
@2003-05-16  Michael Snyder  <msnyder@@redhat.com>
	From Bernd Schmidt  <bernds@@redhat.com>
	* archures.c (bfd_mach_h8300sx): New.
	* bfd-in2.h: Regenerate.
	* cpu-h8300.c (h8300_scan)): Add support for h8300sx.
	(h8300sx_info_struct): New.
	(h8300s_info_struct): Link to it.
	* elf32-h8300.c (elf32_h8_mach): Add support for h8300sx.
	(elf32_h8_final_write_processing): Likewise.
	(elf32_h8_relax_section): Likewise.
@
text
@d585 3
d627 4
@


1.25
log
@Fix typo in spelling of name of R_H8_DIR8 reloc
@
text
@d582 3
d621 4
d1033 4
a1036 1
		     || bfd_get_mach (abfd) == bfd_mach_h8300s)
d1094 4
a1097 1
		     || bfd_get_mach (abfd) == bfd_mach_h8300s)
@


1.24
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d72 2
a73 2
	 complain_overflow_dont, /* complain_on_overflow */
	 special,			/* special_function */
d86 2
a87 2
	 complain_overflow_dont, /* complain_on_overflow */
	 special,			/* special_function */
d100 2
a101 2
	 complain_overflow_dont, /* complain_on_overflow */
	 special,			/* special_function */
d114 3
a116 3
	 complain_overflow_dont, /* complain_on_overflow */
	 special,			/* special_function */
	 "R_H8_DIR16",		/* name */
d129 1
a129 1
	 special,			/* special_function */
d143 1
a143 1
	 special,			/* special_function */
d157 1
a157 1
	 special,			/* special_function */
d171 1
a171 1
	 special,			/* special_function */
d184 2
a185 2
	 complain_overflow_dont, /* complain_on_overflow */
	 special,			/* special_function */
d198 2
a199 2
	 complain_overflow_signed, /* complain_on_overflow */
	 special,			/* special_function */
d212 2
a213 2
	 complain_overflow_signed, /* complain_on_overflow */
	 special,			/* special_function */
@


1.23
log
@Do not crash when encountering relocs against the *ABS* section.
@
text
@d712 1
a712 1
  internal_relocs = (_bfd_elf32_link_read_relocs
d1397 1
a1397 1
      internal_relocs = (_bfd_elf32_link_read_relocs
@


1.22
log
@Add support for h8300hn and h8300sn
@
text
@d781 6
a786 3
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
d1088 1
d1106 21
a1126 10
		if ((code & 0xf0) == 0x00)
		  bfd_put_8 (abfd,
			     (code & 0xf) | 0x20,
			     contents + irel->r_offset - 2);
		else if ((code & 0xf0) == 0x80)
		  bfd_put_8 (abfd,
			     (code & 0xf) | 0x30,
			     contents + irel->r_offset - 2);
		else
		  abort ();
@


1.21
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d576 6
d609 8
@


1.21.2.1
log
@Merge from mainline.
@
text
@a575 6

    case E_H8_MACH_H8300HN:
      return bfd_mach_h8300hn;

    case E_H8_MACH_H8300SN:
      return bfd_mach_h8300sn;
a603 8

    case bfd_mach_h8300hn:
      val = E_H8_MACH_H8300HN;
      break;

    case bfd_mach_h8300sn:
      val = E_H8_MACH_H8300SN;
      break;
d767 3
a769 6
	  symval = isym->st_value;
	  /* If the reloc is absolute, it will not have
	     a symbol or section associated with it.  */
	  if (sym_sec)
	    symval += sym_sec->output_section->vma
	      + sym_sec->output_offset;
a1070 1
		bfd_boolean skip = FALSE;
d1088 10
a1097 21
		switch (code & 0xf0)
		  {
		  case 0x00:
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x80:
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x20:
		  case 0xa0:
		    /* Skip 32bit versions.  */
		    skip = TRUE;
		    break;
		  default:
		    abort ();
		  }

		if (skip)
		  break;
@


1.21.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d72 2
a73 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d86 2
a87 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d100 2
a101 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d114 3
a116 3
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR8",		/* name */
d129 1
a129 1
	 special,		/* special_function */
d143 1
a143 1
	 special,		/* special_function */
d157 1
a157 1
	 special,		/* special_function */
d171 1
a171 1
	 special,		/* special_function */
d184 2
a185 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d198 2
a199 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
d212 2
a213 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
a581 3

    case E_H8_MACH_H8300SX:
      return bfd_mach_h8300sx;
a617 4

    case bfd_mach_h8300sx:
      val = E_H8_MACH_H8300SX;
      break;
d712 1
a712 1
  internal_relocs = (_bfd_elf_link_read_relocs
d1026 1
a1026 4
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
d1084 1
a1084 4
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
d1397 1
a1397 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1 2
a2 2
/* Generic support for 32-bit ELF
   Copyright 1993, 1995, 1998, 1999, 2001, 2002
@


1.19
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d36 2
a37 2
  PARAMS ((bfd *, boolean));
static boolean elf32_h8_object_p
d39 1
a39 1
static boolean elf32_h8_merge_private_bfd_data
d41 3
a43 3
static boolean elf32_h8_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean elf32_h8_relax_delete_bytes
d45 1
a45 1
static boolean elf32_h8_symbol_address_p
d49 1
a49 1
	   bfd_byte *, boolean, asymbol **));
d54 1
a54 1
static boolean elf32_h8_relocate_section
d70 1
a70 1
	 false,			/* pc_relative */
d75 1
a75 1
	 false,			/* partial_inplace */
d78 1
a78 1
	 false),		/* pcrel_offset */
d84 1
a84 1
	 false,			/* pc_relative */
d89 1
a89 1
	 false,			/* partial_inplace */
d92 1
a92 1
	 false),		/* pcrel_offset */
d98 1
a98 1
	 false,			/* pc_relative */
d103 1
a103 1
	 false,			/* partial_inplace */
d106 1
a106 1
	 false),		/* pcrel_offset */
d112 1
a112 1
	 false,			/* pc_relative */
d117 1
a117 1
	 false,			/* partial_inplace */
d120 1
a120 1
	 false),		/* pcrel_offset */
d126 1
a126 1
	 false,			/* pc_relative */
d131 1
a131 1
	 false,			/* partial_inplace */
d134 1
a134 1
	 false),		/* pcrel_offset */
d140 1
a140 1
	 false,			/* pc_relative */
d145 1
a145 1
	 false,			/* partial_inplace */
d148 1
a148 1
	 false),		/* pcrel_offset */
d154 1
a154 1
	 false,			/* pc_relative */
d159 1
a159 1
	 true,			/* partial_inplace */
d162 1
a162 1
	 false),		/* pcrel_offset */
d168 1
a168 1
	 false,			/* pc_relative */
d173 1
a173 1
	 true,			/* partial_inplace */
d176 1
a176 1
	 false),		/* pcrel_offset */
d182 1
a182 1
	 false,			/* pc_relative */
d187 1
a187 1
	 false,			/* partial_inplace */
d190 1
a190 1
	 false),		/* pcrel_offset */
d196 1
a196 1
	 true,			/* pc_relative */
d201 1
a201 1
	 false,			/* partial_inplace */
d204 1
a204 1
	 true),			/* pcrel_offset */
d210 1
a210 1
	 true,			/* pc_relative */
d215 1
a215 1
	 false,			/* partial_inplace */
d218 1
a218 1
	 true),			/* pcrel_offset */
d413 1
a413 1
static boolean
d430 1
a430 1
    return true;
d479 2
a480 2
		      input_section, rel->r_offset, true)))
		return false;
d517 1
a517 1
		return false;
d523 2
a524 2
		      rel->r_offset, true)))
		return false;
d547 1
a547 1
		return false;
d553 1
a553 1
  return true;
d586 1
a586 1
     boolean linker ATTRIBUTE_UNUSED;
d613 1
a613 1
static boolean
d619 1
a619 1
  return true;
d626 1
a626 1
static boolean
d633 1
a633 1
    return true;
d640 1
a640 1
        return false;
d643 1
a643 1
  return true;
d663 1
a663 1
static boolean
d668 1
a668 1
     boolean *again;
d679 1
a679 1
  *again = false;
d688 1
a688 1
    return true;
d843 1
a843 1
		   
d908 1
a908 1
			*again = true;
d931 1
a931 1
		*again = true;
d994 1
a994 1
		*again = true;
d1052 1
a1052 1
		*again = true;
d1109 1
a1109 1
		*again = true;
d1150 1
a1150 1
		*again = true;
d1185 1
a1185 1
  return true;
d1197 1
a1197 1
  return false;
d1202 1
a1202 1
static boolean
d1278 1
a1278 1
  return true;
d1281 3
a1283 3
/* Return true if a symbol exists at the given address, else return
   false.  */
static boolean
d1307 1
a1307 1
	return true;
d1321 1
a1321 1
	return true;
d1324 1
a1324 1
  return false;
d1337 1
a1337 1
     boolean relocateable;
d1370 1
a1370 1
			  (Elf_Internal_Rela *) NULL, false));
@


1.18
log
@Fix h8300 relaxation.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d264 1
a264 1
     Elf32_Internal_Rela *elf_reloc;
d283 1
a283 1
     Elf32_Internal_Rel *elf_reloc ATTRIBUTE_UNUSED;
@


1.17
log
@	* coff-h8300.c: Fix formatting.
	* elf32-h8300.c: Likewise.
	* reloc16.c: Likewise.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d830 3
d839 19
a857 2
		   long conditional branches.  */
		if ((int) gap <= 130
a911 3

		/* We could not eliminate this jump, so just shorten it.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
@


1.16
log
@	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.
@
text
@d64 1
a64 2
static reloc_howto_type h8_elf_howto_table[] =
{
d223 1
a223 2
struct elf_reloc_map
{
d230 1
a230 2
static const struct elf_reloc_map h8_reloc_map[] =
{
d271 1
a271 1
    if (h8_elf_howto_table[i].type== r)
d870 1
a870 1
		        last_reloc->r_info
d872 2
a873 3
					ELF32_R_TYPE (R_H8_PCREL8));
		        last_reloc->r_addend = irel->r_addend;

d937 1
a937 1
	    if ((int)gap >= -126 && (int)gap <= 130)
d939 1
a939 1
	        unsigned char code;
d941 1
a941 1
	        /* Note that we've changed the relocs, section contents,
d943 2
a944 2
	        elf_section_data (sec)->relocs = internal_relocs;
	        elf_section_data (sec)->this_hdr.contents = contents;
d947 2
a948 2
	        /* Get the opcode.  */
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d966 1
a966 1
	        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d968 1
a968 1
	        irel->r_offset--;
d970 2
a971 2
	        /* Delete two bytes of data.  */
	        if (!elf32_h8_relax_delete_bytes (abfd, sec,
d975 1
a975 1
	        /* That will change things, so, we should relax again.
d977 1
a977 1
	        *again = true;
d989 3
a991 3
	         && value >= 0xff00
	         && value <= 0xffff)
	        || ((bfd_get_mach (abfd) == bfd_mach_h8300h
d996 1
a996 1
	        unsigned char code;
d998 1
a998 1
	        /* Note that we've changed the relocs, section contents,
d1000 2
a1001 2
	        elf_section_data (sec)->relocs = internal_relocs;
	        elf_section_data (sec)->this_hdr.contents = contents;
d1004 2
a1005 2
	        /* Get the opcode.  */
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1007 2
a1008 2
	        /* Sanity check.  */
	        if (code != 0x6a)
d1011 1
a1011 1
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1013 1
a1013 1
	        if ((code & 0xf0) == 0x00)
d1016 2
a1017 2
			      contents + irel->r_offset - 2);
	        else if ((code & 0xf0) == 0x80)
d1020 2
a1021 2
			      contents + irel->r_offset - 2);
	        else
d1024 2
a1025 2
	        /* Fix the relocation's type.  */
	        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1028 2
a1029 2
	        /* Delete two bytes of data.  */
	        if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1033 1
a1033 1
	        /* That will change things, so, we should relax again.
d1035 1
a1035 1
	        *again = true;
d1047 3
a1049 3
	         && value >= 0xff00
	         && value <= 0xffff)
	        || ((bfd_get_mach (abfd) == bfd_mach_h8300h
d1054 1
a1054 1
	        unsigned char code;
d1056 1
a1056 1
	        /* Note that we've changed the relocs, section contents,
d1058 2
a1059 2
	        elf_section_data (sec)->relocs = internal_relocs;
	        elf_section_data (sec)->this_hdr.contents = contents;
d1062 2
a1063 2
	        /* Get the opcode.  */
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1065 2
a1066 2
	        /* Sanity check.  */
	        if (code != 0x6a)
d1069 1
a1069 1
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1071 1
a1071 1
	        if ((code & 0xf0) == 0x00)
d1074 2
a1075 2
			      contents + irel->r_offset - 2);
	        else if ((code & 0xf0) == 0x80)
d1078 2
a1079 2
			      contents + irel->r_offset - 2);
	        else
d1082 2
a1083 2
	        /* Fix the relocation's type.  */
	        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1086 2
a1087 2
	        /* Delete two bytes of data.  */
	        if (!elf32_h8_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
d1090 1
a1090 1
	        /* That will change things, so, we should relax again.
d1092 1
a1092 1
	        *again = true;
d1106 1
a1106 1
	        unsigned char code;
d1108 1
a1108 1
	        /* Note that we've changed the relocs, section contents,
d1110 2
a1111 2
	        elf_section_data (sec)->relocs = internal_relocs;
	        elf_section_data (sec)->this_hdr.contents = contents;
d1114 2
a1115 2
	        /* Get the opcode.  */
	        code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1117 2
a1118 2
	        /* We just need to turn off bit 0x20.  */
	        code &= ~0x20;
d1120 1
a1120 1
	        bfd_put_8 (abfd, code, contents + irel->r_offset - 1);
d1122 2
a1123 2
	        /* Fix the relocation's type.  */
	        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1126 2
a1127 2
	        /* Delete two bytes of data.  */
	        if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1131 1
a1131 1
	        /* That will change things, so, we should relax again.
d1133 1
a1133 1
	        *again = true;
@


1.16.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 2
/* BFD back-end for Renesas H8/300 ELF binaries.
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
  (bfd *abfd, bfd_reloc_code_real_type code);
d30 1
a30 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d32 1
a32 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d34 1
a34 1
  (flagword);
d36 11
a46 11
  (bfd *, bfd_boolean);
static bfd_boolean elf32_h8_object_p
  (bfd *);
static bfd_boolean elf32_h8_merge_private_bfd_data
  (bfd *, bfd *);
static bfd_boolean elf32_h8_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean elf32_h8_relax_delete_bytes
  (bfd *, asection *, bfd_vma, int);
static bfd_boolean elf32_h8_symbol_address_p
  (bfd *, asection *, bfd_vma);
d48 2
a49 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
   bfd_byte *, bfd_boolean, asymbol **);
d51 7
a57 7
  (unsigned long, bfd *, bfd *, asection *,
   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
   struct bfd_link_info *, asection *, int);
static bfd_boolean elf32_h8_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *,
   bfd_byte *, Elf_Internal_Rela *,
   Elf_Internal_Sym *, asection **);
d59 1
a59 1
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
d64 2
a65 1
static reloc_howto_type h8_elf_howto_table[] = {
d71 1
a71 1
	 FALSE,			/* pc_relative */
d73 2
a74 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d76 1
a76 1
	 FALSE,			/* partial_inplace */
d79 1
a79 1
	 FALSE),		/* pcrel_offset */
d85 1
a85 1
	 FALSE,			/* pc_relative */
d87 2
a88 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d90 1
a90 1
	 FALSE,			/* partial_inplace */
d93 1
a93 1
	 FALSE),		/* pcrel_offset */
d99 1
a99 1
	 FALSE,			/* pc_relative */
d101 2
a102 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d104 1
a104 1
	 FALSE,			/* partial_inplace */
d107 1
a107 1
	 FALSE),		/* pcrel_offset */
d113 1
a113 1
	 FALSE,			/* pc_relative */
d115 4
a118 4
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR8",		/* name */
	 FALSE,			/* partial_inplace */
d121 1
a121 1
	 FALSE),		/* pcrel_offset */
d127 1
a127 1
	 FALSE,			/* pc_relative */
d130 1
a130 1
	 special,		/* special_function */
d132 1
a132 1
	 FALSE,			/* partial_inplace */
d135 1
a135 1
	 FALSE),		/* pcrel_offset */
d141 1
a141 1
	 FALSE,			/* pc_relative */
d144 1
a144 1
	 special,		/* special_function */
d146 1
a146 1
	 FALSE,			/* partial_inplace */
d149 1
a149 1
	 FALSE),		/* pcrel_offset */
d155 1
a155 1
	 FALSE,			/* pc_relative */
d158 1
a158 1
	 special,		/* special_function */
d160 1
a160 1
	 TRUE,			/* partial_inplace */
d163 1
a163 1
	 FALSE),		/* pcrel_offset */
d169 1
a169 1
	 FALSE,			/* pc_relative */
d172 1
a172 1
	 special,		/* special_function */
d174 1
a174 1
	 TRUE,			/* partial_inplace */
d177 1
a177 1
	 FALSE),		/* pcrel_offset */
d183 1
a183 1
	 FALSE,			/* pc_relative */
d185 4
a188 4
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR32A16",	/* name */
	 FALSE,			/* partial_inplace */
d191 1
a191 1
	 FALSE),		/* pcrel_offset */
d197 1
a197 1
	 TRUE,			/* pc_relative */
d199 2
a200 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
d202 1
a202 1
	 FALSE,			/* partial_inplace */
d205 1
a205 1
	 TRUE),			/* pcrel_offset */
d211 1
a211 1
	 TRUE,			/* pc_relative */
d213 2
a214 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
d216 1
a216 1
	 FALSE,			/* partial_inplace */
d219 1
a219 1
	 TRUE),			/* pcrel_offset */
d224 2
a225 1
struct elf_reloc_map {
d230 1
a230 1
/* An array mapping BFD reloc codes to H8 ELF relocs.  */
d232 2
a233 1
static const struct elf_reloc_map h8_reloc_map[] = {
d249 3
a251 2
elf32_h8_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
d264 4
a267 2
elf32_h8_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			Elf_Internal_Rela *elf_reloc)
d274 1
a274 1
    if (h8_elf_howto_table[i].type == r)
d283 4
a286 2
elf32_h8_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			    Elf_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED)
d300 9
a308 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d320 14
a333 8
elf32_h8_final_link_relocate (unsigned long r_type, bfd *input_bfd,
			      bfd *output_bfd ATTRIBUTE_UNUSED,
			      asection *input_section ATTRIBUTE_UNUSED,
			      bfd_byte *contents, bfd_vma offset,
			      bfd_vma value, bfd_vma addend,
			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
			      asection *sym_sec ATTRIBUTE_UNUSED,
			      int is_local ATTRIBUTE_UNUSED)
d339 1
d416 11
a426 6
static bfd_boolean
elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			   bfd *input_bfd, asection *input_section,
			   bfd_byte *contents, Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
d432 2
a433 2
  if (info->relocatable)
    return TRUE;
d460 1
a460 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d482 2
a483 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d520 1
a520 1
		return FALSE;
d526 2
a527 2
		      rel->r_offset, TRUE)))
		return FALSE;
d550 1
a550 1
		return FALSE;
d556 1
a556 1
  return TRUE;
d565 2
a566 1
elf32_h8_mach (flagword flags)
a578 12

    case E_H8_MACH_H8300HN:
      return bfd_mach_h8300hn;

    case E_H8_MACH_H8300SN:
      return bfd_mach_h8300sn;

    case E_H8_MACH_H8300SX:
      return bfd_mach_h8300sx;

    case E_H8_MACH_H8300SXN:
      return bfd_mach_h8300sxn;
d587 3
a589 2
elf32_h8_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
a606 16

    case bfd_mach_h8300hn:
      val = E_H8_MACH_H8300HN;
      break;

    case bfd_mach_h8300sn:
      val = E_H8_MACH_H8300SN;
      break;

    case bfd_mach_h8300sx:
      val = E_H8_MACH_H8300SX;
      break;

    case bfd_mach_h8300sxn:
      val = E_H8_MACH_H8300SXN;
      break;
d616 3
a618 2
static bfd_boolean
elf32_h8_object_p (bfd *abfd)
d622 1
a622 1
  return TRUE;
d629 4
a632 2
static bfd_boolean
elf32_h8_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d636 1
a636 1
    return TRUE;
d643 1
a643 1
        return FALSE;
d646 1
a646 1
  return TRUE;
d651 1
a651 1
   There are a few relaxing opportunities available on the H8:
d666 6
a671 3
static bfd_boolean
elf32_h8_relax_section (bfd *abfd, asection *sec,
			struct bfd_link_info *link_info, bfd_boolean *again)
d682 1
a682 1
  *again = FALSE;
d684 1
a684 1
  /* We don't have to do anything for a relocatable link, if
d687 1
a687 1
  if (link_info->relocatable
d691 1
a691 1
    return TRUE;
d701 1
a701 1
  internal_relocs = (_bfd_elf_link_read_relocs
d770 3
a772 6
	  symval = isym->st_value;
	  /* If the reloc is absolute, it will not have
	     a symbol or section associated with it.  */
	  if (sym_sec)
	    symval += sym_sec->output_section->vma
	      + sym_sec->output_offset;
a832 3
		/* Get the instruction code being relaxed.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

d839 2
a840 19
		   long conditional branches.

		   Only perform this optimisation for jumps (code 0x5a) not
		   subroutine calls, as otherwise it could transform:

		   	             mov.w   r0,r0
		   	             beq     .L1
		         	     jsr     @@_bar
		              .L1:   rts
		              _bar:  rts
		   into:
		   	             mov.w   r0,r0
			             bne     _bar
			             rts
			      _bar:  rts

		   which changes the call (jsr) into a branch (bne).  */
		if (code == 0x5a
		    && (int) gap <= 130
d873 1
a873 1
			last_reloc->r_info
d875 3
a877 2
					  ELF32_R_TYPE (R_H8_PCREL8));
			last_reloc->r_addend = irel->r_addend;
d892 1
a892 1
			*again = TRUE;
d897 3
d918 1
a918 1
		*again = TRUE;
d941 1
a941 1
	    if ((int) gap >= -126 && (int) gap <= 130)
d943 1
a943 1
		unsigned char code;
d945 1
a945 1
		/* Note that we've changed the relocs, section contents,
d947 2
a948 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d951 2
a952 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d970 1
a970 1
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d972 1
a972 1
		irel->r_offset--;
d974 2
a975 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d979 1
a979 1
		/* That will change things, so, we should relax again.
d981 1
a981 1
		*again = TRUE;
d990 1
a990 1
	    bfd_vma value;
d992 7
a998 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
d1000 1
a1000 1
		unsigned char code;
d1002 1
a1002 1
		/* Note that we've changed the relocs, section contents,
d1004 2
a1005 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1008 2
a1009 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1011 2
a1012 2
		/* Sanity check.  */
		if (code != 0x6a)
d1015 1
a1015 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1017 1
a1017 1
		if ((code & 0xf0) == 0x00)
d1020 2
a1021 2
			     contents + irel->r_offset - 2);
		else if ((code & 0xf0) == 0x80)
d1024 2
a1025 2
			     contents + irel->r_offset - 2);
		else
d1028 2
a1029 2
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1032 2
a1033 5
		/* Move the relocation.  */
		irel->r_offset--;

		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1037 1
a1037 1
		/* That will change things, so, we should relax again.
d1039 1
a1039 1
		*again = TRUE;
d1048 1
a1048 1
	    bfd_vma value;
d1050 7
a1056 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
d1058 1
a1058 1
		unsigned char code;
d1060 1
a1060 1
		/* Note that we've changed the relocs, section contents,
d1062 2
a1063 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1066 2
a1067 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1069 2
a1070 2
		/* Sanity check.  */
		if (code != 0x6a)
d1073 1
a1073 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1075 10
a1084 13
		switch (code & 0xf0)
		  {
		  case 0x20:
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0xa0:
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  default:
		    abort ();
		  }
d1086 2
a1087 2
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
a1088 1
		irel->r_offset--;
d1090 2
a1091 3
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 4))
d1094 1
a1094 1
		/* That will change things, so, we should relax again.
d1096 1
a1096 2
		*again = TRUE;
		break;
d1103 1
a1103 1
	   become a 16-bit absolute address if it is in the right range.  */
d1106 1
a1106 1
	    bfd_vma value;
d1108 1
a1108 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value <= 0x7fff || value >= 0xffff8000u)
d1110 1
a1110 1
		unsigned char code;
d1112 1
a1112 1
		/* Note that we've changed the relocs, section contents,
d1114 2
a1115 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1118 2
a1119 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1121 2
a1122 2
		/* We just need to turn off bit 0x20.  */
		code &= ~0x20;
d1124 1
a1124 1
		bfd_put_8 (abfd, code, contents + irel->r_offset - 1);
d1126 3
a1128 3
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					     R_H8_DIR16);
d1130 2
a1131 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1135 1
a1135 1
		/* That will change things, so, we should relax again.
d1137 1
a1137 1
		*again = TRUE;
d1172 1
a1172 1
  return TRUE;
d1184 1
a1184 1
  return FALSE;
d1189 6
a1194 2
static bfd_boolean
elf32_h8_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, int count)
d1265 1
a1265 1
  return TRUE;
d1268 7
a1274 4
/* Return TRUE if a symbol exists at the given address, else return
   FALSE.  */
static bfd_boolean
elf32_h8_symbol_address_p (bfd *abfd, asection *sec, bfd_vma addr)
d1294 1
a1294 1
	return TRUE;
d1308 1
a1308 1
	return TRUE;
d1311 1
a1311 1
  return FALSE;
d1318 8
a1325 6
elf32_h8_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
d1336 1
a1336 1
  if (relocatable
d1340 1
a1340 1
						       relocatable,
d1355 1
a1355 1
      internal_relocs = (_bfd_elf_link_read_relocs
d1357 1
a1357 1
			  (Elf_Internal_Rela *) NULL, FALSE));
@


1.16.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004
d33 8
a40 4
static unsigned long elf32_h8_mach (flagword);
static void elf32_h8_final_write_processing (bfd *, bfd_boolean);
static bfd_boolean elf32_h8_object_p (bfd *);
static bfd_boolean elf32_h8_merge_private_bfd_data (bfd *, bfd *);
d45 2
a46 1
static bfd_boolean elf32_h8_symbol_address_p (bfd *, asection *, bfd_vma);
a49 5
static asection *elf32_h8_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean elf32_h8_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d643 2
a644 2
			       bfd_get_mach (ibfd)))
	return FALSE;
a1012 1
		unsigned char temp_code;
d1027 1
a1027 3
		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
		if ((temp_code & 0x10) != 0x10)
		  temp_code &= 0xf0;
d1029 10
a1038 19
		switch (temp_code)
		  {
		  case 0x00:
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x80:
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x18:
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x10:
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
		  default:
		    abort ();
		  }
a1068 1
		unsigned char temp_code;
d1083 1
a1083 4
		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		if ((temp_code & 0x30) != 0x30)
		  temp_code &= 0xf0;
d1085 1
a1085 1
		switch (temp_code)
a1094 6
		  case 0x38:
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x30:
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
d1096 1
a1096 1
		    abort();
d1116 1
a1116 1
	/* Fall through.  */
a1430 36
static asection *
elf32_h8_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (h->root.type)
        {
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
          return h->root.u.def.section;

	case bfd_link_hash_common:
          return h->root.u.c.p->section;

	default:
          break;
        }
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
  return NULL;
}

static bfd_boolean
elf32_h8_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
}

a1448 2
#define elf_backend_gc_mark_hook        elf32_h8_gc_mark_hook
#define elf_backend_gc_sweep_hook       elf32_h8_gc_sweep_hook
a1459 1
#define elf_backend_can_gc_sections	1
@


1.16.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d351 1
a351 1
	 value.  Subtract 1 so that we can manipulate the data in 32-bit
d361 1
a361 1
      /* Now scribble it out in one 32-bit hunk.  */
a661 4
     bset:16	     ->    bset:8                 2 bytes
     bset:24/32	     ->    bset:8                 4 bytes
     (also applicable to other bit manipulation instructions)

a664 3
     bset:24/32	     ->    bset:16                2 bytes
     (also applicable to other bit manipulation instructions)

d807 1
a807 1
        /* Try to turn a 24-bit absolute branch/call into an 8-bit
a917 1
		  /* This is jsr.  */
a919 1
		  /* This is jmp.  */
d940 1
a940 1
	/* Try to turn a 16-bit pc-relative branch into a 8-bit pc-relative
d974 1
a974 2
		    /* Get the second byte of the original insn, which
		       contains the condition code.  */
a975 5

		    /* Compute the fisrt byte of the relaxed
		       instruction.  The original sequence 0x58 0xX0
		       is relaxed to 0x4X, where X represents the
		       condition code.  */
a981 1
		  /* This is bsr.  */
d1003 2
a1004 9
	/* This is a 16-bit absolute address in one of the following
	   instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
d1024 1
a1024 2
		/* All instructions with R_H8_DIR16A8 start with
		   0x6a.  */
a1028 3
		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
a1034 1
		    /* This is mov.b @@aa:16,Rd.  */
a1038 1
		    /* This is mov.b Rs,@@aa:16.  */
a1042 3
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
a1045 4
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
d1071 2
a1072 9
	/* This is a 24-bit absolute address in one of the following
	   instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
d1092 1
a1092 2
		/* All instructions with R_H8_DIR24A8 start with
		   0x6a.  */
a1097 3
		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
a1103 1
		    /* This is mov.b @@aa:24/32,Rd.  */
a1107 1
		    /* This is mov.b Rs,@@aa:24/32.  */
a1111 3
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
a1114 4
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
d1138 1
a1138 8
	  /* Fall through.  */

	  /* This is a 24-/32-bit absolute address in one of the
	     following instructions:

	       "band", "bclr", "biand", "bild", "bior", "bist",
	       "bixor", "bld", "bnot", "bor", "bset", "bst", "btst",
	       "bxor", and "mov.[bwl]"
d1140 2
a1141 2
	     We may relax this into an 16-bit absolute address if it's
	     in the right range.  */
d1160 1
a1160 3
		/* Fix the opcode.  For all the instructions that
		   belong to this relaxation, we simply need to turn
		   off bit 0x20 in the previous byte.  */
@


1.16.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d64 2
a65 1
static reloc_howto_type h8_elf_howto_table[] = {
d224 2
a225 1
struct elf_reloc_map {
d232 2
a233 1
static const struct elf_reloc_map h8_reloc_map[] = {
d274 1
a274 1
    if (h8_elf_howto_table[i].type == r)
a832 3
		/* Get the instruction code being relaxed.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

d839 2
a840 19
		   long conditional branches.

		   Only perform this optimisation for jumps (code 0x5a) not
		   subroutine calls, as otherwise it could transform:
		   
		   	             mov.w   r0,r0
		   	             beq     .L1
		         	     jsr     @@_bar
		              .L1:   rts
		              _bar:  rts
		   into:
		   	             mov.w   r0,r0
			             bne     _bar
			             rts
			      _bar:  rts

		   which changes the call (jsr) into a branch (bne).  */
		if (code == 0x5a
		    && (int) gap <= 130
d873 1
a873 1
			last_reloc->r_info
d875 3
a877 2
					  ELF32_R_TYPE (R_H8_PCREL8));
			last_reloc->r_addend = irel->r_addend;
d897 3
d941 1
a941 1
	    if ((int) gap >= -126 && (int) gap <= 130)
d943 1
a943 1
		unsigned char code;
d945 1
a945 1
		/* Note that we've changed the relocs, section contents,
d947 2
a948 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d951 2
a952 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d970 1
a970 1
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d972 1
a972 1
		irel->r_offset--;
d974 2
a975 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d979 1
a979 1
		/* That will change things, so, we should relax again.
d981 1
a981 1
		*again = true;
d993 3
a995 3
		 && value >= 0xff00
		 && value <= 0xffff)
		|| ((bfd_get_mach (abfd) == bfd_mach_h8300h
d1000 1
a1000 1
		unsigned char code;
d1002 1
a1002 1
		/* Note that we've changed the relocs, section contents,
d1004 2
a1005 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1008 2
a1009 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1011 2
a1012 2
		/* Sanity check.  */
		if (code != 0x6a)
d1015 1
a1015 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1017 1
a1017 1
		if ((code & 0xf0) == 0x00)
d1020 2
a1021 2
			     contents + irel->r_offset - 2);
		else if ((code & 0xf0) == 0x80)
d1024 2
a1025 2
			     contents + irel->r_offset - 2);
		else
d1028 2
a1029 2
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1032 2
a1033 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1037 1
a1037 1
		/* That will change things, so, we should relax again.
d1039 1
a1039 1
		*again = true;
d1051 3
a1053 3
		 && value >= 0xff00
		 && value <= 0xffff)
		|| ((bfd_get_mach (abfd) == bfd_mach_h8300h
d1058 1
a1058 1
		unsigned char code;
d1060 1
a1060 1
		/* Note that we've changed the relocs, section contents,
d1062 2
a1063 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1066 2
a1067 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 2);
d1069 2
a1070 2
		/* Sanity check.  */
		if (code != 0x6a)
d1073 1
a1073 1
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1075 1
a1075 1
		if ((code & 0xf0) == 0x00)
d1078 2
a1079 2
			     contents + irel->r_offset - 2);
		else if ((code & 0xf0) == 0x80)
d1082 2
a1083 2
			     contents + irel->r_offset - 2);
		else
d1086 2
a1087 2
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1090 2
a1091 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
d1094 1
a1094 1
		/* That will change things, so, we should relax again.
d1096 1
a1096 1
		*again = true;
d1110 1
a1110 1
		unsigned char code;
d1112 1
a1112 1
		/* Note that we've changed the relocs, section contents,
d1114 2
a1115 2
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
d1118 2
a1119 2
		/* Get the opcode.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
d1121 2
a1122 2
		/* We just need to turn off bit 0x20.  */
		code &= ~0x20;
d1124 1
a1124 1
		bfd_put_8 (abfd, code, contents + irel->r_offset - 1);
d1126 2
a1127 2
		/* Fix the relocation's type.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
d1130 2
a1131 2
		/* Delete two bytes of data.  */
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
d1135 1
a1135 1
		/* That will change things, so, we should relax again.
d1137 1
a1137 1
		*again = true;
@


1.16.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d36 2
a37 2
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_h8_object_p
d39 1
a39 1
static bfd_boolean elf32_h8_merge_private_bfd_data
d41 3
a43 3
static bfd_boolean elf32_h8_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean elf32_h8_relax_delete_bytes
d45 1
a45 1
static bfd_boolean elf32_h8_symbol_address_p
d49 1
a49 1
	   bfd_byte *, bfd_boolean, asymbol **));
d54 1
a54 1
static bfd_boolean elf32_h8_relocate_section
d70 1
a70 1
	 FALSE,			/* pc_relative */
d75 1
a75 1
	 FALSE,			/* partial_inplace */
d78 1
a78 1
	 FALSE),		/* pcrel_offset */
d84 1
a84 1
	 FALSE,			/* pc_relative */
d89 1
a89 1
	 FALSE,			/* partial_inplace */
d92 1
a92 1
	 FALSE),		/* pcrel_offset */
d98 1
a98 1
	 FALSE,			/* pc_relative */
d103 1
a103 1
	 FALSE,			/* partial_inplace */
d106 1
a106 1
	 FALSE),		/* pcrel_offset */
d112 1
a112 1
	 FALSE,			/* pc_relative */
d117 1
a117 1
	 FALSE,			/* partial_inplace */
d120 1
a120 1
	 FALSE),		/* pcrel_offset */
d126 1
a126 1
	 FALSE,			/* pc_relative */
d131 1
a131 1
	 FALSE,			/* partial_inplace */
d134 1
a134 1
	 FALSE),		/* pcrel_offset */
d140 1
a140 1
	 FALSE,			/* pc_relative */
d145 1
a145 1
	 FALSE,			/* partial_inplace */
d148 1
a148 1
	 FALSE),		/* pcrel_offset */
d154 1
a154 1
	 FALSE,			/* pc_relative */
d159 1
a159 1
	 TRUE,			/* partial_inplace */
d162 1
a162 1
	 FALSE),		/* pcrel_offset */
d168 1
a168 1
	 FALSE,			/* pc_relative */
d173 1
a173 1
	 TRUE,			/* partial_inplace */
d176 1
a176 1
	 FALSE),		/* pcrel_offset */
d182 1
a182 1
	 FALSE,			/* pc_relative */
d187 1
a187 1
	 FALSE,			/* partial_inplace */
d190 1
a190 1
	 FALSE),		/* pcrel_offset */
d196 1
a196 1
	 TRUE,			/* pc_relative */
d201 1
a201 1
	 FALSE,			/* partial_inplace */
d204 1
a204 1
	 TRUE),			/* pcrel_offset */
d210 1
a210 1
	 TRUE,			/* pc_relative */
d215 1
a215 1
	 FALSE,			/* partial_inplace */
d218 1
a218 1
	 TRUE),			/* pcrel_offset */
d264 1
a264 1
     Elf_Internal_Rela *elf_reloc;
d283 1
a283 1
     Elf_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED;
d413 1
a413 1
static bfd_boolean
d430 1
a430 1
    return TRUE;
d479 2
a480 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d517 1
a517 1
		return FALSE;
d523 2
a524 2
		      rel->r_offset, TRUE)))
		return FALSE;
d547 1
a547 1
		return FALSE;
d553 1
a553 1
  return TRUE;
d586 1
a586 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d613 1
a613 1
static bfd_boolean
d619 1
a619 1
  return TRUE;
d626 1
a626 1
static bfd_boolean
d633 1
a633 1
    return TRUE;
d640 1
a640 1
        return FALSE;
d643 1
a643 1
  return TRUE;
d663 1
a663 1
static bfd_boolean
d668 1
a668 1
     bfd_boolean *again;
d679 1
a679 1
  *again = FALSE;
d688 1
a688 1
    return TRUE;
d843 1
a843 1

d908 1
a908 1
			*again = TRUE;
d931 1
a931 1
		*again = TRUE;
d994 1
a994 1
		*again = TRUE;
d1052 1
a1052 1
		*again = TRUE;
d1109 1
a1109 1
		*again = TRUE;
d1150 1
a1150 1
		*again = TRUE;
d1185 1
a1185 1
  return TRUE;
d1197 1
a1197 1
  return FALSE;
d1202 1
a1202 1
static bfd_boolean
d1278 1
a1278 1
  return TRUE;
d1281 3
a1283 3
/* Return TRUE if a symbol exists at the given address, else return
   FALSE.  */
static bfd_boolean
d1307 1
a1307 1
	return TRUE;
d1321 1
a1321 1
	return TRUE;
d1324 1
a1324 1
  return FALSE;
d1337 1
a1337 1
     bfd_boolean relocateable;
d1370 1
a1370 1
			  (Elf_Internal_Rela *) NULL, FALSE));
@


1.16.2.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 2
a2 2
/* BFD back-end for Renesas H8/300 ELF binaries.
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003
@


1.16.2.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a575 6

    case E_H8_MACH_H8300HN:
      return bfd_mach_h8300hn;

    case E_H8_MACH_H8300SN:
      return bfd_mach_h8300sn;
a603 8

    case bfd_mach_h8300hn:
      val = E_H8_MACH_H8300HN;
      break;

    case bfd_mach_h8300sn:
      val = E_H8_MACH_H8300SN;
      break;
d767 3
a769 6
	  symval = isym->st_value;
	  /* If the reloc is absolute, it will not have
	     a symbol or section associated with it.  */
	  if (sym_sec)
	    symval += sym_sec->output_section->vma
	      + sym_sec->output_offset;
a1070 1
		bfd_boolean skip = FALSE;
d1088 10
a1097 21
		switch (code & 0xf0)
		  {
		  case 0x00:
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x80:
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x20:
		  case 0xa0:
		    /* Skip 32bit versions.  */
		    skip = TRUE;
		    break;
		  default:
		    abort ();
		  }

		if (skip)
		  break;
@


1.16.2.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d72 2
a73 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d86 2
a87 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d100 2
a101 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d114 3
a116 3
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
	 "R_H8_DIR8",		/* name */
d129 1
a129 1
	 special,		/* special_function */
d143 1
a143 1
	 special,		/* special_function */
d157 1
a157 1
	 special,		/* special_function */
d171 1
a171 1
	 special,		/* special_function */
d184 2
a185 2
	 complain_overflow_dont,/* complain_on_overflow */
	 special,		/* special_function */
d198 2
a199 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
d212 2
a213 2
	 complain_overflow_signed,/* complain_on_overflow */
	 special,		/* special_function */
a581 3

    case E_H8_MACH_H8300SX:
      return bfd_mach_h8300sx;
a617 4

    case bfd_mach_h8300sx:
      val = E_H8_MACH_H8300SX;
      break;
d712 1
a712 1
  internal_relocs = (_bfd_elf_link_read_relocs
d1026 1
a1026 4
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
d1084 1
a1084 4
		     /* FIXME: h8300hn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300s
		     /* FIXME: h8300sn? */
		     || bfd_get_mach (abfd) == bfd_mach_h8300sx)
d1397 1
a1397 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.16.2.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d429 1
a429 1
  if (info->relocatable)
a584 3

    case E_H8_MACH_H8300SXN:
      return bfd_mach_h8300sxn;
a624 4

    case bfd_mach_h8300sxn:
      val = E_H8_MACH_H8300SXN;
      break;
d702 1
a702 1
  /* We don't have to do anything for a relocatable link, if
d705 1
a705 1
  if (link_info->relocatable
d1374 1
a1374 1
					 data, relocatable, symbols)
d1379 1
a1379 1
     bfd_boolean relocatable;
d1391 1
a1391 1
  if (relocatable
d1395 1
a1395 1
						       relocatable,
@


1.16.2.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d28 1
a28 1
  (bfd *abfd, bfd_reloc_code_real_type code);
d30 1
a30 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d32 1
a32 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d34 1
a34 1
  (flagword);
d36 1
a36 1
  (bfd *, bfd_boolean);
d38 1
a38 1
  (bfd *);
d40 1
a40 1
  (bfd *, bfd *);
d42 1
a42 1
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
d44 1
a44 1
  (bfd *, asection *, bfd_vma, int);
d46 1
a46 1
  (bfd *, asection *, bfd_vma);
d48 2
a49 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
   bfd_byte *, bfd_boolean, asymbol **);
d51 3
a53 3
  (unsigned long, bfd *, bfd *, asection *,
   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
   struct bfd_link_info *, asection *, int);
d55 3
a57 3
  (bfd *, struct bfd_link_info *, bfd *, asection *,
   bfd_byte *, Elf_Internal_Rela *,
   Elf_Internal_Sym *, asection **);
d59 1
a59 1
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
d186 1
a186 1
	 "R_H8_DIR32A16",	/* name */
d246 3
a248 2
elf32_h8_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
d261 4
a264 2
elf32_h8_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			Elf_Internal_Rela *elf_reloc)
d280 4
a283 2
elf32_h8_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, arelent *bfd_reloc,
			    Elf_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED)
d297 9
a305 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d317 14
a330 8
elf32_h8_final_link_relocate (unsigned long r_type, bfd *input_bfd,
			      bfd *output_bfd ATTRIBUTE_UNUSED,
			      asection *input_section ATTRIBUTE_UNUSED,
			      bfd_byte *contents, bfd_vma offset,
			      bfd_vma value, bfd_vma addend,
			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
			      asection *sym_sec ATTRIBUTE_UNUSED,
			      int is_local ATTRIBUTE_UNUSED)
d336 1
d414 10
a423 5
elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			   bfd *input_bfd, asection *input_section,
			   bfd_byte *contents, Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
d562 2
a563 1
elf32_h8_mach (flagword flags)
d596 3
a598 2
elf32_h8_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
d642 2
a643 1
elf32_h8_object_p (bfd *abfd)
d655 3
a657 1
elf32_h8_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d692 5
a696 2
elf32_h8_relax_section (bfd *abfd, asection *sec,
			struct bfd_link_info *link_info, bfd_boolean *again)
d1034 1
a1034 1
	    bfd_vma value;
d1036 10
a1045 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
a1078 3
		/* Move the relocation.  */
		irel->r_offset--;

d1095 1
a1095 1
	    bfd_vma value;
d1097 10
a1106 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value >= 0xffffff00u)
d1108 1
d1128 1
a1128 1
		  case 0x20:
d1132 1
a1132 1
		  case 0xa0:
d1136 5
d1145 3
a1150 1
		irel->r_offset--;
d1153 1
a1153 2
		if (!elf32_h8_relax_delete_bytes (abfd, sec,
						  irel->r_offset + 1, 4))
a1158 1
		break;
d1168 1
a1168 1
	    bfd_vma value;
d1170 1
a1170 2
	    value = bfd_h8300_pad_address (abfd, symval + irel->r_addend);
	    if (value <= 0x7fff || value >= 0xffff8000u)
d1190 1
a1190 1
					     R_H8_DIR16);
d1252 5
a1256 1
elf32_h8_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, int count)
d1333 4
a1336 1
elf32_h8_symbol_address_p (bfd *abfd, asection *sec, bfd_vma addr)
d1380 8
a1387 6
elf32_h8_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
@


1.16.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d228 1
a228 1
/* An array mapping BFD reloc codes to H8 ELF relocs.  */
d438 1
a438 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
@


1.16.2.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d652 1
a652 1
   There are a few relaxing opportunities available on the H8:
d1119 1
a1119 1
	   become a 16-bit absolute address if it is in the right range.  */
@


1.16.2.10
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004
d33 8
a40 4
static unsigned long elf32_h8_mach (flagword);
static void elf32_h8_final_write_processing (bfd *, bfd_boolean);
static bfd_boolean elf32_h8_object_p (bfd *);
static bfd_boolean elf32_h8_merge_private_bfd_data (bfd *, bfd *);
d45 2
a46 1
static bfd_boolean elf32_h8_symbol_address_p (bfd *, asection *, bfd_vma);
a49 5
static asection *elf32_h8_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean elf32_h8_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d351 1
a351 1
	 value.  Subtract 1 so that we can manipulate the data in 32-bit
d361 1
a361 1
      /* Now scribble it out in one 32-bit hunk.  */
d643 2
a644 2
			       bfd_get_mach (ibfd)))
	return FALSE;
a661 4
     bset:16	     ->    bset:8                 2 bytes
     bset:24/32	     ->    bset:8                 4 bytes
     (also applicable to other bit manipulation instructions)

a664 3
     bset:24/32	     ->    bset:16                2 bytes
     (also applicable to other bit manipulation instructions)

d807 1
a807 1
        /* Try to turn a 24-bit absolute branch/call into an 8-bit
a917 1
		  /* This is jsr.  */
a919 1
		  /* This is jmp.  */
d940 1
a940 1
	/* Try to turn a 16-bit pc-relative branch into a 8-bit pc-relative
d974 1
a974 2
		    /* Get the second byte of the original insn, which
		       contains the condition code.  */
a975 5

		    /* Compute the fisrt byte of the relaxed
		       instruction.  The original sequence 0x58 0xX0
		       is relaxed to 0x4X, where X represents the
		       condition code.  */
a981 1
		  /* This is bsr.  */
d1003 2
a1004 9
	/* This is a 16-bit absolute address in one of the following
	   instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
a1012 1
		unsigned char temp_code;
d1023 1
a1023 2
		/* All instructions with R_H8_DIR16A8 start with
		   0x6a.  */
d1027 1
a1027 6
		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
		if ((temp_code & 0x10) != 0x10)
		  temp_code &= 0xf0;
d1029 10
a1038 28
		switch (temp_code)
		  {
		  case 0x00:
		    /* This is mov.b @@aa:16,Rd.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x20,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x80:
		    /* This is mov.b Rs,@@aa:16.  */
		    bfd_put_8 (abfd, (code & 0xf) | 0x30,
			       contents + irel->r_offset - 2);
		    break;
		  case 0x18:
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x10:
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
		  default:
		    abort ();
		  }
d1059 2
a1060 9
	/* This is a 24-bit absolute address in one of the following
	   instructions:

	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	     "mov.b"

	   We may relax this into an 8-bit absolute address if it's in
	   the right range.  */
a1068 1
		unsigned char temp_code;
d1079 1
a1079 2
		/* All instructions with R_H8_DIR24A8 start with
		   0x6a.  */
d1083 1
a1083 7
		temp_code = code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

		/* If this is a mov.b instruction, clear the lower
		   nibble, which contains the source/destination
		   register number.  */
		if ((temp_code & 0x30) != 0x30)
		  temp_code &= 0xf0;
d1085 1
a1085 1
		switch (temp_code)
a1087 1
		    /* This is mov.b @@aa:24/32,Rd.  */
a1091 1
		    /* This is mov.b Rs,@@aa:24/32.  */
a1094 13
		  case 0x38:
		    /* This is a bit-maniputation instruction that
		       stores one bit into memory, one of "bclr",
		       "bist", "bnot", "bset", and "bst".  */
		    bfd_put_8 (abfd, 0x7f, contents + irel->r_offset - 2);
		    break;
		  case 0x30:
		    /* This is a bit-maniputation instruction that
		       loads one bit from memory, one of "band",
		       "biand", "bild", "bior", "bixor", "bld", "bor",
		       "btst", and "bxor".  */
		    bfd_put_8 (abfd, 0x7e, contents + irel->r_offset - 2);
		    break;
d1096 1
a1096 1
		    abort();
d1116 1
a1116 4
	  /* Fall through.  */

	  /* This is a 24-/32-bit absolute address in one of the
	     following instructions:
d1118 2
a1119 6
	       "band", "bclr", "biand", "bild", "bior", "bist",
	       "bixor", "bld", "bnot", "bor", "bset", "bst", "btst",
	       "bxor", and "mov.[bwl]"

	     We may relax this into an 16-bit absolute address if it's
	     in the right range.  */
d1138 1
a1138 3
		/* Fix the opcode.  For all the instructions that
		   belong to this relaxation, we simply need to turn
		   off bit 0x20 in the previous byte.  */
a1430 36
static asection *
elf32_h8_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (h->root.type)
        {
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
          return h->root.u.def.section;

	case bfd_link_hash_common:
          return h->root.u.c.p->section;

	default:
          break;
        }
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
  return NULL;
}

static bfd_boolean
elf32_h8_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
}

a1448 2
#define elf_backend_gc_mark_hook        elf32_h8_gc_mark_hook
#define elf_backend_gc_sweep_hook       elf32_h8_gc_sweep_hook
a1459 1
#define elf_backend_can_gc_sections	1
@


1.15
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d768 1
a768 1
	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
@


1.14
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d432 3
d450 1
a452 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d1451 1
@


1.14.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d785 1
a785 1
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
@


1.14.2.2
log
@	Merge from mainline:
	2002-11-15  Kazu Hirata  <kazu@@cs.umass.edu>
	* coff-h8300.c (h8300_reloc16_estimate): Do not optimize away
	jsr after a short jump.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
@
text
@a849 3
		/* Get the instruction code being relaxed.  */
		code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

d856 2
a857 19
		   long conditional branches.

		   Only perform this optimisation for jumps (code 0x5a) not
		   subroutine calls, as otherwise it could transform:

		   	             mov.w   r0,r0
		   	             beq     .L1
		         	     jsr     @@_bar
		              .L1:   rts
		              _bar:  rts
		   into:
		   	             mov.w   r0,r0
			             bne     _bar
			             rts
			      _bar:  rts

		   which changes the call (jsr) into a branch (bne).  */
		if (code == 0x5a
		    && (int) gap <= 130
d913 3
@


1.13
log
@        * elf32-h8300.c (elf32_h8_relax_section): Ignore uninteresting
        relocations.
@
text
@a690 1
  Elf_Internal_Shdr *shndx_hdr;
a691 1
  Elf_Internal_Rela *free_relocs = NULL;
d694 1
a694 4
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
a715 1
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
a722 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a758 1
	      free_contents = contents;
d767 1
a767 1
      if (extsyms == NULL)
d769 7
a775 32
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      /* Go get them off disk.  */
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info * sizeof (Elf32_External_Sym);
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	      symtab_hdr->contents = (PTR) extsyms;
	    }

	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (PTR) shndx_buf;
	    }
d781 2
a782 3
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  Elf_Internal_Sym isym;
d785 3
a787 8
	  /* A local symbol.  */
	  esym = extsyms + ELF32_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);

	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
a846 2
		free_relocs = NULL;

d848 1
a848 3
		free_contents = NULL;

		free_extsyms = NULL;
a862 2
		    Elf32_External_Sym *esym;
		    Elf_External_Sym_Shndx *shndx;
d865 1
a865 1
		    Elf_Internal_Sym last_symbol;
d870 1
a870 8
		    esym = extsyms + ELF32_R_SYM (last_reloc->r_info);
		    shndx = shndx_buf;
		    if (shndx != NULL)
		      shndx += ELF32_R_SYM (last_reloc->r_info);
		    bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					      (const PTR) shndx,
					      &last_symbol);

d872 2
a873 2
		      = bfd_section_from_elf_index (abfd, last_symbol.st_shndx);
		    last_value = (last_symbol.st_value
a964 2
	        free_relocs = NULL;

d966 1
a966 3
	        free_contents = NULL;

	        free_extsyms = NULL;
a1021 2
	        free_relocs = NULL;

d1023 1
a1023 3
	        free_contents = NULL;

	        free_extsyms = NULL;
a1079 2
	        free_relocs = NULL;

d1081 1
a1081 3
	        free_contents = NULL;

	        free_extsyms = NULL;
a1131 2
	        free_relocs = NULL;

d1133 1
a1133 3
	        free_contents = NULL;

	        free_extsyms = NULL;
d1164 2
a1165 1
  if (free_relocs != NULL)
d1167 4
a1170 2
      free (free_relocs);
      free_relocs = NULL;
d1173 2
a1174 1
  if (free_contents != NULL)
d1177 1
a1177 1
	free (free_contents);
a1182 1
      free_contents = NULL;
d1185 3
a1187 14
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }

  if (free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	{
	  symtab_hdr->contents = NULL;
	  free (free_extsyms);
	}
    }
d1192 9
a1200 14
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }
  if (free_extsyms != NULL)
    {
      symtab_hdr->contents = NULL;
      free (free_extsyms);
    }
a1213 2
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
d1218 2
a1220 2
  Elf32_External_Sym *esym, *esymend;
  Elf_External_Sym_Shndx *shndx;
a1224 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

d1253 9
a1261 19
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym, &dummy);
	}
a1293 1
  Elf_Internal_Shdr *shndx_hdr;
d1295 2
a1296 2
  Elf32_External_Sym *esym, *esymend;
  Elf_External_Sym_Shndx *shndx;
d1305 3
a1307 5
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = (Elf32_External_Sym *) symtab_hdr->contents;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
d1309 2
a1310 7
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value == addr)
a1344 1
  Elf_Internal_Shdr *shndx_hdr;
d1349 1
a1349 4
  Elf32_External_Sym *external_syms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *internal_syms = NULL;
a1360 1
  shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
a1367 1
      Elf_Internal_Sym *isymp;
d1369 1
a1369 1
      Elf32_External_Sym *esym, *esymend;
a1371 26
      if (symtab_hdr->contents != NULL)
	external_syms = (Elf32_External_Sym *) symtab_hdr->contents;
      else if (symtab_hdr->sh_info != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf32_External_Sym);
	  external_syms = (Elf32_External_Sym *) bfd_malloc (amt);
	  if (external_syms == NULL)
	    goto error_return;
	  if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) external_syms, amt, input_bfd) != amt)
	    goto error_return;
	}

      if (symtab_hdr->sh_info != 0 && shndx_hdr->sh_size != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf_External_Sym_Shndx);
	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (shndx_buf == NULL)
	    goto error_return;
	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) shndx_buf, amt, input_bfd) != amt)
	    goto error_return;
	}

d1378 10
a1387 5
      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf_Internal_Sym);
      internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (internal_syms == NULL && amt != 0)
	goto error_return;
d1395 2
a1396 4
      for (isymp = internal_syms, secpp = sections, shndx = shndx_buf,
	     esym = external_syms, esymend = esym + symtab_hdr->sh_info;
	   esym < esymend;
	   ++esym, ++isymp, ++secpp, shndx = (shndx ? shndx + 1 : NULL))
d1400 1
a1400 4
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);

	  if (isymp->st_shndx == SHN_UNDEF)
d1402 1
a1402 1
	  else if (isymp->st_shndx == SHN_ABS)
d1404 1
a1404 1
	  else if (isymp->st_shndx == SHN_COMMON)
d1407 1
a1407 1
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d1414 1
a1414 1
				       internal_syms, sections))
d1419 4
a1422 7
      if (internal_syms != NULL)
	free (internal_syms);
      if (shndx_buf != NULL)
	free (shndx_buf);
      if (external_syms != NULL && symtab_hdr->contents == NULL)
	free (external_syms);
      if (internal_relocs != elf_section_data (input_section)->relocs)
d1429 5
d1435 1
a1435 1
      && internal_relocs != elf_section_data (input_section)->relocs)
a1436 8
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (external_syms != NULL && symtab_hdr->contents == NULL)
    free (external_syms);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
@


1.12
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d681 1
a681 4
     mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes


*/
d747 7
@


1.11
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d819 2
a820 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
d916 2
a917 2
		    bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
					      (const PTR *) shndx,
d1345 1
a1345 1
      bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym, (const PTR *) shndx,
d1407 1
a1407 1
      bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym, (const PTR *) shndx,
d1530 2
a1531 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR *) esym,
				    (const PTR *) shndx, isymp);
@


1.10
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 1995, 1998, 1999, 2001 Free Software Foundation, Inc.
d819 2
a820 1
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d916 3
a918 1
		    bfd_elf32_swap_symbol_in (abfd, esym, shndx, &last_symbol);
d1345 2
a1346 1
      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d1407 2
a1408 1
      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d1530 2
a1531 1
	  bfd_elf32_swap_symbol_in (input_bfd, esym, shndx, isymp);
@


1.10.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 2
   Copyright 1993, 1995, 1998, 1999, 2001, 2002
   Free Software Foundation, Inc.
d680 4
a683 1
     mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes */
a749 7
      if (ELF32_R_TYPE (irel->r_info) != R_H8_DIR24R8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_PCREL16
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR16A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR24A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR32A16)
	continue;

d818 1
a818 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d914 1
a914 3
		    bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					      (const PTR) shndx,
					      &last_symbol);
d1341 1
a1341 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d1402 1
a1402 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d1524 1
a1524 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
@


1.10.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d691 1
d693 1
d696 4
a699 1
  Elf_Internal_Sym *isymbuf = NULL;
d721 1
d729 2
d767 1
d776 1
a776 1
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d778 32
a809 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d815 5
d821 4
a824 2
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;
d826 2
a827 3
	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
d887 2
d890 3
a892 1
		symtab_hdr->contents = (unsigned char *) isymbuf;
d907 2
d911 1
a911 1
		    Elf_Internal_Sym *last_sym;
d916 8
a923 1
		    last_sym = isymbuf + ELF32_R_SYM (last_reloc->r_info);
d925 2
a926 2
		      = bfd_section_from_elf_index (abfd, last_sym->st_shndx);
		    last_value = (last_sym->st_value
d1018 2
d1021 3
a1023 1
		symtab_hdr->contents = (unsigned char *) isymbuf;
d1079 2
d1082 3
a1084 1
		symtab_hdr->contents = (unsigned char *) isymbuf;
d1141 2
d1144 3
a1146 1
		symtab_hdr->contents = (unsigned char *) isymbuf;
d1197 2
d1200 3
a1202 1
		symtab_hdr->contents = (unsigned char *) isymbuf;
d1233 1
a1233 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1235 2
a1236 4
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	symtab_hdr->contents = (unsigned char *) isymbuf;
d1239 1
a1239 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d1242 1
a1242 1
	free (contents);
d1248 1
d1251 14
a1264 3
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d1269 14
a1282 9
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d1296 2
a1301 2
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
d1303 2
d1309 3
d1340 19
a1358 9
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
d1391 1
d1393 2
a1394 2
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
d1403 5
a1407 3
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
d1409 7
a1415 2
      if (isym->st_shndx == sec_shndx
	  && isym->st_value == addr)
d1450 1
d1455 4
a1458 1
  Elf_Internal_Sym *isymbuf = NULL;
d1470 1
d1478 1
d1480 1
a1480 1
      Elf_Internal_Sym *isym, *isymend;
d1483 26
d1515 5
a1519 10
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}
d1527 4
a1530 2
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
d1534 4
a1537 1
	  if (isym->st_shndx == SHN_UNDEF)
d1539 1
a1539 1
	  else if (isym->st_shndx == SHN_ABS)
d1541 1
a1541 1
	  else if (isym->st_shndx == SHN_COMMON)
d1544 1
a1544 1
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
d1551 1
a1551 1
				       isymbuf, sections))
d1556 7
a1562 4
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
d1569 9
a1579 6
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
@


1.10.10.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a431 3
  if (info->relocateable)
    return true;

a446 1
      /* This is a final link.  */
d449 21
a1467 1
#define elf_backend_rela_normal		1
@


1.10.10.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d768 1
a768 1
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
@


1.10.8.1
log
@merge from trunk
@
text
@d2 1
a2 2
   Copyright 1993, 1995, 1998, 1999, 2001, 2002
   Free Software Foundation, Inc.
d680 4
a683 1
     mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes */
a749 7
      if (ELF32_R_TYPE (irel->r_info) != R_H8_DIR24R8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_PCREL16
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR16A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR24A8
	  && ELF32_R_TYPE (irel->r_info) != R_H8_DIR32A16)
	continue;

d818 1
a818 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d914 1
a914 3
		    bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					      (const PTR) shndx,
					      &last_symbol);
d1341 1
a1341 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d1402 1
a1402 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d1524 1
a1524 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
@


1.9
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d45 1
a45 1
  PARAMS ((bfd *, asection *, Elf32_External_Sym *, bfd_vma));
d693 1
d701 1
d723 1
d770 1
a770 1
      /* Read this BFD's symbols if we haven't done so already.  */
d779 4
a782 2
	      extsyms = ((Elf32_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
d787 1
a787 2
		  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
d789 15
d810 2
d816 3
a818 3
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irel->r_info),
				    &isym);
a885 1
		symtab_hdr->contents = (bfd_byte *) extsyms;
d901 2
d910 5
a914 3
		    bfd_elf32_swap_symbol_in (abfd,
					      (extsyms + ELF32_R_SYM (last_reloc->r_info)),
					      &last_symbol);
d927 1
a927 2
			&& ! elf32_h8_symbol_address_p (abfd, sec,
						        extsyms, dot))
a1014 1
	        symtab_hdr->contents = (bfd_byte *) extsyms;
a1075 1
	        symtab_hdr->contents = (bfd_byte *) extsyms;
a1137 1
	        symtab_hdr->contents = (bfd_byte *) extsyms;
a1193 1
	        symtab_hdr->contents = (bfd_byte *) extsyms;
d1243 6
a1251 2
	free (free_extsyms);
      else
d1253 2
a1254 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) extsyms;
a1255 1
      free_extsyms = NULL;
d1265 5
d1271 4
a1274 1
    free (free_extsyms);
d1288 1
d1290 1
a1290 1
  int shndx, index;
d1296 4
a1299 1
  struct elf_link_hash_entry *sym_hash;
d1304 1
a1304 1
  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1332 2
d1336 1
a1336 1
  for (; esym < esymend; esym++)
d1339 1
d1341 1
a1341 1
      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
d1343 1
a1343 1
      if (isym.st_shndx == shndx
d1348 1
a1348 1
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym);
d1353 5
a1357 3
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
  for (index = 0; esym < esymend; esym++, index++)
d1359 6
a1364 10
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
      sym_hash = elf_sym_hashes (abfd)[index];
      if (isym.st_shndx == shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value > addr
	  && (sym_hash)->root.u.def.value < toaddr)
d1366 1
a1366 1
	  (sym_hash)->root.u.def.value -= count;
d1376 1
a1376 1
elf32_h8_symbol_address_p (abfd, sec, extsyms, addr)
a1378 1
     Elf32_External_Sym *extsyms;
d1382 2
a1383 1
  int shndx;
d1385 4
a1388 1
  struct elf_link_hash_entry **sym_hash, **sym_hash_end;
d1390 1
a1390 2
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1393 4
a1396 1
  esym = extsyms;
d1398 1
a1398 1
  for (; esym < esymend; esym++)
d1402 1
a1402 1
      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
d1404 1
a1404 1
      if (isym.st_shndx == shndx
d1409 5
a1413 5
  sym_hash = elf_sym_hashes (abfd);
  sym_hash_end = (sym_hash
		  + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		     - symtab_hdr->sh_info));
  for (; sym_hash < sym_hash_end; sym_hash++)
d1415 5
a1419 4
      if (((*sym_hash)->root.type == bfd_link_hash_defined
	   || (*sym_hash)->root.type == bfd_link_hash_defweak)
	  && (*sym_hash)->root.u.def.section == sec
	  && (*sym_hash)->root.u.def.value == addr)
d1422 1
d1440 1
d1446 2
d1460 1
d1471 1
d1475 1
a1475 1
      else
a1476 2
	  bfd_size_type amt;

d1480 1
a1480 1
	  if (external_syms == NULL && symtab_hdr->sh_info > 0)
d1483 13
a1495 1
	      || bfd_bread (external_syms, amt, input_bfd) != amt)
d1505 4
a1508 4
      internal_syms = ((Elf_Internal_Sym *)
		       bfd_malloc ((bfd_size_type) symtab_hdr->sh_info
				   * sizeof (Elf_Internal_Sym)));
      if (internal_syms == NULL && symtab_hdr->sh_info > 0)
d1511 4
a1514 3
      sections = (asection **) bfd_malloc ((bfd_size_type) symtab_hdr->sh_info
					   * sizeof (asection *));
      if (sections == NULL && symtab_hdr->sh_info > 0)
d1517 4
a1520 5
      isymp = internal_syms;
      secpp = sections;
      esym = external_syms;
      esymend = esym + symtab_hdr->sh_info;
      for (; esym < esymend; ++esym, ++isymp, ++secpp)
d1524 1
a1524 1
	  bfd_elf32_swap_symbol_in (input_bfd, esym, isymp);
a1527 2
	  else if (isymp->st_shndx > 0 && isymp->st_shndx < SHN_LORESERVE)
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d1533 1
a1533 4
	    {
	      /* Who knows?  */
	      isec = NULL;
	    }
a1544 1
      sections = NULL;
d1547 2
a1548 1
      internal_syms = NULL;
a1550 1
      external_syms = NULL;
a1552 1
      internal_relocs = NULL;
d1561 2
@


1.8
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d476 1
a476 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1233 1
a1233 1
	  symtab_hdr->contents = extsyms;
@


1.6
log
@        * elf32-h8300.c (elf32_h8_relax_section): New function.
        (elf32_h8_relax_delete_bytes): Likewise.
        (elf32_h8_symbol_address_p): Likewise.
        (elf32_h8_get_relocated_section_contents): Likewise.
        (bfd_elf32_bfd_relax_section): Define.
        (bfd_elf32_bfd_get_relocated_section_contents): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1998, 1999 Free Software Foundation, Inc.
d32 1
a32 1
static int elf32_h8_mach
d34 15
d57 1
a57 1
static bfd_reloc_status_type special 
d438 1
a438 1
      int r_type;
d521 1
a521 1
	  
d582 1
a582 1
static int
d604 1
a604 1
void
d634 1
a634 1
boolean
d647 1
a647 1
boolean
d683 1
a683 1
	
d784 1
a784 1
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d855 1
a855 1
	    if ((int)gap >= -126 && (int)gap <= 130)
d877 2
a878 2
		if (gap <= 130
		    && gap >= -128
d889 1
a889 1
		
d976 1
a976 1
	  
d1286 2
a1287 1
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
d1419 1
a1419 1
	  input_section->_raw_size);
d1432 5
a1436 3
	  external_syms = ((Elf32_External_Sym *)
			   bfd_malloc (symtab_hdr->sh_info
				       * sizeof (Elf32_External_Sym)));
d1440 1
a1440 3
	      || (bfd_read (external_syms, sizeof (Elf32_External_Sym),
			    symtab_hdr->sh_info, input_bfd)
		  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
d1451 1
a1451 1
		       bfd_malloc (symtab_hdr->sh_info
d1456 1
a1456 1
      sections = (asection **) bfd_malloc (symtab_hdr->sh_info
@


1.5
log
@        * elf32-h8300.c (special): New function.
        (h8_elf_howto_table): Use it for SPECIAL_FUNCTION field in
        all relocations.
        (elf32_h8_final_link_relocate): Treat R_H8_DIR24A8 like 32bit
        relocations.  Fix problems with the true 24bit reloc R_H8_DIR24R8.
        Fix minor problems with 8bit and 16bit PC relative relocations.
@
text
@d652 854
d1534 6
@


1.4
log
@	* elf32-h8300.c (h8_elf_howto_table): Add new PC relative
	relocations.
	(h8_reloc_map): Similarly.
	(elf32_h8_final_link_relocate): Remove incorrect overflow tests.
	Add support for PC relative relocations.
@
text
@d42 2
d58 1
a58 1
	 NULL,			/* special_function */
d72 1
a72 1
	 NULL,			/* special_function */
d86 1
a86 1
	 NULL,			/* special_function */
d100 1
a100 1
	 NULL,			/* special_function */
d114 1
a114 1
	 NULL,			/* special_function */
d128 1
a128 1
	 NULL,			/* special_function */
d142 1
a142 1
	 NULL,			/* special_function */
d156 1
a156 1
	 NULL,			/* special_function */
d170 1
a170 1
	 NULL,			/* special_function */
d184 1
a184 1
	 NULL,			/* special_function */
d198 1
a198 1
	 NULL,			/* special_function */
d279 22
d329 1
a347 1
    case R_H8_DIR24A8:
d351 6
d358 2
d361 2
d372 5
d385 5
@


1.3
log
@        * elf32-h8300.c: Put all prototypes together.
        (elf32_h8_info_to_howto): Parameter elf_reloc is used.
        (elf32_h8_final_link_relocate): New function for linker.
        (elf32_h8_relocate_section): Similarly.
        (elf_backend_relocate_section): Define.
@
text
@d174 28
d225 2
a319 3
      if ((long) value > 0x7f || (long) value < -0x80)
	return bfd_reloc_overflow;

a326 3
      if ((long) value > 0x7fffff || (long) value < -0x800000)
	return bfd_reloc_overflow;

d330 18
@


1.2
log
@        * cpu-h8300.c (h8300_scan, compatible): Prototype.
        (h8300_scan): Handle architecture:machine encodings typically
        found in linker scripts.
        * elf.c (prep_headers): Do not try to do H8 machine recognition
        here.
        * elf32-h8300.c:  Add some missing prototypes.
        (elf32_h8_mach, elf32_h8_final_write_processing): New functions.
        (elf32_h8_object_p): Similarly.
@
text
@d30 12
a198 8
static reloc_howto_type *elf32_h8_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf32_h8_info_to_howto
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
static void elf32_h8_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
static int elf32_h8_mach
  PARAMS ((flagword));
d219 1
a219 1
     Elf32_Internal_Rela *elf_reloc ATTRIBUTE_UNUSED;
d247 229
d591 3
@


1.1
log
@	* Makefile.am (elf32-h8300.lo): New target.
	* config.bfd (h8300*-*-elf): New case.
	* configure.in (bfd_elf32_h8300_vec): New case.
	* elf.c (prep_headers): Add case for bfd_arch_h8300.
	* reloc.c (BFD_RELOC_H8_DIR16A8): New relocation.
	(BFD_RELOC_H8_DIR16R8, BFD_RELOC_H8_DIR24A8): Likewise.
	(BFD_RELOC_H8_DIR24R8, BFD_RELOC_H8_DIR32A16): Likewise.
	* targets.c (bfd_target bfd_elf32_h8300_vec): New extern declaration.
	* elf32-h8300.c: New file.
	* Makefile.in, bfd-in2.h, libbfd.h, configure: Regenerated.
@
text
@d187 9
d243 91
d342 9
@

