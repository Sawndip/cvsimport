head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	binutils-2_24-branch:1.15.0.4
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.13
	sid-snapshot-20130901:1.15
	gdb_7_6_1-2013-08-30-release:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	gdb_7_6-2013-04-26-release:1.15
	sid-snapshot-20130401:1.15
	binutils-2_23_2:1.14
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.14
	sid-snapshot-20121201:1.14
	gdb_7_5_1-2012-11-29-release:1.14
	binutils-2_23_1:1.14
	sid-snapshot-20121101:1.14
	binutils-2_23:1.14
	sid-snapshot-20121001:1.14
	sid-snapshot-20120901:1.14
	gdb_7_5-2012-08-17-release:1.14
	sid-snapshot-20120801:1.14
	binutils-2_23-branch:1.14.0.12
	binutils-2_23-branchpoint:1.14
	gdb_7_5-branch:1.14.0.10
	gdb_7_5-2012-07-18-branchpoint:1.14
	sid-snapshot-20120701:1.14
	sid-snapshot-20120601:1.14
	sid-snapshot-20120501:1.14
	binutils-2_22_branch:1.14.0.8
	gdb_7_4_1-2012-04-26-release:1.14
	sid-snapshot-20120401:1.14
	sid-snapshot-20120301:1.14
	sid-snapshot-20120201:1.14
	gdb_7_4-2012-01-24-release:1.14
	sid-snapshot-20120101:1.14
	gdb_7_4-branch:1.14.0.6
	gdb_7_4-2011-12-13-branchpoint:1.14
	sid-snapshot-20111201:1.14
	binutils-2_22:1.14
	sid-snapshot-20111101:1.14
	sid-snapshot-20111001:1.14
	binutils-2_22-branch:1.14.0.4
	binutils-2_22-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	sid-snapshot-20110901:1.14
	sid-snapshot-20110801:1.14
	gdb_7_3-2011-07-26-release:1.14
	sid-snapshot-20110701:1.14
	sid-snapshot-20110601:1.14
	sid-snapshot-20110501:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	sid-snapshot-20110401:1.14
	sid-snapshot-20110301:1.14
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	binutils-2_21:1.13
	sid-snapshot-20101201:1.13
	binutils-2_21-branch:1.13.0.6
	binutils-2_21-branchpoint:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	binutils-2_20_1:1.12
	gdb_7_2-2010-09-02-release:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	gdb_7_2-branch:1.13.0.4
	gdb_7_2-2010-07-07-branchpoint:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	gdb_7_1-2010-03-18-release:1.13
	sid-snapshot-20100301:1.13
	gdb_7_1-branch:1.13.0.2
	gdb_7_1-2010-02-18-branchpoint:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	gdb_7_0_1-2009-12-22-release:1.12
	sid-snapshot-20091201:1.12
	sid-snapshot-20091101:1.12
	binutils-2_20:1.12
	gdb_7_0-2009-10-06-release:1.12
	sid-snapshot-20091001:1.12
	gdb_7_0-branch:1.12.0.10
	gdb_7_0-2009-09-16-branchpoint:1.12
	arc-sim-20090309:1.10
	binutils-arc-20081103-branch:1.11.0.14
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.12.0.8
	binutils-2_20-branchpoint:1.12
	sid-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	msnyder-checkpoint-072509-branch:1.12.0.6
	msnyder-checkpoint-072509-branchpoint:1.12
	sid-snapshot-20090701:1.12
	dje-cgen-play1-branch:1.12.0.4
	dje-cgen-play1-branchpoint:1.12
	sid-snapshot-20090601:1.12
	sid-snapshot-20090501:1.12
	sid-snapshot-20090401:1.12
	arc-20081103-branch:1.11.0.12
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.10.0.10
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.8
	insight_6_8-branchpoint:1.10
	sid-snapshot-20090301:1.12
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	reverse-20081226-branch:1.12.0.2
	reverse-20081226-branchpoint:1.12
	sid-snapshot-20081201:1.12
	multiprocess-20081120-branch:1.11.0.10
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.8
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.6
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.4
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.2
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.8.0.34
	drow-reverse-20070409-branchpoint:1.8
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.10
	sid-snapshot-20080301:1.10
	gdb_6_8-branch:1.10.0.6
	gdb_6_8-2008-02-26-branchpoint:1.10
	sid-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	sid-snapshot-20071001:1.10
	gdb_6_7-branch:1.10.0.4
	gdb_6_7-2007-09-07-branchpoint:1.10
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	insight_6_6-20070208-release:1.8
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	gdb_6_6-2006-12-18-release:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.5.2.1
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	gdb_6_6-branch:1.8.0.32
	gdb_6_6-2006-11-15-branchpoint:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.5.2.1
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.5.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.5.2.1
	gdb-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	binutils-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.5.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	binutils-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.30
	gdb_6_5-2006-05-14-branchpoint:1.8
	binutils-csl-coldfire-4_1-10:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.28
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.26
	msnyder-reverse-20060502-branchpoint:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.5.2.1
	gdb-csl-morpho-4_1-4:1.8
	binutils-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.5.2.1
	readline_5_1-import-branch:1.8.0.24
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	binutils-2_17-branch:1.8.0.22
	binutils-2_17-branchpoint:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.20
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.18
	msnyder-reverse-20060331-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.16
	binutils-csl-2_17-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.14
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.12
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.10
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.6
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.4
	gdb-csl-arm-20051020-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.5.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.5.2.1
	binutils-2_16_1:1.5.2.1
	msnyder-tracepoint-checkpoint-branch:1.8.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.6
	binutils-csl-arm-2005q1b:1.5.2.1
	binutils-2_16:1.5.2.1
	gdb-csl-arm-20050325-2005-q1a:1.6
	binutils-csl-arm-2005q1a:1.5.2.1
	csl-arm-20050325-branch:1.6.0.2
	csl-arm-20050325-branchpoint:1.6
	binutils-csl-arm-2005q1-branch:1.5.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.5.2.1
	binutils-2_16-branch:1.5.0.2
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.2
	gdb_6_3-20041019-branchpoint:1.3
	csl-arm-2004-q3:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.42
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.38
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	binutils-2_15:1.2
	binutils-2_15-branchpoint:1.2
	csl-arm-2004-q1a:1.2
	csl-arm-2004-q1:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.36
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.34
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.32
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.30
	drow_intercu-20040221-branchpoint:1.2
	binutils-2_15-branch:1.2.0.28
	cagney_bfdfile-20040213-branch:1.2.0.26
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.24
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	csl-arm-2003-q4:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.22
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.20
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.18
	cagney_x86i386-20030821-branch:1.2.0.16
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.14
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.2
	binutils-2_14:1.1.10.1
	cagney_convert-20030606-branch:1.2.0.10
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.8
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.4
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.10
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.8
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.6
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.4
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.2
	binutils_latest_snapshot:1.15;
locks; strict;
comment	@ * @;


1.15
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.21.22.13.31;	author sterling;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.03.23.23.40;	author bwilson;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.04.15.53.41;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.04.07.19.40;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.22.19.31.28;	author bwilson;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.11.12.21.59.11;	author bwilson;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.08.00.22.10;	author bwilson;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.09.11.35.35;	author amodra;	state Exp;
branches
	1.2.22.1;
next	1.1;

1.1
date	2003.04.01.15.50.27;	author nickc;	state Exp;
branches
	1.1.6.1
	1.1.8.1
	1.1.10.1;
next	;

1.5.2.1
date	2005.03.22.19.51.16;	author bwilson;	state Exp;
branches;
next	;

1.2.22.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.1.6.1
date	2003.04.16.19.56.47;	author carlton;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.23.18.40.29;	author carlton;	state Exp;
branches;
next	;

1.1.8.1
date	2003.05.18.09.43.49;	author kettenis;	state Exp;
branches;
next	;

1.1.10.1
date	2003.05.09.11.38.06;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* Configurable Xtensa ISA support.
   Copyright 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "xtensa-isa.h"
#include "xtensa-isa-internal.h"

xtensa_isa_status xtisa_errno;
char xtisa_error_msg[1024];


xtensa_isa_status
xtensa_isa_errno (xtensa_isa isa __attribute__ ((unused)))
{
  return xtisa_errno;
}


char *
xtensa_isa_error_msg (xtensa_isa isa __attribute__ ((unused)))
{
  return xtisa_error_msg;
}


#define CHECK_ALLOC(MEM,ERRVAL) \
  do { \
    if ((MEM) == 0) \
      { \
	xtisa_errno = xtensa_isa_out_of_memory; \
	strcpy (xtisa_error_msg, "out of memory"); \
	return (ERRVAL); \
      } \
  } while (0)

#define CHECK_ALLOC_FOR_INIT(MEM,ERRVAL,ERRNO_P,ERROR_MSG_P) \
  do { \
    if ((MEM) == 0) \
      { \
	xtisa_errno = xtensa_isa_out_of_memory; \
	strcpy (xtisa_error_msg, "out of memory"); \
	if (ERRNO_P) *(ERRNO_P) = xtisa_errno; \
	if (ERROR_MSG_P) *(ERROR_MSG_P) = xtisa_error_msg; \
	return (ERRVAL); \
      } \
  } while (0)



/* Instruction buffers.  */

int
xtensa_insnbuf_size (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->insnbuf_size;
}


xtensa_insnbuf
xtensa_insnbuf_alloc (xtensa_isa isa)
{
  xtensa_insnbuf result = (xtensa_insnbuf)
    malloc (xtensa_insnbuf_size (isa) * sizeof (xtensa_insnbuf_word));
  CHECK_ALLOC (result, 0);
  return result;
}


void
xtensa_insnbuf_free (xtensa_isa isa __attribute__ ((unused)),
		     xtensa_insnbuf buf)
{
  free (buf);
}


/* Given <byte_index>, the index of a byte in a xtensa_insnbuf, our
   internal representation of a xtensa instruction word, return the index of
   its word and the bit index of its low order byte in the xtensa_insnbuf.  */

static inline int
byte_to_word_index (int byte_index)
{
  return byte_index / sizeof (xtensa_insnbuf_word);
}


static inline int
byte_to_bit_index (int byte_index)
{
  return (byte_index & 0x3) * 8;
}


/* Copy an instruction in the 32-bit words pointed at by "insn" to
   characters pointed at by "cp".  This is more complicated than you
   might think because we want 16-bit instructions in bytes 2 & 3 for
   big-endian configurations.  This function allows us to specify
   which byte in "insn" to start with and which way to increment,
   allowing trivial implementation for both big- and little-endian
   configurations....and it seems to make pretty good code for
   both.  */

int
xtensa_insnbuf_to_chars (xtensa_isa isa,
			 const xtensa_insnbuf insn,
			 unsigned char *cp,
			 int num_chars)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int insn_size = xtensa_isa_maxlength (isa);
  int fence_post, start, increment, i, byte_count;
  xtensa_format fmt;

  if (num_chars == 0)
    num_chars = insn_size;

  if (intisa->is_big_endian)
    {
      start = insn_size - 1;
      increment = -1;
    }
  else
    {
      start = 0;
      increment = 1;
    }

  /* Find the instruction format.  Do nothing if the buffer does not contain
     a valid instruction since we need to know how many bytes to copy.  */
  fmt = xtensa_format_decode (isa, insn);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  byte_count = xtensa_format_length (isa, fmt);
  if (byte_count == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (byte_count > num_chars)
    {
      xtisa_errno = xtensa_isa_buffer_overflow;
      strcpy (xtisa_error_msg, "output buffer too small for instruction");
      return XTENSA_UNDEFINED;
    }

  fence_post = start + (byte_count * increment);

  for (i = start; i != fence_post; i += increment, ++cp)
    {
      int word_inx = byte_to_word_index (i);
      int bit_inx = byte_to_bit_index (i);

      *cp = (insn[word_inx] >> bit_inx) & 0xff;
    }

  return byte_count;
}


/* Inward conversion from byte stream to xtensa_insnbuf.  See
   xtensa_insnbuf_to_chars for a discussion of why this is complicated
   by endianness.  */

void
xtensa_insnbuf_from_chars (xtensa_isa isa,
			   xtensa_insnbuf insn,
			   const unsigned char *cp,
			   int num_chars)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int max_size, insn_size, fence_post, start, increment, i;

  max_size = xtensa_isa_maxlength (isa);

  /* Decode the instruction length so we know how many bytes to read.  */
  insn_size = (intisa->length_decode_fn) (cp);
  if (insn_size == XTENSA_UNDEFINED)
    {
      /* This should never happen when the byte stream contains a
	 valid instruction.  Just read the maximum number of bytes....  */
      insn_size = max_size;
    }

  if (num_chars == 0 || num_chars > insn_size)
    num_chars = insn_size;

  if (intisa->is_big_endian)
    {
      start = max_size - 1;
      increment = -1;
    }
  else
    {
      start = 0;
      increment = 1;
    }

  fence_post = start + (num_chars * increment);
  memset (insn, 0, xtensa_insnbuf_size (isa) * sizeof (xtensa_insnbuf_word));

  for (i = start; i != fence_post; i += increment, ++cp)
    {
      int word_inx = byte_to_word_index (i);
      int bit_inx = byte_to_bit_index (i);

      insn[word_inx] |= (*cp & 0xff) << bit_inx;
    }
}



/* ISA information.  */

extern xtensa_isa_internal xtensa_modules;

xtensa_isa
xtensa_isa_init (xtensa_isa_status *errno_p, char **error_msg_p)
{
  xtensa_isa_internal *isa = &xtensa_modules;
  int n, is_user;

  /* Set up the opcode name lookup table.  */
  isa->opname_lookup_table =
    bfd_malloc (isa->num_opcodes * sizeof (xtensa_lookup_entry));
  CHECK_ALLOC_FOR_INIT (isa->opname_lookup_table, NULL, errno_p, error_msg_p);
  for (n = 0; n < isa->num_opcodes; n++)
    {
      isa->opname_lookup_table[n].key = isa->opcodes[n].name;
      isa->opname_lookup_table[n].u.opcode = n;
    }
  qsort (isa->opname_lookup_table, isa->num_opcodes,
	 sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);

  /* Set up the state name lookup table.  */
  isa->state_lookup_table =
    bfd_malloc (isa->num_states * sizeof (xtensa_lookup_entry));
  CHECK_ALLOC_FOR_INIT (isa->state_lookup_table, NULL, errno_p, error_msg_p);
  for (n = 0; n < isa->num_states; n++)
    {
      isa->state_lookup_table[n].key = isa->states[n].name;
      isa->state_lookup_table[n].u.state = n;
    }
  qsort (isa->state_lookup_table, isa->num_states,
	 sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);

  /* Set up the sysreg name lookup table.  */
  isa->sysreg_lookup_table =
    bfd_malloc (isa->num_sysregs * sizeof (xtensa_lookup_entry));
  CHECK_ALLOC_FOR_INIT (isa->sysreg_lookup_table, NULL, errno_p, error_msg_p);
  for (n = 0; n < isa->num_sysregs; n++)
    {
      isa->sysreg_lookup_table[n].key = isa->sysregs[n].name;
      isa->sysreg_lookup_table[n].u.sysreg = n;
    }
  qsort (isa->sysreg_lookup_table, isa->num_sysregs,
	 sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);

  /* Set up the user & system sysreg number tables.  */
  for (is_user = 0; is_user < 2; is_user++)
    {
      isa->sysreg_table[is_user] =
	bfd_malloc ((isa->max_sysreg_num[is_user] + 1)
		    * sizeof (xtensa_sysreg));
      CHECK_ALLOC_FOR_INIT (isa->sysreg_table[is_user], NULL,
			    errno_p, error_msg_p);

      for (n = 0; n <= isa->max_sysreg_num[is_user]; n++)
	isa->sysreg_table[is_user][n] = XTENSA_UNDEFINED;
    }
  for (n = 0; n < isa->num_sysregs; n++)
    {
      xtensa_sysreg_internal *sreg = &isa->sysregs[n];
      is_user = sreg->is_user;

      isa->sysreg_table[is_user][sreg->number] = n;
    }

  /* Set up the interface lookup table.  */
  isa->interface_lookup_table =
    bfd_malloc (isa->num_interfaces * sizeof (xtensa_lookup_entry));
  CHECK_ALLOC_FOR_INIT (isa->interface_lookup_table, NULL, errno_p,
			error_msg_p);
  for (n = 0; n < isa->num_interfaces; n++)
    {
      isa->interface_lookup_table[n].key = isa->interfaces[n].name;
      isa->interface_lookup_table[n].u.intf = n;
    }
  qsort (isa->interface_lookup_table, isa->num_interfaces,
	 sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);

  /* Set up the funcUnit lookup table.  */
  isa->funcUnit_lookup_table =
    bfd_malloc (isa->num_funcUnits * sizeof (xtensa_lookup_entry));
  CHECK_ALLOC_FOR_INIT (isa->funcUnit_lookup_table, NULL, errno_p,
			error_msg_p);
  for (n = 0; n < isa->num_funcUnits; n++)
    {
      isa->funcUnit_lookup_table[n].key = isa->funcUnits[n].name;
      isa->funcUnit_lookup_table[n].u.fun = n;
    }
  qsort (isa->funcUnit_lookup_table, isa->num_funcUnits,
	 sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);

  isa->insnbuf_size = ((isa->insn_size + sizeof (xtensa_insnbuf_word) - 1) /
		       sizeof (xtensa_insnbuf_word));

  return (xtensa_isa) isa;
}


void
xtensa_isa_free (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int n;

  /* With this version of the code, the xtensa_isa structure is not
     dynamically allocated, so this function is not essential.  Free
     the memory allocated by xtensa_isa_init and restore the xtensa_isa
     structure to its initial state.  */

  if (intisa->opname_lookup_table)
    {
      free (intisa->opname_lookup_table);
      intisa->opname_lookup_table = 0;
    }

  if (intisa->state_lookup_table)
    {
      free (intisa->state_lookup_table);
      intisa->state_lookup_table = 0;
    }

  if (intisa->sysreg_lookup_table)
    {
      free (intisa->sysreg_lookup_table);
      intisa->sysreg_lookup_table = 0;
    }
  for (n = 0; n < 2; n++)
    {
      if (intisa->sysreg_table[n])
	{
	  free (intisa->sysreg_table[n]);
	  intisa->sysreg_table[n] = 0;
	}
    }

  if (intisa->interface_lookup_table)
    {
      free (intisa->interface_lookup_table);
      intisa->interface_lookup_table = 0;
    }

  if (intisa->funcUnit_lookup_table)
    {
      free (intisa->funcUnit_lookup_table);
      intisa->funcUnit_lookup_table = 0;
    }
}


int
xtensa_isa_name_compare (const void *v1, const void *v2)
{
  xtensa_lookup_entry *e1 = (xtensa_lookup_entry *) v1;
  xtensa_lookup_entry *e2 = (xtensa_lookup_entry *) v2;

  return strcasecmp (e1->key, e2->key);
}


int
xtensa_isa_maxlength (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->insn_size;
}


int
xtensa_isa_length_from_chars (xtensa_isa isa, const unsigned char *cp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return (intisa->length_decode_fn) (cp);
}


int
xtensa_isa_num_pipe_stages (xtensa_isa isa)
{
  xtensa_opcode opcode;
  xtensa_funcUnit_use *use;
  int num_opcodes, num_uses;
  int i, stage;
  static int max_stage = XTENSA_UNDEFINED;

  /* Only compute the value once.  */
  if (max_stage != XTENSA_UNDEFINED)
    return max_stage + 1;

  num_opcodes = xtensa_isa_num_opcodes (isa);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      num_uses = xtensa_opcode_num_funcUnit_uses (isa, opcode);
      for (i = 0; i < num_uses; i++)
	{
	  use = xtensa_opcode_funcUnit_use (isa, opcode, i);
	  stage = use->stage;
	  if (stage > max_stage)
	    max_stage = stage;
	}
    }

  return max_stage + 1;
}


int
xtensa_isa_num_formats (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_formats;
}


int
xtensa_isa_num_opcodes (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_opcodes;
}


int
xtensa_isa_num_regfiles (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_regfiles;
}


int
xtensa_isa_num_states (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_states;
}


int
xtensa_isa_num_sysregs (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_sysregs;
}


int
xtensa_isa_num_interfaces (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_interfaces;
}


int
xtensa_isa_num_funcUnits (xtensa_isa isa)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  return intisa->num_funcUnits;
}



/* Instruction formats.  */


#define CHECK_FORMAT(INTISA,FMT,ERRVAL) \
  do { \
    if ((FMT) < 0 || (FMT) >= (INTISA)->num_formats) \
      { \
	xtisa_errno = xtensa_isa_bad_format; \
	strcpy (xtisa_error_msg, "invalid format specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


#define CHECK_SLOT(INTISA,FMT,SLOT,ERRVAL) \
  do { \
    if ((SLOT) < 0 || (SLOT) >= (INTISA)->formats[FMT].num_slots) \
      { \
	xtisa_errno = xtensa_isa_bad_slot; \
	strcpy (xtisa_error_msg, "invalid slot specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


const char *
xtensa_format_name (xtensa_isa isa, xtensa_format fmt)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FORMAT (intisa, fmt, NULL);
  return intisa->formats[fmt].name;
}


xtensa_format
xtensa_format_lookup (xtensa_isa isa, const char *fmtname)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int fmt;

  if (!fmtname || !*fmtname)
    {
      xtisa_errno = xtensa_isa_bad_format;
      strcpy (xtisa_error_msg, "invalid format name");
      return XTENSA_UNDEFINED;
    }

  for (fmt = 0; fmt < intisa->num_formats; fmt++)
    {
      if (strcasecmp (fmtname, intisa->formats[fmt].name) == 0)
	return fmt;
    }

  xtisa_errno = xtensa_isa_bad_format;
  sprintf (xtisa_error_msg, "format \"%s\" not recognized", fmtname);
  return XTENSA_UNDEFINED;
}


xtensa_format
xtensa_format_decode (xtensa_isa isa, const xtensa_insnbuf insn)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_format fmt;

  fmt = (intisa->format_decode_fn) (insn);
  if (fmt != XTENSA_UNDEFINED)
    return fmt;

  xtisa_errno = xtensa_isa_bad_format;
  strcpy (xtisa_error_msg, "cannot decode instruction format");
  return XTENSA_UNDEFINED;
}


int
xtensa_format_encode (xtensa_isa isa, xtensa_format fmt, xtensa_insnbuf insn)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FORMAT (intisa, fmt, -1);
  (*intisa->formats[fmt].encode_fn) (insn);
  return 0;
}


int
xtensa_format_length (xtensa_isa isa, xtensa_format fmt)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FORMAT (intisa, fmt, XTENSA_UNDEFINED);
  return intisa->formats[fmt].length;
}


int
xtensa_format_num_slots (xtensa_isa isa, xtensa_format fmt)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FORMAT (intisa, fmt, XTENSA_UNDEFINED);
  return intisa->formats[fmt].num_slots;
}


xtensa_opcode
xtensa_format_slot_nop_opcode (xtensa_isa isa, xtensa_format fmt, int slot)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int slot_id;

  CHECK_FORMAT (intisa, fmt, XTENSA_UNDEFINED);
  CHECK_SLOT (intisa, fmt, slot, XTENSA_UNDEFINED);

  slot_id = intisa->formats[fmt].slot_id[slot];
  return xtensa_opcode_lookup (isa, intisa->slots[slot_id].nop_name);
}


int
xtensa_format_get_slot (xtensa_isa isa, xtensa_format fmt, int slot,
			const xtensa_insnbuf insn, xtensa_insnbuf slotbuf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int slot_id;

  CHECK_FORMAT (intisa, fmt, -1);
  CHECK_SLOT (intisa, fmt, slot, -1);

  slot_id = intisa->formats[fmt].slot_id[slot];
  (*intisa->slots[slot_id].get_fn) (insn, slotbuf);
  return 0;
}


int
xtensa_format_set_slot (xtensa_isa isa, xtensa_format fmt, int slot,
			xtensa_insnbuf insn, const xtensa_insnbuf slotbuf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int slot_id;

  CHECK_FORMAT (intisa, fmt, -1);
  CHECK_SLOT (intisa, fmt, slot, -1);

  slot_id = intisa->formats[fmt].slot_id[slot];
  (*intisa->slots[slot_id].set_fn) (insn, slotbuf);
  return 0;
}



/* Opcode information.  */


#define CHECK_OPCODE(INTISA,OPC,ERRVAL) \
  do { \
    if ((OPC) < 0 || (OPC) >= (INTISA)->num_opcodes) \
      { \
	xtisa_errno = xtensa_isa_bad_opcode; \
	strcpy (xtisa_error_msg, "invalid opcode specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_opcode
xtensa_opcode_lookup (xtensa_isa isa, const char *opname)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_lookup_entry entry, *result = 0;

  if (!opname || !*opname)
    {
      xtisa_errno = xtensa_isa_bad_opcode;
      strcpy (xtisa_error_msg, "invalid opcode name");
      return XTENSA_UNDEFINED;
    }

  if (intisa->num_opcodes != 0)
    {
      entry.key = opname;
      result = bsearch (&entry, intisa->opname_lookup_table,
			intisa->num_opcodes, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }

  if (!result)
    {
      xtisa_errno = xtensa_isa_bad_opcode;
      sprintf (xtisa_error_msg, "opcode \"%s\" not recognized", opname);
      return XTENSA_UNDEFINED;
    }

  return result->u.opcode;
}


xtensa_opcode
xtensa_opcode_decode (xtensa_isa isa, xtensa_format fmt, int slot,
		      const xtensa_insnbuf slotbuf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int slot_id;
  xtensa_opcode opc;

  CHECK_FORMAT (intisa, fmt, XTENSA_UNDEFINED);
  CHECK_SLOT (intisa, fmt, slot, XTENSA_UNDEFINED);

  slot_id = intisa->formats[fmt].slot_id[slot];

  opc = (intisa->slots[slot_id].opcode_decode_fn) (slotbuf);
  if (opc != XTENSA_UNDEFINED)
    return opc;

  xtisa_errno = xtensa_isa_bad_opcode;
  strcpy (xtisa_error_msg, "cannot decode opcode");
  return XTENSA_UNDEFINED;
}


int
xtensa_opcode_encode (xtensa_isa isa, xtensa_format fmt, int slot,
		      xtensa_insnbuf slotbuf, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int slot_id;
  xtensa_opcode_encode_fn encode_fn;

  CHECK_FORMAT (intisa, fmt, -1);
  CHECK_SLOT (intisa, fmt, slot, -1);
  CHECK_OPCODE (intisa, opc, -1);

  slot_id = intisa->formats[fmt].slot_id[slot];
  encode_fn = intisa->opcodes[opc].encode_fns[slot_id];
  if (!encode_fn)
    {
      xtisa_errno = xtensa_isa_wrong_slot;
      sprintf (xtisa_error_msg,
	       "opcode \"%s\" is not allowed in slot %d of format \"%s\"",
	       intisa->opcodes[opc].name, slot, intisa->formats[fmt].name);
      return -1;
    }
  (*encode_fn) (slotbuf);
  return 0;
}


const char *
xtensa_opcode_name (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, NULL);
  return intisa->opcodes[opc].name;
}


int
xtensa_opcode_is_branch (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  if ((intisa->opcodes[opc].flags & XTENSA_OPCODE_IS_BRANCH) != 0)
    return 1;
  return 0;
}


int
xtensa_opcode_is_jump (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  if ((intisa->opcodes[opc].flags & XTENSA_OPCODE_IS_JUMP) != 0)
    return 1;
  return 0;
}


int
xtensa_opcode_is_loop (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  if ((intisa->opcodes[opc].flags & XTENSA_OPCODE_IS_LOOP) != 0)
    return 1;
  return 0;
}


int
xtensa_opcode_is_call (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  if ((intisa->opcodes[opc].flags & XTENSA_OPCODE_IS_CALL) != 0)
    return 1;
  return 0;
}


int
xtensa_opcode_num_operands (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  return intisa->iclasses[iclass_id].num_operands;
}


int
xtensa_opcode_num_stateOperands (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  return intisa->iclasses[iclass_id].num_stateOperands;
}


int
xtensa_opcode_num_interfaceOperands (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  return intisa->iclasses[iclass_id].num_interfaceOperands;
}


int
xtensa_opcode_num_funcUnit_uses (xtensa_isa isa, xtensa_opcode opc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  return intisa->opcodes[opc].num_funcUnit_uses;
}


xtensa_funcUnit_use *
xtensa_opcode_funcUnit_use (xtensa_isa isa, xtensa_opcode opc, int u)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_OPCODE (intisa, opc, NULL);
  if (u < 0 || u >= intisa->opcodes[opc].num_funcUnit_uses)
    {
      xtisa_errno = xtensa_isa_bad_funcUnit;
      sprintf (xtisa_error_msg, "invalid functional unit use number (%d); "
	       "opcode \"%s\" has %d", u, intisa->opcodes[opc].name,
	       intisa->opcodes[opc].num_funcUnit_uses);
      return NULL;
    }
  return &intisa->opcodes[opc].funcUnit_uses[u];
}



/* Operand information.  */


#define CHECK_OPERAND(INTISA,OPC,ICLASS,OPND,ERRVAL) \
  do { \
    if ((OPND) < 0 || (OPND) >= (ICLASS)->num_operands) \
      { \
	xtisa_errno = xtensa_isa_bad_operand; \
	sprintf (xtisa_error_msg, "invalid operand number (%d); " \
		 "opcode \"%s\" has %d operands", (OPND), \
		 (INTISA)->opcodes[(OPC)].name, (ICLASS)->num_operands); \
	return (ERRVAL); \
      } \
  } while (0)


static xtensa_operand_internal *
get_operand (xtensa_isa_internal *intisa, xtensa_opcode opc, int opnd)
{
  xtensa_iclass_internal *iclass;
  int iclass_id, operand_id;

  CHECK_OPCODE (intisa, opc, NULL);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_OPERAND (intisa, opc, iclass, opnd, NULL);
  operand_id = iclass->operands[opnd].u.operand_id;
  return &intisa->operands[operand_id];
}


const char *
xtensa_operand_name (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return NULL;
  return intop->name;
}


int
xtensa_operand_is_visible (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_iclass_internal *iclass;
  int iclass_id, operand_id;
  xtensa_operand_internal *intop;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_OPERAND (intisa, opc, iclass, opnd, XTENSA_UNDEFINED);

  /* Special case for "sout" operands.  */
  if (iclass->operands[opnd].inout == 's')
    return 0;

  operand_id = iclass->operands[opnd].u.operand_id;
  intop = &intisa->operands[operand_id];

  if ((intop->flags & XTENSA_OPERAND_IS_INVISIBLE) == 0)
    return 1;
  return 0;
}


char
xtensa_operand_inout (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_iclass_internal *iclass;
  int iclass_id;
  char inout;

  CHECK_OPCODE (intisa, opc, 0);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_OPERAND (intisa, opc, iclass, opnd, 0);
  inout = iclass->operands[opnd].inout;

  /* Special case for "sout" operands.  */
  if (inout == 's')
    return 'o';

  return inout;
}


int
xtensa_operand_get_field (xtensa_isa isa, xtensa_opcode opc, int opnd,
			  xtensa_format fmt, int slot,
			  const xtensa_insnbuf slotbuf, uint32 *valp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;
  int slot_id;
  xtensa_get_field_fn get_fn;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return -1;

  CHECK_FORMAT (intisa, fmt, -1);
  CHECK_SLOT (intisa, fmt, slot, -1);

  slot_id = intisa->formats[fmt].slot_id[slot];
  if (intop->field_id == XTENSA_UNDEFINED)
    {
      xtisa_errno = xtensa_isa_no_field;
      strcpy (xtisa_error_msg, "implicit operand has no field");
      return -1;
    }
  get_fn = intisa->slots[slot_id].get_field_fns[intop->field_id];
  if (!get_fn)
    {
      xtisa_errno = xtensa_isa_wrong_slot;
      sprintf (xtisa_error_msg,
	       "operand \"%s\" does not exist in slot %d of format \"%s\"",
	       intop->name, slot, intisa->formats[fmt].name);
      return -1;
    }
  *valp = (*get_fn) (slotbuf);
  return 0;
}


int
xtensa_operand_set_field (xtensa_isa isa, xtensa_opcode opc, int opnd,
			  xtensa_format fmt, int slot,
			  xtensa_insnbuf slotbuf, uint32 val)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;
  int slot_id;
  xtensa_set_field_fn set_fn;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return -1;

  CHECK_FORMAT (intisa, fmt, -1);
  CHECK_SLOT (intisa, fmt, slot, -1);

  slot_id = intisa->formats[fmt].slot_id[slot];
  if (intop->field_id == XTENSA_UNDEFINED)
    {
      xtisa_errno = xtensa_isa_no_field;
      strcpy (xtisa_error_msg, "implicit operand has no field");
      return -1;
    }
  set_fn = intisa->slots[slot_id].set_field_fns[intop->field_id];
  if (!set_fn)
    {
      xtisa_errno = xtensa_isa_wrong_slot;
      sprintf (xtisa_error_msg,
	       "operand \"%s\" does not exist in slot %d of format \"%s\"",
	       intop->name, slot, intisa->formats[fmt].name);
      return -1;
    }
  (*set_fn) (slotbuf, val);
  return 0;
}


int
xtensa_operand_encode (xtensa_isa isa, xtensa_opcode opc, int opnd,
		       uint32 *valp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;
  uint32 test_val, orig_val;

  intop = get_operand (intisa, opc, opnd);
  if (!intop)
    return -1;

  if (!intop->encode)
    {
      /* This is a default operand for a field.  How can we tell if the
	 value fits in the field?  Write the value into the field,
	 read it back, and then make sure we get the same value.  */
      static xtensa_insnbuf tmpbuf = 0;
      int slot_id;

      if (!tmpbuf)
	{
	  tmpbuf = xtensa_insnbuf_alloc (isa);
	  CHECK_ALLOC (tmpbuf, -1);
	}

      /* A default operand is always associated with a field,
	 but check just to be sure....  */
      if (intop->field_id == XTENSA_UNDEFINED)
	{
	  xtisa_errno = xtensa_isa_internal_error;
	  strcpy (xtisa_error_msg, "operand has no field");
	  return -1;
	}

      /* Find some slot that includes the field.  */
      for (slot_id = 0; slot_id < intisa->num_slots; slot_id++)
	{
	  xtensa_get_field_fn get_fn =
	    intisa->slots[slot_id].get_field_fns[intop->field_id];
	  xtensa_set_field_fn set_fn =
	    intisa->slots[slot_id].set_field_fns[intop->field_id];

	  if (get_fn && set_fn)
	    {
	      (*set_fn) (tmpbuf, *valp);
	      return ((*get_fn) (tmpbuf) != *valp);
	    }
	}

      /* Couldn't find any slot containing the field....  */
      xtisa_errno = xtensa_isa_no_field;
      strcpy (xtisa_error_msg, "field does not exist in any slot");
      return -1;
    }

  /* Encode the value.  In some cases, the encoding function may detect
     errors, but most of the time the only way to determine if the value
     was successfully encoded is to decode it and check if it matches
     the original value.  */
  orig_val = *valp;
  if ((*intop->encode) (valp)
      || (test_val = *valp, (*intop->decode) (&test_val))
      || test_val != orig_val)
    {
      xtisa_errno = xtensa_isa_bad_value;
      sprintf (xtisa_error_msg, "cannot encode operand value 0x%08x", *valp);
      return -1;
    }

  return 0;
}


int
xtensa_operand_decode (xtensa_isa isa, xtensa_opcode opc, int opnd,
		       uint32 *valp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return -1;

  /* Use identity function for "default" operands.  */
  if (!intop->decode)
    return 0;

  if ((*intop->decode) (valp))
    {
      xtisa_errno = xtensa_isa_bad_value;
      sprintf (xtisa_error_msg, "cannot decode operand value 0x%08x", *valp);
      return -1;
    }
  return 0;
}


int
xtensa_operand_is_register (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return XTENSA_UNDEFINED;

  if ((intop->flags & XTENSA_OPERAND_IS_REGISTER) != 0)
    return 1;
  return 0;
}


xtensa_regfile
xtensa_operand_regfile (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return XTENSA_UNDEFINED;

  return intop->regfile;
}


int
xtensa_operand_num_regs (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return XTENSA_UNDEFINED;

  return intop->num_regs;
}


int
xtensa_operand_is_known_reg (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return XTENSA_UNDEFINED;

  if ((intop->flags & XTENSA_OPERAND_IS_UNKNOWN) == 0)
    return 1;
  return 0;
}


int
xtensa_operand_is_PCrelative (xtensa_isa isa, xtensa_opcode opc, int opnd)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return XTENSA_UNDEFINED;

  if ((intop->flags & XTENSA_OPERAND_IS_PCRELATIVE) != 0)
    return 1;
  return 0;
}


int
xtensa_operand_do_reloc (xtensa_isa isa, xtensa_opcode opc, int opnd,
			 uint32 *valp, uint32 pc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return -1;

  if ((intop->flags & XTENSA_OPERAND_IS_PCRELATIVE) == 0)
    return 0;

  if (!intop->do_reloc)
    {
      xtisa_errno = xtensa_isa_internal_error;
      strcpy (xtisa_error_msg, "operand missing do_reloc function");
      return -1;
    }

  if ((*intop->do_reloc) (valp, pc))
    {
      xtisa_errno = xtensa_isa_bad_value;
      sprintf (xtisa_error_msg,
	       "do_reloc failed for value 0x%08x at PC 0x%08x", *valp, pc);
      return -1;
    }

  return 0;
}


int
xtensa_operand_undo_reloc (xtensa_isa isa, xtensa_opcode opc, int opnd,
			   uint32 *valp, uint32 pc)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_operand_internal *intop;

  intop = get_operand (intisa, opc, opnd);
  if (!intop) return -1;

  if ((intop->flags & XTENSA_OPERAND_IS_PCRELATIVE) == 0)
    return 0;

  if (!intop->undo_reloc)
    {
      xtisa_errno = xtensa_isa_internal_error;
      strcpy (xtisa_error_msg, "operand missing undo_reloc function");
      return -1;
    }

  if ((*intop->undo_reloc) (valp, pc))
    {
      xtisa_errno = xtensa_isa_bad_value;
      sprintf (xtisa_error_msg,
	       "undo_reloc failed for value 0x%08x at PC 0x%08x", *valp, pc);
      return -1;
    }

  return 0;
}



/* State Operands.  */


#define CHECK_STATE_OPERAND(INTISA,OPC,ICLASS,STOP,ERRVAL) \
  do { \
    if ((STOP) < 0 || (STOP) >= (ICLASS)->num_stateOperands) \
      { \
	xtisa_errno = xtensa_isa_bad_operand; \
	sprintf (xtisa_error_msg, "invalid state operand number (%d); " \
		 "opcode \"%s\" has %d state operands", (STOP), \
		 (INTISA)->opcodes[(OPC)].name, (ICLASS)->num_stateOperands); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_state
xtensa_stateOperand_state (xtensa_isa isa, xtensa_opcode opc, int stOp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_iclass_internal *iclass;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_STATE_OPERAND (intisa, opc, iclass, stOp, XTENSA_UNDEFINED);
  return iclass->stateOperands[stOp].u.state;
}


char
xtensa_stateOperand_inout (xtensa_isa isa, xtensa_opcode opc, int stOp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_iclass_internal *iclass;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, 0);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_STATE_OPERAND (intisa, opc, iclass, stOp, 0);
  return iclass->stateOperands[stOp].inout;
}



/* Interface Operands.  */


#define CHECK_INTERFACE_OPERAND(INTISA,OPC,ICLASS,IFOP,ERRVAL) \
  do { \
    if ((IFOP) < 0 || (IFOP) >= (ICLASS)->num_interfaceOperands) \
      { \
	xtisa_errno = xtensa_isa_bad_operand; \
	sprintf (xtisa_error_msg, "invalid interface operand number (%d); " \
		 "opcode \"%s\" has %d interface operands", (IFOP), \
		 (INTISA)->opcodes[(OPC)].name, \
		 (ICLASS)->num_interfaceOperands); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_interface
xtensa_interfaceOperand_interface (xtensa_isa isa, xtensa_opcode opc,
				   int ifOp)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_iclass_internal *iclass;
  int iclass_id;

  CHECK_OPCODE (intisa, opc, XTENSA_UNDEFINED);
  iclass_id = intisa->opcodes[opc].iclass_id;
  iclass = &intisa->iclasses[iclass_id];
  CHECK_INTERFACE_OPERAND (intisa, opc, iclass, ifOp, XTENSA_UNDEFINED);
  return iclass->interfaceOperands[ifOp];
}



/* Register Files.  */


#define CHECK_REGFILE(INTISA,RF,ERRVAL) \
  do { \
    if ((RF) < 0 || (RF) >= (INTISA)->num_regfiles) \
      { \
	xtisa_errno = xtensa_isa_bad_regfile; \
	strcpy (xtisa_error_msg, "invalid regfile specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_regfile
xtensa_regfile_lookup (xtensa_isa isa, const char *name)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int n;

  if (!name || !*name)
    {
      xtisa_errno = xtensa_isa_bad_regfile;
      strcpy (xtisa_error_msg, "invalid regfile name");
      return XTENSA_UNDEFINED;
    }

  /* The expected number of regfiles is small; use a linear search.  */
  for (n = 0; n < intisa->num_regfiles; n++)
    {
      if (!filename_cmp (intisa->regfiles[n].name, name))
	return n;
    }

  xtisa_errno = xtensa_isa_bad_regfile;
  sprintf (xtisa_error_msg, "regfile \"%s\" not recognized", name);
  return XTENSA_UNDEFINED;
}


xtensa_regfile
xtensa_regfile_lookup_shortname (xtensa_isa isa, const char *shortname)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  int n;

  if (!shortname || !*shortname)
    {
      xtisa_errno = xtensa_isa_bad_regfile;
      strcpy (xtisa_error_msg, "invalid regfile shortname");
      return XTENSA_UNDEFINED;
    }

  /* The expected number of regfiles is small; use a linear search.  */
  for (n = 0; n < intisa->num_regfiles; n++)
    {
      /* Ignore regfile views since they always have the same shortnames
	 as their parents.  */
      if (intisa->regfiles[n].parent != n)
	continue;
      if (!filename_cmp (intisa->regfiles[n].shortname, shortname))
	return n;
    }

  xtisa_errno = xtensa_isa_bad_regfile;
  sprintf (xtisa_error_msg, "regfile shortname \"%s\" not recognized",
	   shortname);
  return XTENSA_UNDEFINED;
}


const char *
xtensa_regfile_name (xtensa_isa isa, xtensa_regfile rf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_REGFILE (intisa, rf, NULL);
  return intisa->regfiles[rf].name;
}


const char *
xtensa_regfile_shortname (xtensa_isa isa, xtensa_regfile rf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_REGFILE (intisa, rf, NULL);
  return intisa->regfiles[rf].shortname;
}


xtensa_regfile
xtensa_regfile_view_parent (xtensa_isa isa, xtensa_regfile rf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_REGFILE (intisa, rf, XTENSA_UNDEFINED);
  return intisa->regfiles[rf].parent;
}


int
xtensa_regfile_num_bits (xtensa_isa isa, xtensa_regfile rf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_REGFILE (intisa, rf, XTENSA_UNDEFINED);
  return intisa->regfiles[rf].num_bits;
}


int
xtensa_regfile_num_entries (xtensa_isa isa, xtensa_regfile rf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_REGFILE (intisa, rf, XTENSA_UNDEFINED);
  return intisa->regfiles[rf].num_entries;
}



/* Processor States.  */


#define CHECK_STATE(INTISA,ST,ERRVAL) \
  do { \
    if ((ST) < 0 || (ST) >= (INTISA)->num_states) \
      { \
	xtisa_errno = xtensa_isa_bad_state; \
	strcpy (xtisa_error_msg, "invalid state specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_state
xtensa_state_lookup (xtensa_isa isa, const char *name)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_lookup_entry entry, *result = 0;

  if (!name || !*name)
    {
      xtisa_errno = xtensa_isa_bad_state;
      strcpy (xtisa_error_msg, "invalid state name");
      return XTENSA_UNDEFINED;
    }

  if (intisa->num_states != 0)
    {
      entry.key = name;
      result = bsearch (&entry, intisa->state_lookup_table, intisa->num_states,
			sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
    }

  if (!result)
    {
      xtisa_errno = xtensa_isa_bad_state;
      sprintf (xtisa_error_msg, "state \"%s\" not recognized", name);
      return XTENSA_UNDEFINED;
    }

  return result->u.state;
}


const char *
xtensa_state_name (xtensa_isa isa, xtensa_state st)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_STATE (intisa, st, NULL);
  return intisa->states[st].name;
}


int
xtensa_state_num_bits (xtensa_isa isa, xtensa_state st)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_STATE (intisa, st, XTENSA_UNDEFINED);
  return intisa->states[st].num_bits;
}


int
xtensa_state_is_exported (xtensa_isa isa, xtensa_state st)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_STATE (intisa, st, XTENSA_UNDEFINED);
  if ((intisa->states[st].flags & XTENSA_STATE_IS_EXPORTED) != 0)
    return 1;
  return 0;
}


int
xtensa_state_is_shared_or (xtensa_isa isa, xtensa_state st)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_STATE (intisa, st, XTENSA_UNDEFINED);
  if ((intisa->states[st].flags & XTENSA_STATE_IS_SHARED_OR) != 0)
    return 1;
  return 0;
}



/* Sysregs.  */


#define CHECK_SYSREG(INTISA,SYSREG,ERRVAL) \
  do { \
    if ((SYSREG) < 0 || (SYSREG) >= (INTISA)->num_sysregs) \
      { \
	xtisa_errno = xtensa_isa_bad_sysreg; \
	strcpy (xtisa_error_msg, "invalid sysreg specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_sysreg
xtensa_sysreg_lookup (xtensa_isa isa, int num, int is_user)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;

  if (is_user != 0)
    is_user = 1;

  if (num < 0 || num > intisa->max_sysreg_num[is_user]
      || intisa->sysreg_table[is_user][num] == XTENSA_UNDEFINED)
    {
      xtisa_errno = xtensa_isa_bad_sysreg;
      strcpy (xtisa_error_msg, "sysreg not recognized");
      return XTENSA_UNDEFINED;
    }

  return intisa->sysreg_table[is_user][num];
}


xtensa_sysreg
xtensa_sysreg_lookup_name (xtensa_isa isa, const char *name)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_lookup_entry entry, *result = 0;

  if (!name || !*name)
    {
      xtisa_errno = xtensa_isa_bad_sysreg;
      strcpy (xtisa_error_msg, "invalid sysreg name");
      return XTENSA_UNDEFINED;
    }

  if (intisa->num_sysregs != 0)
    {
      entry.key = name;
      result = bsearch (&entry, intisa->sysreg_lookup_table,
			intisa->num_sysregs, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }

  if (!result)
    {
      xtisa_errno = xtensa_isa_bad_sysreg;
      sprintf (xtisa_error_msg, "sysreg \"%s\" not recognized", name);
      return XTENSA_UNDEFINED;
    }

  return result->u.sysreg;
}


const char *
xtensa_sysreg_name (xtensa_isa isa, xtensa_sysreg sysreg)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_SYSREG (intisa, sysreg, NULL);
  return intisa->sysregs[sysreg].name;
}


int
xtensa_sysreg_number (xtensa_isa isa, xtensa_sysreg sysreg)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_SYSREG (intisa, sysreg, XTENSA_UNDEFINED);
  return intisa->sysregs[sysreg].number;
}


int
xtensa_sysreg_is_user (xtensa_isa isa, xtensa_sysreg sysreg)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_SYSREG (intisa, sysreg, XTENSA_UNDEFINED);
  if (intisa->sysregs[sysreg].is_user)
    return 1;
  return 0;
}



/* Interfaces.  */


#define CHECK_INTERFACE(INTISA,INTF,ERRVAL) \
  do { \
    if ((INTF) < 0 || (INTF) >= (INTISA)->num_interfaces) \
      { \
	xtisa_errno = xtensa_isa_bad_interface; \
	strcpy (xtisa_error_msg, "invalid interface specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_interface
xtensa_interface_lookup (xtensa_isa isa, const char *ifname)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_lookup_entry entry, *result = 0;

  if (!ifname || !*ifname)
    {
      xtisa_errno = xtensa_isa_bad_interface;
      strcpy (xtisa_error_msg, "invalid interface name");
      return XTENSA_UNDEFINED;
    }

  if (intisa->num_interfaces != 0)
    {
      entry.key = ifname;
      result = bsearch (&entry, intisa->interface_lookup_table,
			intisa->num_interfaces, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }

  if (!result)
    {
      xtisa_errno = xtensa_isa_bad_interface;
      sprintf (xtisa_error_msg, "interface \"%s\" not recognized", ifname);
      return XTENSA_UNDEFINED;
    }

  return result->u.intf;
}


const char *
xtensa_interface_name (xtensa_isa isa, xtensa_interface intf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_INTERFACE (intisa, intf, NULL);
  return intisa->interfaces[intf].name;
}


int
xtensa_interface_num_bits (xtensa_isa isa, xtensa_interface intf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_INTERFACE (intisa, intf, XTENSA_UNDEFINED);
  return intisa->interfaces[intf].num_bits;
}


char
xtensa_interface_inout (xtensa_isa isa, xtensa_interface intf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_INTERFACE (intisa, intf, 0);
  return intisa->interfaces[intf].inout;
}


int
xtensa_interface_has_side_effect (xtensa_isa isa, xtensa_interface intf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_INTERFACE (intisa, intf, XTENSA_UNDEFINED);
  if ((intisa->interfaces[intf].flags & XTENSA_INTERFACE_HAS_SIDE_EFFECT) != 0)
    return 1;
  return 0;
}


int
xtensa_interface_class_id (xtensa_isa isa, xtensa_interface intf)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_INTERFACE (intisa, intf, XTENSA_UNDEFINED);
  return intisa->interfaces[intf].class_id;
}



/* Functional Units.  */


#define CHECK_FUNCUNIT(INTISA,FUN,ERRVAL) \
  do { \
    if ((FUN) < 0 || (FUN) >= (INTISA)->num_funcUnits) \
      { \
	xtisa_errno = xtensa_isa_bad_funcUnit; \
	strcpy (xtisa_error_msg, "invalid functional unit specifier"); \
	return (ERRVAL); \
      } \
  } while (0)


xtensa_funcUnit
xtensa_funcUnit_lookup (xtensa_isa isa, const char *fname)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  xtensa_lookup_entry entry, *result = 0;

  if (!fname || !*fname)
    {
      xtisa_errno = xtensa_isa_bad_funcUnit;
      strcpy (xtisa_error_msg, "invalid functional unit name");
      return XTENSA_UNDEFINED;
    }

  if (intisa->num_funcUnits != 0)
    {
      entry.key = fname;
      result = bsearch (&entry, intisa->funcUnit_lookup_table,
			intisa->num_funcUnits, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }

  if (!result)
    {
      xtisa_errno = xtensa_isa_bad_funcUnit;
      sprintf (xtisa_error_msg,
	       "functional unit \"%s\" not recognized", fname);
      return XTENSA_UNDEFINED;
    }

  return result->u.fun;
}


const char *
xtensa_funcUnit_name (xtensa_isa isa, xtensa_funcUnit fun)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FUNCUNIT (intisa, fun, NULL);
  return intisa->funcUnits[fun].name;
}


int
xtensa_funcUnit_num_copies (xtensa_isa isa, xtensa_funcUnit fun)
{
  xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
  CHECK_FUNCUNIT (intisa, fun, XTENSA_UNDEFINED);
  return intisa->funcUnits[fun].num_copies;
}

@


1.14
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@d183 1
a183 1
    
d299 1
a299 1
  isa->interface_lookup_table = 
d312 1
a312 1
  isa->funcUnit_lookup_table = 
d409 1
a409 1
xtensa_isa_num_pipe_stages (xtensa_isa isa) 
d547 1
a547 1
  
@


1.13
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1367 1
a1367 1
      if (!strcmp (intisa->regfiles[n].name, name))
d1397 1
a1397 1
      if (!strcmp (intisa->regfiles[n].shortname, shortname))
@


1.12
log
@2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * xtensa-isa.c (xtensa_state_is_shared_or): New function.

2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * xtensa-isa-internal.h (XTENSA_STATE_IS_SHARED_OR): New flag.
        * xtensa-isa.h (xtensa_state_is_shared_or): New prototype.

2008-11-21  Sterling Augustine  <sterling@@tensilica.com>

        * config/tc-xtensa.c (check_t1_t2_reads_and_writes): Call
        xtensa_state_is_shared_or to allow multiple opcodes within a
        single FLIX bundle to write to these special states.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
d1031 2
a1032 1
  if (!intop) return -1;
a1038 2

      xtensa_isa_internal *intisa = (xtensa_isa_internal *) isa;
d1083 3
a1085 3
  if ((*intop->encode) (valp) ||
      (test_val = *valp, (*intop->decode) (&test_val)) ||
      test_val != orig_val)
@


1.11
log
@bfd/
	* xtensa-isa.c (xtensa_isa_num_pipe_stages): Make max_stage static and
	only compute its value once.
gas/
	* config/tc-xtensa.c (xtensa_num_pipe_stages): New.
	(md_begin): Initialize it.
	(resources_conflict): Use it.
@
text
@d1529 11
@


1.10
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d414 6
a419 1
  int i, stage, max_stage = XTENSA_UNDEFINED;
@


1.9
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.8
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d20 1
a21 1
#include "sysdep.h"
@


1.7
log
@Update the FSF address in the copyright/GPL notice
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.6
log
@include ChangeLog
	* xtensa-isa.h: Update a comment and whitespace.
bfd ChangeLog
	* xtensa-isa.c (xtensa_opcode_lookup, xtensa_state_lookup,
	xtensa_sysreg_lookup_name, xtensa_interface_lookup,
	xtensa_funcUnit_lookup): Skip bsearch call if count is zero.
	(xtensa_opcode_decode): Rearrange code.
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.5
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d66 1
a409 1
  int num_opcodes, num_uses;
d412 1
d657 1
a657 1
  xtensa_lookup_entry entry, *result;
d666 7
a672 3
  entry.key = opname;
  result = bsearch (&entry, intisa->opname_lookup_table, intisa->num_opcodes,
		    sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
d699 6
a704 6
  if (opc == XTENSA_UNDEFINED)
    {
      xtisa_errno = xtensa_isa_bad_opcode;
      strcpy (xtisa_error_msg, "cannot decode opcode");
    }
  return opc;
d1296 1
d1447 1
d1467 1
a1467 1
  xtensa_lookup_entry entry, *result;
d1476 6
a1481 3
  entry.key = name;
  result = bsearch (&entry, intisa->state_lookup_table, intisa->num_states,
		    sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
d1522 1
d1562 1
a1562 1
  xtensa_lookup_entry entry, *result;
d1571 7
a1577 3
  entry.key = name;
  result = bsearch (&entry, intisa->sysreg_lookup_table, intisa->num_sysregs,
		    sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
d1618 1
d1638 1
a1638 1
  xtensa_lookup_entry entry, *result;
d1647 7
a1653 4
  entry.key = ifname;
  result = bsearch (&entry, intisa->interface_lookup_table,
		    intisa->num_interfaces,
		    sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
d1712 1
d1732 1
a1732 1
  xtensa_lookup_entry entry, *result;
d1741 7
a1747 4
  entry.key = fname;
  result = bsearch (&entry, intisa->funcUnit_lookup_table,
		    intisa->num_funcUnits,
		    sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
@


1.5.2.1
log
@include:
	* xtensa-isa.h: Update a comment and whitespace.
bfd:
	* xtensa-isa.c (xtensa_opcode_lookup, xtensa_state_lookup,
	xtensa_sysreg_lookup_name, xtensa_interface_lookup,
	xtensa_funcUnit_lookup): Skip bsearch call if count is zero.
	(xtensa_opcode_decode): Rearrange code.
@
text
@a65 1

d409 1
a411 1
  int num_opcodes, num_uses;
d656 1
a656 1
  xtensa_lookup_entry entry, *result = 0;
d665 3
a667 7
  if (intisa->num_opcodes != 0)
    {
      entry.key = opname;
      result = bsearch (&entry, intisa->opname_lookup_table,
			intisa->num_opcodes, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }
d694 6
a699 6
  if (opc != XTENSA_UNDEFINED)
    return opc;

  xtisa_errno = xtensa_isa_bad_opcode;
  strcpy (xtisa_error_msg, "cannot decode opcode");
  return XTENSA_UNDEFINED;
a1290 1

a1440 1

d1460 1
a1460 1
  xtensa_lookup_entry entry, *result = 0;
d1469 3
a1471 6
  if (intisa->num_states != 0)
    {
      entry.key = name;
      result = bsearch (&entry, intisa->state_lookup_table, intisa->num_states,
			sizeof (xtensa_lookup_entry), xtensa_isa_name_compare);
    }
a1511 1

d1551 1
a1551 1
  xtensa_lookup_entry entry, *result = 0;
d1560 3
a1562 7
  if (intisa->num_sysregs != 0)
    {
      entry.key = name;
      result = bsearch (&entry, intisa->sysreg_lookup_table,
			intisa->num_sysregs, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }
a1602 1

d1622 1
a1622 1
  xtensa_lookup_entry entry, *result = 0;
d1631 4
a1634 7
  if (intisa->num_interfaces != 0)
    {
      entry.key = ifname;
      result = bsearch (&entry, intisa->interface_lookup_table,
			intisa->num_interfaces, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }
a1692 1

d1712 1
a1712 1
  xtensa_lookup_entry entry, *result = 0;
d1721 4
a1724 7
  if (intisa->num_funcUnits != 0)
    {
      entry.key = fname;
      result = bsearch (&entry, intisa->funcUnit_lookup_table,
			intisa->num_funcUnits, sizeof (xtensa_lookup_entry),
			xtensa_isa_name_compare);
    }
@


1.4
log
@2004-11-12  Bob Wilson  <bob.wilson@@acm.org>

include/ChangeLog
	* xtensa-isa-internal.h (xtensa_interface_internal): Add class_id.
	* xtensa-isa.h (xtensa_interface_class_id): New prototype.

bfd/ChangeLog
	* xtensa-isa.c (xtensa_interface_class_id): New.

gas/ChangeLog
	* config/tc-xtensa.c (finish_vinsn): Clear pending instruction if
	there is a conflict.
	(check_t1_t2_reads_and_writes): Check for both reads and writes to
	interfaces that are related as determined by xtensa_interface_class_id.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d123 3
a125 1
xtensa_insnbuf_to_chars (xtensa_isa isa, const xtensa_insnbuf insn, char *cp,
d183 3
a185 1
xtensa_insnbuf_from_chars (xtensa_isa isa, xtensa_insnbuf insn, const char *cp,
d399 1
a399 1
xtensa_isa_length_from_chars (xtensa_isa isa, const char *cp)
@


1.3
log
@bfd ChangeLog

	* elf32-xtensa.c (elf32xtensa_size_opt): New global variable.
	(xtensa_default_isa): Global variable moved here from xtensa-isa.c.
	(elf32xtensa_no_literal_movement): New global variable.
	(elf_howto_table): Add entries for new relocations.
	(elf_xtensa_reloc_type_lookup): Handle new relocations.
	(property_table_compare): When addresses are equal, compare sizes and
	various property flags.
	(property_table_matches): New.
	(xtensa_read_table_entries): Extend to read new property tables.  Add
	output_addr parameter to indicate that output addresses should be used.
	Use bfd_get_section_limit.
	(elf_xtensa_find_property_entry): New.
	(elf_xtensa_in_literal_pool): Use elf_xtensa_find_property_entry.
	(elf_xtensa_check_relocs): Handle new relocations.
	(elf_xtensa_do_reloc): Use bfd_get_section_limit.  Handle new
	relocations.  Use new xtensa-isa.h functions.
	(build_encoding_error_message): Remove encode_result parameter.  Add
	new target_address parameter used to detect alignment errors.
	(elf_xtensa_relocate_section): Use bfd_get_section_limit.  Clean up
	error handling.  Use new is_operand_relocation function.
	(elf_xtensa_combine_prop_entries, elf_xtensa_merge_private_bfd_data):
	Use underbar macro for error messages.  Formatting.
	(get_const16_opcode): New.
	(get_l32r_opcode): Add a separate flag for initialization.
	(get_relocation_opnd): Operand number is no longer explicit in the
	relocation.  Change to decode the opcode and analyze its operands.
	(get_relocation_slot): New.
	(get_relocation_opcode): Add bfd parameter.  Use bfd_get_section_limit.
	Use new xtensa-isa.h functions to handle multislot instructions.
	(is_l32r_relocation): Add bfd parameter.  Use is_operand_relocation.
	(get_asm_simplify_size, is_alt_relocation, is_operand_relocation,
	insn_decode_len, insn_decode_opcode, check_branch_target_aligned,
	check_loop_aligned, check_branch_target_aligned_address, narrowable,
	widenable, narrow_instruction, widen_instruction, op_single_fmt_table,
	get_single_format, init_op_single_format_table): New.
	(elf_xtensa_do_asm_simplify): Add error_message parameter and use it
	instead of calling _bfd_error_handler.  Use new xtensa-isa.h functions.
	(contract_asm_expansion): Add error_message parameter and pass it to
	elf_xtensa_do_asm_simplify.  Replace use of R_XTENSA_OP0 relocation
	with R_XTENSA_SLOT0_OP.
	(get_expanded_call_opcode): Extend to handle either L32R or CONST16
	instructions.  Use new xtensa-isa.h functions.
	(r_reloc struct): Add new virtual_offset field.
	(r_reloc_init): Add contents and content_length parameters.  Set
	virtual_offset field to zero.  Add contents to target_offset field for
	partial_inplace relocations.
	(r_reloc_is_defined): Check for null.
	(print_r_reloc): New debug function.
	(source_reloc struct): Replace xtensa_operand field with pair of the
	opcode and the operand position.  Add is_abs_literal field.
	(init_source_reloc): Specify operand by opcode/position pair.  Set
	is_abs_literal field.
	(source_reloc_compare): When target_offsets are equal, compare other
	fields to make sorting predictable.
	(literal_value struct): Add is_abs_literal field.
	(value_map_hash_table struct): Add has_last_loc and last_loc fields.
	(init_literal_value): New.
	(is_same_value): Replace with ...
	(literal_value_equal): ... this function.  Add comparisons of
	virtual_offset and is_abs_literal fields.
	(value_map_hash_table_init): Use bfd_zmalloc.  Check for allocation
	failure.  Initialize has_last_loc field.
	(value_map_hash_table_delete): New.
	(hash_literal_value): Rename to ...
	(literal_value_hash): ... this.  Include is_abs_literal flag and
	virtual_offset field in the hash value.
	(get_cached_value): Rename to ...
	(value_map_get_cached_value): ... this.  Update calls to
	literal_value_hash and literal_value_equal.
	(add_value_map): Check for allocation failure.  Update calls to
	value_map_get_cached_value and literal_value_hash.
	(text_action, text_action_list, text_action_t): New types.
	(find_fill_action, compute_removed_action_diff, adjust_fill_action,
	text_action_add, text_action_add_literal, offset_with_removed_text,
	offset_with_removed_text_before_fill, find_insn_action,
	print_action_list, print_removed_literals): New.
	(offset_with_removed_literals): Delete.
	(xtensa_relax_info struct): Add is_relaxable_asm_section, action_list,
	fix_array, fix_array_count, allocated_relocs, relocs_count, and
	allocated_relocs_count fields.
	(init_xtensa_relax_info): Initialize new fields.
	(reloc_bfd_fix struct): Add new translated field.
	(reloc_bfd_fix_init): Add translated parameter and use it to set the
	translated field.
	(fix_compare, cache_fix_array): New.
	(get_bfd_fix): Remove fix_list parameter and get all relax_info for the
	section via get_xtensa_relax_info.  Use cache_fix_array to set up
	sorted fix_array and use bsearch instead of linear search.
	(section_cache_t): New struct.
	(init_section_cache, section_cache_section, clear_section_cache): New.
	(ebb_t, ebb_target_enum, proposed_action, ebb_constraint): New types.
	(init_ebb_constraint, free_ebb_constraint, init_ebb, extend_ebb_bounds,
	extend_ebb_bounds_forward, extend_ebb_bounds_backward,
	insn_block_decodable_len, ebb_propose_action, ebb_add_proposed_action):
	New.
	(retrieve_contents): Use bfd_get_section_limit.
	(elf_xtensa_relax_section): Add relocations_analyzed flag.  Update call
	to compute_removed_literals.  Free value_map_hash_table when no longer
	needed.
	(analyze_relocations): Check is_relaxable_asm_section flag.  Call
	compute_text_actions for all sections.
	(find_relaxable_sections): Mark sections as relaxable if they contain
	ASM_EXPAND relocations that can be optimized.  Adjust r_reloc_init
	call.  Increment relax_info src_count field only for appropriate
	relocation types.  Remove is_literal_section check.
	(collect_source_relocs): Use bfd_get_section_limit.  Adjust calls to
	r_reloc_init and find_associated_l32r_irel.  Check
	is_relaxable_asm_section flag.  Handle L32R instructions with absolute
	literals.  Pass is_abs_literal flag to init_source_reloc.
	(is_resolvable_asm_expansion): Use bfd_get_section_limit.  Check for
	CONST16 instructions.  Adjust calls to r_reloc_init and
	pcrel_reloc_fits.  Handle weak symbols conservatively.
	(find_associated_l32r_irel): Add bfd parameter and pass it to
	is_l32r_relocation.
	(compute_text_actions, compute_ebb_proposed_actions,
	compute_ebb_actions, check_section_ebb_pcrels_fit,
	check_section_ebb_reduces, text_action_add_proposed,
	compute_fill_extra_space): New.
	(remove_literals): Replace with ...
	(compute_removed_literals): ... this function.  Call
	init_section_cache.  Use bfd_get_section_limit.  Sort internal_relocs.
	Call xtensa_read_table_entries to get the property table.  Skip
	relocations other than R_XTENSA_32 and R_XTENSA_PLT.  Use new
	is_removable_literal, remove_dead_literal, and
	identify_literal_placement functions.
	(get_irel_at_offset): Rewrite to use bsearch on sorted relocations
	instead of linear search.
	(is_removable_literal, remove_dead_literal,
	identify_literal_placement): New.
	(relocations_reach): Update check for literal not referenced by any
	PC-relative relocations.  Adjust call to pcrel_reloc_fits.
	(coalesce_shared_literal, move_shared_literal): New.
	(relax_section): Use bfd_get_section_limit.  Call
	translate_section_fixes.  Update calls to r_reloc_init and
	offset_with_removed_text.  Check new is_relaxable_asm_section flag.
	Add call to pin_internal_relocs.  Add special handling for
	R_XTENSA_ASM_SIMPLIFY and R_XTENSA_DIFF* relocs.  Use virtual_offset
	info to calculate new addend_displacement variable.  Replace code for
	deleting literals with more general code to perform the actions
	determined by the action_list for the section.
	(translate_section_fixes, translate_reloc_bfd_fix): New.
	(translate_reloc): Check new is_relaxable_asm_section flag.  Call
	find_removed_literal only if is_operand_relocation.  Update call to
	offset_with_removed_text.  Use new target_offset and removed_bytes
	variables.
	(move_literal): New.
	(relax_property_section):  Use bfd_get_section_limit.  Set new
	is_full_prop_section flag and handle new property tables.  Update calls
	to r_reloc_init and offset_with_removed_text.  Check
	is_relaxable_asm_section flag.  Handle expansion of zero-sized
	unreachable entries, with use of offset_with_removed_text_before_fill.
	For relocatable links, combine entries only for literal tables.
	(relax_section_symbols): Check is_relaxable_asm_section flag.  Update
	calls to offset_with_removed_text.  Translate st_size field for
	function symbols.
	(do_fix_for_relocatable_link): Change to return bfd_boolean to indicate
	failure.  Add contents parameter.  Update call to get_bfd_fix.  Update
	call to r_reloc_init.  Call _bfd_error_handler and return FALSE for
	R_XTENSA_ASM_EXPAND relocs.
	(do_fix_for_final_link): Add input_bfd and contents parameters.  Update
	call to get_bfd_fix.  Include offset from contents for partial_inplace
	relocations.
	(is_reloc_sym_weak): New.
	(pcrel_reloc_fits): Use new xtensa-isa.h functions.
	(prop_sec_len): New.
	(xtensa_is_property_section): Handle new property sections.
	(is_literal_section): Delete.
	(internal_reloc_compare): When r_offset matches, compare r_info and
	r_addend to make sorting predictable.
	(internal_reloc_matches): New.
	(xtensa_get_property_section_name): Handle new property sections.
	(xtensa_get_property_predef_flags): New.
	(xtensa_callback_required_dependence): Use bfd_get_section_limit.
	Update calls to xtensa_isa_init, is_l32r_relocation, and r_reloc_init.
	* xtensa-isa.c (xtensa_default_isa): Moved to elf32-xtensa.c.
	(xtisa_errno, xtisa_error_msg): New variables.
	(xtensa_isa_errno, xtensa_isa_error_msg): New.
	(xtensa_insnbuf_alloc): Add error handling.
	(xtensa_insnbuf_to_chars): Add num_chars parameter.  Update to
	use xtensa_format_decode.  Add error handling.
	(xtensa_insnbuf_from_chars): Add num_chars parameter.  Decode the
	instruction length to find the number of bytes to copy.
	(xtensa_isa_init): Add error handling.  Replace calls to
	xtensa_load_isa and xtensa_extend_isa with code to initialize lookup
	tables in the xtensa_modules structure.
	(xtensa_check_isa_config, xtensa_add_isa, xtensa_load_isa,
	xtensa_extend_isa): Delete.
	(xtensa_isa_free): Change to only free lookup tables.
	(opname_lookup_compare): Replace with ...
	(xtensa_isa_name_compare): ... this function.  Use strcasecmp.
	(xtensa_insn_maxlength): Rename to ...
	(xtensa_isa_maxlength): ... this.
	(xtensa_insn_length): Delete.
	(xtensa_insn_length_from_first_byte): Replace with ...
	(xtensa_isa_length_from_chars): ... this function.
	(xtensa_num_opcodes): Rename to ...
	(xtensa_isa_num_opcodes): ... this.
	(xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_regfiles, xtensa_isa_num_stages,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot): New functions.
	(xtensa_opcode_lookup): Add error handling.
	(xtensa_decode_insn): Replace with ...
	(xtensa_opcode_decode): ... this function, with new format and
	slot parameters.  Add error handling.
	(xtensa_encode_insn): Replace with ...
	(xtensa_opcode_encode): ... this function, which does the encoding via
	one of the entries in the "encode_fns" array.  Add error handling.
	(xtensa_opcode_name): Add error handling.
	(xtensa_opcode_is_branch, xtensa_opcode_is_jump, xtensa_opcode_is_loop,
	xtensa_opcode_is_call): New.
	(xtensa_num_operands): Replace with ...
	(xtensa_opcode_num_operands): ... this function.  Add error handling.
	(xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible): New.
	(xtensa_get_operand, xtensa_operand_kind): Delete.
	(xtensa_operand_inout): Add error handling and special-case for
	"sout" operands.
	(xtensa_operand_get_field, xtensa_operand_set_field): Rewritten to
	operate on one slot of an instruction.  Added error handling.
	(xtensa_operand_encode): Handle default operands with no encoding
	functions.  Check for success by comparing against decoded value.
	Add error handling.
	(xtensa_operand_decode): Handle default operands.  Return decoded value
	through argument pointer.  Add error handling.
	(xtensa_operand_is_register, xtensa_operand_regfile,
	xtensa_operand_num_regs, xtensa_operand_is_known_reg): New.
	(xtensa_operand_isPCRelative): Rename to ...
	(xtensa_operand_is_PCrelative): ... this.  Add error handling.
	(xtensa_operand_do_reloc, xtensa_operand_undo_reloc): Return value
	through argument pointer.  Add error handling.
	(xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New.
	* xtensa-modules.c: Rewrite to use new data structures.
	* reloc.c (BFD_RELOC_XTENSA_DIFF8, BFD_RELOC_XTENSA_DIFF16,
	BFD_RELOC_XTENSA_DIFF32, BFD_RELOC_XTENSA_SLOT0_OP,
	BFD_RELOC_XTENSA_SLOT1_OP, BFD_RELOC_XTENSA_SLOT2_OP,
	BFD_RELOC_XTENSA_SLOT3_OP, BFD_RELOC_XTENSA_SLOT4_OP,
	BFD_RELOC_XTENSA_SLOT5_OP, BFD_RELOC_XTENSA_SLOT6_OP,
	BFD_RELOC_XTENSA_SLOT7_OP, BFD_RELOC_XTENSA_SLOT8_OP,
	BFD_RELOC_XTENSA_SLOT9_OP, BFD_RELOC_XTENSA_SLOT10_OP,
	BFD_RELOC_XTENSA_SLOT11_OP, BFD_RELOC_XTENSA_SLOT12_OP,
	BFD_RELOC_XTENSA_SLOT13_OP, BFD_RELOC_XTENSA_SLOT14_OP,
	BFD_RELOC_XTENSA_SLOT0_ALT, BFD_RELOC_XTENSA_SLOT1_ALT,
	BFD_RELOC_XTENSA_SLOT2_ALT, BFD_RELOC_XTENSA_SLOT3_ALT,
	BFD_RELOC_XTENSA_SLOT4_ALT, BFD_RELOC_XTENSA_SLOT5_ALT,
	BFD_RELOC_XTENSA_SLOT6_ALT, BFD_RELOC_XTENSA_SLOT7_ALT,
	BFD_RELOC_XTENSA_SLOT8_ALT, BFD_RELOC_XTENSA_SLOT9_ALT,
	BFD_RELOC_XTENSA_SLOT10_ALT, BFD_RELOC_XTENSA_SLOT11_ALT,
	BFD_RELOC_XTENSA_SLOT12_ALT, BFD_RELOC_XTENSA_SLOT13_ALT,
	BFD_RELOC_XTENSA_SLOT14_ALT): Add new relocations.
	* Makefile.am (xtensa-isa.lo, xtensa-modules.lo): Update dependencies.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Likewise.
	* libbfd.h: Likewise.

gas ChangeLog

	* config/tc-xtensa.c (absolute_literals_supported): New global flag.
	(UNREACHABLE_MAX_WIDTH): Define.
	(XTENSA_FETCH_WIDTH): Delete.
	(cur_vinsn, xtensa_fetch_width, xt_saved_debug_type, past_xtensa_end,
	prefer_const16, prefer_l32r): New global variables.
	(LIT4_SECTION_NAME): Define.
	(lit4_state struct): Add lit4_seg_name and lit4_seg fields.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.
	(frag_flags struct): New.
	(xtensa_block_info struct): Move from tc-xtensa.h.  Add flags field.
	(subseg_map struct): Add cur_total_freq and cur_target_freq fields.
	(bitfield, bit_is_set, set_bit, clear_bit): Define.
	(MAX_FORMATS): Define.
	(op_placement_info struct, op_placement_table): New.
	(O_pltrel, O_hi16, O_lo16): Define.
	(directiveE enum): Rename directive_generics to directive_transform.
	Delete directive_relax.  Add directive_schedule,
	directive_absolute_literals, and directive_last_directive.
	(directive_info): Rename "generics" to "transform".  Delete "relax".
	Add "schedule" and "absolute-literals".
	(directive_state): Adjust entries to match changes in directive_info.
	(xtensa_relax_statesE, RELAX_IMMED_MAXSTEPS): Move to tc-xtensa.h.
	(xtensa_const16_opcode, xtensa_movi_opcode, xtensa_movi_n_opcode,
	xtensa_l32r_opcode, xtensa_nop_opcode, xtensa_rsr_lcount_opcode): New.
	(xtensa_j_opcode, xtensa_rsr_opcode): Delete.
	(align_only_targets, software_a0_b_retw_interlock,
	software_avoid_b_j_loop_end, maybe_has_b_j_loop_end,
	software_avoid_short_loop, software_avoid_close_loop_end,
	software_avoid_all_short_loops, specific_opcode): Delete.
	(warn_unaligned_branch_targets): New.
	(workaround_a0_b_retw, workaround_b_j_loop_end, workaround_short_loop,
	workaround_close_loop_end, workaround_all_short_loops): Default FALSE.
	(option_[no_]link_relax, option_[no_]transform,
	option_[no_]absolute_literals, option_warn_unaligned_targets,
	option_prefer_l32r, option_prefer_const16, option_target_hardware):
	New enum values.
	(option_[no_]align_only_targets, option_literal_section_name,
	option_text_section_name, option_data_section_name,
	option_bss_section_name, option_eb, option_el): Delete.
	(md_longopts): Add entries for: [no-]transform, [no-]absolute-literals,
	warn-unaligned-targets, prefer-l32r, prefer-const16, [no-]link-relax,
	and target-hardware.  Delete entries for [no-]target-align-only,
	literal-section-name, text-section-name, data-section-name, and
	bss-section-name.
	(md_parse_option): Handle new options and remove old ones.  Accept but
	ignore [no-]density options.  Warn for [no-]generics and [no-]relax
	and treat them as [no-]transform.
	(md_show_usage): Add new options and remove old ones.
	(xtensa_setup_hw_workarounds): New.
	(md_pseudo_table): Change "word" entry to use xtensa_elf_cons.  Add
	"long", "short", "loc" and "frequency" entries.
	(use_generics): Rename to ...
	(use_transform): ... this function.  Add past_xtensa_end check.
	(use_longcalls): Add past_xtensa_end check.
	(code_density_available, can_relax): Delete.
	(do_align_targets): New.
	(get_directive): Accept dashes in directive names.  Warn about
	[no-]generics and [no-]relax directives and treat them as
	[no-]transform.
	(xtensa_begin_directive): Call md_flush_pending_output only for some
	directives.  Check for directives inside instruction bundles.  Warn
	about deprecated ".begin literal" usage.  Warn and ignore [no-]density
	directives.  Handle new directives.  Check generating_literals flag
	for literal_prefix.
	(xtensa_end_directive): Check for directives inside instruction
	bundles.  Warn and ignore [no-]density directives.  Handle new
	directives.  Call xtensa_set_frag_assembly_state.
	(xtensa_loc_directive_seen, xtensa_dwarf2_directive_loc,
	xtensa_dwarf2_emit_insn): New.
	(xtensa_literal_position): Call md_flush_pending_output.  Do not check
	use_literal_section flag.
	(xtensa_literal_pseudo): Call md_flush_pending_output.  Handle absolute
	literals.  Use xtensa_elf_cons to parse the expression.
	(xtensa_literal_prefix): Do not check use_literal_section.  Support
	".lit4" sections for absolute literals.  Change prefix convention to
	replace ".text" (or ".t" in a linkonce section).  No need to call
	subseg_set.
	(xtensa_frequency_pseudo, xtensa_elf_cons, xtensa_elf_suffix): New.
	(expression_end): Handle closing braces and colons.
	(PLT_SUFFIX, plt_suffix): Delete.
	(expression_maybe_register): Use new xtensa-isa.h functions.  Use
	xtensa_elf_suffix instead of checking for plt suffix, and handle O_lo16
	and O_hi16 expressions as well.
	(tokenize_arguments): Handle closing braces and colons.
	(parse_arguments): Use new xtensa-isa.h functions.  Handle "invisible"
	operands and paired register syntax.
	(get_invisible_operands): New.
	(xg_translate_sysreg_op): Handle new Xtensa LX RSR/WSR/XSR syntax.  Use
	new xtensa-isa.h functions.
	(xtensa_translate_old_userreg_ops, xtensa_translate_zero_immed): New.
	(xg_translate_idioms): Check if inside bundle.  Use use_transform.
	Handle new Xtensa LX RSR/WSR/XSR syntax.  Remove code to widen density
	instructions.  Use xtensa_translate_zero_immed.
	(operand_is_immed, operand_is_pcrel_label): Delete.
	(get_relaxable_immed): Use new xtensa-isa.h functions.
	(get_opcode_from_buf): Add slot parameter.  Use new xtensa-isa.h
	functions.
	(xtensa_print_insn_table, print_vliw_insn): New.
	(is_direct_call_opcode): Use new xtensa-isa.h functions.
	(is_call_opcode, is_loop_opcode, is_conditional_branch_opcode,
	is_branch_or_jump_opcode): Delete.
	(is_movi_opcode, decode_reloc, encode_reloc, encode_alt_reloc): New.
	(opnum_to_reloc, reloc_to_opnum): Delete.
	(xtensa_insnbuf_set_operand, xtensa_insnbuf_get_operand): Use new
	xtensa-isa.h functions.  Operate on one slot of an instruction.
	(xtensa_insnbuf_set_immediate_field, is_negatable_branch,
	xg_get_insn_size): Delete.
	(xg_get_build_instr_size): Use xg_get_single_size.
	(xg_is_narrow_insn, xg_is_single_relaxable_insn): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_get_max_narrow_insn_size): Delete.
	(xg_get_max_insn_widen_size, xg_get_max_insn_widen_literal_size,
	xg_is_relaxable_insn): Update calls to xg_build_widen_table.  Use
	xg_get_single_size.
	(xg_build_to_insn): Record the loc field.  Handle OP_OPERAND_HI16U and
	OP_OPERAND_LOW16U.  Check xg_valid_literal_expression.
	(xg_expand_to_stack, xg_expand_narrow): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_immeds_fit): Use new xtensa-isa.h functions.  Update call to
	xg_check_operand.
	(xg_symbolic_immeds_fit): Likewise.  Also handle O_lo16 and O_hi16, and
	treat weak symbols conservatively.
	(xg_check_operand): Use new xtensa-isa.h functions.
	(is_dnrange): Delete.
	(xg_assembly_relax): Inline previous calls to tinsn_copy.
	(xg_finish_frag): Specify separate relax states for the frag and slot0.
	(is_branch_jmp_to_next, xg_add_branch_and_loop_targets): Use new
	xtensa-isa.h functions.
	(xg_instruction_matches_option_term, xg_instruction_matches_or_options,
	xg_instruction_matches_options): New.
	(xg_instruction_matches_rule): Handle O_register expressions.  Call
	xg_instruction_matches_options.
	(transition_rule_cmp): New.
	(xg_instruction_match): Update call to xg_build_simplify_table.
	(xg_build_token_insn): Record loc fields.
	(xg_simplify_insn): Check is_specific_opcode field and
	density_supported flag.
	(xg_expand_assembly_insn): Skip checking code_density_available.  Use
	new xtensa-isa.h functions.  Call use_transform instead of can_relax.
	(xg_assemble_literal): Add error handling for O_big.  Call
	record_alignment.  Handle O_pltrel.
	(xg_valid_literal_expression): New.
	(xg_assemble_literal_space): Add slot parameter.  Remove call to
	set_expr_symbol_offset.  Add call to record_alignment.  Update call to
	xg_finish_frag.
	(xg_emit_insn): Delete.
	(xg_emit_insn_to_buf): Add format parameter.  Update calls to
	xg_add_opcode_fix and xtensa_insnbuf_to_chars.
	(xg_add_opcode_fix): Change opcode parameter to tinsn and add format
	and slot parameters.  Handle new "alternate" relocations for absolute
	literals and CONST16 instructions.  Check for bad uses of O_lo16 and
	O_hi16.  Use new xtensa-isa.h functions.
	(xg_assemble_tokens): Delete.
	(is_register_writer): Use new xtensa-isa.h functions.
	(is_bad_loopend_opcode): Check for xtensa_rsr_lcount_opcode instead of
	old-style RSR from LCOUNT.
	(next_frag_opcode): Delete.
	(next_frag_opcode_is_loop, next_frag_format_size, frag_format_size,
	update_next_frag_state): New.
	(update_next_frag_nop_state): Delete.
	(next_frag_pre_opcode_bytes): Use next_frag_opcode_is_loop.
	(xtensa_mark_literal_pool_location): Check use_literal_section flag and
	the state of the absolute-literals directive.  Add calls to
	record_alignment and xtensa_set_frag_assembly_state.  Call
	xtensa_switch_to_non_abs_literal_fragment instead of
	xtensa_switch_to_literal_fragment.
	(build_nop): New.
	(assemble_nop): Use build_nop.  Update call to xtensa_insnbuf_to_chars.
	(get_expanded_loop_offset): Change check for undefined opcode to an
	assertion.
	(xtensa_set_frag_assembly_state, relaxable_section,
	xtensa_find_unmarked_state_frags, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_apply_tentative_value): New.
	(md_begin): Update call to xtensa_isa_init.  Initialize linkrelax to 1.
	Set lit4_seg_name.  Call xg_init_vinsn.  Initialize new global opcodes.
	Call init_op_placement_info_table and xtensa_set_frag_assembly_state.
	(xtensa_init_fix_data): New.
	(xtensa_frob_label): Reset label symbol to the current frag.  Check
	do_align_targets and generating_literals flag.  Propagate frequency
	info to new alignment frag.  Call xtensa_set_frag_assembly_state.
	(xtensa_unrecognized_line): New.
	(xtensa_flush_pending_output): Check if inside a bundle.  Add a call
	to xtensa_set_frag_assembly_state.
	(error_reset_cur_vinsn): New.
	(md_assemble): Remove check for literal frag.  Remove call to
	istack_init.  Call use_transform instead of use_generics.  Parse
	explicit instruction format specifiers.  Move code for
	a0_b_retw_interlock workaround to xg_assemble_vliw_tokens.  Call
	error_reset_cur_vinsn on errors.  Add call to get_invisible_operands.
	Add dwarf2_where call.  Remote automatic alignment for ENTRY
	instructions.  Move call to xtensa_clear_insn_labels to the end.
	Rearrange to handle bundles.
	(xtensa_cons_fix_new): Delete.
	(xtensa_handle_align): New.
	(xtensa_frag_init): Call xtensa_set_frag_assembly_state.  Remove
	assignment to is_no_density field.
	(md_pcrel_from): Use new xtensa-isa.h functions.  Use decode_reloc
	instead of reloc_to_opnum.  Handle "alternate" relocations.
	(xtensa_force_relocation, xtensa_check_inside_bundle,
	xtensa_elf_section_change_hook): New.
	(xtensa_symbol_new_hook): Delete.
	(xtensa_fix_adjustable): Check for difference of symbols with an
	offset.  Check for external and weak symbols.
	(md_apply_fix3): Remove cases for XTENSA_OP{0,1,2} relocs.
	(md_estimate_size_before_relax): Return expansion for the first slot.
	(tc_gen_reloc): Handle difference of symbols by producing
	XTENSA_DIFF{8,16,32} relocs and by writing the value of the difference
	into the output.  Handle new XTENSA_SLOT*_OP relocs by storing the
	tentative values into the output when linkrelax is set.
	(XTENSA_PROP_SEC_NAME): Define.
	(xtensa_post_relax_hook): Call xtensa_find_unmarked_state_frags.
	Create literal tables only if using literal sections.  Create new
	property tables instead of old instruction tables.  Check for unaligned
	branch targets and loops.
	(finish_vinsn, find_vinsn_conflicts, check_t1_t2_reads_and_writes,
	new_resource_table, clear_resource_table, resize_resource_table,
	resources_available, reserve_resources, release_resources,
	opcode_funcUnit_use_unit, opcode_funcUnit_use_stage,
	resources_conflict, xg_find_narrowest_format, relaxation_requirements,
	bundle_single_op, emit_single_op, xg_assemble_vliw_tokens): New.
	(xtensa_end): Call xtensa_flush_pending_output.  Set past_xtensa_end
	flag.  Update checks for workaround options.  Call
	xtensa_mark_narrow_branches and xtensa_mark_zcl_first_insns.
	(xtensa_cleanup_align_frags): Add special case for branch targets.
	Check for and mark unreachable frags.
	(xtensa_fix_target_frags): Remove use of align_only_targets flag.
	Use RELAX_LOOP_END_BYTES in special case for negatable branch at the
	end of a zero-overhead loop body.
	(frag_can_negate_branch): Handle instructions with multiple slots.
	Use new xtensa-isa.h functions
	(xtensa_mark_narrow_branches, is_narrow_branch_guaranteed_in_range,
	xtensa_mark_zcl_first_insns): New.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags): Error if
	transformations are disabled.
	(next_instrs_are_b_retw): Use new xtensa-isa.h functions.  Handle
	multislot instructions.
	(xtensa_fix_close_loop_end_frags, xtensa_fix_short_loop_frags):
	Likewise.  Also error if transformations are disabled.
	(unrelaxed_frag_max_size): New.
	(unrelaxed_frag_min_insn_count, unrelax_frag_has_b_j): Use new
	xtensa-isa.h functions.
	(xtensa_sanity_check, is_empty_loop, is_local_forward_loop): Use
	xtensa_opcode_is_loop instead of is_loop_opcode.
	(get_text_align_power): Replace as_fatal with assertion.
	(get_text_align_fill_size): Iterate instead of using modulus when
	use_nops is false.
	(get_noop_aligned_address): Assert that this is for a machine-dependent
	RELAX_ALIGN_NEXT_OPCODE frag.  Use next_frag_opcode_is_loop,
	xg_get_single_size, and frag_format_size.
	(get_widen_aligned_address): Rename to ...
	(get_aligned_diff): ... this function.  Add max_diff parameter.
	Remove handling of rs_align/rs_align_code frags.  Use
	next_frag_format_size, get_text_align_power, get_text_align_fill_size,
	next_frag_opcode_is_loop, and xg_get_single_size.  Compute max_diff
	and pass it back to caller.
	(xtensa_relax_frag): Use relax_frag_loop_align.  Add code for new
	RELAX_SLOTS, RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN,
	RELAX_FILL_NOP, and RELAX_UNREACHABLE frag types.  Check relax_seen.
	(relax_frag_text_align): Rename to ...
	(relax_frag_loop_align): ... this function.  Assume loops can only be
	in the first slot of an instruction.
	(relax_frag_add_nop): Use assemble_nop instead of constructing an OR
	instruction.  Remove call to frag_wane.
	(relax_frag_narrow): Rename to ...
	(relax_frag_for_align): ... this function.  Extend to handle
	RELAX_FILL_NOP and RELAX_UNREACHABLE, as well as RELAX_SLOTS with
	RELAX_NARROW for the first slot.
	(find_address_of_next_align_frag, bytes_to_stretch): New.
	(future_alignment_required): Use find_address_of_next_align_frag and
	bytes_to_stretch.  Look ahead to subsequent frags to make smarter
	alignment decisions.
	(relax_frag_immed): Add format, slot, and estimate_only parameters.
	Check if transformations are enabled for b_j_loop_end workaround.
	Use new xtensa-isa.h functions and handle multislot instructions.
	Update call to xg_assembly_relax.
	(md_convert_frag): Handle new RELAX_SLOTS, RELAX_UNREACHABLE,
	RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN, and RELAX_FILL_NOP
	frag types.
	(convert_frag_narrow): Add segP, format and slot parameters.  Call
	convert_frag_immed for branch instructions.  Adjust calls to
	tinsn_from_chars, tinsn_immed_from_frag, and xg_emit_insn_to_buf.  Use
	xg_get_single_size and xg_get_single_format.
	(convert_frag_fill_nop): New.
	(convert_frag_immed): Add format and slot parameters.  Handle multislot
	instructions and use new xtensa-isa.h functions.  Update calls to
	tinsn_immed_from_frag and xg_assembly_relax.  Check if transformations
	enabled for b_j_loop_end workaround.  Use build_nop instead of
	assemble_nop.  Check is_specific_opcode flag.  Check for unreachable
	frags.  Use xg_get_single_size.  Handle O_pltrel.
	(fix_new_exp_in_seg): Remove check for old plt flag.
	(convert_frag_immed_finish_loop): Update calls to tinsn_from_chars and
	xtensa_insnbuf_to_chars.  Call tinsn_immed_from_frag.  Change check
	for loop opcode to an assertion.  Mark all frags up to the end of the
	loop as not transformable.
	(get_last_insn_flags, set_last_insn_flags): Use get_subseg_info.
	(get_subseg_info): New.
	(xtensa_move_literals): Call xtensa_set_frag_assembly_state.  Add null
	check for dest_seg.
	(xtensa_switch_to_literal_fragment): Rewrite to handle absolute
	literals and use xtensa_switch_to_non_abs_literal_fragment otherwise.
	(xtensa_switch_to_non_abs_literal_fragment): New.
	(cache_literal_section): Add is_code parameter and pass it through to
	retrieve_literal_seg.
	(retrieve_literal_seg): Add is_code parameter and use it to set the
	flags on the literal section.  Handle case where head parameter is 0.
	(get_frag_is_no_transform, set_frag_is_specific_opcode,
	set_frag_is_no_transform): New.
	(xtensa_create_property_segments): Add end_property_function parameter
	and pass it through to add_xt_block_frags.  Call bfd_get_section_flags
	and skip SEC_DEBUGGING and !SEC_ALLOC sections.
	(xtensa_create_xproperty_segments, section_has_xproperty): New.
	(add_xt_block_frags): Add end_property_function parameter and call it
	if it is non-zero.  Call xtensa_frag_flags_init.
	(xtensa_frag_flags_is_empty, xtensa_frag_flags_init,
	get_frag_property_flags, frag_flags_to_number,
	xtensa_frag_flags_combinable, xt_block_aligned_size,
	xtensa_xt_block_combine, add_xt_prop_frags,
	init_op_placement_info_table, opcode_fits_format_slot,
	xg_get_single_size, xg_get_single_format): New.
	(istack_push): Inline call to tinsn_copy.
	(tinsn_copy): Delete.
	(tinsn_has_invalid_symbolic_operands): Handle O_hi16 and O_lo16 and
	CONST16 opcodes.  Handle O_big, O_illegal, and O_absent.
	(tinsn_has_complex_operands): Handle O_hi16 and O_lo16.
	(tinsn_to_insnbuf): Use xg_get_single_format and new xtensa-isa.h
	functions.  Handle invisible operands.
	(tinsn_to_slotbuf): New.
	(tinsn_check_arguments): Use new xtensa-isa.h functions.
	(tinsn_from_chars): Add slot parameter.  Rewrite using xg_init_vinsn,
	vinsn_from_chars, and xg_free_vinsn.
	(tinsn_from_insnbuf): New.
	(tinsn_immed_from_frag): Add slot parameter and handle multislot
	instructions.  Handle symbol differences.
	(get_num_stack_text_bytes): Use xg_get_single_size.
	(xg_init_vinsn, xg_clear_vinsn, vinsn_has_specific_opcodes,
	xg_free_vinsn, vinsn_to_insnbuf, vinsn_from_chars, expr_is_register,
	get_expr_register, set_expr_symbol_offset_diff): New.
	* config/tc-xtensa.h (MAX_SLOTS): Define.
	(xtensa_relax_statesE): Move from tc-xtensa.c. Add
	RELAX_CHECK_ALIGN_NEXT_OPCODE, RELAX_MAYBE_DESIRE_ALIGN, RELAX_SLOTS,
	RELAX_FILL_NOP, RELAX_UNREACHABLE, RELAX_MAYBE_UNREACHABLE, and
	RELAX_NONE types.
	(RELAX_IMMED_MAXSTEPS): Move from tc-xtensa.c.
	(xtensa_frag_type struct): Add is_assembly_state_set,
	use_absolute_literals, relax_seen, is_unreachable, is_specific_opcode,
	is_align, is_text_align, alignment, and is_first_loop_insn fields.
	Replace is_generics and is_relax fields by is_no_transform field.
	Delete is_text and is_longcalls fields.  Change text_expansion and
	literal_expansion to arrays of MAX_SLOTS entries.  Add arrays of
	per-slot information: literal_frags, slot_subtypes, slot_symbols,
	slot_sub_symbols, and slot_offsets.  Add fr_prev field.
	(xtensa_fix_data struct): New.
	(xtensa_symfield_type struct): Delete plt field.
	(xtensa_block_info struct): Move definition to tc-xtensa.h.  Add
	forward declaration here.
	(xt_section_type enum): Delete xt_insn_sec.  Add xt_prop_sec.
	(XTENSA_SECTION_RENAME): Undefine.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA, TC_FORCE_RELOCATION, NO_PSEUDO_DOT,
	tc_unrecognized_line, md_do_align, md_elf_section_change_hook,
	HANDLE_ALIGN, TC_LINKRELAX_FIXUP, SUB_SEGMENT_ALIGN): Define.
	(TC_CONS_FIX_NEW, tc_symbol_new_hook): Delete.
	(unit_num_copies_func, opcode_num_units_func,
	opcode_funcUnit_use_unit_func, opcode_funcUnit_use_stage_func): New.
	(resource_table struct): New.
	* config/xtensa-istack.h (MAX_INSN_ARGS): Increase from 6 to 10.
	(TInsn struct): Add keep_wide, loc, fixup, record_fix, subtype,
	literal_space, symbol, sub_symbol, offset, and literal_frag fields.
	(tinsn_copy): Delete prototype.
	(vliw_insn struct): New.
	* config/xtensa-relax.c (insn_pattern_struct): Add options field.
	(widen_spec_list): Add option conditions for density and boolean
	instructions.  Add expansions using CONST16 and conditions for using
	CONST16 vs. L32R.  Use new Xtensa LX RSR/WSR syntax.  Add entries for
	predicted branches.
	(simplify_spec_list): Add option conditions for density instructions.
	Add entry for NOP instruction.
	(append_transition): Add cmp function pointer parameter and use it to
	insert the new entry in order.
	(operand_function_LOW16U, operand_function_HI16U): New.
	(xg_has_userdef_op_fn, xg_apply_userdef_op_fn): Handle
	OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(enter_opname, split_string): Use xstrdup instead of strdup.
	(init_insn_pattern): Initialize new options field.
	(clear_req_or_option_list, clear_req_option_list,
	clone_req_or_option_list, clone_req_option_list, parse_option_cond):
	New.
	(parse_insn_pattern): Parse option conditions.
	(transition_applies): New.
	(build_transition): Use new xtensa-isa.h functions.  Fix incorrectly
	swapped last arguments in calls to append_constant_value_condition.
	Call clone_req_option_list.  Add warning about invalid opcode.
	Handle LOW16U and HI16U function names.
	(build_transition_table): Add cmp parameter and use it in calls to
	append_transition.  Use new xtensa-isa.h functions.  Check
	transition_applies before adding entries.
	(xg_build_widen_table, xg_build_simplify_table): Add cmp parameter and
	pass it through to build_transition_table.
	* config/xtensa-relax.h (ReqOrOptionList, ReqOrOption, ReqOptionList,
	ReqOption, transition_cmp_fn): New types.
	(OpType enum): Add OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(transition_rule struct): Add options field.
	* doc/as.texinfo (Overview): Update Xtensa options.
	* doc/c-xtensa.texi (Xtensa Options): Delete --[no-]density,
	--[no-]relax, and --[no-]generics options.  Update descriptions of
	--text-section-literals and --[no-]longcalls.  Add
	--[no-]absolute-literals and --[no-]transform.
	(Xtensa Syntax): Add description of syntax for FLIX instructions.
	Remove use of "generic" and "specific" terminology for opcodes.
	(Xtensa Registers): Generalize the syntax description to include
	user-defined register files.
	(Xtensa Automatic Alignment): Update.
	(Xtensa Branch Relaxation): Mention limitation of unconditional jumps.
	(Xtensa Call Relaxation): Linker can now remove most of the overhead.
	(Xtensa Directives): Remove confusing rules about precedence.
	(Density Directive, Relax Directive): Delete.
	(Schedule Directive): New.
	(Generics Directive): Rename to ...
	(Transform Directive): ... this node.
	(Literal Directive): Update for absolute literals.  Missing
	literal_position directive is now an error.
	(Literal Position Directive): Update for absolute literals.
	(Freeregs Directive): Delete.
	(Absolute Literals Directive): New.
	(Frame Directive): Minor editing.
	* Makefile.am (DEPTC_xtensa_elf, DEPOBJ_xtensa_elf, DEP_xtensa_elf):
	Update dependencies.
	* Makefile.in: Regenerate.

gas/testsuite ChangeLog

	* gas/xtensa/all.exp: Adjust expected error message for j_too_far.
	Change entry_align test to expect an error.
	* gas/xtensa/entry_misalign2.s: Use no-transform instead of
	no-generics directives.

include ChangeLog

	* xtensa-config.h (XSHAL_USE_ABSOLUTE_LITERALS,
	XCHAL_HAVE_PREDICTED_BRANCHES, XCHAL_INST_FETCH_WIDTH): New.
	(XCHAL_EXTRA_SA_SIZE, XCHAL_EXTRA_SA_ALIGN): Delete.
	* xtensa-isa-internal.h (ISA_INTERFACE_VERSION): Delete.
	(config_sturct struct): Delete.
	(XTENSA_OPERAND_IS_REGISTER, XTENSA_OPERAND_IS_PCRELATIVE,
	XTENSA_OPERAND_IS_INVISIBLE, XTENSA_OPERAND_IS_UNKNOWN,
	XTENSA_OPCODE_IS_BRANCH, XTENSA_OPCODE_IS_JUMP,
	XTENSA_OPCODE_IS_LOOP, XTENSA_OPCODE_IS_CALL,
	XTENSA_STATE_IS_EXPORTED, XTENSA_INTERFACE_HAS_SIDE_EFFECT): Define.
	(xtensa_format_encode_fn, xtensa_get_slot_fn, xtensa_set_slot_fn): New.
	(xtensa_insn_decode_fn): Rename to ...
	(xtensa_opcode_decode_fn): ... this.
	(xtensa_immed_decode_fn, xtensa_immed_encode_fn, xtensa_do_reloc_fn,
	xtensa_undo_reloc_fn): Update.
	(xtensa_encoding_template_fn): Delete.
	(xtensa_opcode_encode_fn, xtensa_format_decode_fn,
	xtensa_length_decode_fn): New.
	(xtensa_format_internal, xtensa_slot_internal): New types.
	(xtensa_operand_internal): Delete operand_kind, inout, isPCRelative,
	get_field, and set_field fields.  Add name, field_id, regfile,
	num_regs, and flags fields.
	(xtensa_arg_internal): New type.
	(xtensa_iclass_internal): Change operands field to array of
	xtensa_arg_internal.  Add num_stateOperands, stateOperands,
	num_interfaceOperands, and interfaceOperands fields.
	(xtensa_opcode_internal): Delete length, template, and iclass fields.
	Add iclass_id, flags, encode_fns, num_funcUnit_uses, and funcUnit_uses.
	(opname_lookup_entry): Delete.
	(xtensa_regfile_internal, xtensa_interface_internal,
	xtensa_funcUnit_internal, xtensa_state_internal,
	xtensa_sysreg_internal, xtensa_lookup_entry): New.
	(xtensa_isa_internal): Replace opcode_table field with opcodes field.
	Change type of opname_lookup_table.  Delete num_modules,
	module_opcode_base, module_decode_fn, config, and has_density fields.
	Add num_formats, formats, format_decode_fn, length_decode_fn,
	num_slots, slots, num_fields, num_operands, operands, num_iclasses,
	iclasses, num_regfiles, regfiles, num_states, states,
	state_lookup_table, num_sysregs, sysregs, sysreg_lookup_table,
	max_sysreg_num, sysreg_table, num_interfaces, interfaces,
	interface_lookup_table, num_funcUnits, funcUnits and
	funcUnit_lookup_table fields.
	(xtensa_isa_module, xtensa_isa_modules): Delete.
	(xtensa_isa_name_compare): New prototype.
	(xtisa_errno, xtisa_error_msg): New.
	* xtensa-isa.h (XTENSA_ISA_VERSION): Define.
	(xtensa_isa): Change type.
	(xtensa_operand): Delete.
	(xtensa_format, xtensa_regfile, xtensa_state, xtensa_sysreg,
	xtensa_interface, xtensa_funcUnit, xtensa_isa_status,
	xtensa_funcUnit_use): New types.
	(libisa_module_specifier): Delete.
	(xtensa_isa_errno, xtensa_isa_error_msg): New prototypes.
	(xtensa_insnbuf_free, xtensa_insnbuf_to_chars,
	xtensa_insnbuf_from_chars): Update prototypes.
	(xtensa_load_isa, xtensa_extend_isa, xtensa_default_isa,
	xtensa_insn_maxlength, xtensa_num_opcodes, xtensa_decode_insn,
	xtensa_encode_insn, xtensa_insn_length,
	xtensa_insn_length_from_first_byte, xtensa_num_operands,
	xtensa_operand_kind, xtensa_encode_result,
	xtensa_operand_isPCRelative): Delete.
	(xtensa_isa_init, xtensa_operand_inout, xtensa_operand_get_field,
	xtensa_operand_set_field, xtensa_operand_encode,
	xtensa_operand_decode, xtensa_operand_do_reloc,
	xtensa_operand_undo_reloc): Update prototypes.
	(xtensa_isa_maxlength, xtensa_isa_length_from_chars,
	xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_opcodes, xtensa_isa_num_regfiles, xtensa_isa_num_states,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot, xtensa_opcode_decode,
	xtensa_opcode_encode, xtensa_opcode_is_branch, xtensa_opcode_is_jump,
	xtensa_opcode_is_loop, xtensa_opcode_is_call,
	xtensa_opcode_num_operands, xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible, xtensa_operand_is_register,
	xtensa_operand_regfile, xtensa_operand_num_regs,
	xtensa_operand_is_known_reg, xtensa_operand_is_PCrelative,
	xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New prototypes.
	* elf/xtensa.h (R_XTENSA_DIFF8, R_XTENSA_DIFF16, R_XTENSA_DIFF32,
	R_XTENSA_SLOT*_OP, R_XTENSA_SLOT*_ALT): New relocations.
	(XTENSA_PROP_SEC_NAME): Define.
	(property_table_entry): Add flags field.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.

ld ChangeLog

	* ld.texinfo (Xtensa): Describe new linker relaxation to optimize
	assembler-generated longcall sequences.  Describe new --size-opt
	option.
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): Add .xt.prop section.
	* emultempl/xtensaelf.em (remove_section,
	replace_insn_sec_with_prop_sec, replace_instruction_table_sections,
	elf_xtensa_after_open): New.
	(OPTION_OPT_SIZEOPT, OPTION_LITERAL_MOVEMENT,
	OPTION_NO_LITERAL_MOVEMENT): Define.
	(elf32xtensa_size_opt, elf32xtensa_no_literal_movement): New globals.
	(PARSE_AND_LIST_LONGOPTS): Add size-opt and [no-]literal-movement.
	(PARSE_AND_LIST_OPTIONS): Add --size-opt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_OPT_SIZEOPT,
	OPTION_LITERAL_MOVEMENT, and OPTION_NO_LITERAL_MOVEMENT.
	(LDEMUL_AFTER_OPEN): Set to elf_xtensa_after_open.
	* scripttempl/elfxtensa.sc: Update with changes from elf.sc.
	* Makefile.am (eelf32xtensa.c): Update dependencies.
	* Makefile.in: Regenerate.

ld/testsuite ChangeLog

	* ld-xtensa/lcall1.s: Use .literal directive.
	* ld-xtensa/lcall2.s: Align function entry.
	* ld-xtensa/coalesce2.s: Likewise.

opcodes ChangeLog

	* xtensa-dis.c (state_names): Delete.
	(fetch_data): Use xtensa_isa_maxlength.
	(print_xtensa_operand): Replace operand parameter with opcode/operand
	pair.  Remove print_sr_name parameter.  Use new xtensa-isa.h functions.
	(print_insn_xtensa): Use new xtensa-isa.h functions.  Handle multislot
	instruction bundles.  Use xmalloc instead of malloc.
@
text
@d1680 9
@


1.2
log
@	* cpu-arm.c (arm_check_note): Warning fix.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Warning fixes.  Arrange
	to keep relocs if edited.
	(iq2000_elf_print_private_bfd_data): Return TRUE.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use ELFNN_R_SYM, not
	ELF64_R_SYM.
	(elfNN_ia64_relax_ldxmov): Warning fix.
	* xtensa-isa.c (xtensa_add_isa): Warning fix.
	* xtensa-modules.c (get_num_opcodes): Warning fix.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d20 3
a22 5
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <string.h>

d26 145
a170 1
xtensa_isa xtensa_default_isa = NULL;
d172 11
a182 2
static int
opname_lookup_compare (const void *v1, const void *v2)
d184 2
a185 2
  opname_lookup_entry *e1 = (opname_lookup_entry *)v1;
  opname_lookup_entry *e2 = (opname_lookup_entry *)v2;
d187 35
a221 1
  return strcmp (e1->key, e2->key);
d225 5
d231 448
a678 1
xtensa_isa_init (void)
d680 3
a682 2
  xtensa_isa isa;
  int mod;
d684 7
a690 2
  isa = xtensa_load_isa (0);
  if (isa == 0)
d692 143
a834 1
      fprintf (stderr, "Failed to initialize Xtensa base ISA module\n");
d837 72
d910 85
a994 1
  for (mod = 1; xtensa_isa_modules[mod].get_num_opcodes_fn; mod++)
d996 5
a1000 5
      if (!xtensa_extend_isa (isa, mod))
	{
	  fprintf (stderr, "Failed to initialize Xtensa TIE ISA module\n");
	  return NULL;
	}
d1002 2
a1003 2

  return isa;
a1005 1
/* ISA information.  */
d1007 3
a1009 3
static int
xtensa_check_isa_config (xtensa_isa_internal *isa,
			 struct config_struct *config_table)
d1011 3
a1013 1
  int i, j;
d1015 4
a1018 1
  if (!config_table)
d1020 7
a1026 3
      fprintf (stderr, "Error: Empty configuration table in ISA DLL\n");
      return 0;
    }
d1028 5
a1032 2
  /* For the first module, save a pointer to the table and record the
     specified endianness and availability of the density option.  */
d1034 8
a1041 3
  if (isa->num_modules == 0)
    {
      int found_memory_order = 0;
d1043 7
a1049 2
      isa->config = config_table;
      isa->has_density = 1;  /* Default to have density option.  */
d1051 1
a1051 9
      for (i = 0; config_table[i].param_name; i++)
	{
	  if (!strcmp (config_table[i].param_name, "IsaMemoryOrder"))
	    {
	      isa->is_big_endian =
		(strcmp (config_table[i].param_value, "BigEndian") == 0);
	      found_memory_order = 1;
	    }
	  if (!strcmp (config_table[i].param_name, "IsaUseDensityInstruction"))
d1053 2
a1054 1
	      isa->has_density = atoi (config_table[i].param_value);
a1056 6
      if (!found_memory_order)
	{
	  fprintf (stderr, "Error: \"IsaMemoryOrder\" missing from "
		   "configuration table in ISA DLL\n");
	  return 0;
	}
d1058 4
a1061 1
      return 1;
d1064 8
a1071 8
  /* For subsequent modules, check that the parameters match.  Note: This
     code is sufficient to handle the current model where there are never
     more than 2 modules; we might at some point want to handle cases where
     module N > 0 specifies some parameters not included in the base table,
     and we would then add those to isa->config so that subsequent modules
     would check against them. */

  for (i = 0; config_table[i].param_name; i++)
d1073 3
a1075 32
      for (j = 0; isa->config[j].param_name; j++)
	{
	  if (!strcmp (config_table[i].param_name, isa->config[j].param_name))
	    {
	      int mismatch;
	      if (!strcmp (config_table[i].param_name, "IsaCoprocessorCount"))
		{
		  /* Only require the coprocessor count to be <= the base.  */
		  int tiecnt = atoi (config_table[i].param_value);
		  int basecnt = atoi (isa->config[j].param_value);
		  mismatch = (tiecnt > basecnt);
		}
	      else
		mismatch = strcmp (config_table[i].param_value,
				   isa->config[j].param_value);
	      if (mismatch)
		{
#define MISMATCH_MESSAGE \
"Error: Configuration mismatch in the \"%s\" parameter:\n\
the configuration used when the TIE file was compiled had a value of\n\
\"%s\", while the current configuration has a value of\n\
\"%s\". Please rerun the TIE compiler with a matching\n\
configuration.\n"
		  fprintf (stderr, MISMATCH_MESSAGE,
			   config_table[i].param_name,
			   config_table[i].param_value,
			   isa->config[j].param_value);
		  return 0;
		}
	      break;
	    }
	}
d1078 1
a1078 1
  return 1;
d1082 3
a1084 2
static int
xtensa_add_isa (xtensa_isa_internal *isa, libisa_module_specifier libisa)
d1086 2
a1087 6
  int (*get_num_opcodes_fn) (void);
  struct config_struct *(*get_config_table_fn) (void);
  xtensa_opcode_internal **(*get_opcodes_fn) (void);
  int (*decode_insn_fn) (const xtensa_insnbuf);
  xtensa_opcode_internal **opcodes;
  int opc, insn_size, prev_num_opcodes, new_num_opcodes, this_module;
d1089 2
a1090 4
  get_num_opcodes_fn = xtensa_isa_modules[libisa].get_num_opcodes_fn;
  get_opcodes_fn = xtensa_isa_modules[libisa].get_opcodes_fn;
  decode_insn_fn = xtensa_isa_modules[libisa].decode_insn_fn;
  get_config_table_fn = xtensa_isa_modules[libisa].get_config_table_fn;
d1092 2
a1093 2
  if (!get_num_opcodes_fn || !get_opcodes_fn || !decode_insn_fn
      || (!get_config_table_fn && isa->num_modules == 0))
d1096 5
a1100 27
  if (get_config_table_fn
      && !xtensa_check_isa_config (isa, get_config_table_fn ()))
    return 0;

  prev_num_opcodes = isa->num_opcodes;
  new_num_opcodes = (*get_num_opcodes_fn) ();

  isa->num_opcodes += new_num_opcodes;
  isa->opcode_table = (xtensa_opcode_internal **)
    realloc (isa->opcode_table, isa->num_opcodes *
	     sizeof (xtensa_opcode_internal *));
  isa->opname_lookup_table = (opname_lookup_entry *)
    realloc (isa->opname_lookup_table, isa->num_opcodes *
	     sizeof (opname_lookup_entry));

  opcodes = (*get_opcodes_fn) ();

  insn_size = isa->insn_size;
  for (opc = 0; opc < new_num_opcodes; opc++)
    {
      xtensa_opcode_internal *intopc = opcodes[opc];
      int newopc = prev_num_opcodes + opc;
      isa->opcode_table[newopc] = intopc;
      isa->opname_lookup_table[newopc].key = intopc->name;
      isa->opname_lookup_table[newopc].opcode = newopc;
      if (intopc->length > insn_size)
	insn_size = intopc->length;
d1102 2
a1104 3
  isa->insn_size = insn_size;
  isa->insnbuf_size = ((isa->insn_size + sizeof (xtensa_insnbuf_word) - 1) /
		       sizeof (xtensa_insnbuf_word));
d1106 5
a1110 2
  qsort (isa->opname_lookup_table, isa->num_opcodes,
	 sizeof (opname_lookup_entry), opname_lookup_compare);
d1112 2
a1113 11
  /* Check for duplicate opcode names.  */
  for (opc = 1; opc < isa->num_opcodes; opc++)
    {
      if (!opname_lookup_compare (&isa->opname_lookup_table[opc-1],
				  &isa->opname_lookup_table[opc]))
	{
	  fprintf (stderr, "Error: Duplicate TIE opcode \"%s\"\n",
		   isa->opname_lookup_table[opc].key);
	  return 0;
	}
    }
d1115 4
a1118 2
  this_module = isa->num_modules;
  isa->num_modules += 1;
a1119 5
  isa->module_opcode_base = (int *) realloc (isa->module_opcode_base,
					     isa->num_modules * sizeof (int));
  isa->module_decode_fn = (xtensa_insn_decode_fn *)
    realloc (isa->module_decode_fn, isa->num_modules *
	     sizeof (xtensa_insn_decode_fn));
d1121 5
a1125 2
  isa->module_opcode_base[this_module] = prev_num_opcodes;
  isa->module_decode_fn[this_module] = decode_insn_fn;
d1127 2
a1128 1
  xtensa_default_isa = isa;
d1130 1
a1130 1
  return 1;	/* Library was successfully added.  */
d1134 2
a1135 2
xtensa_isa
xtensa_load_isa (libisa_module_specifier libisa)
d1137 5
a1141 1
  xtensa_isa_internal *isa;
d1143 1
a1143 8
  isa = (xtensa_isa_internal *) malloc (sizeof (xtensa_isa_internal));
  memset (isa, 0, sizeof (xtensa_isa_internal));
  if (!xtensa_add_isa (isa, libisa))
    {
      xtensa_isa_free (isa);
      return NULL;
    }
  return (xtensa_isa) isa;
d1148 1
a1148 1
xtensa_extend_isa (xtensa_isa isa, libisa_module_specifier libisa)
d1151 8
a1158 1
  return xtensa_add_isa (intisa, libisa);
d1162 2
a1163 2
void
xtensa_isa_free (xtensa_isa isa)
d1166 8
a1173 9
  if (intisa->opcode_table)
    free (intisa->opcode_table);
  if (intisa->opname_lookup_table)
    free (intisa->opname_lookup_table);
  if (intisa->module_opcode_base)
    free (intisa->module_opcode_base);
  if (intisa->module_decode_fn)
    free (intisa->module_decode_fn);
  free (intisa);
d1178 2
a1179 1
xtensa_insn_maxlength (xtensa_isa isa)
d1182 24
a1205 1
  return intisa->insn_size;
d1210 2
a1211 1
xtensa_insnbuf_size (xtensa_isa isa)
d1213 25
a1237 2
  xtensa_isa_internal *intisa = (xtensa_isa_internal *)isa;
  return intisa->insnbuf_size;
d1241 19
a1259 2
int
xtensa_num_opcodes (xtensa_isa isa)
d1262 8
a1269 1
  return intisa->num_opcodes;
d1273 35
a1307 2
xtensa_opcode
xtensa_opcode_lookup (xtensa_isa isa, const char *opname)
d1310 2
a1311 1
  opname_lookup_entry entry, *result;
d1313 5
a1317 5
  entry.key = opname;
  result = bsearch (&entry, intisa->opname_lookup_table, intisa->num_opcodes,
		    sizeof (opname_lookup_entry), opname_lookup_compare);
  if (!result) return XTENSA_UNDEFINED;
  return result->opcode;
d1321 17
a1337 2
xtensa_opcode
xtensa_decode_insn (xtensa_isa isa, const xtensa_insnbuf insn)
d1340 18
a1357 6
  int n, opc;
  for (n = 0; n < intisa->num_modules; n++) {
    opc = (intisa->module_decode_fn[n]) (insn);
    if (opc != XTENSA_UNDEFINED)
      return intisa->module_opcode_base[n] + opc;
  }
d1362 2
a1363 4
/* Opcode information.  */

void
xtensa_encode_insn (xtensa_isa isa, xtensa_opcode opc, xtensa_insnbuf insn)
a1365 2
  xtensa_insnbuf template = intisa->opcode_table[opc]->template();
  int len = intisa->opcode_table[opc]->length;
d1368 17
a1384 2
  /* Convert length to 32-bit words.  */
  len = (len + 3) / 4;
d1386 4
a1389 7
  /* Copy the template.  */
  for (n = 0; n < len; n++)
    insn[n] = template[n];

  /* Fill any unused buffer space with zeros.  */
  for ( ; n < intisa->insnbuf_size; n++)
    insn[n] = 0;
d1394 1
a1394 1
xtensa_opcode_name (xtensa_isa isa, xtensa_opcode opc)
d1397 2
a1398 1
  return intisa->opcode_table[opc]->name;
d1402 2
a1403 2
int
xtensa_insn_length (xtensa_isa isa, xtensa_opcode opc)
d1406 2
a1407 1
  return intisa->opcode_table[opc]->length;
d1411 2
a1412 2
int
xtensa_insn_length_from_first_byte (xtensa_isa isa, char first_byte)
d1415 2
a1416 2
  int is_density = (first_byte & (intisa->is_big_endian ? 0x80 : 0x08)) != 0;
  return (intisa->has_density && is_density ? 2 : 3);
d1421 1
a1421 1
xtensa_num_operands (xtensa_isa isa, xtensa_opcode opc)
d1424 2
a1425 1
  return intisa->opcode_table[opc]->iclass->num_operands;
d1429 2
a1430 2
xtensa_operand
xtensa_get_operand (xtensa_isa isa, xtensa_opcode opc, int opnd)
d1433 2
a1434 4
  xtensa_iclass_internal *iclass = intisa->opcode_table[opc]->iclass;
  if (opnd >= iclass->num_operands)
    return NULL;
  return (xtensa_operand) iclass->operands[opnd];
d1437 13
a1450 1
/* Operand information.  */
d1452 2
a1453 2
char *
xtensa_operand_kind (xtensa_operand opnd)
d1455 22
a1476 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return intop->operand_kind;
d1480 2
a1481 2
char
xtensa_operand_inout (xtensa_operand opnd)
d1483 3
a1485 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return intop->inout;
d1489 2
a1490 2
uint32
xtensa_operand_get_field (xtensa_operand opnd, const xtensa_insnbuf insn)
d1492 3
a1494 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return (*intop->get_field) (insn);
d1498 2
a1499 2
void
xtensa_operand_set_field (xtensa_operand opnd, xtensa_insnbuf insn, uint32 val)
d1501 5
a1505 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return (*intop->set_field) (insn, val);
d1508 3
d1512 13
a1524 2
xtensa_encode_result
xtensa_operand_encode (xtensa_operand opnd, uint32 *valp)
d1526 14
a1539 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return (*intop->encode) (valp);
d1543 2
a1544 2
uint32
xtensa_operand_decode (xtensa_operand opnd, uint32 val)
d1546 22
a1567 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return (*intop->decode) (val);
d1571 2
a1572 2
int
xtensa_operand_isPCRelative (xtensa_operand opnd)
d1574 3
a1576 2
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  return intop->isPCRelative;
d1580 2
a1581 2
uint32
xtensa_operand_do_reloc (xtensa_operand opnd, uint32 addr, uint32 pc)
d1583 3
a1585 4
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  if (!intop->isPCRelative)
    return addr;
  return (*intop->do_reloc) (addr, pc);
d1589 2
a1590 2
uint32
xtensa_operand_undo_reloc (xtensa_operand opnd, uint32 offset, uint32 pc)
d1592 5
a1596 4
  xtensa_operand_internal *intop = (xtensa_operand_internal *) opnd;
  if (!intop->isPCRelative)
    return offset;
  return (*intop->undo_reloc) (offset, pc);
d1599 13
a1612 1
/* Instruction buffers.  */
d1614 2
a1615 2
xtensa_insnbuf
xtensa_insnbuf_alloc (xtensa_isa isa)
d1617 23
a1639 2
  return (xtensa_insnbuf) malloc (xtensa_insnbuf_size (isa) *
				  sizeof (xtensa_insnbuf_word));
d1643 2
a1644 2
void
xtensa_insnbuf_free (xtensa_insnbuf buf)
d1646 3
a1648 1
  free( buf );
d1652 8
a1659 3
/* Given <byte_index>, the index of a byte in a xtensa_insnbuf, our
   internal representation of a xtensa instruction word, return the index of
   its word and the bit index of its low order byte in the xtensa_insnbuf.  */
d1661 2
a1662 2
static inline int
byte_to_word_index (int byte_index)
d1664 3
a1666 1
  return byte_index / sizeof (xtensa_insnbuf_word);
d1670 2
a1671 2
static inline int
byte_to_bit_index (int byte_index)
d1673 5
a1677 1
  return (byte_index & 0x3) * 8;
d1680 3
d1684 9
a1692 6
/* Copy an instruction in the 32 bit words pointed at by <insn> to characters
   pointed at by <cp>.  This is more complicated than you might think because
   we want 16 bit instructions in bytes 2,3 for big endian. This function
   allows us to specify which byte in <insn> to start with and which way to
   increment, allowing trivial implementation for both big and little endian.
   And it seems to make pretty good code for both.  */
d1694 3
a1696 2
void
xtensa_insnbuf_to_chars (xtensa_isa isa, const xtensa_insnbuf insn, char *cp)
d1699 1
a1699 3
  int insn_size = xtensa_insn_maxlength (intisa);
  int fence_post, start, increment, i, byte_count;
  xtensa_opcode opc;
d1701 1
a1701 6
  if (intisa->is_big_endian)
    {
      start = insn_size - 1;
      increment = -1;
    }
  else
d1703 3
a1705 2
      start = 0;
      increment = 1;
d1708 4
a1711 8
  /* Find the opcode; do nothing if the buffer does not contain a valid
     instruction since we need to know how many bytes to copy.  */
  opc = xtensa_decode_insn (isa, insn);
  if (opc == XTENSA_UNDEFINED)
    return;

  byte_count = xtensa_insn_length (isa, opc);
  fence_post = start + (byte_count * increment);
d1713 1
a1713 1
  for (i = start; i != fence_post; i += increment, ++cp)
d1715 5
a1719 2
      int word_inx = byte_to_word_index (i);
      int bit_inx = byte_to_bit_index (i);
d1721 1
a1721 2
      *cp = (insn[word_inx] >> bit_inx) & 0xff;
    }
d1724 3
a1726 6
/* Inward conversion from byte stream to xtensa_insnbuf.  See
   xtensa_insnbuf_to_chars for a discussion of why this is
   complicated by endianness.  */
    
void
xtensa_insnbuf_from_chars (xtensa_isa isa, xtensa_insnbuf insn, const char* cp)
d1729 3
a1731 13
  int insn_size = xtensa_insn_maxlength (intisa);
  int fence_post, start, increment, i;

  if (intisa->is_big_endian)
    {
      start = insn_size - 1;
      increment = -1;
    }
  else
    {
      start = 0;
      increment = 1;
    }
a1732 2
  fence_post = start + (insn_size * increment);
  memset (insn, 0, xtensa_insnbuf_size (isa) * sizeof (xtensa_insnbuf_word));
d1734 6
a1739 7
  for ( i = start; i != fence_post; i += increment, ++cp )
    {
      int word_inx = byte_to_word_index (i);
      int bit_inx = byte_to_bit_index (i);

      insn[word_inx] |= (*cp & 0xff) << bit_inx;
    }
@


1.2.22.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1
log
@Add Xtensa port
@
text
@d162 1
a162 1
  const int (*get_num_opcodes_fn) (void);
@


1.1.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d162 1
a162 1
  int (*get_num_opcodes_fn) (void);
@


1.1.10.1
log
@	* cpu-arm.c (arm_check_note): Warning fix.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Warning fixes.  Arrange
	to keep relocs if edited.
	(iq2000_elf_print_private_bfd_data): Return TRUE.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use ELFNN_R_SYM, not
	ELF64_R_SYM.
	(elfNN_ia64_relax_ldxmov): Warning fix.
	* xtensa-isa.c (xtensa_add_isa): Warning fix.
	* xtensa-modules.c (get_num_opcodes): Warning fix.
	* elf.c (elf_fake_sections): Use correct cast for sh_name.
@
text
@d162 1
a162 1
  int (*get_num_opcodes_fn) (void);
@


1.1.6.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@@


1.1.6.2
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d162 1
a162 1
  int (*get_num_opcodes_fn) (void);
@


