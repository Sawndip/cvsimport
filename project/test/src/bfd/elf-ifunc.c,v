head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.2
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.4.2.1
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.8
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.10
	gdb_7_6-2013-04-26-release:1.8
	sid-snapshot-20130401:1.8
	binutils-2_23_2:1.7
	gdb_7_6-branch:1.8.0.2
	gdb_7_6-2013-03-12-branchpoint:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.7
	sid-snapshot-20121201:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	binutils-2_23_1:1.7
	sid-snapshot-20121101:1.7
	binutils-2_23:1.7
	sid-snapshot-20121001:1.7
	sid-snapshot-20120901:1.7
	gdb_7_5-2012-08-17-release:1.7
	sid-snapshot-20120801:1.7
	binutils-2_23-branch:1.7.0.10
	binutils-2_23-branchpoint:1.7
	gdb_7_5-branch:1.7.0.8
	gdb_7_5-2012-07-18-branchpoint:1.7
	sid-snapshot-20120701:1.7
	sid-snapshot-20120601:1.7
	sid-snapshot-20120501:1.7
	binutils-2_22_branch:1.7.0.6
	gdb_7_4_1-2012-04-26-release:1.7
	sid-snapshot-20120401:1.7
	sid-snapshot-20120301:1.7
	sid-snapshot-20120201:1.7
	gdb_7_4-2012-01-24-release:1.7
	sid-snapshot-20120101:1.7
	gdb_7_4-branch:1.7.0.4
	gdb_7_4-2011-12-13-branchpoint:1.7
	sid-snapshot-20111201:1.7
	binutils-2_22:1.7
	sid-snapshot-20111101:1.7
	sid-snapshot-20111001:1.7
	binutils-2_22-branch:1.7.0.2
	binutils-2_22-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	sid-snapshot-20110901:1.6
	sid-snapshot-20110801:1.6
	gdb_7_3-2011-07-26-release:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	gdb_7_3-branch:1.6.0.2
	gdb_7_3-2011-04-01-branchpoint:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.4
	binutils-2_21:1.4
	sid-snapshot-20101201:1.4
	binutils-2_21-branch:1.4.0.2
	binutils-2_21-branchpoint:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	binutils-2_20_1:1.3
	gdb_7_2-2010-09-02-release:1.3
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	gdb_7_2-branch:1.3.0.8
	gdb_7_2-2010-07-07-branchpoint:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	gdb_7_1-2010-03-18-release:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.6
	gdb_7_1-2010-02-18-branchpoint:1.3
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	gdb_7_0_1-2009-12-22-release:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	binutils-2_20:1.3
	gdb_7_0-2009-10-06-release:1.3
	sid-snapshot-20091001:1.3
	gdb_7_0-branch:1.3.0.4
	gdb_7_0-2009-09-16-branchpoint:1.3
	binutils-2_20-branch:1.3.0.2
	binutils-2_20-branchpoint:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.2
	msnyder-checkpoint-072509-branch:1.2.0.4
	msnyder-checkpoint-072509-branchpoint:1.2
	sid-snapshot-20090701:1.2
	dje-cgen-play1-branch:1.2.0.2
	dje-cgen-play1-branchpoint:1.2
	binutils_latest_snapshot:1.12;
locks; strict;
comment	@ * @;


1.12
date	2013.05.07.17.03.51;	author willnewton;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.07.17.01.12;	author willnewton;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.17.16.22.13;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.15.21.16.18;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.12.18.17.35;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.07.03.34.23;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.06.18.45.05;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.13.16.59.10;	author hjl;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2009.08.03.15.50.51;	author hjl;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.18.00.45.14;	author hjl;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.16.13.41.10;	author hjl;	state Exp;
branches;
next	;

1.4.2.1
date	2011.05.25.17.41.34;	author hjl;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bfd/elf-ifunc.c: Add header size arg to _bfd_elf_allocate_ifunc_dyn_relocs.

bfd/ChangeLog:

2013-05-07  Will Newton  <will.newton@@linaro.org>

	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Add a
	plt_header_size argument for ports where it differs from
	plt_entry_size.
	* elf-bfd.h: Likewise.
	* elf32-i386.c: Pass plt_header_size to
	_bfd_elf_allocate_ifunc_dyn_relocs.
	* elf64-x86-64.c: Likewise.
@
text
@/* ELF STT_GNU_IFUNC support.
   Copyright 2009-2013
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#define ARCH_SIZE 0
#include "elf-bfd.h"
#include "safe-ctype.h"
#include "libiberty.h"
#include "objalloc.h"

/* Create sections needed by STT_GNU_IFUNC symbol.  */

bfd_boolean
_bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_link_hash_table *htab = elf_hash_table (info);

  if (htab->irelifunc != NULL || htab->iplt != NULL)
    return TRUE;

  flags = bed->dynamic_sec_flags;
  pltflags = flags;
  if (bed->plt_not_loaded)
    /* We do not clear SEC_ALLOC here because we still want the OS to
       allocate space for the section; it's just that there's nothing
       to read in from the object file.  */
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  else
    pltflags |= SEC_ALLOC | SEC_CODE | SEC_LOAD;
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  if (info->shared)
    {
      /* We need to create .rel[a].ifunc for shared objects.  */
      const char *rel_sec = (bed->rela_plts_and_copies_p
			     ? ".rela.ifunc" : ".rel.ifunc");

      s = bfd_make_section_with_flags (abfd, rel_sec,
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  bed->s->log_file_align))
	return FALSE;
      htab->irelifunc = s;
    }
  else
    {
      /* We need to create .iplt, .rel[a].iplt, .igot and .igot.plt
	 for static executables.   */
      s = bfd_make_section_with_flags (abfd, ".iplt", pltflags);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
	return FALSE;
      htab->iplt = s;

      s = bfd_make_section_with_flags (abfd,
				       (bed->rela_plts_and_copies_p
					? ".rela.iplt" : ".rel.iplt"),
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  bed->s->log_file_align))
	return FALSE;
      htab->irelplt = s;

      /* We don't need the .igot section if we have the .igot.plt
	 section.  */
      if (bed->want_got_plt)
	s = bfd_make_section_with_flags (abfd, ".igot.plt", flags);
      else
	s = bfd_make_section_with_flags (abfd, ".igot", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s,
					 bed->s->log_file_align))
	return FALSE;
      htab->igotplt = s;
    }

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs against a STT_GNU_IFUNC symbol definition.  */

bfd_boolean
_bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h,
				    struct elf_dyn_relocs **head,
				    unsigned int plt_entry_size,
				    unsigned int plt_header_size,
				    unsigned int got_entry_size)
{
  asection *plt, *gotplt, *relplt;
  struct elf_dyn_relocs *p;
  unsigned int sizeof_reloc;
  const struct elf_backend_data *bed;
  struct elf_link_hash_table *htab;

  /* When a shared library references a STT_GNU_IFUNC symbol defined
     in executable, the address of the resolved function may be used.
     But in non-shared executable, the address of its .plt slot may
     be used.  Pointer equality may not work correctly.  PIE should
     be used if pointer equality is required here.  */
  if (!info->shared
      && (h->dynindx != -1
	  || info->export_dynamic)
      && h->pointer_equality_needed)
    {
      info->callbacks->einfo
	(_("%F%P: dynamic STT_GNU_IFUNC symbol `%s' with pointer "
	   "equality in `%B' can not be used when making an "
	   "executable; recompile with -fPIE and relink with -pie\n"),
	 h->root.root.string,
	 h->root.u.def.section->owner);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  htab = elf_hash_table (info);

  /* When building shared library, we need to handle the case where it is
     marked with regular reference, but not non-GOT reference since the
     non-GOT reference bit may not be set here.  */
  if (info->shared && !h->non_got_ref && h->ref_regular)
    for (p = *head; p != NULL; p = p->next)
      if (p->count)
	{
	  h->non_got_ref = 1;
	  goto keep;
	}

  /* Support garbage collection against STT_GNU_IFUNC symbols.  */
  if (h->plt.refcount <= 0 && h->got.refcount <= 0)
    {
      h->got = htab->init_got_offset;
      h->plt = htab->init_plt_offset;
      *head = NULL;
      return TRUE;
    }

  /* Return and discard space for dynamic relocations against it if
     it is never referenced in a non-shared object.  */
  if (!h->ref_regular)
    {
      if (h->plt.refcount > 0
	  || h->got.refcount > 0)
	abort ();
      h->got = htab->init_got_offset;
      h->plt = htab->init_plt_offset;
      *head = NULL;
      return TRUE;
    }

keep:
  bed = get_elf_backend_data (info->output_bfd);
  if (bed->rela_plts_and_copies_p)
    sizeof_reloc = bed->s->sizeof_rela;
  else
    sizeof_reloc = bed->s->sizeof_rel;

  /* When building a static executable, use .iplt, .igot.plt and
     .rel[a].iplt sections for STT_GNU_IFUNC symbols.  */
  if (htab->splt != NULL)
    {
      plt = htab->splt;
      gotplt = htab->sgotplt;
      relplt = htab->srelplt;

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (plt->size == 0)
	plt->size += plt_header_size;
    }
  else
    {
      plt = htab->iplt;
      gotplt = htab->igotplt;
      relplt = htab->irelplt;
    }

  /* Don't update value of STT_GNU_IFUNC symbol to PLT.  We need
     the original value for R_*_IRELATIVE.  */
  h->plt.offset = plt->size;

  /* Make room for this entry in the .plt/.iplt section.  */
  plt->size += plt_entry_size;

  /* We also need to make an entry in the .got.plt/.got.iplt section,
     which will be placed in the .got section by the linker script.  */
  gotplt->size += got_entry_size;

  /* We also need to make an entry in the .rel[a].plt/.rel[a].iplt
     section.  */
  relplt->size += sizeof_reloc;
  relplt->reloc_count++;

  /* We need dynamic relocation for STT_GNU_IFUNC symbol only when
     there is a non-GOT reference in a shared object.  */
  if (!info->shared
      || !h->non_got_ref)
    *head = NULL;

  /* Finally, allocate space.  */
  p = *head;
  if (p != NULL)
    {
      bfd_size_type count = 0;
      do
	{
	  count += p->count;
	  p = p->next;
	}
      while (p != NULL);
      htab->irelifunc->size += count * sizeof_reloc;
    }

  /* For STT_GNU_IFUNC symbol, .got.plt has the real function address
     and .got has the PLT entry adddress.  We will load the GOT entry
     with the PLT entry in finish_dynamic_symbol if it is used.  For
     branch, it uses .got.plt.  For symbol value,
     1. Use .got.plt in a shared object if it is forced local or not
     dynamic.
     2. Use .got.plt in a non-shared object if pointer equality isn't
     needed.
     3. Use .got.plt in PIE.
     4. Use .got.plt if .got isn't used.
     5. Otherwise use .got so that it can be shared among different
     objects at run-time.
     We only need to relocate .got entry in shared object.  */
  if (h->got.refcount <= 0
      || (info->shared
	  && (h->dynindx == -1
	      || h->forced_local))
      || (!info->shared
	  && !h->pointer_equality_needed)
      || (info->executable && info->shared)
      || htab->sgot == NULL)
    {
      /* Use .got.plt.  */
      h->got.offset = (bfd_vma) -1;
    }
  else
    {
      h->got.offset = htab->sgot->size;
      htab->sgot->size += got_entry_size;
      if (info->shared)
	htab->srelgot->size += sizeof_reloc;
    }

  return TRUE;
}
@


1.11
log
@bfd/elf-ifunc.c: Remove unused function _bfd_elf_create_ifunc_dyn_reloc.

bfd/ChangeLog:

2013-05-07  Will Newton  <will.newton@@linaro.org>

        * elf-ifunc.c (_bfd_elf_create_ifunc_dyn_reloc): Remove unused
	function.
	* elf-bfd.h: Likewise.
@
text
@d115 1
d197 1
a197 1
	plt->size += plt_entry_size;
@


1.10
log
@Update copyright year on elf-ifunc.c

	* elf-ifunc.c: Update copyright year.
@
text
@a106 45
/* For a STT_GNU_IFUNC symbol, create a dynamic reloc section, SRELOC,
   for the input section, SEC, and append this reloc to HEAD.  */

asection *
_bfd_elf_create_ifunc_dyn_reloc (bfd *abfd, struct bfd_link_info *info,
				 asection *sec, asection *sreloc,
				 struct elf_dyn_relocs **head)
{
  struct elf_dyn_relocs *p;
  struct elf_link_hash_table *htab = elf_hash_table (info);

  if (sreloc == NULL)
    {
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);

      if (htab->dynobj == NULL)
	htab->dynobj = abfd;

      sreloc = _bfd_elf_make_dynamic_reloc_section (sec, htab->dynobj,
						    bed->s->log_file_align,
						    abfd,
						    bed->rela_plts_and_copies_p);
      if (sreloc == NULL)
	return NULL;
    }

  p = *head;
  if (p == NULL || p->sec != sec)
    {
      bfd_size_type amt = sizeof *p;

      p = ((struct elf_dyn_relocs *) bfd_alloc (htab->dynobj, amt));
      if (p == NULL)
	return NULL;
      p->next = *head;
      *head = p;
      p->sec = sec;
      p->count = 0;
      p->pc_count = 0;
    }
  p->count += 1;

  return sreloc;
}

@


1.9
log
@Check regular reference without non-GOT reference

non_got_ref may not be set when building shared library. We need to set
non_got_ref if there are any non-PIC relocations.  But we only did this
when there were no PLT/GOT relocations.  It failed when there is a PLT
relocation.  This checkin moves the non_got_ref check out.

bfd/

2013-04-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/15371
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Check
	regular reference without non-GOT reference when building
	shared library.

ld/testsuite/

2013-04-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/15371
	* ld-ifunc/ifunc-20-i386.d: New file.
	* ld-ifunc/ifunc-20-x86-64.d: Likewise.
	* ld-ifunc/ifunc-20.s: Likewise.
diff --git a/bfd/elf-ifunc.c b/bfd/elf-ifunc.c
index e56427d..7e7ec36 100644
--- a/bfd/elf-ifunc.c
+++ b/bfd/elf-ifunc.c
@@@@ -187,23 +187,20 @@@@ _bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,

   htab = elf_hash_table (info);

+  /* When building shared library, we need to handle the case where it is
+     marked with regular reference, but not non-GOT reference since the
+     non-GOT reference bit may not be set here.  */
+  if (info->shared && !h->non_got_ref && h->ref_regular)
+    for (p = *head; p != NULL; p = p->next)
+      if (p->count)
+	{
+	  h->non_got_ref = 1;
+	  goto keep;
+	}
+
   /* Support garbage collection against STT_GNU_IFUNC symbols.  */
   if (h->plt.refcount <= 0 && h->got.refcount <= 0)
     {
-      /* When building shared library, we need to handle the case
-         where it is marked with regular reference, but not non-GOT
-	 reference.  It may happen if we didn't see STT_GNU_IFUNC
-	 symbol at the time when checking relocations.  */
-      if (info->shared
-	  && !h->non_got_ref
-	  && h->ref_regular)
-	for (p = *head; p != NULL; p = p->next)
-	  if (p->count)
-	    {
-	      h->non_got_ref = 1;
-	      goto keep;
-	    }
-
       h->got = htab->init_got_offset;
       h->plt = htab->init_plt_offset;
       *head = NULL;
diff --git a/ld/testsuite/ld-ifunc/ifunc-20-i386.d b/ld/testsuite/ld-ifunc/ifunc-20-i386.d
new file mode 100644
index 0000000..9373fcf
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-20-i386.d
@@@@ -0,0 +1,13 @@@@
+#source: ifunc-20.s
+#ld: -shared -m elf_i386 -z nocombreloc
+#as: --32
+#readelf: -r --wide
+#target: x86_64-*-* i?86-*-*
+
+Relocation section '.rel.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_32[ ]+ifunc\(\)[ ]+ifunc
+
+Relocation section '.rel.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc
diff --git a/ld/testsuite/ld-ifunc/ifunc-20-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-20-x86-64.d
new file mode 100644
index 0000000..39492d4
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-20-x86-64.d
@@@@ -0,0 +1,13 @@@@
+#source: ifunc-20.s
+#ld: -shared -m elf_x86_64 -z nocombreloc
+#as: --64
+#readelf: -r --wide
+#target: x86_64-*-*
+
+Relocation section '.rela.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_64[ ]+ifunc\(\)[ ]+ifunc \+ 0
+
+Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc \+ 0
diff --git a/ld/testsuite/ld-ifunc/ifunc-20.s b/ld/testsuite/ld-ifunc/ifunc-20.s
new file mode 100644
index 0000000..9d45455
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-20.s
@@@@ -0,0 +1,16 @@@@
+	.section .data.rel,"aw",@@progbits
+	.globl ifunc_ptrt
+	.type	ifunc_ptr, @@object
+ifunc_ptr:
+	.dc.a ifunc
+	.text
+	.type ifunc, @@gnu_indirect_function
+	.globl ifunc
+ifunc:
+	ret
+	.size	ifunc, .-ifunc
+	.type bar, @@function
+	.globl bar
+bar:
+	call	ifunc@@PLT
+	.size	bar, .-bar
@
text
@d2 1
a2 1
   Copyright 2009
@


1.8
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d190 11
a203 14
      /* When building shared library, we need to handle the case
         where it is marked with regular reference, but not non-GOT
	 reference.  It may happen if we didn't see STT_GNU_IFUNC
	 symbol at the time when checking relocations.  */
      if (info->shared
	  && !h->non_got_ref
	  && h->ref_regular)
	for (p = *head; p != NULL; p = p->next)
	  if (p->count)
	    {
	      h->non_got_ref = 1;
	      goto keep;
	    }

@


1.7
log
@Use .got.plt for IFUNC symbols if there are no GOT relocations.

bfd/

2011-09-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13178
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Use .got.plt
	if there are no GOT relocations.

ld/testsuite/

2011-09-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13178
	* ld-ifunc/ifunc-13-i386.d: Updated.
	* ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* ld-ifunc/ifunc-3a-x86.d: Likewise.
	* ld-x86-64/pr13082-5a.d: Likewise.

	* ld-ifunc/ifunc-15-i386.d: New.
	* ld-ifunc/ifunc-15-i386.s: Likewise.
	* ld-ifunc/ifunc-15-x86-64.d: Likewise.
	* ld-ifunc/ifunc-15-x86-64.s: Likewise.
@
text
@d128 1
a128 1
						    bed->rela_plts_and_copies_p); 
d132 1
a132 1
		      
d178 1
a178 1
      info->callbacks->einfo 
d254 1
a254 1
     the original value for R_*_IRELATIVE.  */  
@


1.6
log
@Optimize _bfd_elf_allocate_ifunc_dyn_relocs.

2011-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Optimized.
@
text
@d302 4
a305 3
  if ((info->shared
       && (h->dynindx == -1
	   || h->forced_local))
@


1.5
log
@Handle STT_GNU_IFUNC symols when building shared library.

bfd/

2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Properly
	handle symbols marked with regular reference, but not non-GOT
	reference when building shared library.

	* elf32-i386.c (elf_i386_gc_sweep_hook): Properly handle
	local and global STT_GNU_IFUNC symols when building shared
	library.
	* elf64-x86-64.c (elf_x86_64_gc_sweep_hook): Likewise.

ld/testsuite/

2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* ld-ifunc/ifunc-10-i386.s: Add more tests.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.

	* ld-ifunc/ifunc-12-i386.d: New.
	* ld-ifunc/ifunc-12-i386.s: Likewise.
	* ld-ifunc/ifunc-12-x86-64.d: Likewise.
	* ld-ifunc/ifunc-12-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13-i386.d: Likewise.
	* ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* ld-ifunc/ifunc-13a-i386.s: Likewise.
	* ld-ifunc/ifunc-13a-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13b-i386.s: Likewise.
	* ld-ifunc/ifunc-13b-x86-64.s: Likewise.
@
text
@a196 2
      bfd_size_type count = 0;

d200 6
a205 6
	{
	  for (p = *head; p != NULL; p = p->next)
	    count += p->count;
	  if (count != 0)
	    h->non_got_ref = 1;
	}
d207 4
a210 7
      if (count == 0)
	{
	  h->got = htab->init_got_offset;
	  h->plt = htab->init_plt_offset;
	  *head = NULL;
	  return TRUE;
	}
d226 1
d276 12
a287 2
  for (p = *head; p != NULL; p = p->next)
    htab->irelifunc->size += p->count * sizeof_reloc;
d289 1
a289 1
  /* For STT_GNU_IFUNC symbol, .got.plt has the real function addres
@


1.4
log
@Support garbage collection against STT_GNU_IFUNC symbols.

bfd/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11791
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Support
	garbage collection against STT_GNU_IFUNC symbols.

	* elf32-i386.c (elf_i386_get_local_sym_hash): Don't set
	elf.plt.offset/elf.got.offset to -1.
	(elf_i386_tls_transition): Skip TLS transition for functions.
	(elf_i386_gc_sweep_hook): Support STT_GNU_IFUNC symbols.

	* elf64-x86-64.c (elf64_x86_64_get_local_sym_hash): Don't set
	elf.plt.offset/elf.got.offset to -1.
	(elf64_x86_64_tls_transition): Skip TLS transition for functions.
	(elf64_x86_64_gc_sweep_hook): Support STT_GNU_IFUNC symbols.

ld/testsuite/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11791
	* ld-ifunc/ifunc-10-i386.d: New.
	* ld-ifunc/ifunc-10-i386.s: Likewise.
	* ld-ifunc/ifunc-10-x86-64.d: Likewise.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.d: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.d: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.
@
text
@d193 23
a215 4
      h->got = htab->init_got_offset;
      h->plt = htab->init_plt_offset;
      *head = NULL;
      return TRUE;
@


1.4.2.1
log
@Handle STT_GNU_IFUNC symols when building shared library.

bfd/

2012-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from mainline
	2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Properly
	handle symbols marked with regular reference, but not non-GOT
	reference when building shared library.

	* elf32-i386.c (elf_i386_gc_sweep_hook): Properly handle
	local and global STT_GNU_IFUNC symols when building shared
	library.
	* elf64-x86-64.c (elf_x86_64_gc_sweep_hook): Likewise.

ld/testsuite/

2012-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from mainline
	2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* ld-ifunc/ifunc-10-i386.s: Add more tests.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.

	* ld-ifunc/ifunc-12-i386.d: New.
	* ld-ifunc/ifunc-12-i386.s: Likewise.
	* ld-ifunc/ifunc-12-x86-64.d: Likewise.
	* ld-ifunc/ifunc-12-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13-i386.d: Likewise.
	* ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* ld-ifunc/ifunc-13a-i386.s: Likewise.
	* ld-ifunc/ifunc-13a-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13b-i386.s: Likewise.
	* ld-ifunc/ifunc-13b-x86-64.s: Likewise.
@
text
@d193 4
a196 23
      /* When building shared library, we need to handle the case
         where it is marked with regular reference, but not non-GOT
	 reference.  It may happen if we didn't see STT_GNU_IFUNC
	 symbol at the time when checking relocations.  */
      bfd_size_type count = 0;

      if (info->shared
	  && !h->non_got_ref
	  && h->ref_regular)
	{
	  for (p = *head; p != NULL; p = p->next)
	    count += p->count;
	  if (count != 0)
	    h->non_got_ref = 1;
	}

      if (count == 0)
	{
	  h->got = htab->init_got_offset;
	  h->plt = htab->init_plt_offset;
	  *head = NULL;
	  return TRUE;
	}
@


1.3
log
@2009-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10433
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Set got
	to htab->init_got_offset and plt to htab->init_plt_offset
	when discarding space for dynamic relocations.
@
text
@d190 9
@


1.2
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_allocate_ifunc_dyn_relocs): New.
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs): Use it.
	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Likewise.

2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_create_ifunc_dyn_reloc): New.
	* elf-ifunc.c (_bfd_elf_create_ifunc_dyn_reloc): Likewise.
	* elf32-i386.c (elf_i386_check_relocs): Use it.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.

2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_dyn_relocs): New.

	* elf32-i386.c (elf_i386_dyn_relocs): Removed.
	(elf_i386_link_hash_entry): Replace elf_i386_dyn_relocs with
	elf_dyn_relocs.
	(elf_i386_copy_indirect_symbol): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_gc_sweep_hook): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_readonly_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.

	* elf64-x86-64.c (elf64_x86_64_dyn_relocs): Removed.
	(elf64_x86_64_link_hash_entry): Replace elf64_x86_64_dyn_relocs
	with elf_dyn_relocs.
	(elf64_x86_64_copy_indirect_symbol): Updated.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_gc_sweep_hook): Likewise.
	(elf64_x86_64_adjust_dynamic_symbol): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_readonly_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
@
text
@d188 2
d197 2
a198 1
      h->got.offset = (bfd_vma) -1;
a208 2
  htab = elf_hash_table (info);

@


1.1
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in (elf): Add elf-ifunc.lo.

	* configure: Regenerated.
	* Makefile.in: Likewise.

	* elf-bfd.h (elf_link_hash_table): Add sgot, sgotplt,
	srelgot, splt, srelplt, igotplt, iplt, irelplt and irelifunc.

	* elf32-i386.c (elf_i386_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf_i386_link_hash_table_create): Likewise.
	(elf_i386_create_dynamic_sections): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(elf_i386_finish_dynamic_sections): Likewise.
	(elf_i386_create_got_section): Removed.

	* elf64-x86-64.c (elf64_x86_64_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf64_x86_64_compute_jump_table_size): Updated.
	(elf64_x86_64_link_hash_table_create): Likewise.
	(elf64_x86_64_create_dynamic_sections): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Likewise.
	(elf64_x86_64_create_got_section): Removed.

	* elflink.c (_bfd_elf_create_got_section): Use log_file_align
	for pointer alignment.  Set up section pointers.
	(_bfd_elf_create_dynamic_sections): Likewise.
	(_bfd_elf_create_ifunc_sections): Moved to ...
	* elf-ifunc.c: Here.  New.

	* Makefile.am (BFD32_BACKENDS): Add elf-ifunc.lo.
	(BFD32_BACKENDS_CFILES): Add elf-ifunc.c.
	Run "make dep-am".
@
text
@d106 182
@

