head	1.141;
access;
symbols
	sid-snapshot-20180601:1.141
	sid-snapshot-20180501:1.141
	sid-snapshot-20180401:1.141
	sid-snapshot-20180301:1.141
	sid-snapshot-20180201:1.141
	sid-snapshot-20180101:1.141
	sid-snapshot-20171201:1.141
	sid-snapshot-20171101:1.141
	sid-snapshot-20171001:1.141
	sid-snapshot-20170901:1.141
	sid-snapshot-20170801:1.141
	sid-snapshot-20170701:1.141
	sid-snapshot-20170601:1.141
	sid-snapshot-20170501:1.141
	sid-snapshot-20170401:1.141
	sid-snapshot-20170301:1.141
	sid-snapshot-20170201:1.141
	sid-snapshot-20170101:1.141
	sid-snapshot-20161201:1.141
	sid-snapshot-20161101:1.141
	sid-snapshot-20160901:1.141
	sid-snapshot-20160801:1.141
	sid-snapshot-20160701:1.141
	sid-snapshot-20160601:1.141
	sid-snapshot-20160501:1.141
	sid-snapshot-20160401:1.141
	sid-snapshot-20160301:1.141
	sid-snapshot-20160201:1.141
	sid-snapshot-20160101:1.141
	sid-snapshot-20151201:1.141
	sid-snapshot-20151101:1.141
	sid-snapshot-20151001:1.141
	sid-snapshot-20150901:1.141
	sid-snapshot-20150801:1.141
	sid-snapshot-20150701:1.141
	sid-snapshot-20150601:1.141
	sid-snapshot-20150501:1.141
	sid-snapshot-20150401:1.141
	sid-snapshot-20150301:1.141
	sid-snapshot-20150201:1.141
	sid-snapshot-20150101:1.141
	sid-snapshot-20141201:1.141
	sid-snapshot-20141101:1.141
	sid-snapshot-20141001:1.141
	sid-snapshot-20140901:1.141
	sid-snapshot-20140801:1.141
	sid-snapshot-20140701:1.141
	sid-snapshot-20140601:1.141
	sid-snapshot-20140501:1.141
	sid-snapshot-20140401:1.141
	sid-snapshot-20140301:1.141
	sid-snapshot-20140201:1.141
	sid-snapshot-20140101:1.141
	sid-snapshot-20131201:1.141
	sid-snapshot-20131101:1.141
	sid-snapshot-20131001:1.141
	binutils-2_24-branch:1.141.0.2
	binutils-2_24-branchpoint:1.141
	binutils-2_21_1:1.128
	sid-snapshot-20130901:1.141
	gdb_7_6_1-2013-08-30-release:1.139
	sid-snapshot-20130801:1.141
	sid-snapshot-20130701:1.141
	sid-snapshot-20130601:1.141
	sid-snapshot-20130501:1.141
	gdb_7_6-2013-04-26-release:1.139
	sid-snapshot-20130401:1.141
	binutils-2_23_2:1.134
	gdb_7_6-branch:1.139.0.2
	gdb_7_6-2013-03-12-branchpoint:1.139
	sid-snapshot-20130301:1.139
	sid-snapshot-20130201:1.137
	sid-snapshot-20130101:1.136
	sid-snapshot-20121201:1.136
	gdb_7_5_1-2012-11-29-release:1.134
	binutils-2_23_1:1.134
	sid-snapshot-20121101:1.136
	binutils-2_23:1.134
	sid-snapshot-20121001:1.135
	sid-snapshot-20120901:1.134
	gdb_7_5-2012-08-17-release:1.134
	sid-snapshot-20120801:1.134
	binutils-2_23-branch:1.134.0.4
	binutils-2_23-branchpoint:1.134
	gdb_7_5-branch:1.134.0.2
	gdb_7_5-2012-07-18-branchpoint:1.134
	sid-snapshot-20120701:1.134
	sid-snapshot-20120601:1.133
	sid-snapshot-20120501:1.132
	binutils-2_22_branch:1.130.0.4
	gdb_7_4_1-2012-04-26-release:1.131
	sid-snapshot-20120401:1.131
	sid-snapshot-20120301:1.131
	sid-snapshot-20120201:1.131
	gdb_7_4-2012-01-24-release:1.131
	sid-snapshot-20120101:1.131
	gdb_7_4-branch:1.131.0.2
	gdb_7_4-2011-12-13-branchpoint:1.131
	sid-snapshot-20111201:1.131
	binutils-2_22:1.130
	sid-snapshot-20111101:1.131
	sid-snapshot-20111001:1.130
	binutils-2_22-branch:1.130.0.2
	binutils-2_22-branchpoint:1.130
	gdb_7_3_1-2011-09-04-release:1.128
	sid-snapshot-20110901:1.130
	sid-snapshot-20110801:1.130
	gdb_7_3-2011-07-26-release:1.128
	sid-snapshot-20110701:1.130
	sid-snapshot-20110601:1.128
	sid-snapshot-20110501:1.128
	gdb_7_3-branch:1.128.0.4
	gdb_7_3-2011-04-01-branchpoint:1.128
	sid-snapshot-20110401:1.128
	sid-snapshot-20110301:1.128
	sid-snapshot-20110201:1.128
	sid-snapshot-20110101:1.128
	binutils-2_21:1.128
	sid-snapshot-20101201:1.128
	binutils-2_21-branch:1.128.0.2
	binutils-2_21-branchpoint:1.128
	sid-snapshot-20101101:1.128
	sid-snapshot-20101001:1.126
	binutils-2_20_1:1.117.2.1
	gdb_7_2-2010-09-02-release:1.123
	sid-snapshot-20100901:1.125
	sid-snapshot-20100801:1.123
	gdb_7_2-branch:1.123.0.2
	gdb_7_2-2010-07-07-branchpoint:1.123
	sid-snapshot-20100701:1.123
	sid-snapshot-20100601:1.122
	sid-snapshot-20100501:1.121
	sid-snapshot-20100401:1.121
	gdb_7_1-2010-03-18-release:1.121
	sid-snapshot-20100301:1.121
	gdb_7_1-branch:1.121.0.2
	gdb_7_1-2010-02-18-branchpoint:1.121
	sid-snapshot-20100201:1.119
	sid-snapshot-20100101:1.119
	gdb_7_0_1-2009-12-22-release:1.118
	sid-snapshot-20091201:1.118
	sid-snapshot-20091101:1.118
	binutils-2_20:1.117.2.1
	gdb_7_0-2009-10-06-release:1.118
	sid-snapshot-20091001:1.118
	gdb_7_0-branch:1.118.0.2
	gdb_7_0-2009-09-16-branchpoint:1.118
	arc-sim-20090309:1.108
	binutils-arc-20081103-branch:1.112.0.10
	binutils-arc-20081103-branchpoint:1.112
	binutils-2_20-branch:1.117.0.2
	binutils-2_20-branchpoint:1.117
	sid-snapshot-20090901:1.116
	sid-snapshot-20090801:1.116
	msnyder-checkpoint-072509-branch:1.116.0.4
	msnyder-checkpoint-072509-branchpoint:1.116
	sid-snapshot-20090701:1.116
	dje-cgen-play1-branch:1.116.0.2
	dje-cgen-play1-branchpoint:1.116
	sid-snapshot-20090601:1.115
	sid-snapshot-20090501:1.114
	sid-snapshot-20090401:1.113
	arc-20081103-branch:1.112.0.8
	arc-20081103-branchpoint:1.112
	arc-insight_6_8-branch:1.108.0.6
	arc-insight_6_8-branchpoint:1.108
	insight_6_8-branch:1.108.0.4
	insight_6_8-branchpoint:1.108
	sid-snapshot-20090301:1.113
	binutils-2_19_1:1.111.2.1
	sid-snapshot-20090201:1.112
	sid-snapshot-20090101:1.112
	reverse-20081226-branch:1.112.0.6
	reverse-20081226-branchpoint:1.112
	sid-snapshot-20081201:1.112
	multiprocess-20081120-branch:1.112.0.4
	multiprocess-20081120-branchpoint:1.112
	sid-snapshot-20081101:1.112
	binutils-2_19:1.111.2.1
	sid-snapshot-20081001:1.112
	reverse-20080930-branch:1.112.0.2
	reverse-20080930-branchpoint:1.112
	binutils-2_19-branch:1.111.0.2
	binutils-2_19-branchpoint:1.111
	sid-snapshot-20080901:1.111
	sid-snapshot-20080801:1.110
	reverse-20080717-branch:1.110.0.4
	reverse-20080717-branchpoint:1.110
	sid-snapshot-20080701:1.110
	msnyder-reverse-20080609-branch:1.110.0.2
	msnyder-reverse-20080609-branchpoint:1.110
	drow-reverse-20070409-branch:1.83.0.2
	drow-reverse-20070409-branchpoint:1.83
	sid-snapshot-20080601:1.110
	sid-snapshot-20080501:1.109
	sid-snapshot-20080403:1.109
	sid-snapshot-20080401:1.109
	gdb_6_8-2008-03-27-release:1.108
	sid-snapshot-20080301:1.108
	gdb_6_8-branch:1.108.0.2
	gdb_6_8-2008-02-26-branchpoint:1.108
	sid-snapshot-20080201:1.106
	sid-snapshot-20080101:1.105
	sid-snapshot-20071201:1.101
	sid-snapshot-20071101:1.101
	gdb_6_7_1-2007-10-29-release:1.94
	gdb_6_7-2007-10-10-release:1.94
	sid-snapshot-20071001:1.95
	gdb_6_7-branch:1.94.0.2
	gdb_6_7-2007-09-07-branchpoint:1.94
	binutils-2_18:1.93.2.1
	binutils-2_18-branch:1.93.0.2
	binutils-2_18-branchpoint:1.93
	insight_6_6-20070208-release:1.75
	binutils-csl-coldfire-4_1-32:1.62.4.1
	binutils-csl-sourcerygxx-4_1-32:1.62.4.1
	gdb_6_6-2006-12-18-release:1.75
	binutils-csl-innovasic-fido-3_4_4-33:1.62.4.1
	binutils-csl-sourcerygxx-3_4_4-32:1.42.2.1
	binutils-csl-coldfire-4_1-30:1.62.4.1
	binutils-csl-sourcerygxx-4_1-30:1.62.4.1
	binutils-csl-coldfire-4_1-28:1.62.4.1
	binutils-csl-sourcerygxx-4_1-29:1.62.4.1
	binutils-csl-sourcerygxx-4_1-28:1.62.4.1
	gdb_6_6-branch:1.75.0.2
	gdb_6_6-2006-11-15-branchpoint:1.75
	binutils-csl-arm-2006q3-27:1.62.4.1
	binutils-csl-sourcerygxx-4_1-27:1.62.4.1
	binutils-csl-arm-2006q3-26:1.62.4.1
	binutils-csl-sourcerygxx-4_1-26:1.62.4.1
	binutils-csl-sourcerygxx-4_1-25:1.62.4.1
	binutils-csl-sourcerygxx-4_1-24:1.62.4.1
	binutils-csl-sourcerygxx-4_1-23:1.62.4.1
	insight_6_5-20061003-release:1.65
	gdb-csl-symbian-6_4_50_20060226-12:1.61
	binutils-csl-sourcerygxx-4_1-21:1.62.4.1
	binutils-csl-arm-2006q3-21:1.62.4.1
	binutils-csl-sourcerygxx-4_1-22:1.62.4.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.62.4.1
	binutils-csl-sourcerygxx-4_1-20:1.62.4.1
	binutils-csl-arm-2006q3-19:1.62.4.1
	binutils-csl-sourcerygxx-4_1-19:1.62.4.1
	binutils-csl-sourcerygxx-4_1-18:1.62.4.1
	binutils-csl-renesas-4_1-9:1.62.4.1
	gdb-csl-sourcerygxx-3_4_4-25:1.60
	binutils-csl-sourcerygxx-3_4_4-25:1.42.2.1
	nickrob-async-20060828-mergepoint:1.68
	gdb-csl-symbian-6_4_50_20060226-11:1.61
	binutils-csl-renesas-4_1-8:1.62
	binutils-csl-renesas-4_1-7:1.62
	binutils-csl-renesas-4_1-6:1.62
	gdb-csl-sourcerygxx-4_1-17:1.61
	binutils-csl-sourcerygxx-4_1-17:1.62
	gdb-csl-20060226-branch-local-2:1.61
	gdb-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-14:1.62
	binutils-csl-sourcerygxx-4_1-15:1.62
	gdb-csl-sourcerygxx-4_1-13:1.61
	binutils-csl-sourcerygxx-4_1-13:1.62
	binutils-2_17:1.64
	gdb-csl-sourcerygxx-4_1-12:1.61
	binutils-csl-sourcerygxx-4_1-12:1.62
	gdb-csl-sourcerygxx-3_4_4-21:1.61
	binutils-csl-sourcerygxx-3_4_4-21:1.62
	gdb_6_5-20060621-release:1.65
	binutils-csl-wrs-linux-3_4_4-24:1.42
	binutils-csl-wrs-linux-3_4_4-23:1.42
	gdb-csl-sourcerygxx-4_1-9:1.61
	binutils-csl-sourcerygxx-4_1-9:1.62
	gdb-csl-sourcerygxx-4_1-8:1.61
	binutils-csl-sourcerygxx-4_1-8:1.62
	gdb-csl-sourcerygxx-4_1-7:1.61
	binutils-csl-sourcerygxx-4_1-7:1.62
	gdb-csl-arm-2006q1-6:1.61
	binutils-csl-arm-2006q1-6:1.62
	gdb-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-sourcerygxx-4_1-6:1.62
	binutils-csl-wrs-linux-3_4_4-22:1.42
	gdb-csl-symbian-6_4_50_20060226-10:1.61
	gdb-csl-symbian-6_4_50_20060226-9:1.61
	gdb-csl-symbian-6_4_50_20060226-8:1.61
	gdb-csl-coldfire-4_1-11:1.61
	binutils-csl-coldfire-4_1-11:1.62
	gdb-csl-sourcerygxx-3_4_4-19:1.61
	binutils-csl-sourcerygxx-3_4_4-19:1.62
	gdb-csl-coldfire-4_1-10:1.61
	gdb_6_5-branch:1.65.0.4
	gdb_6_5-2006-05-14-branchpoint:1.65
	binutils-csl-coldfire-4_1-10:1.62
	gdb-csl-sourcerygxx-4_1-5:1.61
	binutils-csl-sourcerygxx-4_1-5:1.62
	nickrob-async-20060513-branch:1.65.0.2
	nickrob-async-20060513-branchpoint:1.65
	gdb-csl-sourcerygxx-4_1-4:1.61
	binutils-csl-sourcerygxx-4_1-4:1.62
	msnyder-reverse-20060502-branch:1.64.0.6
	msnyder-reverse-20060502-branchpoint:1.64
	binutils-csl-wrs-linux-3_4_4-21:1.42
	gdb-csl-morpho-4_1-4:1.61
	binutils-csl-morpho-4_1-4:1.62
	gdb-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-sourcerygxx-3_4_4-17:1.62
	binutils-csl-wrs-linux-3_4_4-20:1.42
	readline_5_1-import-branch:1.64.0.4
	readline_5_1-import-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.61
	binutils-2_17-branch:1.64.0.2
	binutils-2_17-branchpoint:1.64
	gdb-csl-symbian-20060226-branch:1.61.0.4
	gdb-csl-symbian-20060226-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.61
	msnyder-reverse-20060331-branch:1.63.0.2
	msnyder-reverse-20060331-branchpoint:1.63
	binutils-csl-2_17-branch:1.62.0.4
	binutils-csl-2_17-branchpoint:1.62
	gdb-csl-available-20060303-branch:1.62.0.2
	gdb-csl-available-20060303-branchpoint:1.62
	gdb-csl-20060226-branch:1.61.0.2
	gdb-csl-20060226-branchpoint:1.61
	gdb_6_4-20051202-release:1.60
	msnyder-fork-checkpoint-branch:1.60.0.8
	msnyder-fork-checkpoint-branchpoint:1.60
	gdb-csl-gxxpro-6_3-branch:1.60.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.60
	gdb_6_4-branch:1.60.0.4
	gdb_6_4-2005-11-01-branchpoint:1.60
	gdb-csl-arm-20051020-branch:1.60.0.2
	gdb-csl-arm-20051020-branchpoint:1.60
	binutils-csl-gxxpro-3_4-branch:1.42.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.42.2.1
	binutils-2_16_1:1.42.2.1
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.42
	binutils-csl-arm-2005q1b:1.42
	binutils-2_16:1.42
	gdb-csl-arm-20050325-2005-q1a:1.42
	binutils-csl-arm-2005q1a:1.42
	csl-arm-20050325-branch:1.42.0.6
	csl-arm-20050325-branchpoint:1.42
	binutils-csl-arm-2005q1-branch:1.42.0.4
	binutils-csl-arm-2005q1-branchpoint:1.42
	binutils-2_16-branch:1.42.0.2
	binutils-2_16-branchpoint:1.42
	csl-arm-2004-q3d:1.38
	gdb_6_3-20041109-release:1.37
	gdb_6_3-branch:1.37.0.2
	gdb_6_3-20041019-branchpoint:1.37
	csl-arm-2004-q3:1.34
	drow_intercu-merge-20040921:1.34
	drow_intercu-merge-20040915:1.32
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.20
	binutils-2_15:1.20.8.4
	binutils-2_15-branchpoint:1.20
	csl-arm-2004-q1a:1.26
	csl-arm-2004-q1:1.24
	gdb_6_1-2004-04-05-release:1.20
	drow_intercu-merge-20040402:1.24
	drow_intercu-merge-20040327:1.23
	ezannoni_pie-20040323-branch:1.22.0.2
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.20
	cagney_tramp-20040309-branch:1.20.0.14
	cagney_tramp-20040309-branchpoint:1.20
	gdb_6_1-branch:1.20.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.20
	drow_intercu-20040221-branch:1.20.0.10
	drow_intercu-20040221-branchpoint:1.20
	binutils-2_15-branch:1.20.0.8
	cagney_bfdfile-20040213-branch:1.20.0.6
	cagney_bfdfile-20040213-branchpoint:1.20
	drow-cplus-merge-20040208:1.20
	carlton_dictionary-20040126-merge:1.20
	cagney_bigcore-20040122-branch:1.20.0.4
	cagney_bigcore-20040122-branchpoint:1.20
	drow-cplus-merge-20040113:1.20
	csl-arm-2003-q4:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-branch:1.20.0.2
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.17
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.11.0.6
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.4
	cagney_x86i386-20030821-branch:1.11.0.2
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.3.0.14
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.3
	binutils-2_14:1.2
	cagney_convert-20030606-branch:1.3.0.10
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.8
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.4
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	binutils-2_14-branch:1.2.0.6
	binutils-2_14-branchpoint:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.4
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-branch:1.2.0.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.1.0.4
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.2
	binutils_latest_snapshot:1.141;
locks; strict;
comment	@ * @;


1.141
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2012.10.16.01.42.42;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2012.06.29.14.46.01;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.132;

1.132
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2011.10.19.07.17.18;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.13.00.59.11;	author amodra;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2011.06.02.13.43.14;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.127;

1.127
date	2010.10.08.14.00.47;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.125;

1.125
date	2010.08.25.14.53.44;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.123;

1.123
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2010.05.28.18.10.45;	author sterling;	state Exp;
branches;
next	1.121;

1.121
date	2010.02.08.13.16.24;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2010.02.04.09.16.40;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2009.09.09.01.38.40;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2009.06.17.18.08.35;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.114;

1.114
date	2009.04.03.16.06.40;	author sterling;	state Exp;
branches;
next	1.113;

1.113
date	2009.02.24.22.51.10;	author sterling;	state Exp;
branches;
next	1.112;

1.112
date	2008.09.18.00.37.47;	author bwilson;	state Exp;
branches;
next	1.111;

1.111
date	2008.08.20.23.28.58;	author bwilson;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2008.05.07.23.13.08;	author bwilson;	state Exp;
branches;
next	1.109;

1.109
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.04.23.13.24;	author bwilson;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.105;

1.105
date	2007.12.21.23.11.28;	author bwilson;	state Exp;
branches;
next	1.104;

1.104
date	2007.12.12.21.11.10;	author bwilson;	state Exp;
branches;
next	1.103;

1.103
date	2007.12.07.22.52.09;	author bwilson;	state Exp;
branches;
next	1.102;

1.102
date	2007.12.04.22.41.59;	author bwilson;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.17.00.30.31;	author bwilson;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.16.23.57.24;	author bwilson;	state Exp;
branches;
next	1.99;

1.99
date	2007.10.05.19.05.35;	author bwilson;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.05.18.18.23;	author bwilson;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.05.18.09.57;	author bwilson;	state Exp;
branches;
next	1.96;

1.96
date	2007.10.04.17.15.29;	author bwilson;	state Exp;
branches;
next	1.95;

1.95
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.94;

1.94
date	2007.08.28.18.43.03;	author bwilson;	state Exp;
branches;
next	1.93;

1.93
date	2007.07.18.21.06.06;	author bwilson;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2007.07.18.18.23.47;	author bwilson;	state Exp;
branches;
next	1.91;

1.91
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.11.16.53.07;	author bwilson;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.27.20.10.47;	author bwilson;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.27.19.57.40;	author bwilson;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.27.18.28.22;	author bwilson;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2007.04.12.18.55.29;	author bwilson;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.12.15.52.02;	author bwilson;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2007.03.01.23.38.03;	author bwilson;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.05.17.42.38;	author bwilson;	state Exp;
branches;
next	1.79;

1.79
date	2007.02.05.17.18.39;	author bwilson;	state Exp;
branches;
next	1.78;

1.78
date	2007.02.03.06.34.22;	author bwilson;	state Exp;
branches;
next	1.77;

1.77
date	2007.02.03.06.25.00;	author bwilson;	state Exp;
branches;
next	1.76;

1.76
date	2006.11.27.20.14.52;	author bwilson;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2006.10.12.21.56.18;	author bwilson;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.11.22.16.50;	author bwilson;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.10.20.57.36;	author bwilson;	state Exp;
branches;
next	1.70;

1.70
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2006.08.25.00.08.54;	author bwilson;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.26.12.32.27;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.15.17.03.15;	author bwilson;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.14.23.01.19;	author bwilson;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.22.21.46.16;	author bwilson;	state Exp;
branches;
next	1.62;

1.62
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches
	1.62.4.1;
next	1.61;

1.61
date	2005.12.20.01.30.11;	author bwilson;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.03.21.49.17;	author bwilson;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.25.02.32.10;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.15.18.17.12;	author bwilson;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.15.20.43.37;	author bwilson;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.12.11.53.56;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.08.06.20.01;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.08.05.44.53;	author bje;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.08.00.26.45;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.07.19.27.22;	author wilson;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.20.19.53.18;	author bwilson;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.14.00.26.06;	author bwilson;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.07.13.22.51;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.05.14.33.54;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.04.15.53.23;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.04.11.00.16;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2005.01.11.09.32.51;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.19.00.28.58;	author bwilson;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.11.23.09.24;	author bwilson;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.21.16.29.11;	author bwilson;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.12.23.05.30;	author bwilson;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.12.18.33.12;	author bwilson;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.08.00.22.10;	author bwilson;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.29.22.03.33;	author bwilson;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.29.21.03.13;	author bwilson;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.29.13.46.33;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.17.20.33.33;	author bwilson;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.27.21.28.16;	author bwilson;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.21.18.12.47;	author bwilson;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.25.12.48.37;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.23.01.36.59;	author bwilson;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches
	1.20.2.1
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.17.21.31.11;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.11.13.32.38;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.15.25.54;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.14.22.28.27;	author bwilson;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.23.20.23.55;	author bwilson;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.24.00.24.00;	author bwilson;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.24.00.13.42;	author bwilson;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.18.21.09.28;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.10.19.01.47;	author bwilson;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.06.40.25;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.09.02.27.04;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.10.19.19.02;	author bwilson;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2003.04.01.15.50.27;	author nickc;	state Exp;
branches
	1.1.2.1;
next	;

1.130.2.1
date	2012.05.11.12.24.28;	author nickc;	state Exp;
branches;
next	;

1.117.2.1
date	2009.09.09.01.44.15;	author amodra;	state Exp;
branches;
next	;

1.111.2.1
date	2008.09.18.00.48.59;	author bwilson;	state Exp;
branches;
next	;

1.93.2.1
date	2007.08.28.19.03.01;	author bwilson;	state Exp;
branches;
next	;

1.62.4.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.42.2.1
date	2005.05.14.00.29.48;	author bwilson;	state Exp;
branches;
next	;

1.20.2.1
date	2003.12.14.20.26.42;	author drow;	state Exp;
branches;
next	;

1.20.8.1
date	2004.03.23.01.42.47;	author bwilson;	state Exp;
branches;
next	1.20.8.2;

1.20.8.2
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	1.20.8.3;

1.20.8.3
date	2004.04.21.18.21.08;	author bwilson;	state Exp;
branches;
next	1.20.8.4;

1.20.8.4
date	2004.04.27.21.29.43;	author bwilson;	state Exp;
branches;
next	;

1.20.10.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.20.10.2;

1.20.10.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.20.10.3;

1.20.10.3
date	2004.09.16.17.00.28;	author drow;	state Exp;
branches;
next	1.20.10.4;

1.20.10.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.2.2.1
date	2003.04.16.19.56.44;	author carlton;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.05.23.18.40.25;	author carlton;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.06.27.21.49.19;	author carlton;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.08.05.17.12.49;	author carlton;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.09.17.21.27.53;	author carlton;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.11.11.23.50.22;	author carlton;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.12.15.23.59.33;	author carlton;	state Exp;
branches;
next	;

1.2.4.1
date	2003.05.18.09.43.44;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	2003.04.10.21.33.45;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.141
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* Xtensa-specific support for 32-bit ELF.
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"

#include <stdarg.h>
#include <strings.h>

#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/xtensa.h"
#include "xtensa-isa.h"
#include "xtensa-config.h"

#define XTENSA_NO_NOP_REMOVAL 0

/* Local helper functions.  */

static bfd_boolean add_extra_plt_sections (struct bfd_link_info *, int);
static char *vsprint_msg (const char *, const char *, int, ...) ATTRIBUTE_PRINTF(2,4);
static bfd_reloc_status_type bfd_elf_xtensa_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean do_fix_for_relocatable_link
  (Elf_Internal_Rela *, bfd *, asection *, bfd_byte *);
static void do_fix_for_final_link
  (Elf_Internal_Rela *, bfd *, asection *, bfd_byte *, bfd_vma *);

/* Local functions to handle Xtensa configurability.  */

static bfd_boolean is_indirect_call_opcode (xtensa_opcode);
static bfd_boolean is_direct_call_opcode (xtensa_opcode);
static bfd_boolean is_windowed_call_opcode (xtensa_opcode);
static xtensa_opcode get_const16_opcode (void);
static xtensa_opcode get_l32r_opcode (void);
static bfd_vma l32r_offset (bfd_vma, bfd_vma);
static int get_relocation_opnd (xtensa_opcode, int);
static int get_relocation_slot (int);
static xtensa_opcode get_relocation_opcode
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *);
static bfd_boolean is_l32r_relocation
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *);
static bfd_boolean is_alt_relocation (int);
static bfd_boolean is_operand_relocation (int);
static bfd_size_type insn_decode_len
  (bfd_byte *, bfd_size_type, bfd_size_type);
static xtensa_opcode insn_decode_opcode
  (bfd_byte *, bfd_size_type, bfd_size_type, int);
static bfd_boolean check_branch_target_aligned
  (bfd_byte *, bfd_size_type, bfd_vma, bfd_vma);
static bfd_boolean check_loop_aligned
  (bfd_byte *, bfd_size_type, bfd_vma, bfd_vma);
static bfd_boolean check_branch_target_aligned_address (bfd_vma, int);
static bfd_size_type get_asm_simplify_size
  (bfd_byte *, bfd_size_type, bfd_size_type);

/* Functions for link-time code simplifications.  */

static bfd_reloc_status_type elf_xtensa_do_asm_simplify
  (bfd_byte *, bfd_vma, bfd_vma, char **);
static bfd_reloc_status_type contract_asm_expansion
  (bfd_byte *, bfd_vma, Elf_Internal_Rela *, char **);
static xtensa_opcode swap_callx_for_call_opcode (xtensa_opcode);
static xtensa_opcode get_expanded_call_opcode (bfd_byte *, int, bfd_boolean *);

/* Access to internal relocations, section contents and symbols.  */

static Elf_Internal_Rela *retrieve_internal_relocs
  (bfd *, asection *, bfd_boolean);
static void pin_internal_relocs (asection *, Elf_Internal_Rela *);
static void release_internal_relocs (asection *, Elf_Internal_Rela *);
static bfd_byte *retrieve_contents (bfd *, asection *, bfd_boolean);
static void pin_contents (asection *, bfd_byte *);
static void release_contents (asection *, bfd_byte *);
static Elf_Internal_Sym *retrieve_local_syms (bfd *);

/* Miscellaneous utility functions.  */

static asection *elf_xtensa_get_plt_section (struct bfd_link_info *, int);
static asection *elf_xtensa_get_gotplt_section (struct bfd_link_info *, int);
static asection *get_elf_r_symndx_section (bfd *, unsigned long);
static struct elf_link_hash_entry *get_elf_r_symndx_hash_entry
  (bfd *, unsigned long);
static bfd_vma get_elf_r_symndx_offset (bfd *, unsigned long);
static bfd_boolean is_reloc_sym_weak (bfd *, Elf_Internal_Rela *);
static bfd_boolean pcrel_reloc_fits (xtensa_opcode, int, bfd_vma, bfd_vma);
static bfd_boolean xtensa_is_property_section (asection *);
static bfd_boolean xtensa_is_insntable_section (asection *);
static bfd_boolean xtensa_is_littable_section (asection *);
static bfd_boolean xtensa_is_proptable_section (asection *);
static int internal_reloc_compare (const void *, const void *);
static int internal_reloc_matches (const void *, const void *);
static asection *xtensa_get_property_section (asection *, const char *);
extern asection *xtensa_make_property_section (asection *, const char *);
static flagword xtensa_get_property_predef_flags (asection *);

/* Other functions called directly by the linker.  */

typedef void (*deps_callback_t)
  (asection *, bfd_vma, asection *, bfd_vma, void *);
extern bfd_boolean xtensa_callback_required_dependence
  (bfd *, asection *, struct bfd_link_info *, deps_callback_t, void *);


/* Globally visible flag for choosing size optimization of NOP removal
   instead of branch-target-aware minimization for NOP removal.
   When nonzero, narrow all instructions and remove all NOPs possible
   around longcall expansions.  */

int elf32xtensa_size_opt;


/* The "new_section_hook" is used to set up a per-section
   "xtensa_relax_info" data structure with additional information used
   during relaxation.  */

typedef struct xtensa_relax_info_struct xtensa_relax_info;


/* The GNU tools do not easily allow extending interfaces to pass around
   the pointer to the Xtensa ISA information, so instead we add a global
   variable here (in BFD) that can be used by any of the tools that need
   this information. */

xtensa_isa xtensa_default_isa;


/* When this is true, relocations may have been modified to refer to
   symbols from other input files.  The per-section list of "fix"
   records needs to be checked when resolving relocations.  */

static bfd_boolean relaxing_section = FALSE;

/* When this is true, during final links, literals that cannot be
   coalesced and their relocations may be moved to other sections.  */

int elf32xtensa_no_literal_movement = 1;

/* Rename one of the generic section flags to better document how it
   is used here.  */
/* Whether relocations have been processed.  */
#define reloc_done sec_flg0

static reloc_howto_type elf_howto_table[] =
{
  HOWTO (R_XTENSA_NONE, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_NONE",
	 FALSE, 0, 0, FALSE),
  HOWTO (R_XTENSA_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_32",
	 TRUE, 0xffffffff, 0xffffffff, FALSE),

  /* Replace a 32-bit value with a value from the runtime linker (only
     used by linker-generated stub functions).  The r_addend value is
     special: 1 means to substitute a pointer to the runtime linker's
     dynamic resolver function; 2 means to substitute the link map for
     the shared object.  */
  HOWTO (R_XTENSA_RTLD, 0, 2, 32, FALSE, 0, complain_overflow_dont,
	 NULL, "R_XTENSA_RTLD", FALSE, 0, 0, FALSE),

  HOWTO (R_XTENSA_GLOB_DAT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_generic_reloc, "R_XTENSA_GLOB_DAT",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_JMP_SLOT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_generic_reloc, "R_XTENSA_JMP_SLOT",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_RELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_generic_reloc, "R_XTENSA_RELATIVE",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_PLT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_PLT",
	 FALSE, 0, 0xffffffff, FALSE),

  EMPTY_HOWTO (7),

  /* Old relocations for backward compatibility.  */
  HOWTO (R_XTENSA_OP0, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP0", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_OP1, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP1", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_OP2, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP2", FALSE, 0, 0, TRUE),

  /* Assembly auto-expansion.  */
  HOWTO (R_XTENSA_ASM_EXPAND, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_ASM_EXPAND", FALSE, 0, 0, TRUE),
  /* Relax assembly auto-expansion.  */
  HOWTO (R_XTENSA_ASM_SIMPLIFY, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_ASM_SIMPLIFY", FALSE, 0, 0, TRUE),

  EMPTY_HOWTO (13),

  HOWTO (R_XTENSA_32_PCREL, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_32_PCREL",
	 FALSE, 0, 0xffffffff, TRUE),

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_XTENSA_GNU_VTINHERIT, 0, 2, 0, FALSE, 0, complain_overflow_dont,
         NULL, "R_XTENSA_GNU_VTINHERIT",
	 FALSE, 0, 0, FALSE),
  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_XTENSA_GNU_VTENTRY, 0, 2, 0, FALSE, 0, complain_overflow_dont,
         _bfd_elf_rel_vtable_reloc_fn, "R_XTENSA_GNU_VTENTRY",
	 FALSE, 0, 0, FALSE),

  /* Relocations for supporting difference of symbols.  */
  HOWTO (R_XTENSA_DIFF8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF8", FALSE, 0, 0xff, FALSE),
  HOWTO (R_XTENSA_DIFF16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF16", FALSE, 0, 0xffff, FALSE),
  HOWTO (R_XTENSA_DIFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF32", FALSE, 0, 0xffffffff, FALSE),

  /* General immediate operand relocations.  */
  HOWTO (R_XTENSA_SLOT0_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT0_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT1_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT1_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT2_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT2_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT3_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT3_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT4_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT4_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT5_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT5_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT6_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT6_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT7_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT7_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT8_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT8_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT9_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT9_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT10_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT10_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT11_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT11_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT12_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT12_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT13_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT13_OP", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT14_OP, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT14_OP", FALSE, 0, 0, TRUE),

  /* "Alternate" relocations.  The meaning of these is opcode-specific.  */
  HOWTO (R_XTENSA_SLOT0_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT0_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT1_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT1_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT2_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT2_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT3_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT3_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT4_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT4_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT5_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT5_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT6_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT6_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT7_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT7_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT8_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT8_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT9_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT9_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT10_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT10_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT11_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT11_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT12_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT12_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT13_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT13_ALT", FALSE, 0, 0, TRUE),
  HOWTO (R_XTENSA_SLOT14_ALT, 0, 0, 0, TRUE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT14_ALT", FALSE, 0, 0, TRUE),

  /* TLS relocations.  */
  HOWTO (R_XTENSA_TLSDESC_FN, 0, 2, 32, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLSDESC_FN",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_TLSDESC_ARG, 0, 2, 32, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLSDESC_ARG",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_TLS_DTPOFF, 0, 2, 32, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLS_DTPOFF",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLS_TPOFF",
	 FALSE, 0, 0xffffffff, FALSE),
  HOWTO (R_XTENSA_TLS_FUNC, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLS_FUNC",
	 FALSE, 0, 0, FALSE),
  HOWTO (R_XTENSA_TLS_ARG, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLS_ARG",
	 FALSE, 0, 0, FALSE),
  HOWTO (R_XTENSA_TLS_CALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	 bfd_elf_xtensa_reloc, "R_XTENSA_TLS_CALL",
	 FALSE, 0, 0, FALSE),
};

#if DEBUG_GEN_RELOC
#define TRACE(str) \
  fprintf (stderr, "Xtensa bfd reloc lookup %d (%s)\n", code, str)
#else
#define TRACE(str)
#endif

static reloc_howto_type *
elf_xtensa_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_NONE:
      TRACE ("BFD_RELOC_NONE");
      return &elf_howto_table[(unsigned) R_XTENSA_NONE ];

    case BFD_RELOC_32:
      TRACE ("BFD_RELOC_32");
      return &elf_howto_table[(unsigned) R_XTENSA_32 ];

    case BFD_RELOC_32_PCREL:
      TRACE ("BFD_RELOC_32_PCREL");
      return &elf_howto_table[(unsigned) R_XTENSA_32_PCREL ];

    case BFD_RELOC_XTENSA_DIFF8:
      TRACE ("BFD_RELOC_XTENSA_DIFF8");
      return &elf_howto_table[(unsigned) R_XTENSA_DIFF8 ];

    case BFD_RELOC_XTENSA_DIFF16:
      TRACE ("BFD_RELOC_XTENSA_DIFF16");
      return &elf_howto_table[(unsigned) R_XTENSA_DIFF16 ];

    case BFD_RELOC_XTENSA_DIFF32:
      TRACE ("BFD_RELOC_XTENSA_DIFF32");
      return &elf_howto_table[(unsigned) R_XTENSA_DIFF32 ];

    case BFD_RELOC_XTENSA_RTLD:
      TRACE ("BFD_RELOC_XTENSA_RTLD");
      return &elf_howto_table[(unsigned) R_XTENSA_RTLD ];

    case BFD_RELOC_XTENSA_GLOB_DAT:
      TRACE ("BFD_RELOC_XTENSA_GLOB_DAT");
      return &elf_howto_table[(unsigned) R_XTENSA_GLOB_DAT ];

    case BFD_RELOC_XTENSA_JMP_SLOT:
      TRACE ("BFD_RELOC_XTENSA_JMP_SLOT");
      return &elf_howto_table[(unsigned) R_XTENSA_JMP_SLOT ];

    case BFD_RELOC_XTENSA_RELATIVE:
      TRACE ("BFD_RELOC_XTENSA_RELATIVE");
      return &elf_howto_table[(unsigned) R_XTENSA_RELATIVE ];

    case BFD_RELOC_XTENSA_PLT:
      TRACE ("BFD_RELOC_XTENSA_PLT");
      return &elf_howto_table[(unsigned) R_XTENSA_PLT ];

    case BFD_RELOC_XTENSA_OP0:
      TRACE ("BFD_RELOC_XTENSA_OP0");
      return &elf_howto_table[(unsigned) R_XTENSA_OP0 ];

    case BFD_RELOC_XTENSA_OP1:
      TRACE ("BFD_RELOC_XTENSA_OP1");
      return &elf_howto_table[(unsigned) R_XTENSA_OP1 ];

    case BFD_RELOC_XTENSA_OP2:
      TRACE ("BFD_RELOC_XTENSA_OP2");
      return &elf_howto_table[(unsigned) R_XTENSA_OP2 ];

    case BFD_RELOC_XTENSA_ASM_EXPAND:
      TRACE ("BFD_RELOC_XTENSA_ASM_EXPAND");
      return &elf_howto_table[(unsigned) R_XTENSA_ASM_EXPAND ];

    case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
      TRACE ("BFD_RELOC_XTENSA_ASM_SIMPLIFY");
      return &elf_howto_table[(unsigned) R_XTENSA_ASM_SIMPLIFY ];

    case BFD_RELOC_VTABLE_INHERIT:
      TRACE ("BFD_RELOC_VTABLE_INHERIT");
      return &elf_howto_table[(unsigned) R_XTENSA_GNU_VTINHERIT ];

    case BFD_RELOC_VTABLE_ENTRY:
      TRACE ("BFD_RELOC_VTABLE_ENTRY");
      return &elf_howto_table[(unsigned) R_XTENSA_GNU_VTENTRY ];

    case BFD_RELOC_XTENSA_TLSDESC_FN:
      TRACE ("BFD_RELOC_XTENSA_TLSDESC_FN");
      return &elf_howto_table[(unsigned) R_XTENSA_TLSDESC_FN ];

    case BFD_RELOC_XTENSA_TLSDESC_ARG:
      TRACE ("BFD_RELOC_XTENSA_TLSDESC_ARG");
      return &elf_howto_table[(unsigned) R_XTENSA_TLSDESC_ARG ];

    case BFD_RELOC_XTENSA_TLS_DTPOFF:
      TRACE ("BFD_RELOC_XTENSA_TLS_DTPOFF");
      return &elf_howto_table[(unsigned) R_XTENSA_TLS_DTPOFF ];

    case BFD_RELOC_XTENSA_TLS_TPOFF:
      TRACE ("BFD_RELOC_XTENSA_TLS_TPOFF");
      return &elf_howto_table[(unsigned) R_XTENSA_TLS_TPOFF ];

    case BFD_RELOC_XTENSA_TLS_FUNC:
      TRACE ("BFD_RELOC_XTENSA_TLS_FUNC");
      return &elf_howto_table[(unsigned) R_XTENSA_TLS_FUNC ];

    case BFD_RELOC_XTENSA_TLS_ARG:
      TRACE ("BFD_RELOC_XTENSA_TLS_ARG");
      return &elf_howto_table[(unsigned) R_XTENSA_TLS_ARG ];

    case BFD_RELOC_XTENSA_TLS_CALL:
      TRACE ("BFD_RELOC_XTENSA_TLS_CALL");
      return &elf_howto_table[(unsigned) R_XTENSA_TLS_CALL ];

    default:
      if (code >= BFD_RELOC_XTENSA_SLOT0_OP
	  && code <= BFD_RELOC_XTENSA_SLOT14_OP)
	{
	  unsigned n = (R_XTENSA_SLOT0_OP +
			(code - BFD_RELOC_XTENSA_SLOT0_OP));
	  return &elf_howto_table[n];
	}

      if (code >= BFD_RELOC_XTENSA_SLOT0_ALT
	  && code <= BFD_RELOC_XTENSA_SLOT14_ALT)
	{
	  unsigned n = (R_XTENSA_SLOT0_ALT +
			(code - BFD_RELOC_XTENSA_SLOT0_ALT));
	  return &elf_howto_table[n];
	}

      break;
    }

  TRACE ("Unknown");
  return NULL;
}

static reloc_howto_type *
elf_xtensa_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *r_name)
{
  unsigned int i;

  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
    if (elf_howto_table[i].name != NULL
	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
      return &elf_howto_table[i];

  return NULL;
}


/* Given an ELF "rela" relocation, find the corresponding howto and record
   it in the BFD internal arelent representation of the relocation.  */

static void
elf_xtensa_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr,
			       Elf_Internal_Rela *dst)
{
  unsigned int r_type = ELF32_R_TYPE (dst->r_info);

  BFD_ASSERT (r_type < (unsigned int) R_XTENSA_max);
  cache_ptr->howto = &elf_howto_table[r_type];
}


/* Functions for the Xtensa ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so"

/* The size in bytes of an entry in the procedure linkage table.
   (This does _not_ include the space for the literals associated with
   the PLT entry.) */

#define PLT_ENTRY_SIZE 16

/* For _really_ large PLTs, we may need to alternate between literals
   and code to keep the literals within the 256K range of the L32R
   instructions in the code.  It's unlikely that anyone would ever need
   such a big PLT, but an arbitrary limit on the PLT size would be bad.
   Thus, we split the PLT into chunks.  Since there's very little
   overhead (2 extra literals) for each chunk, the chunk size is kept
   small so that the code for handling multiple chunks get used and
   tested regularly.  With 254 entries, there are 1K of literals for
   each chunk, and that seems like a nice round number.  */

#define PLT_ENTRIES_PER_CHUNK 254

/* PLT entries are actually used as stub functions for lazy symbol
   resolution.  Once the symbol is resolved, the stub function is never
   invoked.  Note: the 32-byte frame size used here cannot be changed
   without a corresponding change in the runtime linker.  */

static const bfd_byte elf_xtensa_be_plt_entry[PLT_ENTRY_SIZE] =
{
  0x6c, 0x10, 0x04,	/* entry sp, 32 */
  0x18, 0x00, 0x00,	/* l32r  a8, [got entry for rtld's resolver] */
  0x1a, 0x00, 0x00,	/* l32r  a10, [got entry for rtld's link map] */
  0x1b, 0x00, 0x00,	/* l32r  a11, [literal for reloc index] */
  0x0a, 0x80, 0x00,	/* jx    a8 */
  0			/* unused */
};

static const bfd_byte elf_xtensa_le_plt_entry[PLT_ENTRY_SIZE] =
{
  0x36, 0x41, 0x00,	/* entry sp, 32 */
  0x81, 0x00, 0x00,	/* l32r  a8, [got entry for rtld's resolver] */
  0xa1, 0x00, 0x00,	/* l32r  a10, [got entry for rtld's link map] */
  0xb1, 0x00, 0x00,	/* l32r  a11, [literal for reloc index] */
  0xa0, 0x08, 0x00,	/* jx    a8 */
  0			/* unused */
};

/* The size of the thread control block.  */
#define TCB_SIZE	8

struct elf_xtensa_link_hash_entry
{
  struct elf_link_hash_entry elf;

  bfd_signed_vma tlsfunc_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2	/* global or local dynamic */
#define GOT_TLS_IE	4	/* initial or local exec */
#define GOT_TLS_ANY	(GOT_TLS_GD | GOT_TLS_IE)
  unsigned char tls_type;
};

#define elf_xtensa_hash_entry(ent) ((struct elf_xtensa_link_hash_entry *)(ent))

struct elf_xtensa_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;

  bfd_signed_vma *local_tlsfunc_refcounts;
};

#define elf_xtensa_tdata(abfd) \
  ((struct elf_xtensa_obj_tdata *) (abfd)->tdata.any)

#define elf_xtensa_local_got_tls_type(abfd) \
  (elf_xtensa_tdata (abfd)->local_got_tls_type)

#define elf_xtensa_local_tlsfunc_refcounts(abfd) \
  (elf_xtensa_tdata (abfd)->local_tlsfunc_refcounts)

#define is_xtensa_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_tdata (bfd) != NULL \
   && elf_object_id (bfd) == XTENSA_ELF_DATA)

static bfd_boolean
elf_xtensa_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_xtensa_obj_tdata),
				  XTENSA_ELF_DATA);
}

/* Xtensa ELF linker hash table.  */

struct elf_xtensa_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sgotloc;
  asection *spltlittbl;

  /* Total count of PLT relocations seen during check_relocs.
     The actual PLT code must be split into multiple sections and all
     the sections have to be created before size_dynamic_sections,
     where we figure out the exact number of PLT entries that will be
     needed.  It is OK if this count is an overestimate, e.g., some
     relocations may be removed by GC.  */
  int plt_reloc_count;

  struct elf_xtensa_link_hash_entry *tlsbase;
};

/* Get the Xtensa ELF linker hash table from a link_info structure.  */

#define elf_xtensa_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == XTENSA_ELF_DATA ? ((struct elf_xtensa_link_hash_table *) ((p)->hash)) : NULL)

/* Create an entry in an Xtensa ELF linker hash table.  */

static struct bfd_hash_entry *
elf_xtensa_link_hash_newfunc (struct bfd_hash_entry *entry,
			      struct bfd_hash_table *table,
			      const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf_xtensa_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_xtensa_link_hash_entry *eh = elf_xtensa_hash_entry (entry);
      eh->tlsfunc_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
    }

  return entry;
}

/* Create an Xtensa ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_xtensa_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_entry *tlsbase;
  struct elf_xtensa_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_xtensa_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      elf_xtensa_link_hash_newfunc,
				      sizeof (struct elf_xtensa_link_hash_entry),
				      XTENSA_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  /* Create a hash entry for "_TLS_MODULE_BASE_" to speed up checking
     for it later.  */
  tlsbase = elf_link_hash_lookup (&ret->elf, "_TLS_MODULE_BASE_",
				  TRUE, FALSE, FALSE);
  tlsbase->root.type = bfd_link_hash_new;
  tlsbase->root.u.undef.abfd = NULL;
  tlsbase->non_elf = 0;
  ret->tlsbase = elf_xtensa_hash_entry (tlsbase);
  ret->tlsbase->tls_type = GOT_UNKNOWN;

  return &ret->elf.root;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf_xtensa_copy_indirect_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
{
  struct elf_xtensa_link_hash_entry *edir, *eind;

  edir = elf_xtensa_hash_entry (dir);
  eind = elf_xtensa_hash_entry (ind);

  if (ind->root.type == bfd_link_hash_indirect)
    {
      edir->tlsfunc_refcount += eind->tlsfunc_refcount;
      eind->tlsfunc_refcount = 0;

      if (dir->got.refcount <= 0)
	{
	  edir->tls_type = eind->tls_type;
	  eind->tls_type = GOT_UNKNOWN;
	}
    }

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

static inline bfd_boolean
elf_xtensa_dynamic_symbol_p (struct elf_link_hash_entry *h,
			     struct bfd_link_info *info)
{
  /* Check if we should do dynamic things to this symbol.  The
     "ignore_protected" argument need not be set, because Xtensa code
     does not require special handling of STV_PROTECTED to make function
     pointer comparisons work properly.  The PLT addresses are never
     used for function pointers.  */

  return _bfd_elf_dynamic_symbol_p (h, info, 0);
}


static int
property_table_compare (const void *ap, const void *bp)
{
  const property_table_entry *a = (const property_table_entry *) ap;
  const property_table_entry *b = (const property_table_entry *) bp;

  if (a->address == b->address)
    {
      if (a->size != b->size)
	return (a->size - b->size);

      if ((a->flags & XTENSA_PROP_ALIGN) != (b->flags & XTENSA_PROP_ALIGN))
	return ((b->flags & XTENSA_PROP_ALIGN)
		- (a->flags & XTENSA_PROP_ALIGN));

      if ((a->flags & XTENSA_PROP_ALIGN)
	  && (GET_XTENSA_PROP_ALIGNMENT (a->flags)
	      != GET_XTENSA_PROP_ALIGNMENT (b->flags)))
	return (GET_XTENSA_PROP_ALIGNMENT (a->flags)
		- GET_XTENSA_PROP_ALIGNMENT (b->flags));

      if ((a->flags & XTENSA_PROP_UNREACHABLE)
	  != (b->flags & XTENSA_PROP_UNREACHABLE))
	return ((b->flags & XTENSA_PROP_UNREACHABLE)
		- (a->flags & XTENSA_PROP_UNREACHABLE));

      return (a->flags - b->flags);
    }

  return (a->address - b->address);
}


static int
property_table_matches (const void *ap, const void *bp)
{
  const property_table_entry *a = (const property_table_entry *) ap;
  const property_table_entry *b = (const property_table_entry *) bp;

  /* Check if one entry overlaps with the other.  */
  if ((b->address >= a->address && b->address < (a->address + a->size))
      || (a->address >= b->address && a->address < (b->address + b->size)))
    return 0;

  return (a->address - b->address);
}


/* Get the literal table or property table entries for the given
   section.  Sets TABLE_P and returns the number of entries.  On
   error, returns a negative value.  */

static int
xtensa_read_table_entries (bfd *abfd,
			   asection *section,
			   property_table_entry **table_p,
			   const char *sec_name,
			   bfd_boolean output_addr)
{
  asection *table_section;
  bfd_size_type table_size = 0;
  bfd_byte *table_data;
  property_table_entry *blocks;
  int blk, block_count;
  bfd_size_type num_records;
  Elf_Internal_Rela *internal_relocs, *irel, *rel_end;
  bfd_vma section_addr, off;
  flagword predef_flags;
  bfd_size_type table_entry_size, section_limit;

  if (!section
      || !(section->flags & SEC_ALLOC)
      || (section->flags & SEC_DEBUGGING))
    {
      *table_p = NULL;
      return 0;
    }

  table_section = xtensa_get_property_section (section, sec_name);
  if (table_section)
    table_size = table_section->size;

  if (table_size == 0)
    {
      *table_p = NULL;
      return 0;
    }

  predef_flags = xtensa_get_property_predef_flags (table_section);
  table_entry_size = 12;
  if (predef_flags)
    table_entry_size -= 4;

  num_records = table_size / table_entry_size;
  table_data = retrieve_contents (abfd, table_section, TRUE);
  blocks = (property_table_entry *)
    bfd_malloc (num_records * sizeof (property_table_entry));
  block_count = 0;

  if (output_addr)
    section_addr = section->output_section->vma + section->output_offset;
  else
    section_addr = section->vma;

  internal_relocs = retrieve_internal_relocs (abfd, table_section, TRUE);
  if (internal_relocs && !table_section->reloc_done)
    {
      qsort (internal_relocs, table_section->reloc_count,
	     sizeof (Elf_Internal_Rela), internal_reloc_compare);
      irel = internal_relocs;
    }
  else
    irel = NULL;

  section_limit = bfd_get_section_limit (abfd, section);
  rel_end = internal_relocs + table_section->reloc_count;

  for (off = 0; off < table_size; off += table_entry_size)
    {
      bfd_vma address = bfd_get_32 (abfd, table_data + off);

      /* Skip any relocations before the current offset.  This should help
	 avoid confusion caused by unexpected relocations for the preceding
	 table entry.  */
      while (irel &&
	     (irel->r_offset < off
	      || (irel->r_offset == off
		  && ELF32_R_TYPE (irel->r_info) == R_XTENSA_NONE)))
	{
	  irel += 1;
	  if (irel >= rel_end)
	    irel = 0;
	}

      if (irel && irel->r_offset == off)
	{
	  bfd_vma sym_off;
	  unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
	  BFD_ASSERT (ELF32_R_TYPE (irel->r_info) == R_XTENSA_32);

	  if (get_elf_r_symndx_section (abfd, r_symndx) != section)
	    continue;

	  sym_off = get_elf_r_symndx_offset (abfd, r_symndx);
	  BFD_ASSERT (sym_off == 0);
	  address += (section_addr + sym_off + irel->r_addend);
	}
      else
	{
	  if (address < section_addr
	      || address >= section_addr + section_limit)
	    continue;
	}

      blocks[block_count].address = address;
      blocks[block_count].size = bfd_get_32 (abfd, table_data + off + 4);
      if (predef_flags)
	blocks[block_count].flags = predef_flags;
      else
	blocks[block_count].flags = bfd_get_32 (abfd, table_data + off + 8);
      block_count++;
    }

  release_contents (table_section, table_data);
  release_internal_relocs (table_section, internal_relocs);

  if (block_count > 0)
    {
      /* Now sort them into address order for easy reference.  */
      qsort (blocks, block_count, sizeof (property_table_entry),
	     property_table_compare);

      /* Check that the table contents are valid.  Problems may occur,
         for example, if an unrelocated object file is stripped.  */
      for (blk = 1; blk < block_count; blk++)
	{
	  /* The only circumstance where two entries may legitimately
	     have the same address is when one of them is a zero-size
	     placeholder to mark a place where fill can be inserted.
	     The zero-size entry should come first.  */
	  if (blocks[blk - 1].address == blocks[blk].address &&
	      blocks[blk - 1].size != 0)
	    {
	      (*_bfd_error_handler) (_("%B(%A): invalid property table"),
				     abfd, section);
	      bfd_set_error (bfd_error_bad_value);
	      free (blocks);
	      return -1;
	    }
	}
    }

  *table_p = blocks;
  return block_count;
}


static property_table_entry *
elf_xtensa_find_property_entry (property_table_entry *property_table,
				int property_table_size,
				bfd_vma addr)
{
  property_table_entry entry;
  property_table_entry *rv;

  if (property_table_size == 0)
    return NULL;

  entry.address = addr;
  entry.size = 1;
  entry.flags = 0;

  rv = bsearch (&entry, property_table, property_table_size,
		sizeof (property_table_entry), property_table_matches);
  return rv;
}


static bfd_boolean
elf_xtensa_in_literal_pool (property_table_entry *lit_table,
			    int lit_table_size,
			    bfd_vma addr)
{
  if (elf_xtensa_find_property_entry (lit_table, lit_table_size, addr))
    return TRUE;

  return FALSE;
}


/* Look through the relocs for a section during the first phase, and
   calculate needed space in the dynamic reloc sections.  */

static bfd_boolean
elf_xtensa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  struct elf_xtensa_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  if (info->relocatable || (sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  BFD_ASSERT (is_xtensa_elf (abfd));

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h = NULL;
      struct elf_xtensa_link_hash_entry *eh;
      int tls_type, old_tls_type;
      bfd_boolean is_got = FALSE;
      bfd_boolean is_plt = FALSE;
      bfd_boolean is_tlsfunc = FALSE;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
	  return FALSE;
	}

      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}
      eh = elf_xtensa_hash_entry (h);

      switch (r_type)
	{
	case R_XTENSA_TLSDESC_FN:
	  if (info->shared)
	    {
	      tls_type = GOT_TLS_GD;
	      is_got = TRUE;
	      is_tlsfunc = TRUE;
	    }
	  else
	    tls_type = GOT_TLS_IE;
	  break;

	case R_XTENSA_TLSDESC_ARG:
	  if (info->shared)
	    {
	      tls_type = GOT_TLS_GD;
	      is_got = TRUE;
	    }
	  else
	    {
	      tls_type = GOT_TLS_IE;
	      if (h && elf_xtensa_hash_entry (h) != htab->tlsbase)
		is_got = TRUE;
	    }
	  break;

	case R_XTENSA_TLS_DTPOFF:
	  if (info->shared)
	    tls_type = GOT_TLS_GD;
	  else
	    tls_type = GOT_TLS_IE;
	  break;

	case R_XTENSA_TLS_TPOFF:
	  tls_type = GOT_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  if (info->shared || h)
	    is_got = TRUE;
	  break;

	case R_XTENSA_32:
	  tls_type = GOT_NORMAL;
	  is_got = TRUE;
	  break;

	case R_XTENSA_PLT:
	  tls_type = GOT_NORMAL;
	  is_plt = TRUE;
	  break;

	case R_XTENSA_GNU_VTINHERIT:
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  continue;

	case R_XTENSA_GNU_VTENTRY:
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  continue;

	default:
	  /* Nothing to do for any other relocations.  */
	  continue;
	}

      if (h)
	{
	  if (is_plt)
	    {
	      if (h->plt.refcount <= 0)
		{
		  h->needs_plt = 1;
		  h->plt.refcount = 1;
		}
	      else
		h->plt.refcount += 1;

	      /* Keep track of the total PLT relocation count even if we
		 don't yet know whether the dynamic sections will be
		 created.  */
	      htab->plt_reloc_count += 1;

	      if (elf_hash_table (info)->dynamic_sections_created)
		{
		  if (! add_extra_plt_sections (info, htab->plt_reloc_count))
		    return FALSE;
		}
	    }
	  else if (is_got)
	    {
	      if (h->got.refcount <= 0)
		h->got.refcount = 1;
	      else
		h->got.refcount += 1;
	    }

	  if (is_tlsfunc)
	    eh->tlsfunc_refcount += 1;

	  old_tls_type = eh->tls_type;
	}
      else
	{
	  /* Allocate storage the first time.  */
	  if (elf_local_got_refcounts (abfd) == NULL)
	    {
	      bfd_size_type size = symtab_hdr->sh_info;
	      void *mem;

	      mem = bfd_zalloc (abfd, size * sizeof (bfd_signed_vma));
	      if (mem == NULL)
		return FALSE;
	      elf_local_got_refcounts (abfd) = (bfd_signed_vma *) mem;

	      mem = bfd_zalloc (abfd, size);
	      if (mem == NULL)
		return FALSE;
	      elf_xtensa_local_got_tls_type (abfd) = (char *) mem;

	      mem = bfd_zalloc (abfd, size * sizeof (bfd_signed_vma));
	      if (mem == NULL)
		return FALSE;
	      elf_xtensa_local_tlsfunc_refcounts (abfd)
		= (bfd_signed_vma *) mem;
	    }

	  /* This is a global offset table entry for a local symbol.  */
	  if (is_got || is_plt)
	    elf_local_got_refcounts (abfd) [r_symndx] += 1;

	  if (is_tlsfunc)
	    elf_xtensa_local_tlsfunc_refcounts (abfd) [r_symndx] += 1;

	  old_tls_type = elf_xtensa_local_got_tls_type (abfd) [r_symndx];
	}

      if ((old_tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_IE))
	tls_type |= old_tls_type;
      /* If a TLS symbol is accessed using IE at least once,
	 there is no point to use a dynamic model for it.  */
      else if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
	       && ((old_tls_type & GOT_TLS_GD) == 0
		   || (tls_type & GOT_TLS_IE) == 0))
	{
	  if ((old_tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_GD))
	    tls_type = old_tls_type;
	  else if ((old_tls_type & GOT_TLS_GD) && (tls_type & GOT_TLS_GD))
	    tls_type |= old_tls_type;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B: `%s' accessed both as normal and thread local symbol"),
		 abfd,
		 h ? h->root.root.string : "<local>");
	      return FALSE;
	    }
	}

      if (old_tls_type != tls_type)
	{
	  if (eh)
	    eh->tls_type = tls_type;
	  else
	    elf_xtensa_local_got_tls_type (abfd) [r_symndx] = tls_type;
	}
    }

  return TRUE;
}


static void
elf_xtensa_make_sym_local (struct bfd_link_info *info,
                           struct elf_link_hash_entry *h)
{
  if (info->shared)
    {
      if (h->plt.refcount > 0)
        {
	  /* For shared objects, there's no need for PLT entries for local
	     symbols (use RELATIVE relocs instead of JMP_SLOT relocs).  */
          if (h->got.refcount < 0)
            h->got.refcount = 0;
          h->got.refcount += h->plt.refcount;
          h->plt.refcount = 0;
        }
    }
  else
    {
      /* Don't need any dynamic relocations at all.  */
      h->plt.refcount = 0;
      h->got.refcount = 0;
    }
}


static void
elf_xtensa_hide_symbol (struct bfd_link_info *info,
                        struct elf_link_hash_entry *h,
                        bfd_boolean force_local)
{
  /* For a shared link, move the plt refcount to the got refcount to leave
     space for RELATIVE relocs.  */
  elf_xtensa_make_sym_local (info, h);

  _bfd_elf_link_hash_hide_symbol (info, h, force_local);
}


/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf_xtensa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
{
  /* Property sections are marked "KEEP" in the linker scripts, but they
     should not cause other sections to be marked.  (This approach relies
     on elf_xtensa_discard_info to remove property table entries that
     describe discarded sections.  Alternatively, it might be more
     efficient to avoid using "KEEP" in the linker scripts and instead use
     the gc_mark_extra_sections hook to mark only the property sections
     that describe marked sections.  That alternative does not work well
     with the current property table sections, which do not correspond
     one-to-one with the sections they describe, but that should be fixed
     someday.) */
  if (xtensa_is_property_section (sec))
    return NULL;

  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_XTENSA_GNU_VTINHERIT:
      case R_XTENSA_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}


/* Update the GOT & PLT entry reference counts
   for the section being removed.  */

static bfd_boolean
elf_xtensa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  struct elf_xtensa_link_hash_table *htab;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (info->relocatable)
    return TRUE;

  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
      struct elf_xtensa_link_hash_entry *eh;
      bfd_boolean is_got = FALSE;
      bfd_boolean is_plt = FALSE;
      bfd_boolean is_tlsfunc = FALSE;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
      eh = elf_xtensa_hash_entry (h);

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_XTENSA_TLSDESC_FN:
	  if (info->shared)
	    {
	      is_got = TRUE;
	      is_tlsfunc = TRUE;
	    }
	  break;

	case R_XTENSA_TLSDESC_ARG:
	  if (info->shared)
	    is_got = TRUE;
	  else
	    {
	      if (h && elf_xtensa_hash_entry (h) != htab->tlsbase)
		is_got = TRUE;
	    }
	  break;

	case R_XTENSA_TLS_TPOFF:
	  if (info->shared || h)
	    is_got = TRUE;
	  break;

	case R_XTENSA_32:
	  is_got = TRUE;
	  break;

	case R_XTENSA_PLT:
	  is_plt = TRUE;
	  break;

	default:
	  continue;
	}

      if (h)
	{
	  if (is_plt)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  else if (is_got)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  if (is_tlsfunc)
	    {
	      if (eh->tlsfunc_refcount > 0)
		eh->tlsfunc_refcount--;
	    }
	}
      else
	{
	  if (is_got || is_plt)
	    {
	      bfd_signed_vma *got_refcount
		= &elf_local_got_refcounts (abfd) [r_symndx];
	      if (*got_refcount > 0)
		*got_refcount -= 1;
	    }
	  if (is_tlsfunc)
	    {
	      bfd_signed_vma *tlsfunc_refcount
		= &elf_xtensa_local_tlsfunc_refcounts (abfd) [r_symndx];
	      if (*tlsfunc_refcount > 0)
		*tlsfunc_refcount -= 1;
	    }
	}
    }

  return TRUE;
}


/* Create all the dynamic sections.  */

static bfd_boolean
elf_xtensa_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf_xtensa_link_hash_table *htab;
  flagword flags, noalloc_flags;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* First do all the standard stuff.  */
  if (! _bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;
  htab->splt = bfd_get_linker_section (dynobj, ".plt");
  htab->srelplt = bfd_get_linker_section (dynobj, ".rela.plt");
  htab->sgot = bfd_get_linker_section (dynobj, ".got");
  htab->sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
  htab->srelgot = bfd_get_linker_section (dynobj, ".rela.got");

  /* Create any extra PLT sections in case check_relocs has already
     been called on all the non-dynamic input files.  */
  if (! add_extra_plt_sections (info, htab->plt_reloc_count))
    return FALSE;

  noalloc_flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
		   | SEC_LINKER_CREATED | SEC_READONLY);
  flags = noalloc_flags | SEC_ALLOC | SEC_LOAD;

  /* Mark the ".got.plt" section READONLY.  */
  if (htab->sgotplt == NULL
      || ! bfd_set_section_flags (dynobj, htab->sgotplt, flags))
    return FALSE;

  /* Create ".got.loc" (literal tables for use by dynamic linker).  */
  htab->sgotloc = bfd_make_section_anyway_with_flags (dynobj, ".got.loc",
						      flags);
  if (htab->sgotloc == NULL
      || ! bfd_set_section_alignment (dynobj, htab->sgotloc, 2))
    return FALSE;

  /* Create ".xt.lit.plt" (literal table for ".got.plt*").  */
  htab->spltlittbl = bfd_make_section_anyway_with_flags (dynobj, ".xt.lit.plt",
							 noalloc_flags);
  if (htab->spltlittbl == NULL
      || ! bfd_set_section_alignment (dynobj, htab->spltlittbl, 2))
    return FALSE;

  return TRUE;
}


static bfd_boolean
add_extra_plt_sections (struct bfd_link_info *info, int count)
{
  bfd *dynobj = elf_hash_table (info)->dynobj;
  int chunk;

  /* Iterate over all chunks except 0 which uses the standard ".plt" and
     ".got.plt" sections.  */
  for (chunk = count / PLT_ENTRIES_PER_CHUNK; chunk > 0; chunk--)
    {
      char *sname;
      flagword flags;
      asection *s;

      /* Stop when we find a section has already been created.  */
      if (elf_xtensa_get_plt_section (info, chunk))
	break;

      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED | SEC_READONLY);

      sname = (char *) bfd_malloc (10);
      sprintf (sname, ".plt.%u", chunk);
      s = bfd_make_section_anyway_with_flags (dynobj, sname, flags | SEC_CODE);
      if (s == NULL
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;

      sname = (char *) bfd_malloc (14);
      sprintf (sname, ".got.plt.%u", chunk);
      s = bfd_make_section_anyway_with_flags (dynobj, sname, flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;
    }

  return TRUE;
}


/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_xtensa_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  struct elf_link_hash_entry *h)
{
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object.  The
     reference must go through the GOT, so there's no need for COPY relocs,
     .dynbss, etc.  */

  return TRUE;
}


static bfd_boolean
elf_xtensa_allocate_dynrelocs (struct elf_link_hash_entry *h, void *arg)
{
  struct bfd_link_info *info;
  struct elf_xtensa_link_hash_table *htab;
  struct elf_xtensa_link_hash_entry *eh = elf_xtensa_hash_entry (h);

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) arg;
  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* If we saw any use of an IE model for this symbol, we can then optimize
     away GOT entries for any TLSDESC_FN relocs.  */
  if ((eh->tls_type & GOT_TLS_IE) != 0)
    {
      BFD_ASSERT (h->got.refcount >= eh->tlsfunc_refcount);
      h->got.refcount -= eh->tlsfunc_refcount;
    }

  if (! elf_xtensa_dynamic_symbol_p (h, info))
    elf_xtensa_make_sym_local (info, h);

  if (h->plt.refcount > 0)
    htab->srelplt->size += (h->plt.refcount * sizeof (Elf32_External_Rela));

  if (h->got.refcount > 0)
    htab->srelgot->size += (h->got.refcount * sizeof (Elf32_External_Rela));

  return TRUE;
}


static void
elf_xtensa_allocate_local_got_size (struct bfd_link_info *info)
{
  struct elf_xtensa_link_hash_table *htab;
  bfd *i;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return;

  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got_refcounts;
      bfd_size_type j, cnt;
      Elf_Internal_Shdr *symtab_hdr;

      local_got_refcounts = elf_local_got_refcounts (i);
      if (!local_got_refcounts)
	continue;

      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      cnt = symtab_hdr->sh_info;

      for (j = 0; j < cnt; ++j)
	{
	  /* If we saw any use of an IE model for this symbol, we can
	     then optimize away GOT entries for any TLSDESC_FN relocs.  */
	  if ((elf_xtensa_local_got_tls_type (i) [j] & GOT_TLS_IE) != 0)
	    {
	      bfd_signed_vma *tlsfunc_refcount
		= &elf_xtensa_local_tlsfunc_refcounts (i) [j];
	      BFD_ASSERT (local_got_refcounts[j] >= *tlsfunc_refcount);
	      local_got_refcounts[j] -= *tlsfunc_refcount;
	    }

	  if (local_got_refcounts[j] > 0)
	    htab->srelgot->size += (local_got_refcounts[j]
				    * sizeof (Elf32_External_Rela));
	}
    }
}


/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_xtensa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
{
  struct elf_xtensa_link_hash_table *htab;
  bfd *dynobj, *abfd;
  asection *s, *srelplt, *splt, *sgotplt, *srelgot, *spltlittbl, *sgotloc;
  bfd_boolean relplt, relgot;
  int plt_entries, plt_chunks, chunk;

  plt_entries = 0;
  plt_chunks = 0;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    abort ();
  srelgot = htab->srelgot;
  srelplt = htab->srelplt;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      BFD_ASSERT (htab->srelgot != NULL
		  && htab->srelplt != NULL
		  && htab->sgot != NULL
		  && htab->spltlittbl != NULL
		  && htab->sgotloc != NULL);

      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Allocate room for one word in ".got".  */
      htab->sgot->size = 4;

      /* Allocate space in ".rela.got" for literals that reference global
	 symbols and space in ".rela.plt" for literals that have PLT
	 entries.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      elf_xtensa_allocate_dynrelocs,
			      (void *) info);

      /* If we are generating a shared object, we also need space in
	 ".rela.got" for R_XTENSA_RELATIVE relocs for literals that
	 reference local symbols.  */
      if (info->shared)
	elf_xtensa_allocate_local_got_size (info);

      /* Allocate space in ".plt" to match the size of ".rela.plt".  For
	 each PLT entry, we need the PLT code plus a 4-byte literal.
	 For each chunk of ".plt", we also need two more 4-byte
	 literals, two corresponding entries in ".rela.got", and an
	 8-byte entry in ".xt.lit.plt".  */
      spltlittbl = htab->spltlittbl;
      plt_entries = srelplt->size / sizeof (Elf32_External_Rela);
      plt_chunks =
	(plt_entries + PLT_ENTRIES_PER_CHUNK - 1) / PLT_ENTRIES_PER_CHUNK;

      /* Iterate over all the PLT chunks, including any extra sections
	 created earlier because the initial count of PLT relocations
	 was an overestimate.  */
      for (chunk = 0;
	   (splt = elf_xtensa_get_plt_section (info, chunk)) != NULL;
	   chunk++)
	{
	  int chunk_entries;

	  sgotplt = elf_xtensa_get_gotplt_section (info, chunk);
	  BFD_ASSERT (sgotplt != NULL);

	  if (chunk < plt_chunks - 1)
	    chunk_entries = PLT_ENTRIES_PER_CHUNK;
	  else if (chunk == plt_chunks - 1)
	    chunk_entries = plt_entries - (chunk * PLT_ENTRIES_PER_CHUNK);
	  else
	    chunk_entries = 0;

	  if (chunk_entries != 0)
	    {
	      sgotplt->size = 4 * (chunk_entries + 2);
	      splt->size = PLT_ENTRY_SIZE * chunk_entries;
	      srelgot->size += 2 * sizeof (Elf32_External_Rela);
	      spltlittbl->size += 8;
	    }
	  else
	    {
	      sgotplt->size = 0;
	      splt->size = 0;
	    }
	}

      /* Allocate space in ".got.loc" to match the total size of all the
	 literal tables.  */
      sgotloc = htab->sgotloc;
      sgotloc->size = spltlittbl->size;
      for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
	{
	  if (abfd->flags & DYNAMIC)
	    continue;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      if (! discarded_section (s)
		  && xtensa_is_littable_section (s)
		  && s != spltlittbl)
		sgotloc->size += s->size;
	    }
	}
    }

  /* Allocate memory for dynamic sections.  */
  relplt = FALSE;
  relgot = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      if (strcmp (name, ".rela.plt") == 0)
		relplt = TRUE;
	      else if (strcmp (name, ".rela.got") == 0)
		relgot = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".plt.")
	       && ! CONST_STRNEQ (name, ".got.plt.")
	       && strcmp (name, ".got") != 0
	       && strcmp (name, ".plt") != 0
	       && strcmp (name, ".got.plt") != 0
	       && strcmp (name, ".xt.lit.plt") != 0
	       && strcmp (name, ".got.loc") != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the output
	     file.  We must create the ".plt*" and ".got.plt*"
	     sections in create_dynamic_sections and/or check_relocs
	     based on a conservative estimate of the PLT relocation
	     count, because the sections must be created before the
	     linker maps input sections to output sections.  The
	     linker does that before size_dynamic_sections, where we
	     compute the exact size of the PLT, so there may be more
	     of these sections than are actually needed.  */
	  s->flags |= SEC_EXCLUDE;
	}
      else if ((s->flags & SEC_HAS_CONTENTS) != 0)
	{
	  /* Allocate memory for the section contents.  */
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add the special XTENSA_RTLD relocations now.  The offsets won't be
	 known until finish_dynamic_sections, but we need to get the relocs
	 in place before they are sorted.  */
      for (chunk = 0; chunk < plt_chunks; chunk++)
	{
	  Elf_Internal_Rela irela;
	  bfd_byte *loc;

	  irela.r_offset = 0;
	  irela.r_info = ELF32_R_INFO (0, R_XTENSA_RTLD);
	  irela.r_addend = 0;

	  loc = (srelgot->contents
		 + srelgot->reloc_count * sizeof (Elf32_External_Rela));
	  bfd_elf32_swap_reloca_out (output_bfd, &irela, loc);
	  bfd_elf32_swap_reloca_out (output_bfd, &irela,
				     loc + sizeof (Elf32_External_Rela));
	  srelgot->reloc_count += 2;
	}

      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_xtensa_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (relplt)
	{
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relgot)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_PLTGOT, 0)
	  || !add_dynamic_entry (DT_XTENSA_GOT_LOC_OFF, 0)
	  || !add_dynamic_entry (DT_XTENSA_GOT_LOC_SZ, 0))
	return FALSE;
    }
#undef add_dynamic_entry

  return TRUE;
}

static bfd_boolean
elf_xtensa_always_size_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
{
  struct elf_xtensa_link_hash_table *htab;
  asection *tls_sec;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  tls_sec = htab->elf.tls_sec;

  if (tls_sec && (htab->tlsbase->tls_type & GOT_TLS_ANY) != 0)
    {
      struct elf_link_hash_entry *tlsbase = &htab->tlsbase->elf;
      struct bfd_link_hash_entry *bh = &tlsbase->root;
      const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);

      tlsbase->type = STT_TLS;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
	     tls_sec, 0, NULL, FALSE,
	     bed->collect, &bh)))
	return FALSE;
      tlsbase->def_regular = 1;
      tlsbase->other = STV_HIDDEN;
      (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
    }

  return TRUE;
}


/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);
  bfd_vma base;

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  base = align_power ((bfd_vma) TCB_SIZE, htab->tls_sec->alignment_power);
  return address - htab->tls_sec->vma + base;
}

/* Perform the specified relocation.  The instruction at (contents + address)
   is modified to set one operand to represent the value in "relocation".  The
   operand position is determined by the relocation type recorded in the
   howto.  */

#define CALL_SEGMENT_BITS (30)
#define CALL_SEGMENT_SIZE (1 << CALL_SEGMENT_BITS)

static bfd_reloc_status_type
elf_xtensa_do_reloc (reloc_howto_type *howto,
		     bfd *abfd,
		     asection *input_section,
		     bfd_vma relocation,
		     bfd_byte *contents,
		     bfd_vma address,
		     bfd_boolean is_weak_undef,
		     char **error_message)
{
  xtensa_format fmt;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf ibuff = NULL;
  static xtensa_insnbuf sbuff = NULL;
  bfd_vma self_address;
  bfd_size_type input_size;
  int opnd, slot;
  uint32 newval;

  if (!ibuff)
    {
      ibuff = xtensa_insnbuf_alloc (isa);
      sbuff = xtensa_insnbuf_alloc (isa);
    }

  input_size = bfd_get_section_limit (abfd, input_section);

  /* Calculate the PC address for this instruction.  */
  self_address = (input_section->output_section->vma
		  + input_section->output_offset
		  + address);

  switch (howto->type)
    {
    case R_XTENSA_NONE:
    case R_XTENSA_DIFF8:
    case R_XTENSA_DIFF16:
    case R_XTENSA_DIFF32:
    case R_XTENSA_TLS_FUNC:
    case R_XTENSA_TLS_ARG:
    case R_XTENSA_TLS_CALL:
      return bfd_reloc_ok;

    case R_XTENSA_ASM_EXPAND:
      if (!is_weak_undef)
	{
	  /* Check for windowed CALL across a 1GB boundary.  */
	  opcode = get_expanded_call_opcode (contents + address,
					     input_size - address, 0);
	  if (is_windowed_call_opcode (opcode))
	    {
	      if ((self_address >> CALL_SEGMENT_BITS)
		  != (relocation >> CALL_SEGMENT_BITS))
		{
		  *error_message = "windowed longcall crosses 1GB boundary; "
		    "return may fail";
		  return bfd_reloc_dangerous;
		}
	    }
	}
      return bfd_reloc_ok;

    case R_XTENSA_ASM_SIMPLIFY:
      {
        /* Convert the L32R/CALLX to CALL.  */
	bfd_reloc_status_type retval =
	  elf_xtensa_do_asm_simplify (contents, address, input_size,
				      error_message);
	if (retval != bfd_reloc_ok)
	  return bfd_reloc_dangerous;

	/* The CALL needs to be relocated.  Continue below for that part.  */
	address += 3;
	self_address += 3;
	howto = &elf_howto_table[(unsigned) R_XTENSA_SLOT0_OP ];
      }
      break;

    case R_XTENSA_32:
      {
	bfd_vma x;
	x = bfd_get_32 (abfd, contents + address);
	x = x + relocation;
	bfd_put_32 (abfd, x, contents + address);
      }
      return bfd_reloc_ok;

    case R_XTENSA_32_PCREL:
      bfd_put_32 (abfd, relocation - self_address, contents + address);
      return bfd_reloc_ok;

    case R_XTENSA_PLT:
    case R_XTENSA_TLSDESC_FN:
    case R_XTENSA_TLSDESC_ARG:
    case R_XTENSA_TLS_DTPOFF:
    case R_XTENSA_TLS_TPOFF:
      bfd_put_32 (abfd, relocation, contents + address);
      return bfd_reloc_ok;
    }

  /* Only instruction slot-specific relocations handled below.... */
  slot = get_relocation_slot (howto->type);
  if (slot == XTENSA_UNDEFINED)
    {
      *error_message = "unexpected relocation";
      return bfd_reloc_dangerous;
    }

  /* Read the instruction into a buffer and decode the opcode.  */
  xtensa_insnbuf_from_chars (isa, ibuff, contents + address,
			     input_size - address);
  fmt = xtensa_format_decode (isa, ibuff);
  if (fmt == XTENSA_UNDEFINED)
    {
      *error_message = "cannot decode instruction format";
      return bfd_reloc_dangerous;
    }

  xtensa_format_get_slot (isa, fmt, slot, ibuff, sbuff);

  opcode = xtensa_opcode_decode (isa, fmt, slot, sbuff);
  if (opcode == XTENSA_UNDEFINED)
    {
      *error_message = "cannot decode instruction opcode";
      return bfd_reloc_dangerous;
    }

  /* Check for opcode-specific "alternate" relocations.  */
  if (is_alt_relocation (howto->type))
    {
      if (opcode == get_l32r_opcode ())
	{
	  /* Handle the special-case of non-PC-relative L32R instructions.  */
	  bfd *output_bfd = input_section->output_section->owner;
	  asection *lit4_sec = bfd_get_section_by_name (output_bfd, ".lit4");
	  if (!lit4_sec)
	    {
	      *error_message = "relocation references missing .lit4 section";
	      return bfd_reloc_dangerous;
	    }
	  self_address = ((lit4_sec->vma & ~0xfff)
			  + 0x40000 - 3); /* -3 to compensate for do_reloc */
	  newval = relocation;
	  opnd = 1;
	}
      else if (opcode == get_const16_opcode ())
	{
	  /* ALT used for high 16 bits.  */
	  newval = relocation >> 16;
	  opnd = 1;
	}
      else
	{
	  /* No other "alternate" relocations currently defined.  */
	  *error_message = "unexpected relocation";
	  return bfd_reloc_dangerous;
	}
    }
  else /* Not an "alternate" relocation.... */
    {
      if (opcode == get_const16_opcode ())
	{
	  newval = relocation & 0xffff;
	  opnd = 1;
	}
      else
	{
	  /* ...normal PC-relative relocation.... */

	  /* Determine which operand is being relocated.  */
	  opnd = get_relocation_opnd (opcode, howto->type);
	  if (opnd == XTENSA_UNDEFINED)
	    {
	      *error_message = "unexpected relocation";
	      return bfd_reloc_dangerous;
	    }

	  if (!howto->pc_relative)
	    {
	      *error_message = "expected PC-relative relocation";
	      return bfd_reloc_dangerous;
	    }

	  newval = relocation;
	}
    }

  /* Apply the relocation.  */
  if (xtensa_operand_do_reloc (isa, opcode, opnd, &newval, self_address)
      || xtensa_operand_encode (isa, opcode, opnd, &newval)
      || xtensa_operand_set_field (isa, opcode, opnd, fmt, slot,
				   sbuff, newval))
    {
      const char *opname = xtensa_opcode_name (isa, opcode);
      const char *msg;

      msg = "cannot encode";
      if (is_direct_call_opcode (opcode))
	{
	  if ((relocation & 0x3) != 0)
	    msg = "misaligned call target";
	  else
	    msg = "call target out of range";
	}
      else if (opcode == get_l32r_opcode ())
	{
	  if ((relocation & 0x3) != 0)
	    msg = "misaligned literal target";
	  else if (is_alt_relocation (howto->type))
	    msg = "literal target out of range (too many literals)";
	  else if (self_address > relocation)
	    msg = "literal target out of range (try using text-section-literals)";
	  else
	    msg = "literal placed after use";
	}

      *error_message = vsprint_msg (opname, ": %s", strlen (msg) + 2, msg);
      return bfd_reloc_dangerous;
    }

  /* Check for calls across 1GB boundaries.  */
  if (is_direct_call_opcode (opcode)
      && is_windowed_call_opcode (opcode))
    {
      if ((self_address >> CALL_SEGMENT_BITS)
	  != (relocation >> CALL_SEGMENT_BITS))
	{
	  *error_message =
	    "windowed call crosses 1GB boundary; return may fail";
	  return bfd_reloc_dangerous;
	}
    }

  /* Write the modified instruction back out of the buffer.  */
  xtensa_format_set_slot (isa, fmt, slot, ibuff, sbuff);
  xtensa_insnbuf_to_chars (isa, ibuff, contents + address,
			   input_size - address);
  return bfd_reloc_ok;
}


static char *
vsprint_msg (const char *origmsg, const char *fmt, int arglen, ...)
{
  /* To reduce the size of the memory leak,
     we only use a single message buffer.  */
  static bfd_size_type alloc_size = 0;
  static char *message = NULL;
  bfd_size_type orig_len, len = 0;
  bfd_boolean is_append;

  VA_OPEN (ap, arglen);
  VA_FIXEDARG (ap, const char *, origmsg);

  is_append = (origmsg == message);

  orig_len = strlen (origmsg);
  len = orig_len + strlen (fmt) + arglen + 20;
  if (len > alloc_size)
    {
      message = (char *) bfd_realloc_or_free (message, len);
      alloc_size = len;
    }
  if (message != NULL)
    {
      if (!is_append)
	memcpy (message, origmsg, orig_len);
      vsprintf (message + orig_len, fmt, ap);
    }
  VA_CLOSE (ap);
  return message;
}


/* This function is registered as the "special_function" in the
   Xtensa howto for handling simplify operations.
   bfd_perform_relocation / bfd_install_relocation use it to
   perform (install) the specified relocation.  Since this replaces the code
   in bfd_perform_relocation, it is basically an Xtensa-specific,
   stripped-down version of bfd_perform_relocation.  */

static bfd_reloc_status_type
bfd_elf_xtensa_reloc (bfd *abfd,
		      arelent *reloc_entry,
		      asymbol *symbol,
		      void *data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message)
{
  bfd_vma relocation;
  bfd_reloc_status_type flag;
  bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *reloc_target_output_section;
  bfd_boolean is_weak_undef;

  if (!xtensa_default_isa)
    xtensa_default_isa = xtensa_isa_init (0, 0);

  /* ELF relocs are against symbols.  If we are producing relocatable
     output, and the reloc is against an external symbol, the resulting
     reloc will also be against the same symbol.  In such a case, we
     don't want to change anything about the way the reloc is handled,
     since it will all be done at final link time.  This test is similar
     to what bfd_elf_generic_reloc does except that it lets relocs with
     howto->partial_inplace go through even if the addend is non-zero.
     (The real problem is that partial_inplace is set for XTENSA_32
     relocs to begin with, but that's a long story and there's little we
     can do about it now....)  */

  if (output_bfd && (symbol->flags & BSF_SECTION_SYM) == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  reloc_target_output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if ((output_bfd && !howto->partial_inplace)
      || reloc_target_output_section == NULL)
    output_base = 0;
  else
    output_base = reloc_target_output_section->vma;

  relocation += output_base + symbol->section->output_offset;

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */
  if (output_bfd)
    {
      if (!howto->partial_inplace)
	{
	  /* This is a partial relocation, and we want to apply the relocation
	     to the reloc entry rather than the raw data.  Everything except
	     relocations against section symbols has already been handled
	     above.  */

	  BFD_ASSERT (symbol->flags & BSF_SECTION_SYM);
	  reloc_entry->addend = relocation;
	  reloc_entry->address += input_section->output_offset;
	  return bfd_reloc_ok;
	}
      else
	{
	  reloc_entry->address += input_section->output_offset;
	  reloc_entry->addend = 0;
	}
    }

  is_weak_undef = (bfd_is_und_section (symbol->section)
		   && (symbol->flags & BSF_WEAK) != 0);
  flag = elf_xtensa_do_reloc (howto, abfd, input_section, relocation,
			      (bfd_byte *) data, (bfd_vma) octets,
			      is_weak_undef, error_message);

  if (flag == bfd_reloc_dangerous)
    {
      /* Add the symbol name to the error message.  */
      if (! *error_message)
	*error_message = "";
      *error_message = vsprint_msg (*error_message, ": (%s + 0x%lx)",
				    strlen (symbol->name) + 17,
				    symbol->name,
				    (unsigned long) reloc_entry->addend);
    }

  return flag;
}


/* Set up an entry in the procedure linkage table.  */

static bfd_vma
elf_xtensa_create_plt_entry (struct bfd_link_info *info,
			     bfd *output_bfd,
			     unsigned reloc_index)
{
  asection *splt, *sgotplt;
  bfd_vma plt_base, got_base;
  bfd_vma code_offset, lit_offset;
  int chunk;

  chunk = reloc_index / PLT_ENTRIES_PER_CHUNK;
  splt = elf_xtensa_get_plt_section (info, chunk);
  sgotplt = elf_xtensa_get_gotplt_section (info, chunk);
  BFD_ASSERT (splt != NULL && sgotplt != NULL);

  plt_base = splt->output_section->vma + splt->output_offset;
  got_base = sgotplt->output_section->vma + sgotplt->output_offset;

  lit_offset = 8 + (reloc_index % PLT_ENTRIES_PER_CHUNK) * 4;
  code_offset = (reloc_index % PLT_ENTRIES_PER_CHUNK) * PLT_ENTRY_SIZE;

  /* Fill in the literal entry.  This is the offset of the dynamic
     relocation entry.  */
  bfd_put_32 (output_bfd, reloc_index * sizeof (Elf32_External_Rela),
	      sgotplt->contents + lit_offset);

  /* Fill in the entry in the procedure linkage table.  */
  memcpy (splt->contents + code_offset,
	  (bfd_big_endian (output_bfd)
	   ? elf_xtensa_be_plt_entry
	   : elf_xtensa_le_plt_entry),
	  PLT_ENTRY_SIZE);
  bfd_put_16 (output_bfd, l32r_offset (got_base + 0,
				       plt_base + code_offset + 3),
	      splt->contents + code_offset + 4);
  bfd_put_16 (output_bfd, l32r_offset (got_base + 4,
				       plt_base + code_offset + 6),
	      splt->contents + code_offset + 7);
  bfd_put_16 (output_bfd, l32r_offset (got_base + lit_offset,
				       plt_base + code_offset + 9),
	      splt->contents + code_offset + 10);

  return plt_base + code_offset;
}


static bfd_boolean get_indirect_call_dest_reg (xtensa_opcode, unsigned *);

static bfd_boolean
replace_tls_insn (Elf_Internal_Rela *rel,
		  bfd *abfd,
		  asection *input_section,
		  bfd_byte *contents,
		  bfd_boolean is_ld_model,
		  char **error_message)
{
  static xtensa_insnbuf ibuff = NULL;
  static xtensa_insnbuf sbuff = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  xtensa_opcode old_op, new_op;
  bfd_size_type input_size;
  int r_type;
  unsigned dest_reg, src_reg;

  if (ibuff == NULL)
    {
      ibuff = xtensa_insnbuf_alloc (isa);
      sbuff = xtensa_insnbuf_alloc (isa);
    }

  input_size = bfd_get_section_limit (abfd, input_section);

  /* Read the instruction into a buffer and decode the opcode.  */
  xtensa_insnbuf_from_chars (isa, ibuff, contents + rel->r_offset,
			     input_size - rel->r_offset);
  fmt = xtensa_format_decode (isa, ibuff);
  if (fmt == XTENSA_UNDEFINED)
    {
      *error_message = "cannot decode instruction format";
      return FALSE;
    }

  BFD_ASSERT (xtensa_format_num_slots (isa, fmt) == 1);
  xtensa_format_get_slot (isa, fmt, 0, ibuff, sbuff);

  old_op = xtensa_opcode_decode (isa, fmt, 0, sbuff);
  if (old_op == XTENSA_UNDEFINED)
    {
      *error_message = "cannot decode instruction opcode";
      return FALSE;
    }

  r_type = ELF32_R_TYPE (rel->r_info);
  switch (r_type)
    {
    case R_XTENSA_TLS_FUNC:
    case R_XTENSA_TLS_ARG:
      if (old_op != get_l32r_opcode ()
	  || xtensa_operand_get_field (isa, old_op, 0, fmt, 0,
				       sbuff, &dest_reg) != 0)
	{
	  *error_message = "cannot extract L32R destination for TLS access";
	  return FALSE;
	}
      break;

    case R_XTENSA_TLS_CALL:
      if (! get_indirect_call_dest_reg (old_op, &dest_reg)
	  || xtensa_operand_get_field (isa, old_op, 0, fmt, 0,
				       sbuff, &src_reg) != 0)
	{
	  *error_message = "cannot extract CALLXn operands for TLS access";
	  return FALSE;
	}
      break;

    default:
      abort ();
    }

  if (is_ld_model)
    {
      switch (r_type)
	{
	case R_XTENSA_TLS_FUNC:
	case R_XTENSA_TLS_ARG:
	  /* Change the instruction to a NOP (or "OR a1, a1, a1" for older
	     versions of Xtensa).  */
	  new_op = xtensa_opcode_lookup (isa, "nop");
	  if (new_op == XTENSA_UNDEFINED)
	    {
	      new_op = xtensa_opcode_lookup (isa, "or");
	      if (new_op == XTENSA_UNDEFINED
		  || xtensa_opcode_encode (isa, fmt, 0, sbuff, new_op) != 0
		  || xtensa_operand_set_field (isa, new_op, 0, fmt, 0,
					       sbuff, 1) != 0
		  || xtensa_operand_set_field (isa, new_op, 1, fmt, 0,
					       sbuff, 1) != 0
		  || xtensa_operand_set_field (isa, new_op, 2, fmt, 0,
					       sbuff, 1) != 0)
		{
		  *error_message = "cannot encode OR for TLS access";
		  return FALSE;
		}
	    }
	  else
	    {
	      if (xtensa_opcode_encode (isa, fmt, 0, sbuff, new_op) != 0)
		{
		  *error_message = "cannot encode NOP for TLS access";
		  return FALSE;
		}
	    }
	  break;

	case R_XTENSA_TLS_CALL:
	  /* Read THREADPTR into the CALLX's return value register.  */
	  new_op = xtensa_opcode_lookup (isa, "rur.threadptr");
	  if (new_op == XTENSA_UNDEFINED
	      || xtensa_opcode_encode (isa, fmt, 0, sbuff, new_op) != 0
	      || xtensa_operand_set_field (isa, new_op, 0, fmt, 0,
					   sbuff, dest_reg + 2) != 0)
	    {
	      *error_message = "cannot encode RUR.THREADPTR for TLS access";
	      return FALSE;
	    }
	  break;
	}
    }
  else
    {
      switch (r_type)
	{
	case R_XTENSA_TLS_FUNC:
	  new_op = xtensa_opcode_lookup (isa, "rur.threadptr");
	  if (new_op == XTENSA_UNDEFINED
	      || xtensa_opcode_encode (isa, fmt, 0, sbuff, new_op) != 0
	      || xtensa_operand_set_field (isa, new_op, 0, fmt, 0,
					   sbuff, dest_reg) != 0)
	    {
	      *error_message = "cannot encode RUR.THREADPTR for TLS access";
	      return FALSE;
	    }
	  break;

	case R_XTENSA_TLS_ARG:
	  /* Nothing to do.  Keep the original L32R instruction.  */
	  return TRUE;

	case R_XTENSA_TLS_CALL:
	  /* Add the CALLX's src register (holding the THREADPTR value)
	     to the first argument register (holding the offset) and put
	     the result in the CALLX's return value register.  */
	  new_op = xtensa_opcode_lookup (isa, "add");
	  if (new_op == XTENSA_UNDEFINED
	      || xtensa_opcode_encode (isa, fmt, 0, sbuff, new_op) != 0
	      || xtensa_operand_set_field (isa, new_op, 0, fmt, 0,
					   sbuff, dest_reg + 2) != 0
	      || xtensa_operand_set_field (isa, new_op, 1, fmt, 0,
					   sbuff, dest_reg + 2) != 0
	      || xtensa_operand_set_field (isa, new_op, 2, fmt, 0,
					   sbuff, src_reg) != 0)
	    {
	      *error_message = "cannot encode ADD for TLS access";
	      return FALSE;
	    }
	  break;
	}
    }

  xtensa_format_set_slot (isa, fmt, 0, ibuff, sbuff);
  xtensa_insnbuf_to_chars (isa, ibuff, contents + rel->r_offset,
                           input_size - rel->r_offset);

  return TRUE;
}


#define IS_XTENSA_TLS_RELOC(R_TYPE) \
  ((R_TYPE) == R_XTENSA_TLSDESC_FN \
   || (R_TYPE) == R_XTENSA_TLSDESC_ARG \
   || (R_TYPE) == R_XTENSA_TLS_DTPOFF \
   || (R_TYPE) == R_XTENSA_TLS_TPOFF \
   || (R_TYPE) == R_XTENSA_TLS_FUNC \
   || (R_TYPE) == R_XTENSA_TLS_ARG \
   || (R_TYPE) == R_XTENSA_TLS_CALL)

/* Relocate an Xtensa ELF section.  This is invoked by the linker for
   both relocatable and final links.  */

static bfd_boolean
elf_xtensa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  struct elf_xtensa_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct elf_link_hash_entry **sym_hashes;
  property_table_entry *lit_table = 0;
  int ltblsize = 0;
  char *local_got_tls_types;
  char *error_message = NULL;
  bfd_size_type input_size;
  int tls_type;

  if (!xtensa_default_isa)
    xtensa_default_isa = xtensa_isa_init (0, 0);

  BFD_ASSERT (is_xtensa_elf (input_bfd));

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_tls_types = elf_xtensa_local_got_tls_type (input_bfd);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      ltblsize = xtensa_read_table_entries (input_bfd, input_section,
					    &lit_table, XTENSA_LIT_SEC_NAME,
					    TRUE);
      if (ltblsize < 0)
	return FALSE;
    }

  input_size = bfd_get_section_limit (input_bfd, input_section);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      char sym_type;
      const char *name;
      asection *sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      bfd_boolean is_weak_undef;
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      bfd_boolean dynamic_symbol;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type == (int) R_XTENSA_GNU_VTINHERIT
	  || r_type == (int) R_XTENSA_GNU_VTENTRY)
	continue;

      if (r_type < 0 || r_type >= (int) R_XTENSA_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = &elf_howto_table[r_type];

      r_symndx = ELF32_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      is_weak_undef = FALSE;
      unresolved_reloc = FALSE;
      warned = FALSE;

      if (howto->partial_inplace && !info->relocatable)
	{
	  /* Because R_XTENSA_32 was made partial_inplace to fix some
	     problems with DWARF info in partial links, there may be
	     an addend stored in the contents.  Take it out of there
	     and move it back into the addend field of the reloc.  */
	  rel->r_addend += bfd_get_32 (input_bfd, contents + rel->r_offset);
	  bfd_put_32 (input_bfd, 0, contents + rel->r_offset);
	}

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sym_type = ELF32_ST_TYPE (sym->st_info);
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  if (relocation == 0
	      && !unresolved_reloc
	      && h->root.type == bfd_link_hash_undefweak)
	    is_weak_undef = TRUE;

	  sym_type = h->type;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	{
	  bfd_vma dest_addr;
	  asection * sym_sec = get_elf_r_symndx_section (input_bfd, r_symndx);

	  /* This is a relocatable link.
	     1) If the reloc is against a section symbol, adjust
	     according to the output section.
	     2) If there is a new target for this relocation,
	     the new target will be in the same output section.
	     We adjust the relocation by the output section
	     difference.  */

	  if (relaxing_section)
	    {
	      /* Check if this references a section in another input file.  */
	      if (!do_fix_for_relocatable_link (rel, input_bfd, input_section,
						contents))
		return FALSE;
	    }

	  dest_addr = sym_sec->output_section->vma + sym_sec->output_offset
	    + get_elf_r_symndx_offset (input_bfd, r_symndx) + rel->r_addend;

	  if (r_type == R_XTENSA_ASM_SIMPLIFY)
	    {
	      error_message = NULL;
	      /* Convert ASM_SIMPLIFY into the simpler relocation
		 so that they never escape a relaxing link.  */
	      r = contract_asm_expansion (contents, input_size, rel,
					  &error_message);
	      if (r != bfd_reloc_ok)
		{
		  if (!((*info->callbacks->reloc_dangerous)
			(info, error_message, input_bfd, input_section,
			 rel->r_offset)))
		    return FALSE;
		}
	      r_type = ELF32_R_TYPE (rel->r_info);
	    }

	  /* This is a relocatable link, so we don't have to change
	     anything unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  /* If there is an addend with a partial_inplace howto,
	     then move the addend to the contents.  This is a hack
	     to work around problems with DWARF in relocatable links
	     with some previous version of BFD.  Now we can't easily get
	     rid of the hack without breaking backward compatibility.... */
	  r = bfd_reloc_ok;
	  howto = &elf_howto_table[r_type];
	  if (howto->partial_inplace && rel->r_addend)
	    {
	      r = elf_xtensa_do_reloc (howto, input_bfd, input_section,
				       rel->r_addend, contents,
				       rel->r_offset, FALSE,
				       &error_message);
	      rel->r_addend = 0;
	    }
	  else
	    {
	      /* Put the correct bits in the target instruction, even
		 though the relocation will still be present in the output
		 file.  This makes disassembly clearer, as well as
		 allowing loadable kernel modules to work without needing
		 relocations on anything other than calls and l32r's.  */

	      /* If it is not in the same section, there is nothing we can do.  */
	      if (r_type >= R_XTENSA_SLOT0_OP && r_type <= R_XTENSA_SLOT14_OP &&
		  sym_sec->output_section == input_section->output_section)
		{
		  r = elf_xtensa_do_reloc (howto, input_bfd, input_section,
					   dest_addr, contents,
					   rel->r_offset, FALSE,
					   &error_message);
		}
	    }
	  if (r != bfd_reloc_ok)
	    {
	      if (!((*info->callbacks->reloc_dangerous)
		    (info, error_message, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	    }

	  /* Done with work for relocatable link; continue with next reloc.  */
	  continue;
	}

      /* This is a final link.  */

      if (relaxing_section)
	{
	  /* Check if this references a section in another input file.  */
	  do_fix_for_final_link (rel, input_bfd, input_section, contents,
				 &relocation);
	}

      /* Sanity check the address.  */
      if (rel->r_offset >= input_size
	  && ELF32_R_TYPE (rel->r_info) != R_XTENSA_NONE)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): relocation offset out of range (size=0x%x)"),
	     input_bfd, input_section, rel->r_offset, input_size);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      if (r_symndx != STN_UNDEF
	  && r_type != R_XTENSA_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && IS_XTENSA_TLS_RELOC (r_type) != (sym_type == STT_TLS))
	{
	  (*_bfd_error_handler)
	    ((sym_type == STT_TLS
	      ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
	      : _("%B(%A+0x%lx): %s used with non-TLS symbol %s")),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     name);
	}

      dynamic_symbol = elf_xtensa_dynamic_symbol_p (h, info);

      tls_type = GOT_UNKNOWN;
      if (h)
	tls_type = elf_xtensa_hash_entry (h)->tls_type;
      else if (local_got_tls_types)
	tls_type = local_got_tls_types [r_symndx];

      switch (r_type)
	{
	case R_XTENSA_32:
	case R_XTENSA_PLT:
	  if (elf_hash_table (info)->dynamic_sections_created
	      && (input_section->flags & SEC_ALLOC) != 0
	      && (dynamic_symbol || info->shared))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      asection *srel;

	      if (dynamic_symbol && r_type == R_XTENSA_PLT)
		srel = htab->srelplt;
	      else
		srel = htab->srelgot;

	      BFD_ASSERT (srel != NULL);

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info,
					 input_section, rel->r_offset);

	      if ((outrel.r_offset | 1) == (bfd_vma) -1)
		memset (&outrel, 0, sizeof outrel);
	      else
		{
		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);

		  /* Complain if the relocation is in a read-only section
		     and not in a literal pool.  */
		  if ((input_section->flags & SEC_READONLY) != 0
		      && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						      outrel.r_offset))
		    {
		      error_message =
			_("dynamic relocation in read-only section");
		      if (!((*info->callbacks->reloc_dangerous)
			    (info, error_message, input_bfd, input_section,
			     rel->r_offset)))
			return FALSE;
		    }

		  if (dynamic_symbol)
		    {
		      outrel.r_addend = rel->r_addend;
		      rel->r_addend = 0;

		      if (r_type == R_XTENSA_32)
			{
			  outrel.r_info =
			    ELF32_R_INFO (h->dynindx, R_XTENSA_GLOB_DAT);
			  relocation = 0;
			}
		      else /* r_type == R_XTENSA_PLT */
			{
			  outrel.r_info =
			    ELF32_R_INFO (h->dynindx, R_XTENSA_JMP_SLOT);

			  /* Create the PLT entry and set the initial
			     contents of the literal entry to the address of
			     the PLT entry.  */
			  relocation =
			    elf_xtensa_create_plt_entry (info, output_bfd,
							 srel->reloc_count);
			}
		      unresolved_reloc = FALSE;
		    }
		  else
		    {
		      /* Generate a RELATIVE relocation.  */
		      outrel.r_info = ELF32_R_INFO (0, R_XTENSA_RELATIVE);
		      outrel.r_addend = 0;
		    }
		}

	      loc = (srel->contents
		     + srel->reloc_count++ * sizeof (Elf32_External_Rela));
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      BFD_ASSERT (sizeof (Elf32_External_Rela) * srel->reloc_count
			  <= srel->size);
	    }
	  else if (r_type == R_XTENSA_ASM_EXPAND && dynamic_symbol)
	    {
	      /* This should only happen for non-PIC code, which is not
		 supposed to be used on systems with dynamic linking.
		 Just ignore these relocations.  */
	      continue;
	    }
	  break;

	case R_XTENSA_TLS_TPOFF:
	  /* Switch to LE model for local symbols in an executable.  */
	  if (! info->shared && ! dynamic_symbol)
	    {
	      relocation = tpoff (info, relocation);
	      break;
	    }
	  /* fall through */

	case R_XTENSA_TLSDESC_FN:
	case R_XTENSA_TLSDESC_ARG:
	  {
	    if (r_type == R_XTENSA_TLSDESC_FN)
	      {
		if (! info->shared || (tls_type & GOT_TLS_IE) != 0)
		  r_type = R_XTENSA_NONE;
	      }
	    else if (r_type == R_XTENSA_TLSDESC_ARG)
	      {
		if (info->shared)
		  {
		    if ((tls_type & GOT_TLS_IE) != 0)
		      r_type = R_XTENSA_TLS_TPOFF;
		  }
		else
		  {
		    r_type = R_XTENSA_TLS_TPOFF;
		    if (! dynamic_symbol)
		      {
			relocation = tpoff (info, relocation);
			break;
		      }
		  }
	      }

	    if (r_type == R_XTENSA_NONE)
	      /* Nothing to do here; skip to the next reloc.  */
	      continue;

	    if (! elf_hash_table (info)->dynamic_sections_created)
	      {
		error_message =
		  _("TLS relocation invalid without dynamic sections");
		if (!((*info->callbacks->reloc_dangerous)
		      (info, error_message, input_bfd, input_section,
		       rel->r_offset)))
		  return FALSE;
	      }
	    else
	      {
		Elf_Internal_Rela outrel;
		bfd_byte *loc;
		asection *srel = htab->srelgot;
		int indx;

		outrel.r_offset = (input_section->output_section->vma
				   + input_section->output_offset
				   + rel->r_offset);

		/* Complain if the relocation is in a read-only section
		   and not in a literal pool.  */
		if ((input_section->flags & SEC_READONLY) != 0
		    && ! elf_xtensa_in_literal_pool (lit_table, ltblsize,
						     outrel.r_offset))
		  {
		    error_message =
		      _("dynamic relocation in read-only section");
		    if (!((*info->callbacks->reloc_dangerous)
			  (info, error_message, input_bfd, input_section,
			   rel->r_offset)))
		      return FALSE;
		  }

		indx = h && h->dynindx != -1 ? h->dynindx : 0;
		if (indx == 0)
		  outrel.r_addend = relocation - dtpoff_base (info);
		else
		  outrel.r_addend = 0;
		rel->r_addend = 0;

		outrel.r_info = ELF32_R_INFO (indx, r_type);
		relocation = 0;
		unresolved_reloc = FALSE;

		BFD_ASSERT (srel);
		loc = (srel->contents
		       + srel->reloc_count++ * sizeof (Elf32_External_Rela));
		bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		BFD_ASSERT (sizeof (Elf32_External_Rela) * srel->reloc_count
			    <= srel->size);
	      }
	  }
	  break;

	case R_XTENSA_TLS_DTPOFF:
	  if (! info->shared)
	    /* Switch from LD model to LE model.  */
	    relocation = tpoff (info, relocation);
	  else
	    relocation -= dtpoff_base (info);
	  break;

	case R_XTENSA_TLS_FUNC:
	case R_XTENSA_TLS_ARG:
	case R_XTENSA_TLS_CALL:
	  /* Check if optimizing to IE or LE model.  */
	  if ((tls_type & GOT_TLS_IE) != 0)
	    {
	      bfd_boolean is_ld_model =
		(h && elf_xtensa_hash_entry (h) == htab->tlsbase);
	      if (! replace_tls_insn (rel, input_bfd, input_section, contents,
				      is_ld_model, &error_message))
		{
		  if (!((*info->callbacks->reloc_dangerous)
			(info, error_message, input_bfd, input_section,
			 rel->r_offset)))
		    return FALSE;
		}

	      if (r_type != R_XTENSA_TLS_ARG || is_ld_model)
		{
		  /* Skip subsequent relocations on the same instruction.  */
		  while (rel + 1 < relend && rel[1].r_offset == rel->r_offset)
		    rel++;
		}
	    }
	  continue;

	default:
	  if (elf_hash_table (info)->dynamic_sections_created
	      && dynamic_symbol && (is_operand_relocation (r_type)
				    || r_type == R_XTENSA_32_PCREL))
	    {
	      error_message =
		vsprint_msg ("invalid relocation for dynamic symbol", ": %s",
			     strlen (name) + 2, name);
	      if (!((*info->callbacks->reloc_dangerous)
		    (info, error_message, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      continue;
	    }
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     name);
	  return FALSE;
	}

      /* TLS optimizations may have changed r_type; update "howto".  */
      howto = &elf_howto_table[r_type];

      /* There's no point in calling bfd_perform_relocation here.
	 Just go directly to our "special function".  */
      r = elf_xtensa_do_reloc (howto, input_bfd, input_section,
			       relocation + rel->r_addend,
			       contents, rel->r_offset, is_weak_undef,
			       &error_message);

      if (r != bfd_reloc_ok && !warned)
	{
	  BFD_ASSERT (r == bfd_reloc_dangerous || r == bfd_reloc_other);
	  BFD_ASSERT (error_message != NULL);

	  if (rel->r_addend == 0)
	    error_message = vsprint_msg (error_message, ": %s",
					 strlen (name) + 2, name);
	  else
	    error_message = vsprint_msg (error_message, ": (%s+0x%x)",
					 strlen (name) + 22,
					 name, (int) rel->r_addend);

	  if (!((*info->callbacks->reloc_dangerous)
		(info, error_message, input_bfd, input_section,
		 rel->r_offset)))
	    return FALSE;
	}
    }

  if (lit_table)
    free (lit_table);

  input_section->reloc_done = TRUE;

  return TRUE;
}


/* Finish up dynamic symbol handling.  There's not much to do here since
   the PLT and GOT entries are all set up by relocate_section.  */

static bfd_boolean
elf_xtensa_finish_dynamic_symbol (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
{
  if (h->needs_plt && !h->def_regular)
    {
      /* Mark the symbol as undefined, rather than as defined in
	 the .plt section.  Leave the value alone.  */
      sym->st_shndx = SHN_UNDEF;
      /* If the symbol is weak, we do need to clear the value.
	 Otherwise, the PLT entry would provide a definition for
	 the symbol even if the symbol wasn't defined anywhere,
	 and so the symbol would never be NULL.  */
      if (!h->ref_regular_nonweak)
	sym->st_value = 0;
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}


/* Combine adjacent literal table entries in the output.  Adjacent
   entries within each input section may have been removed during
   relaxation, but we repeat the process here, even though it's too late
   to shrink the output section, because it's important to minimize the
   number of literal table entries to reduce the start-up work for the
   runtime linker.  Returns the number of remaining table entries or -1
   on error.  */

static int
elf_xtensa_combine_prop_entries (bfd *output_bfd,
				 asection *sxtlit,
				 asection *sgotloc)
{
  bfd_byte *contents;
  property_table_entry *table;
  bfd_size_type section_size, sgotloc_size;
  bfd_vma offset;
  int n, m, num;

  section_size = sxtlit->size;
  BFD_ASSERT (section_size % 8 == 0);
  num = section_size / 8;

  sgotloc_size = sgotloc->size;
  if (sgotloc_size != section_size)
    {
      (*_bfd_error_handler)
	(_("internal inconsistency in size of .got.loc section"));
      return -1;
    }

  table = bfd_malloc (num * sizeof (property_table_entry));
  if (table == 0)
    return -1;

  /* The ".xt.lit.plt" section has the SEC_IN_MEMORY flag set and this
     propagates to the output section, where it doesn't really apply and
     where it breaks the following call to bfd_malloc_and_get_section.  */
  sxtlit->flags &= ~SEC_IN_MEMORY;

  if (!bfd_malloc_and_get_section (output_bfd, sxtlit, &contents))
    {
      if (contents != 0)
	free (contents);
      free (table);
      return -1;
    }

  /* There should never be any relocations left at this point, so this
     is quite a bit easier than what is done during relaxation.  */

  /* Copy the raw contents into a property table array and sort it.  */
  offset = 0;
  for (n = 0; n < num; n++)
    {
      table[n].address = bfd_get_32 (output_bfd, &contents[offset]);
      table[n].size = bfd_get_32 (output_bfd, &contents[offset + 4]);
      offset += 8;
    }
  qsort (table, num, sizeof (property_table_entry), property_table_compare);

  for (n = 0; n < num; n++)
    {
      bfd_boolean remove_entry = FALSE;

      if (table[n].size == 0)
	remove_entry = TRUE;
      else if (n > 0
	       && (table[n-1].address + table[n-1].size == table[n].address))
	{
	  table[n-1].size += table[n].size;
	  remove_entry = TRUE;
	}

      if (remove_entry)
	{
	  for (m = n; m < num - 1; m++)
	    {
	      table[m].address = table[m+1].address;
	      table[m].size = table[m+1].size;
	    }

	  n--;
	  num--;
	}
    }

  /* Copy the data back to the raw contents.  */
  offset = 0;
  for (n = 0; n < num; n++)
    {
      bfd_put_32 (output_bfd, table[n].address, &contents[offset]);
      bfd_put_32 (output_bfd, table[n].size, &contents[offset + 4]);
      offset += 8;
    }

  /* Clear the removed bytes.  */
  if ((bfd_size_type) (num * 8) < section_size)
    memset (&contents[num * 8], 0, section_size - num * 8);

  if (! bfd_set_section_contents (output_bfd, sxtlit, contents, 0,
				  section_size))
    return -1;

  /* Copy the contents to ".got.loc".  */
  memcpy (sgotloc->contents, contents, section_size);

  free (contents);
  free (table);
  return num;
}


/* Finish up the dynamic sections.  */

static bfd_boolean
elf_xtensa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  struct elf_xtensa_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn, *srelplt, *sgot, *sxtlit, *sgotloc;
  Elf32_External_Dyn *dyncon, *dynconend;
  int num_xtlit_entries = 0;

  if (! elf_hash_table (info)->dynamic_sections_created)
    return TRUE;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  sgot = htab->sgot;
  if (sgot)
    {
      BFD_ASSERT (sgot->size == 4);
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
    }

  srelplt = htab->srelplt;
  if (srelplt && srelplt->size != 0)
    {
      asection *sgotplt, *srelgot, *spltlittbl;
      int chunk, plt_chunks, plt_entries;
      Elf_Internal_Rela irela;
      bfd_byte *loc;
      unsigned rtld_reloc;

      srelgot = htab->srelgot;
      spltlittbl = htab->spltlittbl;
      BFD_ASSERT (srelgot != NULL && spltlittbl != NULL);

      /* Find the first XTENSA_RTLD relocation.  Presumably the rest
	 of them follow immediately after....  */
      for (rtld_reloc = 0; rtld_reloc < srelgot->reloc_count; rtld_reloc++)
	{
	  loc = srelgot->contents + rtld_reloc * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_in (output_bfd, loc, &irela);
	  if (ELF32_R_TYPE (irela.r_info) == R_XTENSA_RTLD)
	    break;
	}
      BFD_ASSERT (rtld_reloc < srelgot->reloc_count);

      plt_entries = srelplt->size / sizeof (Elf32_External_Rela);
      plt_chunks =
	(plt_entries + PLT_ENTRIES_PER_CHUNK - 1) / PLT_ENTRIES_PER_CHUNK;

      for (chunk = 0; chunk < plt_chunks; chunk++)
	{
	  int chunk_entries = 0;

	  sgotplt = elf_xtensa_get_gotplt_section (info, chunk);
	  BFD_ASSERT (sgotplt != NULL);

	  /* Emit special RTLD relocations for the first two entries in
	     each chunk of the .got.plt section.  */

	  loc = srelgot->contents + rtld_reloc * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_in (output_bfd, loc, &irela);
	  BFD_ASSERT (ELF32_R_TYPE (irela.r_info) == R_XTENSA_RTLD);
	  irela.r_offset = (sgotplt->output_section->vma
			    + sgotplt->output_offset);
	  irela.r_addend = 1; /* tell rtld to set value to resolver function */
	  bfd_elf32_swap_reloca_out (output_bfd, &irela, loc);
	  rtld_reloc += 1;
	  BFD_ASSERT (rtld_reloc <= srelgot->reloc_count);

	  /* Next literal immediately follows the first.  */
	  loc += sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_in (output_bfd, loc, &irela);
	  BFD_ASSERT (ELF32_R_TYPE (irela.r_info) == R_XTENSA_RTLD);
	  irela.r_offset = (sgotplt->output_section->vma
			    + sgotplt->output_offset + 4);
	  /* Tell rtld to set value to object's link map.  */
	  irela.r_addend = 2;
	  bfd_elf32_swap_reloca_out (output_bfd, &irela, loc);
	  rtld_reloc += 1;
	  BFD_ASSERT (rtld_reloc <= srelgot->reloc_count);

	  /* Fill in the literal table.  */
	  if (chunk < plt_chunks - 1)
	    chunk_entries = PLT_ENTRIES_PER_CHUNK;
	  else
	    chunk_entries = plt_entries - (chunk * PLT_ENTRIES_PER_CHUNK);

	  BFD_ASSERT ((unsigned) (chunk + 1) * 8 <= spltlittbl->size);
	  bfd_put_32 (output_bfd,
		      sgotplt->output_section->vma + sgotplt->output_offset,
		      spltlittbl->contents + (chunk * 8) + 0);
	  bfd_put_32 (output_bfd,
		      8 + (chunk_entries * 4),
		      spltlittbl->contents + (chunk * 8) + 4);
	}

      /* All the dynamic relocations have been emitted at this point.
	 Make sure the relocation sections are the correct size.  */
      if (srelgot->size != (sizeof (Elf32_External_Rela)
			    * srelgot->reloc_count)
	  || srelplt->size != (sizeof (Elf32_External_Rela)
			       * srelplt->reloc_count))
	abort ();

     /* The .xt.lit.plt section has just been modified.  This must
	happen before the code below which combines adjacent literal
	table entries, and the .xt.lit.plt contents have to be forced to
	the output here.  */
      if (! bfd_set_section_contents (output_bfd,
				      spltlittbl->output_section,
				      spltlittbl->contents,
				      spltlittbl->output_offset,
				      spltlittbl->size))
	return FALSE;
      /* Clear SEC_HAS_CONTENTS so the contents won't be output again.  */
      spltlittbl->flags &= ~SEC_HAS_CONTENTS;
    }

  /* Combine adjacent literal table entries.  */
  BFD_ASSERT (! info->relocatable);
  sxtlit = bfd_get_section_by_name (output_bfd, ".xt.lit");
  sgotloc = htab->sgotloc;
  BFD_ASSERT (sgotloc);
  if (sxtlit)
    {
      num_xtlit_entries =
	elf_xtensa_combine_prop_entries (output_bfd, sxtlit, sgotloc);
      if (num_xtlit_entries < 0)
	return FALSE;
    }

  dyncon = (Elf32_External_Dyn *) sdyn->contents;
  dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
  for (; dyncon < dynconend; dyncon++)
    {
      Elf_Internal_Dyn dyn;

      bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

      switch (dyn.d_tag)
	{
	default:
	  break;

	case DT_XTENSA_GOT_LOC_SZ:
	  dyn.d_un.d_val = num_xtlit_entries;
	  break;

	case DT_XTENSA_GOT_LOC_OFF:
	  dyn.d_un.d_ptr = htab->sgotloc->output_section->vma;
	  break;

	case DT_PLTGOT:
	  dyn.d_un.d_ptr = htab->sgot->output_section->vma;
	  break;

	case DT_JMPREL:
	  dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
	  break;

	case DT_PLTRELSZ:
	  dyn.d_un.d_val = htab->srelplt->output_section->size;
	  break;

	case DT_RELASZ:
	  /* Adjust RELASZ to not include JMPREL.  This matches what
	     glibc expects and what is done for several other ELF
	     targets (e.g., i386, alpha), but the "correct" behavior
	     seems to be unresolved.  Since the linker script arranges
	     for .rela.plt to follow all other relocation sections, we
	     don't have to worry about changing the DT_RELA entry.  */
	  if (htab->srelplt)
	    dyn.d_un.d_val -= htab->srelplt->output_section->size;
	  break;
	}

      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
    }

  return TRUE;
}


/* Functions for dealing with the e_flags field.  */

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf_xtensa_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  unsigned out_mach, in_mach;
  flagword out_flag, in_flag;

  /* Check if we have the same endianness.  */
  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  /* Don't even pretend to support mixed-format linking.  */
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return FALSE;

  out_flag = elf_elfheader (obfd)->e_flags;
  in_flag = elf_elfheader (ibfd)->e_flags;

  out_mach = out_flag & EF_XTENSA_MACH;
  in_mach = in_flag & EF_XTENSA_MACH;
  if (out_mach != in_mach)
    {
      (*_bfd_error_handler)
	(_("%B: incompatible machine type. Output is 0x%x. Input is 0x%x"),
	 ibfd, out_mach, in_mach);
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flag;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				  bfd_get_mach (ibfd));

      return TRUE;
    }

  if ((out_flag & EF_XTENSA_XT_INSN) != (in_flag & EF_XTENSA_XT_INSN))
    elf_elfheader (obfd)->e_flags &= (~ EF_XTENSA_XT_INSN);

  if ((out_flag & EF_XTENSA_XT_LIT) != (in_flag & EF_XTENSA_XT_LIT))
    elf_elfheader (obfd)->e_flags &= (~ EF_XTENSA_XT_LIT);

  return TRUE;
}


static bfd_boolean
elf_xtensa_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags |= flags;
  elf_flags_init (abfd) = TRUE;

  return TRUE;
}


static bfd_boolean
elf_xtensa_print_private_bfd_data (bfd *abfd, void *farg)
{
  FILE *f = (FILE *) farg;
  flagword e_flags = elf_elfheader (abfd)->e_flags;

  fprintf (f, "\nXtensa header:\n");
  if ((e_flags & EF_XTENSA_MACH) == E_XTENSA_MACH)
    fprintf (f, "\nMachine     = Base\n");
  else
    fprintf (f, "\nMachine Id  = 0x%x\n", e_flags & EF_XTENSA_MACH);

  fprintf (f, "Insn tables = %s\n",
	   (e_flags & EF_XTENSA_XT_INSN) ? "true" : "false");

  fprintf (f, "Literal tables = %s\n",
	   (e_flags & EF_XTENSA_XT_LIT) ? "true" : "false");

  return _bfd_elf_print_private_bfd_data (abfd, farg);
}


/* Set the right machine number for an Xtensa ELF file.  */

static bfd_boolean
elf_xtensa_object_p (bfd *abfd)
{
  int mach;
  unsigned long arch = elf_elfheader (abfd)->e_flags & EF_XTENSA_MACH;

  switch (arch)
    {
    case E_XTENSA_MACH:
      mach = bfd_mach_xtensa;
      break;
    default:
      return FALSE;
    }

  (void) bfd_default_set_arch_mach (abfd, bfd_arch_xtensa, mach);
  return TRUE;
}


/* The final processing done just before writing out an Xtensa ELF object
   file.  This gets the Xtensa architecture right based on the machine
   number.  */

static void
elf_xtensa_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
  int mach;
  unsigned long val;

  switch (mach = bfd_get_mach (abfd))
    {
    case bfd_mach_xtensa:
      val = E_XTENSA_MACH;
      break;
    default:
      return;
    }

  elf_elfheader (abfd)->e_flags &=  (~ EF_XTENSA_MACH);
  elf_elfheader (abfd)->e_flags |= val;
}


static enum elf_reloc_type_class
elf_xtensa_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_XTENSA_RELATIVE:
      return reloc_class_relative;
    case R_XTENSA_JMP_SLOT:
      return reloc_class_plt;
    default:
      return reloc_class_normal;
    }
}


static bfd_boolean
elf_xtensa_discard_info_for_section (bfd *abfd,
				     struct elf_reloc_cookie *cookie,
				     struct bfd_link_info *info,
				     asection *sec)
{
  bfd_byte *contents;
  bfd_vma offset, actual_offset;
  bfd_size_type removed_bytes = 0;
  bfd_size_type entry_size;

  if (sec->output_section
      && bfd_is_abs_section (sec->output_section))
    return FALSE;

  if (xtensa_is_proptable_section (sec))
    entry_size = 12;
  else
    entry_size = 8;

  if (sec->size == 0 || sec->size % entry_size != 0)
    return FALSE;

  contents = retrieve_contents (abfd, sec, info->keep_memory);
  if (!contents)
    return FALSE;

  cookie->rels = retrieve_internal_relocs (abfd, sec, info->keep_memory);
  if (!cookie->rels)
    {
      release_contents (sec, contents);
      return FALSE;
    }

  /* Sort the relocations.  They should already be in order when
     relaxation is enabled, but it might not be.  */
  qsort (cookie->rels, sec->reloc_count, sizeof (Elf_Internal_Rela),
	 internal_reloc_compare);

  cookie->rel = cookie->rels;
  cookie->relend = cookie->rels + sec->reloc_count;

  for (offset = 0; offset < sec->size; offset += entry_size)
    {
      actual_offset = offset - removed_bytes;

      /* The ...symbol_deleted_p function will skip over relocs but it
	 won't adjust their offsets, so do that here.  */
      while (cookie->rel < cookie->relend
	     && cookie->rel->r_offset < offset)
	{
	  cookie->rel->r_offset -= removed_bytes;
	  cookie->rel++;
	}

      while (cookie->rel < cookie->relend
	     && cookie->rel->r_offset == offset)
	{
	  if (bfd_elf_reloc_symbol_deleted_p (offset, cookie))
	    {
	      /* Remove the table entry.  (If the reloc type is NONE, then
		 the entry has already been merged with another and deleted
		 during relaxation.)  */
	      if (ELF32_R_TYPE (cookie->rel->r_info) != R_XTENSA_NONE)
		{
		  /* Shift the contents up.  */
		  if (offset + entry_size < sec->size)
		    memmove (&contents[actual_offset],
			     &contents[actual_offset + entry_size],
			     sec->size - offset - entry_size);
		  removed_bytes += entry_size;
		}

	      /* Remove this relocation.  */
	      cookie->rel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	    }

	  /* Adjust the relocation offset for previous removals.  This
	     should not be done before calling ...symbol_deleted_p
	     because it might mess up the offset comparisons there.
	     Make sure the offset doesn't underflow in the case where
	     the first entry is removed.  */
	  if (cookie->rel->r_offset >= removed_bytes)
	    cookie->rel->r_offset -= removed_bytes;
	  else
	    cookie->rel->r_offset = 0;

	  cookie->rel++;
	}
    }

  if (removed_bytes != 0)
    {
      /* Adjust any remaining relocs (shouldn't be any).  */
      for (; cookie->rel < cookie->relend; cookie->rel++)
	{
	  if (cookie->rel->r_offset >= removed_bytes)
	    cookie->rel->r_offset -= removed_bytes;
	  else
	    cookie->rel->r_offset = 0;
	}

      /* Clear the removed bytes.  */
      memset (&contents[sec->size - removed_bytes], 0, removed_bytes);

      pin_contents (sec, contents);
      pin_internal_relocs (sec, cookie->rels);

      /* Shrink size.  */
      if (sec->rawsize == 0)
	sec->rawsize = sec->size;
      sec->size -= removed_bytes;

      if (xtensa_is_littable_section (sec))
	{
	  asection *sgotloc = elf_xtensa_hash_table (info)->sgotloc;
	  if (sgotloc)
	    sgotloc->size -= removed_bytes;
	}
    }
  else
    {
      release_contents (sec, contents);
      release_internal_relocs (sec, cookie->rels);
    }

  return (removed_bytes != 0);
}


static bfd_boolean
elf_xtensa_discard_info (bfd *abfd,
			 struct elf_reloc_cookie *cookie,
			 struct bfd_link_info *info)
{
  asection *sec;
  bfd_boolean changed = FALSE;

  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      if (xtensa_is_property_section (sec))
	{
	  if (elf_xtensa_discard_info_for_section (abfd, cookie, info, sec))
	    changed = TRUE;
	}
    }

  return changed;
}


static bfd_boolean
elf_xtensa_ignore_discarded_relocs (asection *sec)
{
  return xtensa_is_property_section (sec);
}


static unsigned int
elf_xtensa_action_discarded (asection *sec)
{
  if (strcmp (".xt_except_table", sec->name) == 0)
    return 0;

  if (strcmp (".xt_except_desc", sec->name) == 0)
    return 0;

  return _bfd_elf_default_action_discarded (sec);
}


/* Support for core dump NOTE sections.  */

static bfd_boolean
elf_xtensa_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int size;

  /* The size for Xtensa is variable, so don't try to recognize the format
     based on the size.  Just assume this is GNU/Linux.  */

  /* pr_cursig */
  elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

  /* pr_pid */
  elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

  /* pr_reg */
  offset = 72;
  size = note->descsz - offset - 4;

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}


static bfd_boolean
elf_xtensa_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 128:		/* GNU/Linux elf_prpsinfo */
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}


/* Generic Xtensa configurability stuff.  */

static xtensa_opcode callx0_op = XTENSA_UNDEFINED;
static xtensa_opcode callx4_op = XTENSA_UNDEFINED;
static xtensa_opcode callx8_op = XTENSA_UNDEFINED;
static xtensa_opcode callx12_op = XTENSA_UNDEFINED;
static xtensa_opcode call0_op = XTENSA_UNDEFINED;
static xtensa_opcode call4_op = XTENSA_UNDEFINED;
static xtensa_opcode call8_op = XTENSA_UNDEFINED;
static xtensa_opcode call12_op = XTENSA_UNDEFINED;

static void
init_call_opcodes (void)
{
  if (callx0_op == XTENSA_UNDEFINED)
    {
      callx0_op  = xtensa_opcode_lookup (xtensa_default_isa, "callx0");
      callx4_op  = xtensa_opcode_lookup (xtensa_default_isa, "callx4");
      callx8_op  = xtensa_opcode_lookup (xtensa_default_isa, "callx8");
      callx12_op = xtensa_opcode_lookup (xtensa_default_isa, "callx12");
      call0_op   = xtensa_opcode_lookup (xtensa_default_isa, "call0");
      call4_op   = xtensa_opcode_lookup (xtensa_default_isa, "call4");
      call8_op   = xtensa_opcode_lookup (xtensa_default_isa, "call8");
      call12_op  = xtensa_opcode_lookup (xtensa_default_isa, "call12");
    }
}


static bfd_boolean
is_indirect_call_opcode (xtensa_opcode opcode)
{
  init_call_opcodes ();
  return (opcode == callx0_op
	  || opcode == callx4_op
	  || opcode == callx8_op
	  || opcode == callx12_op);
}


static bfd_boolean
is_direct_call_opcode (xtensa_opcode opcode)
{
  init_call_opcodes ();
  return (opcode == call0_op
	  || opcode == call4_op
	  || opcode == call8_op
	  || opcode == call12_op);
}


static bfd_boolean
is_windowed_call_opcode (xtensa_opcode opcode)
{
  init_call_opcodes ();
  return (opcode == call4_op
	  || opcode == call8_op
	  || opcode == call12_op
	  || opcode == callx4_op
	  || opcode == callx8_op
	  || opcode == callx12_op);
}


static bfd_boolean
get_indirect_call_dest_reg (xtensa_opcode opcode, unsigned *pdst)
{
  unsigned dst = (unsigned) -1;

  init_call_opcodes ();
  if (opcode == callx0_op)
    dst = 0;
  else if (opcode == callx4_op)
    dst = 4;
  else if (opcode == callx8_op)
    dst = 8;
  else if (opcode == callx12_op)
    dst = 12;

  if (dst == (unsigned) -1)
    return FALSE;

  *pdst = dst;
  return TRUE;
}


static xtensa_opcode
get_const16_opcode (void)
{
  static bfd_boolean done_lookup = FALSE;
  static xtensa_opcode const16_opcode = XTENSA_UNDEFINED;
  if (!done_lookup)
    {
      const16_opcode = xtensa_opcode_lookup (xtensa_default_isa, "const16");
      done_lookup = TRUE;
    }
  return const16_opcode;
}


static xtensa_opcode
get_l32r_opcode (void)
{
  static xtensa_opcode l32r_opcode = XTENSA_UNDEFINED;
  static bfd_boolean done_lookup = FALSE;

  if (!done_lookup)
    {
      l32r_opcode = xtensa_opcode_lookup (xtensa_default_isa, "l32r");
      done_lookup = TRUE;
    }
  return l32r_opcode;
}


static bfd_vma
l32r_offset (bfd_vma addr, bfd_vma pc)
{
  bfd_vma offset;

  offset = addr - ((pc+3) & -4);
  BFD_ASSERT ((offset & ((1 << 2) - 1)) == 0);
  offset = (signed int) offset >> 2;
  BFD_ASSERT ((signed int) offset >> 16 == -1);
  return offset;
}


static int
get_relocation_opnd (xtensa_opcode opcode, int r_type)
{
  xtensa_isa isa = xtensa_default_isa;
  int last_immed, last_opnd, opi;

  if (opcode == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  /* Find the last visible PC-relative immediate operand for the opcode.
     If there are no PC-relative immediates, then choose the last visible
     immediate; otherwise, fail and return XTENSA_UNDEFINED.  */
  last_immed = XTENSA_UNDEFINED;
  last_opnd = xtensa_opcode_num_operands (isa, opcode);
  for (opi = last_opnd - 1; opi >= 0; opi--)
    {
      if (xtensa_operand_is_visible (isa, opcode, opi) == 0)
	continue;
      if (xtensa_operand_is_PCrelative (isa, opcode, opi) == 1)
	{
	  last_immed = opi;
	  break;
	}
      if (last_immed == XTENSA_UNDEFINED
	  && xtensa_operand_is_register (isa, opcode, opi) == 0)
	last_immed = opi;
    }
  if (last_immed < 0)
    return XTENSA_UNDEFINED;

  /* If the operand number was specified in an old-style relocation,
     check for consistency with the operand computed above.  */
  if (r_type >= R_XTENSA_OP0 && r_type <= R_XTENSA_OP2)
    {
      int reloc_opnd = r_type - R_XTENSA_OP0;
      if (reloc_opnd != last_immed)
	return XTENSA_UNDEFINED;
    }

  return last_immed;
}


int
get_relocation_slot (int r_type)
{
  switch (r_type)
    {
    case R_XTENSA_OP0:
    case R_XTENSA_OP1:
    case R_XTENSA_OP2:
      return 0;

    default:
      if (r_type >= R_XTENSA_SLOT0_OP && r_type <= R_XTENSA_SLOT14_OP)
	return r_type - R_XTENSA_SLOT0_OP;
      if (r_type >= R_XTENSA_SLOT0_ALT && r_type <= R_XTENSA_SLOT14_ALT)
	return r_type - R_XTENSA_SLOT0_ALT;
      break;
    }

  return XTENSA_UNDEFINED;
}


/* Get the opcode for a relocation.  */

static xtensa_opcode
get_relocation_opcode (bfd *abfd,
		       asection *sec,
		       bfd_byte *contents,
		       Elf_Internal_Rela *irel)
{
  static xtensa_insnbuf ibuff = NULL;
  static xtensa_insnbuf sbuff = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  int slot;

  if (contents == NULL)
    return XTENSA_UNDEFINED;

  if (bfd_get_section_limit (abfd, sec) <= irel->r_offset)
    return XTENSA_UNDEFINED;

  if (ibuff == NULL)
    {
      ibuff = xtensa_insnbuf_alloc (isa);
      sbuff = xtensa_insnbuf_alloc (isa);
    }

  /* Decode the instruction.  */
  xtensa_insnbuf_from_chars (isa, ibuff, &contents[irel->r_offset],
			     sec->size - irel->r_offset);
  fmt = xtensa_format_decode (isa, ibuff);
  slot = get_relocation_slot (ELF32_R_TYPE (irel->r_info));
  if (slot == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;
  xtensa_format_get_slot (isa, fmt, slot, ibuff, sbuff);
  return xtensa_opcode_decode (isa, fmt, slot, sbuff);
}


bfd_boolean
is_l32r_relocation (bfd *abfd,
		    asection *sec,
		    bfd_byte *contents,
		    Elf_Internal_Rela *irel)
{
  xtensa_opcode opcode;
  if (!is_operand_relocation (ELF32_R_TYPE (irel->r_info)))
    return FALSE;
  opcode = get_relocation_opcode (abfd, sec, contents, irel);
  return (opcode == get_l32r_opcode ());
}


static bfd_size_type
get_asm_simplify_size (bfd_byte *contents,
		       bfd_size_type content_len,
		       bfd_size_type offset)
{
  bfd_size_type insnlen, size = 0;

  /* Decode the size of the next two instructions.  */
  insnlen = insn_decode_len (contents, content_len, offset);
  if (insnlen == 0)
    return 0;

  size += insnlen;

  insnlen = insn_decode_len (contents, content_len, offset + size);
  if (insnlen == 0)
    return 0;

  size += insnlen;
  return size;
}


bfd_boolean
is_alt_relocation (int r_type)
{
  return (r_type >= R_XTENSA_SLOT0_ALT
	  && r_type <= R_XTENSA_SLOT14_ALT);
}


bfd_boolean
is_operand_relocation (int r_type)
{
  switch (r_type)
    {
    case R_XTENSA_OP0:
    case R_XTENSA_OP1:
    case R_XTENSA_OP2:
      return TRUE;

    default:
      if (r_type >= R_XTENSA_SLOT0_OP && r_type <= R_XTENSA_SLOT14_OP)
	return TRUE;
      if (r_type >= R_XTENSA_SLOT0_ALT && r_type <= R_XTENSA_SLOT14_ALT)
	return TRUE;
      break;
    }

  return FALSE;
}


#define MIN_INSN_LENGTH 2

/* Return 0 if it fails to decode.  */

bfd_size_type
insn_decode_len (bfd_byte *contents,
		 bfd_size_type content_len,
		 bfd_size_type offset)
{
  int insn_len;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  static xtensa_insnbuf ibuff = NULL;

  if (offset + MIN_INSN_LENGTH > content_len)
    return 0;

  if (ibuff == NULL)
    ibuff = xtensa_insnbuf_alloc (isa);
  xtensa_insnbuf_from_chars (isa, ibuff, &contents[offset],
			     content_len - offset);
  fmt = xtensa_format_decode (isa, ibuff);
  if (fmt == XTENSA_UNDEFINED)
    return 0;
  insn_len = xtensa_format_length (isa, fmt);
  if (insn_len ==  XTENSA_UNDEFINED)
    return 0;
  return insn_len;
}


/* Decode the opcode for a single slot instruction.
   Return 0 if it fails to decode or the instruction is multi-slot.  */

xtensa_opcode
insn_decode_opcode (bfd_byte *contents,
		    bfd_size_type content_len,
		    bfd_size_type offset,
		    int slot)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;

  if (offset + MIN_INSN_LENGTH > content_len)
    return XTENSA_UNDEFINED;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, &contents[offset],
			     content_len - offset);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (slot >= xtensa_format_num_slots (isa, fmt))
    return XTENSA_UNDEFINED;

  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  return xtensa_opcode_decode (isa, fmt, slot, slotbuf);
}


/* The offset is the offset in the contents.
   The address is the address of that offset.  */

static bfd_boolean
check_branch_target_aligned (bfd_byte *contents,
			     bfd_size_type content_length,
			     bfd_vma offset,
			     bfd_vma address)
{
  bfd_size_type insn_len = insn_decode_len (contents, content_length, offset);
  if (insn_len == 0)
    return FALSE;
  return check_branch_target_aligned_address (address, insn_len);
}


static bfd_boolean
check_loop_aligned (bfd_byte *contents,
		    bfd_size_type content_length,
		    bfd_vma offset,
		    bfd_vma address)
{
  bfd_size_type loop_len, insn_len;
  xtensa_opcode opcode;

  opcode = insn_decode_opcode (contents, content_length, offset, 0);
  if (opcode == XTENSA_UNDEFINED
      || xtensa_opcode_is_loop (xtensa_default_isa, opcode) != 1)
    {
      BFD_ASSERT (FALSE);
      return FALSE;
    }

  loop_len = insn_decode_len (contents, content_length, offset);
  insn_len = insn_decode_len (contents, content_length, offset + loop_len);
  if (loop_len == 0 || insn_len == 0)
    {
      BFD_ASSERT (FALSE);
      return FALSE;
    }

  return check_branch_target_aligned_address (address + loop_len, insn_len);
}


static bfd_boolean
check_branch_target_aligned_address (bfd_vma addr, int len)
{
  if (len == 8)
    return (addr % 8 == 0);
  return ((addr >> 2) == ((addr + len - 1) >> 2));
}


/* Instruction widening and narrowing.  */

/* When FLIX is available we need to access certain instructions only
   when they are 16-bit or 24-bit instructions.  This table caches
   information about such instructions by walking through all the
   opcodes and finding the smallest single-slot format into which each
   can be encoded.  */

static xtensa_format *op_single_fmt_table = NULL;


static void
init_op_single_format_table (void)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_insnbuf ibuf;
  xtensa_opcode opcode;
  xtensa_format fmt;
  int num_opcodes;

  if (op_single_fmt_table)
    return;

  ibuf = xtensa_insnbuf_alloc (isa);
  num_opcodes = xtensa_isa_num_opcodes (isa);

  op_single_fmt_table = (xtensa_format *)
    bfd_malloc (sizeof (xtensa_format) * num_opcodes);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      op_single_fmt_table[opcode] = XTENSA_UNDEFINED;
      for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
	{
	  if (xtensa_format_num_slots (isa, fmt) == 1
	      && xtensa_opcode_encode (isa, fmt, 0, ibuf, opcode) == 0)
	    {
	      xtensa_opcode old_fmt = op_single_fmt_table[opcode];
	      int fmt_length = xtensa_format_length (isa, fmt);
	      if (old_fmt == XTENSA_UNDEFINED
		  || fmt_length < xtensa_format_length (isa, old_fmt))
		op_single_fmt_table[opcode] = fmt;
	    }
	}
    }
  xtensa_insnbuf_free (isa, ibuf);
}


static xtensa_format
get_single_format (xtensa_opcode opcode)
{
  init_op_single_format_table ();
  return op_single_fmt_table[opcode];
}


/* For the set of narrowable instructions we do NOT include the
   narrowings beqz -> beqz.n or bnez -> bnez.n because of complexities
   involved during linker relaxation that may require these to
   re-expand in some conditions.  Also, the narrowing "or" -> mov.n
   requires special case code to ensure it only works when op1 == op2.  */

struct string_pair
{
  const char *wide;
  const char *narrow;
};

struct string_pair narrowable[] =
{
  { "add", "add.n" },
  { "addi", "addi.n" },
  { "addmi", "addi.n" },
  { "l32i", "l32i.n" },
  { "movi", "movi.n" },
  { "ret", "ret.n" },
  { "retw", "retw.n" },
  { "s32i", "s32i.n" },
  { "or", "mov.n" } /* special case only when op1 == op2 */
};

struct string_pair widenable[] =
{
  { "add", "add.n" },
  { "addi", "addi.n" },
  { "addmi", "addi.n" },
  { "beqz", "beqz.n" },
  { "bnez", "bnez.n" },
  { "l32i", "l32i.n" },
  { "movi", "movi.n" },
  { "ret", "ret.n" },
  { "retw", "retw.n" },
  { "s32i", "s32i.n" },
  { "or", "mov.n" } /* special case only when op1 == op2 */
};


/* Check if an instruction can be "narrowed", i.e., changed from a standard
   3-byte instruction to a 2-byte "density" instruction.  If it is valid,
   return the instruction buffer holding the narrow instruction.  Otherwise,
   return 0.  The set of valid narrowing are specified by a string table
   but require some special case operand checks in some cases.  */

static xtensa_insnbuf
can_narrow_instruction (xtensa_insnbuf slotbuf,
			xtensa_format fmt,
			xtensa_opcode opcode)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format o_fmt;
  unsigned opi;

  static xtensa_insnbuf o_insnbuf = NULL;
  static xtensa_insnbuf o_slotbuf = NULL;

  if (o_insnbuf == NULL)
    {
      o_insnbuf = xtensa_insnbuf_alloc (isa);
      o_slotbuf = xtensa_insnbuf_alloc (isa);
    }

  for (opi = 0; opi < (sizeof (narrowable)/sizeof (struct string_pair)); opi++)
    {
      bfd_boolean is_or = (strcmp ("or", narrowable[opi].wide) == 0);

      if (opcode == xtensa_opcode_lookup (isa, narrowable[opi].wide))
	{
	  uint32 value, newval;
	  int i, operand_count, o_operand_count;
	  xtensa_opcode o_opcode;

	  /* Address does not matter in this case.  We might need to
	     fix it to handle branches/jumps.  */
	  bfd_vma self_address = 0;

	  o_opcode = xtensa_opcode_lookup (isa, narrowable[opi].narrow);
	  if (o_opcode == XTENSA_UNDEFINED)
	    return 0;
	  o_fmt = get_single_format (o_opcode);
	  if (o_fmt == XTENSA_UNDEFINED)
	    return 0;

	  if (xtensa_format_length (isa, fmt) != 3
	      || xtensa_format_length (isa, o_fmt) != 2)
	    return 0;

	  xtensa_format_encode (isa, o_fmt, o_insnbuf);
	  operand_count = xtensa_opcode_num_operands (isa, opcode);
	  o_operand_count = xtensa_opcode_num_operands (isa, o_opcode);

	  if (xtensa_opcode_encode (isa, o_fmt, 0, o_slotbuf, o_opcode) != 0)
	    return 0;

	  if (!is_or)
	    {
	      if (xtensa_opcode_num_operands (isa, o_opcode) != operand_count)
		return 0;
	    }
	  else
	    {
	      uint32 rawval0, rawval1, rawval2;

	      if (o_operand_count + 1 != operand_count
		  || xtensa_operand_get_field (isa, opcode, 0,
					       fmt, 0, slotbuf, &rawval0) != 0
		  || xtensa_operand_get_field (isa, opcode, 1,
					       fmt, 0, slotbuf, &rawval1) != 0
		  || xtensa_operand_get_field (isa, opcode, 2,
					       fmt, 0, slotbuf, &rawval2) != 0
		  || rawval1 != rawval2
		  || rawval0 == rawval1 /* it is a nop */)
		return 0;
	    }

	  for (i = 0; i < o_operand_count; ++i)
	    {
	      if (xtensa_operand_get_field (isa, opcode, i, fmt, 0,
					    slotbuf, &value)
		  || xtensa_operand_decode (isa, opcode, i, &value))
		return 0;

	      /* PC-relative branches need adjustment, but
		 the PC-rel operand will always have a relocation.  */
	      newval = value;
	      if (xtensa_operand_do_reloc (isa, o_opcode, i, &newval,
					   self_address)
		  || xtensa_operand_encode (isa, o_opcode, i, &newval)
		  || xtensa_operand_set_field (isa, o_opcode, i, o_fmt, 0,
					       o_slotbuf, newval))
		return 0;
	    }

	  if (xtensa_format_set_slot (isa, o_fmt, 0, o_insnbuf, o_slotbuf))
	    return 0;

	  return o_insnbuf;
	}
    }
  return 0;
}


/* Attempt to narrow an instruction.  If the narrowing is valid, perform
   the action in-place directly into the contents and return TRUE.  Otherwise,
   the return value is FALSE and the contents are not modified.  */

static bfd_boolean
narrow_instruction (bfd_byte *contents,
		    bfd_size_type content_length,
		    bfd_size_type offset)
{
  xtensa_opcode opcode;
  bfd_size_type insn_len;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  xtensa_insnbuf o_insnbuf;

  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  BFD_ASSERT (offset < content_length);

  if (content_length < 2)
    return FALSE;

  /* We will hand-code a few of these for a little while.
     These have all been specified in the assembler aleady.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, &contents[offset],
			     content_length - offset);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;

  if (xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf) != 0)
    return FALSE;

  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
  insn_len = xtensa_format_length (isa, fmt);
  if (insn_len > content_length)
    return FALSE;

  o_insnbuf = can_narrow_instruction (slotbuf, fmt, opcode);
  if (o_insnbuf)
    {
      xtensa_insnbuf_to_chars (isa, o_insnbuf, contents + offset,
			       content_length - offset);
      return TRUE;
    }

  return FALSE;
}


/* Check if an instruction can be "widened", i.e., changed from a 2-byte
   "density" instruction to a standard 3-byte instruction.  If it is valid,
   return the instruction buffer holding the wide instruction.  Otherwise,
   return 0.  The set of valid widenings are specified by a string table
   but require some special case operand checks in some cases.  */

static xtensa_insnbuf
can_widen_instruction (xtensa_insnbuf slotbuf,
		       xtensa_format fmt,
		       xtensa_opcode opcode)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format o_fmt;
  unsigned opi;

  static xtensa_insnbuf o_insnbuf = NULL;
  static xtensa_insnbuf o_slotbuf = NULL;

  if (o_insnbuf == NULL)
    {
      o_insnbuf = xtensa_insnbuf_alloc (isa);
      o_slotbuf = xtensa_insnbuf_alloc (isa);
    }

  for (opi = 0; opi < (sizeof (widenable)/sizeof (struct string_pair)); opi++)
    {
      bfd_boolean is_or = (strcmp ("or", widenable[opi].wide) == 0);
      bfd_boolean is_branch = (strcmp ("beqz", widenable[opi].wide) == 0
			       || strcmp ("bnez", widenable[opi].wide) == 0);

      if (opcode == xtensa_opcode_lookup (isa, widenable[opi].narrow))
	{
	  uint32 value, newval;
	  int i, operand_count, o_operand_count, check_operand_count;
	  xtensa_opcode o_opcode;

	  /* Address does not matter in this case.  We might need to fix it
	     to handle branches/jumps.  */
	  bfd_vma self_address = 0;

	  o_opcode = xtensa_opcode_lookup (isa, widenable[opi].wide);
	  if (o_opcode == XTENSA_UNDEFINED)
	    return 0;
	  o_fmt = get_single_format (o_opcode);
	  if (o_fmt == XTENSA_UNDEFINED)
	    return 0;

	  if (xtensa_format_length (isa, fmt) != 2
	      || xtensa_format_length (isa, o_fmt) != 3)
	    return 0;

	  xtensa_format_encode (isa, o_fmt, o_insnbuf);
	  operand_count = xtensa_opcode_num_operands (isa, opcode);
	  o_operand_count = xtensa_opcode_num_operands (isa, o_opcode);
	  check_operand_count = o_operand_count;

	  if (xtensa_opcode_encode (isa, o_fmt, 0, o_slotbuf, o_opcode) != 0)
	    return 0;

	  if (!is_or)
	    {
	      if (xtensa_opcode_num_operands (isa, o_opcode) != operand_count)
		return 0;
	    }
	  else
	    {
	      uint32 rawval0, rawval1;

	      if (o_operand_count != operand_count + 1
		  || xtensa_operand_get_field (isa, opcode, 0,
					       fmt, 0, slotbuf, &rawval0) != 0
		  || xtensa_operand_get_field (isa, opcode, 1,
					       fmt, 0, slotbuf, &rawval1) != 0
		  || rawval0 == rawval1 /* it is a nop */)
		return 0;
	    }
	  if (is_branch)
	    check_operand_count--;

	  for (i = 0; i < check_operand_count; i++)
	    {
	      int new_i = i;
	      if (is_or && i == o_operand_count - 1)
		new_i = i - 1;
	      if (xtensa_operand_get_field (isa, opcode, new_i, fmt, 0,
					    slotbuf, &value)
		  || xtensa_operand_decode (isa, opcode, new_i, &value))
		return 0;

	      /* PC-relative branches need adjustment, but
		 the PC-rel operand will always have a relocation.  */
	      newval = value;
	      if (xtensa_operand_do_reloc (isa, o_opcode, i, &newval,
					   self_address)
		  || xtensa_operand_encode (isa, o_opcode, i, &newval)
		  || xtensa_operand_set_field (isa, o_opcode, i, o_fmt, 0,
					       o_slotbuf, newval))
		return 0;
	    }

	  if (xtensa_format_set_slot (isa, o_fmt, 0, o_insnbuf, o_slotbuf))
	    return 0;

	  return o_insnbuf;
	}
    }
  return 0;
}


/* Attempt to widen an instruction.  If the widening is valid, perform
   the action in-place directly into the contents and return TRUE.  Otherwise,
   the return value is FALSE and the contents are not modified.  */

static bfd_boolean
widen_instruction (bfd_byte *contents,
		   bfd_size_type content_length,
		   bfd_size_type offset)
{
  xtensa_opcode opcode;
  bfd_size_type insn_len;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  xtensa_insnbuf o_insnbuf;

  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  BFD_ASSERT (offset < content_length);

  if (content_length < 2)
    return FALSE;

  /* We will hand-code a few of these for a little while.
     These have all been specified in the assembler aleady.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, &contents[offset],
			     content_length - offset);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;

  if (xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf) != 0)
    return FALSE;

  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
  insn_len = xtensa_format_length (isa, fmt);
  if (insn_len > content_length)
    return FALSE;

  o_insnbuf = can_widen_instruction (slotbuf, fmt, opcode);
  if (o_insnbuf)
    {
      xtensa_insnbuf_to_chars (isa, o_insnbuf, contents + offset,
			       content_length - offset);
      return TRUE;
    }
  return FALSE;
}


/* Code for transforming CALLs at link-time.  */

static bfd_reloc_status_type
elf_xtensa_do_asm_simplify (bfd_byte *contents,
			    bfd_vma address,
			    bfd_vma content_length,
			    char **error_message)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format core_format = XTENSA_UNDEFINED;
  xtensa_opcode opcode;
  xtensa_opcode direct_call_opcode;
  xtensa_isa isa = xtensa_default_isa;
  bfd_byte *chbuf = contents + address;
  int opn;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  if (content_length < address)
    {
      *error_message = _("Attempt to convert L32R/CALLX to CALL failed");
      return bfd_reloc_other;
    }

  opcode = get_expanded_call_opcode (chbuf, content_length - address, 0);
  direct_call_opcode = swap_callx_for_call_opcode (opcode);
  if (direct_call_opcode == XTENSA_UNDEFINED)
    {
      *error_message = _("Attempt to convert L32R/CALLX to CALL failed");
      return bfd_reloc_other;
    }

  /* Assemble a NOP ("or a1, a1, a1") into the 0 byte offset.  */
  core_format = xtensa_format_lookup (isa, "x24");
  opcode = xtensa_opcode_lookup (isa, "or");
  xtensa_opcode_encode (isa, core_format, 0, slotbuf, opcode);
  for (opn = 0; opn < 3; opn++)
    {
      uint32 regno = 1;
      xtensa_operand_encode (isa, opcode, opn, &regno);
      xtensa_operand_set_field (isa, opcode, opn, core_format, 0,
				slotbuf, regno);
    }
  xtensa_format_encode (isa, core_format, insnbuf);
  xtensa_format_set_slot (isa, core_format, 0, insnbuf, slotbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, chbuf, content_length - address);

  /* Assemble a CALL ("callN 0") into the 3 byte offset.  */
  xtensa_opcode_encode (isa, core_format, 0, slotbuf, direct_call_opcode);
  xtensa_operand_set_field (isa, opcode, 0, core_format, 0, slotbuf, 0);

  xtensa_format_encode (isa, core_format, insnbuf);
  xtensa_format_set_slot (isa, core_format, 0, insnbuf, slotbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, chbuf + 3,
			   content_length - address - 3);

  return bfd_reloc_ok;
}


static bfd_reloc_status_type
contract_asm_expansion (bfd_byte *contents,
			bfd_vma content_length,
			Elf_Internal_Rela *irel,
			char **error_message)
{
  bfd_reloc_status_type retval =
    elf_xtensa_do_asm_simplify (contents, irel->r_offset, content_length,
				error_message);

  if (retval != bfd_reloc_ok)
    return bfd_reloc_dangerous;

  /* Update the irel->r_offset field so that the right immediate and
     the right instruction are modified during the relocation.  */
  irel->r_offset += 3;
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_XTENSA_SLOT0_OP);
  return bfd_reloc_ok;
}


static xtensa_opcode
swap_callx_for_call_opcode (xtensa_opcode opcode)
{
  init_call_opcodes ();

  if (opcode == callx0_op) return call0_op;
  if (opcode == callx4_op) return call4_op;
  if (opcode == callx8_op) return call8_op;
  if (opcode == callx12_op) return call12_op;

  /* Return XTENSA_UNDEFINED if the opcode is not an indirect call.  */
  return XTENSA_UNDEFINED;
}


/* Check if "buf" is pointing to a "L32R aN; CALLX aN" or "CONST16 aN;
   CONST16 aN; CALLX aN" sequence, and if so, return the CALLX opcode.
   If not, return XTENSA_UNDEFINED.  */

#define L32R_TARGET_REG_OPERAND 0
#define CONST16_TARGET_REG_OPERAND 0
#define CALLN_SOURCE_OPERAND 0

static xtensa_opcode
get_expanded_call_opcode (bfd_byte *buf, int bufsize, bfd_boolean *p_uses_l32r)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;
  uint32 regno, const16_regno, call_regno;
  int offset = 0;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, buf, bufsize);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED
      || xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf))
    return XTENSA_UNDEFINED;

  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (opcode == get_l32r_opcode ())
    {
      if (p_uses_l32r)
	*p_uses_l32r = TRUE;
      if (xtensa_operand_get_field (isa, opcode, L32R_TARGET_REG_OPERAND,
				    fmt, 0, slotbuf, &regno)
	  || xtensa_operand_decode (isa, opcode, L32R_TARGET_REG_OPERAND,
				    &regno))
	return XTENSA_UNDEFINED;
    }
  else if (opcode == get_const16_opcode ())
    {
      if (p_uses_l32r)
	*p_uses_l32r = FALSE;
      if (xtensa_operand_get_field (isa, opcode, CONST16_TARGET_REG_OPERAND,
				    fmt, 0, slotbuf, &regno)
	  || xtensa_operand_decode (isa, opcode, CONST16_TARGET_REG_OPERAND,
				    &regno))
	return XTENSA_UNDEFINED;

      /* Check that the next instruction is also CONST16.  */
      offset += xtensa_format_length (isa, fmt);
      xtensa_insnbuf_from_chars (isa, insnbuf, buf + offset, bufsize - offset);
      fmt = xtensa_format_decode (isa, insnbuf);
      if (fmt == XTENSA_UNDEFINED
	  || xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf))
	return XTENSA_UNDEFINED;
      opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
      if (opcode != get_const16_opcode ())
	return XTENSA_UNDEFINED;

      if (xtensa_operand_get_field (isa, opcode, CONST16_TARGET_REG_OPERAND,
				    fmt, 0, slotbuf, &const16_regno)
	  || xtensa_operand_decode (isa, opcode, CONST16_TARGET_REG_OPERAND,
				    &const16_regno)
	  || const16_regno != regno)
	return XTENSA_UNDEFINED;
    }
  else
    return XTENSA_UNDEFINED;

  /* Next instruction should be an CALLXn with operand 0 == regno.  */
  offset += xtensa_format_length (isa, fmt);
  xtensa_insnbuf_from_chars (isa, insnbuf, buf + offset, bufsize - offset);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED
      || xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf))
    return XTENSA_UNDEFINED;
  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
  if (opcode == XTENSA_UNDEFINED
      || !is_indirect_call_opcode (opcode))
    return XTENSA_UNDEFINED;

  if (xtensa_operand_get_field (isa, opcode, CALLN_SOURCE_OPERAND,
				fmt, 0, slotbuf, &call_regno)
      || xtensa_operand_decode (isa, opcode, CALLN_SOURCE_OPERAND,
				&call_regno))
    return XTENSA_UNDEFINED;

  if (call_regno != regno)
    return XTENSA_UNDEFINED;

  return opcode;
}


/* Data structures used during relaxation.  */

/* r_reloc: relocation values.  */

/* Through the relaxation process, we need to keep track of the values
   that will result from evaluating relocations.  The standard ELF
   relocation structure is not sufficient for this purpose because we're
   operating on multiple input files at once, so we need to know which
   input file a relocation refers to.  The r_reloc structure thus
   records both the input file (bfd) and ELF relocation.

   For efficiency, an r_reloc also contains a "target_offset" field to
   cache the target-section-relative offset value that is represented by
   the relocation.

   The r_reloc also contains a virtual offset that allows multiple
   inserted literals to be placed at the same "address" with
   different offsets.  */

typedef struct r_reloc_struct r_reloc;

struct r_reloc_struct
{
  bfd *abfd;
  Elf_Internal_Rela rela;
  bfd_vma target_offset;
  bfd_vma virtual_offset;
};


/* The r_reloc structure is included by value in literal_value, but not
   every literal_value has an associated relocation -- some are simple
   constants.  In such cases, we set all the fields in the r_reloc
   struct to zero.  The r_reloc_is_const function should be used to
   detect this case.  */

static bfd_boolean
r_reloc_is_const (const r_reloc *r_rel)
{
  return (r_rel->abfd == NULL);
}


static bfd_vma
r_reloc_get_target_offset (const r_reloc *r_rel)
{
  bfd_vma target_offset;
  unsigned long r_symndx;

  BFD_ASSERT (!r_reloc_is_const (r_rel));
  r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  target_offset = get_elf_r_symndx_offset (r_rel->abfd, r_symndx);
  return (target_offset + r_rel->rela.r_addend);
}


static struct elf_link_hash_entry *
r_reloc_get_hash_entry (const r_reloc *r_rel)
{
  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  return get_elf_r_symndx_hash_entry (r_rel->abfd, r_symndx);
}


static asection *
r_reloc_get_section (const r_reloc *r_rel)
{
  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  return get_elf_r_symndx_section (r_rel->abfd, r_symndx);
}


static bfd_boolean
r_reloc_is_defined (const r_reloc *r_rel)
{
  asection *sec;
  if (r_rel == NULL)
    return FALSE;

  sec = r_reloc_get_section (r_rel);
  if (sec == bfd_abs_section_ptr
      || sec == bfd_com_section_ptr
      || sec == bfd_und_section_ptr)
    return FALSE;
  return TRUE;
}


static void
r_reloc_init (r_reloc *r_rel,
	      bfd *abfd,
	      Elf_Internal_Rela *irel,
	      bfd_byte *contents,
	      bfd_size_type content_length)
{
  int r_type;
  reloc_howto_type *howto;

  if (irel)
    {
      r_rel->rela = *irel;
      r_rel->abfd = abfd;
      r_rel->target_offset = r_reloc_get_target_offset (r_rel);
      r_rel->virtual_offset = 0;
      r_type = ELF32_R_TYPE (r_rel->rela.r_info);
      howto = &elf_howto_table[r_type];
      if (howto->partial_inplace)
	{
	  bfd_vma inplace_val;
	  BFD_ASSERT (r_rel->rela.r_offset < content_length);

	  inplace_val = bfd_get_32 (abfd, &contents[r_rel->rela.r_offset]);
	  r_rel->target_offset += inplace_val;
	}
    }
  else
    memset (r_rel, 0, sizeof (r_reloc));
}


#if DEBUG

static void
print_r_reloc (FILE *fp, const r_reloc *r_rel)
{
  if (r_reloc_is_defined (r_rel))
    {
      asection *sec = r_reloc_get_section (r_rel);
      fprintf (fp, " %s(%s + ", sec->owner->filename, sec->name);
    }
  else if (r_reloc_get_hash_entry (r_rel))
    fprintf (fp, " %s + ", r_reloc_get_hash_entry (r_rel)->root.root.string);
  else
    fprintf (fp, " ?? + ");

  fprintf_vma (fp, r_rel->target_offset);
  if (r_rel->virtual_offset)
    {
      fprintf (fp, " + ");
      fprintf_vma (fp, r_rel->virtual_offset);
    }

  fprintf (fp, ")");
}

#endif /* DEBUG */


/* source_reloc: relocations that reference literals.  */

/* To determine whether literals can be coalesced, we need to first
   record all the relocations that reference the literals.  The
   source_reloc structure below is used for this purpose.  The
   source_reloc entries are kept in a per-literal-section array, sorted
   by offset within the literal section (i.e., target offset).

   The source_sec and r_rel.rela.r_offset fields identify the source of
   the relocation.  The r_rel field records the relocation value, i.e.,
   the offset of the literal being referenced.  The opnd field is needed
   to determine the range of the immediate field to which the relocation
   applies, so we can determine whether another literal with the same
   value is within range.  The is_null field is true when the relocation
   is being removed (e.g., when an L32R is being removed due to a CALLX
   that is converted to a direct CALL).  */

typedef struct source_reloc_struct source_reloc;

struct source_reloc_struct
{
  asection *source_sec;
  r_reloc r_rel;
  xtensa_opcode opcode;
  int opnd;
  bfd_boolean is_null;
  bfd_boolean is_abs_literal;
};


static void
init_source_reloc (source_reloc *reloc,
		   asection *source_sec,
		   const r_reloc *r_rel,
		   xtensa_opcode opcode,
		   int opnd,
		   bfd_boolean is_abs_literal)
{
  reloc->source_sec = source_sec;
  reloc->r_rel = *r_rel;
  reloc->opcode = opcode;
  reloc->opnd = opnd;
  reloc->is_null = FALSE;
  reloc->is_abs_literal = is_abs_literal;
}


/* Find the source_reloc for a particular source offset and relocation
   type.  Note that the array is sorted by _target_ offset, so this is
   just a linear search.  */

static source_reloc *
find_source_reloc (source_reloc *src_relocs,
		   int src_count,
		   asection *sec,
		   Elf_Internal_Rela *irel)
{
  int i;

  for (i = 0; i < src_count; i++)
    {
      if (src_relocs[i].source_sec == sec
	  && src_relocs[i].r_rel.rela.r_offset == irel->r_offset
	  && (ELF32_R_TYPE (src_relocs[i].r_rel.rela.r_info)
	      == ELF32_R_TYPE (irel->r_info)))
	return &src_relocs[i];
    }

  return NULL;
}


static int
source_reloc_compare (const void *ap, const void *bp)
{
  const source_reloc *a = (const source_reloc *) ap;
  const source_reloc *b = (const source_reloc *) bp;

  if (a->r_rel.target_offset != b->r_rel.target_offset)
    return (a->r_rel.target_offset - b->r_rel.target_offset);

  /* We don't need to sort on these criteria for correctness,
     but enforcing a more strict ordering prevents unstable qsort
     from behaving differently with different implementations.
     Without the code below we get correct but different results
     on Solaris 2.7 and 2.8.  We would like to always produce the
     same results no matter the host. */

  if ((!a->is_null) - (!b->is_null))
    return ((!a->is_null) - (!b->is_null));
  return internal_reloc_compare (&a->r_rel.rela, &b->r_rel.rela);
}


/* Literal values and value hash tables.  */

/* Literals with the same value can be coalesced.  The literal_value
   structure records the value of a literal: the "r_rel" field holds the
   information from the relocation on the literal (if there is one) and
   the "value" field holds the contents of the literal word itself.

   The value_map structure records a literal value along with the
   location of a literal holding that value.  The value_map hash table
   is indexed by the literal value, so that we can quickly check if a
   particular literal value has been seen before and is thus a candidate
   for coalescing.  */

typedef struct literal_value_struct literal_value;
typedef struct value_map_struct value_map;
typedef struct value_map_hash_table_struct value_map_hash_table;

struct literal_value_struct
{
  r_reloc r_rel;
  unsigned long value;
  bfd_boolean is_abs_literal;
};

struct value_map_struct
{
  literal_value val;			/* The literal value.  */
  r_reloc loc;				/* Location of the literal.  */
  value_map *next;
};

struct value_map_hash_table_struct
{
  unsigned bucket_count;
  value_map **buckets;
  unsigned count;
  bfd_boolean has_last_loc;
  r_reloc last_loc;
};


static void
init_literal_value (literal_value *lit,
		    const r_reloc *r_rel,
		    unsigned long value,
		    bfd_boolean is_abs_literal)
{
  lit->r_rel = *r_rel;
  lit->value = value;
  lit->is_abs_literal = is_abs_literal;
}


static bfd_boolean
literal_value_equal (const literal_value *src1,
		     const literal_value *src2,
		     bfd_boolean final_static_link)
{
  struct elf_link_hash_entry *h1, *h2;

  if (r_reloc_is_const (&src1->r_rel) != r_reloc_is_const (&src2->r_rel))
    return FALSE;

  if (r_reloc_is_const (&src1->r_rel))
    return (src1->value == src2->value);

  if (ELF32_R_TYPE (src1->r_rel.rela.r_info)
      != ELF32_R_TYPE (src2->r_rel.rela.r_info))
    return FALSE;

  if (src1->r_rel.target_offset != src2->r_rel.target_offset)
    return FALSE;

  if (src1->r_rel.virtual_offset != src2->r_rel.virtual_offset)
    return FALSE;

  if (src1->value != src2->value)
    return FALSE;

  /* Now check for the same section (if defined) or the same elf_hash
     (if undefined or weak).  */
  h1 = r_reloc_get_hash_entry (&src1->r_rel);
  h2 = r_reloc_get_hash_entry (&src2->r_rel);
  if (r_reloc_is_defined (&src1->r_rel)
      && (final_static_link
	  || ((!h1 || h1->root.type != bfd_link_hash_defweak)
	      && (!h2 || h2->root.type != bfd_link_hash_defweak))))
    {
      if (r_reloc_get_section (&src1->r_rel)
	  != r_reloc_get_section (&src2->r_rel))
	return FALSE;
    }
  else
    {
      /* Require that the hash entries (i.e., symbols) be identical.  */
      if (h1 != h2 || h1 == 0)
	return FALSE;
    }

  if (src1->is_abs_literal != src2->is_abs_literal)
    return FALSE;

  return TRUE;
}


/* Must be power of 2.  */
#define INITIAL_HASH_RELOC_BUCKET_COUNT 1024

static value_map_hash_table *
value_map_hash_table_init (void)
{
  value_map_hash_table *values;

  values = (value_map_hash_table *)
    bfd_zmalloc (sizeof (value_map_hash_table));
  values->bucket_count = INITIAL_HASH_RELOC_BUCKET_COUNT;
  values->count = 0;
  values->buckets = (value_map **)
    bfd_zmalloc (sizeof (value_map *) * values->bucket_count);
  if (values->buckets == NULL)
    {
      free (values);
      return NULL;
    }
  values->has_last_loc = FALSE;

  return values;
}


static void
value_map_hash_table_delete (value_map_hash_table *table)
{
  free (table->buckets);
  free (table);
}


static unsigned
hash_bfd_vma (bfd_vma val)
{
  return (val >> 2) + (val >> 10);
}


static unsigned
literal_value_hash (const literal_value *src)
{
  unsigned hash_val;

  hash_val = hash_bfd_vma (src->value);
  if (!r_reloc_is_const (&src->r_rel))
    {
      void *sec_or_hash;

      hash_val += hash_bfd_vma (src->is_abs_literal * 1000);
      hash_val += hash_bfd_vma (src->r_rel.target_offset);
      hash_val += hash_bfd_vma (src->r_rel.virtual_offset);

      /* Now check for the same section and the same elf_hash.  */
      if (r_reloc_is_defined (&src->r_rel))
	sec_or_hash = r_reloc_get_section (&src->r_rel);
      else
	sec_or_hash = r_reloc_get_hash_entry (&src->r_rel);
      hash_val += hash_bfd_vma ((bfd_vma) (size_t) sec_or_hash);
    }
  return hash_val;
}


/* Check if the specified literal_value has been seen before.  */

static value_map *
value_map_get_cached_value (value_map_hash_table *map,
			    const literal_value *val,
			    bfd_boolean final_static_link)
{
  value_map *map_e;
  value_map *bucket;
  unsigned idx;

  idx = literal_value_hash (val);
  idx = idx & (map->bucket_count - 1);
  bucket = map->buckets[idx];
  for (map_e = bucket; map_e; map_e = map_e->next)
    {
      if (literal_value_equal (&map_e->val, val, final_static_link))
	return map_e;
    }
  return NULL;
}


/* Record a new literal value.  It is illegal to call this if VALUE
   already has an entry here.  */

static value_map *
add_value_map (value_map_hash_table *map,
	       const literal_value *val,
	       const r_reloc *loc,
	       bfd_boolean final_static_link)
{
  value_map **bucket_p;
  unsigned idx;

  value_map *val_e = (value_map *) bfd_zmalloc (sizeof (value_map));
  if (val_e == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  BFD_ASSERT (!value_map_get_cached_value (map, val, final_static_link));
  val_e->val = *val;
  val_e->loc = *loc;

  idx = literal_value_hash (val);
  idx = idx & (map->bucket_count - 1);
  bucket_p = &map->buckets[idx];

  val_e->next = *bucket_p;
  *bucket_p = val_e;
  map->count++;
  /* FIXME: Consider resizing the hash table if we get too many entries.  */

  return val_e;
}


/* Lists of text actions (ta_) for narrowing, widening, longcall
   conversion, space fill, code & literal removal, etc.  */

/* The following text actions are generated:

   "ta_remove_insn"         remove an instruction or instructions
   "ta_remove_longcall"     convert longcall to call
   "ta_convert_longcall"    convert longcall to nop/call
   "ta_narrow_insn"         narrow a wide instruction
   "ta_widen"               widen a narrow instruction
   "ta_fill"                add fill or remove fill
      removed < 0 is a fill; branches to the fill address will be
	changed to address + fill size (e.g., address - removed)
      removed >= 0 branches to the fill address will stay unchanged
   "ta_remove_literal"      remove a literal; this action is
			    indicated when a literal is removed
                            or replaced.
   "ta_add_literal"         insert a new literal; this action is
                            indicated when a literal has been moved.
                            It may use a virtual_offset because
			    multiple literals can be placed at the
                            same location.

   For each of these text actions, we also record the number of bytes
   removed by performing the text action.  In the case of a "ta_widen"
   or a "ta_fill" that adds space, the removed_bytes will be negative.  */

typedef struct text_action_struct text_action;
typedef struct text_action_list_struct text_action_list;
typedef enum text_action_enum_t text_action_t;

enum text_action_enum_t
{
  ta_none,
  ta_remove_insn,        /* removed = -size */
  ta_remove_longcall,    /* removed = -size */
  ta_convert_longcall,   /* removed = 0 */
  ta_narrow_insn,        /* removed = -1 */
  ta_widen_insn,         /* removed = +1 */
  ta_fill,               /* removed = +size */
  ta_remove_literal,
  ta_add_literal
};


/* Structure for a text action record.  */
struct text_action_struct
{
  text_action_t action;
  asection *sec;	/* Optional */
  bfd_vma offset;
  bfd_vma virtual_offset;  /* Zero except for adding literals.  */
  int removed_bytes;
  literal_value value;	/* Only valid when adding literals.  */

  text_action *next;
};


/* List of all of the actions taken on a text section.  */
struct text_action_list_struct
{
  text_action *head;
};


static text_action *
find_fill_action (text_action_list *l, asection *sec, bfd_vma offset)
{
  text_action **m_p;

  /* It is not necessary to fill at the end of a section.  */
  if (sec->size == offset)
    return NULL;

  for (m_p = &l->head; *m_p && (*m_p)->offset <= offset; m_p = &(*m_p)->next)
    {
      text_action *t = *m_p;
      /* When the action is another fill at the same address,
	 just increase the size.  */
      if (t->offset == offset && t->action == ta_fill)
	return t;
    }
  return NULL;
}


static int
compute_removed_action_diff (const text_action *ta,
			     asection *sec,
			     bfd_vma offset,
			     int removed,
			     int removable_space)
{
  int new_removed;
  int current_removed = 0;

  if (ta)
    current_removed = ta->removed_bytes;

  BFD_ASSERT (ta == NULL || ta->offset == offset);
  BFD_ASSERT (ta == NULL || ta->action == ta_fill);

  /* It is not necessary to fill at the end of a section.  Clean this up.  */
  if (sec->size == offset)
    new_removed = removable_space - 0;
  else
    {
      int space;
      int added = -removed - current_removed;
      /* Ignore multiples of the section alignment.  */
      added = ((1 << sec->alignment_power) - 1) & added;
      new_removed = (-added);

      /* Modify for removable.  */
      space = removable_space - new_removed;
      new_removed = (removable_space
		     - (((1 << sec->alignment_power) - 1) & space));
    }
  return (new_removed - current_removed);
}


static void
adjust_fill_action (text_action *ta, int fill_diff)
{
  ta->removed_bytes += fill_diff;
}


/* Add a modification action to the text.  For the case of adding or
   removing space, modify any current fill and assume that
   "unreachable_space" bytes can be freely contracted.  Note that a
   negative removed value is a fill.  */

static void
text_action_add (text_action_list *l,
		 text_action_t action,
		 asection *sec,
		 bfd_vma offset,
		 int removed)
{
  text_action **m_p;
  text_action *ta;

  /* It is not necessary to fill at the end of a section.  */
  if (action == ta_fill && sec->size == offset)
    return;

  /* It is not necessary to fill 0 bytes.  */
  if (action == ta_fill && removed == 0)
    return;

  for (m_p = &l->head; *m_p && (*m_p)->offset <= offset; m_p = &(*m_p)->next)
    {
      text_action *t = *m_p;

      if (action == ta_fill)
	{
	  /* When the action is another fill at the same address,
	     just increase the size.  */
	  if (t->offset == offset && t->action == ta_fill)
	    {
	      t->removed_bytes += removed;
	      return;
	    }
	  /* Fills need to happen before widens so that we don't
	     insert fill bytes into the instruction stream.  */
	  if (t->offset == offset && t->action == ta_widen_insn)
	    break;
	}
    }

  /* Create a new record and fill it up.  */
  ta = (text_action *) bfd_zmalloc (sizeof (text_action));
  ta->action = action;
  ta->sec = sec;
  ta->offset = offset;
  ta->removed_bytes = removed;
  ta->next = (*m_p);
  *m_p = ta;
}


static void
text_action_add_literal (text_action_list *l,
			 text_action_t action,
			 const r_reloc *loc,
			 const literal_value *value,
			 int removed)
{
  text_action **m_p;
  text_action *ta;
  asection *sec = r_reloc_get_section (loc);
  bfd_vma offset = loc->target_offset;
  bfd_vma virtual_offset = loc->virtual_offset;

  BFD_ASSERT (action == ta_add_literal);

  for (m_p = &l->head; *m_p != NULL; m_p = &(*m_p)->next)
    {
      if ((*m_p)->offset > offset
	  && ((*m_p)->offset != offset
	      || (*m_p)->virtual_offset > virtual_offset))
	break;
    }

  /* Create a new record and fill it up.  */
  ta = (text_action *) bfd_zmalloc (sizeof (text_action));
  ta->action = action;
  ta->sec = sec;
  ta->offset = offset;
  ta->virtual_offset = virtual_offset;
  ta->value = *value;
  ta->removed_bytes = removed;
  ta->next = (*m_p);
  *m_p = ta;
}


/* Find the total offset adjustment for the relaxations specified by
   text_actions, beginning from a particular starting action.  This is
   typically used from offset_with_removed_text to search an entire list of
   actions, but it may also be called directly when adjusting adjacent offsets
   so that each search may begin where the previous one left off.  */

static int
removed_by_actions (text_action **p_start_action,
		    bfd_vma offset,
		    bfd_boolean before_fill)
{
  text_action *r;
  int removed = 0;

  r = *p_start_action;
  while (r)
    {
      if (r->offset > offset)
	break;

      if (r->offset == offset
	  && (before_fill || r->action != ta_fill || r->removed_bytes >= 0))
	break;

      removed += r->removed_bytes;

      r = r->next;
    }

  *p_start_action = r;
  return removed;
}


static bfd_vma
offset_with_removed_text (text_action_list *action_list, bfd_vma offset)
{
  text_action *r = action_list->head;
  return offset - removed_by_actions (&r, offset, FALSE);
}


static unsigned
action_list_count (text_action_list *action_list)
{
  text_action *r = action_list->head;
  unsigned count = 0;
  for (r = action_list->head; r != NULL; r = r->next)
    {
      count++;
    }
  return count;
}


/* The find_insn_action routine will only find non-fill actions.  */

static text_action *
find_insn_action (text_action_list *action_list, bfd_vma offset)
{
  text_action *t;
  for (t = action_list->head; t; t = t->next)
    {
      if (t->offset == offset)
	{
	  switch (t->action)
	    {
	    case ta_none:
	    case ta_fill:
	      break;
	    case ta_remove_insn:
	    case ta_remove_longcall:
	    case ta_convert_longcall:
	    case ta_narrow_insn:
	    case ta_widen_insn:
	      return t;
	    case ta_remove_literal:
	    case ta_add_literal:
	      BFD_ASSERT (0);
	      break;
	    }
	}
    }
  return NULL;
}


#if DEBUG

static void
print_action_list (FILE *fp, text_action_list *action_list)
{
  text_action *r;

  fprintf (fp, "Text Action\n");
  for (r = action_list->head; r != NULL; r = r->next)
    {
      const char *t = "unknown";
      switch (r->action)
	{
	case ta_remove_insn:
	  t = "remove_insn"; break;
	case ta_remove_longcall:
	  t = "remove_longcall"; break;
	case ta_convert_longcall:
	  t = "convert_longcall"; break;
	case ta_narrow_insn:
	  t = "narrow_insn"; break;
	case ta_widen_insn:
	  t = "widen_insn"; break;
	case ta_fill:
	  t = "fill"; break;
	case ta_none:
	  t = "none"; break;
	case ta_remove_literal:
	  t = "remove_literal"; break;
	case ta_add_literal:
	  t = "add_literal"; break;
	}

      fprintf (fp, "%s: %s[0x%lx] \"%s\" %d\n",
	       r->sec->owner->filename,
	       r->sec->name, (unsigned long) r->offset, t, r->removed_bytes);
    }
}

#endif /* DEBUG */


/* Lists of literals being coalesced or removed.  */

/* In the usual case, the literal identified by "from" is being
   coalesced with another literal identified by "to".  If the literal is
   unused and is being removed altogether, "to.abfd" will be NULL.
   The removed_literal entries are kept on a per-section list, sorted
   by the "from" offset field.  */

typedef struct removed_literal_struct removed_literal;
typedef struct removed_literal_list_struct removed_literal_list;

struct removed_literal_struct
{
  r_reloc from;
  r_reloc to;
  removed_literal *next;
};

struct removed_literal_list_struct
{
  removed_literal *head;
  removed_literal *tail;
};


/* Record that the literal at "from" is being removed.  If "to" is not
   NULL, the "from" literal is being coalesced with the "to" literal.  */

static void
add_removed_literal (removed_literal_list *removed_list,
		     const r_reloc *from,
		     const r_reloc *to)
{
  removed_literal *r, *new_r, *next_r;

  new_r = (removed_literal *) bfd_zmalloc (sizeof (removed_literal));

  new_r->from = *from;
  if (to)
    new_r->to = *to;
  else
    new_r->to.abfd = NULL;
  new_r->next = NULL;

  r = removed_list->head;
  if (r == NULL)
    {
      removed_list->head = new_r;
      removed_list->tail = new_r;
    }
  /* Special check for common case of append.  */
  else if (removed_list->tail->from.target_offset < from->target_offset)
    {
      removed_list->tail->next = new_r;
      removed_list->tail = new_r;
    }
  else
    {
      while (r->from.target_offset < from->target_offset && r->next)
	{
	  r = r->next;
	}
      next_r = r->next;
      r->next = new_r;
      new_r->next = next_r;
      if (next_r == NULL)
	removed_list->tail = new_r;
    }
}


/* Check if the list of removed literals contains an entry for the
   given address.  Return the entry if found.  */

static removed_literal *
find_removed_literal (removed_literal_list *removed_list, bfd_vma addr)
{
  removed_literal *r = removed_list->head;
  while (r && r->from.target_offset < addr)
    r = r->next;
  if (r && r->from.target_offset == addr)
    return r;
  return NULL;
}


#if DEBUG

static void
print_removed_literals (FILE *fp, removed_literal_list *removed_list)
{
  removed_literal *r;
  r = removed_list->head;
  if (r)
    fprintf (fp, "Removed Literals\n");
  for (; r != NULL; r = r->next)
    {
      print_r_reloc (fp, &r->from);
      fprintf (fp, " => ");
      if (r->to.abfd == NULL)
	fprintf (fp, "REMOVED");
      else
	print_r_reloc (fp, &r->to);
      fprintf (fp, "\n");
    }
}

#endif /* DEBUG */


/* Per-section data for relaxation.  */

typedef struct reloc_bfd_fix_struct reloc_bfd_fix;

struct xtensa_relax_info_struct
{
  bfd_boolean is_relaxable_literal_section;
  bfd_boolean is_relaxable_asm_section;
  int visited;				/* Number of times visited.  */

  source_reloc *src_relocs;		/* Array[src_count].  */
  int src_count;
  int src_next;				/* Next src_relocs entry to assign.  */

  removed_literal_list removed_list;
  text_action_list action_list;

  reloc_bfd_fix *fix_list;
  reloc_bfd_fix *fix_array;
  unsigned fix_array_count;

  /* Support for expanding the reloc array that is stored
     in the section structure.  If the relocations have been
     reallocated, the newly allocated relocations will be referenced
     here along with the actual size allocated.  The relocation
     count will always be found in the section structure.  */
  Elf_Internal_Rela *allocated_relocs;
  unsigned relocs_count;
  unsigned allocated_relocs_count;
};

struct elf_xtensa_section_data
{
  struct bfd_elf_section_data elf;
  xtensa_relax_info relax_info;
};


static bfd_boolean
elf_xtensa_new_section_hook (bfd *abfd, asection *sec)
{
  if (!sec->used_by_bfd)
    {
      struct elf_xtensa_section_data *sdata;
      bfd_size_type amt = sizeof (*sdata);

      sdata = bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  return _bfd_elf_new_section_hook (abfd, sec);
}


static xtensa_relax_info *
get_xtensa_relax_info (asection *sec)
{
  struct elf_xtensa_section_data *section_data;

  /* No info available if no section or if it is an output section.  */
  if (!sec || sec == sec->output_section)
    return NULL;

  section_data = (struct elf_xtensa_section_data *) elf_section_data (sec);
  return &section_data->relax_info;
}


static void
init_xtensa_relax_info (asection *sec)
{
  xtensa_relax_info *relax_info = get_xtensa_relax_info (sec);

  relax_info->is_relaxable_literal_section = FALSE;
  relax_info->is_relaxable_asm_section = FALSE;
  relax_info->visited = 0;

  relax_info->src_relocs = NULL;
  relax_info->src_count = 0;
  relax_info->src_next = 0;

  relax_info->removed_list.head = NULL;
  relax_info->removed_list.tail = NULL;

  relax_info->action_list.head = NULL;

  relax_info->fix_list = NULL;
  relax_info->fix_array = NULL;
  relax_info->fix_array_count = 0;

  relax_info->allocated_relocs = NULL;
  relax_info->relocs_count = 0;
  relax_info->allocated_relocs_count = 0;
}


/* Coalescing literals may require a relocation to refer to a section in
   a different input file, but the standard relocation information
   cannot express that.  Instead, the reloc_bfd_fix structures are used
   to "fix" the relocations that refer to sections in other input files.
   These structures are kept on per-section lists.  The "src_type" field
   records the relocation type in case there are multiple relocations on
   the same location.  FIXME: This is ugly; an alternative might be to
   add new symbols with the "owner" field to some other input file.  */

struct reloc_bfd_fix_struct
{
  asection *src_sec;
  bfd_vma src_offset;
  unsigned src_type;			/* Relocation type.  */

  asection *target_sec;
  bfd_vma target_offset;
  bfd_boolean translated;

  reloc_bfd_fix *next;
};


static reloc_bfd_fix *
reloc_bfd_fix_init (asection *src_sec,
		    bfd_vma src_offset,
		    unsigned src_type,
		    asection *target_sec,
		    bfd_vma target_offset,
		    bfd_boolean translated)
{
  reloc_bfd_fix *fix;

  fix = (reloc_bfd_fix *) bfd_malloc (sizeof (reloc_bfd_fix));
  fix->src_sec = src_sec;
  fix->src_offset = src_offset;
  fix->src_type = src_type;
  fix->target_sec = target_sec;
  fix->target_offset = target_offset;
  fix->translated = translated;

  return fix;
}


static void
add_fix (asection *src_sec, reloc_bfd_fix *fix)
{
  xtensa_relax_info *relax_info;

  relax_info = get_xtensa_relax_info (src_sec);
  fix->next = relax_info->fix_list;
  relax_info->fix_list = fix;
}


static int
fix_compare (const void *ap, const void *bp)
{
  const reloc_bfd_fix *a = (const reloc_bfd_fix *) ap;
  const reloc_bfd_fix *b = (const reloc_bfd_fix *) bp;

  if (a->src_offset != b->src_offset)
    return (a->src_offset - b->src_offset);
  return (a->src_type - b->src_type);
}


static void
cache_fix_array (asection *sec)
{
  unsigned i, count = 0;
  reloc_bfd_fix *r;
  xtensa_relax_info *relax_info = get_xtensa_relax_info (sec);

  if (relax_info == NULL)
    return;
  if (relax_info->fix_list == NULL)
    return;

  for (r = relax_info->fix_list; r != NULL; r = r->next)
    count++;

  relax_info->fix_array =
    (reloc_bfd_fix *) bfd_malloc (sizeof (reloc_bfd_fix) * count);
  relax_info->fix_array_count = count;

  r = relax_info->fix_list;
  for (i = 0; i < count; i++, r = r->next)
    {
      relax_info->fix_array[count - 1 - i] = *r;
      relax_info->fix_array[count - 1 - i].next = NULL;
    }

  qsort (relax_info->fix_array, relax_info->fix_array_count,
	 sizeof (reloc_bfd_fix), fix_compare);
}


static reloc_bfd_fix *
get_bfd_fix (asection *sec, bfd_vma offset, unsigned type)
{
  xtensa_relax_info *relax_info = get_xtensa_relax_info (sec);
  reloc_bfd_fix *rv;
  reloc_bfd_fix key;

  if (relax_info == NULL)
    return NULL;
  if (relax_info->fix_list == NULL)
    return NULL;

  if (relax_info->fix_array == NULL)
    cache_fix_array (sec);

  key.src_offset = offset;
  key.src_type = type;
  rv = bsearch (&key, relax_info->fix_array,  relax_info->fix_array_count,
		sizeof (reloc_bfd_fix), fix_compare);
  return rv;
}


/* Section caching.  */

typedef struct section_cache_struct section_cache_t;

struct section_cache_struct
{
  asection *sec;

  bfd_byte *contents;		/* Cache of the section contents.  */
  bfd_size_type content_length;

  property_table_entry *ptbl;	/* Cache of the section property table.  */
  unsigned pte_count;

  Elf_Internal_Rela *relocs;	/* Cache of the section relocations.  */
  unsigned reloc_count;
};


static void
init_section_cache (section_cache_t *sec_cache)
{
  memset (sec_cache, 0, sizeof (*sec_cache));
}


static void
free_section_cache (section_cache_t *sec_cache)
{
  if (sec_cache->sec)
    {
      release_contents (sec_cache->sec, sec_cache->contents);
      release_internal_relocs (sec_cache->sec, sec_cache->relocs);
      if (sec_cache->ptbl)
	free (sec_cache->ptbl);
    }
}


static bfd_boolean
section_cache_section (section_cache_t *sec_cache,
		       asection *sec,
		       struct bfd_link_info *link_info)
{
  bfd *abfd;
  property_table_entry *prop_table = NULL;
  int ptblsize = 0;
  bfd_byte *contents = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  bfd_size_type sec_size;

  if (sec == NULL)
    return FALSE;
  if (sec == sec_cache->sec)
    return TRUE;

  abfd = sec->owner;
  sec_size = bfd_get_section_limit (abfd, sec);

  /* Get the contents.  */
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    goto err;

  /* Get the relocations.  */
  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);

  /* Get the entry table.  */
  ptblsize = xtensa_read_table_entries (abfd, sec, &prop_table,
					XTENSA_PROP_SEC_NAME, FALSE);
  if (ptblsize < 0)
    goto err;

  /* Fill in the new section cache.  */
  free_section_cache (sec_cache);
  init_section_cache (sec_cache);

  sec_cache->sec = sec;
  sec_cache->contents = contents;
  sec_cache->content_length = sec_size;
  sec_cache->relocs = internal_relocs;
  sec_cache->reloc_count = sec->reloc_count;
  sec_cache->pte_count = ptblsize;
  sec_cache->ptbl = prop_table;

  return TRUE;

 err:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  if (prop_table)
    free (prop_table);
  return FALSE;
}


/* Extended basic blocks.  */

/* An ebb_struct represents an Extended Basic Block.  Within this
   range, we guarantee that all instructions are decodable, the
   property table entries are contiguous, and no property table
   specifies a segment that cannot have instructions moved.  This
   structure contains caches of the contents, property table and
   relocations for the specified section for easy use.  The range is
   specified by ranges of indices for the byte offset, property table
   offsets and relocation offsets.  These must be consistent.  */

typedef struct ebb_struct ebb_t;

struct ebb_struct
{
  asection *sec;

  bfd_byte *contents;		/* Cache of the section contents.  */
  bfd_size_type content_length;

  property_table_entry *ptbl;	/* Cache of the section property table.  */
  unsigned pte_count;

  Elf_Internal_Rela *relocs;	/* Cache of the section relocations.  */
  unsigned reloc_count;

  bfd_vma start_offset;		/* Offset in section.  */
  unsigned start_ptbl_idx;	/* Offset in the property table.  */
  unsigned start_reloc_idx;	/* Offset in the relocations.  */

  bfd_vma end_offset;
  unsigned end_ptbl_idx;
  unsigned end_reloc_idx;

  bfd_boolean ends_section;	/* Is this the last ebb in a section?  */

  /* The unreachable property table at the end of this set of blocks;
     NULL if the end is not an unreachable block.  */
  property_table_entry *ends_unreachable;
};


enum ebb_target_enum
{
  EBB_NO_ALIGN = 0,
  EBB_DESIRE_TGT_ALIGN,
  EBB_REQUIRE_TGT_ALIGN,
  EBB_REQUIRE_LOOP_ALIGN,
  EBB_REQUIRE_ALIGN
};


/* proposed_action_struct is similar to the text_action_struct except
   that is represents a potential transformation, not one that will
   occur.  We build a list of these for an extended basic block
   and use them to compute the actual actions desired.  We must be
   careful that the entire set of actual actions we perform do not
   break any relocations that would fit if the actions were not
   performed.  */

typedef struct proposed_action_struct proposed_action;

struct proposed_action_struct
{
  enum ebb_target_enum align_type; /* for the target alignment */
  bfd_vma alignment_pow;
  text_action_t action;
  bfd_vma offset;
  int removed_bytes;
  bfd_boolean do_action; /* If false, then we will not perform the action.  */
};


/* The ebb_constraint_struct keeps a set of proposed actions for an
   extended basic block.   */

typedef struct ebb_constraint_struct ebb_constraint;

struct ebb_constraint_struct
{
  ebb_t ebb;
  bfd_boolean start_movable;

  /* Bytes of extra space at the beginning if movable.  */
  int start_extra_space;

  enum ebb_target_enum start_align;

  bfd_boolean end_movable;

  /* Bytes of extra space at the end if movable.  */
  int end_extra_space;

  unsigned action_count;
  unsigned action_allocated;

  /* Array of proposed actions.  */
  proposed_action *actions;

  /* Action alignments -- one for each proposed action.  */
  enum ebb_target_enum *action_aligns;
};


static void
init_ebb_constraint (ebb_constraint *c)
{
  memset (c, 0, sizeof (ebb_constraint));
}


static void
free_ebb_constraint (ebb_constraint *c)
{
  if (c->actions)
    free (c->actions);
}


static void
init_ebb (ebb_t *ebb,
	  asection *sec,
	  bfd_byte *contents,
	  bfd_size_type content_length,
	  property_table_entry *prop_table,
	  unsigned ptblsize,
	  Elf_Internal_Rela *internal_relocs,
	  unsigned reloc_count)
{
  memset (ebb, 0, sizeof (ebb_t));
  ebb->sec = sec;
  ebb->contents = contents;
  ebb->content_length = content_length;
  ebb->ptbl = prop_table;
  ebb->pte_count = ptblsize;
  ebb->relocs = internal_relocs;
  ebb->reloc_count = reloc_count;
  ebb->start_offset = 0;
  ebb->end_offset = ebb->content_length - 1;
  ebb->start_ptbl_idx = 0;
  ebb->end_ptbl_idx = ptblsize;
  ebb->start_reloc_idx = 0;
  ebb->end_reloc_idx = reloc_count;
}


/* Extend the ebb to all decodable contiguous sections.  The algorithm
   for building a basic block around an instruction is to push it
   forward until we hit the end of a section, an unreachable block or
   a block that cannot be transformed.  Then we push it backwards
   searching for similar conditions.  */

static bfd_boolean extend_ebb_bounds_forward (ebb_t *);
static bfd_boolean extend_ebb_bounds_backward (ebb_t *);
static bfd_size_type insn_block_decodable_len
  (bfd_byte *, bfd_size_type, bfd_vma, bfd_size_type);

static bfd_boolean
extend_ebb_bounds (ebb_t *ebb)
{
  if (!extend_ebb_bounds_forward (ebb))
    return FALSE;
  if (!extend_ebb_bounds_backward (ebb))
    return FALSE;
  return TRUE;
}


static bfd_boolean
extend_ebb_bounds_forward (ebb_t *ebb)
{
  property_table_entry *the_entry, *new_entry;

  the_entry = &ebb->ptbl[ebb->end_ptbl_idx];

  /* Stop when (1) we cannot decode an instruction, (2) we are at
     the end of the property tables, (3) we hit a non-contiguous property
     table entry, (4) we hit a NO_TRANSFORM region.  */

  while (1)
    {
      bfd_vma entry_end;
      bfd_size_type insn_block_len;

      entry_end = the_entry->address - ebb->sec->vma + the_entry->size;
      insn_block_len =
	insn_block_decodable_len (ebb->contents, ebb->content_length,
				  ebb->end_offset,
				  entry_end - ebb->end_offset);
      if (insn_block_len != (entry_end - ebb->end_offset))
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"),
	     ebb->sec->owner, ebb->sec, ebb->end_offset + insn_block_len);
	  return FALSE;
	}
      ebb->end_offset += insn_block_len;

      if (ebb->end_offset == ebb->sec->size)
	ebb->ends_section = TRUE;

      /* Update the reloc counter.  */
      while (ebb->end_reloc_idx + 1 < ebb->reloc_count
	     && (ebb->relocs[ebb->end_reloc_idx + 1].r_offset
		 < ebb->end_offset))
	{
	  ebb->end_reloc_idx++;
	}

      if (ebb->end_ptbl_idx + 1 == ebb->pte_count)
	return TRUE;

      new_entry = &ebb->ptbl[ebb->end_ptbl_idx + 1];
      if (((new_entry->flags & XTENSA_PROP_INSN) == 0)
	  || ((new_entry->flags & XTENSA_PROP_NO_TRANSFORM) != 0)
	  || ((the_entry->flags & XTENSA_PROP_ALIGN) != 0))
	break;

      if (the_entry->address + the_entry->size != new_entry->address)
	break;

      the_entry = new_entry;
      ebb->end_ptbl_idx++;
    }

  /* Quick check for an unreachable or end of file just at the end.  */
  if (ebb->end_ptbl_idx + 1 == ebb->pte_count)
    {
      if (ebb->end_offset == ebb->content_length)
	ebb->ends_section = TRUE;
    }
  else
    {
      new_entry = &ebb->ptbl[ebb->end_ptbl_idx + 1];
      if ((new_entry->flags & XTENSA_PROP_UNREACHABLE) != 0
	  && the_entry->address + the_entry->size == new_entry->address)
	ebb->ends_unreachable = new_entry;
    }

  /* Any other ending requires exact alignment.  */
  return TRUE;
}


static bfd_boolean
extend_ebb_bounds_backward (ebb_t *ebb)
{
  property_table_entry *the_entry, *new_entry;

  the_entry = &ebb->ptbl[ebb->start_ptbl_idx];

  /* Stop when (1) we cannot decode the instructions in the current entry.
     (2) we are at the beginning of the property tables, (3) we hit a
     non-contiguous property table entry, (4) we hit a NO_TRANSFORM region.  */

  while (1)
    {
      bfd_vma block_begin;
      bfd_size_type insn_block_len;

      block_begin = the_entry->address - ebb->sec->vma;
      insn_block_len =
	insn_block_decodable_len (ebb->contents, ebb->content_length,
				  block_begin,
				  ebb->start_offset - block_begin);
      if (insn_block_len != ebb->start_offset - block_begin)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"),
	     ebb->sec->owner, ebb->sec, ebb->end_offset + insn_block_len);
	  return FALSE;
	}
      ebb->start_offset -= insn_block_len;

      /* Update the reloc counter.  */
      while (ebb->start_reloc_idx > 0
	     && (ebb->relocs[ebb->start_reloc_idx - 1].r_offset
		 >= ebb->start_offset))
	{
	  ebb->start_reloc_idx--;
	}

      if (ebb->start_ptbl_idx == 0)
	return TRUE;

      new_entry = &ebb->ptbl[ebb->start_ptbl_idx - 1];
      if ((new_entry->flags & XTENSA_PROP_INSN) == 0
	  || ((new_entry->flags & XTENSA_PROP_NO_TRANSFORM) != 0)
	  || ((new_entry->flags & XTENSA_PROP_ALIGN) != 0))
	return TRUE;
      if (new_entry->address + new_entry->size != the_entry->address)
	return TRUE;

      the_entry = new_entry;
      ebb->start_ptbl_idx--;
    }
  return TRUE;
}


static bfd_size_type
insn_block_decodable_len (bfd_byte *contents,
			  bfd_size_type content_len,
			  bfd_vma block_offset,
			  bfd_size_type block_len)
{
  bfd_vma offset = block_offset;

  while (offset < block_offset + block_len)
    {
      bfd_size_type insn_len = 0;

      insn_len = insn_decode_len (contents, content_len, offset);
      if (insn_len == 0)
	return (offset - block_offset);
      offset += insn_len;
    }
  return (offset - block_offset);
}


static void
ebb_propose_action (ebb_constraint *c,
		    enum ebb_target_enum align_type,
		    bfd_vma alignment_pow,
		    text_action_t action,
		    bfd_vma offset,
		    int removed_bytes,
		    bfd_boolean do_action)
{
  proposed_action *act;

  if (c->action_allocated <= c->action_count)
    {
      unsigned new_allocated, i;
      proposed_action *new_actions;

      new_allocated = (c->action_count + 2) * 2;
      new_actions = (proposed_action *)
	bfd_zmalloc (sizeof (proposed_action) * new_allocated);

      for (i = 0; i < c->action_count; i++)
	new_actions[i] = c->actions[i];
      if (c->actions)
	free (c->actions);
      c->actions = new_actions;
      c->action_allocated = new_allocated;
    }

  act = &c->actions[c->action_count];
  act->align_type = align_type;
  act->alignment_pow = alignment_pow;
  act->action = action;
  act->offset = offset;
  act->removed_bytes = removed_bytes;
  act->do_action = do_action;

  c->action_count++;
}


/* Access to internal relocations, section contents and symbols.  */

/* During relaxation, we need to modify relocations, section contents,
   and symbol definitions, and we need to keep the original values from
   being reloaded from the input files, i.e., we need to "pin" the
   modified values in memory.  We also want to continue to observe the
   setting of the "keep-memory" flag.  The following functions wrap the
   standard BFD functions to take care of this for us.  */

static Elf_Internal_Rela *
retrieve_internal_relocs (bfd *abfd, asection *sec, bfd_boolean keep_memory)
{
  Elf_Internal_Rela *internal_relocs;

  if ((sec->flags & SEC_LINKER_CREATED) != 0)
    return NULL;

  internal_relocs = elf_section_data (sec)->relocs;
  if (internal_relocs == NULL)
    internal_relocs = (_bfd_elf_link_read_relocs
		       (abfd, sec, NULL, NULL, keep_memory));
  return internal_relocs;
}


static void
pin_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
{
  elf_section_data (sec)->relocs = internal_relocs;
}


static void
release_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
{
  if (internal_relocs
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
}


static bfd_byte *
retrieve_contents (bfd *abfd, asection *sec, bfd_boolean keep_memory)
{
  bfd_byte *contents;
  bfd_size_type sec_size;

  sec_size = bfd_get_section_limit (abfd, sec);
  contents = elf_section_data (sec)->this_hdr.contents;

  if (contents == NULL && sec_size != 0)
    {
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	{
	  if (contents)
	    free (contents);
	  return NULL;
	}
      if (keep_memory)
	elf_section_data (sec)->this_hdr.contents = contents;
    }
  return contents;
}


static void
pin_contents (asection *sec, bfd_byte *contents)
{
  elf_section_data (sec)->this_hdr.contents = contents;
}


static void
release_contents (asection *sec, bfd_byte *contents)
{
  if (contents && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
}


static Elf_Internal_Sym *
retrieve_local_syms (bfd *input_bfd)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf;
  size_t locsymcount;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  locsymcount = symtab_hdr->sh_info;

  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				    NULL, NULL, NULL);

  /* Save the symbols for this input file so they won't be read again.  */
  if (isymbuf && isymbuf != (Elf_Internal_Sym *) symtab_hdr->contents)
    symtab_hdr->contents = (unsigned char *) isymbuf;

  return isymbuf;
}


/* Code for link-time relaxation.  */

/* Initialization for relaxation: */
static bfd_boolean analyze_relocations (struct bfd_link_info *);
static bfd_boolean find_relaxable_sections
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean collect_source_relocs
  (bfd *, asection *, struct bfd_link_info *);
static bfd_boolean is_resolvable_asm_expansion
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, struct bfd_link_info *,
   bfd_boolean *);
static Elf_Internal_Rela *find_associated_l32r_irel
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Rela *);
static bfd_boolean compute_text_actions
  (bfd *, asection *, struct bfd_link_info *);
static bfd_boolean compute_ebb_proposed_actions (ebb_constraint *);
static bfd_boolean compute_ebb_actions (ebb_constraint *);
static bfd_boolean check_section_ebb_pcrels_fit
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, const ebb_constraint *,
   const xtensa_opcode *);
static bfd_boolean check_section_ebb_reduces (const ebb_constraint *);
static void text_action_add_proposed
  (text_action_list *, const ebb_constraint *, asection *);
static int compute_fill_extra_space (property_table_entry *);

/* First pass: */
static bfd_boolean compute_removed_literals
  (bfd *, asection *, struct bfd_link_info *, value_map_hash_table *);
static Elf_Internal_Rela *get_irel_at_offset
  (asection *, Elf_Internal_Rela *, bfd_vma);
static bfd_boolean is_removable_literal
  (const source_reloc *, int, const source_reloc *, int, asection *,
   property_table_entry *, int);
static bfd_boolean remove_dead_literal
  (bfd *, asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   Elf_Internal_Rela *, source_reloc *, property_table_entry *, int);
static bfd_boolean identify_literal_placement
  (bfd *, asection *, bfd_byte *, struct bfd_link_info *,
   value_map_hash_table *, bfd_boolean *, Elf_Internal_Rela *, int,
   source_reloc *, property_table_entry *, int, section_cache_t *,
   bfd_boolean);
static bfd_boolean relocations_reach (source_reloc *, int, const r_reloc *);
static bfd_boolean coalesce_shared_literal
  (asection *, source_reloc *, property_table_entry *, int, value_map *);
static bfd_boolean move_shared_literal
  (asection *, struct bfd_link_info *, source_reloc *, property_table_entry *,
   int, const r_reloc *, const literal_value *, section_cache_t *);

/* Second pass: */
static bfd_boolean relax_section (bfd *, asection *, struct bfd_link_info *);
static bfd_boolean translate_section_fixes (asection *);
static bfd_boolean translate_reloc_bfd_fix (reloc_bfd_fix *);
static asection *translate_reloc (const r_reloc *, r_reloc *, asection *);
static void shrink_dynamic_reloc_sections
  (struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *);
static bfd_boolean move_literal
  (bfd *, struct bfd_link_info *, asection *, bfd_vma, bfd_byte *,
   xtensa_relax_info *, Elf_Internal_Rela **, const literal_value *);
static bfd_boolean relax_property_section
  (bfd *, asection *, struct bfd_link_info *);

/* Third pass: */
static bfd_boolean relax_section_symbols (bfd *, asection *);


static bfd_boolean
elf_xtensa_relax_section (bfd *abfd,
			  asection *sec,
			  struct bfd_link_info *link_info,
			  bfd_boolean *again)
{
  static value_map_hash_table *values = NULL;
  static bfd_boolean relocations_analyzed = FALSE;
  xtensa_relax_info *relax_info;

  if (!relocations_analyzed)
    {
      /* Do some overall initialization for relaxation.  */
      values = value_map_hash_table_init ();
      if (values == NULL)
	return FALSE;
      relaxing_section = TRUE;
      if (!analyze_relocations (link_info))
	return FALSE;
      relocations_analyzed = TRUE;
    }
  *again = FALSE;

  /* Don't mess with linker-created sections.  */
  if ((sec->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;

  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info != NULL);

  switch (relax_info->visited)
    {
    case 0:
      /* Note: It would be nice to fold this pass into
	 analyze_relocations, but it is important for this step that the
	 sections be examined in link order.  */
      if (!compute_removed_literals (abfd, sec, link_info, values))
	return FALSE;
      *again = TRUE;
      break;

    case 1:
      if (values)
	value_map_hash_table_delete (values);
      values = NULL;
      if (!relax_section (abfd, sec, link_info))
	return FALSE;
      *again = TRUE;
      break;

    case 2:
      if (!relax_section_symbols (abfd, sec))
	return FALSE;
      break;
    }

  relax_info->visited++;
  return TRUE;
}


/* Initialization for relaxation.  */

/* This function is called once at the start of relaxation.  It scans
   all the input sections and marks the ones that are relaxable (i.e.,
   literal sections with L32R relocations against them), and then
   collects source_reloc information for all the relocations against
   those relaxable sections.  During this process, it also detects
   longcalls, i.e., calls relaxed by the assembler into indirect
   calls, that can be optimized back into direct calls.  Within each
   extended basic block (ebb) containing an optimized longcall, it
   computes a set of "text actions" that can be performed to remove
   the L32R associated with the longcall while optionally preserving
   branch target alignments.  */

static bfd_boolean
analyze_relocations (struct bfd_link_info *link_info)
{
  bfd *abfd;
  asection *sec;
  bfd_boolean is_relaxable = FALSE;

  /* Initialize the per-section relaxation info.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	init_xtensa_relax_info (sec);
      }

  /* Mark relaxable sections (and count relocations against each one).  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	if (!find_relaxable_sections (abfd, sec, link_info, &is_relaxable))
	  return FALSE;
      }

  /* Bail out if there are no relaxable sections.  */
  if (!is_relaxable)
    return TRUE;

  /* Allocate space for source_relocs.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	xtensa_relax_info *relax_info;

	relax_info = get_xtensa_relax_info (sec);
	if (relax_info->is_relaxable_literal_section
	    || relax_info->is_relaxable_asm_section)
	  {
	    relax_info->src_relocs = (source_reloc *)
	      bfd_malloc (relax_info->src_count * sizeof (source_reloc));
	  }
	else
	  relax_info->src_count = 0;
      }

  /* Collect info on relocations against each relaxable section.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	if (!collect_source_relocs (abfd, sec, link_info))
	  return FALSE;
      }

  /* Compute the text actions.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	if (!compute_text_actions (abfd, sec, link_info))
	  return FALSE;
      }

  return TRUE;
}


/* Find all the sections that might be relaxed.  The motivation for
   this pass is that collect_source_relocs() needs to record _all_ the
   relocations that target each relaxable section.  That is expensive
   and unnecessary unless the target section is actually going to be
   relaxed.  This pass identifies all such sections by checking if
   they have L32Rs pointing to them.  In the process, the total number
   of relocations targeting each section is also counted so that we
   know how much space to allocate for source_relocs against each
   relaxable literal section.  */

static bfd_boolean
find_relaxable_sections (bfd *abfd,
			 asection *sec,
			 struct bfd_link_info *link_info,
			 bfd_boolean *is_relaxable_p)
{
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents;
  bfd_boolean ok = TRUE;
  unsigned i;
  xtensa_relax_info *source_relax_info;
  bfd_boolean is_l32r_reloc;

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);
  if (internal_relocs == NULL)
    return ok;

  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec->size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  source_relax_info = get_xtensa_relax_info (sec);
  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      r_reloc r_rel;
      asection *target_sec;
      xtensa_relax_info *target_relax_info;

      /* If this section has not already been marked as "relaxable", and
	 if it contains any ASM_EXPAND relocations (marking expanded
	 longcalls) that can be optimized into direct calls, then mark
	 the section as "relaxable".  */
      if (source_relax_info
	  && !source_relax_info->is_relaxable_asm_section
	  && ELF32_R_TYPE (irel->r_info) == R_XTENSA_ASM_EXPAND)
	{
	  bfd_boolean is_reachable = FALSE;
	  if (is_resolvable_asm_expansion (abfd, sec, contents, irel,
					   link_info, &is_reachable)
	      && is_reachable)
	    {
	      source_relax_info->is_relaxable_asm_section = TRUE;
	      *is_relaxable_p = TRUE;
	    }
	}

      r_reloc_init (&r_rel, abfd, irel, contents,
		    bfd_get_section_limit (abfd, sec));

      target_sec = r_reloc_get_section (&r_rel);
      target_relax_info = get_xtensa_relax_info (target_sec);
      if (!target_relax_info)
	continue;

      /* Count PC-relative operand relocations against the target section.
         Note: The conditions tested here must match the conditions under
	 which init_source_reloc is called in collect_source_relocs().  */
      is_l32r_reloc = FALSE;
      if (is_operand_relocation (ELF32_R_TYPE (irel->r_info)))
	{
	  xtensa_opcode opcode =
	    get_relocation_opcode (abfd, sec, contents, irel);
	  if (opcode != XTENSA_UNDEFINED)
	    {
	      is_l32r_reloc = (opcode == get_l32r_opcode ());
	      if (!is_alt_relocation (ELF32_R_TYPE (irel->r_info))
		  || is_l32r_reloc)
		target_relax_info->src_count++;
	    }
	}

      if (is_l32r_reloc && r_reloc_is_defined (&r_rel))
	{
	  /* Mark the target section as relaxable.  */
	  target_relax_info->is_relaxable_literal_section = TRUE;
	  *is_relaxable_p = TRUE;
	}
    }

 error_return:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  return ok;
}


/* Record _all_ the relocations that point to relaxable sections, and
   get rid of ASM_EXPAND relocs by either converting them to
   ASM_SIMPLIFY or by removing them.  */

static bfd_boolean
collect_source_relocs (bfd *abfd,
		       asection *sec,
		       struct bfd_link_info *link_info)
{
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents;
  bfd_boolean ok = TRUE;
  unsigned i;
  bfd_size_type sec_size;

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);
  if (internal_relocs == NULL)
    return ok;

  sec_size = bfd_get_section_limit (abfd, sec);
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  /* Record relocations against relaxable literal sections.  */
  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      r_reloc r_rel;
      asection *target_sec;
      xtensa_relax_info *target_relax_info;

      r_reloc_init (&r_rel, abfd, irel, contents, sec_size);

      target_sec = r_reloc_get_section (&r_rel);
      target_relax_info = get_xtensa_relax_info (target_sec);

      if (target_relax_info
	  && (target_relax_info->is_relaxable_literal_section
	      || target_relax_info->is_relaxable_asm_section))
	{
	  xtensa_opcode opcode = XTENSA_UNDEFINED;
	  int opnd = -1;
	  bfd_boolean is_abs_literal = FALSE;

	  if (is_alt_relocation (ELF32_R_TYPE (irel->r_info)))
	    {
	      /* None of the current alternate relocs are PC-relative,
		 and only PC-relative relocs matter here.  However, we
		 still need to record the opcode for literal
		 coalescing.  */
	      opcode = get_relocation_opcode (abfd, sec, contents, irel);
	      if (opcode == get_l32r_opcode ())
		{
		  is_abs_literal = TRUE;
		  opnd = 1;
		}
	      else
		opcode = XTENSA_UNDEFINED;
	    }
	  else if (is_operand_relocation (ELF32_R_TYPE (irel->r_info)))
	    {
	      opcode = get_relocation_opcode (abfd, sec, contents, irel);
	      opnd = get_relocation_opnd (opcode, ELF32_R_TYPE (irel->r_info));
	    }

	  if (opcode != XTENSA_UNDEFINED)
	    {
	      int src_next = target_relax_info->src_next++;
	      source_reloc *s_reloc = &target_relax_info->src_relocs[src_next];

	      init_source_reloc (s_reloc, sec, &r_rel, opcode, opnd,
				 is_abs_literal);
	    }
	}
    }

  /* Now get rid of ASM_EXPAND relocations.  At this point, the
     src_relocs array for the target literal section may still be
     incomplete, but it must at least contain the entries for the L32R
     relocations associated with ASM_EXPANDs because they were just
     added in the preceding loop over the relocations.  */

  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      bfd_boolean is_reachable;

      if (!is_resolvable_asm_expansion (abfd, sec, contents, irel, link_info,
					&is_reachable))
	continue;

      if (is_reachable)
	{
	  Elf_Internal_Rela *l32r_irel;
	  r_reloc r_rel;
	  asection *target_sec;
	  xtensa_relax_info *target_relax_info;

	  /* Mark the source_reloc for the L32R so that it will be
	     removed in compute_removed_literals(), along with the
	     associated literal.  */
	  l32r_irel = find_associated_l32r_irel (abfd, sec, contents,
						 irel, internal_relocs);
	  if (l32r_irel == NULL)
	    continue;

	  r_reloc_init (&r_rel, abfd, l32r_irel, contents, sec_size);

	  target_sec = r_reloc_get_section (&r_rel);
	  target_relax_info = get_xtensa_relax_info (target_sec);

	  if (target_relax_info
	      && (target_relax_info->is_relaxable_literal_section
		  || target_relax_info->is_relaxable_asm_section))
	    {
	      source_reloc *s_reloc;

	      /* Search the source_relocs for the entry corresponding to
		 the l32r_irel.  Note: The src_relocs array is not yet
		 sorted, but it wouldn't matter anyway because we're
		 searching by source offset instead of target offset.  */
	      s_reloc = find_source_reloc (target_relax_info->src_relocs,
					   target_relax_info->src_next,
					   sec, l32r_irel);
	      BFD_ASSERT (s_reloc);
	      s_reloc->is_null = TRUE;
	    }

	  /* Convert this reloc to ASM_SIMPLIFY.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       R_XTENSA_ASM_SIMPLIFY);
	  l32r_irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);

	  pin_internal_relocs (sec, internal_relocs);
	}
      else
	{
	  /* It is resolvable but doesn't reach.  We resolve now
	     by eliminating the relocation -- the call will remain
	     expanded into L32R/CALLX.  */
	  irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	  pin_internal_relocs (sec, internal_relocs);
	}
    }

 error_return:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  return ok;
}


/* Return TRUE if the asm expansion can be resolved.  Generally it can
   be resolved on a final link or when a partial link locates it in the
   same section as the target.  Set "is_reachable" flag if the target of
   the call is within the range of a direct call, given the current VMA
   for this section and the target section.  */

bfd_boolean
is_resolvable_asm_expansion (bfd *abfd,
			     asection *sec,
			     bfd_byte *contents,
			     Elf_Internal_Rela *irel,
			     struct bfd_link_info *link_info,
			     bfd_boolean *is_reachable_p)
{
  asection *target_sec;
  bfd_vma target_offset;
  r_reloc r_rel;
  xtensa_opcode opcode, direct_call_opcode;
  bfd_vma self_address;
  bfd_vma dest_address;
  bfd_boolean uses_l32r;
  bfd_size_type sec_size;

  *is_reachable_p = FALSE;

  if (contents == NULL)
    return FALSE;

  if (ELF32_R_TYPE (irel->r_info) != R_XTENSA_ASM_EXPAND)
    return FALSE;

  sec_size = bfd_get_section_limit (abfd, sec);
  opcode = get_expanded_call_opcode (contents + irel->r_offset,
				     sec_size - irel->r_offset, &uses_l32r);
  /* Optimization of longcalls that use CONST16 is not yet implemented.  */
  if (!uses_l32r)
    return FALSE;

  direct_call_opcode = swap_callx_for_call_opcode (opcode);
  if (direct_call_opcode == XTENSA_UNDEFINED)
    return FALSE;

  /* Check and see that the target resolves.  */
  r_reloc_init (&r_rel, abfd, irel, contents, sec_size);
  if (!r_reloc_is_defined (&r_rel))
    return FALSE;

  target_sec = r_reloc_get_section (&r_rel);
  target_offset = r_rel.target_offset;

  /* If the target is in a shared library, then it doesn't reach.  This
     isn't supposed to come up because the compiler should never generate
     non-PIC calls on systems that use shared libraries, but the linker
     shouldn't crash regardless.  */
  if (!target_sec->output_section)
    return FALSE;

  /* For relocatable sections, we can only simplify when the output
     section of the target is the same as the output section of the
     source.  */
  if (link_info->relocatable
      && (target_sec->output_section != sec->output_section
	  || is_reloc_sym_weak (abfd, irel)))
    return FALSE;

  self_address = (sec->output_section->vma
		  + sec->output_offset + irel->r_offset + 3);
  dest_address = (target_sec->output_section->vma
		  + target_sec->output_offset + target_offset);

  *is_reachable_p = pcrel_reloc_fits (direct_call_opcode, 0,
				      self_address, dest_address);

  if ((self_address >> CALL_SEGMENT_BITS) !=
      (dest_address >> CALL_SEGMENT_BITS))
    return FALSE;

  return TRUE;
}


static Elf_Internal_Rela *
find_associated_l32r_irel (bfd *abfd,
			   asection *sec,
			   bfd_byte *contents,
			   Elf_Internal_Rela *other_irel,
			   Elf_Internal_Rela *internal_relocs)
{
  unsigned i;

  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];

      if (irel == other_irel)
	continue;
      if (irel->r_offset != other_irel->r_offset)
	continue;
      if (is_l32r_relocation (abfd, sec, contents, irel))
	return irel;
    }

  return NULL;
}


static xtensa_opcode *
build_reloc_opcodes (bfd *abfd,
		     asection *sec,
		     bfd_byte *contents,
		     Elf_Internal_Rela *internal_relocs)
{
  unsigned i;
  xtensa_opcode *reloc_opcodes =
    (xtensa_opcode *) bfd_malloc (sizeof (xtensa_opcode) * sec->reloc_count);
  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      reloc_opcodes[i] = get_relocation_opcode (abfd, sec, contents, irel);
    }
  return reloc_opcodes;
}


/* The compute_text_actions function will build a list of potential
   transformation actions for code in the extended basic block of each
   longcall that is optimized to a direct call.  From this list we
   generate a set of actions to actually perform that optimizes for
   space and, if not using size_opt, maintains branch target
   alignments.

   These actions to be performed are placed on a per-section list.
   The actual changes are performed by relax_section() in the second
   pass.  */

bfd_boolean
compute_text_actions (bfd *abfd,
		      asection *sec,
		      struct bfd_link_info *link_info)
{
  xtensa_opcode *reloc_opcodes = NULL;
  xtensa_relax_info *relax_info;
  bfd_byte *contents;
  Elf_Internal_Rela *internal_relocs;
  bfd_boolean ok = TRUE;
  unsigned i;
  property_table_entry *prop_table = 0;
  int ptblsize = 0;
  bfd_size_type sec_size;

  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info);
  BFD_ASSERT (relax_info->src_next == relax_info->src_count);

  /* Do nothing if the section contains no optimized longcalls.  */
  if (!relax_info->is_relaxable_asm_section)
    return ok;

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);

  if (internal_relocs)
    qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
	   internal_reloc_compare);

  sec_size = bfd_get_section_limit (abfd, sec);
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  ptblsize = xtensa_read_table_entries (abfd, sec, &prop_table,
					XTENSA_PROP_SEC_NAME, FALSE);
  if (ptblsize < 0)
    {
      ok = FALSE;
      goto error_return;
    }

  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      bfd_vma r_offset;
      property_table_entry *the_entry;
      int ptbl_idx;
      ebb_t *ebb;
      ebb_constraint ebb_table;
      bfd_size_type simplify_size;

      if (irel && ELF32_R_TYPE (irel->r_info) != R_XTENSA_ASM_SIMPLIFY)
	continue;
      r_offset = irel->r_offset;

      simplify_size = get_asm_simplify_size (contents, sec_size, r_offset);
      if (simplify_size == 0)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): could not decode instruction for XTENSA_ASM_SIMPLIFY relocation; possible configuration mismatch"),
	     sec->owner, sec, r_offset);
	  continue;
	}

      /* If the instruction table is not around, then don't do this
	 relaxation.  */
      the_entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
						  sec->vma + irel->r_offset);
      if (the_entry == NULL || XTENSA_NO_NOP_REMOVAL)
	{
	  text_action_add (&relax_info->action_list,
			   ta_convert_longcall, sec, r_offset,
			   0);
	  continue;
	}

      /* If the next longcall happens to be at the same address as an
	 unreachable section of size 0, then skip forward.  */
      ptbl_idx = the_entry - prop_table;
      while ((the_entry->flags & XTENSA_PROP_UNREACHABLE)
	     && the_entry->size == 0
	     && ptbl_idx + 1 < ptblsize
	     && (prop_table[ptbl_idx + 1].address
		 == prop_table[ptbl_idx].address))
	{
	  ptbl_idx++;
	  the_entry++;
	}

      if (the_entry->flags & XTENSA_PROP_NO_TRANSFORM)
	  /* NO_REORDER is OK */
	continue;

      init_ebb_constraint (&ebb_table);
      ebb = &ebb_table.ebb;
      init_ebb (ebb, sec, contents, sec_size, prop_table, ptblsize,
		internal_relocs, sec->reloc_count);
      ebb->start_offset = r_offset + simplify_size;
      ebb->end_offset = r_offset + simplify_size;
      ebb->start_ptbl_idx = ptbl_idx;
      ebb->end_ptbl_idx = ptbl_idx;
      ebb->start_reloc_idx = i;
      ebb->end_reloc_idx = i;

      /* Precompute the opcode for each relocation.  */
      if (reloc_opcodes == NULL)
	reloc_opcodes = build_reloc_opcodes (abfd, sec, contents,
					     internal_relocs);

      if (!extend_ebb_bounds (ebb)
	  || !compute_ebb_proposed_actions (&ebb_table)
	  || !compute_ebb_actions (&ebb_table)
	  || !check_section_ebb_pcrels_fit (abfd, sec, contents,
					    internal_relocs, &ebb_table,
					    reloc_opcodes)
	  || !check_section_ebb_reduces (&ebb_table))
	{
	  /* If anything goes wrong or we get unlucky and something does
	     not fit, with our plan because of expansion between
	     critical branches, just convert to a NOP.  */

	  text_action_add (&relax_info->action_list,
			   ta_convert_longcall, sec, r_offset, 0);
	  i = ebb_table.ebb.end_reloc_idx;
	  free_ebb_constraint (&ebb_table);
	  continue;
	}

      text_action_add_proposed (&relax_info->action_list, &ebb_table, sec);

      /* Update the index so we do not go looking at the relocations
	 we have already processed.  */
      i = ebb_table.ebb.end_reloc_idx;
      free_ebb_constraint (&ebb_table);
    }

#if DEBUG
  if (relax_info->action_list.head)
    print_action_list (stderr, &relax_info->action_list);
#endif

error_return:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  if (prop_table)
    free (prop_table);
  if (reloc_opcodes)
    free (reloc_opcodes);

  return ok;
}


/* Do not widen an instruction if it is preceeded by a
   loop opcode.  It might cause misalignment.  */

static bfd_boolean
prev_instr_is_a_loop (bfd_byte *contents,
		      bfd_size_type content_length,
		      bfd_size_type offset)
{
  xtensa_opcode prev_opcode;

  if (offset < 3)
    return FALSE;
  prev_opcode = insn_decode_opcode (contents, content_length, offset-3, 0);
  return (xtensa_opcode_is_loop (xtensa_default_isa, prev_opcode) == 1);
}


/* Find all of the possible actions for an extended basic block.  */

bfd_boolean
compute_ebb_proposed_actions (ebb_constraint *ebb_table)
{
  const ebb_t *ebb = &ebb_table->ebb;
  unsigned rel_idx = ebb->start_reloc_idx;
  property_table_entry *entry, *start_entry, *end_entry;
  bfd_vma offset = 0;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;

  if (insnbuf == NULL)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  start_entry = &ebb->ptbl[ebb->start_ptbl_idx];
  end_entry = &ebb->ptbl[ebb->end_ptbl_idx];

  for (entry = start_entry; entry <= end_entry; entry++)
    {
      bfd_vma start_offset, end_offset;
      bfd_size_type insn_len;

      start_offset = entry->address - ebb->sec->vma;
      end_offset = entry->address + entry->size - ebb->sec->vma;

      if (entry == start_entry)
	start_offset = ebb->start_offset;
      if (entry == end_entry)
	end_offset = ebb->end_offset;
      offset = start_offset;

      if (offset == entry->address - ebb->sec->vma
	  && (entry->flags & XTENSA_PROP_INSN_BRANCH_TARGET) != 0)
	{
	  enum ebb_target_enum align_type = EBB_DESIRE_TGT_ALIGN;
	  BFD_ASSERT (offset != end_offset);
	  if (offset == end_offset)
	    return FALSE;

	  insn_len = insn_decode_len (ebb->contents, ebb->content_length,
				      offset);
	  if (insn_len == 0)
	    goto decode_error;

	  if (check_branch_target_aligned_address (offset, insn_len))
	    align_type = EBB_REQUIRE_TGT_ALIGN;

	  ebb_propose_action (ebb_table, align_type, 0,
			      ta_none, offset, 0, TRUE);
	}

      while (offset != end_offset)
	{
	  Elf_Internal_Rela *irel;
	  xtensa_opcode opcode;

	  while (rel_idx < ebb->end_reloc_idx
		 && (ebb->relocs[rel_idx].r_offset < offset
		     || (ebb->relocs[rel_idx].r_offset == offset
			 && (ELF32_R_TYPE (ebb->relocs[rel_idx].r_info)
			     != R_XTENSA_ASM_SIMPLIFY))))
	    rel_idx++;

	  /* Check for longcall.  */
	  irel = &ebb->relocs[rel_idx];
	  if (irel->r_offset == offset
	      && ELF32_R_TYPE (irel->r_info) == R_XTENSA_ASM_SIMPLIFY)
	    {
	      bfd_size_type simplify_size;

	      simplify_size = get_asm_simplify_size (ebb->contents,
						     ebb->content_length,
						     irel->r_offset);
	      if (simplify_size == 0)
		goto decode_error;

	      ebb_propose_action (ebb_table, EBB_NO_ALIGN, 0,
				  ta_convert_longcall, offset, 0, TRUE);

	      offset += simplify_size;
	      continue;
	    }

	  if (offset + MIN_INSN_LENGTH > ebb->content_length)
	    goto decode_error;
	  xtensa_insnbuf_from_chars (isa, insnbuf, &ebb->contents[offset],
				     ebb->content_length - offset);
	  fmt = xtensa_format_decode (isa, insnbuf);
	  if (fmt == XTENSA_UNDEFINED)
	    goto decode_error;
	  insn_len = xtensa_format_length (isa, fmt);
	  if (insn_len == (bfd_size_type) XTENSA_UNDEFINED)
	    goto decode_error;

	  if (xtensa_format_num_slots (isa, fmt) != 1)
	    {
	      offset += insn_len;
	      continue;
	    }

	  xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf);
	  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
	  if (opcode == XTENSA_UNDEFINED)
	    goto decode_error;

	  if ((entry->flags & XTENSA_PROP_INSN_NO_DENSITY) == 0
	      && (entry->flags & XTENSA_PROP_NO_TRANSFORM) == 0
	      && can_narrow_instruction (slotbuf, fmt, opcode) != 0)
	    {
	      /* Add an instruction narrow action.  */
	      ebb_propose_action (ebb_table, EBB_NO_ALIGN, 0,
				  ta_narrow_insn, offset, 0, FALSE);
	    }
	  else if ((entry->flags & XTENSA_PROP_NO_TRANSFORM) == 0
		   && can_widen_instruction (slotbuf, fmt, opcode) != 0
		   && ! prev_instr_is_a_loop (ebb->contents,
					      ebb->content_length, offset))
	    {
	      /* Add an instruction widen action.  */
	      ebb_propose_action (ebb_table, EBB_NO_ALIGN, 0,
				  ta_widen_insn, offset, 0, FALSE);
	    }
	  else if (xtensa_opcode_is_loop (xtensa_default_isa, opcode) == 1)
	    {
	      /* Check for branch targets.  */
	      ebb_propose_action (ebb_table, EBB_REQUIRE_LOOP_ALIGN, 0,
				  ta_none, offset, 0, TRUE);
	    }

	  offset += insn_len;
	}
    }

  if (ebb->ends_unreachable)
    {
      ebb_propose_action (ebb_table, EBB_NO_ALIGN, 0,
			  ta_fill, ebb->end_offset, 0, TRUE);
    }

  return TRUE;

 decode_error:
  (*_bfd_error_handler)
    (_("%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"),
     ebb->sec->owner, ebb->sec, offset);
  return FALSE;
}


/* After all of the information has collected about the
   transformations possible in an EBB, compute the appropriate actions
   here in compute_ebb_actions.  We still must check later to make
   sure that the actions do not break any relocations.  The algorithm
   used here is pretty greedy.  Basically, it removes as many no-ops
   as possible so that the end of the EBB has the same alignment
   characteristics as the original.  First, it uses narrowing, then
   fill space at the end of the EBB, and finally widenings.  If that
   does not work, it tries again with one fewer no-op removed.  The
   optimization will only be performed if all of the branch targets
   that were aligned before transformation are also aligned after the
   transformation.

   When the size_opt flag is set, ignore the branch target alignments,
   narrow all wide instructions, and remove all no-ops unless the end
   of the EBB prevents it.  */

bfd_boolean
compute_ebb_actions (ebb_constraint *ebb_table)
{
  unsigned i = 0;
  unsigned j;
  int removed_bytes = 0;
  ebb_t *ebb = &ebb_table->ebb;
  unsigned seg_idx_start = 0;
  unsigned seg_idx_end = 0;

  /* We perform this like the assembler relaxation algorithm: Start by
     assuming all instructions are narrow and all no-ops removed; then
     walk through....  */

  /* For each segment of this that has a solid constraint, check to
     see if there are any combinations that will keep the constraint.
     If so, use it.  */
  for (seg_idx_end = 0; seg_idx_end < ebb_table->action_count; seg_idx_end++)
    {
      bfd_boolean requires_text_end_align = FALSE;
      unsigned longcall_count = 0;
      unsigned longcall_convert_count = 0;
      unsigned narrowable_count = 0;
      unsigned narrowable_convert_count = 0;
      unsigned widenable_count = 0;
      unsigned widenable_convert_count = 0;

      proposed_action *action = NULL;
      int align = (1 << ebb_table->ebb.sec->alignment_power);

      seg_idx_start = seg_idx_end;

      for (i = seg_idx_start; i < ebb_table->action_count; i++)
	{
	  action = &ebb_table->actions[i];
	  if (action->action == ta_convert_longcall)
	    longcall_count++;
	  if (action->action == ta_narrow_insn)
	    narrowable_count++;
	  if (action->action == ta_widen_insn)
	    widenable_count++;
	  if (action->action == ta_fill)
	    break;
	  if (action->align_type == EBB_REQUIRE_LOOP_ALIGN)
	    break;
	  if (action->align_type == EBB_REQUIRE_TGT_ALIGN
	      && !elf32xtensa_size_opt)
	    break;
	}
      seg_idx_end = i;

      if (seg_idx_end == ebb_table->action_count && !ebb->ends_unreachable)
	requires_text_end_align = TRUE;

      if (elf32xtensa_size_opt && !requires_text_end_align
	  && action->align_type != EBB_REQUIRE_LOOP_ALIGN
	  && action->align_type != EBB_REQUIRE_TGT_ALIGN)
	{
	  longcall_convert_count = longcall_count;
	  narrowable_convert_count = narrowable_count;
	  widenable_convert_count = 0;
	}
      else
	{
	  /* There is a constraint.  Convert the max number of longcalls.  */
	  narrowable_convert_count = 0;
	  longcall_convert_count = 0;
	  widenable_convert_count = 0;

	  for (j = 0; j < longcall_count; j++)
	    {
	      int removed = (longcall_count - j) * 3 & (align - 1);
	      unsigned desire_narrow = (align - removed) & (align - 1);
	      unsigned desire_widen = removed;
	      if (desire_narrow <= narrowable_count)
		{
		  narrowable_convert_count = desire_narrow;
		  narrowable_convert_count +=
		    (align * ((narrowable_count - narrowable_convert_count)
			      / align));
		  longcall_convert_count = (longcall_count - j);
		  widenable_convert_count = 0;
		  break;
		}
	      if (desire_widen <= widenable_count && !elf32xtensa_size_opt)
		{
		  narrowable_convert_count = 0;
		  longcall_convert_count = longcall_count - j;
		  widenable_convert_count = desire_widen;
		  break;
		}
	    }
	}

      /* Now the number of conversions are saved.  Do them.  */
      for (i = seg_idx_start; i < seg_idx_end; i++)
	{
	  action = &ebb_table->actions[i];
	  switch (action->action)
	    {
	    case ta_convert_longcall:
	      if (longcall_convert_count != 0)
		{
		  action->action = ta_remove_longcall;
		  action->do_action = TRUE;
		  action->removed_bytes += 3;
		  longcall_convert_count--;
		}
	      break;
	    case ta_narrow_insn:
	      if (narrowable_convert_count != 0)
		{
		  action->do_action = TRUE;
		  action->removed_bytes += 1;
		  narrowable_convert_count--;
		}
	      break;
	    case ta_widen_insn:
	      if (widenable_convert_count != 0)
		{
		  action->do_action = TRUE;
		  action->removed_bytes -= 1;
		  widenable_convert_count--;
		}
	      break;
	    default:
	      break;
	    }
	}
    }

  /* Now we move on to some local opts.  Try to remove each of the
     remaining longcalls.  */

  if (ebb_table->ebb.ends_section || ebb_table->ebb.ends_unreachable)
    {
      removed_bytes = 0;
      for (i = 0; i < ebb_table->action_count; i++)
	{
	  int old_removed_bytes = removed_bytes;
	  proposed_action *action = &ebb_table->actions[i];

	  if (action->do_action && action->action == ta_convert_longcall)
	    {
	      bfd_boolean bad_alignment = FALSE;
	      removed_bytes += 3;
	      for (j = i + 1; j < ebb_table->action_count; j++)
		{
		  proposed_action *new_action = &ebb_table->actions[j];
		  bfd_vma offset = new_action->offset;
		  if (new_action->align_type == EBB_REQUIRE_TGT_ALIGN)
		    {
		      if (!check_branch_target_aligned
			  (ebb_table->ebb.contents,
			   ebb_table->ebb.content_length,
			   offset, offset - removed_bytes))
			{
			  bad_alignment = TRUE;
			  break;
			}
		    }
		  if (new_action->align_type == EBB_REQUIRE_LOOP_ALIGN)
		    {
		      if (!check_loop_aligned (ebb_table->ebb.contents,
					       ebb_table->ebb.content_length,
					       offset,
					       offset - removed_bytes))
			{
			  bad_alignment = TRUE;
			  break;
			}
		    }
		  if (new_action->action == ta_narrow_insn
		      && !new_action->do_action
		      && ebb_table->ebb.sec->alignment_power == 2)
		    {
		      /* Narrow an instruction and we are done.  */
		      new_action->do_action = TRUE;
		      new_action->removed_bytes += 1;
		      bad_alignment = FALSE;
		      break;
		    }
		  if (new_action->action == ta_widen_insn
		      && new_action->do_action
		      && ebb_table->ebb.sec->alignment_power == 2)
		    {
		      /* Narrow an instruction and we are done.  */
		      new_action->do_action = FALSE;
		      new_action->removed_bytes += 1;
		      bad_alignment = FALSE;
		      break;
		    }
		  if (new_action->do_action)
		    removed_bytes += new_action->removed_bytes;
		}
	      if (!bad_alignment)
		{
		  action->removed_bytes += 3;
		  action->action = ta_remove_longcall;
		  action->do_action = TRUE;
		}
	    }
	  removed_bytes = old_removed_bytes;
	  if (action->do_action)
	    removed_bytes += action->removed_bytes;
	}
    }

  removed_bytes = 0;
  for (i = 0; i < ebb_table->action_count; ++i)
    {
      proposed_action *action = &ebb_table->actions[i];
      if (action->do_action)
	removed_bytes += action->removed_bytes;
    }

  if ((removed_bytes % (1 << ebb_table->ebb.sec->alignment_power)) != 0
      && ebb->ends_unreachable)
    {
      proposed_action *action;
      int br;
      int extra_space;

      BFD_ASSERT (ebb_table->action_count != 0);
      action = &ebb_table->actions[ebb_table->action_count - 1];
      BFD_ASSERT (action->action == ta_fill);
      BFD_ASSERT (ebb->ends_unreachable->flags & XTENSA_PROP_UNREACHABLE);

      extra_space = compute_fill_extra_space (ebb->ends_unreachable);
      br = action->removed_bytes + removed_bytes + extra_space;
      br = br & ((1 << ebb->sec->alignment_power ) - 1);

      action->removed_bytes = extra_space - br;
    }
  return TRUE;
}


/* The xlate_map is a sorted array of address mappings designed to
   answer the offset_with_removed_text() query with a binary search instead
   of a linear search through the section's action_list.  */

typedef struct xlate_map_entry xlate_map_entry_t;
typedef struct xlate_map xlate_map_t;

struct xlate_map_entry
{
  unsigned orig_address;
  unsigned new_address;
  unsigned size;
};

struct xlate_map
{
  unsigned entry_count;
  xlate_map_entry_t *entry;
};


static int
xlate_compare (const void *a_v, const void *b_v)
{
  const xlate_map_entry_t *a = (const xlate_map_entry_t *) a_v;
  const xlate_map_entry_t *b = (const xlate_map_entry_t *) b_v;
  if (a->orig_address < b->orig_address)
    return -1;
  if (a->orig_address > (b->orig_address + b->size - 1))
    return 1;
  return 0;
}


static bfd_vma
xlate_offset_with_removed_text (const xlate_map_t *map,
				text_action_list *action_list,
				bfd_vma offset)
{
  void *r;
  xlate_map_entry_t *e;

  if (map == NULL)
    return offset_with_removed_text (action_list, offset);

  if (map->entry_count == 0)
    return offset;

  r = bsearch (&offset, map->entry, map->entry_count,
	       sizeof (xlate_map_entry_t), &xlate_compare);
  e = (xlate_map_entry_t *) r;

  BFD_ASSERT (e != NULL);
  if (e == NULL)
    return offset;
  return e->new_address - e->orig_address + offset;
}


/* Build a binary searchable offset translation map from a section's
   action list.  */

static xlate_map_t *
build_xlate_map (asection *sec, xtensa_relax_info *relax_info)
{
  xlate_map_t *map = (xlate_map_t *) bfd_malloc (sizeof (xlate_map_t));
  text_action_list *action_list = &relax_info->action_list;
  unsigned num_actions = 0;
  text_action *r;
  int removed;
  xlate_map_entry_t *current_entry;

  if (map == NULL)
    return NULL;

  num_actions = action_list_count (action_list);
  map->entry = (xlate_map_entry_t *)
    bfd_malloc (sizeof (xlate_map_entry_t) * (num_actions + 1));
  if (map->entry == NULL)
    {
      free (map);
      return NULL;
    }
  map->entry_count = 0;

  removed = 0;
  current_entry = &map->entry[0];

  current_entry->orig_address = 0;
  current_entry->new_address = 0;
  current_entry->size = 0;

  for (r = action_list->head; r != NULL; r = r->next)
    {
      unsigned orig_size = 0;
      switch (r->action)
	{
	case ta_none:
	case ta_remove_insn:
	case ta_convert_longcall:
	case ta_remove_literal:
	case ta_add_literal:
	  break;
	case ta_remove_longcall:
	  orig_size = 6;
	  break;
	case ta_narrow_insn:
	  orig_size = 3;
	  break;
	case ta_widen_insn:
	  orig_size = 2;
	  break;
	case ta_fill:
	  break;
	}
      current_entry->size =
	r->offset + orig_size - current_entry->orig_address;
      if (current_entry->size != 0)
	{
	  current_entry++;
	  map->entry_count++;
	}
      current_entry->orig_address = r->offset + orig_size;
      removed += r->removed_bytes;
      current_entry->new_address = r->offset + orig_size - removed;
      current_entry->size = 0;
    }

  current_entry->size = (bfd_get_section_limit (sec->owner, sec)
			 - current_entry->orig_address);
  if (current_entry->size != 0)
    map->entry_count++;

  return map;
}


/* Free an offset translation map.  */

static void
free_xlate_map (xlate_map_t *map)
{
  if (map && map->entry)
    free (map->entry);
  if (map)
    free (map);
}


/* Use check_section_ebb_pcrels_fit to make sure that all of the
   relocations in a section will fit if a proposed set of actions
   are performed.  */

static bfd_boolean
check_section_ebb_pcrels_fit (bfd *abfd,
			      asection *sec,
			      bfd_byte *contents,
			      Elf_Internal_Rela *internal_relocs,
			      const ebb_constraint *constraint,
			      const xtensa_opcode *reloc_opcodes)
{
  unsigned i, j;
  Elf_Internal_Rela *irel;
  xlate_map_t *xmap = NULL;
  bfd_boolean ok = TRUE;
  xtensa_relax_info *relax_info;

  relax_info = get_xtensa_relax_info (sec);

  if (relax_info && sec->reloc_count > 100)
    {
      xmap = build_xlate_map (sec, relax_info);
      /* NULL indicates out of memory, but the slow version
	 can still be used.  */
    }

  for (i = 0; i < sec->reloc_count; i++)
    {
      r_reloc r_rel;
      bfd_vma orig_self_offset, orig_target_offset;
      bfd_vma self_offset, target_offset;
      int r_type;
      reloc_howto_type *howto;
      int self_removed_bytes, target_removed_bytes;

      irel = &internal_relocs[i];
      r_type = ELF32_R_TYPE (irel->r_info);

      howto = &elf_howto_table[r_type];
      /* We maintain the required invariant: PC-relative relocations
	 that fit before linking must fit after linking.  Thus we only
	 need to deal with relocations to the same section that are
	 PC-relative.  */
      if (r_type == R_XTENSA_ASM_SIMPLIFY
	  || r_type == R_XTENSA_32_PCREL
	  || !howto->pc_relative)
	continue;

      r_reloc_init (&r_rel, abfd, irel, contents,
		    bfd_get_section_limit (abfd, sec));

      if (r_reloc_get_section (&r_rel) != sec)
	continue;

      orig_self_offset = irel->r_offset;
      orig_target_offset = r_rel.target_offset;

      self_offset = orig_self_offset;
      target_offset = orig_target_offset;

      if (relax_info)
	{
	  self_offset =
	    xlate_offset_with_removed_text (xmap, &relax_info->action_list,
					    orig_self_offset);
	  target_offset =
	    xlate_offset_with_removed_text (xmap, &relax_info->action_list,
					    orig_target_offset);
	}

      self_removed_bytes = 0;
      target_removed_bytes = 0;

      for (j = 0; j < constraint->action_count; ++j)
	{
	  proposed_action *action = &constraint->actions[j];
	  bfd_vma offset = action->offset;
	  int removed_bytes = action->removed_bytes;
	  if (offset < orig_self_offset
	      || (offset == orig_self_offset && action->action == ta_fill
		  && action->removed_bytes < 0))
	    self_removed_bytes += removed_bytes;
	  if (offset < orig_target_offset
	      || (offset == orig_target_offset && action->action == ta_fill
		  && action->removed_bytes < 0))
	    target_removed_bytes += removed_bytes;
	}
      self_offset -= self_removed_bytes;
      target_offset -= target_removed_bytes;

      /* Try to encode it.  Get the operand and check.  */
      if (is_alt_relocation (ELF32_R_TYPE (irel->r_info)))
	{
	  /* None of the current alternate relocs are PC-relative,
	     and only PC-relative relocs matter here.  */
	}
      else
	{
	  xtensa_opcode opcode;
	  int opnum;

	  if (reloc_opcodes)
	    opcode = reloc_opcodes[i];
	  else
	    opcode = get_relocation_opcode (abfd, sec, contents, irel);
	  if (opcode == XTENSA_UNDEFINED)
	    {
	      ok = FALSE;
	      break;
	    }

	  opnum = get_relocation_opnd (opcode, ELF32_R_TYPE (irel->r_info));
	  if (opnum == XTENSA_UNDEFINED)
	    {
	      ok = FALSE;
	      break;
	    }

	  if (!pcrel_reloc_fits (opcode, opnum, self_offset, target_offset))
	    {
	      ok = FALSE;
	      break;
	    }
	}
    }

  if (xmap)
    free_xlate_map (xmap);

  return ok;
}


static bfd_boolean
check_section_ebb_reduces (const ebb_constraint *constraint)
{
  int removed = 0;
  unsigned i;

  for (i = 0; i < constraint->action_count; i++)
    {
      const proposed_action *action = &constraint->actions[i];
      if (action->do_action)
	removed += action->removed_bytes;
    }
  if (removed < 0)
    return FALSE;

  return TRUE;
}


void
text_action_add_proposed (text_action_list *l,
			  const ebb_constraint *ebb_table,
			  asection *sec)
{
  unsigned i;

  for (i = 0; i < ebb_table->action_count; i++)
    {
      proposed_action *action = &ebb_table->actions[i];

      if (!action->do_action)
	continue;
      switch (action->action)
	{
	case ta_remove_insn:
	case ta_remove_longcall:
	case ta_convert_longcall:
	case ta_narrow_insn:
	case ta_widen_insn:
	case ta_fill:
	case ta_remove_literal:
	  text_action_add (l, action->action, sec, action->offset,
			   action->removed_bytes);
	  break;
	case ta_none:
	  break;
	default:
	  BFD_ASSERT (0);
	  break;
	}
    }
}


int
compute_fill_extra_space (property_table_entry *entry)
{
  int fill_extra_space;

  if (!entry)
    return 0;

  if ((entry->flags & XTENSA_PROP_UNREACHABLE) == 0)
    return 0;

  fill_extra_space = entry->size;
  if ((entry->flags & XTENSA_PROP_ALIGN) != 0)
    {
      /* Fill bytes for alignment:
	 (2**n)-1 - (addr + (2**n)-1) & (2**n -1) */
      int pow = GET_XTENSA_PROP_ALIGNMENT (entry->flags);
      int nsm = (1 << pow) - 1;
      bfd_vma addr = entry->address + entry->size;
      bfd_vma align_fill = nsm - ((addr + nsm) & nsm);
      fill_extra_space += align_fill;
    }
  return fill_extra_space;
}


/* First relaxation pass.  */

/* If the section contains relaxable literals, check each literal to
   see if it has the same value as another literal that has already
   been seen, either in the current section or a previous one.  If so,
   add an entry to the per-section list of removed literals.  The
   actual changes are deferred until the next pass.  */

static bfd_boolean
compute_removed_literals (bfd *abfd,
			  asection *sec,
			  struct bfd_link_info *link_info,
			  value_map_hash_table *values)
{
  xtensa_relax_info *relax_info;
  bfd_byte *contents;
  Elf_Internal_Rela *internal_relocs;
  source_reloc *src_relocs, *rel;
  bfd_boolean ok = TRUE;
  property_table_entry *prop_table = NULL;
  int ptblsize;
  int i, prev_i;
  bfd_boolean last_loc_is_prev = FALSE;
  bfd_vma last_target_offset = 0;
  section_cache_t target_sec_cache;
  bfd_size_type sec_size;

  init_section_cache (&target_sec_cache);

  /* Do nothing if it is not a relaxable literal section.  */
  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info);
  if (!relax_info->is_relaxable_literal_section)
    return ok;

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);

  sec_size = bfd_get_section_limit (abfd, sec);
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  /* Sort the source_relocs by target offset.  */
  src_relocs = relax_info->src_relocs;
  qsort (src_relocs, relax_info->src_count,
	 sizeof (source_reloc), source_reloc_compare);
  qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
	 internal_reloc_compare);

  ptblsize = xtensa_read_table_entries (abfd, sec, &prop_table,
					XTENSA_PROP_SEC_NAME, FALSE);
  if (ptblsize < 0)
    {
      ok = FALSE;
      goto error_return;
    }

  prev_i = -1;
  for (i = 0; i < relax_info->src_count; i++)
    {
      Elf_Internal_Rela *irel = NULL;

      rel = &src_relocs[i];
      if (get_l32r_opcode () != rel->opcode)
	continue;
      irel = get_irel_at_offset (sec, internal_relocs,
				 rel->r_rel.target_offset);

      /* If the relocation on this is not a simple R_XTENSA_32 or
	 R_XTENSA_PLT then do not consider it.  This may happen when
	 the difference of two symbols is used in a literal.  */
      if (irel && (ELF32_R_TYPE (irel->r_info) != R_XTENSA_32
		   && ELF32_R_TYPE (irel->r_info) != R_XTENSA_PLT))
	continue;

      /* If the target_offset for this relocation is the same as the
	 previous relocation, then we've already considered whether the
	 literal can be coalesced.  Skip to the next one....  */
      if (i != 0 && prev_i != -1
	  && src_relocs[i-1].r_rel.target_offset == rel->r_rel.target_offset)
	continue;
      prev_i = i;

      if (last_loc_is_prev &&
	  last_target_offset + 4 != rel->r_rel.target_offset)
	last_loc_is_prev = FALSE;

      /* Check if the relocation was from an L32R that is being removed
	 because a CALLX was converted to a direct CALL, and check if
	 there are no other relocations to the literal.  */
      if (is_removable_literal (rel, i, src_relocs, relax_info->src_count,
				sec, prop_table, ptblsize))
	{
	  if (!remove_dead_literal (abfd, sec, link_info, internal_relocs,
				    irel, rel, prop_table, ptblsize))
	    {
	      ok = FALSE;
	      goto error_return;
	    }
	  last_target_offset = rel->r_rel.target_offset;
	  continue;
	}

      if (!identify_literal_placement (abfd, sec, contents, link_info,
				       values,
				       &last_loc_is_prev, irel,
				       relax_info->src_count - i, rel,
				       prop_table, ptblsize,
				       &target_sec_cache, rel->is_abs_literal))
	{
	  ok = FALSE;
	  goto error_return;
	}
      last_target_offset = rel->r_rel.target_offset;
    }

#if DEBUG
  print_removed_literals (stderr, &relax_info->removed_list);
  print_action_list (stderr, &relax_info->action_list);
#endif /* DEBUG */

error_return:
  if (prop_table)
    free (prop_table);
  free_section_cache (&target_sec_cache);

  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  return ok;
}


static Elf_Internal_Rela *
get_irel_at_offset (asection *sec,
		    Elf_Internal_Rela *internal_relocs,
		    bfd_vma offset)
{
  unsigned i;
  Elf_Internal_Rela *irel;
  unsigned r_type;
  Elf_Internal_Rela key;

  if (!internal_relocs)
    return NULL;

  key.r_offset = offset;
  irel = bsearch (&key, internal_relocs, sec->reloc_count,
		  sizeof (Elf_Internal_Rela), internal_reloc_matches);
  if (!irel)
    return NULL;

  /* bsearch does not guarantee which will be returned if there are
     multiple matches.  We need the first that is not an alignment.  */
  i = irel - internal_relocs;
  while (i > 0)
    {
      if (internal_relocs[i-1].r_offset != offset)
	break;
      i--;
    }
  for ( ; i < sec->reloc_count; i++)
    {
      irel = &internal_relocs[i];
      r_type = ELF32_R_TYPE (irel->r_info);
      if (irel->r_offset == offset && r_type != R_XTENSA_NONE)
	return irel;
    }

  return NULL;
}


bfd_boolean
is_removable_literal (const source_reloc *rel,
		      int i,
		      const source_reloc *src_relocs,
		      int src_count,
		      asection *sec,
		      property_table_entry *prop_table,
		      int ptblsize)
{
  const source_reloc *curr_rel;
  property_table_entry *entry;

  if (!rel->is_null)
    return FALSE;

  entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
					  sec->vma + rel->r_rel.target_offset);
  if (entry && (entry->flags & XTENSA_PROP_NO_TRANSFORM))
    return FALSE;

  for (++i; i < src_count; ++i)
    {
      curr_rel = &src_relocs[i];
      /* If all others have the same target offset....  */
      if (curr_rel->r_rel.target_offset != rel->r_rel.target_offset)
	return TRUE;

      if (!curr_rel->is_null
	  && !xtensa_is_property_section (curr_rel->source_sec)
	  && !(curr_rel->source_sec->flags & SEC_DEBUGGING))
	return FALSE;
    }
  return TRUE;
}


bfd_boolean
remove_dead_literal (bfd *abfd,
		     asection *sec,
		     struct bfd_link_info *link_info,
		     Elf_Internal_Rela *internal_relocs,
		     Elf_Internal_Rela *irel,
		     source_reloc *rel,
		     property_table_entry *prop_table,
		     int ptblsize)
{
  property_table_entry *entry;
  xtensa_relax_info *relax_info;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    return FALSE;

  entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
					  sec->vma + rel->r_rel.target_offset);

  /* Mark the unused literal so that it will be removed.  */
  add_removed_literal (&relax_info->removed_list, &rel->r_rel, NULL);

  text_action_add (&relax_info->action_list,
		   ta_remove_literal, sec, rel->r_rel.target_offset, 4);

  /* If the section is 4-byte aligned, do not add fill.  */
  if (sec->alignment_power > 2)
    {
      int fill_extra_space;
      bfd_vma entry_sec_offset;
      text_action *fa;
      property_table_entry *the_add_entry;
      int removed_diff;

      if (entry)
	entry_sec_offset = entry->address - sec->vma + entry->size;
      else
	entry_sec_offset = rel->r_rel.target_offset + 4;

      /* If the literal range is at the end of the section,
	 do not add fill.  */
      the_add_entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
						      entry_sec_offset);
      fill_extra_space = compute_fill_extra_space (the_add_entry);

      fa = find_fill_action (&relax_info->action_list, sec, entry_sec_offset);
      removed_diff = compute_removed_action_diff (fa, sec, entry_sec_offset,
						  -4, fill_extra_space);
      if (fa)
	adjust_fill_action (fa, removed_diff);
      else
	text_action_add (&relax_info->action_list,
			 ta_fill, sec, entry_sec_offset, removed_diff);
    }

  /* Zero out the relocation on this literal location.  */
  if (irel)
    {
      if (elf_hash_table (link_info)->dynamic_sections_created)
	shrink_dynamic_reloc_sections (link_info, abfd, sec, irel);

      irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
      pin_internal_relocs (sec, internal_relocs);
    }

  /* Do not modify "last_loc_is_prev".  */
  return TRUE;
}


bfd_boolean
identify_literal_placement (bfd *abfd,
			    asection *sec,
			    bfd_byte *contents,
			    struct bfd_link_info *link_info,
			    value_map_hash_table *values,
			    bfd_boolean *last_loc_is_prev_p,
			    Elf_Internal_Rela *irel,
			    int remaining_src_rels,
			    source_reloc *rel,
			    property_table_entry *prop_table,
			    int ptblsize,
			    section_cache_t *target_sec_cache,
			    bfd_boolean is_abs_literal)
{
  literal_value val;
  value_map *val_map;
  xtensa_relax_info *relax_info;
  bfd_boolean literal_placed = FALSE;
  r_reloc r_rel;
  unsigned long value;
  bfd_boolean final_static_link;
  bfd_size_type sec_size;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    return FALSE;

  sec_size = bfd_get_section_limit (abfd, sec);

  final_static_link =
    (!link_info->relocatable
     && !elf_hash_table (link_info)->dynamic_sections_created);

  /* The placement algorithm first checks to see if the literal is
     already in the value map.  If so and the value map is reachable
     from all uses, then the literal is moved to that location.  If
     not, then we identify the last location where a fresh literal was
     placed.  If the literal can be safely moved there, then we do so.
     If not, then we assume that the literal is not to move and leave
     the literal where it is, marking it as the last literal
     location.  */

  /* Find the literal value.  */
  value = 0;
  r_reloc_init (&r_rel, abfd, irel, contents, sec_size);
  if (!irel)
    {
      BFD_ASSERT (rel->r_rel.target_offset < sec_size);
      value = bfd_get_32 (abfd, contents + rel->r_rel.target_offset);
    }
  init_literal_value (&val, &r_rel, value, is_abs_literal);

  /* Check if we've seen another literal with the same value that
     is in the same output section.  */
  val_map = value_map_get_cached_value (values, &val, final_static_link);

  if (val_map
      && (r_reloc_get_section (&val_map->loc)->output_section
	  == sec->output_section)
      && relocations_reach (rel, remaining_src_rels, &val_map->loc)
      && coalesce_shared_literal (sec, rel, prop_table, ptblsize, val_map))
    {
      /* No change to last_loc_is_prev.  */
      literal_placed = TRUE;
    }

  /* For relocatable links, do not try to move literals.  To do it
     correctly might increase the number of relocations in an input
     section making the default relocatable linking fail.  */
  if (!link_info->relocatable && !literal_placed
      && values->has_last_loc && !(*last_loc_is_prev_p))
    {
      asection *target_sec = r_reloc_get_section (&values->last_loc);
      if (target_sec && target_sec->output_section == sec->output_section)
	{
	  /* Increment the virtual offset.  */
	  r_reloc try_loc = values->last_loc;
	  try_loc.virtual_offset += 4;

	  /* There is a last loc that was in the same output section.  */
	  if (relocations_reach (rel, remaining_src_rels, &try_loc)
	      && move_shared_literal (sec, link_info, rel,
				      prop_table, ptblsize,
				      &try_loc, &val, target_sec_cache))
	    {
	      values->last_loc.virtual_offset += 4;
	      literal_placed = TRUE;
	      if (!val_map)
		val_map = add_value_map (values, &val, &try_loc,
					 final_static_link);
	      else
		val_map->loc = try_loc;
	    }
	}
    }

  if (!literal_placed)
    {
      /* Nothing worked, leave the literal alone but update the last loc.  */
      values->has_last_loc = TRUE;
      values->last_loc = rel->r_rel;
      if (!val_map)
	val_map = add_value_map (values, &val, &rel->r_rel, final_static_link);
      else
	val_map->loc = rel->r_rel;
      *last_loc_is_prev_p = TRUE;
    }

  return TRUE;
}


/* Check if the original relocations (presumably on L32R instructions)
   identified by reloc[0..N] can be changed to reference the literal
   identified by r_rel.  If r_rel is out of range for any of the
   original relocations, then we don't want to coalesce the original
   literal with the one at r_rel.  We only check reloc[0..N], where the
   offsets are all the same as for reloc[0] (i.e., they're all
   referencing the same literal) and where N is also bounded by the
   number of remaining entries in the "reloc" array.  The "reloc" array
   is sorted by target offset so we know all the entries for the same
   literal will be contiguous.  */

static bfd_boolean
relocations_reach (source_reloc *reloc,
		   int remaining_relocs,
		   const r_reloc *r_rel)
{
  bfd_vma from_offset, source_address, dest_address;
  asection *sec;
  int i;

  if (!r_reloc_is_defined (r_rel))
    return FALSE;

  sec = r_reloc_get_section (r_rel);
  from_offset = reloc[0].r_rel.target_offset;

  for (i = 0; i < remaining_relocs; i++)
    {
      if (reloc[i].r_rel.target_offset != from_offset)
	break;

      /* Ignore relocations that have been removed.  */
      if (reloc[i].is_null)
	continue;

      /* The original and new output section for these must be the same
         in order to coalesce.  */
      if (r_reloc_get_section (&reloc[i].r_rel)->output_section
	  != sec->output_section)
	return FALSE;

      /* Absolute literals in the same output section can always be
	 combined.  */
      if (reloc[i].is_abs_literal)
	continue;

      /* A literal with no PC-relative relocations can be moved anywhere.  */
      if (reloc[i].opnd != -1)
	{
	  /* Otherwise, check to see that it fits.  */
	  source_address = (reloc[i].source_sec->output_section->vma
			    + reloc[i].source_sec->output_offset
			    + reloc[i].r_rel.rela.r_offset);
	  dest_address = (sec->output_section->vma
			  + sec->output_offset
			  + r_rel->target_offset);

	  if (!pcrel_reloc_fits (reloc[i].opcode, reloc[i].opnd,
				 source_address, dest_address))
	    return FALSE;
	}
    }

  return TRUE;
}


/* Move a literal to another literal location because it is
   the same as the other literal value.  */

static bfd_boolean
coalesce_shared_literal (asection *sec,
			 source_reloc *rel,
			 property_table_entry *prop_table,
			 int ptblsize,
			 value_map *val_map)
{
  property_table_entry *entry;
  text_action *fa;
  property_table_entry *the_add_entry;
  int removed_diff;
  xtensa_relax_info *relax_info;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    return FALSE;

  entry = elf_xtensa_find_property_entry
    (prop_table, ptblsize, sec->vma + rel->r_rel.target_offset);
  if (entry && (entry->flags & XTENSA_PROP_NO_TRANSFORM))
    return TRUE;

  /* Mark that the literal will be coalesced.  */
  add_removed_literal (&relax_info->removed_list, &rel->r_rel, &val_map->loc);

  text_action_add (&relax_info->action_list,
		   ta_remove_literal, sec, rel->r_rel.target_offset, 4);

  /* If the section is 4-byte aligned, do not add fill.  */
  if (sec->alignment_power > 2)
    {
      int fill_extra_space;
      bfd_vma entry_sec_offset;

      if (entry)
	entry_sec_offset = entry->address - sec->vma + entry->size;
      else
	entry_sec_offset = rel->r_rel.target_offset + 4;

      /* If the literal range is at the end of the section,
	 do not add fill.  */
      fill_extra_space = 0;
      the_add_entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
						      entry_sec_offset);
      if (the_add_entry && (the_add_entry->flags & XTENSA_PROP_UNREACHABLE))
	fill_extra_space = the_add_entry->size;

      fa = find_fill_action (&relax_info->action_list, sec, entry_sec_offset);
      removed_diff = compute_removed_action_diff (fa, sec, entry_sec_offset,
						  -4, fill_extra_space);
      if (fa)
	adjust_fill_action (fa, removed_diff);
      else
	text_action_add (&relax_info->action_list,
			 ta_fill, sec, entry_sec_offset, removed_diff);
    }

  return TRUE;
}


/* Move a literal to another location.  This may actually increase the
   total amount of space used because of alignments so we need to do
   this carefully.  Also, it may make a branch go out of range.  */

static bfd_boolean
move_shared_literal (asection *sec,
		     struct bfd_link_info *link_info,
		     source_reloc *rel,
		     property_table_entry *prop_table,
		     int ptblsize,
		     const r_reloc *target_loc,
		     const literal_value *lit_value,
		     section_cache_t *target_sec_cache)
{
  property_table_entry *the_add_entry, *src_entry, *target_entry = NULL;
  text_action *fa, *target_fa;
  int removed_diff;
  xtensa_relax_info *relax_info, *target_relax_info;
  asection *target_sec;
  ebb_t *ebb;
  ebb_constraint ebb_table;
  bfd_boolean relocs_fit;

  /* If this routine always returns FALSE, the literals that cannot be
     coalesced will not be moved.  */
  if (elf32xtensa_no_literal_movement)
    return FALSE;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    return FALSE;

  target_sec = r_reloc_get_section (target_loc);
  target_relax_info = get_xtensa_relax_info (target_sec);

  /* Literals to undefined sections may not be moved because they
     must report an error.  */
  if (bfd_is_und_section (target_sec))
    return FALSE;

  src_entry = elf_xtensa_find_property_entry
    (prop_table, ptblsize, sec->vma + rel->r_rel.target_offset);

  if (!section_cache_section (target_sec_cache, target_sec, link_info))
    return FALSE;

  target_entry = elf_xtensa_find_property_entry
    (target_sec_cache->ptbl, target_sec_cache->pte_count,
     target_sec->vma + target_loc->target_offset);

  if (!target_entry)
    return FALSE;

  /* Make sure that we have not broken any branches.  */
  relocs_fit = FALSE;

  init_ebb_constraint (&ebb_table);
  ebb = &ebb_table.ebb;
  init_ebb (ebb, target_sec_cache->sec, target_sec_cache->contents,
	    target_sec_cache->content_length,
	    target_sec_cache->ptbl, target_sec_cache->pte_count,
	    target_sec_cache->relocs, target_sec_cache->reloc_count);

  /* Propose to add 4 bytes + worst-case alignment size increase to
     destination.  */
  ebb_propose_action (&ebb_table, EBB_NO_ALIGN, 0,
		      ta_fill, target_loc->target_offset,
		      -4 - (1 << target_sec->alignment_power), TRUE);

  /* Check all of the PC-relative relocations to make sure they still fit.  */
  relocs_fit = check_section_ebb_pcrels_fit (target_sec->owner, target_sec,
					     target_sec_cache->contents,
					     target_sec_cache->relocs,
					     &ebb_table, NULL);

  if (!relocs_fit)
    return FALSE;

  text_action_add_literal (&target_relax_info->action_list,
			   ta_add_literal, target_loc, lit_value, -4);

  if (target_sec->alignment_power > 2 && target_entry != src_entry)
    {
      /* May need to add or remove some fill to maintain alignment.  */
      int fill_extra_space;
      bfd_vma entry_sec_offset;

      entry_sec_offset =
	target_entry->address - target_sec->vma + target_entry->size;

      /* If the literal range is at the end of the section,
	 do not add fill.  */
      fill_extra_space = 0;
      the_add_entry =
	elf_xtensa_find_property_entry (target_sec_cache->ptbl,
					target_sec_cache->pte_count,
					entry_sec_offset);
      if (the_add_entry && (the_add_entry->flags & XTENSA_PROP_UNREACHABLE))
	fill_extra_space = the_add_entry->size;

      target_fa = find_fill_action (&target_relax_info->action_list,
				    target_sec, entry_sec_offset);
      removed_diff = compute_removed_action_diff (target_fa, target_sec,
						  entry_sec_offset, 4,
						  fill_extra_space);
      if (target_fa)
	adjust_fill_action (target_fa, removed_diff);
      else
	text_action_add (&target_relax_info->action_list,
			 ta_fill, target_sec, entry_sec_offset, removed_diff);
    }

  /* Mark that the literal will be moved to the new location.  */
  add_removed_literal (&relax_info->removed_list, &rel->r_rel, target_loc);

  /* Remove the literal.  */
  text_action_add (&relax_info->action_list,
		   ta_remove_literal, sec, rel->r_rel.target_offset, 4);

  /* If the section is 4-byte aligned, do not add fill.  */
  if (sec->alignment_power > 2 && target_entry != src_entry)
    {
      int fill_extra_space;
      bfd_vma entry_sec_offset;

      if (src_entry)
	entry_sec_offset = src_entry->address - sec->vma + src_entry->size;
      else
	entry_sec_offset = rel->r_rel.target_offset+4;

      /* If the literal range is at the end of the section,
	 do not add fill.  */
      fill_extra_space = 0;
      the_add_entry = elf_xtensa_find_property_entry (prop_table, ptblsize,
						      entry_sec_offset);
      if (the_add_entry && (the_add_entry->flags & XTENSA_PROP_UNREACHABLE))
	fill_extra_space = the_add_entry->size;

      fa = find_fill_action (&relax_info->action_list, sec, entry_sec_offset);
      removed_diff = compute_removed_action_diff (fa, sec, entry_sec_offset,
						  -4, fill_extra_space);
      if (fa)
	adjust_fill_action (fa, removed_diff);
      else
	text_action_add (&relax_info->action_list,
			 ta_fill, sec, entry_sec_offset, removed_diff);
    }

  return TRUE;
}


/* Second relaxation pass.  */

/* Modify all of the relocations to point to the right spot, and if this
   is a relaxable section, delete the unwanted literals and fix the
   section size.  */

bfd_boolean
relax_section (bfd *abfd, asection *sec, struct bfd_link_info *link_info)
{
  Elf_Internal_Rela *internal_relocs;
  xtensa_relax_info *relax_info;
  bfd_byte *contents;
  bfd_boolean ok = TRUE;
  unsigned i;
  bfd_boolean rv = FALSE;
  bfd_boolean virtual_action;
  bfd_size_type sec_size;

  sec_size = bfd_get_section_limit (abfd, sec);
  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info);

  /* First translate any of the fixes that have been added already.  */
  translate_section_fixes (sec);

  /* Handle property sections (e.g., literal tables) specially.  */
  if (xtensa_is_property_section (sec))
    {
      BFD_ASSERT (!relax_info->is_relaxable_literal_section);
      return relax_property_section (abfd, sec, link_info);
    }

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);
  if (!internal_relocs && !relax_info->action_list.head)
    return TRUE;

  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  if (internal_relocs)
    {
      for (i = 0; i < sec->reloc_count; i++)
	{
	  Elf_Internal_Rela *irel;
	  xtensa_relax_info *target_relax_info;
	  bfd_vma source_offset, old_source_offset;
	  r_reloc r_rel;
	  unsigned r_type;
	  asection *target_sec;

	  /* Locally change the source address.
	     Translate the target to the new target address.
	     If it points to this section and has been removed,
	     NULLify it.
	     Write it back.  */

	  irel = &internal_relocs[i];
	  source_offset = irel->r_offset;
	  old_source_offset = source_offset;

	  r_type = ELF32_R_TYPE (irel->r_info);
	  r_reloc_init (&r_rel, abfd, irel, contents,
			bfd_get_section_limit (abfd, sec));

	  /* If this section could have changed then we may need to
	     change the relocation's offset.  */

	  if (relax_info->is_relaxable_literal_section
	      || relax_info->is_relaxable_asm_section)
	    {
	      pin_internal_relocs (sec, internal_relocs);

	      if (r_type != R_XTENSA_NONE
		  && find_removed_literal (&relax_info->removed_list,
					   irel->r_offset))
		{
		  /* Remove this relocation.  */
		  if (elf_hash_table (link_info)->dynamic_sections_created)
		    shrink_dynamic_reloc_sections (link_info, abfd, sec, irel);
		  irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
		  irel->r_offset = offset_with_removed_text
		    (&relax_info->action_list, irel->r_offset);
		  continue;
		}

	      if (r_type == R_XTENSA_ASM_SIMPLIFY)
		{
		  text_action *action =
		    find_insn_action (&relax_info->action_list,
				      irel->r_offset);
		  if (action && (action->action == ta_convert_longcall
				 || action->action == ta_remove_longcall))
		    {
		      bfd_reloc_status_type retval;
		      char *error_message = NULL;

		      retval = contract_asm_expansion (contents, sec_size,
						       irel, &error_message);
		      if (retval != bfd_reloc_ok)
			{
			  (*link_info->callbacks->reloc_dangerous)
			    (link_info, error_message, abfd, sec,
			     irel->r_offset);
			  goto error_return;
			}
		      /* Update the action so that the code that moves
			 the contents will do the right thing.  */
		      if (action->action == ta_remove_longcall)
			action->action = ta_remove_insn;
		      else
			action->action = ta_none;
		      /* Refresh the info in the r_rel.  */
		      r_reloc_init (&r_rel, abfd, irel, contents, sec_size);
		      r_type = ELF32_R_TYPE (irel->r_info);
		    }
		}

	      source_offset = offset_with_removed_text
		(&relax_info->action_list, irel->r_offset);
	      irel->r_offset = source_offset;
	    }

	  /* If the target section could have changed then
	     we may need to change the relocation's target offset.  */

	  target_sec = r_reloc_get_section (&r_rel);

	  /* For a reference to a discarded section from a DWARF section,
	     i.e., where action_discarded is PRETEND, the symbol will
	     eventually be modified to refer to the kept section (at least if
	     the kept and discarded sections are the same size).  Anticipate
	     that here and adjust things accordingly.  */
	  if (! elf_xtensa_ignore_discarded_relocs (sec)
	      && elf_xtensa_action_discarded (sec) == PRETEND
	      && sec->sec_info_type != SEC_INFO_TYPE_STABS
	      && target_sec != NULL
	      && discarded_section (target_sec))
	    {
	      /* It would be natural to call _bfd_elf_check_kept_section
		 here, but it's not exported from elflink.c.  It's also a
		 fairly expensive check.  Adjusting the relocations to the
		 discarded section is fairly harmless; it will only adjust
		 some addends and difference values.  If it turns out that
		 _bfd_elf_check_kept_section fails later, it won't matter,
		 so just compare the section names to find the right group
		 member.  */
	      asection *kept = target_sec->kept_section;
	      if (kept != NULL)
		{
		  if ((kept->flags & SEC_GROUP) != 0)
		    {
		      asection *first = elf_next_in_group (kept);
		      asection *s = first;

		      kept = NULL;
		      while (s != NULL)
			{
			  if (strcmp (s->name, target_sec->name) == 0)
			    {
			      kept = s;
			      break;
			    }
			  s = elf_next_in_group (s);
			  if (s == first)
			    break;
			}
		    }
		}
	      if (kept != NULL
		  && ((target_sec->rawsize != 0
		       ? target_sec->rawsize : target_sec->size)
		      == (kept->rawsize != 0 ? kept->rawsize : kept->size)))
		target_sec = kept;
	    }

	  target_relax_info = get_xtensa_relax_info (target_sec);
	  if (target_relax_info
	      && (target_relax_info->is_relaxable_literal_section
		  || target_relax_info->is_relaxable_asm_section))
	    {
	      r_reloc new_reloc;
	      target_sec = translate_reloc (&r_rel, &new_reloc, target_sec);

	      if (r_type == R_XTENSA_DIFF8
		  || r_type == R_XTENSA_DIFF16
		  || r_type == R_XTENSA_DIFF32)
		{
		  bfd_vma diff_value = 0, new_end_offset, diff_mask = 0;

		  if (bfd_get_section_limit (abfd, sec) < old_source_offset)
		    {
		      (*link_info->callbacks->reloc_dangerous)
			(link_info, _("invalid relocation address"),
			 abfd, sec, old_source_offset);
		      goto error_return;
		    }

		  switch (r_type)
		    {
		    case R_XTENSA_DIFF8:
		      diff_value =
			bfd_get_8 (abfd, &contents[old_source_offset]);
		      break;
		    case R_XTENSA_DIFF16:
		      diff_value =
			bfd_get_16 (abfd, &contents[old_source_offset]);
		      break;
		    case R_XTENSA_DIFF32:
		      diff_value =
			bfd_get_32 (abfd, &contents[old_source_offset]);
		      break;
		    }

		  new_end_offset = offset_with_removed_text
		    (&target_relax_info->action_list,
		     r_rel.target_offset + diff_value);
		  diff_value = new_end_offset - new_reloc.target_offset;

		  switch (r_type)
		    {
		    case R_XTENSA_DIFF8:
		      diff_mask = 0xff;
		      bfd_put_8 (abfd, diff_value,
				 &contents[old_source_offset]);
		      break;
		    case R_XTENSA_DIFF16:
		      diff_mask = 0xffff;
		      bfd_put_16 (abfd, diff_value,
				  &contents[old_source_offset]);
		      break;
		    case R_XTENSA_DIFF32:
		      diff_mask = 0xffffffff;
		      bfd_put_32 (abfd, diff_value,
				  &contents[old_source_offset]);
		      break;
		    }

		  /* Check for overflow.  */
		  if ((diff_value & ~diff_mask) != 0)
		    {
		      (*link_info->callbacks->reloc_dangerous)
			(link_info, _("overflow after relaxation"),
			 abfd, sec, old_source_offset);
		      goto error_return;
		    }

		  pin_contents (sec, contents);
		}

	      /* If the relocation still references a section in the same
		 input file, modify the relocation directly instead of
		 adding a "fix" record.  */
	      if (target_sec->owner == abfd)
		{
		  unsigned r_symndx = ELF32_R_SYM (new_reloc.rela.r_info);
		  irel->r_info = ELF32_R_INFO (r_symndx, r_type);
		  irel->r_addend = new_reloc.rela.r_addend;
		  pin_internal_relocs (sec, internal_relocs);
		}
	      else
		{
		  bfd_vma addend_displacement;
		  reloc_bfd_fix *fix;

		  addend_displacement =
		    new_reloc.target_offset + new_reloc.virtual_offset;
		  fix = reloc_bfd_fix_init (sec, source_offset, r_type,
					    target_sec,
					    addend_displacement, TRUE);
		  add_fix (sec, fix);
		}
	    }
	}
    }

  if ((relax_info->is_relaxable_literal_section
       || relax_info->is_relaxable_asm_section)
      && relax_info->action_list.head)
    {
      /* Walk through the planned actions and build up a table
	 of move, copy and fill records.  Use the move, copy and
	 fill records to perform the actions once.  */

      int removed = 0;
      bfd_size_type final_size, copy_size, orig_insn_size;
      bfd_byte *scratch = NULL;
      bfd_byte *dup_contents = NULL;
      bfd_size_type orig_size = sec->size;
      bfd_vma orig_dot = 0;
      bfd_vma orig_dot_copied = 0; /* Byte copied already from
					    orig dot in physical memory.  */
      bfd_vma orig_dot_vo = 0; /* Virtual offset from orig_dot.  */
      bfd_vma dup_dot = 0;

      text_action *action = relax_info->action_list.head;

      final_size = sec->size;
      for (action = relax_info->action_list.head; action;
	   action = action->next)
	{
	  final_size -= action->removed_bytes;
	}

      scratch = (bfd_byte *) bfd_zmalloc (final_size);
      dup_contents = (bfd_byte *) bfd_zmalloc (final_size);

      /* The dot is the current fill location.  */
#if DEBUG
      print_action_list (stderr, &relax_info->action_list);
#endif

      for (action = relax_info->action_list.head; action;
	   action = action->next)
	{
	  virtual_action = FALSE;
	  if (action->offset > orig_dot)
	    {
	      orig_dot += orig_dot_copied;
	      orig_dot_copied = 0;
	      orig_dot_vo = 0;
	      /* Out of the virtual world.  */
	    }

	  if (action->offset > orig_dot)
	    {
	      copy_size = action->offset - orig_dot;
	      memmove (&dup_contents[dup_dot], &contents[orig_dot], copy_size);
	      orig_dot += copy_size;
	      dup_dot += copy_size;
	      BFD_ASSERT (action->offset == orig_dot);
	    }
	  else if (action->offset < orig_dot)
	    {
	      if (action->action == ta_fill
		  && action->offset - action->removed_bytes == orig_dot)
		{
		  /* This is OK because the fill only effects the dup_dot.  */
		}
	      else if (action->action == ta_add_literal)
		{
		  /* TBD.  Might need to handle this.  */
		}
	    }
	  if (action->offset == orig_dot)
	    {
	      if (action->virtual_offset > orig_dot_vo)
		{
		  if (orig_dot_vo == 0)
		    {
		      /* Need to copy virtual_offset bytes.  Probably four.  */
		      copy_size = action->virtual_offset - orig_dot_vo;
		      memmove (&dup_contents[dup_dot],
			       &contents[orig_dot], copy_size);
		      orig_dot_copied = copy_size;
		      dup_dot += copy_size;
		    }
		  virtual_action = TRUE;
		}
	      else
		BFD_ASSERT (action->virtual_offset <= orig_dot_vo);
	    }
	  switch (action->action)
	    {
	    case ta_remove_literal:
	    case ta_remove_insn:
	      BFD_ASSERT (action->removed_bytes >= 0);
	      orig_dot += action->removed_bytes;
	      break;

	    case ta_narrow_insn:
	      orig_insn_size = 3;
	      copy_size = 2;
	      memmove (scratch, &contents[orig_dot], orig_insn_size);
	      BFD_ASSERT (action->removed_bytes == 1);
	      rv = narrow_instruction (scratch, final_size, 0);
	      BFD_ASSERT (rv);
	      memmove (&dup_contents[dup_dot], scratch, copy_size);
	      orig_dot += orig_insn_size;
	      dup_dot += copy_size;
	      break;

	    case ta_fill:
	      if (action->removed_bytes >= 0)
		orig_dot += action->removed_bytes;
	      else
		{
		  /* Already zeroed in dup_contents.  Just bump the
		     counters.  */
		  dup_dot += (-action->removed_bytes);
		}
	      break;

	    case ta_none:
	      BFD_ASSERT (action->removed_bytes == 0);
	      break;

	    case ta_convert_longcall:
	    case ta_remove_longcall:
	      /* These will be removed or converted before we get here.  */
	      BFD_ASSERT (0);
	      break;

	    case ta_widen_insn:
	      orig_insn_size = 2;
	      copy_size = 3;
	      memmove (scratch, &contents[orig_dot], orig_insn_size);
	      BFD_ASSERT (action->removed_bytes == -1);
	      rv = widen_instruction (scratch, final_size, 0);
	      BFD_ASSERT (rv);
	      memmove (&dup_contents[dup_dot], scratch, copy_size);
	      orig_dot += orig_insn_size;
	      dup_dot += copy_size;
	      break;

	    case ta_add_literal:
	      orig_insn_size = 0;
	      copy_size = 4;
	      BFD_ASSERT (action->removed_bytes == -4);
	      /* TBD -- place the literal value here and insert
		 into the table.  */
	      memset (&dup_contents[dup_dot], 0, 4);
	      pin_internal_relocs (sec, internal_relocs);
	      pin_contents (sec, contents);

	      if (!move_literal (abfd, link_info, sec, dup_dot, dup_contents,
				 relax_info, &internal_relocs, &action->value))
		goto error_return;

	      if (virtual_action)
		orig_dot_vo += copy_size;

	      orig_dot += orig_insn_size;
	      dup_dot += copy_size;
	      break;

	    default:
	      /* Not implemented yet.  */
	      BFD_ASSERT (0);
	      break;
	    }

	  removed += action->removed_bytes;
	  BFD_ASSERT (dup_dot <= final_size);
	  BFD_ASSERT (orig_dot <= orig_size);
	}

      orig_dot += orig_dot_copied;
      orig_dot_copied = 0;

      if (orig_dot != orig_size)
	{
	  copy_size = orig_size - orig_dot;
	  BFD_ASSERT (orig_size > orig_dot);
	  BFD_ASSERT (dup_dot + copy_size == final_size);
	  memmove (&dup_contents[dup_dot], &contents[orig_dot], copy_size);
	  orig_dot += copy_size;
	  dup_dot += copy_size;
	}
      BFD_ASSERT (orig_size == orig_dot);
      BFD_ASSERT (final_size == dup_dot);

      /* Move the dup_contents back.  */
      if (final_size > orig_size)
	{
	  /* Contents need to be reallocated.  Swap the dup_contents into
	     contents.  */
	  sec->contents = dup_contents;
	  free (contents);
	  contents = dup_contents;
	  pin_contents (sec, contents);
	}
      else
	{
	  BFD_ASSERT (final_size <= orig_size);
	  memset (contents, 0, orig_size);
	  memcpy (contents, dup_contents, final_size);
	  free (dup_contents);
	}
      free (scratch);
      pin_contents (sec, contents);

      if (sec->rawsize == 0)
	sec->rawsize = sec->size;
      sec->size = final_size;
    }

 error_return:
  release_internal_relocs (sec, internal_relocs);
  release_contents (sec, contents);
  return ok;
}


static bfd_boolean
translate_section_fixes (asection *sec)
{
  xtensa_relax_info *relax_info;
  reloc_bfd_fix *r;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    return TRUE;

  for (r = relax_info->fix_list; r != NULL; r = r->next)
    if (!translate_reloc_bfd_fix (r))
      return FALSE;

  return TRUE;
}


/* Translate a fix given the mapping in the relax info for the target
   section.  If it has already been translated, no work is required.  */

static bfd_boolean
translate_reloc_bfd_fix (reloc_bfd_fix *fix)
{
  reloc_bfd_fix new_fix;
  asection *sec;
  xtensa_relax_info *relax_info;
  removed_literal *removed;
  bfd_vma new_offset, target_offset;

  if (fix->translated)
    return TRUE;

  sec = fix->target_sec;
  target_offset = fix->target_offset;

  relax_info = get_xtensa_relax_info (sec);
  if (!relax_info)
    {
      fix->translated = TRUE;
      return TRUE;
    }

  new_fix = *fix;

  /* The fix does not need to be translated if the section cannot change.  */
  if (!relax_info->is_relaxable_literal_section
      && !relax_info->is_relaxable_asm_section)
    {
      fix->translated = TRUE;
      return TRUE;
    }

  /* If the literal has been moved and this relocation was on an
     opcode, then the relocation should move to the new literal
     location.  Otherwise, the relocation should move within the
     section.  */

  removed = FALSE;
  if (is_operand_relocation (fix->src_type))
    {
      /* Check if the original relocation is against a literal being
	 removed.  */
      removed = find_removed_literal (&relax_info->removed_list,
				      target_offset);
    }

  if (removed)
    {
      asection *new_sec;

      /* The fact that there is still a relocation to this literal indicates
	 that the literal is being coalesced, not simply removed.  */
      BFD_ASSERT (removed->to.abfd != NULL);

      /* This was moved to some other address (possibly another section).  */
      new_sec = r_reloc_get_section (&removed->to);
      if (new_sec != sec)
	{
	  sec = new_sec;
	  relax_info = get_xtensa_relax_info (sec);
	  if (!relax_info ||
	      (!relax_info->is_relaxable_literal_section
	       && !relax_info->is_relaxable_asm_section))
	    {
	      target_offset = removed->to.target_offset;
	      new_fix.target_sec = new_sec;
	      new_fix.target_offset = target_offset;
	      new_fix.translated = TRUE;
	      *fix = new_fix;
	      return TRUE;
	    }
	}
      target_offset = removed->to.target_offset;
      new_fix.target_sec = new_sec;
    }

  /* The target address may have been moved within its section.  */
  new_offset = offset_with_removed_text (&relax_info->action_list,
					 target_offset);

  new_fix.target_offset = new_offset;
  new_fix.target_offset = new_offset;
  new_fix.translated = TRUE;
  *fix = new_fix;
  return TRUE;
}


/* Fix up a relocation to take account of removed literals.  */

static asection *
translate_reloc (const r_reloc *orig_rel, r_reloc *new_rel, asection *sec)
{
  xtensa_relax_info *relax_info;
  removed_literal *removed;
  bfd_vma target_offset, base_offset;
  text_action *act;

  *new_rel = *orig_rel;

  if (!r_reloc_is_defined (orig_rel))
    return sec ;

  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info && (relax_info->is_relaxable_literal_section
			     || relax_info->is_relaxable_asm_section));

  target_offset = orig_rel->target_offset;

  removed = FALSE;
  if (is_operand_relocation (ELF32_R_TYPE (orig_rel->rela.r_info)))
    {
      /* Check if the original relocation is against a literal being
	 removed.  */
      removed = find_removed_literal (&relax_info->removed_list,
				      target_offset);
    }
  if (removed && removed->to.abfd)
    {
      asection *new_sec;

      /* The fact that there is still a relocation to this literal indicates
	 that the literal is being coalesced, not simply removed.  */
      BFD_ASSERT (removed->to.abfd != NULL);

      /* This was moved to some other address
	 (possibly in another section).  */
      *new_rel = removed->to;
      new_sec = r_reloc_get_section (new_rel);
      if (new_sec != sec)
	{
	  sec = new_sec;
	  relax_info = get_xtensa_relax_info (sec);
	  if (!relax_info
	      || (!relax_info->is_relaxable_literal_section
		  && !relax_info->is_relaxable_asm_section))
	    return sec;
	}
      target_offset = new_rel->target_offset;
    }

  /* Find the base offset of the reloc symbol, excluding any addend from the
     reloc or from the section contents (for a partial_inplace reloc).  Then
     find the adjusted values of the offsets due to relaxation.  The base
     offset is needed to determine the change to the reloc's addend; the reloc
     addend should not be adjusted due to relaxations located before the base
     offset.  */

  base_offset = r_reloc_get_target_offset (new_rel) - new_rel->rela.r_addend;
  act = relax_info->action_list.head;
  if (base_offset <= target_offset)
    {
      int base_removed = removed_by_actions (&act, base_offset, FALSE);
      int addend_removed = removed_by_actions (&act, target_offset, FALSE);
      new_rel->target_offset = target_offset - base_removed - addend_removed;
      new_rel->rela.r_addend -= addend_removed;
    }
  else
    {
      /* Handle a negative addend.  The base offset comes first.  */
      int tgt_removed = removed_by_actions (&act, target_offset, FALSE);
      int addend_removed = removed_by_actions (&act, base_offset, FALSE);
      new_rel->target_offset = target_offset - tgt_removed;
      new_rel->rela.r_addend += addend_removed;
    }

  return sec;
}


/* For dynamic links, there may be a dynamic relocation for each
   literal.  The number of dynamic relocations must be computed in
   size_dynamic_sections, which occurs before relaxation.  When a
   literal is removed, this function checks if there is a corresponding
   dynamic relocation and shrinks the size of the appropriate dynamic
   relocation section accordingly.  At this point, the contents of the
   dynamic relocation sections have not yet been filled in, so there's
   nothing else that needs to be done.  */

static void
shrink_dynamic_reloc_sections (struct bfd_link_info *info,
			       bfd *abfd,
			       asection *input_section,
			       Elf_Internal_Rela *rel)
{
  struct elf_xtensa_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  unsigned long r_symndx;
  int r_type;
  struct elf_link_hash_entry *h;
  bfd_boolean dynamic_symbol;

  htab = elf_xtensa_hash_table (info);
  if (htab == NULL)
    return;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  r_type = ELF32_R_TYPE (rel->r_info);
  r_symndx = ELF32_R_SYM (rel->r_info);

  if (r_symndx < symtab_hdr->sh_info)
    h = NULL;
  else
    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

  dynamic_symbol = elf_xtensa_dynamic_symbol_p (h, info);

  if ((r_type == R_XTENSA_32 || r_type == R_XTENSA_PLT)
      && (input_section->flags & SEC_ALLOC) != 0
      && (dynamic_symbol || info->shared))
    {
      asection *srel;
      bfd_boolean is_plt = FALSE;

      if (dynamic_symbol && r_type == R_XTENSA_PLT)
	{
	  srel = htab->srelplt;
	  is_plt = TRUE;
	}
      else
	srel = htab->srelgot;

      /* Reduce size of the .rela.* section by one reloc.  */
      BFD_ASSERT (srel != NULL);
      BFD_ASSERT (srel->size >= sizeof (Elf32_External_Rela));
      srel->size -= sizeof (Elf32_External_Rela);

      if (is_plt)
	{
	  asection *splt, *sgotplt, *srelgot;
	  int reloc_index, chunk;

	  /* Find the PLT reloc index of the entry being removed.  This
	     is computed from the size of ".rela.plt".  It is needed to
	     figure out which PLT chunk to resize.  Usually "last index
	     = size - 1" since the index starts at zero, but in this
	     context, the size has just been decremented so there's no
	     need to subtract one.  */
	  reloc_index = srel->size / sizeof (Elf32_External_Rela);

	  chunk = reloc_index / PLT_ENTRIES_PER_CHUNK;
	  splt = elf_xtensa_get_plt_section (info, chunk);
	  sgotplt = elf_xtensa_get_gotplt_section (info, chunk);
	  BFD_ASSERT (splt != NULL && sgotplt != NULL);

	  /* Check if an entire PLT chunk has just been eliminated.  */
	  if (reloc_index % PLT_ENTRIES_PER_CHUNK == 0)
	    {
	      /* The two magic GOT entries for that chunk can go away.  */
	      srelgot = htab->srelgot;
	      BFD_ASSERT (srelgot != NULL);
	      srelgot->reloc_count -= 2;
	      srelgot->size -= 2 * sizeof (Elf32_External_Rela);
	      sgotplt->size -= 8;

	      /* There should be only one entry left (and it will be
		 removed below).  */
	      BFD_ASSERT (sgotplt->size == 4);
	      BFD_ASSERT (splt->size == PLT_ENTRY_SIZE);
	    }

	  BFD_ASSERT (sgotplt->size >= 4);
	  BFD_ASSERT (splt->size >= PLT_ENTRY_SIZE);

	  sgotplt->size -= 4;
	  splt->size -= PLT_ENTRY_SIZE;
	}
    }
}


/* Take an r_rel and move it to another section.  This usually
   requires extending the interal_relocation array and pinning it.  If
   the original r_rel is from the same BFD, we can complete this here.
   Otherwise, we add a fix record to let the final link fix the
   appropriate address.  Contents and internal relocations for the
   section must be pinned after calling this routine.  */

static bfd_boolean
move_literal (bfd *abfd,
	      struct bfd_link_info *link_info,
	      asection *sec,
	      bfd_vma offset,
	      bfd_byte *contents,
	      xtensa_relax_info *relax_info,
	      Elf_Internal_Rela **internal_relocs_p,
	      const literal_value *lit)
{
  Elf_Internal_Rela *new_relocs = NULL;
  size_t new_relocs_count = 0;
  Elf_Internal_Rela this_rela;
  const r_reloc *r_rel;

  r_rel = &lit->r_rel;
  BFD_ASSERT (elf_section_data (sec)->relocs == *internal_relocs_p);

  if (r_reloc_is_const (r_rel))
    bfd_put_32 (abfd, lit->value, contents + offset);
  else
    {
      int r_type;
      unsigned i;
      reloc_bfd_fix *fix;
      unsigned insert_at;

      r_type = ELF32_R_TYPE (r_rel->rela.r_info);

      /* This is the difficult case.  We have to create a fix up.  */
      this_rela.r_offset = offset;
      this_rela.r_info = ELF32_R_INFO (0, r_type);
      this_rela.r_addend =
	r_rel->target_offset - r_reloc_get_target_offset (r_rel);
      bfd_put_32 (abfd, lit->value, contents + offset);

      /* Currently, we cannot move relocations during a relocatable link.  */
      BFD_ASSERT (!link_info->relocatable);
      fix = reloc_bfd_fix_init (sec, offset, r_type,
				r_reloc_get_section (r_rel),
				r_rel->target_offset + r_rel->virtual_offset,
				FALSE);
      /* We also need to mark that relocations are needed here.  */
      sec->flags |= SEC_RELOC;

      translate_reloc_bfd_fix (fix);
      /* This fix has not yet been translated.  */
      add_fix (sec, fix);

      /* Add the relocation.  If we have already allocated our own
	 space for the relocations and we have room for more, then use
	 it.  Otherwise, allocate new space and move the literals.  */
      insert_at = sec->reloc_count;
      for (i = 0; i < sec->reloc_count; ++i)
	{
	  if (this_rela.r_offset < (*internal_relocs_p)[i].r_offset)
	    {
	      insert_at = i;
	      break;
	    }
	}

      if (*internal_relocs_p != relax_info->allocated_relocs
	  || sec->reloc_count + 1 > relax_info->allocated_relocs_count)
	{
	  BFD_ASSERT (relax_info->allocated_relocs == NULL
		      || sec->reloc_count == relax_info->relocs_count);

	  if (relax_info->allocated_relocs_count == 0)
	    new_relocs_count = (sec->reloc_count + 2) * 2;
	  else
	    new_relocs_count = (relax_info->allocated_relocs_count + 2) * 2;

	  new_relocs = (Elf_Internal_Rela *)
	    bfd_zmalloc (sizeof (Elf_Internal_Rela) * (new_relocs_count));
	  if (!new_relocs)
	    return FALSE;

	  /* We could handle this more quickly by finding the split point.  */
	  if (insert_at != 0)
	    memcpy (new_relocs, *internal_relocs_p,
		    insert_at * sizeof (Elf_Internal_Rela));

	  new_relocs[insert_at] = this_rela;

	  if (insert_at != sec->reloc_count)
	    memcpy (new_relocs + insert_at + 1,
		    (*internal_relocs_p) + insert_at,
		    (sec->reloc_count - insert_at)
		    * sizeof (Elf_Internal_Rela));

	  if (*internal_relocs_p != relax_info->allocated_relocs)
	    {
	      /* The first time we re-allocate, we can only free the
		 old relocs if they were allocated with bfd_malloc.
		 This is not true when keep_memory is in effect.  */
	      if (!link_info->keep_memory)
		free (*internal_relocs_p);
	    }
	  else
	    free (*internal_relocs_p);
	  relax_info->allocated_relocs = new_relocs;
	  relax_info->allocated_relocs_count = new_relocs_count;
	  elf_section_data (sec)->relocs = new_relocs;
	  sec->reloc_count++;
	  relax_info->relocs_count = sec->reloc_count;
	  *internal_relocs_p = new_relocs;
	}
      else
	{
	  if (insert_at != sec->reloc_count)
	    {
	      unsigned idx;
	      for (idx = sec->reloc_count; idx > insert_at; idx--)
		(*internal_relocs_p)[idx] = (*internal_relocs_p)[idx-1];
	    }
	  (*internal_relocs_p)[insert_at] = this_rela;
	  sec->reloc_count++;
	  if (relax_info->allocated_relocs)
	    relax_info->relocs_count = sec->reloc_count;
	}
    }
  return TRUE;
}


/* This is similar to relax_section except that when a target is moved,
   we shift addresses up.  We also need to modify the size.  This
   algorithm does NOT allow for relocations into the middle of the
   property sections.  */

static bfd_boolean
relax_property_section (bfd *abfd,
			asection *sec,
			struct bfd_link_info *link_info)
{
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents;
  unsigned i;
  bfd_boolean ok = TRUE;
  bfd_boolean is_full_prop_section;
  size_t last_zfill_target_offset = 0;
  asection *last_zfill_target_sec = NULL;
  bfd_size_type sec_size;
  bfd_size_type entry_size;

  sec_size = bfd_get_section_limit (abfd, sec);
  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  is_full_prop_section = xtensa_is_proptable_section (sec);
  if (is_full_prop_section)
    entry_size = 12;
  else
    entry_size = 8;

  if (internal_relocs)
    {
      for (i = 0; i < sec->reloc_count; i++)
	{
	  Elf_Internal_Rela *irel;
	  xtensa_relax_info *target_relax_info;
	  unsigned r_type;
	  asection *target_sec;
	  literal_value val;
	  bfd_byte *size_p, *flags_p;

	  /* Locally change the source address.
	     Translate the target to the new target address.
	     If it points to this section and has been removed, MOVE IT.
	     Also, don't forget to modify the associated SIZE at
	     (offset + 4).  */

	  irel = &internal_relocs[i];
	  r_type = ELF32_R_TYPE (irel->r_info);
	  if (r_type == R_XTENSA_NONE)
	    continue;

	  /* Find the literal value.  */
	  r_reloc_init (&val.r_rel, abfd, irel, contents, sec_size);
	  size_p = &contents[irel->r_offset + 4];
	  flags_p = NULL;
	  if (is_full_prop_section)
	    flags_p = &contents[irel->r_offset + 8];
	  BFD_ASSERT (irel->r_offset + entry_size <= sec_size);

	  target_sec = r_reloc_get_section (&val.r_rel);
	  target_relax_info = get_xtensa_relax_info (target_sec);

	  if (target_relax_info
	      && (target_relax_info->is_relaxable_literal_section
		  || target_relax_info->is_relaxable_asm_section ))
	    {
	      /* Translate the relocation's destination.  */
	      bfd_vma old_offset = val.r_rel.target_offset;
	      bfd_vma new_offset;
	      long old_size, new_size;
	      text_action *act = target_relax_info->action_list.head;
	      new_offset = old_offset -
		removed_by_actions (&act, old_offset, FALSE);

	      /* Assert that we are not out of bounds.  */
	      old_size = bfd_get_32 (abfd, size_p);
	      new_size = old_size;

	      if (old_size == 0)
		{
		  /* Only the first zero-sized unreachable entry is
		     allowed to expand.  In this case the new offset
		     should be the offset before the fill and the new
		     size is the expansion size.  For other zero-sized
		     entries the resulting size should be zero with an
		     offset before or after the fill address depending
		     on whether the expanding unreachable entry
		     preceeds it.  */
		  if (last_zfill_target_sec == 0
		      || last_zfill_target_sec != target_sec
		      || last_zfill_target_offset != old_offset)
		    {
		      bfd_vma new_end_offset = new_offset;

		      /* Recompute the new_offset, but this time don't
			 include any fill inserted by relaxation.  */
		      act = target_relax_info->action_list.head;
		      new_offset = old_offset -
			removed_by_actions (&act, old_offset, TRUE);

		      /* If it is not unreachable and we have not yet
			 seen an unreachable at this address, place it
			 before the fill address.  */
		      if (flags_p && (bfd_get_32 (abfd, flags_p)
				      & XTENSA_PROP_UNREACHABLE) != 0)
			{
			  new_size = new_end_offset - new_offset;

			  last_zfill_target_sec = target_sec;
			  last_zfill_target_offset = old_offset;
			}
		    }
		}
	      else
		new_size -=
		    removed_by_actions (&act, old_offset + old_size, TRUE);

	      if (new_size != old_size)
		{
		  bfd_put_32 (abfd, new_size, size_p);
		  pin_contents (sec, contents);
		}

	      if (new_offset != old_offset)
		{
		  bfd_vma diff = new_offset - old_offset;
		  irel->r_addend += diff;
		  pin_internal_relocs (sec, internal_relocs);
		}
	    }
	}
    }

  /* Combine adjacent property table entries.  This is also done in
     finish_dynamic_sections() but at that point it's too late to
     reclaim the space in the output section, so we do this twice.  */

  if (internal_relocs && (!link_info->relocatable
			  || xtensa_is_littable_section (sec)))
    {
      Elf_Internal_Rela *last_irel = NULL;
      Elf_Internal_Rela *irel, *next_rel, *rel_end;
      int removed_bytes = 0;
      bfd_vma offset;
      flagword predef_flags;

      predef_flags = xtensa_get_property_predef_flags (sec);

      /* Walk over memory and relocations at the same time.
         This REQUIRES that the internal_relocs be sorted by offset.  */
      qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
	     internal_reloc_compare);

      pin_internal_relocs (sec, internal_relocs);
      pin_contents (sec, contents);

      next_rel = internal_relocs;
      rel_end = internal_relocs + sec->reloc_count;

      BFD_ASSERT (sec->size % entry_size == 0);

      for (offset = 0; offset < sec->size; offset += entry_size)
	{
	  Elf_Internal_Rela *offset_rel, *extra_rel;
	  bfd_vma bytes_to_remove, size, actual_offset;
	  bfd_boolean remove_this_rel;
	  flagword flags;

	  /* Find the first relocation for the entry at the current offset.
	     Adjust the offsets of any extra relocations for the previous
	     entry.  */
	  offset_rel = NULL;
	  if (next_rel)
	    {
	      for (irel = next_rel; irel < rel_end; irel++)
		{
		  if ((irel->r_offset == offset
		       && ELF32_R_TYPE (irel->r_info) != R_XTENSA_NONE)
		      || irel->r_offset > offset)
		    {
		      offset_rel = irel;
		      break;
		    }
		  irel->r_offset -= removed_bytes;
		}
	    }

	  /* Find the next relocation (if there are any left).  */
	  extra_rel = NULL;
	  if (offset_rel)
	    {
	      for (irel = offset_rel + 1; irel < rel_end; irel++)
		{
		  if (ELF32_R_TYPE (irel->r_info) != R_XTENSA_NONE)
		    {
		      extra_rel = irel;
		      break;
		    }
		}
	    }

	  /* Check if there are relocations on the current entry.  There
	     should usually be a relocation on the offset field.  If there
	     are relocations on the size or flags, then we can't optimize
	     this entry.  Also, find the next relocation to examine on the
	     next iteration.  */
	  if (offset_rel)
	    {
	      if (offset_rel->r_offset >= offset + entry_size)
		{
		  next_rel = offset_rel;
		  /* There are no relocations on the current entry, but we
		     might still be able to remove it if the size is zero.  */
		  offset_rel = NULL;
		}
	      else if (offset_rel->r_offset > offset
		       || (extra_rel
			   && extra_rel->r_offset < offset + entry_size))
		{
		  /* There is a relocation on the size or flags, so we can't
		     do anything with this entry.  Continue with the next.  */
		  next_rel = offset_rel;
		  continue;
		}
	      else
		{
		  BFD_ASSERT (offset_rel->r_offset == offset);
		  offset_rel->r_offset -= removed_bytes;
		  next_rel = offset_rel + 1;
		}
	    }
	  else
	    next_rel = NULL;

	  remove_this_rel = FALSE;
	  bytes_to_remove = 0;
	  actual_offset = offset - removed_bytes;
	  size = bfd_get_32 (abfd, &contents[actual_offset + 4]);

	  if (is_full_prop_section)
	    flags = bfd_get_32 (abfd, &contents[actual_offset + 8]);
	  else
	    flags = predef_flags;

	  if (size == 0
	      && (flags & XTENSA_PROP_ALIGN) == 0
	      && (flags & XTENSA_PROP_UNREACHABLE) == 0)
	    {
	      /* Always remove entries with zero size and no alignment.  */
	      bytes_to_remove = entry_size;
	      if (offset_rel)
		remove_this_rel = TRUE;
	    }
	  else if (offset_rel
		   && ELF32_R_TYPE (offset_rel->r_info) == R_XTENSA_32)
	    {
	      if (last_irel)
		{
		  flagword old_flags;
		  bfd_vma old_size =
		    bfd_get_32 (abfd, &contents[last_irel->r_offset + 4]);
		  bfd_vma old_address =
		    (last_irel->r_addend
		     + bfd_get_32 (abfd, &contents[last_irel->r_offset]));
		  bfd_vma new_address =
		    (offset_rel->r_addend
		     + bfd_get_32 (abfd, &contents[actual_offset]));
		  if (is_full_prop_section)
		    old_flags = bfd_get_32
		      (abfd, &contents[last_irel->r_offset + 8]);
		  else
		    old_flags = predef_flags;

		  if ((ELF32_R_SYM (offset_rel->r_info)
		       == ELF32_R_SYM (last_irel->r_info))
		      && old_address + old_size == new_address
		      && old_flags == flags
		      && (old_flags & XTENSA_PROP_INSN_BRANCH_TARGET) == 0
		      && (old_flags & XTENSA_PROP_INSN_LOOP_TARGET) == 0)
		    {
		      /* Fix the old size.  */
		      bfd_put_32 (abfd, old_size + size,
				  &contents[last_irel->r_offset + 4]);
		      bytes_to_remove = entry_size;
		      remove_this_rel = TRUE;
		    }
		  else
		    last_irel = offset_rel;
		}
	      else
		last_irel = offset_rel;
	    }

	  if (remove_this_rel)
	    {
	      offset_rel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	      offset_rel->r_offset = 0;
	    }

	  if (bytes_to_remove != 0)
	    {
	      removed_bytes += bytes_to_remove;
	      if (offset + bytes_to_remove < sec->size)
		memmove (&contents[actual_offset],
			 &contents[actual_offset + bytes_to_remove],
			 sec->size - offset - bytes_to_remove);
	    }
	}

      if (removed_bytes)
	{
	  /* Fix up any extra relocations on the last entry.  */
	  for (irel = next_rel; irel < rel_end; irel++)
	    irel->r_offset -= removed_bytes;

	  /* Clear the removed bytes.  */
	  memset (&contents[sec->size - removed_bytes], 0, removed_bytes);

	  if (sec->rawsize == 0)
	    sec->rawsize = sec->size;
	  sec->size -= removed_bytes;

	  if (xtensa_is_littable_section (sec))
	    {
	      asection *sgotloc = elf_xtensa_hash_table (link_info)->sgotloc;
	      if (sgotloc)
		sgotloc->size -= removed_bytes;
	    }
	}
    }

 error_return:
  release_internal_relocs (sec, internal_relocs);
  release_contents (sec, contents);
  return ok;
}


/* Third relaxation pass.  */

/* Change symbol values to account for removed literals.  */

bfd_boolean
relax_section_symbols (bfd *abfd, asection *sec)
{
  xtensa_relax_info *relax_info;
  unsigned int sec_shndx;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf;
  unsigned i, num_syms, num_locals;

  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info);

  if (!relax_info->is_relaxable_literal_section
      && !relax_info->is_relaxable_asm_section)
    return TRUE;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isymbuf = retrieve_local_syms (abfd);

  num_syms = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
  num_locals = symtab_hdr->sh_info;

  /* Adjust the local symbols defined in this section.  */
  for (i = 0; i < num_locals; i++)
    {
      Elf_Internal_Sym *isym = &isymbuf[i];

      if (isym->st_shndx == sec_shndx)
	{
	  text_action *act = relax_info->action_list.head;
	  bfd_vma orig_addr = isym->st_value;

	  isym->st_value -= removed_by_actions (&act, orig_addr, FALSE);

	  if (ELF32_ST_TYPE (isym->st_info) == STT_FUNC)
	    isym->st_size -=
	      removed_by_actions (&act, orig_addr + isym->st_size, FALSE);
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  for (i = 0; i < (num_syms - num_locals); i++)
    {
      struct elf_link_hash_entry *sym_hash;

      sym_hash = elf_sym_hashes (abfd)[i];

      if (sym_hash->root.type == bfd_link_hash_warning)
	sym_hash = (struct elf_link_hash_entry *) sym_hash->root.u.i.link;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
	{
	  text_action *act = relax_info->action_list.head;
	  bfd_vma orig_addr = sym_hash->root.u.def.value;

	  sym_hash->root.u.def.value -=
	    removed_by_actions (&act, orig_addr, FALSE);

	  if (sym_hash->type == STT_FUNC)
	    sym_hash->size -=
	      removed_by_actions (&act, orig_addr + sym_hash->size, FALSE);
	}
    }

  return TRUE;
}


/* "Fix" handling functions, called while performing relocations.  */

static bfd_boolean
do_fix_for_relocatable_link (Elf_Internal_Rela *rel,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents)
{
  r_reloc r_rel;
  asection *sec, *old_sec;
  bfd_vma old_offset;
  int r_type = ELF32_R_TYPE (rel->r_info);
  reloc_bfd_fix *fix;

  if (r_type == R_XTENSA_NONE)
    return TRUE;

  fix = get_bfd_fix (input_section, rel->r_offset, r_type);
  if (!fix)
    return TRUE;

  r_reloc_init (&r_rel, input_bfd, rel, contents,
		bfd_get_section_limit (input_bfd, input_section));
  old_sec = r_reloc_get_section (&r_rel);
  old_offset = r_rel.target_offset;

  if (!old_sec || !r_reloc_is_defined (&r_rel))
    {
      if (r_type != R_XTENSA_ASM_EXPAND)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unexpected fix for %s relocation"),
	     input_bfd, input_section, rel->r_offset,
	     elf_howto_table[r_type].name);
	  return FALSE;
	}
      /* Leave it be.  Resolution will happen in a later stage.  */
    }
  else
    {
      sec = fix->target_sec;
      rel->r_addend += ((sec->output_offset + fix->target_offset)
			- (old_sec->output_offset + old_offset));
    }
  return TRUE;
}


static void
do_fix_for_final_link (Elf_Internal_Rela *rel,
		       bfd *input_bfd,
		       asection *input_section,
		       bfd_byte *contents,
		       bfd_vma *relocationp)
{
  asection *sec;
  int r_type = ELF32_R_TYPE (rel->r_info);
  reloc_bfd_fix *fix;
  bfd_vma fixup_diff;

  if (r_type == R_XTENSA_NONE)
    return;

  fix = get_bfd_fix (input_section, rel->r_offset, r_type);
  if (!fix)
    return;

  sec = fix->target_sec;

  fixup_diff = rel->r_addend;
  if (elf_howto_table[fix->src_type].partial_inplace)
    {
      bfd_vma inplace_val;
      BFD_ASSERT (fix->src_offset
		  < bfd_get_section_limit (input_bfd, input_section));
      inplace_val = bfd_get_32 (input_bfd, &contents[fix->src_offset]);
      fixup_diff += inplace_val;
    }

  *relocationp = (sec->output_section->vma
		  + sec->output_offset
		  + fix->target_offset - fixup_diff);
}


/* Miscellaneous utility functions....  */

static asection *
elf_xtensa_get_plt_section (struct bfd_link_info *info, int chunk)
{
  struct elf_xtensa_link_hash_table *htab;
  bfd *dynobj;
  char plt_name[10];

  if (chunk == 0)
    {
      htab = elf_xtensa_hash_table (info);
      if (htab == NULL)
	return NULL;

      return htab->splt;
    }

  dynobj = elf_hash_table (info)->dynobj;
  sprintf (plt_name, ".plt.%u", chunk);
  return bfd_get_linker_section (dynobj, plt_name);
}


static asection *
elf_xtensa_get_gotplt_section (struct bfd_link_info *info, int chunk)
{
  struct elf_xtensa_link_hash_table *htab;
  bfd *dynobj;
  char got_name[14];

  if (chunk == 0)
    {
      htab = elf_xtensa_hash_table (info);
      if (htab == NULL)
	return NULL;
      return htab->sgotplt;
    }

  dynobj = elf_hash_table (info)->dynobj;
  sprintf (got_name, ".got.plt.%u", chunk);
  return bfd_get_linker_section (dynobj, got_name);
}


/* Get the input section for a given symbol index.
   If the symbol is:
   . a section symbol, return the section;
   . a common symbol, return the common section;
   . an undefined symbol, return the undefined section;
   . an indirect symbol, follow the links;
   . an absolute value, return the absolute section.  */

static asection *
get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  asection *target_sec = NULL;
  if (r_symndx < symtab_hdr->sh_info)
    {
      Elf_Internal_Sym *isymbuf;
      unsigned int section_index;

      isymbuf = retrieve_local_syms (abfd);
      section_index = isymbuf[r_symndx].st_shndx;

      if (section_index == SHN_UNDEF)
	target_sec = bfd_und_section_ptr;
      else if (section_index == SHN_ABS)
	target_sec = bfd_abs_section_ptr;
      else if (section_index == SHN_COMMON)
	target_sec = bfd_com_section_ptr;
      else
	target_sec = bfd_section_from_elf_index (abfd, section_index);
    }
  else
    {
      unsigned long indx = r_symndx - symtab_hdr->sh_info;
      struct elf_link_hash_entry *h = elf_sym_hashes (abfd)[indx];

      while (h->root.type == bfd_link_hash_indirect
             || h->root.type == bfd_link_hash_warning)
        h = (struct elf_link_hash_entry *) h->root.u.i.link;

      switch (h->root.type)
	{
	case bfd_link_hash_defined:
	case  bfd_link_hash_defweak:
	  target_sec = h->root.u.def.section;
	  break;
	case bfd_link_hash_common:
	  target_sec = bfd_com_section_ptr;
	  break;
	case bfd_link_hash_undefined:
	case bfd_link_hash_undefweak:
	  target_sec = bfd_und_section_ptr;
	  break;
	default: /* New indirect warning.  */
	  target_sec = bfd_und_section_ptr;
	  break;
	}
    }
  return target_sec;
}


static struct elf_link_hash_entry *
get_elf_r_symndx_hash_entry (bfd *abfd, unsigned long r_symndx)
{
  unsigned long indx;
  struct elf_link_hash_entry *h;
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  if (r_symndx < symtab_hdr->sh_info)
    return NULL;

  indx = r_symndx - symtab_hdr->sh_info;
  h = elf_sym_hashes (abfd)[indx];
  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
  return h;
}


/* Get the section-relative offset for a symbol number.  */

static bfd_vma
get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  bfd_vma offset = 0;

  if (r_symndx < symtab_hdr->sh_info)
    {
      Elf_Internal_Sym *isymbuf;
      isymbuf = retrieve_local_syms (abfd);
      offset = isymbuf[r_symndx].st_value;
    }
  else
    {
      unsigned long indx = r_symndx - symtab_hdr->sh_info;
      struct elf_link_hash_entry *h =
	elf_sym_hashes (abfd)[indx];

      while (h->root.type == bfd_link_hash_indirect
             || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_defined
          || h->root.type == bfd_link_hash_defweak)
	offset = h->root.u.def.value;
    }
  return offset;
}


static bfd_boolean
is_reloc_sym_weak (bfd *abfd, Elf_Internal_Rela *rel)
{
  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
  struct elf_link_hash_entry *h;

  h = get_elf_r_symndx_hash_entry (abfd, r_symndx);
  if (h && h->root.type == bfd_link_hash_defweak)
    return TRUE;
  return FALSE;
}


static bfd_boolean
pcrel_reloc_fits (xtensa_opcode opc,
		  int opnd,
		  bfd_vma self_address,
		  bfd_vma dest_address)
{
  xtensa_isa isa = xtensa_default_isa;
  uint32 valp = dest_address;
  if (xtensa_operand_do_reloc (isa, opc, opnd, &valp, self_address)
      || xtensa_operand_encode (isa, opc, opnd, &valp))
    return FALSE;
  return TRUE;
}


static bfd_boolean
xtensa_is_property_section (asection *sec)
{
  if (xtensa_is_insntable_section (sec)
      || xtensa_is_littable_section (sec)
      || xtensa_is_proptable_section (sec))
    return TRUE;

  return FALSE;
}


static bfd_boolean
xtensa_is_insntable_section (asection *sec)
{
  if (CONST_STRNEQ (sec->name, XTENSA_INSN_SEC_NAME)
      || CONST_STRNEQ (sec->name, ".gnu.linkonce.x."))
    return TRUE;

  return FALSE;
}


static bfd_boolean
xtensa_is_littable_section (asection *sec)
{
  if (CONST_STRNEQ (sec->name, XTENSA_LIT_SEC_NAME)
      || CONST_STRNEQ (sec->name, ".gnu.linkonce.p."))
    return TRUE;

  return FALSE;
}


static bfd_boolean
xtensa_is_proptable_section (asection *sec)
{
  if (CONST_STRNEQ (sec->name, XTENSA_PROP_SEC_NAME)
      || CONST_STRNEQ (sec->name, ".gnu.linkonce.prop."))
    return TRUE;

  return FALSE;
}


static int
internal_reloc_compare (const void *ap, const void *bp)
{
  const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
  const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;

  if (a->r_offset != b->r_offset)
    return (a->r_offset - b->r_offset);

  /* We don't need to sort on these criteria for correctness,
     but enforcing a more strict ordering prevents unstable qsort
     from behaving differently with different implementations.
     Without the code below we get correct but different results
     on Solaris 2.7 and 2.8.  We would like to always produce the
     same results no matter the host.  */

  if (a->r_info != b->r_info)
    return (a->r_info - b->r_info);

  return (a->r_addend - b->r_addend);
}


static int
internal_reloc_matches (const void *ap, const void *bp)
{
  const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
  const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;

  /* Check if one entry overlaps with the other; this shouldn't happen
     except when searching for a match.  */
  return (a->r_offset - b->r_offset);
}


/* Predicate function used to look up a section in a particular group.  */

static bfd_boolean
match_section_group (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  const char *gname = inf;
  const char *group_name = elf_group_name (sec);

  return (group_name == gname
	  || (group_name != NULL
	      && gname != NULL
	      && strcmp (group_name, gname) == 0));
}


static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

static char *
xtensa_property_section_name (asection *sec, const char *base_name)
{
  const char *suffix, *group_name;
  char *prop_sec_name;

  group_name = elf_group_name (sec);
  if (group_name)
    {
      suffix = strrchr (sec->name, '.');
      if (suffix == sec->name)
	suffix = 0;
      prop_sec_name = (char *) bfd_malloc (strlen (base_name) + 1
					   + (suffix ? strlen (suffix) : 0));
      strcpy (prop_sec_name, base_name);
      if (suffix)
	strcat (prop_sec_name, suffix);
    }
  else if (strncmp (sec->name, ".gnu.linkonce.", linkonce_len) == 0)
    {
      char *linkonce_kind = 0;

      if (strcmp (base_name, XTENSA_INSN_SEC_NAME) == 0)
	linkonce_kind = "x.";
      else if (strcmp (base_name, XTENSA_LIT_SEC_NAME) == 0)
	linkonce_kind = "p.";
      else if (strcmp (base_name, XTENSA_PROP_SEC_NAME) == 0)
	linkonce_kind = "prop.";
      else
	abort ();

      prop_sec_name = (char *) bfd_malloc (strlen (sec->name)
					   + strlen (linkonce_kind) + 1);
      memcpy (prop_sec_name, ".gnu.linkonce.", linkonce_len);
      strcpy (prop_sec_name + linkonce_len, linkonce_kind);

      suffix = sec->name + linkonce_len;
      /* For backward compatibility, replace "t." instead of inserting
         the new linkonce_kind (but not for "prop" sections).  */
      if (CONST_STRNEQ (suffix, "t.") && linkonce_kind[1] == '.')
        suffix += 2;
      strcat (prop_sec_name + linkonce_len, suffix);
    }
  else
    prop_sec_name = strdup (base_name);

  return prop_sec_name;
}


static asection *
xtensa_get_property_section (asection *sec, const char *base_name)
{
  char *prop_sec_name;
  asection *prop_sec;

  prop_sec_name = xtensa_property_section_name (sec, base_name);
  prop_sec = bfd_get_section_by_name_if (sec->owner, prop_sec_name,
					 match_section_group,
					 (void *) elf_group_name (sec));
  free (prop_sec_name);
  return prop_sec;
}


asection *
xtensa_make_property_section (asection *sec, const char *base_name)
{
  char *prop_sec_name;
  asection *prop_sec;

  /* Check if the section already exists.  */
  prop_sec_name = xtensa_property_section_name (sec, base_name);
  prop_sec = bfd_get_section_by_name_if (sec->owner, prop_sec_name,
					 match_section_group,
					 (void *) elf_group_name (sec));
  /* If not, create it.  */
  if (! prop_sec)
    {
      flagword flags = (SEC_RELOC | SEC_HAS_CONTENTS | SEC_READONLY);
      flags |= (bfd_get_section_flags (sec->owner, sec)
		& (SEC_LINK_ONCE | SEC_LINK_DUPLICATES));

      prop_sec = bfd_make_section_anyway_with_flags
	(sec->owner, strdup (prop_sec_name), flags);
      if (! prop_sec)
	return 0;

      elf_group_name (prop_sec) = elf_group_name (sec);
    }

  free (prop_sec_name);
  return prop_sec;
}


flagword
xtensa_get_property_predef_flags (asection *sec)
{
  if (xtensa_is_insntable_section (sec))
    return (XTENSA_PROP_INSN
	    | XTENSA_PROP_NO_TRANSFORM
	    | XTENSA_PROP_INSN_NO_REORDER);

  if (xtensa_is_littable_section (sec))
    return (XTENSA_PROP_LITERAL
	    | XTENSA_PROP_NO_TRANSFORM
	    | XTENSA_PROP_INSN_NO_REORDER);

  return 0;
}


/* Other functions called directly by the linker.  */

bfd_boolean
xtensa_callback_required_dependence (bfd *abfd,
				     asection *sec,
				     struct bfd_link_info *link_info,
				     deps_callback_t callback,
				     void *closure)
{
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents;
  unsigned i;
  bfd_boolean ok = TRUE;
  bfd_size_type sec_size;

  sec_size = bfd_get_section_limit (abfd, sec);

  /* ".plt*" sections have no explicit relocations but they contain L32R
     instructions that reference the corresponding ".got.plt*" sections.  */
  if ((sec->flags & SEC_LINKER_CREATED) != 0
      && CONST_STRNEQ (sec->name, ".plt"))
    {
      asection *sgotplt;

      /* Find the corresponding ".got.plt*" section.  */
      if (sec->name[4] == '\0')
	sgotplt = bfd_get_linker_section (sec->owner, ".got.plt");
      else
	{
	  char got_name[14];
	  int chunk = 0;

	  BFD_ASSERT (sec->name[4] == '.');
	  chunk = strtol (&sec->name[5], NULL, 10);

	  sprintf (got_name, ".got.plt.%u", chunk);
	  sgotplt = bfd_get_linker_section (sec->owner, got_name);
	}
      BFD_ASSERT (sgotplt);

      /* Assume worst-case offsets: L32R at the very end of the ".plt"
	 section referencing a literal at the very beginning of
	 ".got.plt".  This is very close to the real dependence, anyway.  */
      (*callback) (sec, sec_size, sgotplt, 0, closure);
    }

  /* Only ELF files are supported for Xtensa.  Check here to avoid a segfault
     when building uclibc, which runs "ld -b binary /dev/null".  */
  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    return ok;

  internal_relocs = retrieve_internal_relocs (abfd, sec,
					      link_info->keep_memory);
  if (internal_relocs == NULL
      || sec->reloc_count == 0)
    return ok;

  /* Cache the contents for the duration of this scan.  */
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec_size != 0)
    {
      ok = FALSE;
      goto error_return;
    }

  if (!xtensa_default_isa)
    xtensa_default_isa = xtensa_isa_init (0, 0);

  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      if (is_l32r_relocation (abfd, sec, contents, irel))
	{
	  r_reloc l32r_rel;
	  asection *target_sec;
	  bfd_vma target_offset;

	  r_reloc_init (&l32r_rel, abfd, irel, contents, sec_size);
	  target_sec = NULL;
	  target_offset = 0;
	  /* L32Rs must be local to the input file.  */
	  if (r_reloc_is_defined (&l32r_rel))
	    {
	      target_sec = r_reloc_get_section (&l32r_rel);
	      target_offset = l32r_rel.target_offset;
	    }
	  (*callback) (sec, irel->r_offset, target_sec, target_offset,
		       closure);
	}
    }

 error_return:
  release_internal_relocs (sec, internal_relocs);
  release_contents (sec, contents);
  return ok;
}

/* The default literal sections should always be marked as "code" (i.e.,
   SHF_EXECINSTR).  This is particularly important for the Linux kernel
   module loader so that the literals are not placed after the text.  */
static const struct bfd_elf_special_section elf_xtensa_special_sections[] =
{
  { STRING_COMMA_LEN (".fini.literal"), 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".init.literal"), 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".literal"),      0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".xtensa.info"),  0, SHT_NOTE,     0 },
  { NULL,                       0,      0, 0,            0 }
};

#define ELF_TARGET_ID			XTENSA_ELF_DATA
#ifndef ELF_ARCH
#define TARGET_LITTLE_SYM		bfd_elf32_xtensa_le_vec
#define TARGET_LITTLE_NAME		"elf32-xtensa-le"
#define TARGET_BIG_SYM			bfd_elf32_xtensa_be_vec
#define TARGET_BIG_NAME			"elf32-xtensa-be"
#define ELF_ARCH			bfd_arch_xtensa

#define ELF_MACHINE_CODE		EM_XTENSA
#define ELF_MACHINE_ALT1		EM_XTENSA_OLD

#if XCHAL_HAVE_MMU
#define ELF_MAXPAGESIZE			(1 << XCHAL_MMU_MIN_PTE_PAGE_SIZE)
#else /* !XCHAL_HAVE_MMU */
#define ELF_MAXPAGESIZE			1
#endif /* !XCHAL_HAVE_MMU */
#endif /* ELF_ARCH */

#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
#define elf_backend_plt_readonly	1
#define elf_backend_got_header_size	4
#define elf_backend_want_dynbss		0
#define elf_backend_want_got_plt	1

#define elf_info_to_howto		     elf_xtensa_info_to_howto_rela

#define bfd_elf32_mkobject		     elf_xtensa_mkobject

#define bfd_elf32_bfd_merge_private_bfd_data elf_xtensa_merge_private_bfd_data
#define bfd_elf32_new_section_hook	     elf_xtensa_new_section_hook
#define bfd_elf32_bfd_print_private_bfd_data elf_xtensa_print_private_bfd_data
#define bfd_elf32_bfd_relax_section	     elf_xtensa_relax_section
#define bfd_elf32_bfd_reloc_type_lookup	     elf_xtensa_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
  elf_xtensa_reloc_name_lookup
#define bfd_elf32_bfd_set_private_flags	     elf_xtensa_set_private_flags
#define bfd_elf32_bfd_link_hash_table_create elf_xtensa_link_hash_table_create

#define elf_backend_adjust_dynamic_symbol    elf_xtensa_adjust_dynamic_symbol
#define elf_backend_check_relocs	     elf_xtensa_check_relocs
#define elf_backend_create_dynamic_sections  elf_xtensa_create_dynamic_sections
#define elf_backend_discard_info	     elf_xtensa_discard_info
#define elf_backend_ignore_discarded_relocs  elf_xtensa_ignore_discarded_relocs
#define elf_backend_final_write_processing   elf_xtensa_final_write_processing
#define elf_backend_finish_dynamic_sections  elf_xtensa_finish_dynamic_sections
#define elf_backend_finish_dynamic_symbol    elf_xtensa_finish_dynamic_symbol
#define elf_backend_gc_mark_hook	     elf_xtensa_gc_mark_hook
#define elf_backend_gc_sweep_hook	     elf_xtensa_gc_sweep_hook
#define elf_backend_grok_prstatus	     elf_xtensa_grok_prstatus
#define elf_backend_grok_psinfo		     elf_xtensa_grok_psinfo
#define elf_backend_hide_symbol		     elf_xtensa_hide_symbol
#define elf_backend_object_p		     elf_xtensa_object_p
#define elf_backend_reloc_type_class	     elf_xtensa_reloc_type_class
#define elf_backend_relocate_section	     elf_xtensa_relocate_section
#define elf_backend_size_dynamic_sections    elf_xtensa_size_dynamic_sections
#define elf_backend_always_size_sections     elf_xtensa_always_size_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_special_sections	     elf_xtensa_special_sections
#define elf_backend_action_discarded	     elf_xtensa_action_discarded
#define elf_backend_copy_indirect_symbol     elf_xtensa_copy_indirect_symbol

#include "elf32-target.h"
@


1.140
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d1010 4
@


1.139
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d3588 3
a3590 1
elf_xtensa_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.138
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3785 1
a3785 1
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d3788 1
a3788 1
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d3809 1
a3809 1
	elf_tdata (abfd)->core_program
d3811 1
a3811 1
	elf_tdata (abfd)->core_command
d3820 1
a3820 1
    char *command = elf_tdata (abfd)->core_command;
@


1.137
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d658 1
a658 1
  ret = bfd_malloc (amt);
a670 10
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sgotloc = NULL;
  ret->spltlittbl = NULL;

  ret->plt_reloc_count = 0;

@


1.136
log
@	* elf32-xtensa.c (free_section_cache): Renamed from
	clear_section_cache.  Don't zero cache.
	(section_cache_section): Remove ineffectual zero of cache.
	Call init_section_cache instead.
@
text
@d755 1
a755 1
      
d817 1
a817 1
  if (table_size == 0) 
d852 1
a852 1
  for (off = 0; off < table_size; off += table_entry_size) 
d1972 1
a1972 1
		  != (relocation >> CALL_SEGMENT_BITS)) 
d2145 1
a2145 1
	  != (relocation >> CALL_SEGMENT_BITS)) 
d2173 2
a2174 2
  
  is_append = (origmsg == message);  
d3505 1
a3505 1
  if ((out_flag & EF_XTENSA_XT_INSN) != (in_flag & EF_XTENSA_XT_INSN)) 
d3508 1
a3508 1
  if ((out_flag & EF_XTENSA_XT_LIT) != (in_flag & EF_XTENSA_XT_LIT)) 
d4099 1
a4099 1
  
d4138 1
a4138 1
      
d4239 1
a4239 1
  
d4631 1
a4631 1
		       
d4726 1
a4726 1
  
d4731 1
a4731 1
  for (opn = 0; opn < 3; opn++) 
d4799 1
a4799 1
static xtensa_opcode 
d4875 1
a4875 1
  if (opcode == XTENSA_UNDEFINED 
d4906 1
a4906 1
   
d5033 1
a5033 1
    
d5153 1
a5153 1
  r_reloc r_rel; 
d5194 1
a5194 1
  if (r_reloc_is_const (&src1->r_rel) != r_reloc_is_const (&src2->r_rel)) 
d5206 1
a5206 1
   
d5212 1
a5212 1
  
d5254 1
a5254 1
  if (values->buckets == NULL) 
d5293 1
a5293 1
  
d5359 1
a5359 1
  
d5499 1
a5499 1
static void 
d5520 2
a5521 2
      
      if (action == ta_fill) 
d5618 1
a5618 1
static bfd_vma 
d5756 1
a5756 1
  
d5758 1
a5758 1
  if (r == NULL) 
d5771 1
a5771 1
      while (r->from.target_offset < from->target_offset && r->next) 
d5849 1
a5849 1
  Elf_Internal_Rela *allocated_relocs; 
d5915 1
a5915 1
  relax_info->allocated_relocs = NULL; 
d5935 1
a5935 1
  
d5939 1
a5939 1
  
d6550 1
a6550 1
  
d6559 1
a6559 1
      if (keep_memory) 
d6634 1
a6634 1
static bfd_boolean is_removable_literal 
d6639 1
a6639 1
   Elf_Internal_Rela *, source_reloc *, property_table_entry *, int); 
d6669 1
a6669 1
static bfd_boolean 
d6832 1
a6832 1
  if (internal_relocs == NULL) 
d6843 1
a6843 1
  for (i = 0; i < sec->reloc_count; i++) 
d6923 1
a6923 1
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
d6925 1
a6925 1
  if (internal_relocs == NULL) 
d6937 1
a6937 1
  for (i = 0; i < sec->reloc_count; i++) 
d6995 1
a6995 1
  for (i = 0; i < sec->reloc_count; i++) 
d7034 1
a7034 1
	      s_reloc = find_source_reloc (target_relax_info->src_relocs, 
d7093 1
a7093 1
  if (ELF32_R_TYPE (irel->r_info) != R_XTENSA_ASM_EXPAND) 
d7102 1
a7102 1
  
d7121 1
a7121 1
      
d7134 1
a7134 1
      
d7155 1
a7155 1
  for (i = 0; i < sec->reloc_count; i++) 
d7372 1
a7372 1
} 
d7422 1
a7422 1
	  if (insn_len == 0) 
d7451 1
a7451 1
	      simplify_size = get_asm_simplify_size (ebb->contents, 
d7459 1
a7459 1
	      
d7806 1
a7806 1
static int 
d7836 1
a7836 1
  
d7861 1
a7861 1
  map->entry = (xlate_map_entry_t *) 
d7869 1
a7869 1
  
d7924 1
a7924 1
static void 
d8156 1
a8156 1
static bfd_boolean 
d8183 1
a8183 1
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
d8235 1
a8235 1
      if (last_loc_is_prev && 
d8242 1
a8242 1
      if (is_removable_literal (rel, i, src_relocs, relax_info->src_count, 
d8256 2
a8257 2
				       values, 
				       &last_loc_is_prev, irel, 
d8294 1
a8294 1
  if (!internal_relocs) 
d8338 2
a8339 2
  
  entry = elf_xtensa_find_property_entry (prop_table, ptblsize, 
d8360 1
a8360 1
bfd_boolean 
d8387 1
a8387 1
  if (sec->alignment_power > 2) 
d8431 1
a8431 1
bfd_boolean 
d8501 1
a8501 1
  if (!link_info->relocatable && !literal_placed 
d8514 1
a8514 1
				      prop_table, ptblsize, 
d8614 1
a8614 1
static bfd_boolean 
d8643 1
a8643 1
  if (sec->alignment_power > 2) 
d8679 1
a8679 1
static bfd_boolean 
d8722 1
a8722 1
    (target_sec_cache->ptbl, target_sec_cache->pte_count, 
d8733 1
a8733 1
  init_ebb (ebb, target_sec_cache->sec, target_sec_cache->contents, 
d8745 1
a8745 1
  relocs_fit = check_section_ebb_pcrels_fit (target_sec->owner, target_sec, 
d8750 1
a8750 1
  if (!relocs_fit) 
d8756 1
a8756 1
  if (target_sec->alignment_power > 2 && target_entry != src_entry) 
d8762 1
a8762 1
      entry_sec_offset = 
d8795 1
a8795 1
  if (sec->alignment_power > 2 && target_entry != src_entry) 
d8859 1
a8859 1
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
d9189 1
a9189 1
		} 
d9260 1
a9260 1
	      if (virtual_action) 
d9325 1
a9325 1
static bfd_boolean 
d9346 1
a9346 1
static bfd_boolean 
d9392 1
a9392 1
  if (removed) 
d9402 1
a9402 1
      if (new_sec != sec) 
d9406 1
a9406 1
	  if (!relax_info || 
d9695 1
a9695 1
	  if (relax_info->allocated_relocs_count == 0) 
d9715 1
a9715 1
		    (sec->reloc_count - insert_at) 
d9774 1
a9774 1
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
d9999 1
a9999 1
	  if (is_full_prop_section) 
d10027 1
a10027 1
		  if (is_full_prop_section) 
d10443 1
a10443 1
static bfd_boolean 
d10455 1
a10455 1
static bfd_boolean 
d10466 1
a10466 1
static bfd_boolean 
d10477 1
a10477 1
static bfd_boolean 
d10530 1
a10530 1
  
d10562 1
a10562 1
      if (strcmp (base_name, XTENSA_INSN_SEC_NAME) == 0) 
d10564 1
a10564 1
      else if (strcmp (base_name, XTENSA_LIT_SEC_NAME) == 0) 
d10704 1
a10704 1
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
@


1.135
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d6070 1
a6070 1
clear_section_cache (section_cache_t *sec_cache)
a6077 1
      memset (sec_cache, 0, sizeof (sec_cache));
d6118 2
a6119 2
  clear_section_cache (sec_cache);
  memset (sec_cache, 0, sizeof (sec_cache));
d8274 3
a8276 2
  if (prop_table) free (prop_table);
  clear_section_cache (&target_sec_cache);
@


1.134
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d3138 1
a3138 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.133
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1417 5
a1421 5
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d1438 2
a1439 1
  htab->sgotloc = bfd_make_section_with_flags (dynobj, ".got.loc", flags);
d1445 2
a1446 2
  htab->spltlittbl = bfd_make_section_with_flags (dynobj, ".xt.lit.plt",
						  noalloc_flags);
d1478 1
a1478 1
      s = bfd_make_section_with_flags (dynobj, sname, flags | SEC_CODE);
d1485 1
a1485 1
      s = bfd_make_section_with_flags (dynobj, sname, flags);
d1640 1
a1640 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d3279 1
a3279 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d10279 1
a10279 1
  return bfd_get_section_by_name (dynobj, plt_name);
d10300 1
a10300 1
  return bfd_get_section_by_name (dynobj, got_name);
d10679 1
a10679 1
	sgotplt = bfd_get_section_by_name (sec->owner, ".got.plt");
d10689 1
a10689 1
	  sgotplt = bfd_get_section_by_name (sec->owner, got_name);
@


1.132
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2661 1
a2661 1
					 rel, relend, howto, contents);
@


1.131
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1715 1
a1715 1
	      if (! elf_discarded_section (s)
d2659 1
a2659 1
      if (sec != NULL && elf_discarded_section (sec))
d8965 1
a8965 1
	      && sec->sec_info_type != ELF_INFO_TYPE_STABS
d8967 1
a8967 1
	      && elf_discarded_section (target_sec))
@


1.130
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d3061 3
a3063 1
	       && h->def_dynamic))
@


1.130.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1715 1
a1715 1
	      if (! discarded_section (s)
d2659 1
a2659 1
      if (sec != NULL && discarded_section (sec))
d8963 1
a8963 1
	      && sec->sec_info_type != SEC_INFO_TYPE_STABS
d8965 1
a8965 1
	      && discarded_section (target_sec))
@


1.129
log
@Fix spelling mistakes.
@
text
@a1533 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.128
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d3469 1
a3469 1
  /* Check if we have the same endianess.  */
@


1.127
log
@Fix build with -DDEBUG=7
@
text
@d2663 2
a2664 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.126
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d5713 1
a5713 1
	       r->sec->name, r->offset, t, r->removed_bytes);
@


1.125
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2803 1
a2803 1
      if (r_symndx != 0
@


1.124
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d10769 1
@


1.123
log
@fix set but unused variable warnings
@
text
@d3805 1
a3805 1
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.122
log
@2010-05-28  Sterling Augustine  <sterling@@tensilica.com>

        * elf32-xtensa.c (elf_xtensa_relocate_section): Add a large amount
        of code to change the bits in the instructions to match the changes
        in the relocations.  Declare dest_addr and sym_sec to help.
@
text
@a7831 1
  xlate_map_entry_t tmp;
a7840 4
  tmp.orig_address = offset;
  tmp.new_address = offset;
  tmp.size = 1;

a9657 1
      asection *target_sec;
a9661 1
      target_sec = r_reloc_get_section (r_rel);
@


1.121
log
@	* section.c (struct bfd_section): Delete has_tls_reloc,
	has_tls_get_addr_call, has_gp_reloc, need_finalize_relax, reloc_done.
	Add sec_flg0 thru sec_flg5.
	(BFD_FAKE_SECTION): Update for changed flags.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	* elf64-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Update.
	* elf32-xtensa.c (reloc_done): Define.
	* elfxx-ia64.c (skip_relax_pass_0, skip_relax_pass_1): Update.
	* bfd-in2.h: Regenerate.
@
text
@d2675 3
d2694 3
d2733 11
a2743 1
	  if (rel->r_addend)
d2745 9
a2753 2
	      howto = &elf_howto_table[r_type];
	      if (howto->partial_inplace)
d2756 1
a2756 1
					   rel->r_addend, contents,
a2758 8
		  if (r != bfd_reloc_ok)
		    {
		      if (!((*info->callbacks->reloc_dangerous)
			    (info, error_message, input_bfd, input_section,
			     rel->r_offset)))
			return FALSE;
		    }
		  rel->r_addend = 0;
d2761 7
d8873 3
@


1.120
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d158 4
@


1.119
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
d575 1
a575 1
   && elf_object_id (bfd) == XTENSA_ELF_TDATA)
d581 1
a581 1
				  XTENSA_ELF_TDATA);
d613 2
a614 1
  ((struct elf_xtensa_link_hash_table *) ((p)->hash))
d660 2
a661 1
				      sizeof (struct elf_xtensa_link_hash_entry)))
d982 3
d1286 2
d1407 2
d1535 2
d1566 2
d1618 3
d1854 3
d2568 3
d3256 3
d9523 3
d10256 3
d10278 2
@


1.118
log
@	* elf32-xtensa.c (elf_xtensa_relax_section): Delete -r check.
@
text
@d1946 2
a1947 3
	  xtensa_opcode opcode =
	    get_expanded_call_opcode (contents + address,
				      input_size - address, 0);
d2667 1
a2667 1
	      char *error_message = NULL;
d3168 1
a3168 1
      bfd_boolean remove = FALSE;
d3171 3
a3173 3
	remove = TRUE;
      else if (n > 0 &&
	       (table[n-1].address + table[n-1].size == table[n].address))
d3176 1
a3176 1
	  remove = TRUE;
d3179 1
a3179 1
      if (remove)
@


1.117
log
@update copyright dates
@
text
@a6636 4
  if (link_info->relocatable)
    (*link_info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

@


1.117.2.1
log
@	* elf32-xtensa.c (elf_xtensa_relax_section): Delete -r check.
@
text
@d6637 4
@


1.116
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.115
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d1407 1
a1422 6
  /* Create ".rela.got".  */
  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got", flags);
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;

@


1.114
log
@2009-04-02  Sterling Augustine  <sterling@@jaw.hq.tensilica.com>

	* elf32-xtensa.c (relax_property_section): Always set r_offset
	to zero.
@
text
@d6641 4
@


1.113
log
@2009-02-24  Sterling Augustine  <sterling@@tensilica.com>

	* elf32-xtensa.c (text_action_add): Separate test for action
	type.  Break if saved action is ta_widen_insn at same offset.
@
text
@d10018 1
a10018 6
	      /* In case this is the last entry, move the relocation offset
		 to the previous entry, if there is one.  */
	      if (offset_rel->r_offset >= bytes_to_remove)
		offset_rel->r_offset -= bytes_to_remove;
	      else
		offset_rel->r_offset = 0;
@


1.112
log
@        * elf32-xtensa.c (elf_xtensa_check_relocs): Check for negative refcount.
@
text
@d5481 2
a5482 3
      /* When the action is another fill at the same address,
	 just increase the size.  */
      if (t->offset == offset && t->action == ta_fill && action == ta_fill)
d5484 11
a5494 2
	  t->removed_bytes += removed;
	  return;
@


1.111
log
@2008-08-20  Bob Wilson  <bob.wilson@@acm.org>
bfd/
        * elf-bfd.h (elf_object_id): Add XTENSA_ELF_TDATA.
        * elf32-xtensa.c (elf_howto_table): Add TLS relocations.
        (elf_xtensa_reloc_type_lookup): Likewise.
        (TCB_SIZE): Define.
        (elf_xtensa_link_hash_entry): New.
        (GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE, GOT_TLS_ANY): Define.
        (elf_xtensa_hash_entry): Define.
        (elf_xtensa_obj_tdata): New.
        (elf_xtensa_tdata): Define.
        (elf_xtensa_local_got_tls_type): Define.
        (elf_xtensa_local_tlsfunc_refcounts): Define.
        (is_xtensa_elf): Define.
        (elf_xtensa_mkobject): New.
        (elf_xtensa_link_hash_table): Add tlsbase field.
        (elf_xtensa_link_hash_newfunc): New.
        (elf_xtensa_link_hash_table_create): Use elf_xtensa_link_hash_newfunc.
        Create an entry for "_TLS_MODULE_BASE_" and save it in tlsbase field.
        (elf_xtensa_copy_indirect_symbol): New.
        (elf_xtensa_check_relocs): Rewrite to handle TLS relocations.
        (elf_xtensa_gc_sweep_hook): Likewise.
        (elf_xtensa_allocate_dynrelocs): Optimize away GOT entries for
        TLSDESC_FN relocations when an IE reference is seen.
        (elf_xtensa_allocate_local_got_size): Likewise.
        (elf_xtensa_always_size_sections): New.
        (dtpoff_base, tpoff): New.
        (elf_xtensa_do_reloc): Handle TLS relocations.
        (replace_tls_insn): New.
        (IS_XTENSA_TLS_RELOC): Define.
        (elf_xtensa_relocate_section): Handle TLS relocations.
        (get_indirect_call_dest_reg): New.
        (bfd_elf32_mkobject): Define.
        (elf_backend_always_size_sections): New.
        (elf_backend_copy_indirect_symbol): New.
        * reloc.c (BFD_RELOC_XTENSA_TLSDESC_FN, BFD_RELOC_XTENSA_TLSDESC_ARG)
        (BFD_RELOC_XTENSA_TLS_DTPOFF, BFD_RELOC_XTENSA_TLS_TPOFF)
        (BFD_RELOC_XTENSA_TLS_FUNC, BFD_RELOC_XTENSA_TLS_ARG)
        (BFD_RELOC_XTENSA_TLS_CALL): New.
        * bfd-in2.h: Regenerate.
        * libbfd.h: Regenerate.
gas/
        * config/tc-xtensa.c (O_tlsfunc, O_tlsarg, O_tlscall): Define.
        (O_tpoff, O_dtpoff): Define.
        (suffix_relocs): Add entries for TLS suffixes.
        (xtensa_elf_cons): Check for invalid use of TLS relocations.
        (map_operator_to_reloc): Add is_literal parameter and use it to
        control translating TLS instruction relocations to the corresponding
        literal relocations.
        (xg_valid_literal_expression): Allow TLS operators.
        (xg_build_to_insn): Copy TLS operators from pseudo-instruction
        operands to generated literals.
        (xg_assemble_literal): Handle TLS operators.  Update call to
        map_operator_to_reloc.
        (md_assemble): Handle CALLXn.TLS pseudo-instruction.
        (md_apply_fix): Handle TLS relocations.
        (emit_single_op): Handle TLS operators.
        (convert_frag_immed): Update call to map_operator_to_reloc.
        (vinsn_to_insnbuf): Emit relocations for TLS-related instructions.
        * config/xtensa-istack.h (tinsn_struct): Add tls_reloc field.
        * config/xtensa-relax.c (append_literal_op): Add src_op parameter
        to initialize the op_data field of the BuildOp.
        (build_transition): Use it here to record the source operand
        corresponding to a generated literal.
        * config/xtensa-relax.h (build_op): Comment op_data use for literals.
include/elf/
        * xtensa.h (R_XTENSA_TLSDESC_FN, R_XTENSA_TLSDESC_ARG)
        (R_XTENSA_TLS_DTPOFF, R_XTENSA_TLS_TPOFF, R_XTENSA_TLS_FUNC)
        (R_XTENSA_TLS_ARG, R_XTENSA_TLS_CALL): New.
ld/testsuite/
        * ld-xtensa/tlsbin.dd, ld-xtensa/tlsbin.rd, ld-xtensa/tlsbin.s,
        ld-xtensa/tlsbin.sd, ld-xtensa/tlsbin.td, ld-xtensa/tlslib.s,
        ld-xtensa/tlspic.dd, ld-xtensa/tlspic.rd, ld-xtensa/tlspic.sd,
        ld-xtensa/tlspic.td, ld-xtensa/tlspic1.s, ld-xtensa/tlspic2.s: New.
        * ld-xtensa/xtensa.exp: Run them.
@
text
@d1090 7
a1096 2
	      h->plt.refcount += 1;
	      h->needs_plt = 1;
d1110 6
a1115 1
	    h->got.refcount += 1;
@


1.111.2.1
log
@        * elf32-xtensa.c (elf_xtensa_check_relocs): Check for negative refcount.
@
text
@d1090 2
a1091 7
	      if (h->plt.refcount <= 0)
		{
		  h->needs_plt = 1;
		  h->plt.refcount = 1;
		}
	      else
		h->plt.refcount += 1;
d1105 1
a1105 6
	    {
	      if (h->got.refcount <= 0)
		h->got.refcount = 1;
	      else
		h->got.refcount += 1;
	    }
@


1.110
log
@bfd/
        * elf32-xtensa.c (xtensa_property_section_name): New.
        (xtensa_make_property_section): New.
        (xtensa_get_property_section): Make static.  Do not create a new
        section if it does not exist.
gas/
        * config/tc-xtensa.c (xtensa_create_property_segments): Use
        xtensa_make_property_section instead of xtensa_get_property_section.
        (xtensa_create_xproperty_segments): Likewise.
@
text
@d291 23
d401 28
d533 50
d605 2
d614 29
d648 1
d657 2
a658 2
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry)))
d674 10
d687 27
d973 1
a973 1
  if (info->relocatable)
d976 2
d987 6
a992 1
      struct elf_link_hash_entry *h;
d1004 1
a1004 3
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
d1011 1
d1015 10
a1024 3
	case R_XTENSA_32:
	  if (h == NULL)
	    goto local_literal;
d1026 2
a1027 1
	  if ((sec->flags & SEC_ALLOC) != 0)
d1029 8
a1036 4
	      if (h->got.refcount <= 0)
		h->got.refcount = 1;
	      else
		h->got.refcount += 1;
d1040 20
d1061 10
a1070 4
	  /* If this relocation is against a local symbol, then it's
	     exactly the same as a normal local GOT entry.  */
	  if (h == NULL)
	    goto local_literal;
d1072 17
a1088 1
	  if ((sec->flags & SEC_ALLOC) != 0)
d1090 2
a1091 7
	      if (h->plt.refcount <= 0)
		{
		  h->needs_plt = 1;
		  h->plt.refcount = 1;
		}
	      else
		h->plt.refcount += 1;
d1104 5
a1108 1
	  break;
d1110 6
a1115 2
	local_literal:
	  if ((sec->flags & SEC_ALLOC) != 0)
d1117 7
a1123 1
	      bfd_signed_vma *local_got_refcounts;
d1125 4
a1128 5
	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;
d1130 5
a1134 9
		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts =
		    (bfd_signed_vma *) bfd_zalloc (abfd, size);
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      local_got_refcounts[r_symndx] += 1;
a1135 1
	  break;
d1137 9
a1145 6
	case R_XTENSA_GNU_VTINHERIT:
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d1147 21
a1167 8
	case R_XTENSA_GNU_VTENTRY:
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d1169 6
a1174 2
	default:
	  break;
d1260 1
a1260 1
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
a1265 1
  bfd_signed_vma *local_got_refcounts;
d1267 3
a1278 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d1286 4
d1299 1
d1304 23
d1328 1
a1328 4
	  if (h == NULL)
	    goto local_literal;
	  if (h->got.refcount > 0)
	    h->got.refcount--;
d1332 1
a1332 4
	  if (h == NULL)
	    goto local_literal;
	  if (h->plt.refcount > 0)
	    h->plt.refcount--;
d1335 3
a1337 4
	local_literal:
	  if (local_got_refcounts[r_symndx] > 0)
	    local_got_refcounts[r_symndx] -= 1;
	  break;
d1339 34
a1372 2
	default:
	  break;
d1510 1
a1510 1
  bfd_boolean is_dynamic;
d1521 7
a1527 1
  is_dynamic = elf_xtensa_dynamic_symbol_p (h, info);
d1529 1
a1529 1
  if (! is_dynamic)
d1565 10
d1824 30
d1855 29
d1931 3
a1972 1
    case R_XTENSA_PLT:
d1984 8
d2331 182
d2533 1
d2536 1
d2541 2
d2546 1
d2568 2
d2576 1
d2612 1
d2627 2
d2740 16
a2755 2
      /* Generate dynamic relocations.  */
      if (elf_hash_table (info)->dynamic_sections_created)
d2757 12
a2768 1
	  bfd_boolean dynamic_symbol = elf_xtensa_dynamic_symbol_p (h, info);
d2770 13
a2782 16
	  if (dynamic_symbol && (is_operand_relocation (r_type)
				 || r_type == R_XTENSA_32_PCREL))
	    {
	      const char *name = h->root.root.string;
	      error_message =
		vsprint_msg ("invalid relocation for dynamic symbol", ": %s",
			     strlen (name) + 2, name);
	      if (!((*info->callbacks->reloc_dangerous)
		    (info, error_message, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      continue;
	    }
	  else if ((r_type == R_XTENSA_32 || r_type == R_XTENSA_PLT)
		   && (input_section->flags & SEC_ALLOC) != 0
		   && (dynamic_symbol || info->shared))
d2866 145
d3026 1
a3026 1
	     h->root.root.string);
d3030 3
a3041 2
	  const char *name;

d3045 3
a3047 2
	  if (h)
	    name = h->root.root.string;
d3049 3
a3051 16
	    {
	      name = bfd_elf_string_from_elf_section
		(input_bfd, symtab_hdr->sh_link, sym->st_name);
	      if (name && *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }
	  if (name)
	    {
	      if (rel->r_addend == 0)
		error_message = vsprint_msg (error_message, ": %s",
					     strlen (name) + 2, name);
	      else
		error_message = vsprint_msg (error_message, ": (%s+0x%x)",
					     strlen (name) + 22,
					     name, (int)rel->r_addend);
	    }
d3855 23
d10732 2
d10761 1
d10766 1
@


1.109
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d111 2
a112 1
extern asection *xtensa_get_property_section (asection *, const char *);
d9720 2
a9721 2
asection *
xtensa_get_property_section (asection *sec, const char *base_name)
a9724 1
  asection *prop_sec;
d9766 25
d9792 1
d9795 1
a9795 1
					 (void *) group_name);
d9808 1
a9808 1
      elf_group_name (prop_sec) = group_name;
@


1.108
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@a9505 2
      else if (section_index > 0 && section_index < SHN_LORESERVE)
	target_sec = bfd_section_from_elf_index (abfd, section_index);
d9511 1
a9511 2
	/* Who knows?  */
	target_sec = NULL;
@


1.107
log
@	* elf32-xtensa (elf_xtensa_relocate_section): After finding an invalid
	relocation, do not continue processing it.  Ignore R_XTENSA_ASM_EXPAND
	relocations against dynamic symbols.
	(elf_xtensa_finish_dynamic_sections): Do not fail if there is no
	.xt.lit section.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d1761 1
a1761 1
      message = (char *) bfd_realloc (message, len);
d1764 6
a1769 3
  if (!is_append)
    memcpy (message, origmsg, orig_len);
  vsprintf (message + orig_len, fmt, ap);
@


1.106
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2167 1
d2248 7
d2478 1
a2478 1
  int num_xtlit_entries;
d2603 8
a2610 5
  BFD_ASSERT (sxtlit && sgotloc);
  num_xtlit_entries =
    elf_xtensa_combine_prop_entries (output_bfd, sxtlit, sgotloc);
  if (num_xtlit_entries < 0)
    return FALSE;
@


1.105
log
@	* elf32-xtensa.c (relax_section): Update DIFF relocations in the
	same way as other relocations.
@
text
@d1015 3
@


1.104
log
@        * elf32-xtensa.c (elf_xtensa_do_reloc): Update self_address along with
        address.
        (print_action_list): Fix name for ta_convert_longcall.
@
text
@d8243 11
d8256 2
a8257 14
		  /* If the relocation still references a section in the same
		     input file, modify the relocation directly instead of
		     adding a "fix" record.  */
		  if (target_sec->owner == abfd)
		    {
		      unsigned r_symndx = ELF32_R_SYM (new_reloc.rela.r_info);
		      irel->r_info = ELF32_R_INFO (r_symndx, r_type);
		      irel->r_addend = new_reloc.rela.r_addend;
		      pin_internal_relocs (sec, internal_relocs);
		    }
		  else
		    {
		      bfd_vma addend_displacement;
		      reloc_bfd_fix *fix;
d8259 6
a8264 7
		      addend_displacement =
			new_reloc.target_offset + new_reloc.virtual_offset;
		      fix = reloc_bfd_fix_init (sec, source_offset, r_type,
						target_sec,
						addend_displacement, TRUE);
		      add_fix (sec, fix);
		    }
@


1.103
log
@2007-12-07  Bob Wilson  <bob.wilson@@acm.org>

include/elf/
	* xtensa.h (R_XTENSA_32_PCREL): New.

bfd/
	* elf32-xtensa.c (elf_howto_table): Add R_XTENSA_32_PCREL.
	(elf_xtensa_reloc_type_lookup): Handle BFD_RELOC_32_PCREL.
	(elf_xtensa_check_relocs): Use default case for all relocations that
	need nothing done here.
	(elf_xtensa_do_reloc): Compute self_address for all relocation types.
	Handle R_XTENSA_32_PCREL.
	(elf_xtensa_relocate_section): Check for R_XTENSA_32_PCREL for dynamic
	symbols.
	(check_section_ebb_pcrels_fit): Ignore R_XTENSA_32_PCREL relocations.

gas/
	* config/tc-xtensa.c (O_pcrel): Define.
	(suffix_relocs): Add pcrel suffix.
	(md_pseudo_table): Add 4byte and 2byte directives.
	(xtensa_elf_cons): Pass correct pcrel argument to fix_new_exp.
	(xg_assemble_literal): Likewise.  Check for O_pcrel.
	(expression_maybe_register): Reorganize.  Handle BFD_RELOC_32_PCREL.
	(xg_valid_literal_expression): Allow O_pcrel.
	(md_pcrel_from, md_apply_fix): Handle BFD_RELOC_32_PCREL.
	(tc_gen_reloc): Fix punctuation in error message.

gas/testsuite/
	* gas/xtensa/all.exp: Run new pcrel test.
	* gas/xtensa/err-pcrel.s: New.
	* gas/xtensa/pcrel.d: New.
	* gas/xtensa/pcrel.s: New.
	* gas/xtensa/xtensa-err.exp: New.
@
text
@d1578 1
d4850 1
a4850 1
	  t = "remove_longcall"; break;
@


1.102
log
@	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Create DT_PLTGOT
	entry for all dynamic objects.
@
text
@d205 4
a208 1
  EMPTY_HOWTO (14),
d313 4
a902 41
	case R_XTENSA_OP0:
	case R_XTENSA_OP1:
	case R_XTENSA_OP2:
	case R_XTENSA_SLOT0_OP:
	case R_XTENSA_SLOT1_OP:
	case R_XTENSA_SLOT2_OP:
	case R_XTENSA_SLOT3_OP:
	case R_XTENSA_SLOT4_OP:
	case R_XTENSA_SLOT5_OP:
	case R_XTENSA_SLOT6_OP:
	case R_XTENSA_SLOT7_OP:
	case R_XTENSA_SLOT8_OP:
	case R_XTENSA_SLOT9_OP:
	case R_XTENSA_SLOT10_OP:
	case R_XTENSA_SLOT11_OP:
	case R_XTENSA_SLOT12_OP:
	case R_XTENSA_SLOT13_OP:
	case R_XTENSA_SLOT14_OP:
	case R_XTENSA_SLOT0_ALT:
	case R_XTENSA_SLOT1_ALT:
	case R_XTENSA_SLOT2_ALT:
	case R_XTENSA_SLOT3_ALT:
	case R_XTENSA_SLOT4_ALT:
	case R_XTENSA_SLOT5_ALT:
	case R_XTENSA_SLOT6_ALT:
	case R_XTENSA_SLOT7_ALT:
	case R_XTENSA_SLOT8_ALT:
	case R_XTENSA_SLOT9_ALT:
	case R_XTENSA_SLOT10_ALT:
	case R_XTENSA_SLOT11_ALT:
	case R_XTENSA_SLOT12_ALT:
	case R_XTENSA_SLOT13_ALT:
	case R_XTENSA_SLOT14_ALT:
	case R_XTENSA_ASM_EXPAND:
	case R_XTENSA_ASM_SIMPLIFY:
	case R_XTENSA_DIFF8:
	case R_XTENSA_DIFF16:
	case R_XTENSA_DIFF32:
	  /* Nothing to do for these.  */
	  break;

d1521 1
a1521 1
  bfd_vma self_address = 0;
d1534 5
a1555 3
	      self_address = (input_section->output_section->vma
			      + input_section->output_offset
			      + address);
d1591 4
a1679 5
	  /* Calculate the PC address for this instruction.  */
	  self_address = (input_section->output_section->vma
			  + input_section->output_offset
			  + address);

d2152 2
a2153 1
	  if (dynamic_symbol && is_operand_relocation (r_type))
a2154 2
	      /* This is an error.  The symbol's real value won't be known
		 until runtime and it's likely to be out of range anyway.  */
d2156 3
a2158 3
	      error_message = vsprint_msg ("invalid relocation for dynamic "
					   "symbol", ": %s",
					   strlen (name) + 2, name);
d7144 2
a7145 1
      if (ELF32_R_TYPE (irel->r_info) == R_XTENSA_ASM_SIMPLIFY
@


1.101
log
@	* elf32-xtensa.c (relax_section): Check for a reference to a discarded
	DWARF section and anticipate its replacement with the kept section.
@
text
@d1507 1
a1507 2
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
d1521 2
a1522 1
      if (!add_dynamic_entry (DT_XTENSA_GOT_LOC_OFF, 0)
@


1.100
log
@	* elf32-xtensa.c (elf_xtensa_discard_info_for_section): Remove
	unnecessary size variables.  Set sec->rawsize.
	(relax_section, relax_property_section): Likewise.
@
text
@d8153 49
a8202 1

@


1.99
log
@	* elf32-xtensa.c (relax_section): Call pin_internal_relocs when
	changing a relocation's offset.  Adjust call to translate_reloc.  Do
	not add a fix record for a DIFF reloc.  For other relocs, only add a
	fix record if the translated target is in a different object file;
	otherwise, just update the relocation.  Call pin_internal_relocs when
	updating a reloc but not when adding a fix record.
	(translate_reloc): Get the target section from a new argument, not
	from the relocation.  Change check for relaxable sections to an
	assertion.  Compute separate offset adjustments for the base symbol
	and the addend, and set the new relocation's addend correctly.  Return
	the new target section.
@
text
@a2843 1
  bfd_vma section_size;
d2857 1
a2857 2
  section_size = sec->size;
  if (section_size == 0 || section_size % entry_size != 0)
d2879 1
a2879 1
  for (offset = 0; offset < section_size; offset += entry_size)
d2903 1
a2903 1
		  if (offset + entry_size < section_size)
d2906 1
a2906 1
			     section_size - offset - entry_size);
d2940 1
a2940 1
      memset (&contents[section_size - removed_bytes], 0, removed_bytes);
d2946 3
a2948 1
      sec->size = section_size - removed_bytes;
a8263 1
      bfd_size_type size = sec->size;
d8268 1
a8268 1
      bfd_size_type orig_size = size;
a8421 1
	  size -= action->removed_bytes;
d8462 2
a9051 1
      bfd_vma section_size;
d9067 1
a9067 2
      section_size = sec->size;
      BFD_ASSERT (section_size % entry_size == 0);
d9069 1
a9069 1
      for (offset = 0; offset < section_size; offset += entry_size)
d9215 1
a9215 1
	      if (offset + bytes_to_remove < section_size)
d9218 1
a9218 1
			 section_size - offset - bytes_to_remove);
d9229 1
a9229 1
	  memset (&contents[section_size - removed_bytes], 0, removed_bytes);
d9231 3
a9233 1
	  sec->size = section_size - removed_bytes;
@


1.98
log
@	* elf32-xtensa.c (elf_xtensa_relocate_section): Remove updates of
	r_type and howto after calling do_fix_for_relocateable_link and
	do_fix_for_final_link.
@
text
@d5851 1
a5851 1
static void translate_reloc (const r_reloc *, r_reloc *);
d8097 2
a8108 1
		  pin_internal_relocs (sec, internal_relocs);
d8160 1
a8160 4
	      reloc_bfd_fix *fix;
	      bfd_vma addend_displacement;

	      translate_reloc (&r_rel, &new_reloc);
d8227 16
d8244 8
a8251 11
	      /* FIXME: If the relocation still references a section in
		 the same input file, the relocation should be modified
		 directly instead of adding a "fix" record.  */

	      addend_displacement =
		new_reloc.target_offset + new_reloc.virtual_offset;

	      fix = reloc_bfd_fix_init (sec, source_offset, r_type,
					r_reloc_get_section (&new_reloc),
					addend_displacement, TRUE);
	      add_fix (sec, fix);
a8252 2

	  pin_internal_relocs (sec, internal_relocs);
d8585 2
a8586 2
static void
translate_reloc (const r_reloc *orig_rel, r_reloc *new_rel)
a8587 1
  asection *sec;
d8590 2
a8591 1
  bfd_vma new_offset, target_offset, removed_bytes;
d8596 1
a8596 2
    return;
  sec = r_reloc_get_section (orig_rel);
d8599 2
a8600 5
  BFD_ASSERT (relax_info);

  if (!relax_info->is_relaxable_literal_section
      && !relax_info->is_relaxable_asm_section)
    return;
d8631 1
a8631 1
	    return;
d8636 24
a8659 3
  /* ...and the target address may have been moved within its section.  */
  new_offset = offset_with_removed_text (&relax_info->action_list,
					 target_offset);
d8661 1
a8661 4
  /* Modify the offset and addend.  */
  removed_bytes = target_offset - new_offset;
  new_rel->target_offset = new_offset;
  new_rel->rela.r_addend -= removed_bytes;
@


1.97
log
@	* elf32-xtensa.c (removed_by_actions): New.
	(offset_with_removed_text): Reimplement using removed_by_actions.
	(offset_with_removed_text_before_fill): Delete.
	(relax_property_section): Use removed_by_actions.  Rearrange logic.
	(relax_section_symbols): Likewise.
@
text
@a2097 1
	      r_type = ELF32_R_TYPE (rel->r_info);
a2166 4

	  /* Update some already cached values.  */
	  r_type = ELF32_R_TYPE (rel->r_info);
	  howto = &elf_howto_table[r_type];
@


1.96
log
@	* elf32-xtensa.c (reloc_bfd_fix_struct): Delete target_abfd field.
	(reloc_bfd_fix_init): Remove target_abfd argument.
	(relax_section, move_literal): Adjust calls to reloc_bfd_fix_init.
@
text
@d4783 10
a4792 2
static bfd_vma 
offset_with_removed_text (text_action_list *action_list, bfd_vma offset)
d4797 2
a4798 1
  for (r = action_list->head; r && r->offset <= offset; r = r->next)
d4800 10
a4809 3
      if (r->offset < offset
	  || (r->action == ta_fill && r->removed_bytes < 0))
	removed += r->removed_bytes;
d4812 10
a4821 1
  return (offset - removed);
a4837 14
static bfd_vma
offset_with_removed_text_before_fill (text_action_list *action_list,
				      bfd_vma offset)
{
  text_action *r;
  int removed = 0;

  for (r = action_list->head; r && r->offset < offset; r = r->next)
    removed += r->removed_bytes;

  return (offset - removed);
}


d8957 2
a8958 1
	      bfd_vma new_offset, new_end_offset;
d8960 3
a8962 3

	      new_offset = offset_with_removed_text
		(&target_relax_info->action_list, val.r_rel.target_offset);
d8966 1
d8978 3
a8980 5
		  if (last_zfill_target_sec
		      && last_zfill_target_sec == target_sec
		      && last_zfill_target_offset == val.r_rel.target_offset)
		    new_end_offset = new_offset;
		  else
d8982 7
a8988 4
		      new_end_offset = new_offset;
		      new_offset = offset_with_removed_text_before_fill
			(&target_relax_info->action_list,
			 val.r_rel.target_offset);
d8993 2
a8994 5
		      if (!flags_p
			  || (bfd_get_32 (abfd, flags_p)
			      & XTENSA_PROP_UNREACHABLE) == 0)
			new_end_offset = new_offset;
		      else
d8996 2
d8999 1
a8999 1
			  last_zfill_target_offset = val.r_rel.target_offset;
d9004 2
a9005 7
		{
		  new_end_offset = offset_with_removed_text_before_fill
		    (&target_relax_info->action_list,
		     val.r_rel.target_offset + old_size);
		}

	      new_size = new_end_offset - new_offset;
d9013 1
a9013 1
	      if (new_offset != val.r_rel.target_offset)
d9015 1
a9015 1
		  bfd_vma diff = new_offset - val.r_rel.target_offset;
d9268 4
a9271 3
	  bfd_vma new_address = offset_with_removed_text
	    (&relax_info->action_list, isym->st_value);
	  bfd_vma new_size = isym->st_size;
d9274 2
a9275 8
	    {
	      bfd_vma new_end = offset_with_removed_text
		(&relax_info->action_list, isym->st_value + isym->st_size);
	      new_size = new_end - new_address;
	    }

	  isym->st_value = new_address;
	  isym->st_size = new_size;
d9293 5
a9297 3
	  bfd_vma new_address = offset_with_removed_text
	    (&relax_info->action_list, sym_hash->root.u.def.value);
	  bfd_vma new_size = sym_hash->size;
d9300 2
a9301 9
	    {
	      bfd_vma new_end = offset_with_removed_text
		(&relax_info->action_list,
		 sym_hash->root.u.def.value + sym_hash->size);
	      new_size = new_end - new_address;
	    }

	  sym_hash->root.u.def.value = new_address;
	  sym_hash->size = new_size;
@


1.95
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a5123 1
  bfd *target_abfd;
a5135 1
		    bfd *target_abfd,
a5145 1
  fix->target_abfd = target_abfd;
d8231 1
a8231 1
	      fix = reloc_bfd_fix_init (sec, source_offset, r_type, 0,
d8784 1
a8784 1
      fix = reloc_bfd_fix_init (sec, offset, r_type, r_rel->abfd,
@


1.94
log
@2007-08-28  David Heine  <dlheine@@tensilica.com>
	* elf32-xtensa.c (compute_ebb_actions): Update removed_bytes when
	narrowing instructions.
@
text
@d947 3
a949 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.93
log
@	* elf32-xtensa.c (xtensa_callback_required_dependence): Ignore
	non-ELF sections.
@
text
@d6929 2
@


1.93.2.1
log
@2007-08-28  David Heine  <dlheine@@tensilica.com>
	* elf32-xtensa.c (compute_ebb_actions): Update removed_bytes when
	narrowing instructions.
@
text
@a6928 2
		  if (new_action->do_action)
		    removed_bytes += new_action->removed_bytes;
@


1.92
log
@	* elf32-xtensa.c (elf_xtensa_finish_dynamic_sections): Get section
	vma and size for dynamic tags from the output sections.
@
text
@d9808 5
@


1.91
log
@Switch sources over to use the GPL version 3
@
text
@d2652 1
a2652 1
	  dyn.d_un.d_ptr = htab->sgotloc->vma;
d2656 1
a2656 1
	  dyn.d_un.d_ptr = htab->sgot->vma;
d2660 1
a2660 1
	  dyn.d_un.d_ptr = htab->srelplt->vma;
d2664 1
a2664 1
	  dyn.d_un.d_val = htab->srelplt->size;
d2675 1
a2675 1
	    dyn.d_un.d_val -= htab->srelplt->size;
@


1.90
log
@bfd/
        * elf32-xtensa.c (extend_ebb_bounds_forward): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
        (extend_ebb_bounds_backward, compute_text_actions): Likewise.
        (compute_ebb_proposed_actions, coalesce_shared_literal): Likewise.
        (xtensa_get_property_predef_flags): Likewise.
        (compute_removed_literals): Pass new arguments to is_removable_literal.
        (is_removable_literal): Add sec, prop_table and ptblsize arguments.
        Do not remove literal if the NO_TRANSFORM property flag is set.
gas/
        * config/tc-xtensa.c (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
        (frag_flags_struct): Move is_no_transform out of the insn sub-struct.
        (xtensa_mark_frags_for_org): New.
        (xtensa_handle_align): Set RELAX_ORG frag subtype for rs_org.
        (xtensa_post_relax_hook): Call xtensa_mark_frags_for_org.
        (get_frag_property_flags): Adjust reference to is_no_transform flag.
        (xtensa_frag_flags_combinable): Likewise.
        (frag_flags_to_number): Likewise.  Use XTENSA_PROP_NO_TRANSFORM.
        * config/tc-xtensa.h (xtensa_relax_statesE): Add RELAX_ORG.
include/elf/
        * xtensa.h (XTENSA_PROP_INSN_NO_TRANSFORM): Renamed to...
        (XTENSA_PROP_NO_TRANSFORM): ...this.
ld/
        * emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use renamed
        XTENSA_PROP_NO_TRANSFORM flag instead of XTENSA_PROP_INSN_NO_TRANSFORM.
@
text
@d8 1
a8 1
   published by the Free Software Foundation; either version 2 of the
@


1.89
log
@	* elf32-xtensa.c (elf_xtensa_make_sym_local): Restore deleted function.
	(elf_xtensa_hide_symbol, elf_backend_hide_symbol): Likewise.
	(elf_xtensa_allocate_dynrelocs): Use elf_xtensa_make_sym_local.
@
text
@d5544 1
a5544 1
	  || ((new_entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM) != 0)
d5617 1
a5617 1
	  || ((new_entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM) != 0)
d5825 2
a5826 1
  (const source_reloc *, int, const source_reloc *, int);
d6484 1
a6484 1
      if (the_entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM)
d6677 1
a6677 1
	      && (entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM) == 0
d6684 1
a6684 1
	  else if ((entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM) == 0
d7434 2
a7435 1
      if (is_removable_literal (rel, i, src_relocs, relax_info->src_count))
d7519 4
a7522 1
		      int src_count)
d7525 2
d7530 5
d7824 1
a7824 1
  if (entry && (entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM))
d9750 1
a9750 1
	    | XTENSA_PROP_INSN_NO_TRANSFORM
d9755 1
a9755 1
	    | XTENSA_PROP_INSN_NO_TRANSFORM
@


1.88
log
@	* elf32-xtensa.c (xtensa_read_table_entries): Step through table
	contents and relocs in parallel.
@
text
@d960 38
d1245 1
a1245 20
    {
      if (info->shared)
	{
	  /* For shared objects, there's no need for PLT entries for local
	     symbols (use RELATIVE relocs instead of JMP_SLOT relocs).  */
	  if (h->plt.refcount > 0)
	    {
	      if (h->got.refcount < 0)
		h->got.refcount = 0;
	      h->got.refcount += h->plt.refcount;
	      h->plt.refcount = 0;
	    }
	}
      else
	{
	  /* Don't need any dynamic relocations at all.  */
	  h->plt.refcount = 0;
	  h->got.refcount = 0;
	}
    }
d9902 1
@


1.87
log
@	* elf32-xtensa.c (relax_property_section): Remove extra irel increment.
@
text
@d615 2
a616 2
  Elf_Internal_Rela *internal_relocs;
  bfd_vma section_addr;
d618 1
a618 1
  bfd_size_type table_entry_size;
a653 2
  /* If the file has not yet been relocated, process the relocations
     and sort out the table entries that apply to the specified section.  */
d657 26
a682 1
      unsigned i;
d684 1
a684 1
      for (i = 0; i < table_section->reloc_count; i++)
d686 3
a688 2
	  Elf_Internal_Rela *rel = &internal_relocs[i];
	  unsigned long r_symndx;
d690 1
a690 1
	  if (ELF32_R_TYPE (rel->r_info) == R_XTENSA_NONE)
d693 3
a695 19
	  BFD_ASSERT (ELF32_R_TYPE (rel->r_info) == R_XTENSA_32);
	  r_symndx = ELF32_R_SYM (rel->r_info);

	  if (get_elf_r_symndx_section (abfd, r_symndx) == section)
	    {
	      bfd_vma sym_off = get_elf_r_symndx_offset (abfd, r_symndx);
	      BFD_ASSERT (sym_off == 0);
	      blocks[block_count].address =
		(section_addr + sym_off + rel->r_addend
		 + bfd_get_32 (abfd, table_data + rel->r_offset));
	      blocks[block_count].size =
		bfd_get_32 (abfd, table_data + rel->r_offset + 4);
	      if (predef_flags)
		blocks[block_count].flags = predef_flags;
	      else
		blocks[block_count].flags =
		  bfd_get_32 (abfd, table_data + rel->r_offset + 8);
	      block_count++;
	    }
d697 5
a701 25
    }
  else
    {
      /* The file has already been relocated and the addresses are
	 already in the table.  */
      bfd_vma off;
      bfd_size_type section_limit = bfd_get_section_limit (abfd, section);

      for (off = 0; off < table_size; off += table_entry_size) 
	{
	  bfd_vma address = bfd_get_32 (abfd, table_data + off);

	  if (address >= section_addr
	      && address < section_addr + section_limit)
	    {
	      blocks[block_count].address = address;
	      blocks[block_count].size =
		bfd_get_32 (abfd, table_data + off + 4);
	      if (predef_flags)
		blocks[block_count].flags = predef_flags;
	      else
		blocks[block_count].flags =
		  bfd_get_32 (abfd, table_data + off + 8);
	      block_count++;
	    }
d703 8
@


1.86
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a9039 1
		  irel++;
@


1.85
log
@	* elf32-xtensa.c (xtensa_is_insntable_section): New.
	(xtensa_is_proptable_section): New.
	(elf_xtensa_discard_info_for_section): Handle "full" .xt.prop property
	tables with 12-byte entries, as well as tables with 8-byte entries.
	Sort the relocations before examining them.
	(relax_property_section): Use xtensa_is_proptable_section and
	xtensa_is_littable_section.  Rewrite code for combining table entries
	to be more robust in case of unexpected relocations.  Do not set offset
	of unused relocations to less than zero.
	(xtensa_is_property_section): Use other functions instead of
	duplicating section name comparisons.
	(xtensa_is_littable_section): Use CONST_STRNEQ for ".gnu.linkonce.p.".
	(xtensa_get_property_predef_flags): Use xtensa_is_insntable_section.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.84
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Don't follow references
	from Xtensa property sections.
ld/
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): KEEP property sections.
@
text
@d106 1
d108 1
d2834 2
a2835 1
  size_t removed_bytes = 0;
d2837 2
a2838 2
  section_size = sec->size;
  if (section_size == 0 || section_size % 8 != 0)
d2841 7
a2847 2
  if (sec->output_section
      && bfd_is_abs_section (sec->output_section))
d2861 5
d2869 1
a2869 1
  for (offset = 0; offset < section_size; offset += 8)
d2893 1
a2893 1
		  if (offset + 8 < section_size)
d2895 3
a2897 3
			     &contents[actual_offset+8],
			     section_size - offset - 8);
		  removed_bytes += 8;
d8856 1
a8856 1
  unsigned i, nexti;
d8862 1
d8874 5
a8878 3
  is_full_prop_section =
    (   CONST_STRNEQ (sec->name, XTENSA_PROP_SEC_NAME)
     || CONST_STRNEQ (sec->name, ".gnu.linkonce.prop."));
d8907 2
a8908 6
	    {
	      flags_p = &contents[irel->r_offset + 8];
	      BFD_ASSERT (irel->r_offset + 12 <= sec_size);
	    }
	  else
	    BFD_ASSERT (irel->r_offset + 8 <= sec_size);
d8992 1
a8992 1
			  || strcmp (sec->name, XTENSA_LIT_SEC_NAME) == 0))
d8995 1
d8997 1
a8997 1
      bfd_vma offset, last_irel_offset;
a8998 1
      bfd_size_type entry_size;
a9000 5
      if (is_full_prop_section)
	entry_size = 12;
      else
	entry_size = 8;

d9003 1
a9003 1
      /* Walk over memory and irels at the same time.
a9006 1
      nexti = 0; /* Index into internal_relocs.  */
d9011 3
a9013 1
      last_irel_offset = (bfd_vma) -1;
d9019 1
a9019 1
	  Elf_Internal_Rela *irel, *next_irel;
d9021 1
a9021 1
	  bfd_boolean remove_this_irel;
d9024 19
a9042 9
	  irel = NULL;
	  next_irel = NULL;

	  /* Find the next two relocations (if there are that many left),
	     skipping over any R_XTENSA_NONE relocs.  On entry, "nexti" is
	     the starting reloc index.  After these two loops, "i"
	     is the index of the first non-NONE reloc past that starting
	     index, and "nexti" is the index for the next non-NONE reloc
	     after "i".  */
d9044 3
a9046 1
	  for (i = nexti; i < sec->reloc_count; i++)
d9048 1
a9048 1
	      if (ELF32_R_TYPE (internal_relocs[i].r_info) != R_XTENSA_NONE)
d9050 5
a9054 2
		  irel = &internal_relocs[i];
		  break;
a9055 1
	      internal_relocs[i].r_offset -= removed_bytes;
d9058 6
a9063 1
	  for (nexti = i + 1; nexti < sec->reloc_count; nexti++)
d9065 1
a9065 2
	      if (ELF32_R_TYPE (internal_relocs[nexti].r_info)
		  != R_XTENSA_NONE)
d9067 19
a9085 2
		  next_irel = &internal_relocs[nexti];
		  break;
a9086 1
	      internal_relocs[nexti].r_offset -= removed_bytes;
d9088 2
d9091 1
a9091 1
	  remove_this_irel = FALSE;
d9101 3
a9103 24
	  /* Check that the irels are sorted by offset,
	     with only one per address.  */
	  BFD_ASSERT (!irel || (int) irel->r_offset > (int) last_irel_offset); 
	  BFD_ASSERT (!next_irel || next_irel->r_offset > irel->r_offset);

	  /* Make sure there aren't relocs on the size or flag fields.  */
	  if ((irel && irel->r_offset == offset + 4)
	      || (is_full_prop_section 
		  && irel && irel->r_offset == offset + 8))
	    {
	      irel->r_offset -= removed_bytes;
	      last_irel_offset = irel->r_offset;
	    }
	  else if (next_irel && (next_irel->r_offset == offset + 4
				 || (is_full_prop_section 
				     && next_irel->r_offset == offset + 8)))
	    {
	      nexti += 1;
	      irel->r_offset -= removed_bytes;
	      next_irel->r_offset -= removed_bytes;
	      last_irel_offset = next_irel->r_offset;
	    }
	  else if (size == 0 && (flags & XTENSA_PROP_ALIGN) == 0
		   && (flags & XTENSA_PROP_UNREACHABLE) == 0)
d9107 2
a9108 7
	      if (irel && irel->r_offset == offset)
		{
		  remove_this_irel = TRUE;

		  irel->r_offset -= removed_bytes;
		  last_irel_offset = irel->r_offset;
		}
d9110 2
a9111 1
	  else if (irel && irel->r_offset == offset)
d9113 1
a9113 1
	      if (ELF32_R_TYPE (irel->r_info) == R_XTENSA_32)
d9115 21
a9135 1
		  if (last_irel)
d9137 5
a9141 30
		      flagword old_flags;
		      bfd_vma old_size =
			bfd_get_32 (abfd, &contents[last_irel->r_offset + 4]);
		      bfd_vma old_address =
			(last_irel->r_addend
			 + bfd_get_32 (abfd, &contents[last_irel->r_offset]));
		      bfd_vma new_address =
			(irel->r_addend
			 + bfd_get_32 (abfd, &contents[actual_offset]));
		      if (is_full_prop_section) 
			old_flags = bfd_get_32
			  (abfd, &contents[last_irel->r_offset + 8]);
		      else
			old_flags = predef_flags;

		      if ((ELF32_R_SYM (irel->r_info)
			   == ELF32_R_SYM (last_irel->r_info))
			  && old_address + old_size == new_address
			  && old_flags == flags
			  && (old_flags & XTENSA_PROP_INSN_BRANCH_TARGET) == 0
			  && (old_flags & XTENSA_PROP_INSN_LOOP_TARGET) == 0)
			{
			  /* Fix the old size.  */
			  bfd_put_32 (abfd, old_size + size,
				      &contents[last_irel->r_offset + 4]);
			  bytes_to_remove = entry_size;
			  remove_this_irel = TRUE;
			}
		      else
			last_irel = irel;
d9144 1
a9144 1
		    last_irel = irel;
d9146 2
a9147 3

	      irel->r_offset -= removed_bytes;
	      last_irel_offset = irel->r_offset;
d9150 1
a9150 1
	  if (remove_this_irel)
d9152 7
a9158 2
	      irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	      irel->r_offset -= bytes_to_remove;
d9173 4
a9550 2
static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

d9554 3
a9556 3
  if (CONST_STRNEQ (sec->name, XTENSA_INSN_SEC_NAME)
      || CONST_STRNEQ (sec->name, XTENSA_LIT_SEC_NAME)
      || CONST_STRNEQ (sec->name, XTENSA_PROP_SEC_NAME))
d9559 9
a9567 4
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0
      && (CONST_STRNEQ (&sec->name[linkonce_len], "x.")
	  || CONST_STRNEQ (&sec->name[linkonce_len], "p.")
	  || CONST_STRNEQ (&sec->name[linkonce_len], "prop.")))
d9577 2
a9578 1
  if (CONST_STRNEQ (sec->name, XTENSA_LIT_SEC_NAME))
d9581 9
a9589 3
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0
      && sec->name[linkonce_len] == 'p'
      && sec->name[linkonce_len + 1] == '.')
d9646 2
d9722 1
a9722 2
  if (CONST_STRNEQ (sec->name, XTENSA_INSN_SEC_NAME)
      || CONST_STRNEQ (sec->name, ".gnu.linkonce.x."))
@


1.83
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d972 13
@


1.82
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d392 14
d9825 2
@


1.81
log
@	* elf32-xtensa.c (analyze_relocations): Zero src_count if not relaxing.
	(find_relaxable_sections): Do not increment src_count for unknown
	opcodes.  Decode only once instead of calling is_l32r_relocation.
	(compute_text_actions): Remove unused no_insn_move flag.  Assert that
	src_next matches src_count in relax_info.
@
text
@d1989 47
a2116 36
      h = NULL;
      sym = NULL;
      sec = NULL;
      is_weak_undef = FALSE;
      unresolved_reloc = FALSE;
      warned = FALSE;

      if (howto->partial_inplace)
	{
	  /* Because R_XTENSA_32 was made partial_inplace to fix some
	     problems with DWARF info in partial links, there may be
	     an addend stored in the contents.  Take it out of there
	     and move it back into the addend field of the reloc.  */
	  rel->r_addend += bfd_get_32 (input_bfd, contents + rel->r_offset);
	  bfd_put_32 (input_bfd, 0, contents + rel->r_offset);
	}

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  if (relocation == 0
	      && !unresolved_reloc
	      && h->root.type == bfd_link_hash_undefweak)
	    is_weak_undef = TRUE;
	}

a2254 10
      if (r_symndx == 0)
	{
	  /* r_symndx will be zero only for relocs against symbols from
	     removed linkonce sections, or sections discarded by a linker
	     script.  For these relocs, we just want the section contents
	     zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  continue;
	}

@


1.80
log
@	* elf32-xtensa.c (elf_xtensa_make_sym_local): Delete.
	(elf_xtensa_hide_symbol, elf_backend_hide_symbol): Delete.
	(elf_xtensa_fix_refcounts, elf_xtensa_allocate_plt_size)
	(elf_xtensa_allocate_got_size): Replace these with...
	(elf_xtensa_allocate_dynrelocs): ...this new function.
	(elf_xtensa_size_dynamic_sections): Use it.
@
text
@d5916 2
d5961 1
d6012 13
a6024 4
      if (is_operand_relocation (ELF32_R_TYPE (irel->r_info))
	  && (!is_alt_relocation (ELF32_R_TYPE (irel->r_info))
	      || is_l32r_relocation (abfd, sec, contents, irel)))
	target_relax_info->src_count++;
d6026 1
a6026 2
      if (is_l32r_relocation (abfd, sec, contents, irel)
	  && r_reloc_is_defined (&r_rel))
a6346 1
  static bfd_boolean no_insn_move = FALSE;
d6348 3
a6350 2
  if (no_insn_move)
    return ok;
a6352 2
  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info);
@


1.79
log
@	* elf32-xtensa.c (elf_howto_table) <R_XTENSA_GLOB_DAT>
	<R_XTENSA_JMP_SLOT, R_XTENSA_RELATIVE, R_XTENSA_PLT, R_XTENSA_DIFF32>:
	Set src_mask to zero.
	<R_XTENSA_DIFF8, R_XTENSA_DIFF16>: Likewise.  Also fix dst_mask.
	<R_XTENSA_ASM_EXPAND>: Set pcrel_offset to TRUE.
@
text
@a947 37
static void
elf_xtensa_make_sym_local (struct bfd_link_info *info,
			   struct elf_link_hash_entry *h)
{
  if (info->shared)
    {
      if (h->plt.refcount > 0)
	{
	  /* Will use RELATIVE relocs instead of JMP_SLOT relocs.  */
	  if (h->got.refcount < 0)
	    h->got.refcount = 0;
	  h->got.refcount += h->plt.refcount;
	  h->plt.refcount = 0;
	}
    }
  else
    {
      /* Don't need any dynamic relocations at all.  */
      h->plt.refcount = 0;
      h->got.refcount = 0;
    }
}


static void
elf_xtensa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *h,
			bfd_boolean force_local)
{
  /* For a shared link, move the plt refcount to the got refcount to leave
     space for RELATIVE relocs.  */
  elf_xtensa_make_sym_local (info, h);

  _bfd_elf_link_hash_hide_symbol (info, h, force_local);
}


d1164 1
a1164 1
elf_xtensa_fix_refcounts (struct elf_link_hash_entry *h, void *arg)
d1166 6
a1171 1
  struct bfd_link_info *info = (struct bfd_link_info *) arg;
d1176 2
a1177 2
  if (! elf_xtensa_dynamic_symbol_p (h, info))
    elf_xtensa_make_sym_local (info, h);
d1179 1
a1179 2
  return TRUE;
}
d1181 21
a1201 8

static bfd_boolean
elf_xtensa_allocate_plt_size (struct elf_link_hash_entry *h, void *arg)
{
  asection *srelplt = (asection *) arg;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1204 1
a1204 13
    srelplt->size += (h->plt.refcount * sizeof (Elf32_External_Rela));

  return TRUE;
}


static bfd_boolean
elf_xtensa_allocate_got_size (struct elf_link_hash_entry *h, void *arg)
{
  asection *srelgot = (asection *) arg;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1207 1
a1207 1
    srelgot->size += (h->got.refcount * sizeof (Elf32_External_Rela));
d1287 3
a1289 1
      /* Adjust refcounts for symbols that we now know are not "dynamic".  */
d1291 1
a1291 1
			      elf_xtensa_fix_refcounts,
a1293 6
      /* Allocate space in ".rela.got" for literals that reference
	 global symbols.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      elf_xtensa_allocate_got_size,
			      (void *) srelgot);

a1299 5
      /* Allocate space in ".rela.plt" for literals that have PLT entries.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      elf_xtensa_allocate_plt_size,
			      (void *) srelplt);

a9815 1
#define elf_backend_hide_symbol		     elf_xtensa_hide_symbol
@


1.78
log
@        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Renamed to...
        (elf_xtensa_dynamic_symbol_p): ...this.
@
text
@d159 1
a159 1
	 FALSE, 0x00000000, 0x00000000, FALSE),
d163 1
d170 2
a171 2
	 NULL, "R_XTENSA_RTLD",
	 FALSE, 0x00000000, 0x00000000, FALSE),
d174 1
a174 1
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d177 1
a177 1
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d180 1
a180 1
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d183 2
a184 1
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d186 2
d189 1
a189 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP0",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d191 1
a191 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP1",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d193 2
a194 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_OP2",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d197 1
a197 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_ASM_EXPAND",
	 FALSE, 0x00000000, 0x00000000, FALSE),
d200 2
a201 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_ASM_SIMPLIFY",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d204 1
d208 1
a208 1
	 FALSE, 0x00000000, 0x00000000, FALSE),
d212 1
a212 1
	 FALSE, 0x00000000, 0x00000000, FALSE),
d216 1
a216 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF8",
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d218 1
a218 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF16",
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d220 1
a220 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_DIFF32",
	 FALSE, 0xffffffff, 0xffffffff, FALSE),
d224 1
a224 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT0_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d226 1
a226 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT1_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d228 1
a228 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT2_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d230 1
a230 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT3_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d232 1
a232 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT4_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d234 1
a234 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT5_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d236 1
a236 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT6_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d238 1
a238 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT7_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d240 1
a240 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT8_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d242 1
a242 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT9_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d244 1
a244 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT10_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d246 1
a246 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT11_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d248 1
a248 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT12_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d250 1
a250 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT13_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d252 1
a252 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT14_OP",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d256 1
a256 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT0_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d258 1
a258 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT1_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d260 1
a260 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT2_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d262 1
a262 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT3_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d264 1
a264 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT4_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d266 1
a266 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT5_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d268 1
a268 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT6_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d270 1
a270 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT7_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d272 1
a272 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT8_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d274 1
a274 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT9_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d276 1
a276 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT10_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d278 1
a278 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT11_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d280 1
a280 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT12_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d282 1
a282 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT13_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE),
d284 1
a284 2
	 bfd_elf_xtensa_reloc, "R_XTENSA_SLOT14_ALT",
	 FALSE, 0x00000000, 0x00000000, TRUE)
@


1.77
log
@        * elf32-xtensa.c (plt_reloc_count): Move into link hash table.
        (struct elf_xtensa_link_hash_table): New.
        (elf_xtensa_hash_table): New.
        (elf_xtensa_link_hash_table_create): New.
        (elf_xtensa_check_relocs): Update plt_reloc_count references.
        Update arguments to add_extra_plt_sections.
        (elf_xtensa_create_dynamic_sections): Record new sections in the hash
        table.  Update for plt_reloc_count and add_extra_plt_sections.
        (add_extra_plt_sections, elf_xtensa_create_plt_entry): Replace dynobj
        argument with link info.  Update calls to elf_xtensa_get_plt_section
        and elf_xtensa_get_gotplt_section.
        (elf_xtensa_allocate_local_got_size, elf_xtensa_size_dynamic_sections)
        (elf_xtensa_relocate_section, elf_xtensa_finish_dynamic_sections)
        (elf_xtensa_discard_info_for_section, shrink_dynamic_reloc_sections)
        (relax_property_section): Get sections from the hash table and update
        function calls.
        (elf_xtensa_get_plt_section, elf_xtensa_get_gotplt_section): Replace
        dynobj argument with link info.  Get sections for first plt chunk from
        the hash table.
        (bfd_elf32_bfd_link_hash_table_create): Define.
@
text
@d552 1
a552 1
xtensa_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
d1239 1
a1239 1
  if (! xtensa_elf_dynamic_symbol_p (h, info))
d2203 1
a2203 1
	  bfd_boolean dynamic_symbol = xtensa_elf_dynamic_symbol_p (h, info);
d8665 1
a8665 1
  dynamic_symbol = xtensa_elf_dynamic_symbol_p (h, info);
@


1.76
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_special_sections): Add .xtensa.info.
gas/
	* config/tc-xtensa.c (XSHAL_ABI): Add default definition.
	(directive_state): Disable scheduling by default.
	(xtensa_add_config_info): New.
	(xtensa_end): Call xtensa_add_config_info.
gas/testsuite/
	* gas/elf/section2.e-xtensa: New file.
	* gas/elf/elf.exp: Use it.
include/
	* xtensa-config.h (XSHAL_ABI): New.
	(XTHAL_ABI_WINDOWED, XTHAL_ABI_CALL0): New.
ld/
	* emultempl/xtensaelf.em (XSHAL_ABI): Add default definition.
	(replace_insn_sec_with_prop_sec): Use bfd_make_section_with_flags.
	Delete redundant code to set sections flags and alignment.
	(xt_config_info_unpack_and_check, check_xtensa_info): New.
	(elf_xtensa_after_open): Iterate over input statements instead of
	link_info.input_bfds.
	(elf_xtensa_before_allocation): Likewise.  Call check_xtensa_info for
	each input, and write a new .xtensa.info section in the output.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d38 1
a38 1
static bfd_boolean add_extra_plt_sections (bfd *, int);
d97 2
a98 2
static asection *elf_xtensa_get_plt_section (bfd *, int);
static asection *elf_xtensa_get_gotplt_section (bfd *, int);
a134 10
/* Total count of PLT relocations seen during check_relocs.
   The actual PLT code must be split into multiple sections and all
   the sections have to be created before size_dynamic_sections,
   where we figure out the exact number of PLT entries that will be
   needed.  It is OK if this count is an overestimate, e.g., some
   relocations may be removed by GC.  */

static int plt_reloc_count = 0;


d489 61
d808 1
d817 1
d882 1
a882 1
	      plt_reloc_count += 1;
d886 1
a886 2
		  if (!add_extra_plt_sections (elf_hash_table (info)->dynobj,
					       plt_reloc_count))
d1111 1
d1113 2
a1114 1
  asection *s;
d1119 4
d1126 1
a1126 1
  if (!add_extra_plt_sections (dynobj, plt_reloc_count))
d1134 2
a1135 3
  s = bfd_get_section_by_name (dynobj, ".got.plt");
  if (s == NULL
      || ! bfd_set_section_flags (dynobj, s, flags))
d1139 3
a1141 3
  s = bfd_make_section_with_flags (dynobj, ".rela.got", flags);
  if (s == NULL
      || ! bfd_set_section_alignment (dynobj, s, 2))
d1145 3
a1147 3
  s = bfd_make_section_with_flags (dynobj, ".got.loc", flags);
  if (s == NULL
      || ! bfd_set_section_alignment (dynobj, s, 2))
d1151 4
a1154 4
  s = bfd_make_section_with_flags (dynobj, ".xt.lit.plt",
				   noalloc_flags);
  if (s == NULL
      || ! bfd_set_section_alignment (dynobj, s, 2))
d1162 1
a1162 1
add_extra_plt_sections (bfd *dynobj, int count)
d1164 1
d1176 1
a1176 1
      if (elf_xtensa_get_plt_section (dynobj, chunk))
d1277 1
a1277 2
elf_xtensa_allocate_local_got_size (struct bfd_link_info *info,
				    asection *srelgot)
d1279 1
d1282 2
d1300 2
a1301 2
	    srelgot->size += (local_got_refcounts[j]
			      * sizeof (Elf32_External_Rela));
d1313 1
a1320 1
  srelgot = 0;
d1322 1
d1326 2
d1331 6
d1348 1
a1348 4
      s = bfd_get_section_by_name (dynobj, ".got");
      if (s == NULL)
	abort ();
      s->size = 4;
a1356 3
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
      if (srelgot == NULL)
	abort ();
d1365 1
a1365 1
	elf_xtensa_allocate_local_got_size (info, srelgot);
a1367 3
      srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
      if (srelplt == NULL)
	abort ();
d1377 1
a1377 4
      spltlittbl = bfd_get_section_by_name (dynobj, ".xt.lit.plt");
      if (spltlittbl == NULL)
	abort ();

d1386 1
a1386 1
	   (splt = elf_xtensa_get_plt_section (dynobj, chunk)) != NULL;
d1391 2
a1392 3
	  sgotplt = elf_xtensa_get_gotplt_section (dynobj, chunk);
	  if (sgotplt == NULL)
	    abort ();
d1417 1
a1417 3
      sgotloc = bfd_get_section_by_name (dynobj, ".got.loc");
      if (sgotloc == NULL)
	abort ();
a1499 2
      if (srelgot == NULL)
	abort ();
d1945 1
a1945 1
elf_xtensa_create_plt_entry (bfd *dynobj,
d1955 2
a1956 2
  splt = elf_xtensa_get_plt_section (dynobj, chunk);
  sgotplt = elf_xtensa_get_gotplt_section (dynobj, chunk);
d2003 1
a2007 2
  asection *srelgot, *srelplt;
  bfd *dynobj;
d2016 1
a2016 1
  dynobj = elf_hash_table (info)->dynobj;
a2019 8
  srelgot = NULL;
  srelplt = NULL;
  if (dynobj)
    {
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");;
      srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
    }

d2227 1
a2227 1
		srel = srelplt;
d2229 1
a2229 1
		srel = srelgot;
d2278 1
a2278 1
			    elf_xtensa_create_plt_entry (dynobj, output_bfd,
d2526 1
d2535 1
d2542 1
a2542 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d2554 1
a2554 1
  srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
d2563 3
a2565 5
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");;
      BFD_ASSERT (srelgot != NULL);

      spltlittbl = bfd_get_section_by_name (dynobj, ".xt.lit.plt");
      BFD_ASSERT (spltlittbl != NULL);
d2586 1
a2586 1
	  sgotplt = elf_xtensa_get_gotplt_section (dynobj, chunk);
d2654 1
a2654 1
  sgotloc = bfd_get_section_by_name (dynobj, ".got.loc");
a2665 2
      const char *name;
      asection *s;
d2679 3
a2681 2
	  name = ".got.loc";
	  goto get_vma;
d2683 3
a2685 2
	  name = ".got";
	  goto get_vma;
d2687 1
a2687 5
	  name = ".rela.plt";
	get_vma:
	  s = bfd_get_section_by_name (output_bfd, name);
	  BFD_ASSERT (s);
	  dyn.d_un.d_ptr = s->vma;
d2691 1
a2691 3
	  s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	  BFD_ASSERT (s);
	  dyn.d_un.d_val = s->size;
d2701 2
a2702 3
	  s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	  if (s)
	    dyn.d_un.d_val -= s->size;
d2971 3
a2973 8
	  bfd *dynobj = elf_hash_table (info)->dynobj;
	  if (dynobj)
	    {
	      asection *sgotloc =
		bfd_get_section_by_name (dynobj, ".got.loc");
	      if (sgotloc)
		sgotloc->size -= removed_bytes;
	    }
d8645 1
d8653 1
a8670 2
      bfd *dynobj;
      const char *srel_name;
a8673 3
      dynobj = elf_hash_table (info)->dynobj;
      BFD_ASSERT (dynobj != NULL);

d8676 1
a8676 1
	  srel_name = ".rela.plt";
d8680 1
a8680 1
	srel_name = ".rela.got";
a8682 1
      srel = bfd_get_section_by_name (dynobj, srel_name);
d8701 2
a8702 2
	  splt = elf_xtensa_get_plt_section (dynobj, chunk);
	  sgotplt = elf_xtensa_get_gotplt_section (dynobj, chunk);
d8709 1
a8709 1
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d9197 3
a9199 8
	      bfd *dynobj = elf_hash_table (link_info)->dynobj;
	      if (dynobj)
		{
		  asection *sgotloc =
		    bfd_get_section_by_name (dynobj, ".got.loc");
		  if (sgotloc)
		    sgotloc->size -= removed_bytes;
		}
d9385 1
a9385 1
elf_xtensa_get_plt_section (bfd *dynobj, int chunk)
d9387 2
d9392 4
a9395 1
    return bfd_get_section_by_name (dynobj, ".plt");
d9397 1
d9404 1
a9404 1
elf_xtensa_get_gotplt_section (bfd *dynobj, int chunk)
d9406 2
d9411 4
a9414 1
    return bfd_get_section_by_name (dynobj, ".got.plt");
d9416 1
d9874 1
@


1.75
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d9804 1
@


1.74
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2273 10
@


1.73
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_action_discarded): New.
	(elf_backend_action_discarded): Define.
ld/
	* emultempl/xtensaelf.em (is_inconsistent_linkonce_section): Check
	for linkonce XCC exception tables (".e" and ".h").
@
text
@d9847 2
@


1.72
log
@	* elf32-xtensa.c (elf_xtensa_relocate_section): Return after
	unresolvable relocation error.
	(elf_xtensa_finish_dynamic_symbol): Set value of undefined, weak
	symbols to zero.
@
text
@d2972 13
d9848 1
@


1.71
log
@bfd/
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Add DT_DEBUG
	for PIE executables.
ld/
	* emulparams/elf32xtensa.sh (GENERATE_PIE_SCRIPT): Enable.
@
text
@d2262 10
a2271 7
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
	   (long) rel->r_offset,
	   howto->name,
	   h->root.root.string);
d2332 1
a2332 2
  if (h->needs_plt
      && !h->def_regular)
d2337 6
@


1.70
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d1126 1
a1126 2
      s = bfd_make_section_with_flags (dynobj, sname,
				       flags | SEC_CODE);
d1473 1
a1473 1
      if (! info->shared)
@


1.69
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d969 1
a969 1
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
d974 7
a980 17
  if (h)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_XTENSA_GNU_VTINHERIT:
	case R_XTENSA_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
d982 1
a982 9
	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
@


1.68
log
@bfd/
	* elf32-xtensa.c (xtensa_get_property_section_name): Delete.
	(xtensa_get_property_section): New.
	(xtensa_read_table_entries): Use xtensa_get_property_section.
	(relax_property_section, xtensa_get_property_predef_flags): Handle
	group name suffixes in property section names.
	(match_section_group): New.
gas/
	* config/tc-xtensa.c (FINI_LITERAL_SECTION_NAME): Delete.
	(INIT_LITERAL_SECTION_NAME): Delete.
	(lit_state struct): Remove segment names, init_lit_seg, and
	fini_lit_seg.  Add lit_prefix and current_text_seg.
	(init_literal_head_h, init_literal_head): Delete.
	(fini_literal_head_h, fini_literal_head): Delete.
	(xtensa_begin_directive): Move argument parsing to
	xtensa_literal_prefix function.
	(xtensa_end_directive): Deallocate lit_prefix field of lit_state.
	(xtensa_literal_prefix): Parse the directive argument here and
	record it in the lit_prefix field.  Remove code to derive literal
	section names.
	(linkonce_len): New.
	(get_is_linkonce_section): Use linkonce_len.  Check for any
	".gnu.linkonce.*" section, not just text sections.
	(md_begin): Remove initialization of deleted lit_state fields.
	(xtensa_reorder_segments, xtensa_post_relax_hook): Remove references
	to init_literal_head and fini_literal_head.
	(xtensa_move_literals): Likewise.  Skip literals for .init and .fini
	when traversing literal_head list.
	(match_section_group): New.
	(cache_literal_section): Rewrite to determine the literal section
	name on the fly, create the section and return it.
	(xtensa_switch_to_literal_fragment): Adjust for cache_literal_section.
	(xtensa_switch_to_non_abs_literal_fragment): Likewise.
	(xtensa_create_property_segments, xtensa_create_xproperty_segments):
	Use xtensa_get_property_section from bfd.
	(retrieve_xtensa_section): Delete.
	* doc/c-xtensa.texi (Xtensa Options): Fix --text-section-literals
	description to refer to plural literal sections and add xref to
	the Literal Directive section.
	(Literal Directive): Describe new rules for deriving literal section
	names.  Add footnote for special case of .init/.fini with
	--text-section-literals.
	(Literal Prefix Directive): Replace old naming rules with xref to the
	Literal Directive section.
ld/
	* emulparams/elf32xtensa.sh (.xt.prop): Add .xt.prop.*.
	* scripttempl/elfxtensa.sc (.text): Add .literal.*.
@
text
@d1412 1
a1412 1
      if (strncmp (name, ".rela", 5) == 0)
d1426 2
a1427 2
      else if (strncmp (name, ".plt.", 5) != 0
	       && strncmp (name, ".got.plt.", 9) != 0
d8857 2
a8858 4
    ((strncmp (sec->name, XTENSA_PROP_SEC_NAME,
	       sizeof (XTENSA_PROP_SEC_NAME) - 1) == 0)
     || (strncmp (sec->name, ".gnu.linkonce.prop.",
		  sizeof ".gnu.linkonce.prop." - 1) == 0));
a9518 4
static int insn_sec_len = sizeof (XTENSA_INSN_SEC_NAME) - 1;
static int lit_sec_len = sizeof (XTENSA_LIT_SEC_NAME) - 1;
static int prop_sec_len = sizeof (XTENSA_PROP_SEC_NAME) - 1;

d9523 3
a9525 3
  if (strncmp (XTENSA_INSN_SEC_NAME, sec->name, insn_sec_len) == 0
      || strncmp (XTENSA_LIT_SEC_NAME, sec->name, lit_sec_len) == 0
      || strncmp (XTENSA_PROP_SEC_NAME, sec->name, prop_sec_len) == 0)
d9529 3
a9531 3
      && (strncmp (&sec->name[linkonce_len], "x.", 2) == 0
	  || strncmp (&sec->name[linkonce_len], "p.", 2) == 0
	  || strncmp (&sec->name[linkonce_len], "prop.", 5) == 0))
d9541 1
a9541 1
  if (strncmp (XTENSA_LIT_SEC_NAME, sec->name, lit_sec_len) == 0)
d9643 1
a9643 1
      if (strncmp (suffix, "t.", 2) == 0 && linkonce_kind[1] == '.')
d9677 2
a9678 4
  if (strncmp (sec->name, XTENSA_INSN_SEC_NAME,
	       sizeof (XTENSA_INSN_SEC_NAME) - 1) == 0
      || strncmp (sec->name, ".gnu.linkonce.x.",
		  sizeof ".gnu.linkonce.x." - 1) == 0)
d9712 1
a9712 1
      && strncmp (sec->name, ".plt", 4) == 0)
d9789 4
a9792 4
  { ".fini.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".literal",       8, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { NULL,             0, 0, 0,            0 }
@


1.67
log
@	* elf.c (elf_modify_segment_map): Delete empty PT_LOAD segments.
	* elf32-xtensa.c (elf_xtensa_modify_segment_map): Delete.
	(define elf_backend_modify_segment_map): Don't define.
@
text
@d109 1
a109 1
extern char *xtensa_get_property_section_name (asection *, const char *);
a573 1
  char *table_section_name;
d592 1
a592 3
  table_section_name = xtensa_get_property_section_name (section, sec_name);
  table_section = bfd_get_section_by_name (abfd, table_section_name);
  free (table_section_name);
d8857 2
a8858 1
    ((strcmp (sec->name, XTENSA_PROP_SEC_NAME) == 0)
d9594 17
a9610 2
char *
xtensa_get_property_section_name (asection *sec, const char *base_name)
d9612 17
a9628 1
  if (strncmp (sec->name, ".gnu.linkonce.", linkonce_len) == 0)
a9629 2
      char *prop_sec_name;
      const char *suffix;
d9652 19
d9672 1
a9672 1
      return prop_sec_name;
d9675 2
a9676 1
  return strdup (base_name);
d9683 2
a9684 1
  if (strcmp (sec->name, XTENSA_INSN_SEC_NAME) == 0
@


1.66
log
@bfd:
        * elf32-xtensa.c (check_loop_aligned): Fix reversed check for
        undefined opcode.  Clean up assertions.
        (narrow_instruction, widen_instruction): Remove "do_it" parameters.
        Factor most of the code into separate functions....
        (can_narrow_instruction, can_widen_instruction): New.
        (prev_instr_is_a_loop): New.
        (compute_ebb_proposed_actions): Combine error handling code for
        decode errors.  Replace call to insn_decode_len with inline code.
        Use can_narrow_instruction and can_widen_instruction.  Handle errors
        from call to xtensa_opcode_is_loop.
        (relax_section): Adjust calls to narrow_instruction and
        widen_instruction.
gas:
        * config/tc-xtensa.c (is_direct_call_opcode, is_branch_jmp_to_next,
        xg_assemble_vliw_tokens, xtensa_mark_narrow_branches,
        xtensa_fix_short_loop_frags, is_local_forward_loop, relax_frag_immed):
        Handle errors from calls to xtensa_opcode_is_* functions.
@
text
@a1527 25
/* Remove any PT_LOAD segments with no allocated sections.  Prior to
   binutils 2.13, this function used to remove the non-SEC_ALLOC
   sections from PT_LOAD segments, but that task has now been moved
   into elf.c.  We still need this function to remove any empty
   segments that result, but there's nothing Xtensa-specific about
   this and it probably ought to be moved into elf.c as well.  */

static bfd_boolean
elf_xtensa_modify_segment_map (bfd *abfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map **m_p;

  m_p = &elf_tdata (abfd)->segment_map;
  while (*m_p)
    {
      if ((*m_p)->p_type == PT_LOAD && (*m_p)->count == 0)
	*m_p = (*m_p)->next;
      else
	m_p = &(*m_p)->next;
    }
  return TRUE;
}


a9800 1
#define elf_backend_modify_segment_map	     elf_xtensa_modify_segment_map
@


1.65
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d3436 1
a3436 8
  xtensa_opcode opcode =
    insn_decode_opcode (contents, content_length, offset, 0);
  BFD_ASSERT (opcode != XTENSA_UNDEFINED);
  if (opcode != XTENSA_UNDEFINED)
    return FALSE;
  BFD_ASSERT (xtensa_opcode_is_loop (xtensa_default_isa, opcode));
  if (!xtensa_opcode_is_loop (xtensa_default_isa, opcode))
    return FALSE;
d3438 8
a3446 4
  BFD_ASSERT (loop_len != 0);
  if (loop_len == 0)
    return FALSE;

d3448 5
a3452 3
  BFD_ASSERT (insn_len != 0);
  if (insn_len == 0)
    return FALSE;
d3564 4
a3567 4
/* Attempt to narrow an instruction.  Return true if the narrowing is
   valid.  If the do_it parameter is non-zero, then perform the action
   in-place directly into the contents.  Otherwise, do not modify the
   contents.  The set of valid narrowing are specified by a string table
d3570 4
a3573 5
static bfd_boolean
narrow_instruction (bfd_byte *contents,
		    bfd_size_type content_length,
		    bfd_size_type offset,
		    bfd_boolean do_it)
a3574 2
  xtensa_opcode opcode;
  bfd_size_type insn_len, opi;
d3576 2
a3577 1
  xtensa_format fmt, o_fmt;
a3578 2
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
d3582 1
a3582 1
  if (insnbuf == NULL)
a3583 2
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
d3588 1
a3588 24
  BFD_ASSERT (offset < content_length);

  if (content_length < 2)
    return FALSE;

  /* We will hand-code a few of these for a little while.
     These have all been specified in the assembler aleady.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, &contents[offset],
			     content_length - offset);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;

  if (xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf) != 0)
    return FALSE;

  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
  insn_len = xtensa_format_length (isa, fmt);
  if (insn_len > content_length)
    return FALSE;

  for (opi = 0; opi < (sizeof (narrowable)/sizeof (struct string_pair)); ++opi)
d3604 1
a3604 1
	    return FALSE;
d3607 1
a3607 1
	    return FALSE;
d3611 1
a3611 1
	    return FALSE;
d3618 1
a3618 1
	    return FALSE;
d3623 1
a3623 1
		return FALSE;
d3629 10
a3638 16
	      if (o_operand_count + 1 != operand_count)
		return FALSE;
	      if (xtensa_operand_get_field (isa, opcode, 0,
					    fmt, 0, slotbuf, &rawval0) != 0)
		return FALSE;
	      if (xtensa_operand_get_field (isa, opcode, 1,
					    fmt, 0, slotbuf, &rawval1) != 0)
		return FALSE;
	      if (xtensa_operand_get_field (isa, opcode, 2,
					    fmt, 0, slotbuf, &rawval2) != 0)
		return FALSE;

	      if (rawval1 != rawval2)
		return FALSE;
	      if (rawval0 == rawval1) /* it is a nop */
		return FALSE;
d3646 1
a3646 1
		return FALSE;
d3656 1
a3656 1
		return FALSE;
d3659 2
a3660 3
	  if (xtensa_format_set_slot (isa, o_fmt, 0,
				      o_insnbuf, o_slotbuf) != 0)
	    return FALSE;
d3662 1
a3662 4
	  if (do_it)
	    xtensa_insnbuf_to_chars (isa, o_insnbuf, contents + offset,
				     content_length - offset);
	  return TRUE;
d3665 1
a3665 1
  return FALSE;
d3669 3
a3671 6
/* Attempt to widen an instruction.  Return true if the widening is
   valid.  If the do_it parameter is non-zero, then the action should
   be performed inplace into the contents.  Otherwise, do not modify
   the contents.  The set of valid widenings are specified by a string
   table but require some special case operand checks in some
   cases.  */
d3674 3
a3676 4
widen_instruction (bfd_byte *contents,
		   bfd_size_type content_length,
		   bfd_size_type offset,
		   bfd_boolean do_it)
d3679 1
a3679 1
  bfd_size_type insn_len, opi;
d3681 2
a3682 1
  xtensa_format fmt, o_fmt;
a3685 2
  static xtensa_insnbuf o_insnbuf = NULL;
  static xtensa_insnbuf o_slotbuf = NULL;
a3690 2
      o_insnbuf = xtensa_insnbuf_alloc (isa);
      o_slotbuf = xtensa_insnbuf_alloc (isa);
d3698 1
a3698 1
  /* We will hand code a few of these for a little while.
d3716 37
a3752 1
  for (opi = 0; opi < (sizeof (widenable)/sizeof (struct string_pair)); ++opi)
d3770 1
a3770 1
	    return FALSE;
d3773 1
a3773 1
	    return FALSE;
d3777 1
a3777 1
	    return FALSE;
d3785 1
a3785 1
	    return FALSE;
d3790 1
a3790 1
		return FALSE;
d3796 7
a3802 10
	      if (o_operand_count != operand_count + 1)
		return FALSE;
	      if (xtensa_operand_get_field (isa, opcode, 0,
					    fmt, 0, slotbuf, &rawval0) != 0)
		return FALSE;
	      if (xtensa_operand_get_field (isa, opcode, 1,
					    fmt, 0, slotbuf, &rawval1) != 0)
		return FALSE;
	      if (rawval0 == rawval1) /* it is a nop */
		return FALSE;
d3807 1
a3807 1
	  for (i = 0; i < check_operand_count; ++i)
d3815 1
a3815 1
		return FALSE;
d3825 1
a3825 1
		return FALSE;
d3829 1
a3829 1
	    return FALSE;
d3831 1
a3831 4
	  if (do_it)
	    xtensa_insnbuf_to_chars (isa, o_insnbuf, contents + offset,
				     content_length - offset);
	  return TRUE;
d3834 58
d6539 17
d6564 11
d6581 1
a6581 1
      bfd_vma offset, start_offset, end_offset;
d6603 2
a6605 8
	  /* Propose no actions for a section with an undecodable offset.  */
	  if (insn_len == 0) 
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"),
		 ebb->sec->owner, ebb->sec, offset);
	      return FALSE;
	    }
d6636 1
a6636 6
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): could not decode instruction for XTENSA_ASM_SIMPLIFY relocation; possible configuration mismatch"),
		     ebb->sec->owner, ebb->sec, offset);
		  return FALSE;
		}
d6645 12
a6656 4
	  insn_len = insn_decode_len (ebb->contents, ebb->content_length,
				      offset);
	  /* If the instruction is undecodable, then report an error.  */
	  if (insn_len == 0)
d6658 2
a6659 4
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"),
		 ebb->sec->owner, ebb->sec, offset);
	      return FALSE;
d6661 6
a6666 1
	    
d6669 1
a6669 2
	      && narrow_instruction (ebb->contents, ebb->content_length,
				     offset, FALSE))
a6673 2
	      offset += insn_len;
	      continue;
d6675 4
a6678 3
	  if ((entry->flags & XTENSA_PROP_INSN_NO_TRANSFORM) == 0
	      && widen_instruction (ebb->contents, ebb->content_length,
				    offset, FALSE))
a6682 2
	      offset += insn_len;
	      continue;
d6684 1
a6684 3
	  opcode = insn_decode_opcode (ebb->contents, ebb->content_length,
				       offset, 0);
	  if (xtensa_opcode_is_loop (xtensa_default_isa, opcode))
a6688 2
	      offset += insn_len;
	      continue;
d6702 6
d8320 1
a8320 1
	      rv = narrow_instruction (scratch, final_size, 0, TRUE);
d8353 1
a8353 1
	      rv = widen_instruction (scratch, final_size, 0, TRUE);
@


1.64
log
@	* elf32-xtensa.c (build_reloc_opcodes): New.
	(compute_text_actions): Use it to decode opcodes outside inner loop.
	(check_section_ebb_pcrels_fit): Add "reloc_opcodes" argument, and if
	it is set, use it to get the opcodes for relocations.
	(move_shared_literal): Adjust call to check_section_ebb_pcrels_fit.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d5010 4
a5013 2
  struct elf_xtensa_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d5015 5
a5019 4
  sdata = (struct elf_xtensa_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (void *) sdata;
@


1.63
log
@	* elf32-xtensa.c (xtensa_read_table_entries): Remove assertion that
	rel->r_addend is zero.
@
text
@d5769 2
a5770 1
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, const ebb_constraint *);
d6306 18
d6340 1
d6446 5
d6455 2
a6456 1
					    internal_relocs, &ebb_table)
d6488 2
d7057 2
a7058 1
			      const ebb_constraint *constraint)
d7149 4
a7152 1
	  opcode = get_relocation_opcode (abfd, sec, contents, irel);
d7849 1
a7849 1
					     &ebb_table);
@


1.62
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@a642 1
	      BFD_ASSERT (rel->r_addend == 0);
@


1.62.4.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d643 1
d5770 1
a5770 2
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, const ebb_constraint *,
   const xtensa_opcode *);
a6305 18
static xtensa_opcode *
build_reloc_opcodes (bfd *abfd,
		     asection *sec,
		     bfd_byte *contents,
		     Elf_Internal_Rela *internal_relocs)
{
  unsigned i;
  xtensa_opcode *reloc_opcodes =
    (xtensa_opcode *) bfd_malloc (sizeof (xtensa_opcode) * sec->reloc_count);
  for (i = 0; i < sec->reloc_count; i++)
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      reloc_opcodes[i] = get_relocation_opcode (abfd, sec, contents, irel);
    }
  return reloc_opcodes;
}


a6321 1
  xtensa_opcode *reloc_opcodes = NULL;
a6426 5
      /* Precompute the opcode for each relocation.  */
      if (reloc_opcodes == NULL)
	reloc_opcodes = build_reloc_opcodes (abfd, sec, contents,
					     internal_relocs);

d6431 1
a6431 2
					    internal_relocs, &ebb_table,
					    reloc_opcodes)
a6462 2
  if (reloc_opcodes)
    free (reloc_opcodes);
d7030 1
a7030 2
			      const ebb_constraint *constraint,
			      const xtensa_opcode *reloc_opcodes)
d7121 1
a7121 4
	  if (reloc_opcodes)
	    opcode = reloc_opcodes[i];
	  else
	    opcode = get_relocation_opcode (abfd, sec, contents, irel);
d7818 1
a7818 1
					     &ebb_table, NULL);
@


1.61
log
@	* elf32-xtensa.c (action_list_count, xlate_map_entry, xlate_map,
	xlate_offset_with_removed_text, build_xlate_map, free_xlate_map): New.
	(check_section_ebb_pcrels_fit): Build new xlate_map, use it and free it
	when finished.
@
text
@d2387 1
a2387 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.60
log
@	* elf32-xtensa.c (relocations_reach): Skip range check for
	absolute literals.
@
text
@d4759 13
d6867 154
d7034 2
d7040 7
d7082 6
a7087 4
	  self_offset = offset_with_removed_text (&relax_info->action_list,
						  orig_self_offset);
	  target_offset = offset_with_removed_text (&relax_info->action_list,
						    orig_target_offset);
d7123 4
a7126 1
	    return FALSE;
d7130 4
a7133 1
	    return FALSE;
d7136 4
a7139 1
	    return FALSE;
d7143 4
a7146 1
  return TRUE;
@


1.59
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d7465 5
@


1.58
log
@	* elf32-xtensa.c (ELF_MACHINE_CODE, ELF_MACHINE_ALT1): Swap values
	of EM_XTENSA and EM_XTENSA_OLD.
@
text
@d2311 1
a2311 1
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
d2315 1
@


1.57
log
@        * elf32-xtensa.c (vsprint_msg): Add prototype.
        (build_encoding_error_message): Delete.  Code moved into....
        (elf_xtensa_do_reloc): ....here, and changed to give better
        error messages for out of range literals.
@
text
@d9490 2
a9491 8
/* The new EM_XTENSA value will be recognized beginning in the Xtensa T1040
   release. However, we still have to generate files with the EM_XTENSA_OLD
   value so that pre-T1040 tools can read the files.  As soon as we stop
   caring about pre-T1040 tools, the following two values should be
   swapped. At the same time, any other code that uses EM_XTENSA_OLD
   should be changed to use EM_XTENSA.  */
#define ELF_MACHINE_CODE		EM_XTENSA_OLD
#define ELF_MACHINE_ALT1		EM_XTENSA
@


1.56
log
@	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Warning fix.
@
text
@d39 1
a39 1
static char *build_encoding_error_message (xtensa_opcode, bfd_vma);
d1745 24
a1768 1
      *error_message = build_encoding_error_message (opcode, relocation);
d1793 1
a1793 1
static char * ATTRIBUTE_PRINTF(2,4)
a1822 26
static char *
build_encoding_error_message (xtensa_opcode opcode, bfd_vma target_address)
{
  const char *opname = xtensa_opcode_name (xtensa_default_isa, opcode);
  const char *msg;

  msg = "cannot encode";
  if (is_direct_call_opcode (opcode))
    {
      if ((target_address & 0x3) != 0)
	msg = "misaligned call target";
      else
	msg = "call target out of range";
    }
  else if (opcode == get_l32r_opcode ())
    {
      if ((target_address & 0x3) != 0)
	msg = "misaligned literal target";
      else
	msg = "literal target out of range";
    }

  return vsprint_msg (opname, ": %s", strlen (msg) + 2, msg);
}


@


1.55
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1933 2
a1934 1
				    symbol->name, reloc_entry->addend);
@


1.54
log
@	* elf32-xtensa.c: Include <stdarg.h> unconditionally, not only
	when ANSI_PROTOTYPES is defined.  Remove #ifdef logic.
@
text
@a1407 1
      bfd_boolean strip;
a1415 2
      strip = FALSE;

d1418 10
a1427 24
	  if (strcmp (name, ".rela.plt") == 0)
	    relplt = TRUE;
	  else if (strcmp (name, ".rela.got") == 0)
	    relgot = TRUE;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
	}
      else if (strncmp (name, ".plt.", 5) == 0
	       || strncmp (name, ".got.plt.", 9) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the output
		 file.  We must create the ".plt*" and ".got.plt*"
		 sections in create_dynamic_sections and/or check_relocs
		 based on a conservative estimate of the PLT relocation
		 count, because the sections must be created before the
		 linker maps input sections to output sections.  The
		 linker does that before size_dynamic_sections, where we
		 compute the exact size of the PLT, so there may be more
		 of these sections than are actually needed.  */
	      strip = TRUE;
d1430 3
a1432 1
      else if (strcmp (name, ".got") != 0
d1442 14
a1455 3
      if (strip)
	s->flags |= SEC_EXCLUDE;
      else
d1459 1
a1459 1
	  if (s->contents == NULL && s->size != 0)
@


1.53
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a23 1
#ifdef ANSI_PROTOTYPES
a24 3
#else
#include <varargs.h>
#endif
@


1.52
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@a9491 19

static const struct bfd_elf_special_section *
elf_xtensa_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf_xtensa_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d9550 1
a9550 1
#define elf_backend_get_sec_type_attr	     elf_xtensa_get_sec_type_attr
@


1.51
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@d1778 1
a1778 1
static char *
d2358 1
a2358 1
					     name, rel->r_addend);
@


1.50
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d9485 1
a9485 1
static struct bfd_elf_special_section const elf_xtensa_special_sections[] =
d9496 1
a9496 1
  const struct bfd_elf_special_section const *ssect;
@


1.49
log
@	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Make sure that
	xtensa_default_isa is initialized.
@
text
@d9485 1
a9485 2
static struct bfd_elf_special_section const
  xtensa_special_sections_f[]=
a9487 6
  { NULL,             0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  xtensa_special_sections_i[]=
{
a9488 5
  { NULL,             0, 0, 0,            0 }
};
static struct bfd_elf_special_section const
  xtensa_special_sections_l[]=
{
d9493 2
a9494 2
static struct bfd_elf_special_section const *
  elf_xtensa_special_sections[27] =
d9496 14
a9509 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  xtensa_special_sections_f,	/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  xtensa_special_sections_i,	/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  xtensa_special_sections_l,	/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  NULL,				/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d9569 1
a9569 1
#define elf_backend_special_sections	     elf_xtensa_special_sections
@


1.48
log
@	* elf32-xtensa.c (xtensa_get_property_section_name): Add missing
	periods in linkonce_kind values.
@
text
@d1858 3
@


1.47
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d9341 1
a9341 1
	linkonce_kind = "x";
d9343 1
a9343 1
	linkonce_kind = "p";
@


1.46
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d9482 15
a9496 1
static struct bfd_elf_special_section const elf_xtensa_special_sections[]=
a9498 2
  { ".init.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".fini.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
d9502 32
@


1.45
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1108 1
a1108 1
  s = bfd_make_section (dynobj, ".rela.got");
a1109 1
      || ! bfd_set_section_flags (dynobj, s, flags)
d1114 1
a1114 1
  s = bfd_make_section (dynobj, ".got.loc");
a1115 1
      || ! bfd_set_section_flags (dynobj, s, flags)
d1120 2
a1121 1
  s = bfd_make_section (dynobj, ".xt.lit.plt");
a1122 1
      || ! bfd_set_section_flags (dynobj, s, noalloc_flags)
d1152 2
a1153 1
      s = bfd_make_section (dynobj, sname);
a1154 1
	  || ! bfd_set_section_flags (dynobj, s, flags | SEC_CODE)
d1160 1
a1160 1
      s = bfd_make_section (dynobj, sname);
a1161 1
	  || ! bfd_set_section_flags (dynobj, s, flags)
@


1.44
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
@


1.43
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1465 1
a1465 1
	_bfd_strip_section_from_output (info, s);
@


1.42
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@d19 1
a19 1
   02111-1307, USA.  */
@


1.42.2.1
log
@	* elf32-xtensa.c (xtensa_get_property_section_name): Add missing
	periods in linkonce_kind values.
@
text
@d9344 1
a9344 1
	linkonce_kind = "x.";
d9346 1
a9346 1
	linkonce_kind = "p.";
@


1.41
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d4474 1
a4474 1
      hash_val += hash_bfd_vma ((bfd_vma) (unsigned) sec_or_hash);
@


1.40
log
@	* elf32-xtensa.c (ebb_propose_action): Fix argument order.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d1042 6
a1047 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.39
log
@	* elf32-xtensa.c (property_table_compare): Remove assertion about
	entries with the same address and non-zero size.
	(xtensa_read_table_entries): Report such entries as errors.
@
text
@d5602 1
a5603 1
		    enum ebb_target_enum align_type,
@


1.38
log
@	* elf32-xtensa.c (ebb_propose_action): Put declarations before
	statements.
@
text
@a525 6
      /* The only circumstance where two entries may legitimately have the
	 same address is when one of them is a zero-size placeholder to
	 mark a place where fill can be inserted.  The zero-size entry should
	 come first.  */
      BFD_ASSERT ((a->size == 0 || b->size == 0));

d582 1
a582 1
  int block_count;
d697 19
@


1.37
log
@bfd ChangeLog

	* elf32-xtensa.c (elf_xtensa_get_private_bfd_flags): Delete.
	(narrow_instruction, widen_instruction): Remove unnecessary calls to
	xtensa_format_encode.
	(ebb_propose_action): Inline call to ebb_add_proposed_action.
	(ebb_add_proposed_action): Delete.

gas ChangeLog

	* config/tc-xtensa.c (xtensa_frequency_pseudo): Use set_subseg_freq.
	(is_entry_opcode, is_movi_opcode, is_the_loop_opcode, is_jx_opcode,
	is_windowed_return_opcode): Delete.
	(xtensa_frob_label): Use get_subseg_target_freq.
	(md_assemble): Inline call to is_entry_opcode.
	(xtensa_handle_align): Inline call to get_frag_is_literal.
	(relaxation_requirements): Inline call to is_jx_opcode.
	(emit_single_op): Inline call to is_movi_opcode.
	(xg_assemble_vliw_tokens): Inline calls to get_frag_is_insn,
	get_frag_is_no_transform, is_entry_opcode, and
	set_frag_is_specific_opcode.  Use get_subseg_total_freq.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags,
	xtensa_fix_close_loop_end_frags, relax_frag_immed, convert_frag_immed):
	Inline calls to get_frag_is_no_transform.
	(next_instrs_are_b_retw): Inline call to is_windowed_return_opcode.
	(xtensa_fix_short_loop_frags): Inline calls to is_the_loop_opcode and
	get_frag_is_no_transform.
	(convert_frag_immed_finish_loop): Inline calls to get_expression_value
	and set_frag_is_no_transform.
	(get_expression_value): Delete.
	(subseg_map struct): Rename cur_total_freq to total_freq.  Rename
	cur_target_freq to target_freq.
	(get_subseg_info): Split out code to create a new map entry into ...
	(add_subseg_info): ... this new function.
	(get_last_insn_flags): Check if get_subseg_info succeeded.
	(set_last_insn_flags): Call add_subseg_info if needed.
	(get_subseg_total_freq, get_subseg_target_freq, set_subseg_freq): New.
	(xtensa_reorder_segments): Compute last_sec while counting sections.
	Remove call to get_last_sec.
	(get_last_sec): Delete.
	(cache_literal_section): Inline call to retrieve_literal_seg and its
	callees, seg_present and add_seg_list.
	(retrieve_literal_seg, seg_present, add_seg_list): Delete.
	(get_frag_is_insn, get_frag_is_no_transform,
	set_frag_is_specific_opcode, set_frag_is_no_transform): Delete.
	* config/tc-xtensa.h (MAX_SLOTS): Reduce from 31 to 15.
@
text
@d5601 1
d5604 1
a5604 1
      proposed_action *new_actions = (proposed_action *)
@


1.36
log
@bfd ChangeLog

	* elf32-xtensa.c: Use ISO C90 formatting.

gas ChangeLog

	* config/tc-xtensa.c: Use ISO C90 formatting.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.

ld ChangeLog

	* emultempl/xtensaelf.em: Use ISO C90 formatting.

opcodes ChangeLog

	* xtensa-dis.c: Use ISO C90 formatting.
@
text
@a39 2
extern flagword elf_xtensa_get_private_bfd_flags (bfd *);

a2767 7
extern flagword
elf_xtensa_get_private_bfd_flags (bfd *abfd)
{
  return elf_elfheader (abfd)->e_flags;
}


a3634 1
	  xtensa_format_encode (isa, o_fmt, o_slotbuf);
a3781 1
	  xtensa_format_encode (isa, o_fmt, o_slotbuf);
a5586 2
static void ebb_add_proposed_action (ebb_constraint *, proposed_action *);

d5596 1
a5596 9
  proposed_action paction;
  paction.align_type = align_type;
  paction.alignment_pow = alignment_pow;
  paction.action = action;
  paction.offset = offset;
  paction.removed_bytes = removed_bytes;
  paction.do_action = do_action;
  ebb_add_proposed_action (c, &paction);
}
a5597 5

static void
ebb_add_proposed_action (ebb_constraint *c, proposed_action *action)
{
  unsigned i;
d5600 3
a5602 1
      unsigned new_allocated = (c->action_count + 2) * 2;
d5613 9
a5621 1
  c->actions[c->action_count] = *action;
@


1.35
log
@bfd ChangeLog

	* elf32-xtensa.c (elf32xtensa_size_opt): New global variable.
	(xtensa_default_isa): Global variable moved here from xtensa-isa.c.
	(elf32xtensa_no_literal_movement): New global variable.
	(elf_howto_table): Add entries for new relocations.
	(elf_xtensa_reloc_type_lookup): Handle new relocations.
	(property_table_compare): When addresses are equal, compare sizes and
	various property flags.
	(property_table_matches): New.
	(xtensa_read_table_entries): Extend to read new property tables.  Add
	output_addr parameter to indicate that output addresses should be used.
	Use bfd_get_section_limit.
	(elf_xtensa_find_property_entry): New.
	(elf_xtensa_in_literal_pool): Use elf_xtensa_find_property_entry.
	(elf_xtensa_check_relocs): Handle new relocations.
	(elf_xtensa_do_reloc): Use bfd_get_section_limit.  Handle new
	relocations.  Use new xtensa-isa.h functions.
	(build_encoding_error_message): Remove encode_result parameter.  Add
	new target_address parameter used to detect alignment errors.
	(elf_xtensa_relocate_section): Use bfd_get_section_limit.  Clean up
	error handling.  Use new is_operand_relocation function.
	(elf_xtensa_combine_prop_entries, elf_xtensa_merge_private_bfd_data):
	Use underbar macro for error messages.  Formatting.
	(get_const16_opcode): New.
	(get_l32r_opcode): Add a separate flag for initialization.
	(get_relocation_opnd): Operand number is no longer explicit in the
	relocation.  Change to decode the opcode and analyze its operands.
	(get_relocation_slot): New.
	(get_relocation_opcode): Add bfd parameter.  Use bfd_get_section_limit.
	Use new xtensa-isa.h functions to handle multislot instructions.
	(is_l32r_relocation): Add bfd parameter.  Use is_operand_relocation.
	(get_asm_simplify_size, is_alt_relocation, is_operand_relocation,
	insn_decode_len, insn_decode_opcode, check_branch_target_aligned,
	check_loop_aligned, check_branch_target_aligned_address, narrowable,
	widenable, narrow_instruction, widen_instruction, op_single_fmt_table,
	get_single_format, init_op_single_format_table): New.
	(elf_xtensa_do_asm_simplify): Add error_message parameter and use it
	instead of calling _bfd_error_handler.  Use new xtensa-isa.h functions.
	(contract_asm_expansion): Add error_message parameter and pass it to
	elf_xtensa_do_asm_simplify.  Replace use of R_XTENSA_OP0 relocation
	with R_XTENSA_SLOT0_OP.
	(get_expanded_call_opcode): Extend to handle either L32R or CONST16
	instructions.  Use new xtensa-isa.h functions.
	(r_reloc struct): Add new virtual_offset field.
	(r_reloc_init): Add contents and content_length parameters.  Set
	virtual_offset field to zero.  Add contents to target_offset field for
	partial_inplace relocations.
	(r_reloc_is_defined): Check for null.
	(print_r_reloc): New debug function.
	(source_reloc struct): Replace xtensa_operand field with pair of the
	opcode and the operand position.  Add is_abs_literal field.
	(init_source_reloc): Specify operand by opcode/position pair.  Set
	is_abs_literal field.
	(source_reloc_compare): When target_offsets are equal, compare other
	fields to make sorting predictable.
	(literal_value struct): Add is_abs_literal field.
	(value_map_hash_table struct): Add has_last_loc and last_loc fields.
	(init_literal_value): New.
	(is_same_value): Replace with ...
	(literal_value_equal): ... this function.  Add comparisons of
	virtual_offset and is_abs_literal fields.
	(value_map_hash_table_init): Use bfd_zmalloc.  Check for allocation
	failure.  Initialize has_last_loc field.
	(value_map_hash_table_delete): New.
	(hash_literal_value): Rename to ...
	(literal_value_hash): ... this.  Include is_abs_literal flag and
	virtual_offset field in the hash value.
	(get_cached_value): Rename to ...
	(value_map_get_cached_value): ... this.  Update calls to
	literal_value_hash and literal_value_equal.
	(add_value_map): Check for allocation failure.  Update calls to
	value_map_get_cached_value and literal_value_hash.
	(text_action, text_action_list, text_action_t): New types.
	(find_fill_action, compute_removed_action_diff, adjust_fill_action,
	text_action_add, text_action_add_literal, offset_with_removed_text,
	offset_with_removed_text_before_fill, find_insn_action,
	print_action_list, print_removed_literals): New.
	(offset_with_removed_literals): Delete.
	(xtensa_relax_info struct): Add is_relaxable_asm_section, action_list,
	fix_array, fix_array_count, allocated_relocs, relocs_count, and
	allocated_relocs_count fields.
	(init_xtensa_relax_info): Initialize new fields.
	(reloc_bfd_fix struct): Add new translated field.
	(reloc_bfd_fix_init): Add translated parameter and use it to set the
	translated field.
	(fix_compare, cache_fix_array): New.
	(get_bfd_fix): Remove fix_list parameter and get all relax_info for the
	section via get_xtensa_relax_info.  Use cache_fix_array to set up
	sorted fix_array and use bsearch instead of linear search.
	(section_cache_t): New struct.
	(init_section_cache, section_cache_section, clear_section_cache): New.
	(ebb_t, ebb_target_enum, proposed_action, ebb_constraint): New types.
	(init_ebb_constraint, free_ebb_constraint, init_ebb, extend_ebb_bounds,
	extend_ebb_bounds_forward, extend_ebb_bounds_backward,
	insn_block_decodable_len, ebb_propose_action, ebb_add_proposed_action):
	New.
	(retrieve_contents): Use bfd_get_section_limit.
	(elf_xtensa_relax_section): Add relocations_analyzed flag.  Update call
	to compute_removed_literals.  Free value_map_hash_table when no longer
	needed.
	(analyze_relocations): Check is_relaxable_asm_section flag.  Call
	compute_text_actions for all sections.
	(find_relaxable_sections): Mark sections as relaxable if they contain
	ASM_EXPAND relocations that can be optimized.  Adjust r_reloc_init
	call.  Increment relax_info src_count field only for appropriate
	relocation types.  Remove is_literal_section check.
	(collect_source_relocs): Use bfd_get_section_limit.  Adjust calls to
	r_reloc_init and find_associated_l32r_irel.  Check
	is_relaxable_asm_section flag.  Handle L32R instructions with absolute
	literals.  Pass is_abs_literal flag to init_source_reloc.
	(is_resolvable_asm_expansion): Use bfd_get_section_limit.  Check for
	CONST16 instructions.  Adjust calls to r_reloc_init and
	pcrel_reloc_fits.  Handle weak symbols conservatively.
	(find_associated_l32r_irel): Add bfd parameter and pass it to
	is_l32r_relocation.
	(compute_text_actions, compute_ebb_proposed_actions,
	compute_ebb_actions, check_section_ebb_pcrels_fit,
	check_section_ebb_reduces, text_action_add_proposed,
	compute_fill_extra_space): New.
	(remove_literals): Replace with ...
	(compute_removed_literals): ... this function.  Call
	init_section_cache.  Use bfd_get_section_limit.  Sort internal_relocs.
	Call xtensa_read_table_entries to get the property table.  Skip
	relocations other than R_XTENSA_32 and R_XTENSA_PLT.  Use new
	is_removable_literal, remove_dead_literal, and
	identify_literal_placement functions.
	(get_irel_at_offset): Rewrite to use bsearch on sorted relocations
	instead of linear search.
	(is_removable_literal, remove_dead_literal,
	identify_literal_placement): New.
	(relocations_reach): Update check for literal not referenced by any
	PC-relative relocations.  Adjust call to pcrel_reloc_fits.
	(coalesce_shared_literal, move_shared_literal): New.
	(relax_section): Use bfd_get_section_limit.  Call
	translate_section_fixes.  Update calls to r_reloc_init and
	offset_with_removed_text.  Check new is_relaxable_asm_section flag.
	Add call to pin_internal_relocs.  Add special handling for
	R_XTENSA_ASM_SIMPLIFY and R_XTENSA_DIFF* relocs.  Use virtual_offset
	info to calculate new addend_displacement variable.  Replace code for
	deleting literals with more general code to perform the actions
	determined by the action_list for the section.
	(translate_section_fixes, translate_reloc_bfd_fix): New.
	(translate_reloc): Check new is_relaxable_asm_section flag.  Call
	find_removed_literal only if is_operand_relocation.  Update call to
	offset_with_removed_text.  Use new target_offset and removed_bytes
	variables.
	(move_literal): New.
	(relax_property_section):  Use bfd_get_section_limit.  Set new
	is_full_prop_section flag and handle new property tables.  Update calls
	to r_reloc_init and offset_with_removed_text.  Check
	is_relaxable_asm_section flag.  Handle expansion of zero-sized
	unreachable entries, with use of offset_with_removed_text_before_fill.
	For relocatable links, combine entries only for literal tables.
	(relax_section_symbols): Check is_relaxable_asm_section flag.  Update
	calls to offset_with_removed_text.  Translate st_size field for
	function symbols.
	(do_fix_for_relocatable_link): Change to return bfd_boolean to indicate
	failure.  Add contents parameter.  Update call to get_bfd_fix.  Update
	call to r_reloc_init.  Call _bfd_error_handler and return FALSE for
	R_XTENSA_ASM_EXPAND relocs.
	(do_fix_for_final_link): Add input_bfd and contents parameters.  Update
	call to get_bfd_fix.  Include offset from contents for partial_inplace
	relocations.
	(is_reloc_sym_weak): New.
	(pcrel_reloc_fits): Use new xtensa-isa.h functions.
	(prop_sec_len): New.
	(xtensa_is_property_section): Handle new property sections.
	(is_literal_section): Delete.
	(internal_reloc_compare): When r_offset matches, compare r_info and
	r_addend to make sorting predictable.
	(internal_reloc_matches): New.
	(xtensa_get_property_section_name): Handle new property sections.
	(xtensa_get_property_predef_flags): New.
	(xtensa_callback_required_dependence): Use bfd_get_section_limit.
	Update calls to xtensa_isa_init, is_l32r_relocation, and r_reloc_init.
	* xtensa-isa.c (xtensa_default_isa): Moved to elf32-xtensa.c.
	(xtisa_errno, xtisa_error_msg): New variables.
	(xtensa_isa_errno, xtensa_isa_error_msg): New.
	(xtensa_insnbuf_alloc): Add error handling.
	(xtensa_insnbuf_to_chars): Add num_chars parameter.  Update to
	use xtensa_format_decode.  Add error handling.
	(xtensa_insnbuf_from_chars): Add num_chars parameter.  Decode the
	instruction length to find the number of bytes to copy.
	(xtensa_isa_init): Add error handling.  Replace calls to
	xtensa_load_isa and xtensa_extend_isa with code to initialize lookup
	tables in the xtensa_modules structure.
	(xtensa_check_isa_config, xtensa_add_isa, xtensa_load_isa,
	xtensa_extend_isa): Delete.
	(xtensa_isa_free): Change to only free lookup tables.
	(opname_lookup_compare): Replace with ...
	(xtensa_isa_name_compare): ... this function.  Use strcasecmp.
	(xtensa_insn_maxlength): Rename to ...
	(xtensa_isa_maxlength): ... this.
	(xtensa_insn_length): Delete.
	(xtensa_insn_length_from_first_byte): Replace with ...
	(xtensa_isa_length_from_chars): ... this function.
	(xtensa_num_opcodes): Rename to ...
	(xtensa_isa_num_opcodes): ... this.
	(xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_regfiles, xtensa_isa_num_stages,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot): New functions.
	(xtensa_opcode_lookup): Add error handling.
	(xtensa_decode_insn): Replace with ...
	(xtensa_opcode_decode): ... this function, with new format and
	slot parameters.  Add error handling.
	(xtensa_encode_insn): Replace with ...
	(xtensa_opcode_encode): ... this function, which does the encoding via
	one of the entries in the "encode_fns" array.  Add error handling.
	(xtensa_opcode_name): Add error handling.
	(xtensa_opcode_is_branch, xtensa_opcode_is_jump, xtensa_opcode_is_loop,
	xtensa_opcode_is_call): New.
	(xtensa_num_operands): Replace with ...
	(xtensa_opcode_num_operands): ... this function.  Add error handling.
	(xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible): New.
	(xtensa_get_operand, xtensa_operand_kind): Delete.
	(xtensa_operand_inout): Add error handling and special-case for
	"sout" operands.
	(xtensa_operand_get_field, xtensa_operand_set_field): Rewritten to
	operate on one slot of an instruction.  Added error handling.
	(xtensa_operand_encode): Handle default operands with no encoding
	functions.  Check for success by comparing against decoded value.
	Add error handling.
	(xtensa_operand_decode): Handle default operands.  Return decoded value
	through argument pointer.  Add error handling.
	(xtensa_operand_is_register, xtensa_operand_regfile,
	xtensa_operand_num_regs, xtensa_operand_is_known_reg): New.
	(xtensa_operand_isPCRelative): Rename to ...
	(xtensa_operand_is_PCrelative): ... this.  Add error handling.
	(xtensa_operand_do_reloc, xtensa_operand_undo_reloc): Return value
	through argument pointer.  Add error handling.
	(xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New.
	* xtensa-modules.c: Rewrite to use new data structures.
	* reloc.c (BFD_RELOC_XTENSA_DIFF8, BFD_RELOC_XTENSA_DIFF16,
	BFD_RELOC_XTENSA_DIFF32, BFD_RELOC_XTENSA_SLOT0_OP,
	BFD_RELOC_XTENSA_SLOT1_OP, BFD_RELOC_XTENSA_SLOT2_OP,
	BFD_RELOC_XTENSA_SLOT3_OP, BFD_RELOC_XTENSA_SLOT4_OP,
	BFD_RELOC_XTENSA_SLOT5_OP, BFD_RELOC_XTENSA_SLOT6_OP,
	BFD_RELOC_XTENSA_SLOT7_OP, BFD_RELOC_XTENSA_SLOT8_OP,
	BFD_RELOC_XTENSA_SLOT9_OP, BFD_RELOC_XTENSA_SLOT10_OP,
	BFD_RELOC_XTENSA_SLOT11_OP, BFD_RELOC_XTENSA_SLOT12_OP,
	BFD_RELOC_XTENSA_SLOT13_OP, BFD_RELOC_XTENSA_SLOT14_OP,
	BFD_RELOC_XTENSA_SLOT0_ALT, BFD_RELOC_XTENSA_SLOT1_ALT,
	BFD_RELOC_XTENSA_SLOT2_ALT, BFD_RELOC_XTENSA_SLOT3_ALT,
	BFD_RELOC_XTENSA_SLOT4_ALT, BFD_RELOC_XTENSA_SLOT5_ALT,
	BFD_RELOC_XTENSA_SLOT6_ALT, BFD_RELOC_XTENSA_SLOT7_ALT,
	BFD_RELOC_XTENSA_SLOT8_ALT, BFD_RELOC_XTENSA_SLOT9_ALT,
	BFD_RELOC_XTENSA_SLOT10_ALT, BFD_RELOC_XTENSA_SLOT11_ALT,
	BFD_RELOC_XTENSA_SLOT12_ALT, BFD_RELOC_XTENSA_SLOT13_ALT,
	BFD_RELOC_XTENSA_SLOT14_ALT): Add new relocations.
	* Makefile.am (xtensa-isa.lo, xtensa-modules.lo): Update dependencies.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Likewise.
	* libbfd.h: Likewise.

gas ChangeLog

	* config/tc-xtensa.c (absolute_literals_supported): New global flag.
	(UNREACHABLE_MAX_WIDTH): Define.
	(XTENSA_FETCH_WIDTH): Delete.
	(cur_vinsn, xtensa_fetch_width, xt_saved_debug_type, past_xtensa_end,
	prefer_const16, prefer_l32r): New global variables.
	(LIT4_SECTION_NAME): Define.
	(lit4_state struct): Add lit4_seg_name and lit4_seg fields.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.
	(frag_flags struct): New.
	(xtensa_block_info struct): Move from tc-xtensa.h.  Add flags field.
	(subseg_map struct): Add cur_total_freq and cur_target_freq fields.
	(bitfield, bit_is_set, set_bit, clear_bit): Define.
	(MAX_FORMATS): Define.
	(op_placement_info struct, op_placement_table): New.
	(O_pltrel, O_hi16, O_lo16): Define.
	(directiveE enum): Rename directive_generics to directive_transform.
	Delete directive_relax.  Add directive_schedule,
	directive_absolute_literals, and directive_last_directive.
	(directive_info): Rename "generics" to "transform".  Delete "relax".
	Add "schedule" and "absolute-literals".
	(directive_state): Adjust entries to match changes in directive_info.
	(xtensa_relax_statesE, RELAX_IMMED_MAXSTEPS): Move to tc-xtensa.h.
	(xtensa_const16_opcode, xtensa_movi_opcode, xtensa_movi_n_opcode,
	xtensa_l32r_opcode, xtensa_nop_opcode, xtensa_rsr_lcount_opcode): New.
	(xtensa_j_opcode, xtensa_rsr_opcode): Delete.
	(align_only_targets, software_a0_b_retw_interlock,
	software_avoid_b_j_loop_end, maybe_has_b_j_loop_end,
	software_avoid_short_loop, software_avoid_close_loop_end,
	software_avoid_all_short_loops, specific_opcode): Delete.
	(warn_unaligned_branch_targets): New.
	(workaround_a0_b_retw, workaround_b_j_loop_end, workaround_short_loop,
	workaround_close_loop_end, workaround_all_short_loops): Default FALSE.
	(option_[no_]link_relax, option_[no_]transform,
	option_[no_]absolute_literals, option_warn_unaligned_targets,
	option_prefer_l32r, option_prefer_const16, option_target_hardware):
	New enum values.
	(option_[no_]align_only_targets, option_literal_section_name,
	option_text_section_name, option_data_section_name,
	option_bss_section_name, option_eb, option_el): Delete.
	(md_longopts): Add entries for: [no-]transform, [no-]absolute-literals,
	warn-unaligned-targets, prefer-l32r, prefer-const16, [no-]link-relax,
	and target-hardware.  Delete entries for [no-]target-align-only,
	literal-section-name, text-section-name, data-section-name, and
	bss-section-name.
	(md_parse_option): Handle new options and remove old ones.  Accept but
	ignore [no-]density options.  Warn for [no-]generics and [no-]relax
	and treat them as [no-]transform.
	(md_show_usage): Add new options and remove old ones.
	(xtensa_setup_hw_workarounds): New.
	(md_pseudo_table): Change "word" entry to use xtensa_elf_cons.  Add
	"long", "short", "loc" and "frequency" entries.
	(use_generics): Rename to ...
	(use_transform): ... this function.  Add past_xtensa_end check.
	(use_longcalls): Add past_xtensa_end check.
	(code_density_available, can_relax): Delete.
	(do_align_targets): New.
	(get_directive): Accept dashes in directive names.  Warn about
	[no-]generics and [no-]relax directives and treat them as
	[no-]transform.
	(xtensa_begin_directive): Call md_flush_pending_output only for some
	directives.  Check for directives inside instruction bundles.  Warn
	about deprecated ".begin literal" usage.  Warn and ignore [no-]density
	directives.  Handle new directives.  Check generating_literals flag
	for literal_prefix.
	(xtensa_end_directive): Check for directives inside instruction
	bundles.  Warn and ignore [no-]density directives.  Handle new
	directives.  Call xtensa_set_frag_assembly_state.
	(xtensa_loc_directive_seen, xtensa_dwarf2_directive_loc,
	xtensa_dwarf2_emit_insn): New.
	(xtensa_literal_position): Call md_flush_pending_output.  Do not check
	use_literal_section flag.
	(xtensa_literal_pseudo): Call md_flush_pending_output.  Handle absolute
	literals.  Use xtensa_elf_cons to parse the expression.
	(xtensa_literal_prefix): Do not check use_literal_section.  Support
	".lit4" sections for absolute literals.  Change prefix convention to
	replace ".text" (or ".t" in a linkonce section).  No need to call
	subseg_set.
	(xtensa_frequency_pseudo, xtensa_elf_cons, xtensa_elf_suffix): New.
	(expression_end): Handle closing braces and colons.
	(PLT_SUFFIX, plt_suffix): Delete.
	(expression_maybe_register): Use new xtensa-isa.h functions.  Use
	xtensa_elf_suffix instead of checking for plt suffix, and handle O_lo16
	and O_hi16 expressions as well.
	(tokenize_arguments): Handle closing braces and colons.
	(parse_arguments): Use new xtensa-isa.h functions.  Handle "invisible"
	operands and paired register syntax.
	(get_invisible_operands): New.
	(xg_translate_sysreg_op): Handle new Xtensa LX RSR/WSR/XSR syntax.  Use
	new xtensa-isa.h functions.
	(xtensa_translate_old_userreg_ops, xtensa_translate_zero_immed): New.
	(xg_translate_idioms): Check if inside bundle.  Use use_transform.
	Handle new Xtensa LX RSR/WSR/XSR syntax.  Remove code to widen density
	instructions.  Use xtensa_translate_zero_immed.
	(operand_is_immed, operand_is_pcrel_label): Delete.
	(get_relaxable_immed): Use new xtensa-isa.h functions.
	(get_opcode_from_buf): Add slot parameter.  Use new xtensa-isa.h
	functions.
	(xtensa_print_insn_table, print_vliw_insn): New.
	(is_direct_call_opcode): Use new xtensa-isa.h functions.
	(is_call_opcode, is_loop_opcode, is_conditional_branch_opcode,
	is_branch_or_jump_opcode): Delete.
	(is_movi_opcode, decode_reloc, encode_reloc, encode_alt_reloc): New.
	(opnum_to_reloc, reloc_to_opnum): Delete.
	(xtensa_insnbuf_set_operand, xtensa_insnbuf_get_operand): Use new
	xtensa-isa.h functions.  Operate on one slot of an instruction.
	(xtensa_insnbuf_set_immediate_field, is_negatable_branch,
	xg_get_insn_size): Delete.
	(xg_get_build_instr_size): Use xg_get_single_size.
	(xg_is_narrow_insn, xg_is_single_relaxable_insn): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_get_max_narrow_insn_size): Delete.
	(xg_get_max_insn_widen_size, xg_get_max_insn_widen_literal_size,
	xg_is_relaxable_insn): Update calls to xg_build_widen_table.  Use
	xg_get_single_size.
	(xg_build_to_insn): Record the loc field.  Handle OP_OPERAND_HI16U and
	OP_OPERAND_LOW16U.  Check xg_valid_literal_expression.
	(xg_expand_to_stack, xg_expand_narrow): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_immeds_fit): Use new xtensa-isa.h functions.  Update call to
	xg_check_operand.
	(xg_symbolic_immeds_fit): Likewise.  Also handle O_lo16 and O_hi16, and
	treat weak symbols conservatively.
	(xg_check_operand): Use new xtensa-isa.h functions.
	(is_dnrange): Delete.
	(xg_assembly_relax): Inline previous calls to tinsn_copy.
	(xg_finish_frag): Specify separate relax states for the frag and slot0.
	(is_branch_jmp_to_next, xg_add_branch_and_loop_targets): Use new
	xtensa-isa.h functions.
	(xg_instruction_matches_option_term, xg_instruction_matches_or_options,
	xg_instruction_matches_options): New.
	(xg_instruction_matches_rule): Handle O_register expressions.  Call
	xg_instruction_matches_options.
	(transition_rule_cmp): New.
	(xg_instruction_match): Update call to xg_build_simplify_table.
	(xg_build_token_insn): Record loc fields.
	(xg_simplify_insn): Check is_specific_opcode field and
	density_supported flag.
	(xg_expand_assembly_insn): Skip checking code_density_available.  Use
	new xtensa-isa.h functions.  Call use_transform instead of can_relax.
	(xg_assemble_literal): Add error handling for O_big.  Call
	record_alignment.  Handle O_pltrel.
	(xg_valid_literal_expression): New.
	(xg_assemble_literal_space): Add slot parameter.  Remove call to
	set_expr_symbol_offset.  Add call to record_alignment.  Update call to
	xg_finish_frag.
	(xg_emit_insn): Delete.
	(xg_emit_insn_to_buf): Add format parameter.  Update calls to
	xg_add_opcode_fix and xtensa_insnbuf_to_chars.
	(xg_add_opcode_fix): Change opcode parameter to tinsn and add format
	and slot parameters.  Handle new "alternate" relocations for absolute
	literals and CONST16 instructions.  Check for bad uses of O_lo16 and
	O_hi16.  Use new xtensa-isa.h functions.
	(xg_assemble_tokens): Delete.
	(is_register_writer): Use new xtensa-isa.h functions.
	(is_bad_loopend_opcode): Check for xtensa_rsr_lcount_opcode instead of
	old-style RSR from LCOUNT.
	(next_frag_opcode): Delete.
	(next_frag_opcode_is_loop, next_frag_format_size, frag_format_size,
	update_next_frag_state): New.
	(update_next_frag_nop_state): Delete.
	(next_frag_pre_opcode_bytes): Use next_frag_opcode_is_loop.
	(xtensa_mark_literal_pool_location): Check use_literal_section flag and
	the state of the absolute-literals directive.  Add calls to
	record_alignment and xtensa_set_frag_assembly_state.  Call
	xtensa_switch_to_non_abs_literal_fragment instead of
	xtensa_switch_to_literal_fragment.
	(build_nop): New.
	(assemble_nop): Use build_nop.  Update call to xtensa_insnbuf_to_chars.
	(get_expanded_loop_offset): Change check for undefined opcode to an
	assertion.
	(xtensa_set_frag_assembly_state, relaxable_section,
	xtensa_find_unmarked_state_frags, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_apply_tentative_value): New.
	(md_begin): Update call to xtensa_isa_init.  Initialize linkrelax to 1.
	Set lit4_seg_name.  Call xg_init_vinsn.  Initialize new global opcodes.
	Call init_op_placement_info_table and xtensa_set_frag_assembly_state.
	(xtensa_init_fix_data): New.
	(xtensa_frob_label): Reset label symbol to the current frag.  Check
	do_align_targets and generating_literals flag.  Propagate frequency
	info to new alignment frag.  Call xtensa_set_frag_assembly_state.
	(xtensa_unrecognized_line): New.
	(xtensa_flush_pending_output): Check if inside a bundle.  Add a call
	to xtensa_set_frag_assembly_state.
	(error_reset_cur_vinsn): New.
	(md_assemble): Remove check for literal frag.  Remove call to
	istack_init.  Call use_transform instead of use_generics.  Parse
	explicit instruction format specifiers.  Move code for
	a0_b_retw_interlock workaround to xg_assemble_vliw_tokens.  Call
	error_reset_cur_vinsn on errors.  Add call to get_invisible_operands.
	Add dwarf2_where call.  Remote automatic alignment for ENTRY
	instructions.  Move call to xtensa_clear_insn_labels to the end.
	Rearrange to handle bundles.
	(xtensa_cons_fix_new): Delete.
	(xtensa_handle_align): New.
	(xtensa_frag_init): Call xtensa_set_frag_assembly_state.  Remove
	assignment to is_no_density field.
	(md_pcrel_from): Use new xtensa-isa.h functions.  Use decode_reloc
	instead of reloc_to_opnum.  Handle "alternate" relocations.
	(xtensa_force_relocation, xtensa_check_inside_bundle,
	xtensa_elf_section_change_hook): New.
	(xtensa_symbol_new_hook): Delete.
	(xtensa_fix_adjustable): Check for difference of symbols with an
	offset.  Check for external and weak symbols.
	(md_apply_fix3): Remove cases for XTENSA_OP{0,1,2} relocs.
	(md_estimate_size_before_relax): Return expansion for the first slot.
	(tc_gen_reloc): Handle difference of symbols by producing
	XTENSA_DIFF{8,16,32} relocs and by writing the value of the difference
	into the output.  Handle new XTENSA_SLOT*_OP relocs by storing the
	tentative values into the output when linkrelax is set.
	(XTENSA_PROP_SEC_NAME): Define.
	(xtensa_post_relax_hook): Call xtensa_find_unmarked_state_frags.
	Create literal tables only if using literal sections.  Create new
	property tables instead of old instruction tables.  Check for unaligned
	branch targets and loops.
	(finish_vinsn, find_vinsn_conflicts, check_t1_t2_reads_and_writes,
	new_resource_table, clear_resource_table, resize_resource_table,
	resources_available, reserve_resources, release_resources,
	opcode_funcUnit_use_unit, opcode_funcUnit_use_stage,
	resources_conflict, xg_find_narrowest_format, relaxation_requirements,
	bundle_single_op, emit_single_op, xg_assemble_vliw_tokens): New.
	(xtensa_end): Call xtensa_flush_pending_output.  Set past_xtensa_end
	flag.  Update checks for workaround options.  Call
	xtensa_mark_narrow_branches and xtensa_mark_zcl_first_insns.
	(xtensa_cleanup_align_frags): Add special case for branch targets.
	Check for and mark unreachable frags.
	(xtensa_fix_target_frags): Remove use of align_only_targets flag.
	Use RELAX_LOOP_END_BYTES in special case for negatable branch at the
	end of a zero-overhead loop body.
	(frag_can_negate_branch): Handle instructions with multiple slots.
	Use new xtensa-isa.h functions
	(xtensa_mark_narrow_branches, is_narrow_branch_guaranteed_in_range,
	xtensa_mark_zcl_first_insns): New.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags): Error if
	transformations are disabled.
	(next_instrs_are_b_retw): Use new xtensa-isa.h functions.  Handle
	multislot instructions.
	(xtensa_fix_close_loop_end_frags, xtensa_fix_short_loop_frags):
	Likewise.  Also error if transformations are disabled.
	(unrelaxed_frag_max_size): New.
	(unrelaxed_frag_min_insn_count, unrelax_frag_has_b_j): Use new
	xtensa-isa.h functions.
	(xtensa_sanity_check, is_empty_loop, is_local_forward_loop): Use
	xtensa_opcode_is_loop instead of is_loop_opcode.
	(get_text_align_power): Replace as_fatal with assertion.
	(get_text_align_fill_size): Iterate instead of using modulus when
	use_nops is false.
	(get_noop_aligned_address): Assert that this is for a machine-dependent
	RELAX_ALIGN_NEXT_OPCODE frag.  Use next_frag_opcode_is_loop,
	xg_get_single_size, and frag_format_size.
	(get_widen_aligned_address): Rename to ...
	(get_aligned_diff): ... this function.  Add max_diff parameter.
	Remove handling of rs_align/rs_align_code frags.  Use
	next_frag_format_size, get_text_align_power, get_text_align_fill_size,
	next_frag_opcode_is_loop, and xg_get_single_size.  Compute max_diff
	and pass it back to caller.
	(xtensa_relax_frag): Use relax_frag_loop_align.  Add code for new
	RELAX_SLOTS, RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN,
	RELAX_FILL_NOP, and RELAX_UNREACHABLE frag types.  Check relax_seen.
	(relax_frag_text_align): Rename to ...
	(relax_frag_loop_align): ... this function.  Assume loops can only be
	in the first slot of an instruction.
	(relax_frag_add_nop): Use assemble_nop instead of constructing an OR
	instruction.  Remove call to frag_wane.
	(relax_frag_narrow): Rename to ...
	(relax_frag_for_align): ... this function.  Extend to handle
	RELAX_FILL_NOP and RELAX_UNREACHABLE, as well as RELAX_SLOTS with
	RELAX_NARROW for the first slot.
	(find_address_of_next_align_frag, bytes_to_stretch): New.
	(future_alignment_required): Use find_address_of_next_align_frag and
	bytes_to_stretch.  Look ahead to subsequent frags to make smarter
	alignment decisions.
	(relax_frag_immed): Add format, slot, and estimate_only parameters.
	Check if transformations are enabled for b_j_loop_end workaround.
	Use new xtensa-isa.h functions and handle multislot instructions.
	Update call to xg_assembly_relax.
	(md_convert_frag): Handle new RELAX_SLOTS, RELAX_UNREACHABLE,
	RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN, and RELAX_FILL_NOP
	frag types.
	(convert_frag_narrow): Add segP, format and slot parameters.  Call
	convert_frag_immed for branch instructions.  Adjust calls to
	tinsn_from_chars, tinsn_immed_from_frag, and xg_emit_insn_to_buf.  Use
	xg_get_single_size and xg_get_single_format.
	(convert_frag_fill_nop): New.
	(convert_frag_immed): Add format and slot parameters.  Handle multislot
	instructions and use new xtensa-isa.h functions.  Update calls to
	tinsn_immed_from_frag and xg_assembly_relax.  Check if transformations
	enabled for b_j_loop_end workaround.  Use build_nop instead of
	assemble_nop.  Check is_specific_opcode flag.  Check for unreachable
	frags.  Use xg_get_single_size.  Handle O_pltrel.
	(fix_new_exp_in_seg): Remove check for old plt flag.
	(convert_frag_immed_finish_loop): Update calls to tinsn_from_chars and
	xtensa_insnbuf_to_chars.  Call tinsn_immed_from_frag.  Change check
	for loop opcode to an assertion.  Mark all frags up to the end of the
	loop as not transformable.
	(get_last_insn_flags, set_last_insn_flags): Use get_subseg_info.
	(get_subseg_info): New.
	(xtensa_move_literals): Call xtensa_set_frag_assembly_state.  Add null
	check for dest_seg.
	(xtensa_switch_to_literal_fragment): Rewrite to handle absolute
	literals and use xtensa_switch_to_non_abs_literal_fragment otherwise.
	(xtensa_switch_to_non_abs_literal_fragment): New.
	(cache_literal_section): Add is_code parameter and pass it through to
	retrieve_literal_seg.
	(retrieve_literal_seg): Add is_code parameter and use it to set the
	flags on the literal section.  Handle case where head parameter is 0.
	(get_frag_is_no_transform, set_frag_is_specific_opcode,
	set_frag_is_no_transform): New.
	(xtensa_create_property_segments): Add end_property_function parameter
	and pass it through to add_xt_block_frags.  Call bfd_get_section_flags
	and skip SEC_DEBUGGING and !SEC_ALLOC sections.
	(xtensa_create_xproperty_segments, section_has_xproperty): New.
	(add_xt_block_frags): Add end_property_function parameter and call it
	if it is non-zero.  Call xtensa_frag_flags_init.
	(xtensa_frag_flags_is_empty, xtensa_frag_flags_init,
	get_frag_property_flags, frag_flags_to_number,
	xtensa_frag_flags_combinable, xt_block_aligned_size,
	xtensa_xt_block_combine, add_xt_prop_frags,
	init_op_placement_info_table, opcode_fits_format_slot,
	xg_get_single_size, xg_get_single_format): New.
	(istack_push): Inline call to tinsn_copy.
	(tinsn_copy): Delete.
	(tinsn_has_invalid_symbolic_operands): Handle O_hi16 and O_lo16 and
	CONST16 opcodes.  Handle O_big, O_illegal, and O_absent.
	(tinsn_has_complex_operands): Handle O_hi16 and O_lo16.
	(tinsn_to_insnbuf): Use xg_get_single_format and new xtensa-isa.h
	functions.  Handle invisible operands.
	(tinsn_to_slotbuf): New.
	(tinsn_check_arguments): Use new xtensa-isa.h functions.
	(tinsn_from_chars): Add slot parameter.  Rewrite using xg_init_vinsn,
	vinsn_from_chars, and xg_free_vinsn.
	(tinsn_from_insnbuf): New.
	(tinsn_immed_from_frag): Add slot parameter and handle multislot
	instructions.  Handle symbol differences.
	(get_num_stack_text_bytes): Use xg_get_single_size.
	(xg_init_vinsn, xg_clear_vinsn, vinsn_has_specific_opcodes,
	xg_free_vinsn, vinsn_to_insnbuf, vinsn_from_chars, expr_is_register,
	get_expr_register, set_expr_symbol_offset_diff): New.
	* config/tc-xtensa.h (MAX_SLOTS): Define.
	(xtensa_relax_statesE): Move from tc-xtensa.c. Add
	RELAX_CHECK_ALIGN_NEXT_OPCODE, RELAX_MAYBE_DESIRE_ALIGN, RELAX_SLOTS,
	RELAX_FILL_NOP, RELAX_UNREACHABLE, RELAX_MAYBE_UNREACHABLE, and
	RELAX_NONE types.
	(RELAX_IMMED_MAXSTEPS): Move from tc-xtensa.c.
	(xtensa_frag_type struct): Add is_assembly_state_set,
	use_absolute_literals, relax_seen, is_unreachable, is_specific_opcode,
	is_align, is_text_align, alignment, and is_first_loop_insn fields.
	Replace is_generics and is_relax fields by is_no_transform field.
	Delete is_text and is_longcalls fields.  Change text_expansion and
	literal_expansion to arrays of MAX_SLOTS entries.  Add arrays of
	per-slot information: literal_frags, slot_subtypes, slot_symbols,
	slot_sub_symbols, and slot_offsets.  Add fr_prev field.
	(xtensa_fix_data struct): New.
	(xtensa_symfield_type struct): Delete plt field.
	(xtensa_block_info struct): Move definition to tc-xtensa.h.  Add
	forward declaration here.
	(xt_section_type enum): Delete xt_insn_sec.  Add xt_prop_sec.
	(XTENSA_SECTION_RENAME): Undefine.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA, TC_FORCE_RELOCATION, NO_PSEUDO_DOT,
	tc_unrecognized_line, md_do_align, md_elf_section_change_hook,
	HANDLE_ALIGN, TC_LINKRELAX_FIXUP, SUB_SEGMENT_ALIGN): Define.
	(TC_CONS_FIX_NEW, tc_symbol_new_hook): Delete.
	(unit_num_copies_func, opcode_num_units_func,
	opcode_funcUnit_use_unit_func, opcode_funcUnit_use_stage_func): New.
	(resource_table struct): New.
	* config/xtensa-istack.h (MAX_INSN_ARGS): Increase from 6 to 10.
	(TInsn struct): Add keep_wide, loc, fixup, record_fix, subtype,
	literal_space, symbol, sub_symbol, offset, and literal_frag fields.
	(tinsn_copy): Delete prototype.
	(vliw_insn struct): New.
	* config/xtensa-relax.c (insn_pattern_struct): Add options field.
	(widen_spec_list): Add option conditions for density and boolean
	instructions.  Add expansions using CONST16 and conditions for using
	CONST16 vs. L32R.  Use new Xtensa LX RSR/WSR syntax.  Add entries for
	predicted branches.
	(simplify_spec_list): Add option conditions for density instructions.
	Add entry for NOP instruction.
	(append_transition): Add cmp function pointer parameter and use it to
	insert the new entry in order.
	(operand_function_LOW16U, operand_function_HI16U): New.
	(xg_has_userdef_op_fn, xg_apply_userdef_op_fn): Handle
	OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(enter_opname, split_string): Use xstrdup instead of strdup.
	(init_insn_pattern): Initialize new options field.
	(clear_req_or_option_list, clear_req_option_list,
	clone_req_or_option_list, clone_req_option_list, parse_option_cond):
	New.
	(parse_insn_pattern): Parse option conditions.
	(transition_applies): New.
	(build_transition): Use new xtensa-isa.h functions.  Fix incorrectly
	swapped last arguments in calls to append_constant_value_condition.
	Call clone_req_option_list.  Add warning about invalid opcode.
	Handle LOW16U and HI16U function names.
	(build_transition_table): Add cmp parameter and use it in calls to
	append_transition.  Use new xtensa-isa.h functions.  Check
	transition_applies before adding entries.
	(xg_build_widen_table, xg_build_simplify_table): Add cmp parameter and
	pass it through to build_transition_table.
	* config/xtensa-relax.h (ReqOrOptionList, ReqOrOption, ReqOptionList,
	ReqOption, transition_cmp_fn): New types.
	(OpType enum): Add OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(transition_rule struct): Add options field.
	* doc/as.texinfo (Overview): Update Xtensa options.
	* doc/c-xtensa.texi (Xtensa Options): Delete --[no-]density,
	--[no-]relax, and --[no-]generics options.  Update descriptions of
	--text-section-literals and --[no-]longcalls.  Add
	--[no-]absolute-literals and --[no-]transform.
	(Xtensa Syntax): Add description of syntax for FLIX instructions.
	Remove use of "generic" and "specific" terminology for opcodes.
	(Xtensa Registers): Generalize the syntax description to include
	user-defined register files.
	(Xtensa Automatic Alignment): Update.
	(Xtensa Branch Relaxation): Mention limitation of unconditional jumps.
	(Xtensa Call Relaxation): Linker can now remove most of the overhead.
	(Xtensa Directives): Remove confusing rules about precedence.
	(Density Directive, Relax Directive): Delete.
	(Schedule Directive): New.
	(Generics Directive): Rename to ...
	(Transform Directive): ... this node.
	(Literal Directive): Update for absolute literals.  Missing
	literal_position directive is now an error.
	(Literal Position Directive): Update for absolute literals.
	(Freeregs Directive): Delete.
	(Absolute Literals Directive): New.
	(Frame Directive): Minor editing.
	* Makefile.am (DEPTC_xtensa_elf, DEPOBJ_xtensa_elf, DEP_xtensa_elf):
	Update dependencies.
	* Makefile.in: Regenerate.

gas/testsuite ChangeLog

	* gas/xtensa/all.exp: Adjust expected error message for j_too_far.
	Change entry_align test to expect an error.
	* gas/xtensa/entry_misalign2.s: Use no-transform instead of
	no-generics directives.

include ChangeLog

	* xtensa-config.h (XSHAL_USE_ABSOLUTE_LITERALS,
	XCHAL_HAVE_PREDICTED_BRANCHES, XCHAL_INST_FETCH_WIDTH): New.
	(XCHAL_EXTRA_SA_SIZE, XCHAL_EXTRA_SA_ALIGN): Delete.
	* xtensa-isa-internal.h (ISA_INTERFACE_VERSION): Delete.
	(config_sturct struct): Delete.
	(XTENSA_OPERAND_IS_REGISTER, XTENSA_OPERAND_IS_PCRELATIVE,
	XTENSA_OPERAND_IS_INVISIBLE, XTENSA_OPERAND_IS_UNKNOWN,
	XTENSA_OPCODE_IS_BRANCH, XTENSA_OPCODE_IS_JUMP,
	XTENSA_OPCODE_IS_LOOP, XTENSA_OPCODE_IS_CALL,
	XTENSA_STATE_IS_EXPORTED, XTENSA_INTERFACE_HAS_SIDE_EFFECT): Define.
	(xtensa_format_encode_fn, xtensa_get_slot_fn, xtensa_set_slot_fn): New.
	(xtensa_insn_decode_fn): Rename to ...
	(xtensa_opcode_decode_fn): ... this.
	(xtensa_immed_decode_fn, xtensa_immed_encode_fn, xtensa_do_reloc_fn,
	xtensa_undo_reloc_fn): Update.
	(xtensa_encoding_template_fn): Delete.
	(xtensa_opcode_encode_fn, xtensa_format_decode_fn,
	xtensa_length_decode_fn): New.
	(xtensa_format_internal, xtensa_slot_internal): New types.
	(xtensa_operand_internal): Delete operand_kind, inout, isPCRelative,
	get_field, and set_field fields.  Add name, field_id, regfile,
	num_regs, and flags fields.
	(xtensa_arg_internal): New type.
	(xtensa_iclass_internal): Change operands field to array of
	xtensa_arg_internal.  Add num_stateOperands, stateOperands,
	num_interfaceOperands, and interfaceOperands fields.
	(xtensa_opcode_internal): Delete length, template, and iclass fields.
	Add iclass_id, flags, encode_fns, num_funcUnit_uses, and funcUnit_uses.
	(opname_lookup_entry): Delete.
	(xtensa_regfile_internal, xtensa_interface_internal,
	xtensa_funcUnit_internal, xtensa_state_internal,
	xtensa_sysreg_internal, xtensa_lookup_entry): New.
	(xtensa_isa_internal): Replace opcode_table field with opcodes field.
	Change type of opname_lookup_table.  Delete num_modules,
	module_opcode_base, module_decode_fn, config, and has_density fields.
	Add num_formats, formats, format_decode_fn, length_decode_fn,
	num_slots, slots, num_fields, num_operands, operands, num_iclasses,
	iclasses, num_regfiles, regfiles, num_states, states,
	state_lookup_table, num_sysregs, sysregs, sysreg_lookup_table,
	max_sysreg_num, sysreg_table, num_interfaces, interfaces,
	interface_lookup_table, num_funcUnits, funcUnits and
	funcUnit_lookup_table fields.
	(xtensa_isa_module, xtensa_isa_modules): Delete.
	(xtensa_isa_name_compare): New prototype.
	(xtisa_errno, xtisa_error_msg): New.
	* xtensa-isa.h (XTENSA_ISA_VERSION): Define.
	(xtensa_isa): Change type.
	(xtensa_operand): Delete.
	(xtensa_format, xtensa_regfile, xtensa_state, xtensa_sysreg,
	xtensa_interface, xtensa_funcUnit, xtensa_isa_status,
	xtensa_funcUnit_use): New types.
	(libisa_module_specifier): Delete.
	(xtensa_isa_errno, xtensa_isa_error_msg): New prototypes.
	(xtensa_insnbuf_free, xtensa_insnbuf_to_chars,
	xtensa_insnbuf_from_chars): Update prototypes.
	(xtensa_load_isa, xtensa_extend_isa, xtensa_default_isa,
	xtensa_insn_maxlength, xtensa_num_opcodes, xtensa_decode_insn,
	xtensa_encode_insn, xtensa_insn_length,
	xtensa_insn_length_from_first_byte, xtensa_num_operands,
	xtensa_operand_kind, xtensa_encode_result,
	xtensa_operand_isPCRelative): Delete.
	(xtensa_isa_init, xtensa_operand_inout, xtensa_operand_get_field,
	xtensa_operand_set_field, xtensa_operand_encode,
	xtensa_operand_decode, xtensa_operand_do_reloc,
	xtensa_operand_undo_reloc): Update prototypes.
	(xtensa_isa_maxlength, xtensa_isa_length_from_chars,
	xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_opcodes, xtensa_isa_num_regfiles, xtensa_isa_num_states,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot, xtensa_opcode_decode,
	xtensa_opcode_encode, xtensa_opcode_is_branch, xtensa_opcode_is_jump,
	xtensa_opcode_is_loop, xtensa_opcode_is_call,
	xtensa_opcode_num_operands, xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible, xtensa_operand_is_register,
	xtensa_operand_regfile, xtensa_operand_num_regs,
	xtensa_operand_is_known_reg, xtensa_operand_is_PCrelative,
	xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New prototypes.
	* elf/xtensa.h (R_XTENSA_DIFF8, R_XTENSA_DIFF16, R_XTENSA_DIFF32,
	R_XTENSA_SLOT*_OP, R_XTENSA_SLOT*_ALT): New relocations.
	(XTENSA_PROP_SEC_NAME): Define.
	(property_table_entry): Add flags field.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.

ld ChangeLog

	* ld.texinfo (Xtensa): Describe new linker relaxation to optimize
	assembler-generated longcall sequences.  Describe new --size-opt
	option.
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): Add .xt.prop section.
	* emultempl/xtensaelf.em (remove_section,
	replace_insn_sec_with_prop_sec, replace_instruction_table_sections,
	elf_xtensa_after_open): New.
	(OPTION_OPT_SIZEOPT, OPTION_LITERAL_MOVEMENT,
	OPTION_NO_LITERAL_MOVEMENT): Define.
	(elf32xtensa_size_opt, elf32xtensa_no_literal_movement): New globals.
	(PARSE_AND_LIST_LONGOPTS): Add size-opt and [no-]literal-movement.
	(PARSE_AND_LIST_OPTIONS): Add --size-opt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_OPT_SIZEOPT,
	OPTION_LITERAL_MOVEMENT, and OPTION_NO_LITERAL_MOVEMENT.
	(LDEMUL_AFTER_OPEN): Set to elf_xtensa_after_open.
	* scripttempl/elfxtensa.sc: Update with changes from elf.sc.
	* Makefile.am (eelf32xtensa.c): Update dependencies.
	* Makefile.in: Regenerate.

ld/testsuite ChangeLog

	* ld-xtensa/lcall1.s: Use .literal directive.
	* ld-xtensa/lcall2.s: Align function entry.
	* ld-xtensa/coalesce2.s: Likewise.

opcodes ChangeLog

	* xtensa-dis.c (state_names): Delete.
	(fetch_data): Use xtensa_isa_maxlength.
	(print_xtensa_operand): Replace operand parameter with opcode/operand
	pair.  Remove print_sr_name parameter.  Use new xtensa-isa.h functions.
	(print_insn_xtensa): Use new xtensa-isa.h functions.  Handle multislot
	instruction bundles.  Use xmalloc instead of malloc.
@
text
@d40 1
a40 62
/* Main interface functions.  */
static void elf_xtensa_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static reloc_howto_type *elf_xtensa_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
extern int xtensa_read_table_entries
  PARAMS ((bfd *, asection *, property_table_entry **, const char *,
	   bfd_boolean));
static bfd_boolean elf_xtensa_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static void elf_xtensa_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
static asection *elf_xtensa_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf_xtensa_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf_xtensa_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_xtensa_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf_xtensa_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_xtensa_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_xtensa_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf_xtensa_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *again));
static bfd_boolean elf_xtensa_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf_xtensa_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_xtensa_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf_xtensa_set_private_flags
  PARAMS ((bfd *, flagword));
extern flagword elf_xtensa_get_private_bfd_flags
  PARAMS ((bfd *));
static bfd_boolean elf_xtensa_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean elf_xtensa_object_p
  PARAMS ((bfd *));
static void elf_xtensa_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
static enum elf_reloc_type_class elf_xtensa_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf_xtensa_discard_info
  PARAMS ((bfd *, struct elf_reloc_cookie *, struct bfd_link_info *));
static bfd_boolean elf_xtensa_ignore_discarded_relocs
  PARAMS ((asection *));
static bfd_boolean elf_xtensa_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf_xtensa_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf_xtensa_new_section_hook
  PARAMS ((bfd *, asection *));

d44 2
a45 29
static bfd_boolean xtensa_elf_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
static int property_table_compare
  PARAMS ((const PTR, const PTR));
static int property_table_matches
  PARAMS ((const PTR, const PTR));
static property_table_entry *elf_xtensa_find_property_entry
  PARAMS ((property_table_entry *, int, bfd_vma));
static bfd_boolean elf_xtensa_in_literal_pool
  PARAMS ((property_table_entry *, int, bfd_vma));
static void elf_xtensa_make_sym_local
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean add_extra_plt_sections
  PARAMS ((bfd *, int));
static bfd_boolean elf_xtensa_fix_refcounts
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_xtensa_allocate_plt_size
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_xtensa_allocate_got_size
  PARAMS ((struct elf_link_hash_entry *, PTR));
static void elf_xtensa_allocate_local_got_size
  PARAMS ((struct bfd_link_info *, asection *));
static bfd_reloc_status_type elf_xtensa_do_reloc
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_vma, bfd_byte *,
	   bfd_vma, bfd_boolean, char **));
static char * vsprint_msg
  VPARAMS ((const char *, const char *, int, ...));
static char *build_encoding_error_message
  PARAMS ((xtensa_opcode, bfd_vma));
d47 1
a47 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d49 1
a49 1
  PARAMS ((Elf_Internal_Rela *, bfd *, asection *, bfd_byte *));
d51 1
a51 8
  PARAMS ((Elf_Internal_Rela *, bfd *, asection *, bfd_byte *, bfd_vma *));
static bfd_vma elf_xtensa_create_plt_entry
  PARAMS ((bfd *, bfd *, unsigned));
static int elf_xtensa_combine_prop_entries
  PARAMS ((bfd *, asection *, asection *));
static bfd_boolean elf_xtensa_discard_info_for_section
  PARAMS ((bfd *, struct elf_reloc_cookie *, struct bfd_link_info *,
	   asection *));
d55 8
a62 18
static void init_call_opcodes
  PARAMS ((void));
static bfd_boolean is_indirect_call_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_direct_call_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_windowed_call_opcode
  PARAMS ((xtensa_opcode));
static xtensa_opcode get_const16_opcode
  PARAMS ((void));
static xtensa_opcode get_l32r_opcode
  PARAMS ((void));
static bfd_vma l32r_offset
  PARAMS ((bfd_vma, bfd_vma));
static int get_relocation_opnd
  PARAMS ((xtensa_opcode, int));
static int get_relocation_slot
  PARAMS ((int));
d64 1
a64 1
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *));
d66 3
a68 5
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *));
static bfd_boolean is_alt_relocation
  PARAMS ((int));
static bfd_boolean is_operand_relocation
  PARAMS ((int));
d70 1
a70 1
  PARAMS ((bfd_byte *, bfd_size_type, bfd_size_type));
d72 1
a72 1
  PARAMS ((bfd_byte *, bfd_size_type, bfd_size_type, int));
d74 1
a74 1
  PARAMS ((bfd_byte *, bfd_size_type, bfd_vma, bfd_vma));
d76 2
a77 3
  PARAMS ((bfd_byte *, bfd_size_type, bfd_vma, bfd_vma));
static bfd_boolean check_branch_target_aligned_address
  PARAMS ((bfd_vma, int));
d79 1
a79 1
  PARAMS ((bfd_byte *, bfd_size_type, bfd_size_type));
d84 1
a84 1
  PARAMS ((bfd_byte *, bfd_vma, bfd_vma, char **));
d86 3
a88 5
  PARAMS ((bfd_byte *, bfd_vma, Elf_Internal_Rela *, char **));
static xtensa_opcode swap_callx_for_call_opcode
  PARAMS ((xtensa_opcode));
static xtensa_opcode get_expanded_call_opcode
  PARAMS ((bfd_byte *, int, bfd_boolean *));
d93 7
a99 13
  PARAMS ((bfd *, asection *, bfd_boolean));
static void pin_internal_relocs
  PARAMS ((asection *, Elf_Internal_Rela *));
static void release_internal_relocs
  PARAMS ((asection *, Elf_Internal_Rela *));
static bfd_byte *retrieve_contents
  PARAMS ((bfd *, asection *, bfd_boolean));
static void pin_contents
  PARAMS ((asection *, bfd_byte *));
static void release_contents
  PARAMS ((asection *, bfd_byte *));
static Elf_Internal_Sym *retrieve_local_syms
  PARAMS ((bfd *));
d103 3
a105 6
static asection *elf_xtensa_get_plt_section
  PARAMS ((bfd *, int));
static asection *elf_xtensa_get_gotplt_section
  PARAMS ((bfd *, int));
static asection *get_elf_r_symndx_section
  PARAMS ((bfd *, unsigned long));
d107 10
a116 19
  PARAMS ((bfd *, unsigned long));
static bfd_vma get_elf_r_symndx_offset
  PARAMS ((bfd *, unsigned long));
static bfd_boolean is_reloc_sym_weak
  PARAMS ((bfd *, Elf_Internal_Rela *));
static bfd_boolean pcrel_reloc_fits
  PARAMS ((xtensa_opcode, int, bfd_vma, bfd_vma));
static bfd_boolean xtensa_is_property_section
  PARAMS ((asection *));
static bfd_boolean xtensa_is_littable_section
  PARAMS ((asection *));
static int internal_reloc_compare
  PARAMS ((const PTR, const PTR));
static int internal_reloc_matches
  PARAMS ((const PTR, const PTR));
extern char *xtensa_get_property_section_name
  PARAMS ((asection *, const char *));
static flagword xtensa_get_property_predef_flags
  PARAMS ((asection *));
d121 1
a121 1
  PARAMS ((asection *, bfd_vma, asection *, bfd_vma, PTR));
d123 1
a123 2
  PARAMS ((bfd *, asection *, struct bfd_link_info *,
	   deps_callback_t, PTR));
d130 1
d137 1
a140 1

d342 2
a343 3
elf_xtensa_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d444 3
a446 4
elf_xtensa_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d507 2
a508 3
xtensa_elf_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
d521 1
a521 3
property_table_compare (ap, bp)
     const PTR ap;
     const PTR bp;
d560 1
a560 3
property_table_matches (ap, bp)
     const PTR ap;
     const PTR bp;
d578 6
a583 7
int
xtensa_read_table_entries (abfd, section, table_p, sec_name, output_addr)
     bfd *abfd;
     asection *section;
     property_table_entry **table_p;
     const char *sec_name;
     bfd_boolean output_addr;
d712 4
a715 5
property_table_entry *
elf_xtensa_find_property_entry (property_table, property_table_size, addr)
     property_table_entry *property_table;
     int property_table_size;
     bfd_vma addr;
d734 3
a736 4
elf_xtensa_in_literal_pool (lit_table, lit_table_size, addr)
     property_table_entry *lit_table;
     int lit_table_size;
     bfd_vma addr;
d749 4
a752 5
elf_xtensa_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d925 27
a951 4
elf_xtensa_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
d965 5
a969 6
elf_xtensa_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d971 1
a971 1
  if (h != NULL)
d1000 1
d1005 4
a1008 5
elf_xtensa_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1067 1
a1067 3
elf_xtensa_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d1117 1
a1117 3
add_extra_plt_sections (dynobj, count)
     bfd *dynobj;
     int count;
d1164 2
a1165 3
elf_xtensa_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
d1170 1
a1170 1
  if (h->u.weakdef != NULL)
a1186 25
static void
elf_xtensa_make_sym_local (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  if (info->shared)
    {
      if (h->plt.refcount > 0)
	{
	  /* Will use RELATIVE relocs instead of JMP_SLOT relocs.  */
	  if (h->got.refcount < 0)
	    h->got.refcount = 0;
	  h->got.refcount += h->plt.refcount;
	  h->plt.refcount = 0;
	}
    }
  else
    {
      /* Don't need any dynamic relocations at all.  */
      h->plt.refcount = 0;
      h->got.refcount = 0;
    }
}


d1188 1
a1188 3
elf_xtensa_fix_refcounts (h, arg)
     struct elf_link_hash_entry *h;
     PTR arg;
d1203 1
a1203 3
elf_xtensa_allocate_plt_size (h, arg)
     struct elf_link_hash_entry *h;
     PTR arg;
d1218 1
a1218 3
elf_xtensa_allocate_got_size (h, arg)
     struct elf_link_hash_entry *h;
     PTR arg;
d1233 2
a1234 3
elf_xtensa_allocate_local_got_size (info, srelgot)
     struct bfd_link_info *info;
     asection *srelgot;
d1264 2
a1265 3
elf_xtensa_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1301 1
a1301 1
			      (PTR) info);
d1310 1
a1310 1
			      (PTR) srelgot);
d1324 1
a1324 1
			      (PTR) srelplt);
d1532 2
a1533 3
elf_xtensa_modify_segment_map (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1538 1
a1538 1
  while (*m_p != NULL)
d1555 1
a1555 1
#define CALL_SEGMENT_SIZE (1<<CALL_SEGMENT_BITS)
d1558 8
a1565 10
elf_xtensa_do_reloc (howto, abfd, input_section, relocation,
		     contents, address, is_weak_undef, error_message)
     reloc_howto_type *howto;
     bfd *abfd;
     asection *input_section;
     bfd_vma relocation;
     bfd_byte *contents;
     bfd_vma address;
     bfd_boolean is_weak_undef;
     char **error_message;
d1766 1
a1766 1
vsprint_msg VPARAMS ((const char *origmsg, const char *fmt, int arglen, ...))
d1796 1
a1796 3
build_encoding_error_message (opcode, target_address)
     xtensa_opcode opcode;
     bfd_vma target_address;
d1829 7
a1835 9
bfd_elf_xtensa_reloc (abfd, reloc_entry, symbol, data, input_section,
		      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1856 1
a1856 2
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0)
d1935 3
a1937 4
elf_xtensa_create_plt_entry (dynobj, output_bfd, reloc_index)
      bfd *dynobj;
      bfd *output_bfd;
      unsigned reloc_index;
d1984 8
a1991 11
elf_xtensa_relocate_section (output_bfd, info, input_bfd,
			     input_section, contents, relocs,
			     local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d2013 1
a2013 1
  if (dynobj != NULL)
d2323 1
a2323 1
	  BFD_ASSERT (error_message != (char *) NULL);
d2325 1
a2325 1
	  if (h != NULL)
d2365 4
a2368 5
elf_xtensa_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2396 3
a2398 4
elf_xtensa_combine_prop_entries (output_bfd, sxtlit, sgotloc)
     bfd *output_bfd;
     asection *sxtlit;
     asection *sgotloc;
d2503 2
a2504 3
elf_xtensa_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d2525 1
a2525 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
d2533 1
a2533 1
  if (srelplt != NULL && srelplt->size != 0)
d2706 1
a2706 3
elf_xtensa_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2758 1
a2758 3
elf_xtensa_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d2771 1
a2771 2
elf_xtensa_get_private_bfd_flags (abfd)
     bfd *abfd;
d2778 1
a2778 3
elf_xtensa_print_private_bfd_data (abfd, farg)
     bfd *abfd;
     PTR farg;
d2802 1
a2802 2
elf_xtensa_object_p (abfd)
     bfd *abfd;
d2826 2
a2827 3
elf_xtensa_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d2847 1
a2847 2
elf_xtensa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d2862 4
a2865 5
elf_xtensa_discard_info_for_section (abfd, cookie, info, sec)
     bfd *abfd;
     struct elf_reloc_cookie *cookie;
     struct bfd_link_info *info;
     asection *sec;
d2986 3
a2988 4
elf_xtensa_discard_info (abfd, cookie, info)
     bfd *abfd;
     struct elf_reloc_cookie *cookie;
     struct bfd_link_info *info;
d3007 1
a3007 2
elf_xtensa_ignore_discarded_relocs (sec)
     asection *sec;
d3016 1
a3016 3
elf_xtensa_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d3041 1
a3041 3
elf_xtensa_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d3083 1
a3083 1
init_call_opcodes ()
d3100 1
a3100 2
is_indirect_call_opcode (opcode)
     xtensa_opcode opcode;
d3111 1
a3111 2
is_direct_call_opcode (opcode)
     xtensa_opcode opcode;
d3122 1
a3122 2
is_windowed_call_opcode (opcode)
     xtensa_opcode opcode;
d3164 1
a3164 3
l32r_offset (addr, pc)
     bfd_vma addr;
     bfd_vma pc;
d3177 1
a3177 3
get_relocation_opnd (opcode, r_type)
     xtensa_opcode opcode;
     int r_type;
d3220 1
a3220 2
get_relocation_slot (r_type)
     int r_type;
d3244 4
a3247 5
get_relocation_opcode (abfd, sec, contents, irel)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     Elf_Internal_Rela *irel;
d3280 4
a3283 5
is_l32r_relocation (abfd, sec, contents, irel)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     Elf_Internal_Rela *irel;
d3294 3
a3296 4
get_asm_simplify_size (contents, content_len, offset)
     bfd_byte *contents;
     bfd_size_type content_len;
     bfd_size_type offset;
d3317 1
a3317 2
is_alt_relocation (r_type)
     int r_type;
d3325 1
a3325 2
is_operand_relocation (r_type)
     int r_type;
d3351 3
a3353 4
insn_decode_len (contents, content_len, offset)
     bfd_byte *contents;
     bfd_size_type content_len;
     bfd_size_type offset;
d3381 4
a3384 5
insn_decode_opcode (contents, content_len, offset, slot)
     bfd_byte *contents;
     bfd_size_type content_len;
     bfd_size_type offset;
     int slot;
d3418 4
a3421 5
check_branch_target_aligned (contents, content_length, offset, address)
     bfd_byte *contents;
     bfd_size_type content_length;
     bfd_vma offset;
     bfd_vma address;
d3431 4
a3434 5
check_loop_aligned (contents, content_length, offset, address)
     bfd_byte *contents;
     bfd_size_type content_length;
     bfd_vma offset;
     bfd_vma address;
d3461 1
a3461 3
check_branch_target_aligned_address (addr, len)
     bfd_vma addr;
     int len;
d3471 44
a3514 8
static bfd_boolean narrow_instruction
  PARAMS ((bfd_byte *, bfd_size_type, bfd_size_type, bfd_boolean));
static bfd_boolean widen_instruction
  PARAMS ((bfd_byte *, bfd_size_type, bfd_size_type, bfd_boolean));
static xtensa_format get_single_format
  PARAMS ((xtensa_opcode));
static void init_op_single_format_table
  PARAMS ((void));
d3517 2
a3518 1
struct string_pair
d3520 3
a3522 3
  const char *wide;
  const char *narrow;
};
d3531 6
d3573 4
a3576 5
narrow_instruction (contents, content_length, offset, do_it)
     bfd_byte *contents;
     bfd_size_type content_length;
     bfd_size_type offset;
     bfd_boolean do_it;
d3719 4
a3722 5
widen_instruction (contents, content_length, offset, do_it)
     bfd_byte *contents;
     bfd_size_type content_length;
     bfd_size_type offset;
     bfd_boolean do_it;
a3856 55

/* When FLIX is available we need to access certain instructions only
   when they are 16-bit or 24-bit instructions.  This table caches
   information about such instructions by walking through all the
   opcodes and finding the smallest single-slot format into which each
   can be encoded.  */

static xtensa_format *op_single_fmt_table = NULL;


static xtensa_format
get_single_format (opcode)
     xtensa_opcode opcode;
{
  init_op_single_format_table ();
  return op_single_fmt_table[opcode];
}


static void
init_op_single_format_table ()
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_insnbuf ibuf;
  xtensa_opcode opcode;
  xtensa_format fmt;
  int num_opcodes;

  if (op_single_fmt_table != NULL)
    return;

  ibuf = xtensa_insnbuf_alloc (isa);
  num_opcodes = xtensa_isa_num_opcodes (isa);

  op_single_fmt_table = (xtensa_format *)
    bfd_malloc (sizeof (xtensa_format) * num_opcodes);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      op_single_fmt_table[opcode] = XTENSA_UNDEFINED;
      for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
	{
	  if (xtensa_format_num_slots (isa, fmt) == 1
	      && xtensa_opcode_encode (isa, fmt, 0, ibuf, opcode) == 0)
	    {
	      xtensa_opcode old_fmt = op_single_fmt_table[opcode];
	      int fmt_length = xtensa_format_length (isa, fmt);
	      if (old_fmt == XTENSA_UNDEFINED
		  || fmt_length < xtensa_format_length (isa, old_fmt))
		op_single_fmt_table[opcode] = fmt;
	    }
	}
    }
  xtensa_insnbuf_free (isa, ibuf);
}

d3861 4
a3864 5
elf_xtensa_do_asm_simplify (contents, address, content_length, error_message)
     bfd_byte *contents;
     bfd_vma address;
     bfd_vma content_length;
     char **error_message;
d3924 4
a3927 5
contract_asm_expansion (contents, content_length, irel, error_message)
     bfd_byte *contents;
     bfd_vma content_length;
     Elf_Internal_Rela *irel;
     char **error_message;
d3945 1
a3945 2
swap_callx_for_call_opcode (opcode)
     xtensa_opcode opcode;
d3968 1
a3968 4
get_expanded_call_opcode (buf, bufsize, p_uses_l32r)
     bfd_byte *buf;
     int bufsize;
     bfd_boolean *p_uses_l32r;
a4088 17
static bfd_boolean r_reloc_is_const
  PARAMS ((const r_reloc *));
static void r_reloc_init
  PARAMS ((r_reloc *, bfd *, Elf_Internal_Rela *, bfd_byte *, bfd_size_type));
static bfd_vma r_reloc_get_target_offset
  PARAMS ((const r_reloc *));
static asection *r_reloc_get_section
  PARAMS ((const r_reloc *));
static bfd_boolean r_reloc_is_defined
  PARAMS ((const r_reloc *));
static struct elf_link_hash_entry *r_reloc_get_hash_entry
  PARAMS ((const r_reloc *));
#if DEBUG
static void print_r_reloc
  PARAMS ((FILE *fp, const r_reloc *r));
#endif /* DEBUG */

d4097 1
a4097 2
r_reloc_is_const (r_rel)
     const r_reloc *r_rel;
a4102 33
static void
r_reloc_init (r_rel, abfd, irel, contents, content_length) 
     r_reloc *r_rel;
     bfd *abfd;
     Elf_Internal_Rela *irel;
     bfd_byte *contents;
     bfd_size_type content_length;
{
  int r_type;
  reloc_howto_type *howto;

  if (irel != NULL)
    {
      r_rel->rela = *irel;
      r_rel->abfd = abfd;
      r_rel->target_offset = r_reloc_get_target_offset (r_rel);
      r_rel->virtual_offset = 0;
      r_type = ELF32_R_TYPE (r_rel->rela.r_info);
      howto = &elf_howto_table[r_type];
      if (howto->partial_inplace)
	{
	  bfd_vma inplace_val;
	  BFD_ASSERT (r_rel->rela.r_offset < content_length);

	  inplace_val = bfd_get_32 (abfd, &contents[r_rel->rela.r_offset]);
	  r_rel->target_offset += inplace_val;
	}
    }
  else
    memset (r_rel, 0, sizeof (r_reloc));
}


d4104 1
a4104 2
r_reloc_get_target_offset (r_rel)
     const r_reloc *r_rel;
d4117 1
a4117 2
r_reloc_get_hash_entry (r_rel)
     const r_reloc *r_rel;
d4125 1
a4125 2
r_reloc_get_section (r_rel)
     const r_reloc *r_rel;
d4133 1
a4133 2
r_reloc_is_defined (r_rel)
     const r_reloc *r_rel;
d4148 32
d4183 1
a4183 3
print_r_reloc (fp, r_rel)
     FILE *fp;
     const r_reloc *r_rel;
a4237 9
static void init_source_reloc
  PARAMS ((source_reloc *, asection *, const r_reloc *,
	   xtensa_opcode, int, bfd_boolean));
static source_reloc *find_source_reloc
  PARAMS ((source_reloc *, int, asection *, Elf_Internal_Rela *));
static int source_reloc_compare
  PARAMS ((const PTR, const PTR));


d4239 6
a4244 7
init_source_reloc (reloc, source_sec, r_rel, opcode, opnd, is_abs_literal)
     source_reloc *reloc;
     asection *source_sec;
     const r_reloc *r_rel;
     xtensa_opcode opcode;
     int opnd;
     bfd_boolean is_abs_literal;
d4260 4
a4263 5
find_source_reloc (src_relocs, src_count, sec, irel)
     source_reloc *src_relocs;
     int src_count;
     asection *sec;
     Elf_Internal_Rela *irel;
d4281 1
a4281 3
source_reloc_compare (ap, bp)
     const PTR ap;
     const PTR bp;
a4342 19
static void init_literal_value
  PARAMS ((literal_value *, const r_reloc *, unsigned long, bfd_boolean));
static bfd_boolean literal_value_equal
  PARAMS ((const literal_value *, const literal_value *, bfd_boolean));
static value_map_hash_table *value_map_hash_table_init
  PARAMS ((void));
static void value_map_hash_table_delete
  PARAMS ((value_map_hash_table *));
static unsigned literal_value_hash
  PARAMS ((const literal_value *));
static unsigned hash_bfd_vma
  PARAMS ((bfd_vma));
static value_map *value_map_get_cached_value
  PARAMS ((value_map_hash_table *, const literal_value *, bfd_boolean));
static value_map *add_value_map
  PARAMS ((value_map_hash_table *, const literal_value *, const r_reloc *,
	   bfd_boolean));


d4344 4
a4347 5
init_literal_value (lit, r_rel, value, is_abs_literal)
     literal_value *lit;
     const r_reloc *r_rel;
     unsigned long value;
     bfd_boolean is_abs_literal;
d4356 3
a4358 4
literal_value_equal (src1, src2, final_static_link)
     const literal_value *src1;
     const literal_value *src2;
     bfd_boolean final_static_link;
d4412 1
a4412 1
value_map_hash_table_init ()
d4434 1
a4434 2
value_map_hash_table_delete (table)
     value_map_hash_table *table;
d4442 1
a4442 2
hash_bfd_vma (val) 
     bfd_vma val;
d4449 1
a4449 2
literal_value_hash (src)
     const literal_value *src;
d4476 3
a4478 4
value_map_get_cached_value (map, val, final_static_link)
     value_map_hash_table *map;
     const literal_value *val;
     bfd_boolean final_static_link;
d4500 4
a4503 5
add_value_map (map, val, loc, final_static_link)
     value_map_hash_table *map;
     const literal_value *val;
     const r_reloc *loc;
     bfd_boolean final_static_link;
d4598 2
a4599 28
static text_action *find_fill_action
  PARAMS ((text_action_list *, asection *, bfd_vma));
static int compute_removed_action_diff
  PARAMS ((const text_action *, asection *, bfd_vma, int, int));
static void adjust_fill_action
  PARAMS ((text_action *, int));
static void text_action_add
  PARAMS ((text_action_list *, text_action_t, asection *, bfd_vma, int));
static void text_action_add_literal
  PARAMS ((text_action_list *, text_action_t, const r_reloc *,
	   const literal_value *, int));
static bfd_vma offset_with_removed_text
  PARAMS ((text_action_list *, bfd_vma));
static bfd_vma offset_with_removed_text_before_fill
  PARAMS ((text_action_list *, bfd_vma));
static text_action *find_insn_action
  PARAMS ((text_action_list *, bfd_vma));
#if DEBUG
static void print_action_list
  PARAMS ((FILE *, text_action_list *));
#endif


text_action *
find_fill_action (l, sec, offset)
     text_action_list *l;
     asection *sec;
     bfd_vma offset;
d4607 1
a4607 3
  for (m_p = &l->head;
       *m_p != NULL && (*m_p)->offset <= offset;
       m_p = &(*m_p)->next)
d4620 5
a4624 6
compute_removed_action_diff (ta, sec, offset, removed, removable_space)
     const text_action *ta;
     asection *sec;
     bfd_vma offset;
     int removed;
     int removable_space;
d4629 1
a4629 1
  if (ta != NULL)
d4655 2
a4656 4
void
adjust_fill_action (ta, fill_diff)
     text_action *ta;
     int fill_diff;
d4668 5
a4672 6
text_action_add (l, action, sec, offset, removed)
     text_action_list *l;
     text_action_t action;
     asection *sec;
     bfd_vma offset;
     int removed;
d4685 1
a4685 3
  for (m_p = &l->head;
       *m_p != NULL && (*m_p)->offset <= offset;
       m_p = &(*m_p)->next)
d4709 5
a4713 6
text_action_add_literal (l, action, loc, value, removed)
     text_action_list *l;
     text_action_t action;
     const r_reloc *loc;
     const literal_value *value;
     int removed;
d4744 2
a4745 4
bfd_vma 
offset_with_removed_text (action_list, offset)
     text_action_list *action_list;
     bfd_vma offset;
d4761 3
a4763 4
bfd_vma
offset_with_removed_text_before_fill (action_list, offset)
     text_action_list *action_list;
     bfd_vma offset;
d4777 2
a4778 4
text_action *
find_insn_action (action_list, offset)
     text_action_list *action_list;
     bfd_vma offset;
d4810 1
a4810 3
print_action_list (fp, action_list)
     FILE *fp;
     text_action_list *action_list;
a4873 10
static void add_removed_literal
  PARAMS ((removed_literal_list *, const r_reloc *, const r_reloc *));
static removed_literal *find_removed_literal
  PARAMS ((removed_literal_list *, bfd_vma));
#if DEBUG
static void print_removed_literals
  PARAMS ((FILE *, removed_literal_list *));
#endif /* DEBUG */


d4878 3
a4880 4
add_removed_literal (removed_list, from, to)
     removed_literal_list *removed_list;
     const r_reloc *from;
     const r_reloc *to;
d4907 1
a4907 2
      while (r->from.target_offset < from->target_offset
	     && r->next != NULL) 
d4924 1
a4924 3
find_removed_literal (removed_list, addr)
     removed_literal_list *removed_list;
     bfd_vma addr;
d4938 1
a4938 3
print_removed_literals (fp, removed_list)
     FILE *fp;
     removed_literal_list *removed_list;
a4995 5
static void init_xtensa_relax_info
  PARAMS ((asection *));
static xtensa_relax_info *get_xtensa_relax_info
  PARAMS ((asection *));

d4998 1
a4998 3
elf_xtensa_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d5006 1
a5006 1
  sec->used_by_bfd = (PTR) sdata;
d5012 14
d5027 1
a5027 2
init_xtensa_relax_info (sec)
     asection *sec;
a5052 15

static xtensa_relax_info *
get_xtensa_relax_info (sec)
     asection *sec;
{
  struct elf_xtensa_section_data *section_data;

  /* No info available if no section or if it is an output section.  */
  if (!sec || sec == sec->output_section)
    return NULL;

  section_data = (struct elf_xtensa_section_data *) elf_section_data (sec);
  return &section_data->relax_info;
}

a5077 13
static reloc_bfd_fix *reloc_bfd_fix_init
  PARAMS ((asection *, bfd_vma, unsigned, bfd *, asection *, bfd_vma,
	   bfd_boolean));
static void add_fix
  PARAMS ((asection *, reloc_bfd_fix *));
static int fix_compare
  PARAMS ((const PTR, const PTR));
static void cache_fix_array
  PARAMS ((asection *));
static reloc_bfd_fix *get_bfd_fix
  PARAMS ((asection *, bfd_vma, unsigned));


d5079 7
a5085 9
reloc_bfd_fix_init (src_sec, src_offset, src_type,
		    target_abfd, target_sec, target_offset, translated)
     asection *src_sec;
     bfd_vma src_offset;
     unsigned src_type;
     bfd *target_abfd;
     asection *target_sec;
     bfd_vma target_offset;
     bfd_boolean translated;
d5103 1
a5103 3
add_fix (src_sec, fix)
     asection *src_sec;
     reloc_bfd_fix *fix;
d5114 1
a5114 3
fix_compare (ap, bp)
     const PTR ap;
     const PTR bp;
d5126 1
a5126 2
cache_fix_array (sec)
     asection *sec;
d5157 1
a5157 4
get_bfd_fix (sec, offset, type)
     asection *sec;
     bfd_vma offset;
     unsigned type;
d5198 5
a5202 6
static void init_section_cache
  PARAMS ((section_cache_t *));
static bfd_boolean section_cache_section
  PARAMS ((section_cache_t *, asection *, struct bfd_link_info *));
static void clear_section_cache
  PARAMS ((section_cache_t *));
d5206 1
a5206 2
init_section_cache (sec_cache)
     section_cache_t *sec_cache;
d5208 8
a5215 1
  memset (sec_cache, 0, sizeof (*sec_cache));
d5220 3
a5222 4
section_cache_section (sec_cache, sec, link_info)
     section_cache_t *sec_cache;
     asection *sec;
     struct bfd_link_info *link_info;
a5275 15

static void
clear_section_cache (sec_cache)
     section_cache_t *sec_cache;
{
  if (sec_cache->sec)
    {
      release_contents (sec_cache->sec, sec_cache->contents);
      release_internal_relocs (sec_cache->sec, sec_cache->relocs);
      if (sec_cache->ptbl)
	free (sec_cache->ptbl);
      memset (sec_cache, 0, sizeof (sec_cache));
    }
}

a5380 22
static void init_ebb_constraint
  PARAMS ((ebb_constraint *));
static void free_ebb_constraint
  PARAMS ((ebb_constraint *));
static void init_ebb
  PARAMS ((ebb_t *, asection *, bfd_byte *, bfd_size_type,
	   property_table_entry *, unsigned, Elf_Internal_Rela *, unsigned));
static bfd_boolean extend_ebb_bounds
  PARAMS ((ebb_t *));
static bfd_boolean extend_ebb_bounds_forward
  PARAMS ((ebb_t *));
static bfd_boolean extend_ebb_bounds_backward
  PARAMS ((ebb_t *));
static bfd_size_type insn_block_decodable_len
  PARAMS ((bfd_byte *, bfd_size_type, bfd_vma, bfd_size_type));
static void ebb_propose_action 
  PARAMS ((ebb_constraint *, enum ebb_target_enum, bfd_vma, text_action_t,
	   bfd_vma, int, bfd_boolean));
static void ebb_add_proposed_action
  PARAMS ((ebb_constraint *, proposed_action *));


d5382 1
a5382 2
init_ebb_constraint (c)
     ebb_constraint *c;
d5389 1
a5389 2
free_ebb_constraint (c)
     ebb_constraint *c;
d5391 1
a5391 1
  if (c->actions != NULL)
d5397 8
a5404 10
init_ebb (ebb, sec, contents, content_length, prop_table, ptblsize,
	  internal_relocs, reloc_count) 
     ebb_t *ebb;
     asection *sec;
     bfd_byte *contents;
     bfd_size_type content_length;
     property_table_entry *prop_table;
     unsigned ptblsize;
     Elf_Internal_Rela *internal_relocs;
     unsigned reloc_count;
d5429 5
d5435 1
a5435 2
extend_ebb_bounds (ebb)
     ebb_t *ebb;
d5446 1
a5446 2
extend_ebb_bounds_forward (ebb)
     ebb_t *ebb;
d5522 1
a5522 2
extend_ebb_bounds_backward (ebb)
     ebb_t *ebb;
d5578 4
a5581 5
insn_block_decodable_len (contents, content_len, block_offset, block_len)
     bfd_byte *contents;
     bfd_size_type content_len;
     bfd_vma block_offset;
     bfd_size_type block_len;
d5598 2
d5601 7
a5607 9
ebb_propose_action (c, align_type, alignment_pow, action, offset,
		    removed_bytes, do_action)
     ebb_constraint *c;
     bfd_vma alignment_pow;
     enum ebb_target_enum align_type;
     text_action_t action;
     bfd_vma offset;
     int removed_bytes;
     bfd_boolean do_action;
d5621 1
a5621 3
ebb_add_proposed_action (c, action)
     ebb_constraint *c;
     proposed_action *action;
d5632 1
a5632 1
      if (c->actions != NULL)
d5652 1
a5652 4
retrieve_internal_relocs (abfd, sec, keep_memory)
     bfd *abfd;
     asection *sec;
     bfd_boolean keep_memory;
d5662 1
a5662 2
		       (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			keep_memory));
d5668 1
a5668 3
pin_internal_relocs (sec, internal_relocs)
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
d5675 1
a5675 3
release_internal_relocs (sec, internal_relocs)
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
d5684 1
a5684 4
retrieve_contents (abfd, sec, keep_memory)
     bfd *abfd;
     asection *sec;
     bfd_boolean keep_memory;
d5696 1
a5696 1
	  if (contents != NULL)
d5708 1
a5708 3
pin_contents (sec, contents)
     asection *sec;
     bfd_byte *contents;
d5715 1
a5715 3
release_contents (sec, contents)
     asection *sec;
     bfd_byte *contents;
d5723 1
a5723 2
retrieve_local_syms (input_bfd)
     bfd *input_bfd;
d5748 1
a5748 2
static bfd_boolean analyze_relocations
  PARAMS ((struct bfd_link_info *));
d5750 1
a5750 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d5752 1
a5752 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
d5754 2
a5755 2
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *,
	   struct bfd_link_info *, bfd_boolean *));
d5757 1
a5757 2
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *));
d5759 3
a5761 5
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
static bfd_boolean compute_ebb_proposed_actions
  PARAMS ((ebb_constraint *));
static bfd_boolean compute_ebb_actions
  PARAMS ((ebb_constraint *));
d5763 2
a5764 4
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *,
	   const ebb_constraint *));
static bfd_boolean check_section_ebb_reduces
  PARAMS ((const ebb_constraint *));
d5766 2
a5767 3
  PARAMS ((text_action_list *, const ebb_constraint *, asection *));
static int compute_fill_extra_space
  PARAMS ((property_table_entry *));
d5771 1
a5771 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *, value_map_hash_table *));
d5773 1
a5773 1
  PARAMS ((asection *, Elf_Internal_Rela *, bfd_vma));
d5775 1
a5775 1
  PARAMS ((const source_reloc *, int, const source_reloc *, int));
d5777 8
a5784 9
  PARAMS ((bfd *, asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *, source_reloc *, property_table_entry *, int)); 
static bfd_boolean identify_literal_placement 
  PARAMS ((bfd *, asection *, bfd_byte *, struct bfd_link_info *,
	   value_map_hash_table *, bfd_boolean *, Elf_Internal_Rela *, int,
	   source_reloc *, property_table_entry *, int, section_cache_t *,
	   bfd_boolean));
static bfd_boolean relocations_reach
  PARAMS ((source_reloc *, int, const r_reloc *));
d5786 1
a5786 2
  PARAMS ((asection *, source_reloc *, property_table_entry *, int,
	   value_map *));
d5788 2
a5789 3
  PARAMS ((asection *, struct bfd_link_info *, source_reloc *,
	   property_table_entry *, int, const r_reloc *,
	   const literal_value *, section_cache_t *));
d5792 4
a5795 8
static bfd_boolean relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
static bfd_boolean translate_section_fixes
  PARAMS ((asection *));
static bfd_boolean translate_reloc_bfd_fix
  PARAMS ((reloc_bfd_fix *));
static void translate_reloc
  PARAMS ((const r_reloc *, r_reloc *));
d5797 1
a5797 1
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *));
d5799 2
a5800 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *, bfd_vma, bfd_byte *,
	   xtensa_relax_info *, Elf_Internal_Rela **, const literal_value *));
d5802 1
a5802 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
d5805 1
a5805 2
static bfd_boolean relax_section_symbols
  PARAMS ((bfd *, asection *));
d5809 4
a5812 5
elf_xtensa_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d5884 1
a5884 2
analyze_relocations (link_info)
     struct bfd_link_info *link_info;
d5955 4
a5958 5
find_relaxable_sections (abfd, sec, link_info, is_relaxable_p)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *is_relaxable_p;
d6041 3
a6043 4
collect_source_relocs (abfd, sec, link_info)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
d6200 6
a6205 8
is_resolvable_asm_expansion (abfd, sec, contents, irel, link_info,
			     is_reachable_p)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     Elf_Internal_Rela *irel;
     struct bfd_link_info *link_info;
     bfd_boolean *is_reachable_p;
d6275 5
a6279 6
find_associated_l32r_irel (abfd, sec, contents, other_irel, internal_relocs)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     Elf_Internal_Rela *other_irel;
     Elf_Internal_Rela *internal_relocs;
d6311 3
a6313 4
compute_text_actions (abfd, sec, link_info)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
d6447 1
a6447 1
  if (relax_info->action_list.head != NULL)
d6464 1
a6464 2
compute_ebb_proposed_actions (ebb_table)
     ebb_constraint *ebb_table;
d6625 1
a6625 2
compute_ebb_actions (ebb_table)
     ebb_constraint *ebb_table;
d6865 5
a6869 6
check_section_ebb_pcrels_fit (abfd, sec, contents, internal_relocs, constraint)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     Elf_Internal_Rela *internal_relocs;
     const ebb_constraint *constraint;
d6967 1
a6967 2
check_section_ebb_reduces (constraint)
     const ebb_constraint *constraint;
d6986 3
a6988 4
text_action_add_proposed (l, ebb_table, sec)
     text_action_list *l;
     const ebb_constraint *ebb_table;
     asection *sec;
d7021 1
a7021 2
compute_fill_extra_space (entry)
     property_table_entry *entry;
d7055 4
a7058 5
compute_removed_literals (abfd, sec, link_info, values)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     value_map_hash_table *values;
d7181 3
a7183 4
get_irel_at_offset (sec, internal_relocs, offset)
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
     bfd_vma offset;
d7221 4
a7224 5
is_removable_literal (rel, i, src_relocs, src_count)
     const source_reloc *rel;
     int i;
     const source_reloc *src_relocs;
     int src_count;
d7247 8
a7254 10
remove_dead_literal (abfd, sec, link_info, internal_relocs,
		     irel, rel, prop_table, ptblsize)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     Elf_Internal_Rela *internal_relocs;
     Elf_Internal_Rela *irel;
     source_reloc *rel;
     property_table_entry *prop_table;
     int ptblsize;
d7318 13
a7330 17
identify_literal_placement (abfd, sec, contents, link_info, values,
			    last_loc_is_prev_p, irel, remaining_src_rels,
			    rel, prop_table, ptblsize, target_sec_cache,
			    is_abs_literal)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     struct bfd_link_info *link_info;
     value_map_hash_table *values;
     bfd_boolean *last_loc_is_prev_p;
     Elf_Internal_Rela *irel;
     int remaining_src_rels;
     source_reloc *rel;
     property_table_entry *prop_table;
     int ptblsize;
     section_cache_t *target_sec_cache;
     bfd_boolean is_abs_literal;
d7442 3
a7444 4
relocations_reach (reloc, remaining_relocs, r_rel)
     source_reloc *reloc;
     int remaining_relocs;
     const r_reloc *r_rel;
d7496 5
a7500 6
coalesce_shared_literal (sec, rel, prop_table, ptblsize, val_map)
     asection *sec;
     source_reloc *rel;
     property_table_entry *prop_table;
     int ptblsize;
     value_map *val_map;
d7561 8
a7568 10
move_shared_literal (sec, link_info, rel, prop_table, ptblsize,
		     target_loc, lit_value, target_sec_cache)
     asection *sec;
     struct bfd_link_info *link_info;
     source_reloc *rel;
     property_table_entry *prop_table;
     int ptblsize;
     const r_reloc *target_loc;
     const literal_value *lit_value;
     section_cache_t *target_sec_cache;
d7715 1
a7715 4
relax_section (abfd, sec, link_info)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
d8149 1
a8149 2
translate_section_fixes (sec)
     asection *sec;
d8170 1
a8170 2
translate_reloc_bfd_fix (fix)
     reloc_bfd_fix *fix;
d8260 1
a8260 3
translate_reloc (orig_rel, new_rel)
     const r_reloc *orig_rel;
     r_reloc *new_rel;
d8335 4
a8338 5
shrink_dynamic_reloc_sections (info, abfd, input_section, rel)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
d8438 8
a8445 10
move_literal (abfd, link_info, sec, offset, contents, relax_info,
	      internal_relocs_p, lit)
     bfd *abfd;
     struct bfd_link_info *link_info;
     asection *sec;
     bfd_vma offset;
     bfd_byte *contents;
     xtensa_relax_info *relax_info;
     Elf_Internal_Rela **internal_relocs_p;
     const literal_value *lit;
d8571 3
a8573 4
relax_property_section (abfd, sec, link_info)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
d8921 1
a8921 3
relax_section_symbols (abfd, sec)
     bfd *abfd;
     asection *sec;
d9005 4
a9008 5
do_fix_for_relocatable_link (rel, input_bfd, input_section, contents)
     Elf_Internal_Rela *rel;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
d9051 5
a9055 6
do_fix_for_final_link (rel, input_bfd, input_section, contents, relocationp)
     Elf_Internal_Rela *rel;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma *relocationp;
d9090 1
a9090 3
elf_xtensa_get_plt_section (dynobj, chunk)
     bfd *dynobj;
     int chunk;
d9103 1
a9103 3
elf_xtensa_get_gotplt_section (dynobj, chunk)
     bfd *dynobj;
     int chunk;
d9124 1
a9124 3
get_elf_r_symndx_section (abfd, r_symndx)
     bfd *abfd;
     unsigned long r_symndx;
d9180 1
a9180 3
get_elf_r_symndx_hash_entry (abfd, r_symndx)
     bfd *abfd;
     unsigned long r_symndx;
d9201 1
a9201 3
get_elf_r_symndx_offset (abfd, r_symndx)
     bfd *abfd;
     unsigned long r_symndx;
d9230 1
a9230 3
is_reloc_sym_weak (abfd, rel)
     bfd *abfd;
     Elf_Internal_Rela *rel;
d9243 4
a9246 5
pcrel_reloc_fits (opc, opnd, self_address, dest_address)
     xtensa_opcode opc;
     int opnd;
     bfd_vma self_address;
     bfd_vma dest_address;
d9264 1
a9264 2
xtensa_is_property_section (sec)
     asection *sec;
d9282 1
a9282 2
xtensa_is_littable_section (sec)
     asection *sec;
d9297 1
a9297 3
internal_reloc_compare (ap, bp)
     const PTR ap;
     const PTR bp;
d9320 1
a9320 3
internal_reloc_matches (ap, bp)
     const PTR ap;
     const PTR bp;
d9332 1
a9332 3
xtensa_get_property_section_name (sec, base_name)
     asection *sec;
     const char *base_name;
d9369 1
a9369 2
xtensa_get_property_predef_flags (sec)
     asection *sec;
d9390 5
a9394 6
xtensa_callback_required_dependence (abfd, sec, link_info, callback, closure)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     deps_callback_t callback;
     PTR closure;
@


1.34
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d38 2
d46 2
a47 1
  PARAMS ((bfd *, asection *, property_table_entry **, const char *));
d109 4
d133 1
a133 1
  PARAMS ((xtensa_opcode, xtensa_encode_result));
d136 2
a137 2
static void do_fix_for_relocatable_link
  PARAMS ((Elf_Internal_Rela *, bfd *, asection *));
d139 1
a139 1
  PARAMS ((Elf_Internal_Rela *, asection *, bfd_vma *));
d158 2
d165 3
a167 1
  PARAMS ((Elf_Internal_Rela *));
d169 1
a169 1
  PARAMS ((asection *, bfd_byte *, Elf_Internal_Rela *));
d171 17
a187 1
  PARAMS ((asection *, bfd_byte *, Elf_Internal_Rela *));
d191 2
a192 2
static bfd_reloc_status_type elf_xtensa_do_asm_simplify 
  PARAMS ((bfd_byte *, bfd_vma, bfd_vma));
d194 1
a194 1
  PARAMS ((bfd_byte *, bfd_vma, Elf_Internal_Rela *));
d198 1
a198 1
  PARAMS ((bfd_byte *, int));
d229 2
d232 1
a232 1
  PARAMS ((xtensa_operand, bfd_vma, bfd_vma));
a236 2
static bfd_boolean is_literal_section
  PARAMS ((asection *));
d239 2
d243 2
d255 10
d268 1
d279 8
d293 5
d354 106
a459 1
	 FALSE, 0x00000000, 0x00000000, FALSE)
d462 1
a462 1
#ifdef DEBUG_GEN_RELOC
d484 12
d545 16
d659 42
a700 2
  /* Check if one entry overlaps with the other; this shouldn't happen
     except when searching for a match.  */
d709 3
a711 3
/* Get the literal table or instruction table entries for the given
   section.  Sets TABLE_P and returns the number of entries.  On error,
   returns a negative value.  */
d714 1
a714 1
xtensa_read_table_entries (abfd, section, table_p, sec_name)
d719 1
d730 10
d741 1
a741 2
  table_section_name = 
    xtensa_get_property_section_name (section, sec_name);
d744 1
a744 1
  if (table_section != NULL)
d746 1
a746 1
  
d753 6
a758 1
  num_records = table_size / 8;
d763 5
a767 2
  
  section_addr = section->output_section->vma + section->output_offset;
d790 2
d797 5
d811 1
d813 1
a813 1
      for (off = 0; off < table_size; off += 8) 
d818 1
a818 1
	      && address < section_addr + section->size)
d823 5
d836 1
a836 1
  if (block_count > 0) 
d842 1
a842 1
    
d848 4
a851 4
static bfd_boolean
elf_xtensa_in_literal_pool (lit_table, lit_table_size, addr)
     property_table_entry *lit_table;
     int lit_table_size;
d855 1
d857 2
a858 2
  if (lit_table_size == 0)
    return FALSE;
d862 6
d869 8
a876 2
  if (bsearch (&entry, lit_table, lit_table_size,
	       sizeof (property_table_entry), property_table_compare))
d989 2
a990 2
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
d1002 30
d1034 3
d1725 1
a1726 2
  xtensa_operand operand;
  xtensa_encode_result encode_result;
d1728 5
a1732 3
  xtensa_insnbuf ibuff;
  bfd_vma self_address;
  int opnd;
d1735 8
d1746 3
d1757 1
a1757 1
				      input_section->size - address);
d1763 2
a1764 2
	      if ((self_address >> CALL_SEGMENT_BITS) !=
		  (relocation >> CALL_SEGMENT_BITS)) 
d1775 1
a1775 1
      { 
d1777 3
a1779 2
	bfd_reloc_status_type retval = 
	  elf_xtensa_do_asm_simplify (contents, address, input_section->size);
d1781 1
a1781 1
	  return retval;
d1785 1
a1785 1
	howto = &elf_howto_table[(unsigned) R_XTENSA_OP0 ];
d1800 3
a1802 7
  /* Read the instruction into a buffer and decode the opcode.  */
  ibuff = xtensa_insnbuf_alloc (isa);
  xtensa_insnbuf_from_chars (isa, ibuff, contents + address);
  opcode = xtensa_decode_insn (isa, ibuff);

  /* Determine which operand is being relocated.  */
  if (opcode == XTENSA_UNDEFINED)
d1804 1
a1804 1
      *error_message = "cannot decode instruction";
d1808 5
a1812 1
  if (howto->type < R_XTENSA_OP0 || howto->type > R_XTENSA_OP2)
d1814 1
a1814 1
      *error_message = "unexpected relocation";
d1818 1
a1818 1
  opnd = howto->type - R_XTENSA_OP0;
d1820 2
a1821 2
  /* Calculate the PC address for this instruction.  */
  if (!howto->pc_relative)
d1823 1
a1823 1
      *error_message = "expected PC-relative relocation";
d1827 55
a1881 3
  self_address = (input_section->output_section->vma
		  + input_section->output_offset
		  + address);
d1883 4
a1886 5
  /* Apply the relocation.  */
  operand = xtensa_get_operand (isa, opcode, opnd);
  newval = xtensa_operand_do_reloc (operand, relocation, self_address);
  encode_result = xtensa_operand_encode (operand, &newval);
  xtensa_operand_set_field (operand, ibuff, newval);
d1888 3
a1890 3
  /* Write the modified instruction back out of the buffer.  */
  xtensa_insnbuf_to_chars (isa, ibuff, contents + address);
  free (ibuff);
d1892 5
a1896 1
  if (encode_result != xtensa_encode_result_ok)
d1898 1
a1898 2
      char *message = build_encoding_error_message (opcode, encode_result);
      *error_message = message;
d1902 1
a1902 1
  /* Final check for call.  */
d1906 2
a1907 2
      if ((self_address >> CALL_SEGMENT_BITS) !=
	  (relocation >> CALL_SEGMENT_BITS)) 
d1909 2
a1910 2
	  *error_message = "windowed call crosses 1GB boundary; "
	    "return may fail";
d1915 4
d1954 1
a1954 1
build_encoding_error_message (opcode, encode_result)
d1956 1
a1956 1
     xtensa_encode_result encode_result;
d1959 1
a1959 1
  const char *msg = NULL;
d1961 2
a1962 1
  switch (encode_result)
d1964 4
a1967 19
    case xtensa_encode_result_ok:
      msg = "unexpected valid encoding";
      break;
    case xtensa_encode_result_align:
      msg = "misaligned encoding";
      break;
    case xtensa_encode_result_not_in_table:
      msg = "encoding not in lookup table";
      break;
    case xtensa_encode_result_too_low:
      msg = "encoding out of range: too low";
      break;
    case xtensa_encode_result_too_high:
      msg = "encoding out of range: too high";
      break;
    case xtensa_encode_result_not_ok:
    default:
      msg = "could not encode";
      break;
d1969 1
a1969 8

  if (is_direct_call_opcode (opcode)
      && (encode_result == xtensa_encode_result_too_low
	  || encode_result == xtensa_encode_result_too_high))

    msg = "direct call out of range";

  else if (opcode == get_l32r_opcode ()) 
d1971 4
a1974 9
      /* L32Rs have the strange interaction with encoding in that they
         have an unsigned immediate field, so libisa returns "too high"
         when the absolute value is out of range and never returns "too
         low", but I leave the "too low" message in case anything
         changes.  */
      if (encode_result == xtensa_encode_result_too_low)
	msg = "literal out of range";
      else if (encode_result == xtensa_encode_result_too_high)
	msg = "literal placed after use";
d1976 1
a1976 1
  
d2062 1
a2062 1
         
d2169 1
d2171 2
a2172 2
  if (xtensa_default_isa == NULL)
    xtensa_isa_init ();
d2189 2
a2190 1
					    &lit_table, XTENSA_LIT_SEC_NAME);
d2195 2
d2229 1
a2229 1
	  /* This is a relocatable link. 
d2240 3
a2242 1
	      do_fix_for_relocatable_link (rel, input_bfd, input_section);
d2246 1
a2246 1
	  if (r_type == R_XTENSA_ASM_SIMPLIFY) 
d2248 1
d2251 9
a2259 1
	      contract_asm_expansion (contents, input_section->size, rel);
d2347 2
a2348 1
	  do_fix_for_final_link (rel, input_section, &relocation);
d2356 1
a2356 1
      if (rel->r_offset >= bfd_get_section_limit (input_bfd, input_section)
d2359 3
d2371 1
a2371 3
	  if (dynamic_symbol && (r_type == R_XTENSA_OP0
				 || r_type == R_XTENSA_OP1
				 || r_type == R_XTENSA_OP2))
d2443 1
a2443 1
			  relocation = 
d2484 1
a2484 1
      
d2489 1
a2489 1
	  BFD_ASSERT (r == bfd_reloc_dangerous);
d2502 10
a2511 2
	    error_message = vsprint_msg (error_message, ": %s",
					 strlen (name), name);
d2583 1
a2583 1
	("internal inconsistency in size of .got.loc section");
d2897 1
a2897 1
  if (out_mach != in_mach) 
d2900 1
a2900 1
	("%B: incompatible machine type. Output is 0x%x. Input is 0x%x",
d2910 1
a2910 1
      
d2915 1
a2915 1
      
d2919 5
a2923 7
  if ((out_flag & EF_XTENSA_XT_INSN) !=
      (in_flag & EF_XTENSA_XT_INSN)) 
    elf_elfheader(obfd)->e_flags &= (~ EF_XTENSA_XT_INSN);

  if ((out_flag & EF_XTENSA_XT_LIT) !=
      (in_flag & EF_XTENSA_XT_LIT)) 
    elf_elfheader(obfd)->e_flags &= (~ EF_XTENSA_XT_LIT);
d2961 1
a2961 1
  if ((e_flags & EF_XTENSA_MACH) == E_XTENSA_MACH) 
d3325 14
d3342 3
a3344 1
  if (l32r_opcode == XTENSA_UNDEFINED)
d3347 1
a3347 1
      BFD_ASSERT (l32r_opcode != XTENSA_UNDEFINED);
d3368 44
a3411 2
/* Get the operand number for a PC-relative relocation.
   If the relocation is not a PC-relative one, return (-1).  */
d3413 3
a3415 3
static int
get_relocation_opnd (irel)
     Elf_Internal_Rela *irel;
d3417 16
a3432 4
  if (ELF32_R_TYPE (irel->r_info) < R_XTENSA_OP0
      || ELF32_R_TYPE (irel->r_info) >= R_XTENSA_max)
    return -1;
  return ELF32_R_TYPE (irel->r_info) - R_XTENSA_OP0;
d3439 2
a3440 1
get_relocation_opcode (sec, contents, irel)
d3446 1
d3448 2
a3449 3

  if (get_relocation_opnd (irel) == -1)
    return XTENSA_UNDEFINED;
d3454 1
a3454 1
  if (sec->size <= irel->r_offset)
d3458 5
a3462 2
    ibuff = xtensa_insnbuf_alloc (isa);
      
d3464 8
a3471 2
  xtensa_insnbuf_from_chars (isa, ibuff, &contents[irel->r_offset]);
  return xtensa_decode_insn (isa, ibuff);
d3476 2
a3477 1
is_l32r_relocation (sec, contents, irel)
d3483 1
a3483 2

  if (ELF32_R_TYPE (irel->r_info) != R_XTENSA_OP1)
d3485 1
a3485 2
  
  opcode = get_relocation_opcode (sec, contents, irel);
a3488 2

/* Code for transforming CALLs at link-time.  */
d3490 2
a3491 2
static bfd_reloc_status_type
elf_xtensa_do_asm_simplify (contents, address, content_length)
d3493 2
a3494 2
     bfd_vma address;
     bfd_vma content_length;
d3496 1
a3496 7
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_opcode opcode;
  xtensa_operand operand;
  xtensa_opcode direct_call_opcode;
  xtensa_isa isa = xtensa_default_isa;
  bfd_byte *chbuf = contents + address;
  int opn;
d3498 4
a3501 2
  if (insnbuf == NULL)
    insnbuf = xtensa_insnbuf_alloc (isa);
d3503 5
a3507 6
  if (content_length < address)
    {
      (*_bfd_error_handler)
	("Attempt to convert L32R/CALLX to CALL failed");
      return bfd_reloc_other;
    }
d3509 3
a3511 18
  opcode = get_expanded_call_opcode (chbuf, content_length - address);
  direct_call_opcode = swap_callx_for_call_opcode (opcode);
  if (direct_call_opcode == XTENSA_UNDEFINED)
    {
      (*_bfd_error_handler)
	("Attempt to convert L32R/CALLX to CALL failed");
      return bfd_reloc_other;
    }
  
  /* Assemble a NOP ("or a1, a1, a1") into the 0 byte offset.  */
  opcode = xtensa_opcode_lookup (isa, "or");
  xtensa_encode_insn (isa, opcode, insnbuf);
  for (opn = 0; opn < 3; opn++) 
    {
      operand = xtensa_get_operand (isa, opcode, opn);
      xtensa_operand_set_field (operand, insnbuf, 1);
    }
  xtensa_insnbuf_to_chars (isa, insnbuf, chbuf);
a3512 5
  /* Assemble a CALL ("callN 0") into the 3 byte offset.  */
  xtensa_encode_insn (isa, direct_call_opcode, insnbuf);
  operand = xtensa_get_operand (isa, opcode, 0);
  xtensa_operand_set_field (operand, insnbuf, 0);
  xtensa_insnbuf_to_chars (isa, insnbuf, chbuf + 3);
d3514 6
a3519 1
  return bfd_reloc_ok;
d3523 3
a3525 5
static bfd_reloc_status_type
contract_asm_expansion (contents, content_length, irel)
     bfd_byte *contents;
     bfd_vma content_length;
     Elf_Internal_Rela *irel;
d3527 6
a3532 2
  bfd_reloc_status_type retval =
    elf_xtensa_do_asm_simplify (contents, irel->r_offset, content_length);
d3534 7
a3540 2
  if (retval != bfd_reloc_ok)
    return retval;
d3542 1
a3542 5
  /* Update the irel->r_offset field so that the right immediate and
     the right instruction are modified during the relocation.  */
  irel->r_offset += 3;
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_XTENSA_OP0);
  return bfd_reloc_ok;
d3545 4
d3550 5
a3554 3
static xtensa_opcode
swap_callx_for_call_opcode (opcode)
     xtensa_opcode opcode;
d3556 4
a3559 1
  init_call_opcodes ();
d3561 2
a3562 4
  if (opcode == callx0_op) return call0_op;
  if (opcode == callx4_op) return call4_op;
  if (opcode == callx8_op) return call8_op;
  if (opcode == callx12_op) return call12_op;
d3564 11
a3574 2
  /* Return XTENSA_UNDEFINED if the opcode is not an indirect call.  */
  return XTENSA_UNDEFINED;
d3578 2
a3579 2
/* Check if "buf" is pointing to a "L32R aN; CALLX aN" sequence, and
   if so, return the CALLX opcode.  If not, return XTENSA_UNDEFINED.  */
d3581 6
a3586 7
#define L32R_TARGET_REG_OPERAND 0
#define CALLN_SOURCE_OPERAND 0

static xtensa_opcode 
get_expanded_call_opcode (buf, bufsize)
     bfd_byte *buf;
     int bufsize;
d3588 2
d3591 3
a3593 7
  xtensa_opcode opcode;
  xtensa_operand operand;
  xtensa_isa isa = xtensa_default_isa;
  uint32 regno, call_regno;
  
  /* Buffer must be at least 6 bytes.  */
  if (bufsize < 6)
d3597 9
a3605 6
    insnbuf = xtensa_insnbuf_alloc (isa);
      
  xtensa_insnbuf_from_chars (isa, insnbuf, buf);
  opcode = xtensa_decode_insn (isa, insnbuf);
  
  if (opcode != get_l32r_opcode ())
d3607 2
a3608 11
  
  operand = xtensa_get_operand (isa, opcode, L32R_TARGET_REG_OPERAND);
  regno = xtensa_operand_decode
    (operand, xtensa_operand_get_field (operand, insnbuf));
  
  /* Next instruction should be an CALLXn with operand 0 == regno.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, 
			     buf + xtensa_insn_length (isa, opcode));
  opcode = xtensa_decode_insn (isa, insnbuf);
  
  if (!is_indirect_call_opcode (opcode))
d3610 3
a3612 8
  
  operand = xtensa_get_operand (isa, opcode, CALLN_SOURCE_OPERAND);
  call_regno = xtensa_operand_decode
    (operand, xtensa_operand_get_field (operand, insnbuf));
  if (call_regno != regno)
    return XTENSA_UNDEFINED;
  
  return opcode;
a3614 2

/* Data structures used during relaxation.  */
d3616 2
a3617 1
/* r_reloc: relocation values.  */
d3619 12
a3630 6
/* Through the relaxation process, we need to keep track of the values
   that will result from evaluating relocations.  The standard ELF
   relocation structure is not sufficient for this purpose because we're
   operating on multiple input files at once, so we need to know which
   input file a relocation refers to.  The r_reloc structure thus
   records both the input file (bfd) and ELF relocation.
a3631 3
   For efficiency, an r_reloc also contains a "target_offset" field to
   cache the target-section-relative offset value that is represented by
   the relocation.  */
d3633 16
a3648 1
typedef struct r_reloc_struct r_reloc;
d3650 4
a3653 6
struct r_reloc_struct
{
  bfd *abfd;
  Elf_Internal_Rela rela;
  bfd_vma target_offset;
};
d3655 4
a3658 12
static bfd_boolean r_reloc_is_const
  PARAMS ((const r_reloc *));
static void r_reloc_init
  PARAMS ((r_reloc *, bfd *, Elf_Internal_Rela *));
static bfd_vma r_reloc_get_target_offset
  PARAMS ((const r_reloc *));
static asection *r_reloc_get_section
  PARAMS ((const r_reloc *));
static bfd_boolean r_reloc_is_defined
  PARAMS ((const r_reloc *));
static struct elf_link_hash_entry *r_reloc_get_hash_entry
  PARAMS ((const r_reloc *));
d3660 2
a3662 5
/* The r_reloc structure is included by value in literal_value, but not
   every literal_value has an associated relocation -- some are simple
   constants.  In such cases, we set all the fields in the r_reloc
   struct to zero.  The r_reloc_is_const function should be used to
   detect this case.  */
d3665 3
a3667 2
r_reloc_is_const (r_rel)
     const r_reloc *r_rel;
d3669 3
a3671 1
  return (r_rel->abfd == NULL);
d3674 11
d3686 2
a3687 5
static void
r_reloc_init (r_rel, abfd, irel) 
     r_reloc *r_rel;
     bfd *abfd;
     Elf_Internal_Rela *irel;
d3689 4
a3692 9
  if (irel != NULL)
    {
      r_rel->rela = *irel;
      r_rel->abfd = abfd;
      r_rel->target_offset = r_reloc_get_target_offset (r_rel);
    }
  else
    memset (r_rel, 0, sizeof (r_reloc));
}
d3694 18
d3713 1
a3713 3
static bfd_vma
r_reloc_get_target_offset (r_rel)
     const r_reloc *r_rel;
d3715 12
a3726 2
  bfd_vma target_offset;
  unsigned long r_symndx;
a3727 5
  BFD_ASSERT (!r_reloc_is_const (r_rel));
  r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  target_offset = get_elf_r_symndx_offset (r_rel->abfd, r_symndx);
  return (target_offset + r_rel->rela.r_addend);
}
d3729 5
d3735 6
a3740 3
static struct elf_link_hash_entry *
r_reloc_get_hash_entry (r_rel)
     const r_reloc *r_rel;
d3742 4
a3745 3
  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  return get_elf_r_symndx_hash_entry (r_rel->abfd, r_symndx);
}
d3747 4
d3752 7
a3758 7
static asection *
r_reloc_get_section (r_rel)
     const r_reloc *r_rel;
{
  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
  return get_elf_r_symndx_section (r_rel->abfd, r_symndx);
}
d3760 1
d3762 1
a3762 8
static bfd_boolean
r_reloc_is_defined (r_rel)
     const r_reloc *r_rel;
{
  asection *sec = r_reloc_get_section (r_rel);
  if (sec == bfd_abs_section_ptr
      || sec == bfd_com_section_ptr
      || sec == bfd_und_section_ptr)
a3763 2
  return TRUE;
}
d3765 7
a3771 2

/* source_reloc: relocations that reference literal sections.  */
d3773 2
a3774 5
/* To determine whether literals can be coalesced, we need to first
   record all the relocations that reference the literals.  The
   source_reloc structure below is used for this purpose.  The
   source_reloc entries are kept in a per-literal-section array, sorted
   by offset within the literal section (i.e., target offset).
d3776 6
a3781 8
   The source_sec and r_rel.rela.r_offset fields identify the source of
   the relocation.  The r_rel field records the relocation value, i.e.,
   the offset of the literal being referenced.  The opnd field is needed
   to determine the range of the immediate field to which the relocation
   applies, so we can determine whether another literal with the same
   value is within range.  The is_null field is true when the relocation
   is being removed (e.g., when an L32R is being removed due to a CALLX
   that is converted to a direct CALL).  */
d3783 3
a3785 1
typedef struct source_reloc_struct source_reloc;
d3787 5
a3791 7
struct source_reloc_struct
{
  asection *source_sec;
  r_reloc r_rel;
  xtensa_operand opnd;
  bfd_boolean is_null;
};
d3793 3
d3797 6
a3802 6
static void init_source_reloc
  PARAMS ((source_reloc *, asection *, const r_reloc *, xtensa_operand));
static source_reloc *find_source_reloc
  PARAMS ((source_reloc *, int, asection *, Elf_Internal_Rela *));
static int source_reloc_compare
  PARAMS ((const PTR, const PTR));
d3804 3
d3808 4
a3811 12
static void
init_source_reloc (reloc, source_sec, r_rel, opnd)
     source_reloc *reloc;
     asection *source_sec;
     const r_reloc *r_rel;
     xtensa_operand opnd;
{
  reloc->source_sec = source_sec;
  reloc->r_rel = *r_rel;
  reloc->opnd = opnd;
  reloc->is_null = FALSE;
}
d3813 2
d3816 8
a3823 3
/* Find the source_reloc for a particular source offset and relocation
   type.  Note that the array is sorted by _target_ offset, so this is
   just a linear search.  */
d3825 11
a3835 8
static source_reloc *
find_source_reloc (src_relocs, src_count, sec, irel)
     source_reloc *src_relocs;
     int src_count;
     asection *sec;
     Elf_Internal_Rela *irel;
{
  int i;
d3837 5
a3841 8
  for (i = 0; i < src_count; i++)
    {
      if (src_relocs[i].source_sec == sec
	  && src_relocs[i].r_rel.rela.r_offset == irel->r_offset
	  && (ELF32_R_TYPE (src_relocs[i].r_rel.rela.r_info)
	      == ELF32_R_TYPE (irel->r_info)))
	return &src_relocs[i];
    }
d3843 6
a3848 2
  return NULL;
}
d3850 10
d3861 3
a3863 7
static int
source_reloc_compare (ap, bp)
     const PTR ap;
     const PTR bp;
{
  const source_reloc *a = (const source_reloc *) ap;
  const source_reloc *b = (const source_reloc *) bp;
d3865 7
a3871 1
  return (a->r_rel.target_offset - b->r_rel.target_offset);
a3873 2

/* Literal values and value hash tables.  */
d3875 6
a3880 4
/* Literals with the same value can be coalesced.  The literal_value
   structure records the value of a literal: the "r_rel" field holds the
   information from the relocation on the literal (if there is one) and
   the "value" field holds the contents of the literal word itself.
d3882 11
a3892 5
   The value_map structure records a literal value along with the
   location of a literal holding that value.  The value_map hash table
   is indexed by the literal value, so that we can quickly check if a
   particular literal value has been seen before and is thus a candidate
   for coalescing.  */
d3894 4
a3897 3
typedef struct literal_value_struct literal_value;
typedef struct value_map_struct value_map;
typedef struct value_map_hash_table_struct value_map_hash_table;
d3899 7
a3905 5
struct literal_value_struct
{
  r_reloc r_rel; 
  unsigned long value;
};
d3907 1
a3907 6
struct value_map_struct
{
  literal_value val;			/* The literal value.  */
  r_reloc loc;				/* Location of the literal.  */
  value_map *next;
};
d3909 2
a3910 6
struct value_map_hash_table_struct
{
  unsigned bucket_count;
  value_map **buckets;
  unsigned count;
};
d3912 7
d3920 2
a3921 13
static bfd_boolean is_same_value
  PARAMS ((const literal_value *, const literal_value *, bfd_boolean));
static value_map_hash_table *value_map_hash_table_init
  PARAMS ((void));
static unsigned hash_literal_value
  PARAMS ((const literal_value *));
static unsigned hash_bfd_vma
  PARAMS ((bfd_vma));
static value_map *get_cached_value
  PARAMS ((value_map_hash_table *, const literal_value *, bfd_boolean));
static value_map *add_value_map
  PARAMS ((value_map_hash_table *, const literal_value *, const r_reloc *,
	   bfd_boolean));
d3923 6
d3930 5
a3934 7
static bfd_boolean
is_same_value (src1, src2, final_static_link)
     const literal_value *src1;
     const literal_value *src2;
     bfd_boolean final_static_link;
{
  struct elf_link_hash_entry *h1, *h2;
d3936 5
a3940 2
  if (r_reloc_is_const (&src1->r_rel) != r_reloc_is_const (&src2->r_rel)) 
    return FALSE;
d3942 3
a3944 2
  if (r_reloc_is_const (&src1->r_rel))
    return (src1->value == src2->value);
d3946 6
a3951 3
  if (ELF32_R_TYPE (src1->r_rel.rela.r_info)
      != ELF32_R_TYPE (src2->r_rel.rela.r_info))
    return FALSE;
d3953 3
a3955 3
  if (r_reloc_get_target_offset (&src1->r_rel)
      != r_reloc_get_target_offset (&src2->r_rel))
    return FALSE;
d3957 5
a3961 22
  if (src1->value != src2->value)
    return FALSE;
  
  /* Now check for the same section (if defined) or the same elf_hash
     (if undefined or weak).  */
  h1 = r_reloc_get_hash_entry (&src1->r_rel);
  h2 = r_reloc_get_hash_entry (&src2->r_rel);
  if (r_reloc_is_defined (&src1->r_rel)
      && (final_static_link
	  || ((!h1 || h1->root.type != bfd_link_hash_defweak)
	      && (!h2 || h2->root.type != bfd_link_hash_defweak))))
    {
      if (r_reloc_get_section (&src1->r_rel)
	  != r_reloc_get_section (&src2->r_rel))
	return FALSE;
    }
  else
    {
      /* Require that the hash entries (i.e., symbols) be identical.  */
      if (h1 != h2 || h1 == 0)
	return FALSE;
    }
d3963 2
a3964 2
  return TRUE;
}
d3966 8
d3975 13
a3987 2
/* Must be power of 2.  */
#define INITIAL_HASH_RELOC_BUCKET_COUNT 1024
d3989 9
a3997 4
static value_map_hash_table *
value_map_hash_table_init ()
{
  value_map_hash_table *values;
d3999 10
a4008 2
  values = (value_map_hash_table *)
    bfd_malloc (sizeof (value_map_hash_table));
d4010 2
a4011 4
  values->bucket_count = INITIAL_HASH_RELOC_BUCKET_COUNT;
  values->count = 0;
  values->buckets = (value_map **)
    bfd_zmalloc (sizeof (value_map *) * values->bucket_count);
d4013 7
a4019 1
  return values;
d4023 12
a4034 3
static unsigned
hash_bfd_vma (val) 
     bfd_vma val;
d4036 2
a4037 1
  return (val >> 2) + (val >> 10);
d4041 2
a4042 3
static unsigned
hash_literal_value (src)
     const literal_value *src;
d4044 5
a4048 1
  unsigned hash_val;
d4050 2
a4051 2
  if (r_reloc_is_const (&src->r_rel))
    return hash_bfd_vma (src->value);
d4053 2
a4054 8
  hash_val = (hash_bfd_vma (r_reloc_get_target_offset (&src->r_rel))
	      + hash_bfd_vma (src->value));
  
  /* Now check for the same section and the same elf_hash.  */
  if (r_reloc_is_defined (&src->r_rel))
    hash_val += hash_bfd_vma ((bfd_vma) (unsigned) r_reloc_get_section (&src->r_rel));
  else
    hash_val += hash_bfd_vma ((bfd_vma) (unsigned) r_reloc_get_hash_entry (&src->r_rel));
d4056 19
a4074 1
  return hash_val;
d4077 2
d4080 6
a4085 7
/* Check if the specified literal_value has been seen before.  */

static value_map *
get_cached_value (map, val, final_static_link)
     value_map_hash_table *map;
     const literal_value *val;
     bfd_boolean final_static_link;
d4087 8
a4094 3
  value_map *map_e;
  value_map *bucket;
  unsigned idx;
d4096 1
a4096 4
  idx = hash_literal_value (val);
  idx = idx & (map->bucket_count - 1);
  bucket = map->buckets[idx];
  for (map_e = bucket; map_e; map_e = map_e->next)
d4098 2
a4099 2
      if (is_same_value (&map_e->val, val, final_static_link))
	return map_e;
a4100 2
  return NULL;
}
d4102 5
d4108 22
a4129 2
/* Record a new literal value.  It is illegal to call this if VALUE
   already has an entry here.  */
d4131 3
a4133 9
static value_map *
add_value_map (map, val, loc, final_static_link)
     value_map_hash_table *map;
     const literal_value *val;
     const r_reloc *loc;
     bfd_boolean final_static_link;
{
  value_map **bucket_p;
  unsigned idx;
d4135 4
a4138 1
  value_map *val_e = (value_map *) bfd_zmalloc (sizeof (value_map));
d4140 2
a4141 3
  BFD_ASSERT (get_cached_value (map, val, final_static_link) == NULL);
  val_e->val = *val;
  val_e->loc = *loc;
a4142 3
  idx = hash_literal_value (val);
  idx = idx & (map->bucket_count - 1);
  bucket_p = &map->buckets[idx];
d4144 10
a4153 7
  val_e->next = *bucket_p;
  *bucket_p = val_e;
  map->count++;
  /* FIXME: consider resizing the hash table if we get too many entries */
  
  return val_e;
}
d4155 2
a4156 2

/* Lists of literals being coalesced or removed.  */
d4158 6
a4163 5
/* In the usual case, the literal identified by "from" is being
   coalesced with another literal identified by "to".  If the literal is
   unused and is being removed altogether, "to.abfd" will be NULL.
   The removed_literal entries are kept on a per-section list, sorted
   by the "from" offset field.  */
a4164 2
typedef struct removed_literal_struct removed_literal;
typedef struct removed_literal_list_struct removed_literal_list;
d4166 3
a4168 1
struct removed_literal_struct
d4170 1
a4170 4
  r_reloc from;
  r_reloc to;
  removed_literal *next;
};
d4172 4
a4175 5
struct removed_literal_list_struct
{
  removed_literal *head;
  removed_literal *tail;
};
d4177 3
a4180 6
static void add_removed_literal
  PARAMS ((removed_literal_list *, const r_reloc *, const r_reloc *));
static removed_literal *find_removed_literal
  PARAMS ((removed_literal_list *, bfd_vma));
static bfd_vma offset_with_removed_literals
  PARAMS ((removed_literal_list *, bfd_vma));
d4182 3
d4186 3
a4188 2
/* Record that the literal at "from" is being removed.  If "to" is not
   NULL, the "from" literal is being coalesced with the "to" literal.  */
d4190 5
a4194 5
static void
add_removed_literal (removed_list, from, to)
     removed_literal_list *removed_list;
     const r_reloc *from;
     const r_reloc *to;
d4196 7
a4202 1
  removed_literal *r, *new_r, *next_r;
d4204 1
a4204 11
  new_r = (removed_literal *) bfd_zmalloc (sizeof (removed_literal));

  new_r->from = *from;
  if (to)
    new_r->to = *to;
  else
    new_r->to.abfd = NULL;
  new_r->next = NULL;
  
  r = removed_list->head;
  if (r == NULL) 
d4206 2
a4207 2
      removed_list->head = new_r;
      removed_list->tail = new_r;
d4209 12
a4220 2
  /* Special check for common case of append.  */
  else if (removed_list->tail->from.target_offset < from->target_offset)
d4222 35
a4256 2
      removed_list->tail->next = new_r;
      removed_list->tail = new_r;
d4259 13
a4271 13
    {
      while (r->from.target_offset < from->target_offset
	     && r->next != NULL) 
	{
	  r = r->next;
	}
      next_r = r->next;
      r->next = new_r;
      new_r->next = next_r;
      if (next_r == NULL)
	removed_list->tail = new_r;
    }
}
d4273 5
d4279 2
a4280 2
/* Check if the list of removed literals contains an entry for the
   given address.  Return the entry if found.  */
d4282 1
a4282 11
static removed_literal *
find_removed_literal (removed_list, addr)
     removed_literal_list *removed_list;
     bfd_vma addr;
{
  removed_literal *r = removed_list->head;
  while (r && r->from.target_offset < addr)
    r = r->next;
  if (r && r->from.target_offset == addr)
    return r;
  return NULL;
d4285 2
d4288 1
a4288 3
/* Adjust an offset in a section to compensate for literals that are
   being removed.  Search the list of removed literals and subtract
   4 bytes for every removed literal prior to the given address.  */
d4290 6
a4295 7
static bfd_vma 
offset_with_removed_literals (removed_list, addr)
     removed_literal_list *removed_list;
     bfd_vma addr;
{
  removed_literal *r = removed_list->head;
  unsigned num_bytes = 0;
d4297 7
a4303 2
  if (r == NULL)
    return addr;
d4305 1
a4305 9
  while (r && r->from.target_offset <= addr)
    {
      num_bytes += 4;
      r = r->next;
    }
  if (num_bytes > addr)
    return 0;
  return (addr - num_bytes);
}
d4307 1
a4307 13

/* Coalescing literals may require a relocation to refer to a section in
   a different input file, but the standard relocation information
   cannot express that.  Instead, the reloc_bfd_fix structures are used
   to "fix" the relocations that refer to sections in other input files.
   These structures are kept on per-section lists.  The "src_type" field
   records the relocation type in case there are multiple relocations on
   the same location.  FIXME: This is ugly; an alternative might be to
   add new symbols with the "owner" field to some other input file.  */

typedef struct reloc_bfd_fix_struct reloc_bfd_fix;

struct reloc_bfd_fix_struct
d4309 2
a4310 6
  asection *src_sec;
  bfd_vma src_offset;
  unsigned src_type;			/* Relocation type.  */
  
  bfd *target_abfd;
  asection *target_sec;
d4312 1
a4312 2
  
  reloc_bfd_fix *next;
d4315 16
a4331 4
static reloc_bfd_fix *reloc_bfd_fix_init
  PARAMS ((asection *, bfd_vma, unsigned, bfd *, asection *, bfd_vma));
static reloc_bfd_fix *get_bfd_fix
  PARAMS ((reloc_bfd_fix *, asection *, bfd_vma, unsigned));
d4333 5
d4339 3
a4341 9
static reloc_bfd_fix *
reloc_bfd_fix_init (src_sec, src_offset, src_type,
		    target_abfd, target_sec, target_offset)
     asection *src_sec;
     bfd_vma src_offset;
     unsigned src_type;
     bfd *target_abfd;
     asection *target_sec;
     bfd_vma target_offset;
d4343 1
a4343 11
  reloc_bfd_fix *fix;

  fix = (reloc_bfd_fix *) bfd_malloc (sizeof (reloc_bfd_fix));
  fix->src_sec = src_sec;
  fix->src_offset = src_offset;
  fix->src_type = src_type;
  fix->target_abfd = target_abfd;
  fix->target_sec = target_sec;
  fix->target_offset = target_offset;

  return fix;
d4347 7
a4353 6
static reloc_bfd_fix *
get_bfd_fix (fix_list, sec, offset, type)
     reloc_bfd_fix *fix_list;
     asection *sec;
     bfd_vma offset;
     unsigned type;
d4355 2
a4356 1
  reloc_bfd_fix *r;
d4358 1
a4358 1
  for (r = fix_list; r != NULL; r = r->next) 
d4360 14
a4373 4
      if (r->src_sec == sec
	  && r->src_offset == offset
	  && r->src_type == type)
	return r;
d4375 2
a4376 1
  return NULL;
a4378 2

/* Per-section data for relaxation.  */
d4380 3
a4382 1
struct xtensa_relax_info_struct
d4384 2
a4385 2
  bfd_boolean is_relaxable_literal_section;
  int visited;				/* Number of times visited.  */
d4387 5
a4391 3
  source_reloc *src_relocs;		/* Array[src_count].  */
  int src_count;
  int src_next;				/* Next src_relocs entry to assign.  */
a4392 1
  removed_literal_list removed_list;
d4394 8
a4401 2
  reloc_bfd_fix *fix_list;
};
d4403 3
a4405 1
struct elf_xtensa_section_data
d4407 3
a4409 10
  struct bfd_elf_section_data elf;
  xtensa_relax_info relax_info;
};

static void init_xtensa_relax_info
  PARAMS ((asection *));
static xtensa_relax_info *get_xtensa_relax_info
  PARAMS ((asection *));
static void add_fix
  PARAMS ((asection *, reloc_bfd_fix *));
d4413 2
a4414 3
elf_xtensa_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d4416 3
a4418 2
  struct elf_xtensa_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d4420 4
a4423 2
  sdata = (struct elf_xtensa_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
d4425 2
a4426 1
  sec->used_by_bfd = (PTR) sdata;
a4427 2
  return _bfd_elf_new_section_hook (abfd, sec);
}
d4429 1
d4432 3
a4434 2
init_xtensa_relax_info (sec)
     asection *sec;
d4436 19
a4454 1
  xtensa_relax_info *relax_info = get_xtensa_relax_info (sec);
d4456 1
a4456 2
  relax_info->is_relaxable_literal_section = FALSE;
  relax_info->visited = 0;
d4458 2
a4459 3
  relax_info->src_relocs = NULL;
  relax_info->src_count = 0;
  relax_info->src_next = 0;
d4461 5
a4465 2
  relax_info->removed_list.head = NULL;
  relax_info->removed_list.tail = NULL;
d4467 8
a4474 2
  relax_info->fix_list = NULL;
}
d4476 1
d4478 1
a4478 3
static xtensa_relax_info *
get_xtensa_relax_info (sec)
     asection *sec;
d4480 7
a4486 1
  struct elf_xtensa_section_data *section_data;
a4487 3
  /* No info available if no section or if it is an output section.  */
  if (!sec || sec == sec->output_section)
    return NULL;
d4489 7
a4495 3
  section_data = (struct elf_xtensa_section_data *) elf_section_data (sec);
  return &section_data->relax_info;
}
d4499 7
a4505 3
add_fix (src_sec, fix)
     asection *src_sec;
     reloc_bfd_fix *fix;
d4507 6
a4512 5
  xtensa_relax_info *relax_info;

  relax_info = get_xtensa_relax_info (src_sec);
  fix->next = relax_info->fix_list;
  relax_info->fix_list = fix;
a4514 2

/* Access to internal relocations, section contents and symbols.  */
d4516 3
a4518 6
/* During relaxation, we need to modify relocations, section contents,
   and symbol definitions, and we need to keep the original values from
   being reloaded from the input files, i.e., we need to "pin" the
   modified values in memory.  We also want to continue to observe the
   setting of the "keep-memory" flag.  The following functions wrap the
   standard BFD functions to take care of this for us.  */
d4520 4
a4523 3
static Elf_Internal_Rela *
retrieve_internal_relocs (abfd, sec, keep_memory)
     bfd *abfd;
d4525 1
a4525 1
     bfd_boolean keep_memory;
d4527 1
a4527 1
  Elf_Internal_Rela *internal_relocs;
d4529 8
a4536 2
  if ((sec->flags & SEC_LINKER_CREATED) != 0)
    return NULL;
d4538 1
a4538 6
  internal_relocs = elf_section_data (sec)->relocs;
  if (internal_relocs == NULL)
    internal_relocs = (_bfd_elf_link_read_relocs
		       (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			keep_memory));
  return internal_relocs;
d4542 4
a4545 4
static void
pin_internal_relocs (sec, internal_relocs)
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
d4547 16
a4562 1
  elf_section_data (sec)->relocs = internal_relocs;
d4565 17
d4583 1
a4583 4
static void
release_internal_relocs (sec, internal_relocs)
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
d4585 4
a4588 4
  if (internal_relocs
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
}
d4590 6
d4597 1
a4597 5
static bfd_byte *
retrieve_contents (abfd, sec, keep_memory)
     bfd *abfd;
     asection *sec;
     bfd_boolean keep_memory;
d4599 7
a4605 1
  bfd_byte *contents;
d4607 17
a4623 15
  contents = elf_section_data (sec)->this_hdr.contents;
  
  if (contents == NULL && sec->size != 0)
    {
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	{
	  if (contents != NULL)
	    free (contents);
	  return NULL;
	}
      if (keep_memory) 
	elf_section_data (sec)->this_hdr.contents = contents;
    }
  return contents;
}
d4627 5
a4631 3
pin_contents (sec, contents)
     asection *sec;
     bfd_byte *contents;
d4633 3
a4635 1
  elf_section_data (sec)->this_hdr.contents = contents;
d4639 5
a4643 4
static void
release_contents (sec, contents)
     asection *sec;
     bfd_byte *contents;
d4645 45
a4689 3
  if (contents && 
      elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
d4693 5
a4697 3
static Elf_Internal_Sym *
retrieve_local_syms (input_bfd)
     bfd *input_bfd;
d4699 1
a4699 3
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf;
  size_t locsymcount;
d4701 12
a4712 2
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  locsymcount = symtab_hdr->sh_info;
d4714 2
a4715 4
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				    NULL, NULL, NULL);
a4716 3
  /* Save the symbols for this input file so they won't be read again.  */
  if (isymbuf && isymbuf != (Elf_Internal_Sym *) symtab_hdr->contents)
    symtab_hdr->contents = (unsigned char *) isymbuf;
d4718 6
a4723 1
  return isymbuf;
a4725 2

/* Code for link-time relaxation.  */
d4727 6
a4732 29
/* Local helper functions.  */
static bfd_boolean analyze_relocations
  PARAMS ((struct bfd_link_info *));
static bfd_boolean find_relaxable_sections
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean collect_source_relocs
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
static bfd_boolean is_resolvable_asm_expansion
  PARAMS ((bfd *, asection *, bfd_byte *, Elf_Internal_Rela *,
	   struct bfd_link_info *, bfd_boolean *));
static bfd_boolean remove_literals
  PARAMS ((bfd *, asection *, struct bfd_link_info *, value_map_hash_table *));
static bfd_boolean relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
static bfd_boolean relax_property_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *));
static bfd_boolean relax_section_symbols
  PARAMS ((bfd *, asection *));
static bfd_boolean relocations_reach
  PARAMS ((source_reloc *, int, const r_reloc *));
static void translate_reloc
  PARAMS ((const r_reloc *, r_reloc *));
static Elf_Internal_Rela *get_irel_at_offset
  PARAMS ((asection *, Elf_Internal_Rela *, bfd_vma));
static Elf_Internal_Rela *find_associated_l32r_irel
  PARAMS ((asection *, bfd_byte *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *));
static void shrink_dynamic_reloc_sections
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *));
d4735 3
a4737 6
static bfd_boolean 
elf_xtensa_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d4739 1
a4739 2
  static value_map_hash_table *values = NULL;
  xtensa_relax_info *relax_info;
d4741 2
a4742 1
  if (!values)
d4744 12
a4755 5
      /* Do some overall initialization for relaxation.  */
      values = value_map_hash_table_init ();
      relaxing_section = TRUE;
      if (!analyze_relocations (link_info))
	return FALSE;
d4757 3
a4759 1
  *again = FALSE;
d4761 1
a4761 3
  /* Don't mess with linker-created sections.  */
  if ((sec->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;
d4763 9
a4771 2
  relax_info = get_xtensa_relax_info (sec);
  BFD_ASSERT (relax_info != NULL);
d4773 4
a4776 1
  switch (relax_info->visited)
d4778 9
a4786 8
    case 0:
      /* Note: It would be nice to fold this pass into
	 analyze_relocations, but it is important for this step that the
	 sections be examined in link order.  */
      if (!remove_literals (abfd, sec, link_info, values))
	return FALSE;
      *again = TRUE;
      break;
d4788 9
a4796 5
    case 1:
      if (!relax_section (abfd, sec, link_info))
	return FALSE;
      *again = TRUE;
      break;
d4798 5
a4802 4
    case 2:
      if (!relax_section_symbols (abfd, sec))
	return FALSE;
      break;
d4805 14
a4818 2
  relax_info->visited++;
  return TRUE;
d4821 114
a4934 1
/* Initialization for relaxation.  */
a4935 5
/* This function is called once at the start of relaxation.  It scans
   all the input sections and marks the ones that are relaxable (i.e.,
   literal sections with L32R relocations against them).  It then
   collect source_reloc information for all the relocations against
   those relaxable sections.  */
d4937 7
a4943 3
static bfd_boolean
analyze_relocations (link_info)
     struct bfd_link_info *link_info;
d4945 5
a4949 3
  bfd *abfd;
  asection *sec;
  bfd_boolean is_relaxable = FALSE;
d4951 2
a4952 6
  /* Initialize the per-section relaxation info.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	init_xtensa_relax_info (sec);
      }
d4954 1773
a6726 7
  /* Mark relaxable sections (and count relocations against each one).  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	if (!find_relaxable_sections (abfd, sec, link_info, &is_relaxable))
	  return FALSE;
      }
a6727 3
  /* Bail out if there are no relaxable sections.  */
  if (!is_relaxable)
    return TRUE;
d6729 9
a6737 5
  /* Allocate space for source_relocs.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	xtensa_relax_info *relax_info;
d6739 3
a6741 7
	relax_info = get_xtensa_relax_info (sec);
	if (relax_info->is_relaxable_literal_section)
	  {
	    relax_info->src_relocs = (source_reloc *)
	      bfd_malloc (relax_info->src_count * sizeof (source_reloc));
	  }
      }
d6743 7
a6749 7
  /* Collect info on relocations against each relaxable section.  */
  for (abfd = link_info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    for (sec = abfd->sections; sec != NULL; sec = sec->next)
      {
	if (!collect_source_relocs (abfd, sec, link_info))
	  return FALSE;
      }
d6751 1
a6751 1
  return TRUE;
d6755 10
a6764 9
/* Find all the literal sections that might be relaxed.  The motivation
   for this pass is that collect_source_relocs() needs to record _all_
   the relocations that target each relaxable section.  That is
   expensive and unnecessary unless the target section is actually going
   to be relaxed.  This pass identifies all such sections by checking if
   they have L32Rs pointing to them.  In the process, the total number
   of relocations targeting each section is also counted so that we
   know how much space to allocate for source_relocs against each
   relaxable literal section.  */
d6766 2
a6767 2
static bfd_boolean
find_relaxable_sections (abfd, sec, link_info, is_relaxable_p)
a6770 1
     bfd_boolean *is_relaxable_p;
d6772 2
a6774 1
  bfd_byte *contents;
d6777 13
a6792 2
  if (internal_relocs == NULL) 
    return ok;
d6794 5
d6800 9
a6808 1
  if (contents == NULL && sec->size != 0)
d6814 1
a6814 1
  for (i = 0; i < sec->reloc_count; i++) 
d6817 6
a6822 3
      r_reloc r_rel;
      asection *target_sec;
      xtensa_relax_info *target_relax_info;
d6824 3
a6826 1
      r_reloc_init (&r_rel, abfd, irel);
d6828 8
a6835 4
      target_sec = r_reloc_get_section (&r_rel);
      target_relax_info = get_xtensa_relax_info (target_sec);
      if (!target_relax_info)
	continue;
d6837 11
a6847 2
      /* Count relocations against the target section.  */
      target_relax_info->src_count++;
d6849 8
a6856 3
      if (is_literal_section (target_sec)
	  && is_l32r_relocation (sec, contents, irel)
	  && r_reloc_is_defined (&r_rel))
d6858 35
a6892 3
	  /* Mark the target section as relaxable.  */
	  target_relax_info->is_relaxable_literal_section = TRUE;
	  *is_relaxable_p = TRUE;
d6894 7
d6903 6
a6908 1
 error_return:
d6911 3
d6918 1
a6918 3
/* Record _all_ the relocations that point to relaxable literal
   sections, and get rid of ASM_EXPAND relocs by either converting them
   to ASM_SIMPLIFY or by removing them.  */
d6920 3
a6922 5
static bfd_boolean
collect_source_relocs (abfd, sec, link_info)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
d6924 3
a6926 4
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents;
  bfd_boolean ok = TRUE;
  unsigned i;
d6928 2
a6929 4
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
					      link_info->keep_memory);
  if (internal_relocs == NULL) 
    return ok;
d6931 1
a6931 2
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec->size != 0)
d6933 19
a6951 3
      ok = FALSE;
      goto error_return;
    }
d6953 2
a6954 7
  /* Record relocations against relaxable literal sections.  */
  for (i = 0; i < sec->reloc_count; i++) 
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      r_reloc r_rel;
      asection *target_sec;
      xtensa_relax_info *target_relax_info;
d6956 10
a6965 1
      r_reloc_init (&r_rel, abfd, irel);
d6967 3
a6969 2
      target_sec = r_reloc_get_section (&r_rel);
      target_relax_info = get_xtensa_relax_info (target_sec);
d6971 1
a6971 2
      if (target_relax_info
	  && target_relax_info->is_relaxable_literal_section)
d6973 1
a6974 3
	  xtensa_operand opnd;
	  source_reloc *s_reloc;
	  int src_next;
d6976 31
a7006 2
	  src_next = target_relax_info->src_next++;
	  s_reloc = &target_relax_info->src_relocs[src_next];
d7008 42
a7049 6
	  opcode = get_relocation_opcode (sec, contents, irel);
	  if (opcode == XTENSA_UNDEFINED)
	    opnd = NULL;
	  else
	    opnd = xtensa_get_operand (xtensa_default_isa, opcode,
				       get_relocation_opnd (irel));
d7051 1
a7051 1
	  init_source_reloc (s_reloc, sec, &r_rel, opnd);
d7055 5
a7059 5
  /* Now get rid of ASM_EXPAND relocations.  At this point, the
     src_relocs array for the target literal section may still be
     incomplete, but it must at least contain the entries for the L32R
     relocations associated with ASM_EXPANDs because they were just
     added in the preceding loop over the relocations.  */
d7061 2
a7062 4
  for (i = 0; i < sec->reloc_count; i++) 
    {
      Elf_Internal_Rela *irel = &internal_relocs[i];
      bfd_boolean is_reachable;
a7063 3
      if (!is_resolvable_asm_expansion (abfd, sec, contents, irel, link_info,
					&is_reachable))
	continue;
d7065 16
a7080 6
      if (is_reachable)
	{
	  Elf_Internal_Rela *l32r_irel;
	  r_reloc r_rel;
	  asection *target_sec;
	  xtensa_relax_info *target_relax_info;
d7082 51
a7132 7
	  /* Mark the source_reloc for the L32R so that it will be
	     removed in remove_literals(), along with the associated
	     literal.  */
	  l32r_irel = find_associated_l32r_irel (sec, contents,
						 irel, internal_relocs);
	  if (l32r_irel == NULL)
	    continue;
d7134 2
a7135 1
	  r_reloc_init (&r_rel, abfd, l32r_irel);
d7137 14
a7150 2
	  target_sec = r_reloc_get_section (&r_rel);
	  target_relax_info = get_xtensa_relax_info (target_sec);
d7152 1
a7152 2
	  if (target_relax_info
	      && target_relax_info->is_relaxable_literal_section)
d7154 22
a7175 1
	      source_reloc *s_reloc;
d7177 33
a7209 9
	      /* Search the source_relocs for the entry corresponding to
		 the l32r_irel.  Note: The src_relocs array is not yet
		 sorted, but it wouldn't matter anyway because we're
		 searching by source offset instead of target offset.  */
	      s_reloc = find_source_reloc (target_relax_info->src_relocs, 
					   target_relax_info->src_next,
					   sec, l32r_irel);
	      BFD_ASSERT (s_reloc);
	      s_reloc->is_null = TRUE;
d7211 5
d7217 7
a7223 4
	  /* Convert this reloc to ASM_SIMPLIFY.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       R_XTENSA_ASM_SIMPLIFY);
	  l32r_irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
d7225 61
a7285 9
	  pin_internal_relocs (sec, internal_relocs);
	}
      else
	{
	  /* It is resolvable but doesn't reach.  We resolve now
	     by eliminating the relocation -- the call will remain
	     expanded into L32R/CALLX.  */
	  irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	  pin_internal_relocs (sec, internal_relocs);
d7289 27
a7315 4
 error_return:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  return ok;
d7319 3
a7321 5
/* Return TRUE if the asm expansion can be resolved.  Generally it can
   be resolved on a final link or when a partial link locates it in the
   same section as the target.  Set "is_reachable" flag if the target of
   the call is within the range of a direct call, given the current VMA
   for this section and the target section.  */
d7323 2
a7324 3
bfd_boolean
is_resolvable_asm_expansion (abfd, sec, contents, irel, link_info,
			     is_reachable_p)
d7328 2
a7329 3
     Elf_Internal_Rela *irel;
     struct bfd_link_info *link_info;
     bfd_boolean *is_reachable_p;
d7331 66
a7396 6
  asection *target_sec;
  bfd_vma target_offset;
  r_reloc r_rel;
  xtensa_opcode opcode, direct_call_opcode;
  bfd_vma self_address;
  bfd_vma dest_address;
d7398 10
a7407 1
  *is_reachable_p = FALSE;
d7409 3
a7411 2
  if (contents == NULL)
    return FALSE;
d7413 3
a7415 9
  if (ELF32_R_TYPE (irel->r_info) != R_XTENSA_ASM_EXPAND) 
    return FALSE;
  
  opcode = get_expanded_call_opcode (contents + irel->r_offset,
				     sec->size - irel->r_offset);
  
  direct_call_opcode = swap_callx_for_call_opcode (opcode);
  if (direct_call_opcode == XTENSA_UNDEFINED)
    return FALSE;
d7417 4
a7420 4
  /* Check and see that the target resolves.  */
  r_reloc_init (&r_rel, abfd, irel);
  if (!r_reloc_is_defined (&r_rel))
    return FALSE;
d7422 2
a7423 2
  target_sec = r_reloc_get_section (&r_rel);
  target_offset = r_reloc_get_target_offset (&r_rel);
a7424 13
  /* If the target is in a shared library, then it doesn't reach.  This
     isn't supposed to come up because the compiler should never generate
     non-PIC calls on systems that use shared libraries, but the linker
     shouldn't crash regardless.  */
  if (!target_sec->output_section)
    return FALSE;
      
  /* For relocatable sections, we can only simplify when the output
     section of the target is the same as the output section of the
     source.  */
  if (link_info->relocatable
      && (target_sec->output_section != sec->output_section))
    return FALSE;
d7426 6
a7431 8
  self_address = (sec->output_section->vma
		  + sec->output_offset + irel->r_offset + 3);
  dest_address = (target_sec->output_section->vma
		  + target_sec->output_offset + target_offset);
      
  *is_reachable_p = pcrel_reloc_fits
    (xtensa_get_operand (xtensa_default_isa, direct_call_opcode, 0),
     self_address, dest_address);
d7433 7
a7439 2
  if ((self_address >> CALL_SEGMENT_BITS) !=
      (dest_address >> CALL_SEGMENT_BITS))
d7446 4
a7449 2
static Elf_Internal_Rela *
find_associated_l32r_irel (sec, contents, other_irel, internal_relocs)
a7450 3
     bfd_byte *contents;
     Elf_Internal_Rela *other_irel;
     Elf_Internal_Rela *internal_relocs;
d7454 1
a7454 1
  for (i = 0; i < sec->reloc_count; i++) 
d7456 1
a7456 1
      Elf_Internal_Rela *irel = &internal_relocs[i];
d7458 1
a7458 1
      if (irel == other_irel)
d7460 18
a7477 4
      if (irel->r_offset != other_irel->r_offset)
	continue;
      if (is_l32r_relocation (sec, contents, irel))
	return irel;
d7479 14
d7494 12
a7505 1
  return NULL;
d7508 1
d7511 4
a7514 4
/* If the section is relaxable (i.e., a literal section), check each
   literal to see if it has the same value as another literal that has
   already been seen, either in the current section or a previous one.
   If so, add an entry to the per-section list of removed literals.  The
d7518 1
a7518 1
remove_literals (abfd, sec, link_info, values)
d7527 1
a7527 2
  source_reloc *src_relocs;
  bfd_boolean final_static_link;
d7529 9
a7537 1
  int i;
a7541 1

d7548 1
d7550 1
a7550 1
  if (contents == NULL && sec->size != 0)
a7555 4
  final_static_link =
    (!link_info->relocatable
     && !elf_hash_table (link_info)->dynamic_sections_created);

d7560 10
d7571 1
a7573 1
      source_reloc *rel;
a7574 2
      literal_value val;
      value_map *val_map;
d7577 2
d7582 7
d7592 2
a7593 2
      if (i != 0 && (src_relocs[i-1].r_rel.target_offset
		     == rel->r_rel.target_offset))
d7595 5
d7604 1
a7604 4
      if (rel->is_null
	  && (i == relax_info->src_count - 1
	      || (src_relocs[i+1].r_rel.target_offset
		  != rel->r_rel.target_offset)))
d7606 78
a7683 2
	  /* Mark the unused literal so that it will be removed.  */
	  add_removed_literal (&relax_info->removed_list, &rel->r_rel, NULL);
d7685 133
a7817 5
	  /* Zero out the relocation on this literal location.  */
	  if (irel)
	    {
	      if (elf_hash_table (link_info)->dynamic_sections_created)
		shrink_dynamic_reloc_sections (link_info, abfd, sec, irel);
d7819 3
a7821 2
	      irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
	    }
d7823 51
a7873 23
	  continue;
	}

      /* Find the literal value.  */
      r_reloc_init (&val.r_rel, abfd, irel);
      BFD_ASSERT (rel->r_rel.target_offset < sec->size);
      val.value = bfd_get_32 (abfd, contents + rel->r_rel.target_offset);
          
      /* Check if we've seen another literal with the same value.  */
      val_map = get_cached_value (values, &val, final_static_link);
      if (val_map != NULL) 
	{
	  /* First check that THIS and all the other relocs to this
	     literal will FIT if we move them to the new address.  */

	  if (relocations_reach (rel, relax_info->src_count - i,
				 &val_map->loc))
	    {
	      /* Mark that the literal will be coalesced.  */
	      add_removed_literal (&relax_info->removed_list,
				   &rel->r_rel, &val_map->loc);
	    }
	  else
d7875 7
a7881 2
	      /* Relocations do not reach -- do not remove this literal.  */
	      val_map->loc = rel->r_rel;
d7884 9
d7894 2
a7895 5
	{
	  /* This is the first time we've seen this literal value.  */
	  BFD_ASSERT (sec == r_reloc_get_section (&rel->r_rel));
	  add_value_map (values, &val, &rel->r_rel, final_static_link);
	}
d7898 1
a7898 4
error_return:
  release_contents (sec, contents);
  release_internal_relocs (sec, internal_relocs);
  return ok;
d7944 2
a7945 3
      /* A NULL operand means it is not a PC-relative relocation, so
         the literal can be moved anywhere.  */
      if (reloc[i].opnd)
d7955 2
a7956 1
	  if (!pcrel_reloc_fits (reloc[i].opnd, source_address, dest_address))
d7965 68
a8032 3
/* WARNING: linear search here.  If the relocation are in order by
   address, we can use a faster binary search.  ALSO, we assume that
   there is only 1 non-NONE relocation per address.  */
d8034 3
a8036 2
static Elf_Internal_Rela *
get_irel_at_offset (sec, internal_relocs, offset)
d8038 115
a8152 7
     Elf_Internal_Rela *internal_relocs;
     bfd_vma offset;
{
  unsigned i;
  if (!internal_relocs) 
    return NULL;
  for (i = 0; i < sec->reloc_count; i++)
d8154 24
a8177 4
      Elf_Internal_Rela *irel = &internal_relocs[i];
      if (irel->r_offset == offset
	  && ELF32_R_TYPE (irel->r_info) != R_XTENSA_NONE)
	return irel;
d8179 2
a8180 1
  return NULL;
d8188 1
a8188 1
   cooked_size.  */
d8190 1
a8190 1
bfd_boolean 
d8201 3
d8205 1
d8209 3
d8214 423
a8636 4
    {
      BFD_ASSERT (!relax_info->is_relaxable_literal_section);
      return relax_property_section (abfd, sec, link_info);
    }
d8638 3
a8640 8
  internal_relocs = retrieve_internal_relocs (abfd, sec, 
					      link_info->keep_memory);
  contents = retrieve_contents (abfd, sec, link_info->keep_memory);
  if (contents == NULL && sec->size != 0)
    {
      ok = FALSE;
      goto error_return;
    }
d8642 2
a8643 10
  if (internal_relocs)
    {
      for (i = 0; i < sec->reloc_count; i++) 
	{
	  Elf_Internal_Rela *irel;
	  xtensa_relax_info *target_relax_info;
	  bfd_vma source_offset;
	  r_reloc r_rel;
	  unsigned r_type;
	  asection *target_sec;
a8644 5
	  /* Locally change the source address.
	     Translate the target to the new target address.
	     If it points to this section and has been removed,
	     NULLify it.
	     Write it back.  */
d8646 2
a8647 2
	  irel = &internal_relocs[i];
	  source_offset = irel->r_offset;
d8649 9
a8657 22
	  r_type = ELF32_R_TYPE (irel->r_info);
	  r_reloc_init (&r_rel, abfd, irel);
	
	  if (relax_info->is_relaxable_literal_section)
	    {
	      if (r_type != R_XTENSA_NONE
		  && find_removed_literal (&relax_info->removed_list,
					   irel->r_offset))
		{
		  /* Remove this relocation.  */
		  if (elf_hash_table (link_info)->dynamic_sections_created)
		    shrink_dynamic_reloc_sections (link_info, abfd, sec, irel);
		  irel->r_info = ELF32_R_INFO (0, R_XTENSA_NONE);
		  irel->r_offset = offset_with_removed_literals
		    (&relax_info->removed_list, irel->r_offset);
		  continue;
		}
	      source_offset =
		offset_with_removed_literals (&relax_info->removed_list,
					      irel->r_offset);
	      irel->r_offset = source_offset;
	    }
d8659 2
a8660 2
	  target_sec = r_reloc_get_section (&r_rel);
	  target_relax_info = get_xtensa_relax_info (target_sec);
d8662 2
a8663 5
	  if (target_relax_info
	      && target_relax_info->is_relaxable_literal_section)
	    {
	      r_reloc new_rel;
	      reloc_bfd_fix *fix;
d8665 6
a8670 1
	      translate_reloc (&r_rel, &new_rel);
d8672 1
a8672 3
	      /* FIXME: If the relocation still references a section in
		 the same input file, the relocation should be modified
		 directly instead of adding a "fix" record.  */
d8674 7
a8680 5
	      fix = reloc_bfd_fix_init (sec, source_offset, r_type, 0,
					r_reloc_get_section (&new_rel),
					new_rel.target_offset);
	      add_fix (sec, fix);
	    }
d8682 12
a8693 2
	  pin_internal_relocs (sec, internal_relocs);
	}
d8696 1
a8696 1
  if (relax_info->is_relaxable_literal_section)
d8698 1
a8698 2
      /* Walk through the contents and delete literals that are not needed 
         anymore.  */
d8700 3
a8702 2
      unsigned long size = sec->size;
      unsigned long removed = 0;
d8704 16
a8719 14
      removed_literal *reloc = relax_info->removed_list.head;
      for (; reloc; reloc = reloc->next) 
	{
	  unsigned long upper = sec->size;
	  bfd_vma start = reloc->from.target_offset + 4;
	  if (reloc->next)
	    upper = reloc->next->from.target_offset;
	  if (upper - start != 0) 
	    {
	      BFD_ASSERT (start <= upper);
	      memmove (contents + start - removed - 4,
		       contents + start,
		       upper - start );
	      pin_contents (sec, contents);
a8720 2
	  removed += 4;
	  size -= 4;
d8722 3
d8726 9
a8734 8
      /* Change the section size.  */
      sec->size = size;
    }
  
 error_return:
  release_internal_relocs (sec, internal_relocs);
  release_contents (sec, contents);
  return ok;
d8748 1
a8748 1
  unsigned long new_offset;
d8759 2
a8760 1
  if (!relax_info->is_relaxable_literal_section)
d8763 11
a8773 4
  /* Check if the original relocation is against a literal being removed.  */
  removed = find_removed_literal (&relax_info->removed_list,
				  orig_rel->target_offset);
  if (removed) 
d8781 2
a8782 1
      /* This was moved to some other address (possibly in another section). */
d8785 1
a8785 1
      if (new_sec != sec) 
d8789 3
a8791 1
	  if (!relax_info || !relax_info->is_relaxable_literal_section)
d8794 1
d8798 2
a8799 2
  new_offset = offset_with_removed_literals (&relax_info->removed_list,
					     new_rel->target_offset);
d8802 1
d8804 1
a8804 1
  new_rel->rela.r_addend += (new_offset - new_rel->target_offset);
d8914 137
d9056 1
a9056 1
static bfd_boolean 
d9066 4
d9071 1
d9075 1
a9075 1
  if (contents == NULL && sec->size != 0)
d9081 6
a9086 1
  if (internal_relocs) 
d9088 1
a9088 1
      for (i = 0; i < sec->reloc_count; i++) 
a9091 1
	  r_reloc r_rel;
d9094 2
d9108 11
a9118 1
	  r_reloc_init (&r_rel, abfd, irel);
d9120 1
a9120 1
	  target_sec = r_reloc_get_section (&r_rel);
d9124 2
a9125 1
	      && target_relax_info->is_relaxable_literal_section)
d9128 1
a9128 3
	      bfd_vma new_offset;
	      bfd_vma new_end_offset;
	      bfd_byte *size_p;
d9131 2
a9132 3
	      new_offset =
		offset_with_removed_literals (&target_relax_info->removed_list,
					      r_rel.target_offset);
d9135 43
a9177 2
	      size_p = &contents[irel->r_offset + 4];
	      old_size = bfd_get_32 (abfd, &contents[irel->r_offset + 4]);
a9178 4
	      new_end_offset =
		offset_with_removed_literals (&target_relax_info->removed_list,
					      r_rel.target_offset + old_size);
	      
d9180 1
d9186 2
a9187 2
	      
	      if (new_offset != r_rel.target_offset)
d9189 1
a9189 1
		  bfd_vma diff = new_offset - r_rel.target_offset;
d9201 2
a9202 1
  if (internal_relocs)
d9208 9
d9229 1
a9229 1
      BFD_ASSERT (section_size % 8 == 0);
d9231 1
a9231 1
      for (offset = 0; offset < section_size; offset += 8)
d9236 1
d9274 5
d9284 4
a9287 2
	  /* Make sure there isn't a reloc on the size field.  */
	  if (irel && irel->r_offset == offset + 4)
d9292 3
a9294 1
	  else if (next_irel && next_irel->r_offset == offset + 4)
d9301 2
a9302 1
	  else if (size == 0)
d9304 2
a9305 2
	      /* Always remove entries with zero size.  */
	      bytes_to_remove = 8;
d9320 2
a9321 1
		      bfd_vma old_size = 
d9323 2
a9324 2
		      bfd_vma old_address = 
			(last_irel->r_addend 
d9326 2
a9327 2
		      bfd_vma new_address = 
			(irel->r_addend 
d9329 5
d9335 6
a9340 3
		      if ((ELF32_R_SYM (irel->r_info) ==
			   ELF32_R_SYM (last_irel->r_info))
			  && (old_address + old_size == new_address)) 
d9342 1
a9342 1
			  /* fix the old size */
d9345 1
a9345 1
			  bytes_to_remove = 8;
d9368 1
a9368 1
	      if (offset + 8 < section_size)
d9370 2
a9371 2
			 &contents[actual_offset+8],
			 section_size - offset - 8);
d9375 1
a9375 1
      if (removed_bytes) 
d9407 1
a9407 1
bfd_boolean 
d9421 2
a9422 1
  if (!relax_info->is_relaxable_literal_section)
d9440 13
a9452 4
	  bfd_vma new_address = offset_with_removed_literals
	    (&relax_info->removed_list, isym->st_value);
	  if (new_address != isym->st_value)
	    isym->st_value = new_address;
d9470 14
a9483 4
	  bfd_vma new_address = offset_with_removed_literals
	    (&relax_info->removed_list, sym_hash->root.u.def.value);
	  if (new_address != sym_hash->root.u.def.value)
	    sym_hash->root.u.def.value = new_address;
d9493 2
a9494 2
static void
do_fix_for_relocatable_link (rel, input_bfd, input_section)
d9498 1
a9503 1
  reloc_bfd_fix *fix_list;
d9507 1
a9507 1
    return;
d9509 3
a9511 3
  fix_list = (get_xtensa_relax_info (input_section))->fix_list;
  if (fix_list == NULL)
    return;
d9513 4
a9516 3
  fix = get_bfd_fix (fix_list, input_section, rel->r_offset, r_type);
  if (fix == NULL)
    return;
d9518 1
a9518 5
  r_reloc_init (&r_rel, input_bfd, rel);
  old_sec = r_reloc_get_section (&r_rel);
  old_offset = r_reloc_get_target_offset (&r_rel);
	      
  if (old_sec == NULL || !r_reloc_is_defined (&r_rel))
d9520 8
a9527 1
      BFD_ASSERT (r_type == R_XTENSA_ASM_EXPAND);
d9536 1
d9541 1
a9541 1
do_fix_for_final_link (rel, input_section, relocationp)
d9543 1
d9545 1
a9549 1
  reloc_bfd_fix *fix_list;
d9551 1
d9556 2
a9557 2
  fix_list = (get_xtensa_relax_info (input_section))->fix_list;
  if (fix_list == NULL)
d9560 11
a9570 3
  fix = get_bfd_fix (fix_list, input_section, rel->r_offset, r_type);
  if (fix == NULL)
    return;
a9571 1
  sec = fix->target_sec;
d9574 1
a9574 1
		  + fix->target_offset - rel->r_addend);
d9625 1
a9625 1
  if (r_symndx < symtab_hdr->sh_info) 
d9641 1
a9641 1
      else 
d9687 1
a9687 1
  
d9707 1
a9707 1
  if (r_symndx < symtab_hdr->sh_info) 
d9731 18
a9748 2
pcrel_reloc_fits (opnd, self_address, dest_address)
     xtensa_operand opnd;
d9752 6
a9757 4
  uint32 new_address =
    xtensa_operand_do_reloc (opnd, dest_address, self_address);
  return (xtensa_operand_encode (opnd, &new_address)
	  == xtensa_encode_result_ok);
d9764 1
d9772 2
a9773 1
      || strncmp (XTENSA_LIT_SEC_NAME, sec->name, lit_sec_len) == 0)
d9777 3
a9779 3
      && (sec->name[linkonce_len] == 'x'
	  || sec->name[linkonce_len] == 'p')
      && sec->name[linkonce_len + 1] == '.')
d9802 4
a9805 3
static bfd_boolean
is_literal_section (sec)
     asection *sec;
d9807 17
a9823 4
  /* FIXME: the current definition of this leaves a lot to be desired....  */
  if (sec == NULL || sec->name == NULL)
    return FALSE;
  return (strstr (sec->name, "literal") != NULL);
d9828 1
a9828 1
internal_reloc_compare (ap, bp)
d9835 2
d9850 1
a9850 1
      char linkonce_kind = 0;
d9853 1
a9853 1
	linkonce_kind = 'x';
d9855 3
a9857 1
	linkonce_kind = 'p';
d9861 2
a9862 1
      prop_sec_name = (char *) bfd_malloc (strlen (sec->name) + 1);
d9864 1
a9864 2
      prop_sec_name[linkonce_len] = linkonce_kind;
      prop_sec_name[linkonce_len + 1] = '.';
d9868 4
a9871 4
	 the new linkonce_kind.  */
      if (strncmp (suffix, "t.", 2) == 0)
	suffix += 2;
      strcpy (prop_sec_name + linkonce_len + 2, suffix);
d9879 20
d9914 3
d9944 1
a9944 1
      (*callback) (sec, sec->size, sgotplt, 0, closure);
d9950 1
a9950 1
      || sec->reloc_count == 0) 
d9955 1
a9955 1
  if (contents == NULL && sec->size != 0)
d9961 2
a9962 2
  if (xtensa_default_isa == NULL)
    xtensa_isa_init ();
d9964 1
a9964 1
  for (i = 0; i < sec->reloc_count; i++) 
d9967 1
a9967 1
      if (is_l32r_relocation (sec, contents, irel))
d9972 2
a9973 2
	  
	  r_reloc_init (&l32r_rel, abfd, irel);
d9980 1
a9980 1
	      target_offset = r_reloc_get_target_offset (&l32r_rel);
d10017 1
a10017 1
   (e.g., prep_headers() in elf.c) should be changed to use EM_XTENSA.  */
@


1.33
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d987 1
a987 1
  if (h->weakdef != NULL)
d989 4
a992 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.32
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d684 1
a684 1
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2103 1
a2103 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d2163 2
a2164 2
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
@


1.31
log
@	* elf32-xtensa.c (elf_xtensa_relocate_section): Use
	bfd_get_section_limit.
@
text
@d644 2
a645 3
	  (*_bfd_error_handler) (_("%s: bad symbol index: %d"),
				 bfd_archive_filename (abfd),
				 r_symndx);
d2105 3
a2107 3
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
d2525 2
a2526 2
	("%s: incompatible machine type. Output is 0x%x. Input is 0x%x",
	 bfd_archive_filename (ibfd), out_mach, in_mach);
@


1.30
log
@	* elf32-xtensa.c (elf_xtensa_combine_prop_entries): Don't change the
	output section size.
@
text
@d1991 1
a1991 1
      if (rel->r_offset >= input_section->size
@


1.29
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2280 1
a2280 4
    {
      memset (&contents[num * 8], 0, section_size - num * 8);
      sxtlit->size = num * 8;
    }
@


1.28
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1652 1
  bfd_size_type sz;
d1677 1
a1677 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz / bfd_octets_per_byte (abfd))
@


1.27
log
@	* elf32-xtensa.c (xtensa_get_property_section_name): Determine linkonce
	section names by inserting a new substring after .gnu.linkonce, except
	for .gnu.linkonce.t.* where the "t." is replaced.
@
text
@d507 1
a507 2
    table_size = (table_section->_cooked_size
		  ? table_section->_cooked_size : table_section->_raw_size);
d564 1
a564 1
	      && address < ( section_addr + section->_raw_size))
d1058 1
a1058 1
    srelplt->_raw_size += (h->plt.refcount * sizeof (Elf32_External_Rela));
d1075 1
a1075 1
    srelgot->_raw_size += (h->got.refcount * sizeof (Elf32_External_Rela));
d1104 2
a1105 2
	    srelgot->_raw_size += (local_got_refcounts[j]
				   * sizeof (Elf32_External_Rela));
d1139 1
a1139 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1147 1
a1147 1
      s->_raw_size = 4;
d1186 1
a1186 1
      plt_entries = srelplt->_raw_size / sizeof (Elf32_External_Rela);
d1212 4
a1215 4
	      sgotplt->_raw_size = 4 * (chunk_entries + 2);
	      splt->_raw_size = PLT_ENTRY_SIZE * chunk_entries;
	      srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
	      spltlittbl->_raw_size += 8;
d1219 2
a1220 2
	      sgotplt->_raw_size = 0;
	      splt->_raw_size = 0;
d1229 1
a1229 1
      sgotloc->_raw_size = spltlittbl->_raw_size;
d1239 1
a1239 1
		sgotloc->_raw_size += s->_raw_size;
d1275 1
a1275 1
	  if (s->_raw_size == 0)
d1304 2
a1305 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
d1441 1
a1441 1
				      input_section->_raw_size - address);
d1462 1
a1462 2
	  elf_xtensa_do_asm_simplify (contents, address,
				      input_section->_raw_size);
d1653 1
d1678 2
a1679 2
  if (reloc_entry->address > (input_section->_cooked_size
			      / bfd_octets_per_byte (abfd)))
d1897 1
a1897 1
	      contract_asm_expansion (contents, input_section->_raw_size, rel);
d1993 1
a1993 1
      if (rel->r_offset >= input_section->_raw_size
d2097 1
a2097 1
			  <= srel->_cooked_size);
d2203 1
a2203 2
  section_size = (sxtlit->_cooked_size != 0
		  ? sxtlit->_cooked_size : sxtlit->_raw_size);
d2207 1
a2207 2
  sgotloc_size = (sgotloc->_cooked_size != 0
		  ? sgotloc->_cooked_size : sgotloc->_raw_size);
d2215 2
a2216 4
  contents = (bfd_byte *) bfd_malloc (section_size);
  table = (property_table_entry *)
    bfd_malloc (num * sizeof (property_table_entry));
  if (contents == 0 || table == 0)
d2221 1
a2221 1
     where it breaks the following call to bfd_get_section_contents.  */
d2224 7
a2230 3
  if (! bfd_get_section_contents (output_bfd, sxtlit, contents, 0,
				  section_size))
    return -1;
d2284 1
a2284 1
      sxtlit->_cooked_size = num * 8;
d2324 1
a2324 1
      BFD_ASSERT (sgot->_raw_size == 4);
d2334 1
a2334 1
  if (srelplt != NULL && srelplt->_raw_size != 0)
d2359 1
a2359 1
      plt_entries = (srelplt->_raw_size / sizeof (Elf32_External_Rela));
d2401 1
a2401 1
	  BFD_ASSERT ((unsigned) (chunk + 1) * 8 <= spltlittbl->_cooked_size);
d2412 4
a2415 4
      if (srelgot->_cooked_size != (sizeof (Elf32_External_Rela)
				    * srelgot->reloc_count)
	  || srelplt->_cooked_size != (sizeof (Elf32_External_Rela)
				       * srelplt->reloc_count))
d2426 1
a2426 1
				      spltlittbl->_raw_size))
d2443 1
a2443 1
  dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2478 1
a2478 1
	  dyn.d_un.d_val = (s->_cooked_size ? s->_cooked_size : s->_raw_size);
d2490 1
a2490 4
	    {
	      dyn.d_un.d_val -=
		(s->_cooked_size ? s->_cooked_size : s->_raw_size);
	    }
d2686 1
a2686 1
  section_size = (sec->_cooked_size ? sec->_cooked_size : sec->_raw_size);
d2774 2
a2775 3
      sec->_cooked_size = section_size - removed_bytes;
      /* Also shrink _raw_size.  See comments in relax_property_section.  */
      sec->_raw_size = sec->_cooked_size;
d2785 1
a2785 7
		{
		  bfd_size_type sgotloc_size =
		    (sgotloc->_cooked_size ? sgotloc->_cooked_size
		     : sgotloc->_raw_size);
		  sgotloc->_cooked_size = sgotloc_size - removed_bytes;
		  sgotloc->_raw_size = sgotloc_size - removed_bytes;
		}
d2837 1
a2837 1
  unsigned int raw_size;
d2850 1
a2850 1
  raw_size = note->descsz - offset - 4;
d2854 1
a2854 1
					  raw_size, note->descpos + offset);
d3016 1
a3016 1
  if (sec->_raw_size <= irel->r_offset)
d3950 1
a3950 1
  if (contents == NULL && sec->_raw_size != 0)
d3952 1
a3952 2
      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (contents != NULL)
d3954 3
a3956 8
	  if (! bfd_get_section_contents (abfd, sec, contents,
					  (file_ptr) 0, sec->_raw_size))
	    {
	      free (contents);
	      return NULL;
	    }
	  if (keep_memory) 
	    elf_section_data (sec)->this_hdr.contents = contents;
d3958 2
d4185 1
a4185 1
  if (contents == NULL && sec->_raw_size != 0)
d4246 1
a4246 1
  if (contents == NULL && sec->_raw_size != 0)
d4394 1
a4394 1
				     sec->_raw_size - irel->r_offset);
d4497 1
a4497 1
  if (contents == NULL && sec->_raw_size != 0)
d4555 1
a4555 1
      BFD_ASSERT (rel->r_rel.target_offset < sec->_raw_size);
d4711 1
a4711 1
  if (contents == NULL && sec->_raw_size != 0)
d4790 1
a4790 1
      unsigned long size = sec->_cooked_size;
d4796 1
a4796 1
	  unsigned long upper = sec->_raw_size;
d4813 1
a4813 7
      sec->_cooked_size = size;
      /* Also shrink _raw_size.  (The code in relocate_section that
	 checks that relocations are within the section must use
	 _raw_size because of the way the stabs sections are relaxed;
	 shrinking _raw_size means that these checks will not be
	 unnecessarily lax.)  */
      sec->_raw_size = size;
d4939 2
a4940 7
      BFD_ASSERT (srel->_cooked_size >= sizeof (Elf32_External_Rela));
      srel->_cooked_size -= sizeof (Elf32_External_Rela);

      /* Also shrink _raw_size.  (This seems wrong but other bfd code seems
	 to assume that linker-created sections will never be relaxed and
	 hence _raw_size must always equal _cooked_size.) */
      srel->_raw_size = srel->_cooked_size;
d4953 1
a4953 1
	  reloc_index = srel->_cooked_size / sizeof (Elf32_External_Rela);
d4967 2
a4968 5
	      srelgot->_cooked_size -= 2 * sizeof (Elf32_External_Rela);
	      /* Shrink _raw_size (see comment above).  */
	      srelgot->_raw_size = srelgot->_cooked_size;

	      sgotplt->_cooked_size -= 8;
d4972 2
a4973 2
	      BFD_ASSERT (sgotplt->_cooked_size == 4);
	      BFD_ASSERT (splt->_cooked_size == PLT_ENTRY_SIZE);
d4976 2
a4977 5
	  BFD_ASSERT (sgotplt->_cooked_size >= 4);
	  BFD_ASSERT (splt->_cooked_size >= PLT_ENTRY_SIZE);

	  sgotplt->_cooked_size -= 4;
	  splt->_cooked_size -= PLT_ENTRY_SIZE;
d4979 2
a4980 3
	  /* Shrink _raw_sizes (see comment above).  */
	  sgotplt->_raw_size = sgotplt->_cooked_size;
	  splt->_raw_size = splt->_cooked_size;
d5005 1
a5005 1
  if (contents == NULL && sec->_raw_size != 0)
d5096 1
a5096 1
      section_size = (sec->_cooked_size ? sec->_cooked_size : sec->_raw_size);
d5228 1
a5228 7
	  sec->_cooked_size = section_size - removed_bytes;
	  /* Also shrink _raw_size.  (The code in relocate_section that
	     checks that relocations are within the section must use
	     _raw_size because of the way the stabs sections are
	     relaxed; shrinking _raw_size means that these checks will
	     not be unnecessarily lax.)  */
	  sec->_raw_size = sec->_cooked_size;
d5238 1
a5238 7
		    {
		      bfd_size_type sgotloc_size =
			(sgotloc->_cooked_size ? sgotloc->_cooked_size
			 : sgotloc->_raw_size);
		      sgotloc->_cooked_size = sgotloc_size - removed_bytes;
		      sgotloc->_raw_size = sgotloc_size - removed_bytes;
		    }
d5697 1
a5697 1
      (*callback) (sec, sec->_raw_size, sgotplt, 0, closure);
d5708 1
a5708 1
  if (contents == NULL && sec->_raw_size != 0)
@


1.26
log
@	* elf32-xtensa.c (xtensa_read_table_entries): Use section _cooked_size
	if set.  Check reloc_done flag before applying relocations.  Use
	output addresses, both when applying relocations and when comparing
	against the specified section.
	(elf_xtensa_relocate_section): Use output address to check if dynamic
	reloc is in a literal pool.  Set section's reloc_done flag.
@
text
@d5688 4
a5691 6
      while (*suffix)
	{
	  suffix += 1;
	  if (suffix[-1] == '.')
	    break;
	}
@


1.25
log
@	* elf32-xtensa.c (is_same_value): Add final_static_link argument and
	require relocations against a weak symbol to reference the same
	symbol hash entry if not a final, static link.
	(get_cached_value, add_value_map): Add final_static_link argument.
	(remove_literals): Pass final_static_link argument as needed.
@
text
@d500 1
d507 2
a508 1
    table_size = bfd_get_section_size_before_reloc (table_section);
d522 2
d527 1
a527 1
  if (internal_relocs)
d546 1
a546 1
		(section->vma + sym_off + rel->r_addend
d556 2
a557 2
      /* No relocations.  Presumably the file has been relocated
	 and the addresses are already in the table.  */
d564 2
a565 2
	  if (address >= section->vma
	      && address < ( section->vma + section->_raw_size))
d2051 1
a2051 2
						      input_section->vma
						      + rel->r_offset))
d2150 2
@


1.24
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d3434 1
a3434 1
  PARAMS ((const literal_value *, const literal_value *));
d3442 1
a3442 1
  PARAMS ((value_map_hash_table *, const literal_value *));
d3444 2
a3445 1
  PARAMS ((value_map_hash_table *, const literal_value *, const r_reloc *));
d3449 1
a3449 1
is_same_value (src1, src2)
d3452 1
d3454 2
d3473 8
a3480 2
  /* Now check for the same section and the same elf_hash.  */
  if (r_reloc_is_defined (&src1->r_rel))
d3488 2
a3489 5
      if (r_reloc_get_hash_entry (&src1->r_rel)
	  != r_reloc_get_hash_entry (&src2->r_rel))
	return FALSE;

      if (r_reloc_get_hash_entry (&src1->r_rel) == 0)
d3550 1
a3550 1
get_cached_value (map, val)
d3553 1
d3564 1
a3564 1
      if (is_same_value (&map_e->val, val))
d3575 1
a3575 1
add_value_map (map, val, loc)
d3579 1
d3586 1
a3586 1
  BFD_ASSERT (get_cached_value (map, val) == NULL);
d4492 1
d4513 4
d4569 1
a4569 1
      val_map = get_cached_value (values, &val);
d4592 1
a4592 1
	  add_value_map (values, &val, &rel->r_rel);
@


1.23
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d736 1
a736 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d743 1
a743 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2723 1
a2723 1
	  if (_bfd_elf32_reloc_symbol_deleted_p (offset, cookie))
a5817 1
#define bfd_elf32_bfd_final_link	     bfd_elf32_bfd_final_link
@


1.22
log
@bfd/ChangeLog:
	* elf32-xtensa.c (elf_xtensa_check_relocs): Remove code to read
	literal tables and check for relocs outside of literal pools.
	(elf_xtensa_make_sym_local): Don't clear ELF_LINK_NON_GOT_REF flag.
	(elf_xtensa_fix_refcounts): Don't check ELF_LINK_NON_GOT_REF or
	set DF_TEXTREL.
	(elf_xtensa_size_dynamic_sections): Don't add DT_TEXTREL entry.
	(elf_xtensa_relocate_section): Read literal tables and check for
	dynamic relocations in read-only sections and not in literal pools.
gas/ChangeLog:
	* config/tc-xtensa.c (xtensa_post_relax_hook): Create literal
	tables even when use_literal_section flag is not set.
@
text
@d1337 1
a1337 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.21
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@a621 2
  property_table_entry *lit_table;
  int ltblsize;
a628 5
  ltblsize = xtensa_read_table_entries (abfd, sec, &lit_table,
					XTENSA_LIT_SEC_NAME);
  if (ltblsize < 0)
    return FALSE;

a664 5
	      if ((sec->flags & SEC_READONLY) != 0
		  && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						  sec->vma + rel->r_offset))
		h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

a679 5
	      if ((sec->flags & SEC_READONLY) != 0
		  && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						  sec->vma + rel->r_offset))
		h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

a721 8

	      /* If the relocation is not inside the GOT, the DF_TEXTREL
		 flag needs to be set.  */
	      if (info->shared
		  && (sec->flags & SEC_READONLY) != 0
		  && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						  sec->vma + rel->r_offset))
		info->flags |= DF_TEXTREL;
a751 1
  free (lit_table);
a1020 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
a1039 5
  /* If the symbol has a relocation outside the GOT, set the
     DF_TEXTREL flag.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) != 0)
    info->flags |= DF_TEXTREL;

a1361 6
      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}

d1816 2
d1835 8
d2043 15
d2144 3
@


1.20
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d1996 4
a1999 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.20.10.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d622 2
d631 5
d672 5
d692 5
d739 8
d777 1
d1047 1
d1067 5
d1369 1
a1369 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1394 6
a1853 2
  property_table_entry *lit_table = 0;
  int ltblsize = 0;
a1870 8
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      ltblsize = xtensa_read_table_entries (input_bfd, input_section,
					    &lit_table, XTENSA_LIT_SEC_NAME);
      if (ltblsize < 0)
	return FALSE;
    }

d1996 4
a1999 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
a2070 15
		  /* Complain if the relocation is in a read-only section
		     and not in a literal pool.  */
		  if ((input_section->flags & SEC_READONLY) != 0
		      && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						      input_section->vma
						      + rel->r_offset))
		    {
		      error_message =
			_("dynamic relocation in read-only section");
		      if (!((*info->callbacks->reloc_dangerous)
			    (info, error_message, input_bfd, input_section,
			     rel->r_offset)))
			return FALSE;
		    }

a2156 3

  if (lit_table)
    free (lit_table);
@


1.20.10.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d736 1
a736 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d743 1
a743 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2723 1
a2723 1
	  if (bfd_elf_reloc_symbol_deleted_p (offset, cookie))
d5818 1
@


1.20.10.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a499 1
  bfd_vma section_addr;
d506 1
a506 1
    table_size = table_section->size;
a519 2
  section_addr = section->output_section->vma + section->output_offset;

d523 1
a523 1
  if (internal_relocs && !table_section->reloc_done)
d542 1
a542 1
		(section_addr + sym_off + rel->r_addend
d552 2
a553 2
      /* The file has already been relocated and the addresses are
	 already in the table.  */
d560 2
a561 2
	  if (address >= section_addr
	      && address < section_addr + section->size)
d641 3
a643 2
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
d1055 1
a1055 1
    srelplt->size += (h->plt.refcount * sizeof (Elf32_External_Rela));
d1072 1
a1072 1
    srelgot->size += (h->got.refcount * sizeof (Elf32_External_Rela));
d1101 2
a1102 2
	    srelgot->size += (local_got_refcounts[j]
			      * sizeof (Elf32_External_Rela));
d1136 1
a1136 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1144 1
a1144 1
      s->size = 4;
d1183 1
a1183 1
      plt_entries = srelplt->size / sizeof (Elf32_External_Rela);
d1209 4
a1212 4
	      sgotplt->size = 4 * (chunk_entries + 2);
	      splt->size = PLT_ENTRY_SIZE * chunk_entries;
	      srelgot->size += 2 * sizeof (Elf32_External_Rela);
	      spltlittbl->size += 8;
d1216 2
a1217 2
	      sgotplt->size = 0;
	      splt->size = 0;
d1226 1
a1226 1
      sgotloc->size = spltlittbl->size;
d1236 1
a1236 1
		sgotloc->size += s->size;
d1272 1
a1272 1
	  if (s->size == 0)
d1301 2
a1302 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL && s->size != 0)
d1438 1
a1438 1
				      input_section->size - address);
d1459 2
a1460 1
	  elf_xtensa_do_asm_simplify (contents, address, input_section->size);
d1675 2
a1676 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1894 1
a1894 1
	      contract_asm_expansion (contents, input_section->size, rel);
d1990 1
a1990 1
      if (rel->r_offset >= bfd_get_section_limit (input_bfd, input_section)
d2047 2
a2048 1
						      outrel.r_offset))
d2095 1
a2095 1
			  <= srel->size);
d2106 3
a2108 3
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
a2147 2
  input_section->reloc_done = TRUE;

d2199 2
a2200 1
  section_size = sxtlit->size;
d2204 2
a2205 1
  sgotloc_size = sgotloc->size;
d2213 4
a2216 2
  table = bfd_malloc (num * sizeof (property_table_entry));
  if (table == 0)
d2221 1
a2221 1
     where it breaks the following call to bfd_malloc_and_get_section.  */
d2224 3
a2226 7
  if (!bfd_malloc_and_get_section (output_bfd, sxtlit, &contents))
    {
      if (contents != 0)
	free (contents);
      free (table);
      return -1;
    }
d2278 4
a2281 1
    memset (&contents[num * 8], 0, section_size - num * 8);
d2320 1
a2320 1
      BFD_ASSERT (sgot->size == 4);
d2330 1
a2330 1
  if (srelplt != NULL && srelplt->size != 0)
d2355 1
a2355 1
      plt_entries = srelplt->size / sizeof (Elf32_External_Rela);
d2397 1
a2397 1
	  BFD_ASSERT ((unsigned) (chunk + 1) * 8 <= spltlittbl->size);
d2408 4
a2411 4
      if (srelgot->size != (sizeof (Elf32_External_Rela)
			    * srelgot->reloc_count)
	  || srelplt->size != (sizeof (Elf32_External_Rela)
			       * srelplt->reloc_count))
d2422 1
a2422 1
				      spltlittbl->size))
d2439 1
a2439 1
  dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d2474 1
a2474 1
	  dyn.d_un.d_val = s->size;
d2486 4
a2489 1
	    dyn.d_un.d_val -= s->size;
d2530 2
a2531 2
	("%B: incompatible machine type. Output is 0x%x. Input is 0x%x",
	 ibfd, out_mach, in_mach);
d2685 1
a2685 1
  section_size = sec->size;
d2773 3
a2775 2
      /* Shrink size.  */
      sec->size = section_size - removed_bytes;
d2785 7
a2791 1
		sgotloc->size -= removed_bytes;
d2843 1
a2843 1
  unsigned int size;
d2856 1
a2856 1
  size = note->descsz - offset - 4;
d2860 1
a2860 1
					  size, note->descpos + offset);
d3022 1
a3022 1
  if (sec->size <= irel->r_offset)
d3434 1
a3434 1
  PARAMS ((const literal_value *, const literal_value *, bfd_boolean));
d3442 1
a3442 1
  PARAMS ((value_map_hash_table *, const literal_value *, bfd_boolean));
d3444 1
a3444 2
  PARAMS ((value_map_hash_table *, const literal_value *, const r_reloc *,
	   bfd_boolean));
d3448 1
a3448 1
is_same_value (src1, src2, final_static_link)
a3450 1
     bfd_boolean final_static_link;
a3451 2
  struct elf_link_hash_entry *h1, *h2;

d3469 2
a3470 8
  /* Now check for the same section (if defined) or the same elf_hash
     (if undefined or weak).  */
  h1 = r_reloc_get_hash_entry (&src1->r_rel);
  h2 = r_reloc_get_hash_entry (&src2->r_rel);
  if (r_reloc_is_defined (&src1->r_rel)
      && (final_static_link
	  || ((!h1 || h1->root.type != bfd_link_hash_defweak)
	      && (!h2 || h2->root.type != bfd_link_hash_defweak))))
d3478 5
a3482 2
      /* Require that the hash entries (i.e., symbols) be identical.  */
      if (h1 != h2 || h1 == 0)
d3543 1
a3543 1
get_cached_value (map, val, final_static_link)
a3545 1
     bfd_boolean final_static_link;
d3556 1
a3556 1
      if (is_same_value (&map_e->val, val, final_static_link))
d3567 1
a3567 1
add_value_map (map, val, loc, final_static_link)
a3570 1
     bfd_boolean final_static_link;
d3577 1
a3577 1
  BFD_ASSERT (get_cached_value (map, val, final_static_link) == NULL);
d3947 1
a3947 1
  if (contents == NULL && sec->size != 0)
d3949 2
a3950 1
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d3952 8
a3959 3
	  if (contents != NULL)
	    free (contents);
	  return NULL;
a3960 2
      if (keep_memory) 
	elf_section_data (sec)->this_hdr.contents = contents;
d4186 1
a4186 1
  if (contents == NULL && sec->size != 0)
d4247 1
a4247 1
  if (contents == NULL && sec->size != 0)
d4395 1
a4395 1
				     sec->size - irel->r_offset);
a4482 1
  bfd_boolean final_static_link;
d4497 1
a4497 1
  if (contents == NULL && sec->size != 0)
a4502 4
  final_static_link =
    (!link_info->relocatable
     && !elf_hash_table (link_info)->dynamic_sections_created);

d4551 1
a4551 1
      BFD_ASSERT (rel->r_rel.target_offset < sec->size);
d4555 1
a4555 1
      val_map = get_cached_value (values, &val, final_static_link);
d4578 1
a4578 1
	  add_value_map (values, &val, &rel->r_rel, final_static_link);
d4707 1
a4707 1
  if (contents == NULL && sec->size != 0)
d4786 1
a4786 1
      unsigned long size = sec->size;
d4792 1
a4792 1
	  unsigned long upper = sec->size;
d4809 7
a4815 1
      sec->size = size;
d4941 7
a4947 2
      BFD_ASSERT (srel->size >= sizeof (Elf32_External_Rela));
      srel->size -= sizeof (Elf32_External_Rela);
d4960 1
a4960 1
	  reloc_index = srel->size / sizeof (Elf32_External_Rela);
d4974 5
a4978 2
	      srelgot->size -= 2 * sizeof (Elf32_External_Rela);
	      sgotplt->size -= 8;
d4982 2
a4983 2
	      BFD_ASSERT (sgotplt->size == 4);
	      BFD_ASSERT (splt->size == PLT_ENTRY_SIZE);
d4986 5
a4990 2
	  BFD_ASSERT (sgotplt->size >= 4);
	  BFD_ASSERT (splt->size >= PLT_ENTRY_SIZE);
d4992 3
a4994 2
	  sgotplt->size -= 4;
	  splt->size -= PLT_ENTRY_SIZE;
d5019 1
a5019 1
  if (contents == NULL && sec->size != 0)
d5110 1
a5110 1
      section_size = sec->size;
d5242 7
a5248 1
	  sec->size = section_size - removed_bytes;
d5258 7
a5264 1
		    sgotloc->size -= removed_bytes;
d5669 6
a5674 4
      /* For backward compatibility, replace "t." instead of inserting
	 the new linkonce_kind.  */
      if (strncmp (suffix, "t.", 2) == 0)
	suffix += 2;
d5725 1
a5725 1
      (*callback) (sec, sec->size, sgotplt, 0, closure);
d5736 1
a5736 1
  if (contents == NULL && sec->size != 0)
@


1.20.10.4
log
@Merge from mainline.
@
text
@d684 1
a684 1
		  h->needs_plt = 1;
d987 1
a987 1
  if (h->u.weakdef != NULL)
d989 4
a992 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d2103 1
a2103 1
	       && h->def_dynamic))
d2163 2
a2164 2
  if (h->needs_plt
      && !h->def_regular)
@


1.20.8.1
log
@bfd/ChangeLog:
	* elf32-xtensa.c (elf_xtensa_check_relocs): Remove code to read
	literal tables and check for relocs outside of literal pools.
	(elf_xtensa_make_sym_local): Don't clear ELF_LINK_NON_GOT_REF flag.
	(elf_xtensa_fix_refcounts): Don't check ELF_LINK_NON_GOT_REF or
	set DF_TEXTREL.
	(elf_xtensa_size_dynamic_sections): Don't add DT_TEXTREL entry.
	(elf_xtensa_relocate_section): Read literal tables and check for
	dynamic relocations in read-only sections and not in literal pools.
gas/ChangeLog:
	* config/tc-xtensa.c (xtensa_post_relax_hook): Create literal
	tables even when use_literal_section flag is not set.
@
text
@d622 2
d631 5
d672 5
d692 5
d739 8
d777 1
d1047 1
d1067 5
d1394 6
a1853 2
  property_table_entry *lit_table = 0;
  int ltblsize = 0;
a1870 8
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      ltblsize = xtensa_read_table_entries (input_bfd, input_section,
					    &lit_table, XTENSA_LIT_SEC_NAME);
      if (ltblsize < 0)
	return FALSE;
    }

a2070 15
		  /* Complain if the relocation is in a read-only section
		     and not in a literal pool.  */
		  if ((input_section->flags & SEC_READONLY) != 0
		      && !elf_xtensa_in_literal_pool (lit_table, ltblsize,
						      input_section->vma
						      + rel->r_offset))
		    {
		      error_message =
			_("dynamic relocation in read-only section");
		      if (!((*info->callbacks->reloc_dangerous)
			    (info, error_message, input_bfd, input_section,
			     rel->r_offset)))
			return FALSE;
		    }

a2156 3

  if (lit_table)
    free (lit_table);
@


1.20.8.2
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d736 1
a736 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d743 1
a743 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1337 1
a1337 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1968 4
a1971 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2723 1
a2723 1
	  if (bfd_elf_reloc_symbol_deleted_p (offset, cookie))
d5818 1
@


1.20.8.3
log
@	* elf32-xtensa.c (is_same_value): Add final_static_link argument and
	require relocations against a weak symbol to reference the same
	symbol hash entry if not a final, static link.
	(get_cached_value, add_value_map): Add final_static_link argument.
	(remove_literals): Pass final_static_link argument as needed.
@
text
@d3434 1
a3434 1
  PARAMS ((const literal_value *, const literal_value *, bfd_boolean));
d3442 1
a3442 1
  PARAMS ((value_map_hash_table *, const literal_value *, bfd_boolean));
d3444 1
a3444 2
  PARAMS ((value_map_hash_table *, const literal_value *, const r_reloc *,
	   bfd_boolean));
d3448 1
a3448 1
is_same_value (src1, src2, final_static_link)
a3450 1
     bfd_boolean final_static_link;
a3451 2
  struct elf_link_hash_entry *h1, *h2;

d3469 2
a3470 8
  /* Now check for the same section (if defined) or the same elf_hash
     (if undefined or weak).  */
  h1 = r_reloc_get_hash_entry (&src1->r_rel);
  h2 = r_reloc_get_hash_entry (&src2->r_rel);
  if (r_reloc_is_defined (&src1->r_rel)
      && (final_static_link
	  || ((!h1 || h1->root.type != bfd_link_hash_defweak)
	      && (!h2 || h2->root.type != bfd_link_hash_defweak))))
d3478 5
a3482 2
      /* Require that the hash entries (i.e., symbols) be identical.  */
      if (h1 != h2 || h1 == 0)
d3543 1
a3543 1
get_cached_value (map, val, final_static_link)
a3545 1
     bfd_boolean final_static_link;
d3556 1
a3556 1
      if (is_same_value (&map_e->val, val, final_static_link))
d3567 1
a3567 1
add_value_map (map, val, loc, final_static_link)
a3570 1
     bfd_boolean final_static_link;
d3577 1
a3577 1
  BFD_ASSERT (get_cached_value (map, val, final_static_link) == NULL);
a4482 1
  bfd_boolean final_static_link;
a4502 4
  final_static_link =
    (!link_info->relocatable
     && !elf_hash_table (link_info)->dynamic_sections_created);

d4555 1
a4555 1
      val_map = get_cached_value (values, &val, final_static_link);
d4578 1
a4578 1
	  add_value_map (values, &val, &rel->r_rel, final_static_link);
@


1.20.8.4
log
@	* elf32-xtensa.c (xtensa_read_table_entries): Use section _cooked_size
	if set.  Check reloc_done flag before applying relocations.  Use
	output addresses, both when applying relocations and when comparing
	against the specified section.
	(elf_xtensa_relocate_section): Use output address to check if dynamic
	reloc is in a literal pool.  Set section's reloc_done flag.
@
text
@a499 1
  bfd_vma section_addr;
d506 1
a506 2
    table_size = (table_section->_cooked_size
		  ? table_section->_cooked_size : table_section->_raw_size);
a519 2
  section_addr = section->output_section->vma + section->output_offset;

d523 1
a523 1
  if (internal_relocs && !table_section->reloc_done)
d542 1
a542 1
		(section_addr + sym_off + rel->r_addend
d552 2
a553 2
      /* The file has already been relocated and the addresses are
	 already in the table.  */
d560 2
a561 2
	  if (address >= section_addr
	      && address < ( section_addr + section->_raw_size))
d2047 2
a2048 1
						      outrel.r_offset))
a2146 2

  input_section->reloc_done = TRUE;
@


1.20.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.19
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d1717 1
a1717 1
  /* Work out which section the relocation is targetted at and the
d4174 1
a4174 1
   of relocations targetting each section is also counted so that we
@


1.18
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d63 1
a63 1
  PARAMS ((bfd *));
d1418 1
a1418 1
elf_xtensa_modify_segment_map (abfd)
d1420 1
@


1.17
log
@Fix decision about when a .interp section should exist
@
text
@a49 3
static void elf_xtensa_copy_indirect_symbol
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
a795 13
static void
elf_xtensa_copy_indirect_symbol (bed, dir, ind)
     const struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);

  /* The standard function doesn't copy the NEEDS_PLT flag.  */
  dir->elf_link_hash_flags |=
    (ind->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT);
}


a5836 1
#define elf_backend_copy_indirect_symbol     elf_xtensa_copy_indirect_symbol
@


1.16
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1179 1
a1179 1
      if (! info->shared)
@


1.15
log
@2003-10-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-xtensa.c (xtensa_read_table_entries): The external size
	of entry is 8 bytes.
@
text
@d2007 1
a2007 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.14
log
@bfd ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* elf32-xtensa.c (get_is_linkonce_section): Delete.
	(xtensa_is_property_section, xtensa_is_littable_section): Use
	XTENSA_INSN_SEC_NAME and XTENSA_LIT_SEC_NAME macros.  Do not recognize
	linkonce sections containing ".xt.insn" and ".xt.lit" substrings.
	(xtensa_get_property_section_name): Check section name instead of
	calling get_is_linkonce_section.  Remove unused bfd parameter.  Use
	XTENSA_INSN_SEC_NAME and XTENSA_LIT_SEC_NAME macros.  Never generate
	linkonce section names by appending ".xt.insn" or ".xt.lit".
	(xtensa_read_table_entries): Remove bfd argument in call to
	xtensa_get_property_section_name.  Free section name when done.
	(elf_xtensa_combine_prop_entries): Free leaking table.

gas ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* config/tc-xtensa.c (xtensa_create_property_segments): Remove bfd
	argument in call to xtensa_get_property_section_name.  Formatting.

include ChangeLog:

2003-10-14  Bob Wilson  <bob.wilson@@acm.org>

	* elf/xtensa.h: Formatting.  Fix comments about property section
	names for linkonce sections.
@
text
@d517 1
a517 1
  num_records = table_size / sizeof (property_table_entry);
d559 1
a559 1
      for (off = 0; off < table_size; off += sizeof (property_table_entry)) 
@


1.13
log
@	* elf32-xtensa.c (elf_xtensa_relocate_section): Fix typo that clobbered
	dynamic relocation offsets.
@
text
@a214 2
static bfd_boolean get_is_linkonce_section
  PARAMS ((bfd *, asection *));
d216 1
a216 1
  PARAMS ((bfd *, asection *, const char *));
d505 1
a505 1
    xtensa_get_property_section_name (abfd, section, sec_name);
d507 1
d2316 1
d5608 5
d5617 3
a5619 1
  static int linkonce_len = sizeof (".gnu.linkonce.") - 1;
d5621 4
a5624 2
  if (strncmp (".xt.insn", sec->name, 8) == 0
      || strncmp (".xt.lit", sec->name, 7) == 0)
a5626 9
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0)
    {
      if (strncmp ("x.", sec->name + linkonce_len, 2) == 0
	  || strncmp ("p.", sec->name + linkonce_len, 2) == 0)
	return TRUE;
      if (strstr (sec->name + linkonce_len, ".xt.insn") != NULL
	  || strstr (sec->name + linkonce_len, ".xt.lit") != NULL)
	return TRUE;
    }
d5635 2
a5636 1
  static int linkonce_len = sizeof (".gnu.linkonce.") - 1;
d5638 3
a5640 1
  if (strncmp (".xt.lit", sec->name, 7) == 0)
a5642 7
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0)
    {
      if (strncmp ("p.", sec->name + linkonce_len, 2) == 0)
	return TRUE;
      if (strstr (sec->name + linkonce_len, ".xt.lit") != NULL)
	return TRUE;
    }
a5669 24
static bfd_boolean
get_is_linkonce_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
{
  flagword flags, link_once_flags;
  bfd_boolean is_linkonce = FALSE;;

  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);
  if (link_once_flags != 0)
    is_linkonce = TRUE;

  /* In order for this to be useful to the assembler
     before the linkonce flag is set we need to
     check for the GNU extension name.  */
  if (!is_linkonce &&
      strncmp (sec->name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
    is_linkonce = TRUE;
  
  return is_linkonce;
}


d5671 1
a5671 2
xtensa_get_property_section_name (abfd, sec, base_name)
     bfd *abfd;
d5673 1
a5673 1
     const char * base_name;
d5675 12
a5686 2
  char *table_sec_name = NULL;
  bfd_boolean is_linkonce;
d5688 4
a5691 1
  is_linkonce = get_is_linkonce_section (abfd, sec);
d5693 2
a5694 20
  if (!is_linkonce)
    {
      table_sec_name = strdup (base_name);
    }
  else
    {
      static size_t prefix_len = sizeof (".gnu.linkonce.t.") - 1;
      size_t len = strlen (sec->name) + 1;
      char repl_char = '\0';
      const char *segname = sec->name;

      if (strncmp (segname, ".gnu.linkonce.t.", prefix_len) == 0)
	{
	  if (strcmp (base_name, ".xt.insn") == 0) 
	    repl_char = 'x';
	  else if (strcmp (base_name, ".xt.lit") == 0) 
	    repl_char = 'p';
	}
      
      if (repl_char != '\0')
d5696 3
a5698 12
	  char *name = (char *) bfd_malloc (len);
	  memcpy (name, sec->name, len);
	  name[prefix_len - 2] = repl_char;
	  table_sec_name = name;
	}
      else
	{
	  size_t base_len = strlen (base_name) + 1;
	  char *name = (char *) bfd_malloc (len + base_len);
	  memcpy (name, sec->name, len - 1);
	  memcpy (name + len - 1, base_name, base_len);
	  table_sec_name = name;
d5700 3
d5705 1
a5705 1
  return table_sec_name;
@


1.12
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d2084 2
a2085 2
		  outrel.r_offset = (input_section->output_section->vma
				     + input_section->output_offset);
@


1.11
log
@Better handking for unresolved symbols
@
text
@d5844 4
a5847 8
  { ".literal",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init.literal",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".fini.literal",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.10
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2012 8
a2019 24
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  relocation = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;

	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
a2020 14
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (!info->shared || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      warned = TRUE;
	    }
d3548 1
d3557 1
a3557 1
    hash_val += hash_bfd_vma ((bfd_vma) r_reloc_get_section (&src->r_rel));
d3559 1
a3559 1
    hash_val += hash_bfd_vma ((bfd_vma) r_reloc_get_hash_entry (&src->r_rel));
@


1.9
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d51 1
a51 1
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
d802 1
a802 1
     struct elf_backend_data *bed;
@


1.8
log
@        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Make inline and move
        near the beginning of the file.  Swap order of arguments.  Call
        _bfd_elf_dynamic_symbol_p with "ignore_protected" set to 0.
        (elf_xtensa_fix_refcounts): Adjust xtensa_elf_dynamic_symbol_p call.
        (elf_xtensa_relocate_section): Likewise.
        (shrink_dynamic_reloc_sections): Likewise.
@
text
@d5868 15
d5943 1
@


1.7
log
@        * elf32-xtensa.c (plt_reloc_count): Fix typo in comment.
        (elf_xtensa_size_dynamic_sections): Use elf_discarded_section.
        (elf_xtensa_combine_prop_entries): Avoid returning non-zero without
        first printing an error message.
        (elf_xtensa_finish_dynamic_sections): Likewise.
        (elf_xtensa_discard_info_for_section): Adjust size of .got.loc when
        discarding literal table entries.
        (elf_xtensa_merge_private_bfd_data): Remove newline from error message.
        (elf_xtensa_do_asm_simplify): Likewise.
@
text
@d105 2
a135 2
static bfd_boolean xtensa_elf_dynamic_symbol_p
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d452 15
d1081 1
a1081 1
  if (! xtensa_elf_dynamic_symbol_p (info, h))
a1847 11
static bfd_boolean
xtensa_elf_dynamic_symbol_p (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  /* ??? What, if anything, needs to happen wrt STV_PROTECTED and PLT
     entries?  For now assume the worst.  */
  return _bfd_elf_dynamic_symbol_p (h, info, 1);
}


d2074 1
a2074 1
	  bfd_boolean dynamic_symbol = xtensa_elf_dynamic_symbol_p (info, h);
d4970 1
a4970 1
  dynamic_symbol = xtensa_elf_dynamic_symbol_p (info, h);
@


1.6
log
@        * elflink.c (_bfd_elf_dynamic_symbol_p): New.
        * elf-bfd.h (_bfd_elf_dynamic_symbol_p): Declare it.
        (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use it.
        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Likewise.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
        * elf64-hppa.c (elf64_hppa_dynamic_symbol_p): Likewise.
        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Likewise.
        Update all callers to provide the relocation being resolved.
@
text
@d236 1
a236 1
   needed.  It is OK is this count is an overestimate, e.g., some
d1267 3
a1269 6
	      /* Skip input sections that are being discarded.  */
	      if (!bfd_is_abs_section (s)
		  && bfd_is_abs_section (s->output_section))
		continue;

	      if (xtensa_is_littable_section (s) && s != spltlittbl)
d2259 5
a2263 1
    return -1;
d2483 1
a2483 2
  if (!sxtlit || !sgotloc)
    return FALSE;
d2581 1
a2581 1
	("%s: incompatible machine type. Output is 0x%x. Input is 0x%x\n",
d2827 18
d3123 1
a3123 1
	("Attempt to convert L32R/CALLX to CALL failed\n");
d3132 1
a3132 1
	("Attempt to convert L32R/CALLX to CALL failed\n");
@


1.5
log
@bfd ChangeLog:
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Create new
	.got.loc section.  Do not set SEC_ALLOC or SEC_LOAD flags for the
	.xt.lit.plt section.
	(elf_xtensa_size_dynamic_sections): Set size of the .got.loc section
	and allocate memory for it.
	(elf_xtensa_combine_prop_entries): Copy contents of .xt.lit output
	section to the .got.loc section.
	(elf_xtensa_finish_dynamic_sections): Fix up call to
	elf_xtensa_combine_prop_entries and set DT_XTENSA_GOT_LOC_OFF to
	the address of .got.loc.
	(relax_property_section): Shrink .got.loc to match changes in any
	literal table section.
	(xtensa_is_property_section): Change to match
	xtensa_get_property_section_name.
	(xtensa_is_littable_section): New.
ld ChangeLog:
	* emulparams/elf32xtensa.sh (OTHER_READONLY_SECTIONS): Replace .xt.lit
	with new .got.loc section.
	(OTHER_READWRITE_SECTIONS): Do not combine linkonce sections for
	non-relocating links.
	(OTHER_SECTIONS): Add .xt.lit here.  Change it to keep linkonce
	sections separate for non-relocating links; likewise for .xt.insn.
@
text
@d1841 3
a1843 32
  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return TRUE;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_DEFAULT:
      break;
    case STV_HIDDEN:
    case STV_INTERNAL:
      return FALSE;
    case STV_PROTECTED:
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
        return FALSE;
      break;
    }

  if ((info->shared && !info->symbolic)
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  return FALSE;
@


1.4
log
@Correct spelling of "relocatable".
@
text
@d139 1
a139 1
  PARAMS ((bfd *, const char *));
d209 2
d909 1
a909 1
  flagword flags;
d921 3
a923 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);
d938 7
d948 1
a948 1
      || ! bfd_set_section_flags (dynobj, s, flags)
d1149 2
a1150 2
  bfd *dynobj;
  asection *s, *srelplt, *splt, *sgotplt, *srelgot, *spltlittbl;
d1254 22
d1326 2
a1327 1
	       && strcmp (name, ".xt.lit.plt") != 0)
d2272 1
a2272 1
elf_xtensa_combine_prop_entries (output_bfd, secname)
d2274 2
a2275 1
     const char *secname;
a2276 1
  asection *sec;
d2279 1
a2279 1
  bfd_size_type section_size;
d2283 2
a2284 5
  sec = bfd_get_section_by_name (output_bfd, secname);
  if (!sec)
    return -1;

  section_size = (sec->_cooked_size != 0 ? sec->_cooked_size : sec->_raw_size);
d2288 5
d2302 1
a2302 1
  sec->flags &= ~SEC_IN_MEMORY;
d2304 2
a2305 1
  if (! bfd_get_section_contents (output_bfd, sec, contents, 0, section_size))
d2360 1
a2360 1
      sec->_cooked_size = num * 8;
d2363 2
a2364 1
  if (! bfd_set_section_contents (output_bfd, sec, contents, 0, section_size))
d2367 3
d2383 1
a2383 1
  asection *sdyn, *srelplt, *sgot;
d2509 6
a2514 1
  num_xtlit_entries = elf_xtensa_combine_prop_entries (output_bfd, ".xt.lit");
a2533 2
	  s = bfd_get_section_by_name (output_bfd, ".xt.lit");
	  BFD_ASSERT (s);
d2538 1
a2538 1
	  name = ".xt.lit";
d5310 18
d5330 1
a5330 1
	  
d5648 27
a5674 1
  static int len = sizeof (".gnu.linkonce.t.") - 1;
d5676 8
a5683 4
  return (strcmp (".xt.insn", sec->name) == 0
	  || strcmp (".xt.lit", sec->name) == 0
	  || strncmp (".gnu.linkonce.x.", sec->name, len) == 0
	  || strncmp (".gnu.linkonce.p.", sec->name, len) == 0);
@


1.3
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d130 1
a130 1
static void do_fix_for_relocateable_link
d612 1
a612 1
  if (info->relocateable)
d1665 1
a1665 1
  /* ELF relocs are against symbols.  If we are producing relocateable
d1844 1
a1844 1
   both relocateable and final links.  */
d1912 1
a1912 1
      if (info->relocateable)
d1914 1
a1914 1
	  /* This is a relocateable link. 
d1925 1
a1925 1
	      do_fix_for_relocateable_link (rel, input_bfd, input_section);
d1937 1
a1937 1
	  /* This is a relocateable link, so we don't have to change
d1953 1
a1953 1
	     to work around problems with DWARF in relocateable links
d1976 1
a1976 1
	  /* Done with work for relocateable link; continue with next reloc.  */
d2468 1
a2468 1
  BFD_ASSERT (! info->relocateable);
d4434 1
a4434 1
  /* For relocateable sections, we can only simplify when the output
d4437 1
a4437 1
  if (link_info->relocateable
d5348 1
a5348 1
do_fix_for_relocateable_link (rel, input_bfd, input_section)
@


1.2
log
@        * elf32-xtensa.c (elf_xtensa_relocate_section): Don't continue to the
        next relocation on an undefined symbol.
@
text
@d3928 1
a3928 1
    internal_relocs = (_bfd_elf32_link_read_relocs
@


1.2.4.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d3928 1
a3928 1
    internal_relocs = (_bfd_elf_link_read_relocs
@


1.2.2.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@@


1.2.2.2
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d3928 1
a3928 1
    internal_relocs = (_bfd_elf_link_read_relocs
@


1.2.2.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d130 1
a130 1
static void do_fix_for_relocatable_link
d612 1
a612 1
  if (info->relocatable)
d1665 1
a1665 1
  /* ELF relocs are against symbols.  If we are producing relocatable
d1844 1
a1844 1
   both relocatable and final links.  */
d1912 1
a1912 1
      if (info->relocatable)
d1914 1
a1914 1
	  /* This is a relocatable link. 
d1925 1
a1925 1
	      do_fix_for_relocatable_link (rel, input_bfd, input_section);
d1937 1
a1937 1
	  /* This is a relocatable link, so we don't have to change
d1953 1
a1953 1
	     to work around problems with DWARF in relocatable links
d1976 1
a1976 1
	  /* Done with work for relocatable link; continue with next reloc.  */
d2468 1
a2468 1
  BFD_ASSERT (! info->relocatable);
d4434 1
a4434 1
  /* For relocatable sections, we can only simplify when the output
d4437 1
a4437 1
  if (link_info->relocatable
d5348 1
a5348 1
do_fix_for_relocatable_link (rel, input_bfd, input_section)
@


1.2.2.4
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a104 2
static bfd_boolean xtensa_elf_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d134 2
d139 1
a139 1
  PARAMS ((bfd *, asection *, asection *));
a208 2
static bfd_boolean xtensa_is_littable_section
  PARAMS ((asection *));
d234 1
a234 1
   needed.  It is OK if this count is an overestimate, e.g., some
a449 15

static inline bfd_boolean
xtensa_elf_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  /* Check if we should do dynamic things to this symbol.  The
     "ignore_protected" argument need not be set, because Xtensa code
     does not require special handling of STV_PROTECTED to make function
     pointer comparisons work properly.  The PLT addresses are never
     used for function pointers.  */

  return _bfd_elf_dynamic_symbol_p (h, info, 0);
}

d907 1
a907 1
  flagword flags, noalloc_flags;
d919 2
a920 3
  noalloc_flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
		   | SEC_LINKER_CREATED | SEC_READONLY);
  flags = noalloc_flags | SEC_ALLOC | SEC_LOAD;
a934 7
  /* Create ".got.loc" (literal tables for use by dynamic linker).  */
  s = bfd_make_section (dynobj, ".got.loc");
  if (s == NULL
      || ! bfd_set_section_flags (dynobj, s, flags)
      || ! bfd_set_section_alignment (dynobj, s, 2))
    return FALSE;

d938 1
a938 1
      || ! bfd_set_section_flags (dynobj, s, noalloc_flags)
d1056 1
a1056 1
  if (! xtensa_elf_dynamic_symbol_p (h, info))
d1139 2
a1140 2
  bfd *dynobj, *abfd;
  asection *s, *srelplt, *splt, *sgotplt, *srelgot, *spltlittbl, *sgotloc;
a1243 19

      /* Allocate space in ".got.loc" to match the total size of all the
	 literal tables.  */
      sgotloc = bfd_get_section_by_name (dynobj, ".got.loc");
      if (sgotloc == NULL)
	abort ();
      sgotloc->_raw_size = spltlittbl->_raw_size;
      for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
	{
	  if (abfd->flags & DYNAMIC)
	    continue;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      if (! elf_discarded_section (s)
		  && xtensa_is_littable_section (s)
		  && s != spltlittbl)
		sgotloc->_raw_size += s->_raw_size;
	    }
	}
d1294 1
a1294 2
	       && strcmp (name, ".xt.lit.plt") != 0
	       && strcmp (name, ".got.loc") != 0)
d1803 40
d2069 1
a2069 1
	  bfd_boolean dynamic_symbol = xtensa_elf_dynamic_symbol_p (h, info);
d2239 1
a2239 1
elf_xtensa_combine_prop_entries (output_bfd, sxtlit, sgotloc)
d2241 1
a2241 2
     asection *sxtlit;
     asection *sgotloc;
d2243 1
d2246 1
a2246 1
  bfd_size_type section_size, sgotloc_size;
d2250 5
a2254 2
  section_size = (sxtlit->_cooked_size != 0
		  ? sxtlit->_cooked_size : sxtlit->_raw_size);
a2257 9
  sgotloc_size = (sgotloc->_cooked_size != 0
		  ? sgotloc->_cooked_size : sgotloc->_raw_size);
  if (sgotloc_size != section_size)
    {
      (*_bfd_error_handler)
	("internal inconsistency in size of .got.loc section");
      return -1;
    }

d2267 1
a2267 1
  sxtlit->flags &= ~SEC_IN_MEMORY;
d2269 1
a2269 2
  if (! bfd_get_section_contents (output_bfd, sxtlit, contents, 0,
				  section_size))
d2324 1
a2324 1
      sxtlit->_cooked_size = num * 8;
d2327 1
a2327 2
  if (! bfd_set_section_contents (output_bfd, sxtlit, contents, 0,
				  section_size))
a2329 3
  /* Copy the contents to ".got.loc".  */
  memcpy (sgotloc->contents, contents, section_size);

d2343 1
a2343 1
  asection *sdyn, *srelplt, *sgot, *sxtlit, *sgotloc;
d2469 1
a2469 5
  sxtlit = bfd_get_section_by_name (output_bfd, ".xt.lit");
  sgotloc = bfd_get_section_by_name (dynobj, ".got.loc");
  BFD_ASSERT (sxtlit && sgotloc);
  num_xtlit_entries =
    elf_xtensa_combine_prop_entries (output_bfd, sxtlit, sgotloc);
d2489 2
d2495 1
a2495 1
	  name = ".got.loc";
d2567 1
a2567 1
	("%s: incompatible machine type. Output is 0x%x. Input is 0x%x",
a2812 18

      if (xtensa_is_littable_section (sec))
	{
	  bfd *dynobj = elf_hash_table (info)->dynobj;
	  if (dynobj)
	    {
	      asection *sgotloc =
		bfd_get_section_by_name (dynobj, ".got.loc");
	      if (sgotloc)
		{
		  bfd_size_type sgotloc_size =
		    (sgotloc->_cooked_size ? sgotloc->_cooked_size
		     : sgotloc->_raw_size);
		  sgotloc->_cooked_size = sgotloc_size - removed_bytes;
		  sgotloc->_raw_size = sgotloc_size - removed_bytes;
		}
	    }
	}
d3091 1
a3091 1
	("Attempt to convert L32R/CALLX to CALL failed");
d3100 1
a3100 1
	("Attempt to convert L32R/CALLX to CALL failed");
d4934 1
a4934 1
  dynamic_symbol = xtensa_elf_dynamic_symbol_p (h, info);
a5266 18

	  if (xtensa_is_littable_section (sec))
	    {
	      bfd *dynobj = elf_hash_table (link_info)->dynobj;
	      if (dynobj)
		{
		  asection *sgotloc =
		    bfd_get_section_by_name (dynobj, ".got.loc");
		  if (sgotloc)
		    {
		      bfd_size_type sgotloc_size =
			(sgotloc->_cooked_size ? sgotloc->_cooked_size
			 : sgotloc->_raw_size);
		      sgotloc->_cooked_size = sgotloc_size - removed_bytes;
		      sgotloc->_raw_size = sgotloc_size - removed_bytes;
		    }
		}
	    }
d5269 1
a5269 1

d5587 1
a5587 5
  static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

  if (strncmp (".xt.insn", sec->name, 8) == 0
      || strncmp (".xt.lit", sec->name, 7) == 0)
    return TRUE;
d5589 4
a5592 30
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0)
    {
      if (strncmp ("x.", sec->name + linkonce_len, 2) == 0
	  || strncmp ("p.", sec->name + linkonce_len, 2) == 0)
	return TRUE;
      if (strstr (sec->name + linkonce_len, ".xt.insn") != NULL
	  || strstr (sec->name + linkonce_len, ".xt.lit") != NULL)
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean 
xtensa_is_littable_section (sec)
     asection *sec;
{
  static int linkonce_len = sizeof (".gnu.linkonce.") - 1;

  if (strncmp (".xt.lit", sec->name, 7) == 0)
    return TRUE;

  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0)
    {
      if (strncmp ("p.", sec->name + linkonce_len, 2) == 0)
	return TRUE;
      if (strstr (sec->name + linkonce_len, ".xt.lit") != NULL)
	return TRUE;
    }
  return FALSE;
a5783 15
/* The default literal sections should always be marked as "code" (i.e.,
   SHF_EXECINSTR).  This is particularly important for the Linux kernel
   module loader so that the literals are not placed after the text.  */
static struct bfd_elf_special_section const elf_xtensa_special_sections[]=
{
  { ".literal",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init.literal",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".fini.literal",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a5843 1
#define elf_backend_special_sections	     elf_xtensa_special_sections
@


1.2.2.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d51 1
a51 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d802 1
a802 1
     const struct elf_backend_data *bed;
d2012 24
a2035 8
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);

	  if (relocation == 0
	      && !unresolved_reloc
	      && h->root.type == bfd_link_hash_undefweak)
d2037 14
a3577 1

d3586 1
a3586 1
    hash_val += hash_bfd_vma ((bfd_vma) (unsigned) r_reloc_get_section (&src->r_rel));
d3588 1
a3588 1
    hash_val += hash_bfd_vma ((bfd_vma) (unsigned) r_reloc_get_hash_entry (&src->r_rel));
@


1.2.2.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d215 2
d218 1
a218 1
  PARAMS ((asection *, const char *));
d507 1
a507 1
    xtensa_get_property_section_name (section, sec_name);
a508 1
  free (table_section_name);
d518 1
a518 1
  num_records = table_size / 8;
d560 1
a560 1
      for (off = 0; off < table_size; off += 8) 
d1180 1
a1180 1
      if (info->executable)
d2008 1
a2008 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2084 2
a2085 2
		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);
a2316 1
  free (table);
a5607 5
static int linkonce_len = sizeof (".gnu.linkonce.") - 1;
static int insn_sec_len = sizeof (XTENSA_INSN_SEC_NAME) - 1;
static int lit_sec_len = sizeof (XTENSA_LIT_SEC_NAME) - 1;


d5612 1
a5612 3
  if (strncmp (XTENSA_INSN_SEC_NAME, sec->name, insn_sec_len) == 0
      || strncmp (XTENSA_LIT_SEC_NAME, sec->name, lit_sec_len) == 0)
    return TRUE;
d5614 2
a5615 4
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0
      && (sec->name[linkonce_len] == 'x'
	  || sec->name[linkonce_len] == 'p')
      && sec->name[linkonce_len + 1] == '.')
d5618 9
d5635 1
a5635 2
  if (strncmp (XTENSA_LIT_SEC_NAME, sec->name, lit_sec_len) == 0)
    return TRUE;
d5637 1
a5637 3
  if (strncmp (".gnu.linkonce.", sec->name, linkonce_len) == 0
      && sec->name[linkonce_len] == 'p'
      && sec->name[linkonce_len + 1] == '.')
d5640 7
d5674 24
d5699 2
a5700 1
xtensa_get_property_section_name (sec, base_name)
d5702 1
a5702 1
     const char *base_name;
d5704 6
a5709 1
  if (strncmp (sec->name, ".gnu.linkonce.", linkonce_len) == 0)
d5711 24
a5734 8
      char *prop_sec_name;
      const char *suffix;
      char linkonce_kind = 0;

      if (strcmp (base_name, XTENSA_INSN_SEC_NAME) == 0) 
	linkonce_kind = 'x';
      else if (strcmp (base_name, XTENSA_LIT_SEC_NAME) == 0) 
	linkonce_kind = 'p';
a5735 9
	abort ();

      prop_sec_name = (char *) bfd_malloc (strlen (sec->name) + 1);
      memcpy (prop_sec_name, ".gnu.linkonce.", linkonce_len);
      prop_sec_name[linkonce_len] = linkonce_kind;
      prop_sec_name[linkonce_len + 1] = '.';

      suffix = sec->name + linkonce_len;
      while (*suffix)
d5737 5
a5741 3
	  suffix += 1;
	  if (suffix[-1] == '.')
	    break;
a5742 3
      strcpy (prop_sec_name + linkonce_len + 2, suffix);

      return prop_sec_name;
d5745 1
a5745 1
  return strdup (base_name);
d5844 8
a5851 4
  { ".literal",       8, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".fini.literal", 13, 0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { NULL,             0, 0, 0,            0 }
@


1.2.2.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d50 3
d66 1
a66 1
  PARAMS ((bfd *, struct bfd_link_info *));
d799 13
d1434 1
a1434 1
elf_xtensa_modify_segment_map (abfd, info)
a1435 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1732 1
a1732 1
  /* Work out which section the relocation is targeted at and the
d4189 1
a4189 1
   of relocations targeting each section is also counted so that we
d5853 1
@


1.1
log
@Add Xtensa port
@
text
@d1896 1
d1987 1
d2044 1
a2044 4

	      /* To avoid any more warning messages, like "call out of
		 range", we continue immediately to the next relocation.  */
	      continue;
d2173 1
a2173 1
      if (r != bfd_reloc_ok)
@


1.1.2.1
log
@Merge with mainline.
@
text
@a1895 1
      bfd_boolean warned;
a1985 1
      warned = FALSE;
d2042 4
a2045 1
	      warned = TRUE;
d2174 1
a2174 1
      if (r != bfd_reloc_ok && !warned)
@


