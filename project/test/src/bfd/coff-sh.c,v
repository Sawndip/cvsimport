head	1.44;
access;
symbols
	sid-snapshot-20180601:1.44
	sid-snapshot-20180501:1.44
	sid-snapshot-20180401:1.44
	sid-snapshot-20180301:1.44
	sid-snapshot-20180201:1.44
	sid-snapshot-20180101:1.44
	sid-snapshot-20171201:1.44
	sid-snapshot-20171101:1.44
	sid-snapshot-20171001:1.44
	sid-snapshot-20170901:1.44
	sid-snapshot-20170801:1.44
	sid-snapshot-20170701:1.44
	sid-snapshot-20170601:1.44
	sid-snapshot-20170501:1.44
	sid-snapshot-20170401:1.44
	sid-snapshot-20170301:1.44
	sid-snapshot-20170201:1.44
	sid-snapshot-20170101:1.44
	sid-snapshot-20161201:1.44
	sid-snapshot-20161101:1.44
	sid-snapshot-20160901:1.44
	sid-snapshot-20160801:1.44
	sid-snapshot-20160701:1.44
	sid-snapshot-20160601:1.44
	sid-snapshot-20160501:1.44
	sid-snapshot-20160401:1.44
	sid-snapshot-20160301:1.44
	sid-snapshot-20160201:1.44
	sid-snapshot-20160101:1.44
	sid-snapshot-20151201:1.44
	sid-snapshot-20151101:1.44
	sid-snapshot-20151001:1.44
	sid-snapshot-20150901:1.44
	sid-snapshot-20150801:1.44
	sid-snapshot-20150701:1.44
	sid-snapshot-20150601:1.44
	sid-snapshot-20150501:1.44
	sid-snapshot-20150401:1.44
	sid-snapshot-20150301:1.44
	sid-snapshot-20150201:1.44
	sid-snapshot-20150101:1.44
	sid-snapshot-20141201:1.44
	sid-snapshot-20141101:1.44
	sid-snapshot-20141001:1.44
	sid-snapshot-20140901:1.44
	sid-snapshot-20140801:1.44
	sid-snapshot-20140701:1.44
	sid-snapshot-20140601:1.44
	sid-snapshot-20140501:1.44
	sid-snapshot-20140401:1.44
	sid-snapshot-20140301:1.44
	sid-snapshot-20140201:1.44
	sid-snapshot-20140101:1.44
	sid-snapshot-20131201:1.44
	sid-snapshot-20131101:1.44
	sid-snapshot-20131001:1.44
	binutils-2_24-branch:1.44.0.8
	binutils-2_24-branchpoint:1.44
	binutils-2_21_1:1.41.10.1
	sid-snapshot-20130901:1.44
	gdb_7_6_1-2013-08-30-release:1.44
	sid-snapshot-20130801:1.44
	sid-snapshot-20130701:1.44
	sid-snapshot-20130601:1.44
	sid-snapshot-20130501:1.44
	gdb_7_6-2013-04-26-release:1.44
	sid-snapshot-20130401:1.44
	binutils-2_23_2:1.44
	gdb_7_6-branch:1.44.0.6
	gdb_7_6-2013-03-12-branchpoint:1.44
	sid-snapshot-20130301:1.44
	sid-snapshot-20130201:1.44
	sid-snapshot-20130101:1.44
	sid-snapshot-20121201:1.44
	gdb_7_5_1-2012-11-29-release:1.44
	binutils-2_23_1:1.44
	sid-snapshot-20121101:1.44
	binutils-2_23:1.44
	sid-snapshot-20121001:1.44
	sid-snapshot-20120901:1.44
	gdb_7_5-2012-08-17-release:1.44
	sid-snapshot-20120801:1.44
	binutils-2_23-branch:1.44.0.4
	binutils-2_23-branchpoint:1.44
	gdb_7_5-branch:1.44.0.2
	gdb_7_5-2012-07-18-branchpoint:1.44
	sid-snapshot-20120701:1.43
	sid-snapshot-20120601:1.43
	sid-snapshot-20120501:1.43
	binutils-2_22_branch:1.43.0.6
	gdb_7_4_1-2012-04-26-release:1.43
	sid-snapshot-20120401:1.43
	sid-snapshot-20120301:1.43
	sid-snapshot-20120201:1.43
	gdb_7_4-2012-01-24-release:1.43
	sid-snapshot-20120101:1.43
	gdb_7_4-branch:1.43.0.4
	gdb_7_4-2011-12-13-branchpoint:1.43
	sid-snapshot-20111201:1.43
	binutils-2_22:1.43
	sid-snapshot-20111101:1.43
	sid-snapshot-20111001:1.43
	binutils-2_22-branch:1.43.0.2
	binutils-2_22-branchpoint:1.43
	gdb_7_3_1-2011-09-04-release:1.42
	sid-snapshot-20110901:1.43
	sid-snapshot-20110801:1.43
	gdb_7_3-2011-07-26-release:1.42
	sid-snapshot-20110701:1.43
	sid-snapshot-20110601:1.42
	sid-snapshot-20110501:1.42
	gdb_7_3-branch:1.42.0.2
	gdb_7_3-2011-04-01-branchpoint:1.42
	sid-snapshot-20110401:1.42
	sid-snapshot-20110301:1.42
	sid-snapshot-20110201:1.42
	sid-snapshot-20110101:1.41
	binutils-2_21:1.41
	sid-snapshot-20101201:1.41
	binutils-2_21-branch:1.41.0.10
	binutils-2_21-branchpoint:1.41
	sid-snapshot-20101101:1.41
	sid-snapshot-20101001:1.41
	binutils-2_20_1:1.41
	gdb_7_2-2010-09-02-release:1.41
	sid-snapshot-20100901:1.41
	sid-snapshot-20100801:1.41
	gdb_7_2-branch:1.41.0.8
	gdb_7_2-2010-07-07-branchpoint:1.41
	sid-snapshot-20100701:1.41
	sid-snapshot-20100601:1.41
	sid-snapshot-20100501:1.41
	sid-snapshot-20100401:1.41
	gdb_7_1-2010-03-18-release:1.41
	sid-snapshot-20100301:1.41
	gdb_7_1-branch:1.41.0.6
	gdb_7_1-2010-02-18-branchpoint:1.41
	sid-snapshot-20100201:1.41
	sid-snapshot-20100101:1.41
	gdb_7_0_1-2009-12-22-release:1.41
	sid-snapshot-20091201:1.41
	sid-snapshot-20091101:1.41
	binutils-2_20:1.41
	gdb_7_0-2009-10-06-release:1.41
	sid-snapshot-20091001:1.41
	gdb_7_0-branch:1.41.0.4
	gdb_7_0-2009-09-16-branchpoint:1.41
	arc-sim-20090309:1.37
	binutils-arc-20081103-branch:1.39.0.12
	binutils-arc-20081103-branchpoint:1.39
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	sid-snapshot-20090901:1.40
	sid-snapshot-20090801:1.40
	msnyder-checkpoint-072509-branch:1.40.0.4
	msnyder-checkpoint-072509-branchpoint:1.40
	sid-snapshot-20090701:1.40
	dje-cgen-play1-branch:1.40.0.2
	dje-cgen-play1-branchpoint:1.40
	sid-snapshot-20090601:1.40
	sid-snapshot-20090501:1.40
	sid-snapshot-20090401:1.40
	arc-20081103-branch:1.39.0.10
	arc-20081103-branchpoint:1.39
	arc-insight_6_8-branch:1.37.0.14
	arc-insight_6_8-branchpoint:1.37
	insight_6_8-branch:1.37.0.12
	insight_6_8-branchpoint:1.37
	sid-snapshot-20090301:1.40
	binutils-2_19_1:1.39
	sid-snapshot-20090201:1.39
	sid-snapshot-20090101:1.39
	reverse-20081226-branch:1.39.0.8
	reverse-20081226-branchpoint:1.39
	sid-snapshot-20081201:1.39
	multiprocess-20081120-branch:1.39.0.6
	multiprocess-20081120-branchpoint:1.39
	sid-snapshot-20081101:1.39
	binutils-2_19:1.39
	sid-snapshot-20081001:1.39
	reverse-20080930-branch:1.39.0.4
	reverse-20080930-branchpoint:1.39
	binutils-2_19-branch:1.39.0.2
	binutils-2_19-branchpoint:1.39
	sid-snapshot-20080901:1.39
	sid-snapshot-20080801:1.39
	reverse-20080717-branch:1.37.0.10
	reverse-20080717-branchpoint:1.37
	sid-snapshot-20080701:1.37
	msnyder-reverse-20080609-branch:1.37.0.8
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.35.0.2
	drow-reverse-20070409-branchpoint:1.35
	sid-snapshot-20080601:1.37
	sid-snapshot-20080501:1.37
	sid-snapshot-20080403:1.37
	sid-snapshot-20080401:1.37
	gdb_6_8-2008-03-27-release:1.37
	sid-snapshot-20080301:1.37
	gdb_6_8-branch:1.37.0.6
	gdb_6_8-2008-02-26-branchpoint:1.37
	sid-snapshot-20080201:1.37
	sid-snapshot-20080101:1.37
	sid-snapshot-20071201:1.37
	sid-snapshot-20071101:1.37
	gdb_6_7_1-2007-10-29-release:1.37
	gdb_6_7-2007-10-10-release:1.37
	sid-snapshot-20071001:1.37
	gdb_6_7-branch:1.37.0.4
	gdb_6_7-2007-09-07-branchpoint:1.37
	binutils-2_18:1.37
	binutils-2_18-branch:1.37.0.2
	binutils-2_18-branchpoint:1.37
	insight_6_6-20070208-release:1.34
	binutils-csl-coldfire-4_1-32:1.33
	binutils-csl-sourcerygxx-4_1-32:1.33
	gdb_6_6-2006-12-18-release:1.34
	binutils-csl-innovasic-fido-3_4_4-33:1.33
	binutils-csl-sourcerygxx-3_4_4-32:1.31
	binutils-csl-coldfire-4_1-30:1.33
	binutils-csl-sourcerygxx-4_1-30:1.33
	binutils-csl-coldfire-4_1-28:1.33
	binutils-csl-sourcerygxx-4_1-29:1.33
	binutils-csl-sourcerygxx-4_1-28:1.33
	gdb_6_6-branch:1.34.0.2
	gdb_6_6-2006-11-15-branchpoint:1.34
	binutils-csl-arm-2006q3-27:1.33
	binutils-csl-sourcerygxx-4_1-27:1.33
	binutils-csl-arm-2006q3-26:1.33
	binutils-csl-sourcerygxx-4_1-26:1.33
	binutils-csl-sourcerygxx-4_1-25:1.33
	binutils-csl-sourcerygxx-4_1-24:1.33
	binutils-csl-sourcerygxx-4_1-23:1.33
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	binutils-csl-sourcerygxx-4_1-21:1.33
	binutils-csl-arm-2006q3-21:1.33
	binutils-csl-sourcerygxx-4_1-22:1.33
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.33
	binutils-csl-sourcerygxx-4_1-20:1.33
	binutils-csl-arm-2006q3-19:1.33
	binutils-csl-sourcerygxx-4_1-19:1.33
	binutils-csl-sourcerygxx-4_1-18:1.33
	binutils-csl-renesas-4_1-9:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.33
	binutils-csl-sourcerygxx-3_4_4-25:1.31
	nickrob-async-20060828-mergepoint:1.34
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	binutils-csl-renesas-4_1-8:1.33
	binutils-csl-renesas-4_1-7:1.33
	binutils-csl-renesas-4_1-6:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33
	binutils-csl-sourcerygxx-4_1-17:1.33
	gdb-csl-20060226-branch-local-2:1.33
	gdb-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-15:1.33
	gdb-csl-sourcerygxx-4_1-13:1.33
	binutils-csl-sourcerygxx-4_1-13:1.33
	binutils-2_17:1.33
	gdb-csl-sourcerygxx-4_1-12:1.33
	binutils-csl-sourcerygxx-4_1-12:1.33
	gdb-csl-sourcerygxx-3_4_4-21:1.33
	binutils-csl-sourcerygxx-3_4_4-21:1.33
	gdb_6_5-20060621-release:1.33
	binutils-csl-wrs-linux-3_4_4-24:1.31
	binutils-csl-wrs-linux-3_4_4-23:1.31
	gdb-csl-sourcerygxx-4_1-9:1.33
	binutils-csl-sourcerygxx-4_1-9:1.33
	gdb-csl-sourcerygxx-4_1-8:1.33
	binutils-csl-sourcerygxx-4_1-8:1.33
	gdb-csl-sourcerygxx-4_1-7:1.33
	binutils-csl-sourcerygxx-4_1-7:1.33
	gdb-csl-arm-2006q1-6:1.33
	binutils-csl-arm-2006q1-6:1.33
	gdb-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-wrs-linux-3_4_4-22:1.31
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33
	binutils-csl-coldfire-4_1-11:1.33
	gdb-csl-sourcerygxx-3_4_4-19:1.33
	binutils-csl-sourcerygxx-3_4_4-19:1.33
	gdb-csl-coldfire-4_1-10:1.33
	gdb_6_5-branch:1.33.0.30
	gdb_6_5-2006-05-14-branchpoint:1.33
	binutils-csl-coldfire-4_1-10:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33
	binutils-csl-sourcerygxx-4_1-5:1.33
	nickrob-async-20060513-branch:1.33.0.28
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.33
	binutils-csl-sourcerygxx-4_1-4:1.33
	msnyder-reverse-20060502-branch:1.33.0.26
	msnyder-reverse-20060502-branchpoint:1.33
	binutils-csl-wrs-linux-3_4_4-21:1.31
	gdb-csl-morpho-4_1-4:1.33
	binutils-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-wrs-linux-3_4_4-20:1.31
	readline_5_1-import-branch:1.33.0.24
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	binutils-2_17-branch:1.33.0.22
	binutils-2_17-branchpoint:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.20
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.18
	msnyder-reverse-20060331-branchpoint:1.33
	binutils-csl-2_17-branch:1.33.0.16
	binutils-csl-2_17-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.14
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.12
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.33
	msnyder-fork-checkpoint-branch:1.33.0.10
	msnyder-fork-checkpoint-branchpoint:1.33
	gdb-csl-gxxpro-6_3-branch:1.33.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.33
	gdb_6_4-branch:1.33.0.6
	gdb_6_4-2005-11-01-branchpoint:1.33
	gdb-csl-arm-20051020-branch:1.33.0.4
	gdb-csl-arm-20051020-branchpoint:1.33
	binutils-csl-gxxpro-3_4-branch:1.31.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.31
	binutils-2_16_1:1.31
	msnyder-tracepoint-checkpoint-branch:1.33.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.33
	gdb-csl-arm-20050325-2005-q1b:1.31
	binutils-csl-arm-2005q1b:1.31
	binutils-2_16:1.31
	gdb-csl-arm-20050325-2005-q1a:1.31
	binutils-csl-arm-2005q1a:1.31
	csl-arm-20050325-branch:1.31.0.6
	csl-arm-20050325-branchpoint:1.31
	binutils-csl-arm-2005q1-branch:1.31.0.4
	binutils-csl-arm-2005q1-branchpoint:1.31
	binutils-2_16-branch:1.31.0.2
	binutils-2_16-branchpoint:1.31
	csl-arm-2004-q3d:1.29
	gdb_6_3-20041109-release:1.28
	gdb_6_3-branch:1.28.0.2
	gdb_6_3-20041019-branchpoint:1.28
	csl-arm-2004-q3:1.28
	drow_intercu-merge-20040921:1.28
	drow_intercu-merge-20040915:1.28
	jimb-gdb_6_2-e500-branch:1.27.0.6
	jimb-gdb_6_2-e500-branchpoint:1.27
	gdb_6_2-20040730-release:1.27
	gdb_6_2-branch:1.27.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.27
	gdb_6_1_1-20040616-release:1.26
	binutils-2_15:1.26
	binutils-2_15-branchpoint:1.26
	csl-arm-2004-q1a:1.26
	csl-arm-2004-q1:1.26
	gdb_6_1-2004-04-05-release:1.26
	drow_intercu-merge-20040402:1.26
	drow_intercu-merge-20040327:1.26
	ezannoni_pie-20040323-branch:1.26.0.14
	ezannoni_pie-20040323-branchpoint:1.26
	cagney_tramp-20040321-mergepoint:1.26
	cagney_tramp-20040309-branch:1.26.0.12
	cagney_tramp-20040309-branchpoint:1.26
	gdb_6_1-branch:1.26.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.26
	drow_intercu-20040221-branch:1.26.0.8
	drow_intercu-20040221-branchpoint:1.26
	binutils-2_15-branch:1.26.0.6
	cagney_bfdfile-20040213-branch:1.26.0.4
	cagney_bfdfile-20040213-branchpoint:1.26
	drow-cplus-merge-20040208:1.26
	carlton_dictionary-20040126-merge:1.26
	cagney_bigcore-20040122-branch:1.26.0.2
	cagney_bigcore-20040122-branchpoint:1.26
	drow-cplus-merge-20040113:1.26
	csl-arm-2003-q4:1.26
	drow-cplus-merge-20031224:1.26
	drow-cplus-merge-20031220:1.26
	carlton_dictionary-20031215-merge:1.26
	drow-cplus-merge-20031214:1.26
	carlton-dictionary-20031111-merge:1.26
	gdb_6_0-2003-10-04-release:1.24
	kettenis_sparc-20030918-branch:1.25.0.6
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.4
	cagney_x86i386-20030821-branch:1.25.0.2
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.24.0.6
	gdb_6_0-2003-06-23-branchpoint:1.24
	jimb-ppc64-linux-20030613-branch:1.24.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.24
	binutils-2_14:1.23
	cagney_convert-20030606-branch:1.24.0.2
	cagney_convert-20030606-branchpoint:1.24
	cagney_writestrings-20030508-branch:1.23.0.12
	cagney_writestrings-20030508-branchpoint:1.23
	jimb-ppc64-linux-20030528-branch:1.23.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.23
	carlton_dictionary-20030523-merge:1.23
	cagney_fileio-20030521-branch:1.23.0.8
	cagney_fileio-20030521-branchpoint:1.23
	kettenis_i386newframe-20030517-mergepoint:1.23
	jimb-ppc64-linux-20030509-branch:1.23.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.23
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	binutils-2_14-branch:1.23.0.4
	binutils-2_14-branchpoint:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.2
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.22
	kettenis_i386newframe-20030406-branch:1.22.0.18
	kettenis_i386newframe-20030406-branchpoint:1.22
	cagney_frameaddr-20030403-branchpoint:1.22
	cagney_frameaddr-20030403-branch:1.22.0.16
	cagney_framebase-20030330-mergepoint:1.22
	cagney_framebase-20030326-branch:1.22.0.14
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.22.0.12
	cagney_lazyid-20030317-branchpoint:1.22
	kettenis-i386newframe-20030316-mergepoint:1.22
	offbyone-20030313-branch:1.22.0.10
	offbyone-20030313-branchpoint:1.22
	kettenis-i386newframe-20030308-branch:1.22.0.8
	kettenis-i386newframe-20030308-branchpoint:1.22
	carlton_dictionary-20030305-merge:1.22
	cagney_offbyone-20030303-branch:1.22.0.6
	cagney_offbyone-20030303-branchpoint:1.22
	carlton_dictionary-20030207-merge:1.22
	interps-20030202-branch:1.22.0.4
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.22.0.2
	cagney-unwind-20030108-branchpoint:1.22
	binutils-2_13_2_1:1.21
	binutils-2_13_2:1.21
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.21
	binutils-2_13_1:1.21
	kseitz_interps-20021105-merge:1.21
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.21
	drow-cplus-merge-20021025:1.21
	carlton_dictionary-20021025-merge:1.21
	carlton_dictionary-20021011-merge:1.21
	drow-cplus-branch:1.21.0.16
	drow-cplus-branchpoint:1.21
	kseitz_interps-20020930-merge:1.21
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.14
	carlton_dictionary-20020920-branchpoint:1.21
	sid-20020905-branchpoint:1.21
	sid-20020905-branch:1.21.0.12
	gdb_5_3-branch:1.21.0.10
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.8
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.21.0.6
	readline_4_3-import-branchpoint:1.21
	binutils-2_13:1.21
	gdb_5_2_1-2002-07-23-release:1.19
	binutils-2_13-branchpoint:1.21
	binutils-2_13-branch:1.21.0.4
	kseitz_interps-20020528-branch:1.21.0.2
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.20.0.4
	cagney_regbuf-20020515-branchpoint:1.20
	binutils-2_12_1:1.19.2.2
	jimb-macro-020506-branch:1.20.0.2
	jimb-macro-020506-branchpoint:1.20
	gdb_5_2-2002-04-29-release:1.19
	binutils-2_12:1.19
	gdb_5_2-branch:1.19.0.4
	gdb_5_2-2002-03-03-branchpoint:1.19
	binutils-2_12-branch:1.19.0.2
	binutils-2_12-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.4
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.2
	gdb_5_1-2001-07-29-branchpoint:1.15
	binutils-2_11_2:1.14.2.1
	binutils-2_11_1:1.14.2.1
	binutils-2_11:1.14
	x86_64versiong3:1.14
	binutils-2_11-branch:1.14.0.2
	insight-precleanup-2001-01-01:1.14
	binutils-2_10_1:1.11
	binutils-2_10:1.11
	gdb-premipsmulti-2000-06-06-branch:1.13.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.13
	gdb_5_0-2000-05-19-release:1.11
	gdb_4_18_2-2000-05-18-release:1.11
	gdb_4_95_1-2000-05-11-snapshot:1.11
	gdb_4_95_0-2000-04-27-snapshot:1.11
	gdb_5_0-2000-04-10-branch:1.11.0.4
	gdb_5_0-2000-04-10-branchpoint:1.11
	binutils-2_10-branch:1.11.0.2
	binutils-2_10-branchpoint:1.11
	binutils_latest_snapshot:1.44
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2012.07.13.14.22.45;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.06.01.26.02;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.14.12.35.56;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.41.10.1;
next	1.40;

1.40
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.21.14.09.57;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.13.09.07.36;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.04.15.53.03;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.03.11.40.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.31.23.13.16;	author bje;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.21.15.28.19;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.11.13.08.44;	author amodra;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.04.10.47.32;	author sveinse;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.11.17.15.53;	author drow;	state Exp;
branches
	1.21.14.1
	1.21.16.1;
next	1.20;

1.20
date	2002.03.07.18.11.20;	author hjl;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.23.17.05.52;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.07.18.32.07;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.16.00.54.12;	author kazu;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.05.01.04.47.39;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.28.13.50.57;	author cpopetz;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.18.56.10;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.17.00.33.34;	author amylaar;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.10.20.17.33;	author amylaar;	state Exp;
branches;
next	1.6;

1.6
date	99.09.07.04.28.27;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.05.21.01.37;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.28.44;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.18.48.20;	author amylaar;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.10.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.26.8.1
date	2004.09.16.17.00.14;	author drow;	state Exp;
branches;
next	;

1.21.14.1
date	2002.12.23.19.37.28;	author carlton;	state Exp;
branches;
next	1.21.14.2;

1.21.14.2
date	2003.04.16.19.56.41;	author carlton;	state Exp;
branches;
next	1.21.14.3;

1.21.14.3
date	2003.06.27.21.49.07;	author carlton;	state Exp;
branches;
next	1.21.14.4;

1.21.14.4
date	2003.11.11.23.50.08;	author carlton;	state Exp;
branches;
next	;

1.21.16.1
date	2003.12.14.20.26.35;	author drow;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.19.2.1
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.05.11.17.13.41;	author drow;	state Exp;
branches;
next	;

1.14.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.44
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@/* BFD back-end for Renesas Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.
   Written by Steve Chamberlain, <sac@@cygnus.com>.
   Relaxing code written by Ian Lance Taylor, <ian@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "coff/sh.h"
#include "coff/internal.h"

#undef  bfd_pe_print_pdata

#ifdef COFF_WITH_PE
#include "coff/pe.h"

#ifndef COFF_IMAGE_WITH_PE
static bfd_boolean sh_align_load_span
  (bfd *, asection *, bfd_byte *,
   bfd_boolean (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),
   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *);

#define _bfd_sh_align_load_span sh_align_load_span
#endif

#define	bfd_pe_print_pdata   _bfd_pe_print_ce_compressed_pdata

#else

#define	bfd_pe_print_pdata   NULL

#endif /* COFF_WITH_PE.  */

#include "libcoff.h"

/* Internal functions.  */

#ifdef COFF_WITH_PE
/* Can't build import tables with 2**4 alignment.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	2
#else
/* Default section alignment to 2**4.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	4
#endif

#ifdef COFF_IMAGE_WITH_PE
/* Align PE executables.  */
#define COFF_PAGE_SIZE 0x1000
#endif

/* Generate long file names.  */
#define COFF_LONG_FILENAMES

#ifdef COFF_WITH_PE
/* Return TRUE if this relocation should
   appear in the output .reloc section.  */

static bfd_boolean
in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,
	    reloc_howto_type * howto)
{
  return ! howto->pc_relative && howto->type != R_SH_IMAGEBASE;
}
#endif

static bfd_reloc_status_type
sh_reloc (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean
sh_relocate_section (bfd *, struct bfd_link_info *, bfd *, asection *,
		     bfd_byte *, struct internal_reloc *,
		     struct internal_syment *, asection **);
static bfd_boolean
sh_align_loads (bfd *, asection *, struct internal_reloc *,
		bfd_byte *, bfd_boolean *);

/* The supported relocations.  There are a lot of relocations defined
   in coff/internal.h which we do not expect to ever see.  */
static reloc_howto_type sh_coff_howtos[] =
{
  EMPTY_HOWTO (0),
  EMPTY_HOWTO (1),
#ifdef COFF_WITH_PE
  /* Windows CE */
  HOWTO (R_SH_IMM32CE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm32ce",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#else
  EMPTY_HOWTO (2),
#endif
  EMPTY_HOWTO (3), /* R_SH_PCREL8 */
  EMPTY_HOWTO (4), /* R_SH_PCREL16 */
  EMPTY_HOWTO (5), /* R_SH_HIGH8 */
  EMPTY_HOWTO (6), /* R_SH_IMM24 */
  EMPTY_HOWTO (7), /* R_SH_LOW16 */
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9), /* R_SH_PCDISP8BY4 */

  HOWTO (R_SH_PCDISP8BY2,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcdisp8by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (11), /* R_SH_PCDISP8 */

  HOWTO (R_SH_PCDISP,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcdisp12by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (13),

  HOWTO (R_SH_IMM32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (15),
#ifdef COFF_WITH_PE
  HOWTO (R_SH_IMAGEBASE,        /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,       	/* special_function */
	 "rva32",	        /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */
#else
  EMPTY_HOWTO (16), /* R_SH_IMM8 */
#endif
  EMPTY_HOWTO (17), /* R_SH_IMM8BY2 */
  EMPTY_HOWTO (18), /* R_SH_IMM8BY4 */
  EMPTY_HOWTO (19), /* R_SH_IMM4 */
  EMPTY_HOWTO (20), /* R_SH_IMM4BY2 */
  EMPTY_HOWTO (21), /* R_SH_IMM4BY4 */

  HOWTO (R_SH_PCRELIMM8BY2,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcrelimm8by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_PCRELIMM8BY4,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcrelimm8by4",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_IMM16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_USES,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_uses",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_COUNT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_count",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_ALIGN,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_align",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_CODE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_code",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DATA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_data",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_LABEL,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_label",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch8",		/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

#define SH_COFF_HOWTO_COUNT (sizeof sh_coff_howtos / sizeof sh_coff_howtos[0])

/* Check for a bad magic number.  */
#define BADMAG(x) SHBADMAG(x)

/* Customize coffcode.h (this is not currently used).  */
#define SH 1

/* FIXME: This should not be set here.  */
#define __A_MAGIC_SET__

#ifndef COFF_WITH_PE
/* Swap the r_offset field in and out.  */
#define SWAP_IN_RELOC_OFFSET  H_GET_32
#define SWAP_OUT_RELOC_OFFSET H_PUT_32

/* Swap out extra information in the reloc structure.  */
#define SWAP_OUT_RELOC_EXTRA(abfd, src, dst)	\
  do						\
    {						\
      dst->r_stuff[0] = 'S';			\
      dst->r_stuff[1] = 'C';			\
    }						\
  while (0)
#endif

/* Get the value of a symbol, when performing a relocation.  */

static long
get_symbol_value (asymbol *symbol)
{
  bfd_vma relocation;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = (symbol->value +
		  symbol->section->output_section->vma +
		  symbol->section->output_offset);

  return relocation;
}

#ifdef COFF_WITH_PE
/* Convert an rtype to howto for the COFF backend linker.
   Copied from coff-i386.  */
#define coff_rtype_to_howto coff_sh_rtype_to_howto


static reloc_howto_type *
coff_sh_rtype_to_howto (bfd * abfd ATTRIBUTE_UNUSED,
			asection * sec,
			struct internal_reloc * rel,
			struct coff_link_hash_entry * h,
			struct internal_syment * sym,
			bfd_vma * addendp)
{
  reloc_howto_type * howto;

  howto = sh_coff_howtos + rel->r_type;

  *addendp = 0;

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
    }

  if (howto->pc_relative)
    {
      *addendp -= 4;

      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	*addendp -= sym->n_value;
    }

  if (rel->r_type == R_SH_IMAGEBASE)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;

  return howto;
}

#endif /* COFF_WITH_PE */

/* This structure is used to map BFD reloc codes to SH PE relocs.  */
struct shcoff_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char shcoff_reloc_val;
};

#ifdef COFF_WITH_PE
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32CE },
  { BFD_RELOC_RVA, R_SH_IMAGEBASE },
  { BFD_RELOC_CTOR, R_SH_IMM32CE },
};
#else
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_CTOR, R_SH_IMM32 },
};
#endif

/* Given a BFD reloc code, return the howto structure for the
   corresponding SH PE reloc.  */
#define coff_bfd_reloc_type_lookup	sh_coff_reloc_type_lookup
#define coff_bfd_reloc_name_lookup sh_coff_reloc_name_lookup

static reloc_howto_type *
sh_coff_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = ARRAY_SIZE (sh_reloc_map); i--;)
    if (sh_reloc_map[i].bfd_reloc_val == code)
      return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];

  (*_bfd_error_handler) (_("SH Error: unknown reloc type %d"), code);
  return NULL;
}

static reloc_howto_type *
sh_coff_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   const char *r_name)
{
  unsigned int i;

  for (i = 0; i < sizeof (sh_coff_howtos) / sizeof (sh_coff_howtos[0]); i++)
    if (sh_coff_howtos[i].name != NULL
	&& strcasecmp (sh_coff_howtos[i].name, r_name) == 0)
      return &sh_coff_howtos[i];

  return NULL;
}

/* This macro is used in coffcode.h to get the howto corresponding to
   an internal reloc.  */

#define RTYPE2HOWTO(relent, internal)		\
  ((relent)->howto =				\
   ((internal)->r_type < SH_COFF_HOWTO_COUNT	\
    ? &sh_coff_howtos[(internal)->r_type]	\
    : (reloc_howto_type *) NULL))

/* This is the same as the macro in coffcode.h, except that it copies
   r_offset into reloc_entry->addend for some relocs.  */
#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)                \
  {                                                             \
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)                   \
      coffsym = (obj_symbols (abfd)                             \
                 + (cache_ptr->sym_ptr_ptr - symbols));         \
    else if (ptr)                                               \
      coffsym = coff_symbol_from (abfd, ptr);                   \
    if (coffsym != (coff_symbol_type *) NULL                    \
        && coffsym->native->u.syment.n_scnum == 0)              \
      cache_ptr->addend = 0;                                    \
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd               \
             && ptr->section != (asection *) NULL)              \
      cache_ptr->addend = - (ptr->section->vma + ptr->value);   \
    else                                                        \
      cache_ptr->addend = 0;                                    \
    if ((reloc).r_type == R_SH_SWITCH8				\
	|| (reloc).r_type == R_SH_SWITCH16			\
	|| (reloc).r_type == R_SH_SWITCH32			\
	|| (reloc).r_type == R_SH_USES				\
	|| (reloc).r_type == R_SH_COUNT				\
	|| (reloc).r_type == R_SH_ALIGN)			\
      cache_ptr->addend = (reloc).r_offset;			\
  }

/* This is the howto function for the SH relocations.  */

static bfd_reloc_status_type
sh_reloc (bfd *      abfd,
	  arelent *  reloc_entry,
	  asymbol *  symbol_in,
	  void *     data,
	  asection * input_section,
	  bfd *      output_bfd,
	  char **    error_message ATTRIBUTE_UNUSED)
{
  unsigned long insn;
  bfd_vma sym_value;
  unsigned short r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      /* Partial linking--do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Almost all relocs have to do with relaxing.  If any work must be
     done for them, it has been done in sh_relax_section.  */
  if (r_type != R_SH_IMM32
#ifdef COFF_WITH_PE
      && r_type != R_SH_IMM32CE
      && r_type != R_SH_IMAGEBASE
#endif
      && (r_type != R_SH_PCDISP
	  || (symbol_in->flags & BSF_LOCAL) != 0))
    return bfd_reloc_ok;

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    return bfd_reloc_undefined;

  sym_value = get_symbol_value (symbol_in);

  switch (r_type)
    {
    case R_SH_IMM32:
#ifdef COFF_WITH_PE
    case R_SH_IMM32CE:
#endif
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
#ifdef COFF_WITH_PE
    case R_SH_IMAGEBASE:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      insn -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
#endif
    case R_SH_PCDISP:
      insn = bfd_get_16 (abfd, hit_data);
      sym_value += reloc_entry->addend;
      sym_value -= (input_section->output_section->vma
		    + input_section->output_offset
		    + addr
		    + 4);
      sym_value += (insn & 0xfff) << 1;
      if (insn & 0x800)
	sym_value -= 0x1000;
      insn = (insn & 0xf000) | (sym_value & 0xfff);
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
      if (sym_value < (bfd_vma) -0x1000 || sym_value >= 0x1000)
	return bfd_reloc_overflow;
      break;
    default:
      abort ();
      break;
    }

  return bfd_reloc_ok;
}

#define coff_bfd_merge_private_bfd_data _bfd_generic_verify_endian_match

/* We can do relaxing.  */
#define coff_bfd_relax_section sh_relax_section

/* We use the special COFF backend linker.  */
#define coff_relocate_section sh_relocate_section

/* When relaxing, we need to use special code to get the relocated
   section contents.  */
#define coff_bfd_get_relocated_section_contents \
  sh_coff_get_relocated_section_contents

#include "coffcode.h"

static bfd_boolean
sh_relax_delete_bytes (bfd *, asection *, bfd_vma, int);

/* This function handles relaxing on the SH.

   Function calls on the SH look like this:

       movl  L1,r0
       ...
       jsr   @@r0
       ...
     L1:
       .long function

   The compiler and assembler will cooperate to create R_SH_USES
   relocs on the jsr instructions.  The r_offset field of the
   R_SH_USES reloc is the PC relative offset to the instruction which
   loads the register (the r_offset field is computed as though it
   were a jump instruction, so the offset value is actually from four
   bytes past the instruction).  The linker can use this reloc to
   determine just which function is being called, and thus decide
   whether it is possible to replace the jsr with a bsr.

   If multiple function calls are all based on a single register load
   (i.e., the same function is called multiple times), the compiler
   guarantees that each function call will have an R_SH_USES reloc.
   Therefore, if the linker is able to convert each R_SH_USES reloc
   which refers to that address, it can safely eliminate the register
   load.

   When the assembler creates an R_SH_USES reloc, it examines it to
   determine which address is being loaded (L1 in the above example).
   It then counts the number of references to that address, and
   creates an R_SH_COUNT reloc at that address.  The r_offset field of
   the R_SH_COUNT reloc will be the number of references.  If the
   linker is able to eliminate a register load, it can use the
   R_SH_COUNT reloc to see whether it can also eliminate the function
   address.

   SH relaxing also handles another, unrelated, matter.  On the SH, if
   a load or store instruction is not aligned on a four byte boundary,
   the memory cycle interferes with the 32 bit instruction fetch,
   causing a one cycle bubble in the pipeline.  Therefore, we try to
   align load and store instructions on four byte boundaries if we
   can, by swapping them with one of the adjacent instructions.  */

static bfd_boolean
sh_relax_section (bfd *abfd,
		  asection *sec,
		  struct bfd_link_info *link_info,
		  bfd_boolean *again)
{
  struct internal_reloc *internal_relocs;
  bfd_boolean have_code;
  struct internal_reloc *irel, *irelend;
  bfd_byte *contents = NULL;

  *again = FALSE;

  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

  if (coff_section_data (abfd, sec) == NULL)
    {
      bfd_size_type amt = sizeof (struct coff_section_tdata);
      sec->used_by_bfd = bfd_zalloc (abfd, amt);
      if (sec->used_by_bfd == NULL)
	return FALSE;
    }

  internal_relocs = (_bfd_coff_read_internal_relocs
		     (abfd, sec, link_info->keep_memory,
		      (bfd_byte *) NULL, FALSE,
		      (struct internal_reloc *) NULL));
  if (internal_relocs == NULL)
    goto error_return;

  have_code = FALSE;

  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma laddr, paddr, symval;
      unsigned short insn;
      struct internal_reloc *irelfn, *irelscan, *irelcount;
      struct internal_syment sym;
      bfd_signed_vma foff;

      if (irel->r_type == R_SH_CODE)
	have_code = TRUE;

      if (irel->r_type != R_SH_USES)
	continue;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (coff_section_data (abfd, sec)->contents != NULL)
	    contents = coff_section_data (abfd, sec)->contents;
	  else
	    {
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      /* The r_offset field of the R_SH_USES reloc will point us to
         the register load.  The 4 is because the r_offset field is
         computed as though it were a jump offset, which are based
         from 4 bytes after the jump instruction.  */
      laddr = irel->r_vaddr - sec->vma + 4;
      /* Careful to sign extend the 32-bit offset.  */
      laddr += ((irel->r_offset & 0xffffffff) ^ 0x80000000) - 0x80000000;
      if (laddr >= sec->size)
	{
	  (*_bfd_error_handler) ("%B: 0x%lx: warning: bad R_SH_USES offset",
				 abfd, (unsigned long) irel->r_vaddr);
	  continue;
	}
      insn = bfd_get_16 (abfd, contents + laddr);

      /* If the instruction is not mov.l NN,rN, we don't know what to do.  */
      if ((insn & 0xf000) != 0xd000)
	{
	  ((*_bfd_error_handler)
	   ("%B: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x",
	    abfd, (unsigned long) irel->r_vaddr, insn));
	  continue;
	}

      /* Get the address from which the register is being loaded.  The
      	 displacement in the mov.l instruction is quadrupled.  It is a
      	 displacement from four bytes after the movl instruction, but,
      	 before adding in the PC address, two least significant bits
      	 of the PC are cleared.  We assume that the section is aligned
      	 on a four byte boundary.  */
      paddr = insn & 0xff;
      paddr *= 4;
      paddr += (laddr + 4) &~ (bfd_vma) 3;
      if (paddr >= sec->size)
	{
	  ((*_bfd_error_handler)
	   ("%B: 0x%lx: warning: bad R_SH_USES load offset",
	    abfd, (unsigned long) irel->r_vaddr));
	  continue;
	}

      /* Get the reloc for the address from which the register is
         being loaded.  This reloc will tell us which function is
         actually being called.  */
      paddr += sec->vma;
      for (irelfn = internal_relocs; irelfn < irelend; irelfn++)
	if (irelfn->r_vaddr == paddr
#ifdef COFF_WITH_PE
	    && (irelfn->r_type == R_SH_IMM32
		|| irelfn->r_type == R_SH_IMM32CE
		|| irelfn->r_type == R_SH_IMAGEBASE)

#else
	    && irelfn->r_type == R_SH_IMM32
#endif
	    )
	  break;
      if (irelfn >= irelend)
	{
	  ((*_bfd_error_handler)
	   ("%B: 0x%lx: warning: could not find expected reloc",
	    abfd, (unsigned long) paddr));
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (! _bfd_coff_get_external_symbols (abfd))
	goto error_return;
      bfd_coff_swap_sym_in (abfd,
			    ((bfd_byte *) obj_coff_external_syms (abfd)
			     + (irelfn->r_symndx
				* bfd_coff_symesz (abfd))),
			    &sym);
      if (sym.n_scnum != 0 && sym.n_scnum != sec->target_index)
	{
	  ((*_bfd_error_handler)
	   ("%B: 0x%lx: warning: symbol in unexpected section",
	    abfd, (unsigned long) paddr));
	  continue;
	}

      if (sym.n_sclass != C_EXT)
	{
	  symval = (sym.n_value
		    - sec->vma
		    + sec->output_section->vma
		    + sec->output_offset);
	}
      else
	{
	  struct coff_link_hash_entry *h;

	  h = obj_coff_sym_hashes (abfd)[irelfn->r_symndx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      symval += bfd_get_32 (abfd, contents + paddr - sec->vma);

      /* See if this function call can be shortened.  */
      foff = (symval
	      - (irel->r_vaddr
		 - sec->vma
		 + sec->output_section->vma
		 + sec->output_offset
		 + 4));
      if (foff < -0x1000 || foff >= 0x1000)
	{
	  /* After all that work, we can't shorten this function call.  */
	  continue;
	}

      /* Shorten the function call.  */

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */

      coff_section_data (abfd, sec)->relocs = internal_relocs;
      coff_section_data (abfd, sec)->keep_relocs = TRUE;

      coff_section_data (abfd, sec)->contents = contents;
      coff_section_data (abfd, sec)->keep_contents = TRUE;

      obj_coff_keep_syms (abfd) = TRUE;

      /* Replace the jsr with a bsr.  */

      /* Change the R_SH_USES reloc into an R_SH_PCDISP reloc, and
         replace the jsr with a bsr.  */
      irel->r_type = R_SH_PCDISP;
      irel->r_symndx = irelfn->r_symndx;
      if (sym.n_sclass != C_EXT)
	{
	  /* If this needs to be changed because of future relaxing,
             it will be handled here like other internal PCDISP
             relocs.  */
	  bfd_put_16 (abfd,
		      (bfd_vma) 0xb000 | ((foff >> 1) & 0xfff),
		      contents + irel->r_vaddr - sec->vma);
	}
      else
	{
	  /* We can't fully resolve this yet, because the external
             symbol value may be changed by future relaxing.  We let
             the final link phase handle it.  */
	  bfd_put_16 (abfd, (bfd_vma) 0xb000,
		      contents + irel->r_vaddr - sec->vma);
	}

      /* See if there is another R_SH_USES reloc referring to the same
         register load.  */
      for (irelscan = internal_relocs; irelscan < irelend; irelscan++)
	if (irelscan->r_type == R_SH_USES
	    && laddr == irelscan->r_vaddr - sec->vma + 4 + irelscan->r_offset)
	  break;
      if (irelscan < irelend)
	{
	  /* Some other function call depends upon this register load,
	     and we have not yet converted that function call.
	     Indeed, we may never be able to convert it.  There is
	     nothing else we can do at this point.  */
	  continue;
	}

      /* Look for a R_SH_COUNT reloc on the location where the
         function address is stored.  Do this before deleting any
         bytes, to avoid confusion about the address.  */
      for (irelcount = internal_relocs; irelcount < irelend; irelcount++)
	if (irelcount->r_vaddr == paddr
	    && irelcount->r_type == R_SH_COUNT)
	  break;

      /* Delete the register load.  */
      if (! sh_relax_delete_bytes (abfd, sec, laddr, 2))
	goto error_return;

      /* That will change things, so, just in case it permits some
         other function call to come within range, we should relax
         again.  Note that this is not required, and it may be slow.  */
      *again = TRUE;

      /* Now check whether we got a COUNT reloc.  */
      if (irelcount >= irelend)
	{
	  ((*_bfd_error_handler)
	   ("%B: 0x%lx: warning: could not find expected COUNT reloc",
	    abfd, (unsigned long) paddr));
	  continue;
	}

      /* The number of uses is stored in the r_offset field.  We've
         just deleted one.  */
      if (irelcount->r_offset == 0)
	{
	  ((*_bfd_error_handler) ("%B: 0x%lx: warning: bad count",
				  abfd, (unsigned long) paddr));
	  continue;
	}

      --irelcount->r_offset;

      /* If there are no more uses, we can delete the address.  Reload
         the address from irelfn, in case it was changed by the
         previous call to sh_relax_delete_bytes.  */
      if (irelcount->r_offset == 0)
	{
	  if (! sh_relax_delete_bytes (abfd, sec,
				       irelfn->r_vaddr - sec->vma, 4))
	    goto error_return;
	}

      /* We've done all we can with that function call.  */
    }

  /* Look for load and store instructions that we can align on four
     byte boundaries.  */
  if (have_code)
    {
      bfd_boolean swapped;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (coff_section_data (abfd, sec)->contents != NULL)
	    contents = coff_section_data (abfd, sec)->contents;
	  else
	    {
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      if (! sh_align_loads (abfd, sec, internal_relocs, contents, &swapped))
	goto error_return;

      if (swapped)
	{
	  coff_section_data (abfd, sec)->relocs = internal_relocs;
	  coff_section_data (abfd, sec)->keep_relocs = TRUE;

	  coff_section_data (abfd, sec)->contents = contents;
	  coff_section_data (abfd, sec)->keep_contents = TRUE;

	  obj_coff_keep_syms (abfd) = TRUE;
	}
    }

  if (internal_relocs != NULL
      && internal_relocs != coff_section_data (abfd, sec)->relocs)
    {
      if (! link_info->keep_memory)
	free (internal_relocs);
      else
	coff_section_data (abfd, sec)->relocs = internal_relocs;
    }

  if (contents != NULL && contents != coff_section_data (abfd, sec)->contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	/* Cache the section contents for coff_link_input_bfd.  */
	coff_section_data (abfd, sec)->contents = contents;
    }

  return TRUE;

 error_return:
  if (internal_relocs != NULL
      && internal_relocs != coff_section_data (abfd, sec)->relocs)
    free (internal_relocs);
  if (contents != NULL && contents != coff_section_data (abfd, sec)->contents)
    free (contents);
  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
sh_relax_delete_bytes (bfd *abfd,
		       asection *sec,
		       bfd_vma addr,
		       int count)
{
  bfd_byte *contents;
  struct internal_reloc *irel, *irelend;
  struct internal_reloc *irelalign;
  bfd_vma toaddr;
  bfd_byte *esym, *esymend;
  bfd_size_type symesz;
  struct coff_link_hash_entry **sym_hash;
  asection *o;

  contents = coff_section_data (abfd, sec)->contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->size;

  irel = coff_section_data (abfd, sec)->relocs;
  irelend = irel + sec->reloc_count;
  for (; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_ALIGN
	  && irel->r_vaddr - sec->vma > addr
	  && count < (1 << irel->r_offset))
	{
	  irelalign = irel;
	  toaddr = irel->r_vaddr - sec->vma;
	  break;
	}
    }

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  if (irelalign == NULL)
    sec->size -= count;
  else
    {
      int i;

#define NOP_OPCODE (0x0009)

      BFD_ASSERT ((count & 1) == 0);
      for (i = 0; i < count; i += 2)
	bfd_put_16 (abfd, (bfd_vma) NOP_OPCODE, contents + toaddr - count + i);
    }

  /* Adjust all the relocs.  */
  for (irel = coff_section_data (abfd, sec)->relocs; irel < irelend; irel++)
    {
      bfd_vma nraddr, stop;
      bfd_vma start = 0;
      int insn = 0;
      struct internal_syment sym;
      int off, adjust, oinsn;
      bfd_signed_vma voff = 0;
      bfd_boolean overflow;

      /* Get the new reloc address.  */
      nraddr = irel->r_vaddr - sec->vma;
      if ((irel->r_vaddr - sec->vma > addr
	   && irel->r_vaddr - sec->vma < toaddr)
	  || (irel->r_type == R_SH_ALIGN
	      && irel->r_vaddr - sec->vma == toaddr))
	nraddr -= count;

      /* See if this reloc was for the bytes we have deleted, in which
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
      if (irel->r_vaddr - sec->vma >= addr
	  && irel->r_vaddr - sec->vma < addr + count
	  && irel->r_type != R_SH_ALIGN
	  && irel->r_type != R_SH_CODE
	  && irel->r_type != R_SH_DATA
	  && irel->r_type != R_SH_LABEL)
	irel->r_type = R_SH_UNUSED;

      /* If this is a PC relative reloc, see if the range it covers
         includes the bytes we have deleted.  */
      switch (irel->r_type)
	{
	default:
	  break;

	case R_SH_PCDISP8BY2:
	case R_SH_PCDISP:
	case R_SH_PCRELIMM8BY2:
	case R_SH_PCRELIMM8BY4:
	  start = irel->r_vaddr - sec->vma;
	  insn = bfd_get_16 (abfd, contents + nraddr);
	  break;
	}

      switch (irel->r_type)
	{
	default:
	  start = stop = addr;
	  break;

	case R_SH_IMM32:
#ifdef COFF_WITH_PE
	case R_SH_IMM32CE:
	case R_SH_IMAGEBASE:
#endif
	  /* If this reloc is against a symbol defined in this
             section, and the symbol will not be adjusted below, we
             must check the addend to see it will put the value in
             range to be adjusted, and hence must be changed.  */
	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irel->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass != C_EXT
	      && sym.n_scnum == sec->target_index
	      && ((bfd_vma) sym.n_value <= addr
		  || (bfd_vma) sym.n_value >= toaddr))
	    {
	      bfd_vma val;

	      val = bfd_get_32 (abfd, contents + nraddr);
	      val += sym.n_value;
	      if (val > addr && val < toaddr)
		bfd_put_32 (abfd, val - count, contents + nraddr);
	    }
	  start = stop = addr;
	  break;

	case R_SH_PCDISP8BY2:
	  off = insn & 0xff;
	  if (off & 0x80)
	    off -= 0x100;
	  stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);
	  break;

	case R_SH_PCDISP:
	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irel->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass == C_EXT)
	    start = stop = addr;
	  else
	    {
	      off = insn & 0xfff;
	      if (off & 0x800)
		off -= 0x1000;
	      stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);
	    }
	  break;

	case R_SH_PCRELIMM8BY2:
	  off = insn & 0xff;
	  stop = start + 4 + off * 2;
	  break;

	case R_SH_PCRELIMM8BY4:
	  off = insn & 0xff;
	  stop = (start &~ (bfd_vma) 3) + 4 + off * 4;
	  break;

	case R_SH_SWITCH8:
	case R_SH_SWITCH16:
	case R_SH_SWITCH32:
	  /* These relocs types represent
	       .word L2-L1
	     The r_offset field holds the difference between the reloc
	     address and L1.  That is the start of the reloc, and
	     adding in the contents gives us the top.  We must adjust
	     both the r_offset field and the section contents.  */

	  start = irel->r_vaddr - sec->vma;
	  stop = (bfd_vma) ((bfd_signed_vma) start - (long) irel->r_offset);

	  if (start > addr
	      && start < toaddr
	      && (stop <= addr || stop >= toaddr))
	    irel->r_offset += count;
	  else if (stop > addr
		   && stop < toaddr
		   && (start <= addr || start >= toaddr))
	    irel->r_offset -= count;

	  start = stop;

	  if (irel->r_type == R_SH_SWITCH16)
	    voff = bfd_get_signed_16 (abfd, contents + nraddr);
	  else if (irel->r_type == R_SH_SWITCH8)
	    voff = bfd_get_8 (abfd, contents + nraddr);
	  else
	    voff = bfd_get_signed_32 (abfd, contents + nraddr);
	  stop = (bfd_vma) ((bfd_signed_vma) start + voff);

	  break;

	case R_SH_USES:
	  start = irel->r_vaddr - sec->vma;
	  stop = (bfd_vma) ((bfd_signed_vma) start
			    + (long) irel->r_offset
			    + 4);
	  break;
	}

      if (start > addr
	  && start < toaddr
	  && (stop <= addr || stop >= toaddr))
	adjust = count;
      else if (stop > addr
	       && stop < toaddr
	       && (start <= addr || start >= toaddr))
	adjust = - count;
      else
	adjust = 0;

      if (adjust != 0)
	{
	  oinsn = insn;
	  overflow = FALSE;
	  switch (irel->r_type)
	    {
	    default:
	      abort ();
	      break;

	    case R_SH_PCDISP8BY2:
	    case R_SH_PCRELIMM8BY2:
	      insn += adjust / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_PCDISP:
	      insn += adjust / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_PCRELIMM8BY4:
	      BFD_ASSERT (adjust == count || count >= 4);
	      if (count >= 4)
		insn += adjust / 4;
	      else
		{
		  if ((irel->r_vaddr & 3) == 0)
		    ++insn;
		}
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_SWITCH8:
	      voff += adjust;
	      if (voff < 0 || voff >= 0xff)
		overflow = TRUE;
	      bfd_put_8 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH16:
	      voff += adjust;
	      if (voff < - 0x8000 || voff >= 0x8000)
		overflow = TRUE;
	      bfd_put_signed_16 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH32:
	      voff += adjust;
	      bfd_put_signed_32 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_USES:
	      irel->r_offset += adjust;
	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       ("%B: 0x%lx: fatal: reloc overflow while relaxing",
		abfd, (unsigned long) irel->r_vaddr));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      irel->r_vaddr = nraddr + sec->vma;
    }

  /* Look through all the other sections.  If there contain any IMM32
     relocs against internal symbols which we are not going to adjust
     below, we may need to adjust the addends.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *internal_relocs;
      struct internal_reloc *irelscan, *irelscanend;
      bfd_byte *ocontents;

      if (o == sec
	  || (o->flags & SEC_RELOC) == 0
	  || o->reloc_count == 0)
	continue;

      /* We always cache the relocs.  Perhaps, if info->keep_memory is
         FALSE, we should free them, if we are permitted to, when we
         leave sh_coff_relax_section.  */
      internal_relocs = (_bfd_coff_read_internal_relocs
			 (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,
			  (struct internal_reloc *) NULL));
      if (internal_relocs == NULL)
	return FALSE;

      ocontents = NULL;
      irelscanend = internal_relocs + o->reloc_count;
      for (irelscan = internal_relocs; irelscan < irelscanend; irelscan++)
	{
	  struct internal_syment sym;

#ifdef COFF_WITH_PE
	  if (irelscan->r_type != R_SH_IMM32
	      && irelscan->r_type != R_SH_IMAGEBASE
	      && irelscan->r_type != R_SH_IMM32CE)
#else
	  if (irelscan->r_type != R_SH_IMM32)
#endif
	    continue;

	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irelscan->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass != C_EXT
	      && sym.n_scnum == sec->target_index
	      && ((bfd_vma) sym.n_value <= addr
		  || (bfd_vma) sym.n_value >= toaddr))
	    {
	      bfd_vma val;

	      if (ocontents == NULL)
		{
		  if (coff_section_data (abfd, o)->contents != NULL)
		    ocontents = coff_section_data (abfd, o)->contents;
		  else
		    {
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			return FALSE;
		      /* We always cache the section contents.
                         Perhaps, if info->keep_memory is FALSE, we
                         should free them, if we are permitted to,
                         when we leave sh_coff_relax_section.  */
		      coff_section_data (abfd, o)->contents = ocontents;
		    }
		}

	      val = bfd_get_32 (abfd, ocontents + irelscan->r_vaddr - o->vma);
	      val += sym.n_value;
	      if (val > addr && val < toaddr)
		bfd_put_32 (abfd, val - count,
			    ocontents + irelscan->r_vaddr - o->vma);

	      coff_section_data (abfd, o)->keep_contents = TRUE;
	    }
	}
    }

  /* Adjusting the internal symbols will not work if something has
     already retrieved the generic symbols.  It would be possible to
     make this work by adjusting the generic symbols at the same time.
     However, this case should not arise in normal usage.  */
  if (obj_symbols (abfd) != NULL
      || obj_raw_syments (abfd) != NULL)
    {
      ((*_bfd_error_handler)
       ("%B: fatal: generic symbols retrieved before relaxing", abfd));
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Adjust all the symbols.  */
  sym_hash = obj_coff_sym_hashes (abfd);
  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esymend = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esymend)
    {
      struct internal_syment isym;

      bfd_coff_swap_sym_in (abfd, esym, &isym);

      if (isym.n_scnum == sec->target_index
	  && (bfd_vma) isym.n_value > addr
	  && (bfd_vma) isym.n_value < toaddr)
	{
	  isym.n_value -= count;

	  bfd_coff_swap_sym_out (abfd, &isym, esym);

	  if (*sym_hash != NULL)
	    {
	      BFD_ASSERT ((*sym_hash)->root.type == bfd_link_hash_defined
			  || (*sym_hash)->root.type == bfd_link_hash_defweak);
	      BFD_ASSERT ((*sym_hash)->root.u.def.value >= addr
			  && (*sym_hash)->root.u.def.value < toaddr);
	      (*sym_hash)->root.u.def.value -= count;
	    }
	}

      esym += (isym.n_numaux + 1) * symesz;
      sym_hash += isym.n_numaux + 1;
    }

  /* See if we can move the ALIGN reloc forward.  We have adjusted
     r_vaddr for it already.  */
  if (irelalign != NULL)
    {
      bfd_vma alignto, alignaddr;

      alignto = BFD_ALIGN (toaddr, 1 << irelalign->r_offset);
      alignaddr = BFD_ALIGN (irelalign->r_vaddr - sec->vma,
			     1 << irelalign->r_offset);
      if (alignto != alignaddr)
	{
	  /* Tail recursion.  */
	  return sh_relax_delete_bytes (abfd, sec, alignaddr,
					(int) (alignto - alignaddr));
	}
    }

  return TRUE;
}

/* This is yet another version of the SH opcode table, used to rapidly
   get information about a particular instruction.  */

/* The opcode map is represented by an array of these structures.  The
   array is indexed by the high order four bits in the instruction.  */

struct sh_major_opcode
{
  /* A pointer to the instruction list.  This is an array which
     contains all the instructions with this major opcode.  */
  const struct sh_minor_opcode *minor_opcodes;
  /* The number of elements in minor_opcodes.  */
  unsigned short count;
};

/* This structure holds information for a set of SH opcodes.  The
   instruction code is anded with the mask value, and the resulting
   value is used to search the order opcode list.  */

struct sh_minor_opcode
{
  /* The sorted opcode list.  */
  const struct sh_opcode *opcodes;
  /* The number of elements in opcodes.  */
  unsigned short count;
  /* The mask value to use when searching the opcode list.  */
  unsigned short mask;
};

/* This structure holds information for an SH instruction.  An array
   of these structures is sorted in order by opcode.  */

struct sh_opcode
{
  /* The code for this instruction, after it has been anded with the
     mask value in the sh_major_opcode structure.  */
  unsigned short opcode;
  /* Flags for this instruction.  */
  unsigned long flags;
};

/* Flag which appear in the sh_opcode structure.  */

/* This instruction loads a value from memory.  */
#define LOAD (0x1)

/* This instruction stores a value to memory.  */
#define STORE (0x2)

/* This instruction is a branch.  */
#define BRANCH (0x4)

/* This instruction has a delay slot.  */
#define DELAY (0x8)

/* This instruction uses the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define USES1 (0x10)
#define USES1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction uses the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define USES2 (0x20)
#define USES2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction uses the value in register 0.  */
#define USESR0 (0x40)

/* This instruction sets the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define SETS1 (0x80)
#define SETS1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction sets the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define SETS2 (0x100)
#define SETS2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction sets register 0.  */
#define SETSR0 (0x200)

/* This instruction sets a special register.  */
#define SETSSP (0x400)

/* This instruction uses a special register.  */
#define USESSP (0x800)

/* This instruction uses the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define USESF1 (0x1000)
#define USESF1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction uses the floating point register in the field at
   mask 0x00f0 of the instruction.  */
#define USESF2 (0x2000)
#define USESF2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction uses floating point register 0.  */
#define USESF0 (0x4000)

/* This instruction sets the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define SETSF1 (0x8000)
#define SETSF1_REG(x) ((x & 0x0f00) >> 8)

#define USESAS (0x10000)
#define USESAS_REG(x) (((((x) >> 8) - 2) & 3) + 2)
#define USESR8 (0x20000)
#define SETSAS (0x40000)
#define SETSAS_REG(x) USESAS_REG (x)

#define MAP(a) a, sizeof a / sizeof a[0]

#ifndef COFF_IMAGE_WITH_PE

/* The opcode maps.  */

static const struct sh_opcode sh_opcode00[] =
{
  { 0x0008, SETSSP },			/* clrt */
  { 0x0009, 0 },			/* nop */
  { 0x000b, BRANCH | DELAY | USESSP },	/* rts */
  { 0x0018, SETSSP },			/* sett */
  { 0x0019, SETSSP },			/* div0u */
  { 0x001b, 0 },			/* sleep */
  { 0x0028, SETSSP },			/* clrmac */
  { 0x002b, BRANCH | DELAY | SETSSP },	/* rte */
  { 0x0038, USESSP | SETSSP },		/* ldtlb */
  { 0x0048, SETSSP },			/* clrs */
  { 0x0058, SETSSP }			/* sets */
};

static const struct sh_opcode sh_opcode01[] =
{
  { 0x0003, BRANCH | DELAY | USES1 | SETSSP },	/* bsrf rn */
  { 0x000a, SETS1 | USESSP },			/* sts mach,rn */
  { 0x001a, SETS1 | USESSP },			/* sts macl,rn */
  { 0x0023, BRANCH | DELAY | USES1 },		/* braf rn */
  { 0x0029, SETS1 | USESSP },			/* movt rn */
  { 0x002a, SETS1 | USESSP },			/* sts pr,rn */
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn / sts dsr,rn */
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
  { 0x007a, SETS1 | USESSP },			/* sts a0,rn */
  { 0x008a, SETS1 | USESSP },			/* sts x0,rn */
  { 0x009a, SETS1 | USESSP },			/* sts x1,rn */
  { 0x00aa, SETS1 | USESSP },			/* sts y0,rn */
  { 0x00ba, SETS1 | USESSP }			/* sts y1,rn */
};

static const struct sh_opcode sh_opcode02[] =
{
  { 0x0002, SETS1 | USESSP },			/* stc <special_reg>,rn */
  { 0x0004, STORE | USES1 | USES2 | USESR0 },	/* mov.b rm,@@(r0,rn) */
  { 0x0005, STORE | USES1 | USES2 | USESR0 },	/* mov.w rm,@@(r0,rn) */
  { 0x0006, STORE | USES1 | USES2 | USESR0 },	/* mov.l rm,@@(r0,rn) */
  { 0x0007, SETSSP | USES1 | USES2 },		/* mul.l rm,rn */
  { 0x000c, LOAD | SETS1 | USES2 | USESR0 },	/* mov.b @@(r0,rm),rn */
  { 0x000d, LOAD | SETS1 | USES2 | USESR0 },	/* mov.w @@(r0,rm),rn */
  { 0x000e, LOAD | SETS1 | USES2 | USESR0 },	/* mov.l @@(r0,rm),rn */
  { 0x000f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.l @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode0[] =
{
  { MAP (sh_opcode00), 0xffff },
  { MAP (sh_opcode01), 0xf0ff },
  { MAP (sh_opcode02), 0xf00f }
};

static const struct sh_opcode sh_opcode10[] =
{
  { 0x1000, STORE | USES1 | USES2 }	/* mov.l rm,@@(disp,rn) */
};

static const struct sh_minor_opcode sh_opcode1[] =
{
  { MAP (sh_opcode10), 0xf000 }
};

static const struct sh_opcode sh_opcode20[] =
{
  { 0x2000, STORE | USES1 | USES2 },		/* mov.b rm,@@rn */
  { 0x2001, STORE | USES1 | USES2 },		/* mov.w rm,@@rn */
  { 0x2002, STORE | USES1 | USES2 },		/* mov.l rm,@@rn */
  { 0x2004, STORE | SETS1 | USES1 | USES2 },	/* mov.b rm,@@-rn */
  { 0x2005, STORE | SETS1 | USES1 | USES2 },	/* mov.w rm,@@-rn */
  { 0x2006, STORE | SETS1 | USES1 | USES2 },	/* mov.l rm,@@-rn */
  { 0x2007, SETSSP | USES1 | USES2 | USESSP },	/* div0s */
  { 0x2008, SETSSP | USES1 | USES2 },		/* tst rm,rn */
  { 0x2009, SETS1 | USES1 | USES2 },		/* and rm,rn */
  { 0x200a, SETS1 | USES1 | USES2 },		/* xor rm,rn */
  { 0x200b, SETS1 | USES1 | USES2 },		/* or rm,rn */
  { 0x200c, SETSSP | USES1 | USES2 },		/* cmp/str rm,rn */
  { 0x200d, SETS1 | USES1 | USES2 },		/* xtrct rm,rn */
  { 0x200e, SETSSP | USES1 | USES2 },		/* mulu.w rm,rn */
  { 0x200f, SETSSP | USES1 | USES2 }		/* muls.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode2[] =
{
  { MAP (sh_opcode20), 0xf00f }
};

static const struct sh_opcode sh_opcode30[] =
{
  { 0x3000, SETSSP | USES1 | USES2 },		/* cmp/eq rm,rn */
  { 0x3002, SETSSP | USES1 | USES2 },		/* cmp/hs rm,rn */
  { 0x3003, SETSSP | USES1 | USES2 },		/* cmp/ge rm,rn */
  { 0x3004, SETSSP | USESSP | USES1 | USES2 },	/* div1 rm,rn */
  { 0x3005, SETSSP | USES1 | USES2 },		/* dmulu.l rm,rn */
  { 0x3006, SETSSP | USES1 | USES2 },		/* cmp/hi rm,rn */
  { 0x3007, SETSSP | USES1 | USES2 },		/* cmp/gt rm,rn */
  { 0x3008, SETS1 | USES1 | USES2 },		/* sub rm,rn */
  { 0x300a, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* subc rm,rn */
  { 0x300b, SETS1 | SETSSP | USES1 | USES2 },	/* subv rm,rn */
  { 0x300c, SETS1 | USES1 | USES2 },		/* add rm,rn */
  { 0x300d, SETSSP | USES1 | USES2 },		/* dmuls.l rm,rn */
  { 0x300e, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* addc rm,rn */
  { 0x300f, SETS1 | SETSSP | USES1 | USES2 }	/* addv rm,rn */
};

static const struct sh_minor_opcode sh_opcode3[] =
{
  { MAP (sh_opcode30), 0xf00f }
};

static const struct sh_opcode sh_opcode40[] =
{
  { 0x4000, SETS1 | SETSSP | USES1 },		/* shll rn */
  { 0x4001, SETS1 | SETSSP | USES1 },		/* shlr rn */
  { 0x4002, STORE | SETS1 | USES1 | USESSP },	/* sts.l mach,@@-rn */
  { 0x4004, SETS1 | SETSSP | USES1 },		/* rotl rn */
  { 0x4005, SETS1 | SETSSP | USES1 },		/* rotr rn */
  { 0x4006, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,mach */
  { 0x4008, SETS1 | USES1 },			/* shll2 rn */
  { 0x4009, SETS1 | USES1 },			/* shlr2 rn */
  { 0x400a, SETSSP | USES1 },			/* lds rm,mach */
  { 0x400b, BRANCH | DELAY | USES1 },		/* jsr @@rn */
  { 0x4010, SETS1 | SETSSP | USES1 },		/* dt rn */
  { 0x4011, SETSSP | USES1 },			/* cmp/pz rn */
  { 0x4012, STORE | SETS1 | USES1 | USESSP },	/* sts.l macl,@@-rn */
  { 0x4014, SETSSP | USES1 },			/* setrc rm */
  { 0x4015, SETSSP | USES1 },			/* cmp/pl rn */
  { 0x4016, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,macl */
  { 0x4018, SETS1 | USES1 },			/* shll8 rn */
  { 0x4019, SETS1 | USES1 },			/* shlr8 rn */
  { 0x401a, SETSSP | USES1 },			/* lds rm,macl */
  { 0x401b, LOAD | SETSSP | USES1 },		/* tas.b @@rn */
  { 0x4020, SETS1 | SETSSP | USES1 },		/* shal rn */
  { 0x4021, SETS1 | SETSSP | USES1 },		/* shar rn */
  { 0x4022, STORE | SETS1 | USES1 | USESSP },	/* sts.l pr,@@-rn */
  { 0x4024, SETS1 | SETSSP | USES1 | USESSP },	/* rotcl rn */
  { 0x4025, SETS1 | SETSSP | USES1 | USESSP },	/* rotcr rn */
  { 0x4026, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,pr */
  { 0x4028, SETS1 | USES1 },			/* shll16 rn */
  { 0x4029, SETS1 | USES1 },			/* shlr16 rn */
  { 0x402a, SETSSP | USES1 },			/* lds rm,pr */
  { 0x402b, BRANCH | DELAY | USES1 },		/* jmp @@rn */
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr / dsr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr / dsr */
  { 0x406a, SETSSP | USES1 },			/* lds rm,fpscr / lds rm,dsr */
  { 0x4072, STORE | SETS1 | USES1 | USESSP },	/* sts.l a0,@@-rn */
  { 0x4076, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,a0 */
  { 0x407a, SETSSP | USES1 },			/* lds.l rm,a0 */
  { 0x4082, STORE | SETS1 | USES1 | USESSP },	/* sts.l x0,@@-rn */
  { 0x4086, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x0 */
  { 0x408a, SETSSP | USES1 },			/* lds.l rm,x0 */
  { 0x4092, STORE | SETS1 | USES1 | USESSP },	/* sts.l x1,@@-rn */
  { 0x4096, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x1 */
  { 0x409a, SETSSP | USES1 },			/* lds.l rm,x1 */
  { 0x40a2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y0,@@-rn */
  { 0x40a6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y0 */
  { 0x40aa, SETSSP | USES1 },			/* lds.l rm,y0 */
  { 0x40b2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y1,@@-rn */
  { 0x40b6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y1 */
  { 0x40ba, SETSSP | USES1 }			/* lds.l rm,y1 */
};

static const struct sh_opcode sh_opcode41[] =
{
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l <special_reg>,@@-rn */
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,<special_reg> */
  { 0x400c, SETS1 | USES1 | USES2 },		/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },		/* shld rm,rn */
  { 0x400e, SETSSP | USES1 },			/* ldc rm,<special_reg> */
  { 0x400f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.w @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode4[] =
{
  { MAP (sh_opcode40), 0xf0ff },
  { MAP (sh_opcode41), 0xf00f }
};

static const struct sh_opcode sh_opcode50[] =
{
  { 0x5000, LOAD | SETS1 | USES2 }	/* mov.l @@(disp,rm),rn */
};

static const struct sh_minor_opcode sh_opcode5[] =
{
  { MAP (sh_opcode50), 0xf000 }
};

static const struct sh_opcode sh_opcode60[] =
{
  { 0x6000, LOAD | SETS1 | USES2 },		/* mov.b @@rm,rn */
  { 0x6001, LOAD | SETS1 | USES2 },		/* mov.w @@rm,rn */
  { 0x6002, LOAD | SETS1 | USES2 },		/* mov.l @@rm,rn */
  { 0x6003, SETS1 | USES2 },			/* mov rm,rn */
  { 0x6004, LOAD | SETS1 | SETS2 | USES2 },	/* mov.b @@rm+,rn */
  { 0x6005, LOAD | SETS1 | SETS2 | USES2 },	/* mov.w @@rm+,rn */
  { 0x6006, LOAD | SETS1 | SETS2 | USES2 },	/* mov.l @@rm+,rn */
  { 0x6007, SETS1 | USES2 },			/* not rm,rn */
  { 0x6008, SETS1 | USES2 },			/* swap.b rm,rn */
  { 0x6009, SETS1 | USES2 },			/* swap.w rm,rn */
  { 0x600a, SETS1 | SETSSP | USES2 | USESSP },	/* negc rm,rn */
  { 0x600b, SETS1 | USES2 },			/* neg rm,rn */
  { 0x600c, SETS1 | USES2 },			/* extu.b rm,rn */
  { 0x600d, SETS1 | USES2 },			/* extu.w rm,rn */
  { 0x600e, SETS1 | USES2 },			/* exts.b rm,rn */
  { 0x600f, SETS1 | USES2 }			/* exts.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode6[] =
{
  { MAP (sh_opcode60), 0xf00f }
};

static const struct sh_opcode sh_opcode70[] =
{
  { 0x7000, SETS1 | USES1 }		/* add #imm,rn */
};

static const struct sh_minor_opcode sh_opcode7[] =
{
  { MAP (sh_opcode70), 0xf000 }
};

static const struct sh_opcode sh_opcode80[] =
{
  { 0x8000, STORE | USES2 | USESR0 },	/* mov.b r0,@@(disp,rn) */
  { 0x8100, STORE | USES2 | USESR0 },	/* mov.w r0,@@(disp,rn) */
  { 0x8200, SETSSP },			/* setrc #imm */
  { 0x8400, LOAD | SETSR0 | USES2 },	/* mov.b @@(disp,rm),r0 */
  { 0x8500, LOAD | SETSR0 | USES2 },	/* mov.w @@(disp,rn),r0 */
  { 0x8800, SETSSP | USESR0 },		/* cmp/eq #imm,r0 */
  { 0x8900, BRANCH | USESSP },		/* bt label */
  { 0x8b00, BRANCH | USESSP },		/* bf label */
  { 0x8c00, SETSSP },			/* ldrs @@(disp,pc) */
  { 0x8d00, BRANCH | DELAY | USESSP },	/* bt/s label */
  { 0x8e00, SETSSP },			/* ldre @@(disp,pc) */
  { 0x8f00, BRANCH | DELAY | USESSP }	/* bf/s label */
};

static const struct sh_minor_opcode sh_opcode8[] =
{
  { MAP (sh_opcode80), 0xff00 }
};

static const struct sh_opcode sh_opcode90[] =
{
  { 0x9000, LOAD | SETS1 }	/* mov.w @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcode9[] =
{
  { MAP (sh_opcode90), 0xf000 }
};

static const struct sh_opcode sh_opcodea0[] =
{
  { 0xa000, BRANCH | DELAY }	/* bra label */
};

static const struct sh_minor_opcode sh_opcodea[] =
{
  { MAP (sh_opcodea0), 0xf000 }
};

static const struct sh_opcode sh_opcodeb0[] =
{
  { 0xb000, BRANCH | DELAY }	/* bsr label */
};

static const struct sh_minor_opcode sh_opcodeb[] =
{
  { MAP (sh_opcodeb0), 0xf000 }
};

static const struct sh_opcode sh_opcodec0[] =
{
  { 0xc000, STORE | USESR0 | USESSP },		/* mov.b r0,@@(disp,gbr) */
  { 0xc100, STORE | USESR0 | USESSP },		/* mov.w r0,@@(disp,gbr) */
  { 0xc200, STORE | USESR0 | USESSP },		/* mov.l r0,@@(disp,gbr) */
  { 0xc300, BRANCH | USESSP },			/* trapa #imm */
  { 0xc400, LOAD | SETSR0 | USESSP },		/* mov.b @@(disp,gbr),r0 */
  { 0xc500, LOAD | SETSR0 | USESSP },		/* mov.w @@(disp,gbr),r0 */
  { 0xc600, LOAD | SETSR0 | USESSP },		/* mov.l @@(disp,gbr),r0 */
  { 0xc700, SETSR0 },				/* mova @@(disp,pc),r0 */
  { 0xc800, SETSSP | USESR0 },			/* tst #imm,r0 */
  { 0xc900, SETSR0 | USESR0 },			/* and #imm,r0 */
  { 0xca00, SETSR0 | USESR0 },			/* xor #imm,r0 */
  { 0xcb00, SETSR0 | USESR0 },			/* or #imm,r0 */
  { 0xcc00, LOAD | SETSSP | USESR0 | USESSP },	/* tst.b #imm,@@(r0,gbr) */
  { 0xcd00, LOAD | STORE | USESR0 | USESSP },	/* and.b #imm,@@(r0,gbr) */
  { 0xce00, LOAD | STORE | USESR0 | USESSP },	/* xor.b #imm,@@(r0,gbr) */
  { 0xcf00, LOAD | STORE | USESR0 | USESSP }	/* or.b #imm,@@(r0,gbr) */
};

static const struct sh_minor_opcode sh_opcodec[] =
{
  { MAP (sh_opcodec0), 0xff00 }
};

static const struct sh_opcode sh_opcoded0[] =
{
  { 0xd000, LOAD | SETS1 }		/* mov.l @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcoded[] =
{
  { MAP (sh_opcoded0), 0xf000 }
};

static const struct sh_opcode sh_opcodee0[] =
{
  { 0xe000, SETS1 }		/* mov #imm,rn */
};

static const struct sh_minor_opcode sh_opcodee[] =
{
  { MAP (sh_opcodee0), 0xf000 }
};

static const struct sh_opcode sh_opcodef0[] =
{
  { 0xf000, SETSF1 | USESF1 | USESF2 },		/* fadd fm,fn */
  { 0xf001, SETSF1 | USESF1 | USESF2 },		/* fsub fm,fn */
  { 0xf002, SETSF1 | USESF1 | USESF2 },		/* fmul fm,fn */
  { 0xf003, SETSF1 | USESF1 | USESF2 },		/* fdiv fm,fn */
  { 0xf004, SETSSP | USESF1 | USESF2 },		/* fcmp/eq fm,fn */
  { 0xf005, SETSSP | USESF1 | USESF2 },		/* fcmp/gt fm,fn */
  { 0xf006, LOAD | SETSF1 | USES2 | USESR0 },	/* fmov.s @@(r0,rm),fn */
  { 0xf007, STORE | USES1 | USESF2 | USESR0 },	/* fmov.s fm,@@(r0,rn) */
  { 0xf008, LOAD | SETSF1 | USES2 },		/* fmov.s @@rm,fn */
  { 0xf009, LOAD | SETS2 | SETSF1 | USES2 },	/* fmov.s @@rm+,fn */
  { 0xf00a, STORE | USES1 | USESF2 },		/* fmov.s fm,@@rn */
  { 0xf00b, STORE | SETS1 | USES1 | USESF2 },	/* fmov.s fm,@@-rn */
  { 0xf00c, SETSF1 | USESF2 },			/* fmov fm,fn */
  { 0xf00e, SETSF1 | USESF1 | USESF2 | USESF0 }	/* fmac f0,fm,fn */
};

static const struct sh_opcode sh_opcodef1[] =
{
  { 0xf00d, SETSF1 | USESSP },	/* fsts fpul,fn */
  { 0xf01d, SETSSP | USESF1 },	/* flds fn,fpul */
  { 0xf02d, SETSF1 | USESSP },	/* float fpul,fn */
  { 0xf03d, SETSSP | USESF1 },	/* ftrc fn,fpul */
  { 0xf04d, SETSF1 | USESF1 },	/* fneg fn */
  { 0xf05d, SETSF1 | USESF1 },	/* fabs fn */
  { 0xf06d, SETSF1 | USESF1 },	/* fsqrt fn */
  { 0xf07d, SETSSP | USESF1 },	/* ftst/nan fn */
  { 0xf08d, SETSF1 },		/* fldi0 fn */
  { 0xf09d, SETSF1 }		/* fldi1 fn */
};

static const struct sh_minor_opcode sh_opcodef[] =
{
  { MAP (sh_opcodef0), 0xf00f },
  { MAP (sh_opcodef1), 0xf0ff }
};

static struct sh_major_opcode sh_opcodes[] =
{
  { MAP (sh_opcode0) },
  { MAP (sh_opcode1) },
  { MAP (sh_opcode2) },
  { MAP (sh_opcode3) },
  { MAP (sh_opcode4) },
  { MAP (sh_opcode5) },
  { MAP (sh_opcode6) },
  { MAP (sh_opcode7) },
  { MAP (sh_opcode8) },
  { MAP (sh_opcode9) },
  { MAP (sh_opcodea) },
  { MAP (sh_opcodeb) },
  { MAP (sh_opcodec) },
  { MAP (sh_opcoded) },
  { MAP (sh_opcodee) },
  { MAP (sh_opcodef) }
};

/* The double data transfer / parallel processing insns are not
   described here.  This will cause sh_align_load_span to leave them alone.  */

static const struct sh_opcode sh_dsp_opcodef0[] =
{
  { 0xf400, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@-as,ds */
  { 0xf401, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@-as */
  { 0xf404, USESAS | LOAD | SETSSP },		/* movs.x @@as,ds */
  { 0xf405, USESAS | STORE | USESSP },		/* movs.x ds,@@as */
  { 0xf408, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@as+,ds */
  { 0xf409, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@as+ */
  { 0xf40c, USESAS | SETSAS | LOAD | SETSSP | USESR8 },	/* movs.x @@as+r8,ds */
  { 0xf40d, USESAS | SETSAS | STORE | USESSP | USESR8 }	/* movs.x ds,@@as+r8 */
};

static const struct sh_minor_opcode sh_dsp_opcodef[] =
{
  { MAP (sh_dsp_opcodef0), 0xfc0d }
};

/* Given an instruction, return a pointer to the corresponding
   sh_opcode structure.  Return NULL if the instruction is not
   recognized.  */

static const struct sh_opcode *
sh_insn_info (unsigned int insn)
{
  const struct sh_major_opcode *maj;
  const struct sh_minor_opcode *min, *minend;

  maj = &sh_opcodes[(insn & 0xf000) >> 12];
  min = maj->minor_opcodes;
  minend = min + maj->count;
  for (; min < minend; min++)
    {
      unsigned int l;
      const struct sh_opcode *op, *opend;

      l = insn & min->mask;
      op = min->opcodes;
      opend = op + min->count;

      /* Since the opcodes tables are sorted, we could use a binary
         search here if the count were above some cutoff value.  */
      for (; op < opend; op++)
	if (op->opcode == l)
	  return op;
    }

  return NULL;
}

/* See whether an instruction uses a general purpose register.  */

static bfd_boolean
sh_insn_uses_reg (unsigned int insn,
		  const struct sh_opcode *op,
		  unsigned int reg)
{
  unsigned int f;

  f = op->flags;

  if ((f & USES1) != 0
      && USES1_REG (insn) == reg)
    return TRUE;
  if ((f & USES2) != 0
      && USES2_REG (insn) == reg)
    return TRUE;
  if ((f & USESR0) != 0
      && reg == 0)
    return TRUE;
  if ((f & USESAS) && reg == USESAS_REG (insn))
    return TRUE;
  if ((f & USESR8) && reg == 8)
    return TRUE;

  return FALSE;
}

/* See whether an instruction sets a general purpose register.  */

static bfd_boolean
sh_insn_sets_reg (unsigned int insn,
		  const struct sh_opcode *op,
		  unsigned int reg)
{
  unsigned int f;

  f = op->flags;

  if ((f & SETS1) != 0
      && SETS1_REG (insn) == reg)
    return TRUE;
  if ((f & SETS2) != 0
      && SETS2_REG (insn) == reg)
    return TRUE;
  if ((f & SETSR0) != 0
      && reg == 0)
    return TRUE;
  if ((f & SETSAS) && reg == SETSAS_REG (insn))
    return TRUE;

  return FALSE;
}

/* See whether an instruction uses or sets a general purpose register */

static bfd_boolean
sh_insn_uses_or_sets_reg (unsigned int insn,
			  const struct sh_opcode *op,
			  unsigned int reg)
{
  if (sh_insn_uses_reg (insn, op, reg))
    return TRUE;

  return sh_insn_sets_reg (insn, op, reg);
}

/* See whether an instruction uses a floating point register.  */

static bfd_boolean
sh_insn_uses_freg (unsigned int insn,
		   const struct sh_opcode *op,
		   unsigned int freg)
{
  unsigned int f;

  f = op->flags;

  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */

  if ((f & USESF1) != 0
      && (USESF1_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;
  if ((f & USESF2) != 0
      && (USESF2_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;
  if ((f & USESF0) != 0
      && freg == 0)
    return TRUE;

  return FALSE;
}

/* See whether an instruction sets a floating point register.  */

static bfd_boolean
sh_insn_sets_freg (unsigned int insn,
		   const struct sh_opcode *op,
		   unsigned int freg)
{
  unsigned int f;

  f = op->flags;

  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */

  if ((f & SETSF1) != 0
      && (SETSF1_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;

  return FALSE;
}

/* See whether an instruction uses or sets a floating point register */

static bfd_boolean
sh_insn_uses_or_sets_freg (unsigned int insn,
			   const struct sh_opcode *op,
			   unsigned int reg)
{
  if (sh_insn_uses_freg (insn, op, reg))
    return TRUE;

  return sh_insn_sets_freg (insn, op, reg);
}

/* See whether instructions I1 and I2 conflict, assuming I1 comes
   before I2.  OP1 and OP2 are the corresponding sh_opcode structures.
   This should return TRUE if there is a conflict, or FALSE if the
   instructions can be swapped safely.  */

static bfd_boolean
sh_insns_conflict (unsigned int i1,
		   const struct sh_opcode *op1,
		   unsigned int i2,
		   const struct sh_opcode *op2)
{
  unsigned int f1, f2;

  f1 = op1->flags;
  f2 = op2->flags;

  /* Load of fpscr conflicts with floating point operations.
     FIXME: shouldn't test raw opcodes here.  */
  if (((i1 & 0xf0ff) == 0x4066 && (i2 & 0xf000) == 0xf000)
      || ((i2 & 0xf0ff) == 0x4066 && (i1 & 0xf000) == 0xf000))
    return TRUE;

  if ((f1 & (BRANCH | DELAY)) != 0
      || (f2 & (BRANCH | DELAY)) != 0)
    return TRUE;

  if (((f1 | f2) & SETSSP)
      && (f1 & (SETSSP | USESSP))
      && (f2 & (SETSSP | USESSP)))
    return TRUE;

  if ((f1 & SETS1) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, SETS1_REG (i1)))
    return TRUE;
  if ((f1 & SETS2) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, SETS2_REG (i1)))
    return TRUE;
  if ((f1 & SETSR0) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, 0))
    return TRUE;
  if ((f1 & SETSAS)
      && sh_insn_uses_or_sets_reg (i2, op2, SETSAS_REG (i1)))
    return TRUE;
  if ((f1 & SETSF1) != 0
      && sh_insn_uses_or_sets_freg (i2, op2, SETSF1_REG (i1)))
    return TRUE;

  if ((f2 & SETS1) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, SETS1_REG (i2)))
    return TRUE;
  if ((f2 & SETS2) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, SETS2_REG (i2)))
    return TRUE;
  if ((f2 & SETSR0) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, 0))
    return TRUE;
  if ((f2 & SETSAS)
      && sh_insn_uses_or_sets_reg (i1, op1, SETSAS_REG (i2)))
    return TRUE;
  if ((f2 & SETSF1) != 0
      && sh_insn_uses_or_sets_freg (i1, op1, SETSF1_REG (i2)))
    return TRUE;

  /* The instructions do not conflict.  */
  return FALSE;
}

/* I1 is a load instruction, and I2 is some other instruction.  Return
   TRUE if I1 loads a register which I2 uses.  */

static bfd_boolean
sh_load_use (unsigned int i1,
	     const struct sh_opcode *op1,
	     unsigned int i2,
	     const struct sh_opcode *op2)
{
  unsigned int f1;

  f1 = op1->flags;

  if ((f1 & LOAD) == 0)
    return FALSE;

  /* If both SETS1 and SETSSP are set, that means a load to a special
     register using postincrement addressing mode, which we don't care
     about here.  */
  if ((f1 & SETS1) != 0
      && (f1 & SETSSP) == 0
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
    return TRUE;

  if ((f1 & SETSR0) != 0
      && sh_insn_uses_reg (i2, op2, 0))
    return TRUE;

  if ((f1 & SETSF1) != 0
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
    return TRUE;

  return FALSE;
}

/* Try to align loads and stores within a span of memory.  This is
   called by both the ELF and the COFF sh targets.  ABFD and SEC are
   the BFD and section we are examining.  CONTENTS is the contents of
   the section.  SWAP is the routine to call to swap two instructions.
   RELOCS is a pointer to the internal relocation information, to be
   passed to SWAP.  PLABEL is a pointer to the current label in a
   sorted list of labels; LABEL_END is the end of the list.  START and
   STOP are the range of memory to examine.  If a swap is made,
   *PSWAPPED is set to TRUE.  */

#ifdef COFF_WITH_PE
static
#endif
bfd_boolean
_bfd_sh_align_load_span (bfd *abfd,
			 asection *sec,
			 bfd_byte *contents,
			 bfd_boolean (*swap) (bfd *, asection *, void *, bfd_byte *, bfd_vma),
			 void * relocs,
			 bfd_vma **plabel,
			 bfd_vma *label_end,
			 bfd_vma start,
			 bfd_vma stop,
			 bfd_boolean *pswapped)
{
  int dsp = (abfd->arch_info->mach == bfd_mach_sh_dsp
	     || abfd->arch_info->mach == bfd_mach_sh3_dsp);
  bfd_vma i;

  /* The SH4 has a Harvard architecture, hence aligning loads is not
     desirable.  In fact, it is counter-productive, since it interferes
     with the schedules generated by the compiler.  */
  if (abfd->arch_info->mach == bfd_mach_sh4)
    return TRUE;

  /* If we are linking sh[3]-dsp code, swap the FPU instructions for DSP
     instructions.  */
  if (dsp)
    {
      sh_opcodes[0xf].minor_opcodes = sh_dsp_opcodef;
      sh_opcodes[0xf].count = sizeof sh_dsp_opcodef / sizeof sh_dsp_opcodef;
    }

  /* Instructions should be aligned on 2 byte boundaries.  */
  if ((start & 1) == 1)
    ++start;

  /* Now look through the unaligned addresses.  */
  i = start;
  if ((i & 2) == 0)
    i += 2;
  for (; i < stop; i += 4)
    {
      unsigned int insn;
      const struct sh_opcode *op;
      unsigned int prev_insn = 0;
      const struct sh_opcode *prev_op = NULL;

      insn = bfd_get_16 (abfd, contents + i);
      op = sh_insn_info (insn);
      if (op == NULL
	  || (op->flags & (LOAD | STORE)) == 0)
	continue;

      /* This is a load or store which is not on a four byte boundary.  */

      while (*plabel < label_end && **plabel < i)
	++*plabel;

      if (i > start)
	{
	  prev_insn = bfd_get_16 (abfd, contents + i - 2);
	  /* If INSN is the field b of a parallel processing insn, it is not
	     a load / store after all.  Note that the test here might mistake
	     the field_b of a pcopy insn for the starting code of a parallel
	     processing insn; this might miss a swapping opportunity, but at
	     least we're on the safe side.  */
	  if (dsp && (prev_insn & 0xfc00) == 0xf800)
	    continue;

	  /* Check if prev_insn is actually the field b of a parallel
	     processing insn.  Again, this can give a spurious match
	     after a pcopy.  */
	  if (dsp && i - 2 > start)
	    {
	      unsigned pprev_insn = bfd_get_16 (abfd, contents + i - 4);

	      if ((pprev_insn & 0xfc00) == 0xf800)
		prev_op = NULL;
	      else
		prev_op = sh_insn_info (prev_insn);
	    }
	  else
	    prev_op = sh_insn_info (prev_insn);

	  /* If the load/store instruction is in a delay slot, we
	     can't swap.  */
	  if (prev_op == NULL
	      || (prev_op->flags & DELAY) != 0)
	    continue;
	}
      if (i > start
	  && (*plabel >= label_end || **plabel != i)
	  && prev_op != NULL
	  && (prev_op->flags & (LOAD | STORE)) == 0
	  && ! sh_insns_conflict (prev_insn, prev_op, insn, op))
	{
	  bfd_boolean ok;

	  /* The load/store instruction does not have a label, and
	     there is a previous instruction; PREV_INSN is not
	     itself a load/store instruction, and PREV_INSN and
	     INSN do not conflict.  */

	  ok = TRUE;

	  if (i >= start + 4)
	    {
	      unsigned int prev2_insn;
	      const struct sh_opcode *prev2_op;

	      prev2_insn = bfd_get_16 (abfd, contents + i - 4);
	      prev2_op = sh_insn_info (prev2_insn);

	      /* If the instruction before PREV_INSN has a delay
		 slot--that is, PREV_INSN is in a delay slot--we
		 can not swap.  */
	      if (prev2_op == NULL
		  || (prev2_op->flags & DELAY) != 0)
		ok = FALSE;

	      /* If the instruction before PREV_INSN is a load,
		 and it sets a register which INSN uses, then
		 putting INSN immediately after PREV_INSN will
		 cause a pipeline bubble, so there is no point to
		 making the swap.  */
	      if (ok
		  && (prev2_op->flags & LOAD) != 0
		  && sh_load_use (prev2_insn, prev2_op, insn, op))
		ok = FALSE;
	    }

	  if (ok)
	    {
	      if (! (*swap) (abfd, sec, relocs, contents, i - 2))
		return FALSE;
	      *pswapped = TRUE;
	      continue;
	    }
	}

      while (*plabel < label_end && **plabel < i + 2)
	++*plabel;

      if (i + 2 < stop
	  && (*plabel >= label_end || **plabel != i + 2))
	{
	  unsigned int next_insn;
	  const struct sh_opcode *next_op;

	  /* There is an instruction after the load/store
	     instruction, and it does not have a label.  */
	  next_insn = bfd_get_16 (abfd, contents + i + 2);
	  next_op = sh_insn_info (next_insn);
	  if (next_op != NULL
	      && (next_op->flags & (LOAD | STORE)) == 0
	      && ! sh_insns_conflict (insn, op, next_insn, next_op))
	    {
	      bfd_boolean ok;

	      /* NEXT_INSN is not itself a load/store instruction,
		 and it does not conflict with INSN.  */

	      ok = TRUE;

	      /* If PREV_INSN is a load, and it sets a register
		 which NEXT_INSN uses, then putting NEXT_INSN
		 immediately after PREV_INSN will cause a pipeline
		 bubble, so there is no reason to make this swap.  */
	      if (prev_op != NULL
		  && (prev_op->flags & LOAD) != 0
		  && sh_load_use (prev_insn, prev_op, next_insn, next_op))
		ok = FALSE;

	      /* If INSN is a load, and it sets a register which
		 the insn after NEXT_INSN uses, then doing the
		 swap will cause a pipeline bubble, so there is no
		 reason to make the swap.  However, if the insn
		 after NEXT_INSN is itself a load or store
		 instruction, then it is misaligned, so
		 optimistically hope that it will be swapped
		 itself, and just live with the pipeline bubble if
		 it isn't.  */
	      if (ok
		  && i + 4 < stop
		  && (op->flags & LOAD) != 0)
		{
		  unsigned int next2_insn;
		  const struct sh_opcode *next2_op;

		  next2_insn = bfd_get_16 (abfd, contents + i + 4);
		  next2_op = sh_insn_info (next2_insn);
		  if (next2_op == NULL
		      || ((next2_op->flags & (LOAD | STORE)) == 0
			  && sh_load_use (insn, op, next2_insn, next2_op)))
		    ok = FALSE;
		}

	      if (ok)
		{
		  if (! (*swap) (abfd, sec, relocs, contents, i))
		    return FALSE;
		  *pswapped = TRUE;
		  continue;
		}
	    }
	}
    }

  return TRUE;
}
#endif /* not COFF_IMAGE_WITH_PE */

/* Swap two SH instructions.  */

static bfd_boolean
sh_swap_insns (bfd *      abfd,
	       asection * sec,
	       void *     relocs,
	       bfd_byte * contents,
	       bfd_vma    addr)
{
  struct internal_reloc *internal_relocs = (struct internal_reloc *) relocs;
  unsigned short i1, i2;
  struct internal_reloc *irel, *irelend;

  /* Swap the instructions themselves.  */
  i1 = bfd_get_16 (abfd, contents + addr);
  i2 = bfd_get_16 (abfd, contents + addr + 2);
  bfd_put_16 (abfd, (bfd_vma) i2, contents + addr);
  bfd_put_16 (abfd, (bfd_vma) i1, contents + addr + 2);

  /* Adjust all reloc addresses.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      int type, add;

      /* There are a few special types of relocs that we don't want to
         adjust.  These relocs do not apply to the instruction itself,
         but are only associated with the address.  */
      type = irel->r_type;
      if (type == R_SH_ALIGN
	  || type == R_SH_CODE
	  || type == R_SH_DATA
	  || type == R_SH_LABEL)
	continue;

      /* If an R_SH_USES reloc points to one of the addresses being
         swapped, we must adjust it.  It would be incorrect to do this
         for a jump, though, since we want to execute both
         instructions after the jump.  (We have avoided swapping
         around a label, so the jump will not wind up executing an
         instruction it shouldn't).  */
      if (type == R_SH_USES)
	{
	  bfd_vma off;

	  off = irel->r_vaddr - sec->vma + 4 + irel->r_offset;
	  if (off == addr)
	    irel->r_offset += 2;
	  else if (off == addr + 2)
	    irel->r_offset -= 2;
	}

      if (irel->r_vaddr - sec->vma == addr)
	{
	  irel->r_vaddr += 2;
	  add = -2;
	}
      else if (irel->r_vaddr - sec->vma == addr + 2)
	{
	  irel->r_vaddr -= 2;
	  add = 2;
	}
      else
	add = 0;

      if (add != 0)
	{
	  bfd_byte *loc;
	  unsigned short insn, oinsn;
	  bfd_boolean overflow;

	  loc = contents + irel->r_vaddr - sec->vma;
	  overflow = FALSE;
	  switch (type)
	    {
	    default:
	      break;

	    case R_SH_PCDISP8BY2:
	    case R_SH_PCRELIMM8BY2:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_PCDISP:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_PCRELIMM8BY4:
	      /* This reloc ignores the least significant 3 bits of
                 the program counter before adding in the offset.
                 This means that if ADDR is at an even address, the
                 swap will not affect the offset.  If ADDR is an at an
                 odd address, then the instruction will be crossing a
                 four byte boundary, and must be adjusted.  */
	      if ((addr & 3) != 0)
		{
		  insn = bfd_get_16 (abfd, loc);
		  oinsn = insn;
		  insn += add / 2;
		  if ((oinsn & 0xff00) != (insn & 0xff00))
		    overflow = TRUE;
		  bfd_put_16 (abfd, (bfd_vma) insn, loc);
		}

	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       ("%B: 0x%lx: fatal: reloc overflow while relaxing",
		abfd, (unsigned long) irel->r_vaddr));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Look for loads and stores which we can align to four byte
   boundaries.  See the longer comment above sh_relax_section for why
   this is desirable.  This sets *PSWAPPED if some instruction was
   swapped.  */

static bfd_boolean
sh_align_loads (bfd *abfd,
		asection *sec,
		struct internal_reloc *internal_relocs,
		bfd_byte *contents,
		bfd_boolean *pswapped)
{
  struct internal_reloc *irel, *irelend;
  bfd_vma *labels = NULL;
  bfd_vma *label, *label_end;
  bfd_size_type amt;

  *pswapped = FALSE;

  irelend = internal_relocs + sec->reloc_count;

  /* Get all the addresses with labels on them.  */
  amt = (bfd_size_type) sec->reloc_count * sizeof (bfd_vma);
  labels = (bfd_vma *) bfd_malloc (amt);
  if (labels == NULL)
    goto error_return;
  label_end = labels;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_LABEL)
	{
	  *label_end = irel->r_vaddr - sec->vma;
	  ++label_end;
	}
    }

  /* Note that the assembler currently always outputs relocs in
     address order.  If that ever changes, this code will need to sort
     the label values and the relocs.  */

  label = labels;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma start, stop;

      if (irel->r_type != R_SH_CODE)
	continue;

      start = irel->r_vaddr - sec->vma;

      for (irel++; irel < irelend; irel++)
	if (irel->r_type == R_SH_DATA)
	  break;
      if (irel < irelend)
	stop = irel->r_vaddr - sec->vma;
      else
	stop = sec->size;

      if (! _bfd_sh_align_load_span (abfd, sec, contents, sh_swap_insns,
				     internal_relocs, &label,
				     label_end, start, stop, pswapped))
	goto error_return;
    }

  free (labels);

  return TRUE;

 error_return:
  if (labels != NULL)
    free (labels);
  return FALSE;
}

/* This is a modification of _bfd_coff_generic_relocate_section, which
   will handle SH relaxing.  */

static bfd_boolean
sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
		     struct bfd_link_info *info,
		     bfd *input_bfd,
		     asection *input_section,
		     bfd_byte *contents,
		     struct internal_reloc *relocs,
		     struct internal_syment *syms,
		     asection **sections)
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      reloc_howto_type *howto;
      bfd_reloc_status_type rstat;

      /* Almost all relocs have to do with relaxing.  If any work must
         be done for them, it has been done in sh_relax_section.  */
      if (rel->r_type != R_SH_IMM32
#ifdef COFF_WITH_PE
	  && rel->r_type != R_SH_IMM32CE
	  && rel->r_type != R_SH_IMAGEBASE
#endif
	  && rel->r_type != R_SH_PCDISP)
	continue;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  if (symndx < 0
	      || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
	    {
	      (*_bfd_error_handler)
		("%B: illegal symbol index %ld in relocs",
		 input_bfd, symndx);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;

      if (rel->r_type == R_SH_PCDISP)
	addend -= 4;

      if (rel->r_type >= SH_COFF_HOWTO_COUNT)
	howto = NULL;
      else
	howto = &sh_coff_howtos[rel->r_type];

      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

#ifdef COFF_WITH_PE
      if (rel->r_type == R_SH_IMAGEBASE)
	addend -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
#endif

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  /* There is nothing to do for an internal PCDISP reloc.  */
	  if (rel->r_type == R_SH_PCDISP)
	    continue;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
	    }
	}
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if (! info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = NULL;
	    else if (sym->_n._n_n._n_zeroes == 0
		     && sym->_n._n_n._n_offset != 0)
	      name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	    else
	      {
 		strncpy (buf, sym->_n._n_name, SYMNMLEN);
		buf[SYMNMLEN] = '\0';
		name = buf;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd, input_section,
		    rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses sh_relocate_section.  */

static bfd_byte *
sh_coff_get_relocated_section_contents (bfd *output_bfd,
					struct bfd_link_info *link_info,
					struct bfd_link_order *link_order,
					bfd_byte *data,
					bfd_boolean relocatable,
					asymbol **symbols)
{
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  struct internal_reloc *internal_relocs = NULL;
  struct internal_syment *internal_syms = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || coff_section_data (input_bfd, input_section) == NULL
      || coff_section_data (input_bfd, input_section)->contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  memcpy (data, coff_section_data (input_bfd, input_section)->contents,
	  (size_t) input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      bfd_size_type symesz = bfd_coff_symesz (input_bfd);
      bfd_byte *esym, *esymend;
      struct internal_syment *isymp;
      asection **secpp;
      bfd_size_type amt;

      if (! _bfd_coff_get_external_symbols (input_bfd))
	goto error_return;

      internal_relocs = (_bfd_coff_read_internal_relocs
			 (input_bfd, input_section, FALSE, (bfd_byte *) NULL,
			  FALSE, (struct internal_reloc *) NULL));
      if (internal_relocs == NULL)
	goto error_return;

      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (struct internal_syment);
      internal_syms = (struct internal_syment *) bfd_malloc (amt);
      if (internal_syms == NULL)
	goto error_return;

      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL)
	goto error_return;

      isymp = internal_syms;
      secpp = sections;
      esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
      esymend = esym + obj_raw_syment_count (input_bfd) * symesz;
      while (esym < esymend)
	{
	  bfd_coff_swap_sym_in (input_bfd, esym, isymp);

	  if (isymp->n_scnum != 0)
	    *secpp = coff_section_from_bfd_index (input_bfd, isymp->n_scnum);
	  else
	    {
	      if (isymp->n_value == 0)
		*secpp = bfd_und_section_ptr;
	      else
		*secpp = bfd_com_section_ptr;
	    }

	  esym += (isymp->n_numaux + 1) * symesz;
	  secpp += isymp->n_numaux + 1;
	  isymp += isymp->n_numaux + 1;
	}

      if (! sh_relocate_section (output_bfd, link_info, input_bfd,
				 input_section, data, internal_relocs,
				 internal_syms, sections))
	goto error_return;

      free (sections);
      sections = NULL;
      free (internal_syms);
      internal_syms = NULL;
      free (internal_relocs);
      internal_relocs = NULL;
    }

  return data;

 error_return:
  if (internal_relocs != NULL)
    free (internal_relocs);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
  return NULL;
}

/* The target vectors.  */

#ifndef TARGET_SHL_SYM
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
#endif

#ifdef TARGET_SHL_SYM
#define TARGET_SYM TARGET_SHL_SYM
#else
#define TARGET_SYM shlcoff_vec
#endif

#ifndef TARGET_SHL_NAME
#define TARGET_SHL_NAME "coff-shl"
#endif

#ifdef COFF_WITH_PE
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       SEC_CODE | SEC_DATA, '_', NULL, COFF_SWAP_TABLE);
#else
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       0, '_', NULL, COFF_SWAP_TABLE)
#endif

#ifndef TARGET_SHL_SYM

/* Some people want versions of the SH COFF target which do not align
   to 16 byte boundaries.  We implement that by adding a couple of new
   target vectors.  These are just like the ones above, but they
   change the default section alignment.  To generate them in the
   assembler, use -small.  To use them in the linker, use -b
   coff-sh{l}-small and -oformat coff-sh{l}-small.

   Yes, this is a horrible hack.  A general solution for setting
   section alignment in COFF is rather complex.  ELF handles this
   correctly.  */

/* Only recognize the small versions if the target was not defaulted.
   Otherwise we won't recognize the non default endianness.  */

static const bfd_target *
coff_small_object_p (bfd *abfd)
{
  if (abfd->target_defaulted)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  return coff_object_p (abfd);
}

/* Set the section alignment for the small versions.  */

static bfd_boolean
coff_small_new_section_hook (bfd *abfd, asection *section)
{
  if (! coff_new_section_hook (abfd, section))
    return FALSE;

  /* We must align to at least a four byte boundary, because longword
     accesses must be on a four byte boundary.  */
  if (section->alignment_power == COFF_DEFAULT_SECTION_ALIGNMENT_POWER)
    section->alignment_power = 2;

  return TRUE;
}

/* This is copied from bfd_coff_std_swap_table so that we can change
   the default section alignment power.  */

static bfd_coff_backend_data bfd_coff_small_swap_table =
{
  coff_swap_aux_in, coff_swap_sym_in, coff_swap_lineno_in,
  coff_swap_aux_out, coff_swap_sym_out,
  coff_swap_lineno_out, coff_swap_reloc_out,
  coff_swap_filehdr_out, coff_swap_aouthdr_out,
  coff_swap_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_LONG_SECTION_NAMES,
  2,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_swap_filehdr_in, coff_swap_aouthdr_in, coff_swap_scnhdr_in,
  coff_swap_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript,
  bfd_pe_print_pdata
};

#define coff_small_close_and_cleanup \
  coff_close_and_cleanup
#define coff_small_bfd_free_cached_info \
  coff_bfd_free_cached_info
#define coff_small_get_section_contents \
  coff_get_section_contents
#define coff_small_get_section_contents_in_window \
  coff_get_section_contents_in_window

extern const bfd_target shlcoff_small_vec;

const bfd_target shcoff_small_vec =
{
  "coff-sh-small",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff_small),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & shlcoff_small_vec,

  & bfd_coff_small_swap_table
};

const bfd_target shlcoff_small_vec =
{
  "coff-shl-small",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little endian too*/

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff_small),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & shcoff_small_vec,

  & bfd_coff_small_swap_table
};
#endif
@


1.43
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d41 3
a43 3
  PARAMS ((bfd *, asection *, bfd_byte *,
	   bfd_boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *));
a58 22
static bfd_reloc_status_type sh_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static long get_symbol_value PARAMS ((asymbol *));
static bfd_boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
#ifndef COFF_IMAGE_WITH_PE
static const struct sh_opcode *sh_insn_info PARAMS ((unsigned int));
#endif
static bfd_boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *,
	   bfd_boolean *));
static bfd_boolean sh_swap_insns
  PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
static bfd_boolean sh_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_byte *sh_coff_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
static reloc_howto_type * sh_coff_reloc_type_lookup PARAMS ((bfd *, bfd_reloc_code_real_type));
a76 1
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
d79 4
a82 3
static bfd_boolean in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
d88 10
d398 1
a398 2
get_symbol_value (symbol)
     asymbol *symbol;
d416 1
a416 1
static reloc_howto_type * coff_sh_rtype_to_howto PARAMS ((bfd *, asection *, struct internal_reloc *, struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));
d419 6
a424 7
coff_sh_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * sec;
     struct internal_reloc * rel;
     struct coff_link_hash_entry * h;
     struct internal_syment * sym;
     bfd_vma * addendp;
d497 2
a498 3
sh_coff_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d563 7
a569 9
sh_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d659 3
d706 4
a709 5
sh_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d726 1
a726 1
      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d1062 4
a1065 5
sh_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
d1457 1
a1457 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &isym);
d1465 1
a1465 1
	  bfd_coff_swap_sym_out (abfd, (PTR) &isym, (PTR) esym);
a1614 18
static bfd_boolean sh_insn_uses_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_or_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_or_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insns_conflict
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));
static bfd_boolean sh_load_use
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));
d2023 1
a2023 2
sh_insn_info (insn)
     unsigned int insn;
a2049 14
/* See whether an instruction uses or sets a general purpose register */

static bfd_boolean
sh_insn_uses_or_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  if (sh_insn_uses_reg (insn, op, reg))
    return TRUE;

  return sh_insn_sets_reg (insn, op, reg);
}

d2053 3
a2055 4
sh_insn_uses_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
d2081 3
a2083 4
sh_insn_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
d2104 1
a2104 1
/* See whether an instruction uses or sets a floating point register */
d2107 3
a2109 4
sh_insn_uses_or_sets_freg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
d2111 1
a2111 1
  if (sh_insn_uses_freg (insn, op, reg))
d2114 1
a2114 1
  return sh_insn_sets_freg (insn, op, reg);
d2120 3
a2122 4
sh_insn_uses_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
d2153 3
a2155 4
sh_insn_sets_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
d2177 13
d2196 4
a2199 5
sh_insns_conflict (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
d2261 4
a2264 5
sh_load_use (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
d2306 10
a2315 12
_bfd_sh_align_load_span (abfd, sec, contents, swap, relocs,
			 plabel, label_end, start, stop, pswapped)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     bfd_boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
     PTR relocs;
     bfd_vma **plabel;
     bfd_vma *label_end;
     bfd_vma start;
     bfd_vma stop;
     bfd_boolean *pswapped;
a2514 76
/* Look for loads and stores which we can align to four byte
   boundaries.  See the longer comment above sh_relax_section for why
   this is desirable.  This sets *PSWAPPED if some instruction was
   swapped.  */

static bfd_boolean
sh_align_loads (abfd, sec, internal_relocs, contents, pswapped)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *internal_relocs;
     bfd_byte *contents;
     bfd_boolean *pswapped;
{
  struct internal_reloc *irel, *irelend;
  bfd_vma *labels = NULL;
  bfd_vma *label, *label_end;
  bfd_size_type amt;

  *pswapped = FALSE;

  irelend = internal_relocs + sec->reloc_count;

  /* Get all the addresses with labels on them.  */
  amt = (bfd_size_type) sec->reloc_count * sizeof (bfd_vma);
  labels = (bfd_vma *) bfd_malloc (amt);
  if (labels == NULL)
    goto error_return;
  label_end = labels;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_LABEL)
	{
	  *label_end = irel->r_vaddr - sec->vma;
	  ++label_end;
	}
    }

  /* Note that the assembler currently always outputs relocs in
     address order.  If that ever changes, this code will need to sort
     the label values and the relocs.  */

  label = labels;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma start, stop;

      if (irel->r_type != R_SH_CODE)
	continue;

      start = irel->r_vaddr - sec->vma;

      for (irel++; irel < irelend; irel++)
	if (irel->r_type == R_SH_DATA)
	  break;
      if (irel < irelend)
	stop = irel->r_vaddr - sec->vma;
      else
	stop = sec->size;

      if (! _bfd_sh_align_load_span (abfd, sec, contents, sh_swap_insns,
				     (PTR) internal_relocs, &label,
				     label_end, start, stop, pswapped))
	goto error_return;
    }

  free (labels);

  return TRUE;

 error_return:
  if (labels != NULL)
    free (labels);
  return FALSE;
}

d2518 5
a2522 6
sh_swap_insns (abfd, sec, relocs, contents, addr)
     bfd *abfd;
     asection *sec;
     PTR relocs;
     bfd_byte *contents;
     bfd_vma addr;
d2645 75
d2725 8
a2732 10
sh_relocate_section (output_bfd, info, input_bfd, input_section, contents,
		     relocs, syms, sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
d2896 6
a2901 8
sh_coff_get_relocated_section_contents (output_bfd, link_info, link_order,
					data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
d2958 1
a2958 1
	  bfd_coff_swap_sym_in (input_bfd, (PTR) esym, (PTR) isymp);
d3025 1
a3025 2
static const bfd_target * coff_small_object_p PARAMS ((bfd *));
static bfd_boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
d3041 1
a3041 2
coff_small_object_p (abfd)
     bfd *abfd;
d3054 1
a3054 3
coff_small_new_section_hook (abfd, section)
     bfd *abfd;
     asection *section;
d3160 1
a3160 1
  (PTR) &bfd_coff_small_swap_table
d3205 1
a3205 1
  (PTR) &bfd_coff_small_swap_table
@


1.42
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d3188 1
d3233 1
@


1.41
log
@update copyright dates
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
d521 1
a521 1
  fprintf (stderr, "SH Error: unknown reloc type %d\n", code);
@


1.41.10.1
log
@backport from mainline
@
text
@d3 1
a3 2
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
   Free Software Foundation, Inc.
d520 1
a520 1
  (*_bfd_error_handler) (_("SH Error: unknown reloc type %d"), code);
@


1.40
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008, 2009  Free Software Foundation, Inc.
@


1.39
log
@        * coff-sh.c (bfd_pe_print_pdata): Define to NULL for non
        COFF_WITH_PE based SH ports.
        * libpei.h (_bfd_XX_print_ce_compressed_pdata): Prototype.
        * arm-wince-pe.c (bfd_pe_print_pdata): Use
        _bfd_pe_print_ce_compressed_pdata.
        (slurp_symcache, cleanup_syms, pe_print_ce_compressed_pdata): Move
        to...
        * peXXigen.c: ... here and rename pe_print_ce_compressed_pdata to
        _bfd_XX_print_ce_compressed_pdata.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008  Free Software Foundation, Inc.
d3124 1
a3124 1
static const bfd_coff_backend_data bfd_coff_small_swap_table =
d3137 1
a3137 5
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
@


1.38
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d33 2
a45 1
#endif
d47 7
a53 3
#undef  bfd_pe_print_pdata
#define	bfd_pe_print_pdata   pe_print_ce_compressed_pdata
extern bfd_boolean pe_print_ce_compressed_pdata (bfd *, void *);
@


1.37
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d46 4
d3156 2
a3157 1
  coff_link_output_has_begun, coff_final_link_postscript
@


1.36
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d22 2
a23 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.35
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d24 1
a25 1
#include "sysdep.h"
@


1.34
log
@* coff-sh.c (_bfd_sh_align_load_span): Catch sh_insn_info() returning a NULL
  value.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d497 1
d514 14
@


1.33
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2513 3
a2515 2
		  if ((next2_op->flags & (LOAD | STORE)) == 0
		      && sh_load_use (insn, op, next2_insn, next2_op))
@


1.32
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.31
log
@update copyright dates
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.30
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
@


1.29
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a1658 20
/* These sixteen instructions can be handled with one table entry below.  */
#if 0
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
  { 0x0032, SETS1 | USESSP },			/* stc ssr,rn */
  { 0x0042, SETS1 | USESSP },			/* stc spc,rn */
  { 0x0052, SETS1 | USESSP },			/* stc mod,rn */
  { 0x0062, SETS1 | USESSP },			/* stc rs,rn */
  { 0x0072, SETS1 | USESSP },			/* stc re,rn */
  { 0x0082, SETS1 | USESSP },			/* stc r0_bank,rn */
  { 0x0092, SETS1 | USESSP },			/* stc r1_bank,rn */
  { 0x00a2, SETS1 | USESSP },			/* stc r2_bank,rn */
  { 0x00b2, SETS1 | USESSP },			/* stc r3_bank,rn */
  { 0x00c2, SETS1 | USESSP },			/* stc r4_bank,rn */
  { 0x00d2, SETS1 | USESSP },			/* stc r5_bank,rn */
  { 0x00e2, SETS1 | USESSP },			/* stc r6_bank,rn */
  { 0x00f2, SETS1 | USESSP }			/* stc r7_bank,rn */
#endif

a1788 38
#if 0 /* These groups sixteen insns can be
         handled with one table entry each below.  */
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
  { 0x4033, STORE | SETS1 | USES1 | USESSP },	/* stc.l ssr,@@-rn */
  { 0x4043, STORE | SETS1 | USES1 | USESSP },	/* stc.l spc,@@-rn */
  { 0x4053, STORE | SETS1 | USES1 | USESSP },	/* stc.l mod,@@-rn */
  { 0x4063, STORE | SETS1 | USES1 | USESSP },	/* stc.l rs,@@-rn */
  { 0x4073, STORE | SETS1 | USES1 | USESSP },	/* stc.l re,@@-rn */
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l r0_bank,@@-rn */
  ..
  { 0x40f3, STORE | SETS1 | USES1 | USESSP },	/* stc.l r7_bank,@@-rn */

  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
  { 0x4037, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,ssr */
  { 0x4047, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,spc */
  { 0x4057, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,mod */
  { 0x4067, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rs */
  { 0x4077, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,re */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r0_bank */
  ..
  { 0x40f7, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r7_bank */

  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
  { 0x403e, SETSSP | USES1 },			/* ldc rm,ssr */
  { 0x404e, SETSSP | USES1 },			/* ldc rm,spc */
  { 0x405e, SETSSP | USES1 },			/* ldc rm,mod */
  { 0x406e, SETSSP | USES1 },			/* ldc rm,rs */
  { 0x407e, SETSSP | USES1 }			/* ldc rm,re */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,r0_bank */
  ..
  { 0x40fe, SETSSP | USES1 }			/* ldc rm,r7_bank */
#endif
@


1.28
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d2949 1
a2949 1
	      name = h->root.root.string;
d2961 3
a2963 2
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
@


1.27
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d765 2
a766 3
	  (*_bfd_error_handler) ("%s: 0x%lx: warning: bad R_SH_USES offset",
				 bfd_archive_filename (abfd),
				 (unsigned long) irel->r_vaddr);
d775 2
a776 2
	   ("%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x",
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr, insn));
d792 2
a793 2
	   ("%s: 0x%lx: warning: bad R_SH_USES load offset",
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d816 2
a817 2
	   ("%s: 0x%lx: warning: could not find expected reloc",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d832 2
a833 2
	   ("%s: 0x%lx: warning: symbol in unexpected section",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d957 2
a958 2
	   ("%s: 0x%lx: warning: could not find expected COUNT reloc",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d966 2
a967 3
	  ((*_bfd_error_handler) ("%s: 0x%lx: warning: bad count",
				  bfd_archive_filename (abfd),
				  (unsigned long) paddr));
d1338 2
a1339 2
	       ("%s: 0x%lx: fatal: reloc overflow while relaxing",
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d1433 1
a1433 2
       ("%s: fatal: generic symbols retrieved before relaxing",
	bfd_archive_filename (abfd)));
d2788 2
a2789 2
	       ("%s: 0x%lx: fatal: reloc overflow while relaxing",
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d2852 2
a2853 2
		("%s: illegal symbol index %ld in relocs",
		 bfd_archive_filename (input_bfd), symndx);
@


1.26
log
@	* coff-sh.c: Move definition of MAP and guard more code with
	COFF_IMAGE_WITH_PE.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a700 1
  struct internal_reloc *free_relocs = NULL;
a703 1
  bfd_byte *free_contents = NULL;
d712 7
a718 4
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;
a725 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
d747 1
a747 2
	  if (coff_section_data (abfd, sec) != NULL
	      && coff_section_data (abfd, sec)->contents != NULL)
d751 1
a751 7
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d763 1
a763 1
      if (laddr >= sec->_raw_size)
d790 1
a790 1
      if (paddr >= sec->_raw_size)
d807 1
a807 1
		|| irelfn->r_type == R_SH_IMAGEBASE))
d810 1
a810 1
	    && irelfn->r_type == R_SH_IMM32)
d812 1
a889 8
      if (coff_section_data (abfd, sec) == NULL)
	{
	  bfd_size_type amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	  if (sec->used_by_bfd == NULL)
	    goto error_return;
	}

a891 1
      free_relocs = NULL;
a894 1
      free_contents = NULL;
d997 1
a997 2
	  if (coff_section_data (abfd, sec) != NULL
	      && coff_section_data (abfd, sec)->contents != NULL)
d1001 1
a1001 7
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
a1010 8
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	    }

a1012 1
	  free_relocs = NULL;
a1015 1
	  free_contents = NULL;
d1021 2
a1022 1
  if (free_relocs != NULL)
d1024 4
a1027 2
      free (free_relocs);
      free_relocs = NULL;
d1030 1
a1030 1
  if (free_contents != NULL)
d1033 1
a1033 1
	free (free_contents);
d1035 2
a1036 12
	{
	  /* Cache the section contents for coff_link_input_bfd.  */
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	      coff_section_data (abfd, sec)->relocs = NULL;
	    }
	  coff_section_data (abfd, sec)->contents = contents;
	}
d1042 5
a1046 4
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
d1074 1
a1074 1
  toaddr = sec->_cooked_size;
d1094 1
a1094 1
    sec->_cooked_size -= count;
d1406 2
a1411 7
		      ocontents = (bfd_byte *) bfd_malloc (o->_raw_size);
		      if (ocontents == NULL)
			return FALSE;
		      if (! bfd_get_section_contents (abfd, o, ocontents,
						      (file_ptr) 0,
						      o->_raw_size))
			return FALSE;
d2652 1
a2652 1
	stop = sec->_cooked_size;
d3004 1
a3004 1
	  (size_t) input_section->_raw_size);
@


1.26.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
d701 1
d705 1
d714 4
a717 7
  if (coff_section_data (abfd, sec) == NULL)
    {
      bfd_size_type amt = sizeof (struct coff_section_tdata);
      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
      if (sec->used_by_bfd == NULL)
	return FALSE;
    }
d725 2
d748 2
a749 1
	  if (coff_section_data (abfd, sec)->contents != NULL)
d753 7
a759 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d771 1
a771 1
      if (laddr >= sec->size)
d773 3
a775 2
	  (*_bfd_error_handler) ("%B: 0x%lx: warning: bad R_SH_USES offset",
				 abfd, (unsigned long) irel->r_vaddr);
d784 2
a785 2
	   ("%B: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x",
	    abfd, (unsigned long) irel->r_vaddr, insn));
d798 1
a798 1
      if (paddr >= sec->size)
d801 2
a802 2
	   ("%B: 0x%lx: warning: bad R_SH_USES load offset",
	    abfd, (unsigned long) irel->r_vaddr));
d815 1
a815 1
		|| irelfn->r_type == R_SH_IMAGEBASE)
d818 1
a818 1
	    && irelfn->r_type == R_SH_IMM32
a819 1
	    )
d824 2
a825 2
	   ("%B: 0x%lx: warning: could not find expected reloc",
	    abfd, (unsigned long) paddr));
d840 2
a841 2
	   ("%B: 0x%lx: warning: symbol in unexpected section",
	    abfd, (unsigned long) paddr));
d897 8
d907 1
d911 1
d975 2
a976 2
	   ("%B: 0x%lx: warning: could not find expected COUNT reloc",
	    abfd, (unsigned long) paddr));
d984 3
a986 2
	  ((*_bfd_error_handler) ("%B: 0x%lx: warning: bad count",
				  abfd, (unsigned long) paddr));
d1014 2
a1015 1
	  if (coff_section_data (abfd, sec)->contents != NULL)
d1019 7
a1025 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d1035 8
d1045 1
d1049 1
d1055 1
a1055 2
  if (internal_relocs != NULL
      && internal_relocs != coff_section_data (abfd, sec)->relocs)
d1057 2
a1058 4
      if (! link_info->keep_memory)
	free (internal_relocs);
      else
	coff_section_data (abfd, sec)->relocs = internal_relocs;
d1061 1
a1061 1
  if (contents != NULL && contents != coff_section_data (abfd, sec)->contents)
d1064 1
a1064 1
	free (contents);
d1066 12
a1077 2
	/* Cache the section contents for coff_link_input_bfd.  */
	coff_section_data (abfd, sec)->contents = contents;
d1083 4
a1086 5
  if (internal_relocs != NULL
      && internal_relocs != coff_section_data (abfd, sec)->relocs)
    free (internal_relocs);
  if (contents != NULL && contents != coff_section_data (abfd, sec)->contents)
    free (contents);
d1114 1
a1114 1
  toaddr = sec->size;
d1134 1
a1134 1
    sec->size -= count;
d1380 2
a1381 2
	       ("%B: 0x%lx: fatal: reloc overflow while relaxing",
		abfd, (unsigned long) irel->r_vaddr));
a1445 2
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			return FALSE;
d1450 7
d1480 2
a1481 1
       ("%B: fatal: generic symbols retrieved before relaxing", abfd));
d2697 1
a2697 1
	stop = sec->size;
d2836 2
a2837 2
	       ("%B: 0x%lx: fatal: reloc overflow while relaxing",
		abfd, (unsigned long) irel->r_vaddr));
d2900 2
a2901 2
		("%B: illegal symbol index %ld in relocs",
		 input_bfd, symndx);
d3049 1
a3049 1
	  (size_t) input_section->size);
@


1.25
log
@Correct spelling of "relocatable".
@
text
@d1650 2
d1671 1
a1671 1
#endif
a1673 2
#define MAP(a) a, sizeof a / sizeof a[0]

a2091 1
#ifndef COFF_IMAGE_WITH_PE
a2110 1
#endif
a2131 1
#ifndef COFF_IMAGE_WITH_PE
@


1.24
log
@Altered the CREATE_xxx_COFF_TARGET_VEC macro arguments
@
text
@d709 1
a709 1
  if (link_info->relocateable
d2972 1
a2972 1
	  else if (! info->relocateable)
d3027 1
a3027 1
					data, relocateable, symbols)
d3032 1
a3032 1
     bfd_boolean relocateable;
d3043 1
a3043 1
  if (relocateable
d3048 1
a3048 1
						       relocateable,
@


1.23
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d3135 1
a3135 1
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL)
d3150 1
a3150 1
			       SEC_CODE | SEC_DATA, '_', NULL);
d3153 1
a3153 1
			       0, '_', NULL)
@


1.22
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1 2
a2 2
/* BFD back-end for Hitachi Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 4
a13 4
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d15 4
a18 4
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d20 3
a22 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.21
log
@2002-05-11  Ralf Corsepius  <corsepiu@@faw.uni-ulm.de>
            Daniel Jacobowitz  <drow@@mvista.com>

        * coff-sh.c (sh_reloc_map): Map to R_SH_IMM32 for non-PE.  Don't
        map BFD_RELOC_RVA.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d36 1
a36 1
static boolean sh_align_load_span
d38 2
a39 2
	   boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, boolean *));
d51 3
a53 3
static boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean sh_relax_delete_bytes
d58 4
a61 3
static boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *, boolean *));
static boolean sh_swap_insns
d63 1
a63 1
static boolean sh_relocate_section
d68 1
a68 1
	   bfd_byte *, boolean, asymbol **));
d88 2
a89 2
static boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return true if this relocation should
d91 1
a91 1
static boolean in_reloc_p (abfd, howto)
d111 1
a111 1
	 false,			/* pc_relative */
d116 1
a116 1
	 true,			/* partial_inplace */
d119 1
a119 1
	 false),		/* pcrel_offset */
d135 1
a135 1
	 true,			/* pc_relative */
d140 1
a140 1
	 true,			/* partial_inplace */
d143 1
a143 1
	 true),			/* pcrel_offset */
d151 1
a151 1
	 true,			/* pc_relative */
d156 1
a156 1
	 true,			/* partial_inplace */
d159 1
a159 1
	 true),			/* pcrel_offset */
d167 1
a167 1
	 false,			/* pc_relative */
d172 1
a172 1
	 true,			/* partial_inplace */
d175 1
a175 1
	 false),		/* pcrel_offset */
d183 1
a183 1
	 false,	                /* pc_relative */
d188 1
a188 1
	 true,	                /* partial_inplace */
d191 1
a191 1
	 false),                /* pcrel_offset */
d205 1
a205 1
	 true,			/* pc_relative */
d210 1
a210 1
	 true,			/* partial_inplace */
d213 1
a213 1
	 true),			/* pcrel_offset */
d219 1
a219 1
	 true,			/* pc_relative */
d224 1
a224 1
	 true,			/* partial_inplace */
d227 1
a227 1
	 true),			/* pcrel_offset */
d233 1
a233 1
	 false,			/* pc_relative */
d238 1
a238 1
	 true,			/* partial_inplace */
d241 1
a241 1
	 false),		/* pcrel_offset */
d247 1
a247 1
	 false,			/* pc_relative */
d252 1
a252 1
	 true,			/* partial_inplace */
d255 1
a255 1
	 false),		/* pcrel_offset */
d261 1
a261 1
	 false,			/* pc_relative */
d266 1
a266 1
	 true,			/* partial_inplace */
d269 1
a269 1
	 false),		/* pcrel_offset */
d275 1
a275 1
	 false,			/* pc_relative */
d280 1
a280 1
	 true,			/* partial_inplace */
d283 1
a283 1
	 false),		/* pcrel_offset */
d289 1
a289 1
	 false,			/* pc_relative */
d294 1
a294 1
	 true,			/* partial_inplace */
d297 1
a297 1
	 false),		/* pcrel_offset */
d303 1
a303 1
	 false,			/* pc_relative */
d308 1
a308 1
	 true,			/* partial_inplace */
d311 1
a311 1
	 false),		/* pcrel_offset */
d317 1
a317 1
	 false,			/* pc_relative */
d322 1
a322 1
	 true,			/* partial_inplace */
d325 1
a325 1
	 false),		/* pcrel_offset */
d331 1
a331 1
	 false,			/* pc_relative */
d336 1
a336 1
	 true,			/* partial_inplace */
d339 1
a339 1
	 false),		/* pcrel_offset */
d345 1
a345 1
	 false,			/* pc_relative */
d350 1
a350 1
	 true,			/* partial_inplace */
d353 1
a353 1
	 false),		/* pcrel_offset */
d359 1
a359 1
	 false,			/* pc_relative */
d364 1
a364 1
	 true,			/* partial_inplace */
d367 1
a367 1
	 false)			/* pcrel_offset */
d693 1
a693 1
static boolean
d698 1
a698 1
     boolean *again;
d702 1
a702 1
  boolean have_code;
d707 1
a707 1
  *again = false;
d712 1
a712 1
    return true;
d721 1
a721 1
		      (bfd_byte *) NULL, false,
d728 1
a728 1
  have_code = false;
d740 1
a740 1
	have_code = true;
d906 1
a906 1
      coff_section_data (abfd, sec)->keep_relocs = true;
d910 1
a910 1
      coff_section_data (abfd, sec)->keep_contents = true;
d913 1
a913 1
      obj_coff_keep_syms (abfd) = true;
d969 1
a969 1
      *again = true;
d1009 1
a1009 1
      boolean swapped;
d1044 1
a1044 1
	  coff_section_data (abfd, sec)->keep_relocs = true;
d1048 1
a1048 1
	  coff_section_data (abfd, sec)->keep_contents = true;
d1051 1
a1051 1
	  obj_coff_keep_syms (abfd) = true;
d1080 1
a1080 1
  return true;
d1087 1
a1087 1
  return false;
d1092 1
a1092 1
static boolean
d1155 1
a1155 1
      boolean overflow;
d1317 1
a1317 1
	  overflow = false;
d1328 1
a1328 1
		overflow = true;
d1335 1
a1335 1
		overflow = true;
d1349 1
a1349 1
		overflow = true;
d1356 1
a1356 1
		overflow = true;
d1363 1
a1363 1
		overflow = true;
d1383 1
a1383 1
	      return false;
d1405 1
a1405 1
         false, we should free them, if we are permitted to, when we
d1408 1
a1408 1
			 (abfd, o, true, (bfd_byte *) NULL, false,
d1411 1
a1411 1
	return false;
d1447 1
a1447 1
                         Perhaps, if info->keep_memory is false, we
d1452 1
a1452 1
			return false;
d1456 1
a1456 1
			return false;
d1467 1
a1467 1
	      coff_section_data (abfd, o)->keep_contents = true;
d1483 1
a1483 1
      return false;
d1536 1
a1536 1
  return true;
d1651 1
a1651 1
static boolean sh_insn_uses_reg
d1653 1
a1653 1
static boolean sh_insn_sets_reg
d1655 1
a1655 1
static boolean sh_insn_uses_or_sets_reg
d1657 1
a1657 1
static boolean sh_insn_uses_freg
d1659 1
a1659 1
static boolean sh_insn_sets_freg
d1661 1
a1661 1
static boolean sh_insn_uses_or_sets_freg
d1663 1
a1663 1
static boolean sh_insns_conflict
d1666 1
a1666 1
static boolean sh_load_use
d2170 1
a2170 1
static boolean
d2177 1
a2177 1
    return true;
d2184 1
a2184 1
static boolean
d2196 1
a2196 1
    return true;
d2199 1
a2199 1
    return true;
d2202 1
a2202 1
    return true;
d2204 1
a2204 1
    return true;
d2206 1
a2206 1
    return true;
d2208 1
a2208 1
  return false;
d2213 1
a2213 1
static boolean
d2225 1
a2225 1
    return true;
d2228 1
a2228 1
    return true;
d2231 1
a2231 1
    return true;
d2233 1
a2233 1
    return true;
d2235 1
a2235 1
  return false;
d2240 1
a2240 1
static boolean
d2247 1
a2247 1
    return true;
d2254 1
a2254 1
static boolean
d2275 1
a2275 1
    return true;
d2278 1
a2278 1
    return true;
d2281 1
a2281 1
    return true;
d2283 1
a2283 1
  return false;
d2288 1
a2288 1
static boolean
d2309 1
a2309 1
    return true;
d2311 1
a2311 1
  return false;
d2316 1
a2316 1
   This should return true if there is a conflict, or false if the
d2319 1
a2319 1
static boolean
d2335 1
a2335 1
    return true;
d2339 1
a2339 1
    return true;
d2344 1
a2344 1
    return true;
d2348 1
a2348 1
    return true;
d2351 1
a2351 1
    return true;
d2354 1
a2354 1
    return true;
d2357 1
a2357 1
    return true;
d2360 1
a2360 1
    return true;
d2364 1
a2364 1
    return true;
d2367 1
a2367 1
    return true;
d2370 1
a2370 1
    return true;
d2373 1
a2373 1
    return true;
d2376 1
a2376 1
    return true;
d2379 1
a2379 1
  return false;
d2383 1
a2383 1
   true if I1 loads a register which I2 uses.  */
d2385 1
a2385 1
static boolean
d2397 1
a2397 1
    return false;
d2405 1
a2405 1
    return true;
d2409 1
a2409 1
    return true;
d2413 1
a2413 1
    return true;
d2415 1
a2415 1
  return false;
d2426 1
a2426 1
   *PSWAPPED is set to true.  */
d2431 1
a2431 1
boolean
d2437 1
a2437 1
     boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d2443 1
a2443 1
     boolean *pswapped;
d2453 1
a2453 1
    return true;
d2527 1
a2527 1
	  boolean ok;
d2534 1
a2534 1
	  ok = true;
d2549 1
a2549 1
		ok = false;
d2559 1
a2559 1
		ok = false;
d2565 2
a2566 2
		return false;
	      *pswapped = true;
d2588 1
a2588 1
	      boolean ok;
d2593 1
a2593 1
	      ok = true;
d2602 1
a2602 1
		ok = false;
d2624 1
a2624 1
		    ok = false;
d2630 2
a2631 2
		    return false;
		  *pswapped = true;
d2638 1
a2638 1
  return true;
d2647 1
a2647 1
static boolean
d2653 1
a2653 1
     boolean *pswapped;
d2660 1
a2660 1
  *pswapped = false;
d2710 1
a2710 1
  return true;
d2715 1
a2715 1
  return false;
d2720 1
a2720 1
static boolean
d2788 1
a2788 1
	  boolean overflow;
d2791 1
a2791 1
	  overflow = false;
d2803 1
a2803 1
		overflow = true;
d2812 1
a2812 1
		overflow = true;
d2829 1
a2829 1
		    overflow = true;
d2842 1
a2842 1
	      return false;
d2847 1
a2847 1
  return true;
d2853 1
a2853 1
static boolean
d2906 1
a2906 1
	      return false;
d2928 1
a2928 1
	  return false;
d2976 2
a2977 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d3014 1
a3014 1
	      return false;
d3019 1
a3019 1
  return true;
d3032 1
a3032 1
     boolean relocateable;
d3067 2
a3068 2
			 (input_bfd, input_section, false, (bfd_byte *) NULL,
			  false, (struct internal_reloc *) NULL));
d3158 1
a3158 1
static boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
d3187 1
a3187 1
static boolean
d3193 1
a3193 1
    return false;
d3200 1
a3200 1
  return true;
d3215 1
a3215 1
  true,
d3217 1
a3217 1
  false,
d3220 1
a3220 1
  true,
d3222 1
a3222 1
  false,
d3226 1
a3226 1
  true,
d3228 1
a3228 1
  false,
@


1.21.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 2
/* BFD back-end for Renesas Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 1
a36 1
static bfd_boolean sh_align_load_span
d38 2
a39 2
	   bfd_boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *));
d51 3
a53 3
static bfd_boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_relax_delete_bytes
d58 3
a60 4
static bfd_boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *,
	   bfd_boolean *));
static bfd_boolean sh_swap_insns
d62 1
a62 1
static bfd_boolean sh_relocate_section
d67 1
a67 1
	   bfd_byte *, bfd_boolean, asymbol **));
d87 2
a88 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d90 1
a90 1
static bfd_boolean in_reloc_p (abfd, howto)
d110 1
a110 1
	 FALSE,			/* pc_relative */
d115 1
a115 1
	 TRUE,			/* partial_inplace */
d118 1
a118 1
	 FALSE),		/* pcrel_offset */
d134 1
a134 1
	 TRUE,			/* pc_relative */
d139 1
a139 1
	 TRUE,			/* partial_inplace */
d142 1
a142 1
	 TRUE),			/* pcrel_offset */
d150 1
a150 1
	 TRUE,			/* pc_relative */
d155 1
a155 1
	 TRUE,			/* partial_inplace */
d158 1
a158 1
	 TRUE),			/* pcrel_offset */
d166 1
a166 1
	 FALSE,			/* pc_relative */
d171 1
a171 1
	 TRUE,			/* partial_inplace */
d174 1
a174 1
	 FALSE),		/* pcrel_offset */
d182 1
a182 1
	 FALSE,	                /* pc_relative */
d187 1
a187 1
	 TRUE,	                /* partial_inplace */
d190 1
a190 1
	 FALSE),                /* pcrel_offset */
d204 1
a204 1
	 TRUE,			/* pc_relative */
d209 1
a209 1
	 TRUE,			/* partial_inplace */
d212 1
a212 1
	 TRUE),			/* pcrel_offset */
d218 1
a218 1
	 TRUE,			/* pc_relative */
d223 1
a223 1
	 TRUE,			/* partial_inplace */
d226 1
a226 1
	 TRUE),			/* pcrel_offset */
d232 1
a232 1
	 FALSE,			/* pc_relative */
d237 1
a237 1
	 TRUE,			/* partial_inplace */
d240 1
a240 1
	 FALSE),		/* pcrel_offset */
d246 1
a246 1
	 FALSE,			/* pc_relative */
d251 1
a251 1
	 TRUE,			/* partial_inplace */
d254 1
a254 1
	 FALSE),		/* pcrel_offset */
d260 1
a260 1
	 FALSE,			/* pc_relative */
d265 1
a265 1
	 TRUE,			/* partial_inplace */
d268 1
a268 1
	 FALSE),		/* pcrel_offset */
d274 1
a274 1
	 FALSE,			/* pc_relative */
d279 1
a279 1
	 TRUE,			/* partial_inplace */
d282 1
a282 1
	 FALSE),		/* pcrel_offset */
d288 1
a288 1
	 FALSE,			/* pc_relative */
d293 1
a293 1
	 TRUE,			/* partial_inplace */
d296 1
a296 1
	 FALSE),		/* pcrel_offset */
d302 1
a302 1
	 FALSE,			/* pc_relative */
d307 1
a307 1
	 TRUE,			/* partial_inplace */
d310 1
a310 1
	 FALSE),		/* pcrel_offset */
d316 1
a316 1
	 FALSE,			/* pc_relative */
d321 1
a321 1
	 TRUE,			/* partial_inplace */
d324 1
a324 1
	 FALSE),		/* pcrel_offset */
d330 1
a330 1
	 FALSE,			/* pc_relative */
d335 1
a335 1
	 TRUE,			/* partial_inplace */
d338 1
a338 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1
	 FALSE,			/* pc_relative */
d349 1
a349 1
	 TRUE,			/* partial_inplace */
d352 1
a352 1
	 FALSE),		/* pcrel_offset */
d358 1
a358 1
	 FALSE,			/* pc_relative */
d363 1
a363 1
	 TRUE,			/* partial_inplace */
d366 1
a366 1
	 FALSE)			/* pcrel_offset */
d692 1
a692 1
static bfd_boolean
d697 1
a697 1
     bfd_boolean *again;
d701 1
a701 1
  bfd_boolean have_code;
d706 1
a706 1
  *again = FALSE;
d708 1
a708 1
  if (link_info->relocatable
d711 1
a711 1
    return TRUE;
d720 1
a720 1
		      (bfd_byte *) NULL, FALSE,
d727 1
a727 1
  have_code = FALSE;
d739 1
a739 1
	have_code = TRUE;
d905 1
a905 1
      coff_section_data (abfd, sec)->keep_relocs = TRUE;
d909 1
a909 1
      coff_section_data (abfd, sec)->keep_contents = TRUE;
d912 1
a912 1
      obj_coff_keep_syms (abfd) = TRUE;
d968 1
a968 1
      *again = TRUE;
d1008 1
a1008 1
      bfd_boolean swapped;
d1043 1
a1043 1
	  coff_section_data (abfd, sec)->keep_relocs = TRUE;
d1047 1
a1047 1
	  coff_section_data (abfd, sec)->keep_contents = TRUE;
d1050 1
a1050 1
	  obj_coff_keep_syms (abfd) = TRUE;
d1079 1
a1079 1
  return TRUE;
d1086 1
a1086 1
  return FALSE;
d1091 1
a1091 1
static bfd_boolean
d1154 1
a1154 1
      bfd_boolean overflow;
d1316 1
a1316 1
	  overflow = FALSE;
d1327 1
a1327 1
		overflow = TRUE;
d1334 1
a1334 1
		overflow = TRUE;
d1348 1
a1348 1
		overflow = TRUE;
d1355 1
a1355 1
		overflow = TRUE;
d1362 1
a1362 1
		overflow = TRUE;
d1382 1
a1382 1
	      return FALSE;
d1404 1
a1404 1
         FALSE, we should free them, if we are permitted to, when we
d1407 1
a1407 1
			 (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,
d1410 1
a1410 1
	return FALSE;
d1446 1
a1446 1
                         Perhaps, if info->keep_memory is FALSE, we
d1451 1
a1451 1
			return FALSE;
d1455 1
a1455 1
			return FALSE;
d1466 1
a1466 1
	      coff_section_data (abfd, o)->keep_contents = TRUE;
d1482 1
a1482 1
      return FALSE;
d1535 1
a1535 1
  return TRUE;
a1648 2
#define MAP(a) a, sizeof a / sizeof a[0]

d1650 1
a1650 1
static bfd_boolean sh_insn_uses_reg
d1652 1
a1652 1
static bfd_boolean sh_insn_sets_reg
d1654 1
a1654 1
static bfd_boolean sh_insn_uses_or_sets_reg
d1656 1
a1656 1
static bfd_boolean sh_insn_uses_freg
d1658 1
a1658 1
static bfd_boolean sh_insn_sets_freg
d1660 1
a1660 1
static bfd_boolean sh_insn_uses_or_sets_freg
d1662 1
a1662 1
static bfd_boolean sh_insns_conflict
d1665 1
a1665 1
static bfd_boolean sh_load_use
d1668 2
d1671 1
a1671 1
/* The opcode maps.  */
d2091 1
d2111 1
d2133 1
d2169 1
a2169 1
static bfd_boolean
d2176 1
a2176 1
    return TRUE;
d2183 1
a2183 1
static bfd_boolean
d2195 1
a2195 1
    return TRUE;
d2198 1
a2198 1
    return TRUE;
d2201 1
a2201 1
    return TRUE;
d2203 1
a2203 1
    return TRUE;
d2205 1
a2205 1
    return TRUE;
d2207 1
a2207 1
  return FALSE;
d2212 1
a2212 1
static bfd_boolean
d2224 1
a2224 1
    return TRUE;
d2227 1
a2227 1
    return TRUE;
d2230 1
a2230 1
    return TRUE;
d2232 1
a2232 1
    return TRUE;
d2234 1
a2234 1
  return FALSE;
d2239 1
a2239 1
static bfd_boolean
d2246 1
a2246 1
    return TRUE;
d2253 1
a2253 1
static bfd_boolean
d2274 1
a2274 1
    return TRUE;
d2277 1
a2277 1
    return TRUE;
d2280 1
a2280 1
    return TRUE;
d2282 1
a2282 1
  return FALSE;
d2287 1
a2287 1
static bfd_boolean
d2308 1
a2308 1
    return TRUE;
d2310 1
a2310 1
  return FALSE;
d2315 1
a2315 1
   This should return TRUE if there is a conflict, or FALSE if the
d2318 1
a2318 1
static bfd_boolean
d2334 1
a2334 1
    return TRUE;
d2338 1
a2338 1
    return TRUE;
d2343 1
a2343 1
    return TRUE;
d2347 1
a2347 1
    return TRUE;
d2350 1
a2350 1
    return TRUE;
d2353 1
a2353 1
    return TRUE;
d2356 1
a2356 1
    return TRUE;
d2359 1
a2359 1
    return TRUE;
d2363 1
a2363 1
    return TRUE;
d2366 1
a2366 1
    return TRUE;
d2369 1
a2369 1
    return TRUE;
d2372 1
a2372 1
    return TRUE;
d2375 1
a2375 1
    return TRUE;
d2378 1
a2378 1
  return FALSE;
d2382 1
a2382 1
   TRUE if I1 loads a register which I2 uses.  */
d2384 1
a2384 1
static bfd_boolean
d2396 1
a2396 1
    return FALSE;
d2404 1
a2404 1
    return TRUE;
d2408 1
a2408 1
    return TRUE;
d2412 1
a2412 1
    return TRUE;
d2414 1
a2414 1
  return FALSE;
d2425 1
a2425 1
   *PSWAPPED is set to TRUE.  */
d2430 1
a2430 1
bfd_boolean
d2436 1
a2436 1
     bfd_boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d2442 1
a2442 1
     bfd_boolean *pswapped;
d2452 1
a2452 1
    return TRUE;
d2526 1
a2526 1
	  bfd_boolean ok;
d2533 1
a2533 1
	  ok = TRUE;
d2548 1
a2548 1
		ok = FALSE;
d2558 1
a2558 1
		ok = FALSE;
d2564 2
a2565 2
		return FALSE;
	      *pswapped = TRUE;
d2587 1
a2587 1
	      bfd_boolean ok;
d2592 1
a2592 1
	      ok = TRUE;
d2601 1
a2601 1
		ok = FALSE;
d2623 1
a2623 1
		    ok = FALSE;
d2629 2
a2630 2
		    return FALSE;
		  *pswapped = TRUE;
d2637 1
a2637 1
  return TRUE;
d2646 1
a2646 1
static bfd_boolean
d2652 1
a2652 1
     bfd_boolean *pswapped;
d2659 1
a2659 1
  *pswapped = FALSE;
d2709 1
a2709 1
  return TRUE;
d2714 1
a2714 1
  return FALSE;
d2719 1
a2719 1
static bfd_boolean
d2787 1
a2787 1
	  bfd_boolean overflow;
d2790 1
a2790 1
	  overflow = FALSE;
d2802 1
a2802 1
		overflow = TRUE;
d2811 1
a2811 1
		overflow = TRUE;
d2828 1
a2828 1
		    overflow = TRUE;
d2841 1
a2841 1
	      return FALSE;
d2846 1
a2846 1
  return TRUE;
d2852 1
a2852 1
static bfd_boolean
d2905 1
a2905 1
	      return FALSE;
d2927 1
a2927 1
	  return FALSE;
d2971 1
a2971 1
	  else if (! info->relocatable)
d2975 2
a2976 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d3013 1
a3013 1
	      return FALSE;
d3018 1
a3018 1
  return TRUE;
d3026 1
a3026 1
					data, relocatable, symbols)
d3031 1
a3031 1
     bfd_boolean relocatable;
d3042 1
a3042 1
  if (relocatable
d3047 1
a3047 1
						       relocatable,
d3066 2
a3067 2
			 (input_bfd, input_section, FALSE, (bfd_byte *) NULL,
			  FALSE, (struct internal_reloc *) NULL));
d3134 1
a3134 1
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
d3149 1
a3149 1
			       SEC_CODE | SEC_DATA, '_', NULL, COFF_SWAP_TABLE);
d3152 1
a3152 1
			       0, '_', NULL, COFF_SWAP_TABLE)
d3157 1
a3157 1
static bfd_boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
d3186 1
a3186 1
static bfd_boolean
d3192 1
a3192 1
    return FALSE;
d3199 1
a3199 1
  return TRUE;
d3214 1
a3214 1
  TRUE,
d3216 1
a3216 1
  FALSE,
d3219 1
a3219 1
  TRUE,
d3221 1
a3221 1
  FALSE,
d3225 1
a3225 1
  TRUE,
d3227 1
a3227 1
  FALSE,
@


1.21.14.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d36 1
a36 1
static bfd_boolean sh_align_load_span
d38 2
a39 2
	   bfd_boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *));
d51 3
a53 3
static bfd_boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_relax_delete_bytes
d58 3
a60 4
static bfd_boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *,
	   bfd_boolean *));
static bfd_boolean sh_swap_insns
d62 1
a62 1
static bfd_boolean sh_relocate_section
d67 1
a67 1
	   bfd_byte *, bfd_boolean, asymbol **));
d87 2
a88 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d90 1
a90 1
static bfd_boolean in_reloc_p (abfd, howto)
d110 1
a110 1
	 FALSE,			/* pc_relative */
d115 1
a115 1
	 TRUE,			/* partial_inplace */
d118 1
a118 1
	 FALSE),		/* pcrel_offset */
d134 1
a134 1
	 TRUE,			/* pc_relative */
d139 1
a139 1
	 TRUE,			/* partial_inplace */
d142 1
a142 1
	 TRUE),			/* pcrel_offset */
d150 1
a150 1
	 TRUE,			/* pc_relative */
d155 1
a155 1
	 TRUE,			/* partial_inplace */
d158 1
a158 1
	 TRUE),			/* pcrel_offset */
d166 1
a166 1
	 FALSE,			/* pc_relative */
d171 1
a171 1
	 TRUE,			/* partial_inplace */
d174 1
a174 1
	 FALSE),		/* pcrel_offset */
d182 1
a182 1
	 FALSE,	                /* pc_relative */
d187 1
a187 1
	 TRUE,	                /* partial_inplace */
d190 1
a190 1
	 FALSE),                /* pcrel_offset */
d204 1
a204 1
	 TRUE,			/* pc_relative */
d209 1
a209 1
	 TRUE,			/* partial_inplace */
d212 1
a212 1
	 TRUE),			/* pcrel_offset */
d218 1
a218 1
	 TRUE,			/* pc_relative */
d223 1
a223 1
	 TRUE,			/* partial_inplace */
d226 1
a226 1
	 TRUE),			/* pcrel_offset */
d232 1
a232 1
	 FALSE,			/* pc_relative */
d237 1
a237 1
	 TRUE,			/* partial_inplace */
d240 1
a240 1
	 FALSE),		/* pcrel_offset */
d246 1
a246 1
	 FALSE,			/* pc_relative */
d251 1
a251 1
	 TRUE,			/* partial_inplace */
d254 1
a254 1
	 FALSE),		/* pcrel_offset */
d260 1
a260 1
	 FALSE,			/* pc_relative */
d265 1
a265 1
	 TRUE,			/* partial_inplace */
d268 1
a268 1
	 FALSE),		/* pcrel_offset */
d274 1
a274 1
	 FALSE,			/* pc_relative */
d279 1
a279 1
	 TRUE,			/* partial_inplace */
d282 1
a282 1
	 FALSE),		/* pcrel_offset */
d288 1
a288 1
	 FALSE,			/* pc_relative */
d293 1
a293 1
	 TRUE,			/* partial_inplace */
d296 1
a296 1
	 FALSE),		/* pcrel_offset */
d302 1
a302 1
	 FALSE,			/* pc_relative */
d307 1
a307 1
	 TRUE,			/* partial_inplace */
d310 1
a310 1
	 FALSE),		/* pcrel_offset */
d316 1
a316 1
	 FALSE,			/* pc_relative */
d321 1
a321 1
	 TRUE,			/* partial_inplace */
d324 1
a324 1
	 FALSE),		/* pcrel_offset */
d330 1
a330 1
	 FALSE,			/* pc_relative */
d335 1
a335 1
	 TRUE,			/* partial_inplace */
d338 1
a338 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1
	 FALSE,			/* pc_relative */
d349 1
a349 1
	 TRUE,			/* partial_inplace */
d352 1
a352 1
	 FALSE),		/* pcrel_offset */
d358 1
a358 1
	 FALSE,			/* pc_relative */
d363 1
a363 1
	 TRUE,			/* partial_inplace */
d366 1
a366 1
	 FALSE)			/* pcrel_offset */
d692 1
a692 1
static bfd_boolean
d697 1
a697 1
     bfd_boolean *again;
d701 1
a701 1
  bfd_boolean have_code;
d706 1
a706 1
  *again = FALSE;
d711 1
a711 1
    return TRUE;
d720 1
a720 1
		      (bfd_byte *) NULL, FALSE,
d727 1
a727 1
  have_code = FALSE;
d739 1
a739 1
	have_code = TRUE;
d905 1
a905 1
      coff_section_data (abfd, sec)->keep_relocs = TRUE;
d909 1
a909 1
      coff_section_data (abfd, sec)->keep_contents = TRUE;
d912 1
a912 1
      obj_coff_keep_syms (abfd) = TRUE;
d968 1
a968 1
      *again = TRUE;
d1008 1
a1008 1
      bfd_boolean swapped;
d1043 1
a1043 1
	  coff_section_data (abfd, sec)->keep_relocs = TRUE;
d1047 1
a1047 1
	  coff_section_data (abfd, sec)->keep_contents = TRUE;
d1050 1
a1050 1
	  obj_coff_keep_syms (abfd) = TRUE;
d1079 1
a1079 1
  return TRUE;
d1086 1
a1086 1
  return FALSE;
d1091 1
a1091 1
static bfd_boolean
d1154 1
a1154 1
      bfd_boolean overflow;
d1316 1
a1316 1
	  overflow = FALSE;
d1327 1
a1327 1
		overflow = TRUE;
d1334 1
a1334 1
		overflow = TRUE;
d1348 1
a1348 1
		overflow = TRUE;
d1355 1
a1355 1
		overflow = TRUE;
d1362 1
a1362 1
		overflow = TRUE;
d1382 1
a1382 1
	      return FALSE;
d1404 1
a1404 1
         FALSE, we should free them, if we are permitted to, when we
d1407 1
a1407 1
			 (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,
d1410 1
a1410 1
	return FALSE;
d1446 1
a1446 1
                         Perhaps, if info->keep_memory is FALSE, we
d1451 1
a1451 1
			return FALSE;
d1455 1
a1455 1
			return FALSE;
d1466 1
a1466 1
	      coff_section_data (abfd, o)->keep_contents = TRUE;
d1482 1
a1482 1
      return FALSE;
d1535 1
a1535 1
  return TRUE;
d1650 1
a1650 1
static bfd_boolean sh_insn_uses_reg
d1652 1
a1652 1
static bfd_boolean sh_insn_sets_reg
d1654 1
a1654 1
static bfd_boolean sh_insn_uses_or_sets_reg
d1656 1
a1656 1
static bfd_boolean sh_insn_uses_freg
d1658 1
a1658 1
static bfd_boolean sh_insn_sets_freg
d1660 1
a1660 1
static bfd_boolean sh_insn_uses_or_sets_freg
d1662 1
a1662 1
static bfd_boolean sh_insns_conflict
d1665 1
a1665 1
static bfd_boolean sh_load_use
d2169 1
a2169 1
static bfd_boolean
d2176 1
a2176 1
    return TRUE;
d2183 1
a2183 1
static bfd_boolean
d2195 1
a2195 1
    return TRUE;
d2198 1
a2198 1
    return TRUE;
d2201 1
a2201 1
    return TRUE;
d2203 1
a2203 1
    return TRUE;
d2205 1
a2205 1
    return TRUE;
d2207 1
a2207 1
  return FALSE;
d2212 1
a2212 1
static bfd_boolean
d2224 1
a2224 1
    return TRUE;
d2227 1
a2227 1
    return TRUE;
d2230 1
a2230 1
    return TRUE;
d2232 1
a2232 1
    return TRUE;
d2234 1
a2234 1
  return FALSE;
d2239 1
a2239 1
static bfd_boolean
d2246 1
a2246 1
    return TRUE;
d2253 1
a2253 1
static bfd_boolean
d2274 1
a2274 1
    return TRUE;
d2277 1
a2277 1
    return TRUE;
d2280 1
a2280 1
    return TRUE;
d2282 1
a2282 1
  return FALSE;
d2287 1
a2287 1
static bfd_boolean
d2308 1
a2308 1
    return TRUE;
d2310 1
a2310 1
  return FALSE;
d2315 1
a2315 1
   This should return TRUE if there is a conflict, or FALSE if the
d2318 1
a2318 1
static bfd_boolean
d2334 1
a2334 1
    return TRUE;
d2338 1
a2338 1
    return TRUE;
d2343 1
a2343 1
    return TRUE;
d2347 1
a2347 1
    return TRUE;
d2350 1
a2350 1
    return TRUE;
d2353 1
a2353 1
    return TRUE;
d2356 1
a2356 1
    return TRUE;
d2359 1
a2359 1
    return TRUE;
d2363 1
a2363 1
    return TRUE;
d2366 1
a2366 1
    return TRUE;
d2369 1
a2369 1
    return TRUE;
d2372 1
a2372 1
    return TRUE;
d2375 1
a2375 1
    return TRUE;
d2378 1
a2378 1
  return FALSE;
d2382 1
a2382 1
   TRUE if I1 loads a register which I2 uses.  */
d2384 1
a2384 1
static bfd_boolean
d2396 1
a2396 1
    return FALSE;
d2404 1
a2404 1
    return TRUE;
d2408 1
a2408 1
    return TRUE;
d2412 1
a2412 1
    return TRUE;
d2414 1
a2414 1
  return FALSE;
d2425 1
a2425 1
   *PSWAPPED is set to TRUE.  */
d2430 1
a2430 1
bfd_boolean
d2436 1
a2436 1
     bfd_boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d2442 1
a2442 1
     bfd_boolean *pswapped;
d2452 1
a2452 1
    return TRUE;
d2526 1
a2526 1
	  bfd_boolean ok;
d2533 1
a2533 1
	  ok = TRUE;
d2548 1
a2548 1
		ok = FALSE;
d2558 1
a2558 1
		ok = FALSE;
d2564 2
a2565 2
		return FALSE;
	      *pswapped = TRUE;
d2587 1
a2587 1
	      bfd_boolean ok;
d2592 1
a2592 1
	      ok = TRUE;
d2601 1
a2601 1
		ok = FALSE;
d2623 1
a2623 1
		    ok = FALSE;
d2629 2
a2630 2
		    return FALSE;
		  *pswapped = TRUE;
d2637 1
a2637 1
  return TRUE;
d2646 1
a2646 1
static bfd_boolean
d2652 1
a2652 1
     bfd_boolean *pswapped;
d2659 1
a2659 1
  *pswapped = FALSE;
d2709 1
a2709 1
  return TRUE;
d2714 1
a2714 1
  return FALSE;
d2719 1
a2719 1
static bfd_boolean
d2787 1
a2787 1
	  bfd_boolean overflow;
d2790 1
a2790 1
	  overflow = FALSE;
d2802 1
a2802 1
		overflow = TRUE;
d2811 1
a2811 1
		overflow = TRUE;
d2828 1
a2828 1
		    overflow = TRUE;
d2841 1
a2841 1
	      return FALSE;
d2846 1
a2846 1
  return TRUE;
d2852 1
a2852 1
static bfd_boolean
d2905 1
a2905 1
	      return FALSE;
d2927 1
a2927 1
	  return FALSE;
d2975 2
a2976 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d3013 1
a3013 1
	      return FALSE;
d3018 1
a3018 1
  return TRUE;
d3031 1
a3031 1
     bfd_boolean relocateable;
d3066 2
a3067 2
			 (input_bfd, input_section, FALSE, (bfd_byte *) NULL,
			  FALSE, (struct internal_reloc *) NULL));
d3157 1
a3157 1
static bfd_boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
d3186 1
a3186 1
static bfd_boolean
d3192 1
a3192 1
    return FALSE;
d3199 1
a3199 1
  return TRUE;
d3214 1
a3214 1
  TRUE,
d3216 1
a3216 1
  FALSE,
d3219 1
a3219 1
  TRUE,
d3221 1
a3221 1
  FALSE,
d3225 1
a3225 1
  TRUE,
d3227 1
a3227 1
  FALSE,
@


1.21.14.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 2
a2 2
/* BFD back-end for Renesas Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 4
a13 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d15 4
a18 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d20 3
a22 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.21.14.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d709 1
a709 1
  if (link_info->relocatable
d2972 1
a2972 1
	  else if (! info->relocatable)
d3027 1
a3027 1
					data, relocatable, symbols)
d3032 1
a3032 1
     bfd_boolean relocatable;
d3043 1
a3043 1
  if (relocatable
d3048 1
a3048 1
						       relocatable,
d3135 1
a3135 1
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
d3150 1
a3150 1
			       SEC_CODE | SEC_DATA, '_', NULL, COFF_SWAP_TABLE);
d3153 1
a3153 1
			       0, '_', NULL, COFF_SWAP_TABLE)
@


1.21.14.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a1649 2
#define MAP(a) a, sizeof a / sizeof a[0]

d1669 2
d1672 1
a1672 1
/* The opcode maps.  */
d2092 1
d2112 1
d2134 1
@


1.20
log
@2002-03-07  H.J. Lu  (hjl@@gnu.org)

	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.
@
text
@d476 1
d484 8
@


1.20.4.1
log
@merge from trunk
@
text
@a475 1
#ifdef COFF_WITH_PE
a482 8
#else
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_CTOR, R_SH_IMM32 },
};
#endif
@


1.19
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d472 1
a472 1
  unsigned char bfd_reloc_val;
@


1.19.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d472 1
a472 1
  bfd_reloc_code_real_type bfd_reloc_val;
@


1.19.2.2
log
@2002-05-11  Ralf Corsepius  <corsepiu@@faw.uni-ulm.de>
            Daniel Jacobowitz  <drow@@mvista.com>

        * coff-sh.c (sh_reloc_map): Map to R_SH_IMM32 for non-PE.  Don't
        map BFD_RELOC_RVA.
@
text
@a475 1
#ifdef COFF_WITH_PE
a482 8
#else
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_CTOR, R_SH_IMM32 },
};
#endif
@


1.18
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d764 1
a764 1
				 bfd_get_filename (abfd),
d775 1
a775 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_vaddr, insn));
d792 1
a792 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d815 1
a815 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d831 1
a831 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d966 1
a966 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d975 1
a975 1
				  bfd_get_filename (abfd),
d1371 1
a1371 1
		bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d1471 1
a1471 1
	bfd_get_filename (abfd)));
d2830 1
a2830 1
		bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d2894 1
a2894 1
		 bfd_get_filename (input_bfd), symndx);
@


1.17
log
@Add more missing prototypes
@
text
@d382 2
a383 2
#define SWAP_IN_RELOC_OFFSET  bfd_h_get_32
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_32
d592 1
a592 1
      bfd_put_32 (abfd, insn, hit_data);
d597 3
a599 3
      insn += (sym_value + reloc_entry->addend
	       - pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase);
      bfd_put_32 (abfd, insn, hit_data);
d613 1
a613 1
      bfd_put_16 (abfd, insn, hit_data);
d787 1
a787 1
      paddr += (laddr + 4) &~ 3;
d889 2
a890 2
	  sec->used_by_bfd =
	    ((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d917 1
a917 1
		      0xb000 | ((foff >> 1) & 0xfff),
d925 2
a926 1
	  bfd_put_16 (abfd, 0xb000, contents + irel->r_vaddr - sec->vma);
d1027 2
a1028 2
	      sec->used_by_bfd =
		((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d1060 2
a1061 2
	      sec->used_by_bfd =
		((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d1121 2
a1122 1
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
d1133 1
a1133 1
	bfd_put_16 (abfd, NOP_OPCODE, contents + toaddr - count + i);
d1319 1
a1319 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1326 1
a1326 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1340 1
a1340 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1347 1
a1347 1
	      bfd_put_8 (abfd, voff, contents + nraddr);
d1354 1
a1354 1
	      bfd_put_signed_16 (abfd, voff, contents + nraddr);
d1359 1
a1359 1
	      bfd_put_signed_32 (abfd, voff, contents + nraddr);
d1522 1
a1522 1
					alignto - alignaddr);
d2648 1
d2655 2
a2656 1
  labels = (bfd_vma *) bfd_malloc (sec->reloc_count * sizeof (bfd_vma));
d2725 2
a2726 2
  bfd_put_16 (abfd, i2, contents + addr);
  bfd_put_16 (abfd, i1, contents + addr + 2);
d2794 1
a2794 1
	      bfd_put_16 (abfd, insn, loc);
d2803 1
a2803 1
	      bfd_put_16 (abfd, insn, loc);
d2820 1
a2820 1
		  bfd_put_16 (abfd, insn, loc);
d3042 1
a3042 1
	  input_section->_raw_size);
d3051 1
d3062 3
a3064 3
      internal_syms = ((struct internal_syment *)
		       bfd_malloc (obj_raw_syment_count (input_bfd)
				   * sizeof (struct internal_syment)));
d3068 3
a3070 2
      sections = (asection **) bfd_malloc (obj_raw_syment_count (input_bfd)
					   * sizeof (asection *));
@


1.16
log
@Support relocs for sh-coff targets as well as sh-pe.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d68 1
d87 1
d417 1
d2080 1
d2100 1
d3141 2
@


1.15
log
@Update copyright notices
@
text
@d26 1
d464 2
d492 3
a494 5
  for (i = 0; i < sizeof (sh_reloc_map) / sizeof (struct shcoff_reloc_map); i++)
    {
      if (sh_reloc_map[i].bfd_reloc_val == code)
	return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];
    }
a498 1
#endif /* COFF_WITH_PE */
@


1.14
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* coff-rs6000.c: Fix formatting.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* coff-we32k.c: Likewise.
	* coff-z8k.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
@


1.14.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
@


1.13
log
@Fix bfd_coff_small_swap_table initialisation.
@
text
@d34 1
a34 1
static boolean sh_align_load_span 
d91 1
a91 1
}     
d174 6
a179 6
  HOWTO (R_SH_IMAGEBASE,        /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d181 5
a185 5
	 sh_reloc,       	/* special_function */                     
	 "rva32",	        /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d394 1
a394 1
get_symbol_value (symbol)       
d396 1
a396 1
{                                             
d400 2
a401 2
    relocation = 0;                           
  else 
d679 1
a679 1
static boolean 
d2147 1
a2147 1
  return NULL;  
d2254 1
a2254 1
     
d2288 1
a2288 1
     
d2488 1
a2488 1
	
d2878 1
a2878 1
	{    
d2915 1
a2915 1
      
d3121 1
a3121 1
     
d3273 1
a3273 1
  
d3300 1
a3300 1
     bfd_generic_archive_p, _bfd_dummy_target},   
d3317 1
a3317 1
  
@


1.12
log
@	* coff-mips.c (mips_ecoff_backend_data):  Add initialization of
	_bfd_coff_force_symnames in strings and
	_bfd_coff_debug_string_prefix_length to their default values.
	* coff-sh.c: (bfd_coff_small_swap_table): Ditto.
@
text
@a3200 2
  false,
  2,
@


1.11
log
@Fix building with --enable-targets=all
@
text
@d3201 12
@


1.10
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d32 9
d53 1
d55 1
d416 1
a416 1
     bfd * abfd;
d1561 1
a1561 1
  unsigned short flags;
d1634 1
d1653 1
a1653 1

d2116 1
a2399 1
#ifndef COFF_IMAGE_WITH_PE
d2410 3
d2622 1
a2622 1
#endif
d3130 2
a3131 1
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE, 0, '_', NULL)
d3133 1
a3133 1
     
@


1.9
log
@Add WinCE support.
@
text
@d2941 1
a2941 1
		      rel->r_vaddr - input_section->vma)))
@


1.8
log
@bfd:
Reinstate bits of sh4 support that got accidentally deleted.
Add sh-dsp support.

bfd:

	* archures.c (bfd_mach_sh2, bfd_mach_sh_dsp): New macros.
	(bfd_mach_sh3_dsp): Likewise.
	(bfd_mach_sh4): Reinstate.
	(bfd_default_scan): Recognize 7410, 7708, 7729 and 7750.
	* bfd-in2.h: Regenerate.
	* coff-sh.c (struct sh_opcode): flags is no longer short.
	(USESAS, USESAS_REG, USESR8, SETSAS, SETSAS_REG): New macros.
	(sh_opcode41, sh_opcode42): Integrate as sh_opcode41.
	(sh_opcode01, sh_opcode02, sh_opcode40): Add sh-dsp opcodes.
	(sh_opcode41, sh_opcode4, sh_opcode80): Likewise.
	(sh_opcodes): No longer const.
	(sh_dsp_opcodef0, sh_dsp_opcodef): New arrays.
	(sh_insn_uses_reg): Check for USESAS and USESR8.
	(sh_insn_sets_reg, sh_insns_conflict): Check for SETSAS.
	(_bfd_sh_align_load_span): Return early for SH4.
	Modify sh_opcodes lookup table for sh-dsp / sh3-dsp.
	Take into account that field b of a parallel processing insn
	could be mistaken for a separate insn.
	* cpu-sh.c (arch_info_struct): New array elements for
	sh2, sh-dsp and sh3-dsp.
	Reinstate element for sh4.
	(SH2_NEXT, SH_DSP_NEXT, SH3_DSP_NEXT): New macros.
	(SH4_NEXT): Reinstate.
	(SH3_NEXT, SH3E_NEXT): Adjust.
	* elf-bfd.h (_sh_elf_set_mach_from_flags): Declare.
	* elf32-sh.c (sh_elf_set_private_flags): New function.
	(sh_elf_copy_private_data, sh_elf_set_mach_from_flags): Likewise.
	(sh_elf_merge_private_data): New function.
	(elf_backend_object_p, bfd_elf32_bfd_set_private_bfd_flags): Define.
	(bfd_elf32_bfd_copy_private_bfd_data): Define.
	(bfd_elf32_bfd_merge_private_bfd_data): Change to
	sh_elf_merge_private_data.

gas:

	* config/tc-sh.c ("elf/sh.h"): Include.
	(sh_dsp, valid_arch, reg_x, reg_y, reg_efg): New static variables.
	(md.begin): Initialize target_arch.
	Only include opcodes in has table that match selected architecture.
	(parse_reg): Recognize register names for sh-dsp.
	(parse_at): Recognize post-modify addressing.
	(get_operands): The leading space is now optional.
	(get_specific): Remove FDREG_N support.  Add support for sh-dsp
	arguments.  Update valid_arch.
	(build_Mytes): Add support for SDT_REG_N.
	(find_cooked_opcode): New function, broken out of md_assemble.
	(assemble_ppi, sh_elf_final_processing): New functions.
	(md_assemble): Use find_cooked_opcode and assemble_ppi.
	(md_longopts, md_parse_option): New option: -dsp.
	* config/tc-sh.h (elf_tc_final_processing): Define.
	(sh_elf_final_processing): Declare.

include/elf:

	* sh.h: (EF_SH_MACH_MASK, EF_SH_UNKNOWN, EF_SH1, EF_SH2): New macros.
	(EF_SH3, EF_SH_HAS_DSP, EF_SH_DSP, EF_SH3_DSP): Likewise.
	(EF_SH_HAS_FP, EF_SH3E, EF_SH4, EF_SH_MERGE_MACH): Likewise.

opcodes:

	* sh-dis.c (print_movxy, print_insn_ddt, print_dsp_reg): New functions.
	(print_insn_ppi): Likewise.
	(print_insn_shx): Use info->mach to select appropriate insn set.
	Add support for sh-dsp.  Remove FD_REG_N support.
	* sh-opc.h (sh_nibble_type): Add new values for sh-dsp support.
	(sh_arg_type): Likewise.  Remove FD_REG_N.
	(sh_dsp_reg_nums): New enum.
	(arch_sh1, arch_sh2, arch_sh3, arch_sh3e, arch_sh4): New macros.
	(arch_sh_dsp, arch_sh3_dsp, arch_sh1_up, arch_sh2_up): Likewise.
	(arch_sh3_up, arch_sh3e_up, arch_sh4_up, arch_sh_dsp_up): Likewise.
	(arch_sh3_dsp_up): Likewise.
	(sh_opcode_info): New field: arch.
	(sh_table): Split up insn with FD_REG_N into ones with F_REG_N and
	D_REG_N.  Fill in arch field.  Add sh-dsp insns.
@
text
@d29 5
d56 4
d61 7
a67 1
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (4)
d72 11
d89 16
d106 1
d162 15
d178 1
d365 1
d378 1
d398 90
d555 4
d572 3
d579 8
d787 6
d794 1
d1172 4
d1392 5
d1398 1
d1550 1
a1550 1
  unsigned flags;
d2179 1
d2387 1
d2607 1
d2848 4
d2896 5
d3097 1
d3099 1
d3111 4
d3116 1
d3118 1
a3118 1

d3294 1
@


1.7
log
@Fix problem where -relax could reorder multiple consecutive sets of the
same register:
	* coff-sh.c (USES1_REG, USES2_REG, SETS1_REG, SETS2_REG,
	USESF1_REG, USESF2_REG, SETSF1_REG, SETSF2_REG): New macros.
	* (sh_insn_sets_reg, sh_insn_sets_freg): New prototypes.
	* (sh_insn_sets_reg, sh_insn_uses_or_sets_reg, sh_insns_sets_freg,
	sh_insns_uses_or_sets_freg): New functions.
	* (sh_insn_uses_reg, sh_insn_uses_freg): Use new macros.
	* (sh_insns_conflict): Use new functions and new macros to
	detect conflicts when two instructions both set same integer registers,
	both set same fp register, and both set special register.
@
text
@d1367 1
a1367 1
  unsigned short flags;
d1434 6
a1479 1
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
a1481 1
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
a1482 1
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
d1486 15
d1503 3
a1505 2
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn */
a1506 1
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
d1514 1
a1514 1
};
d1518 1
a1597 1
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
a1600 1
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
a1604 1
  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
d1608 1
a1608 1
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
a1610 1
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
a1614 1
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
a1617 1
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
a1620 1
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
d1625 26
a1650 1
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
d1652 11
d1664 11
a1675 2
  { 0x4043, STORE | SETS1 | USES1 | USESSP },	/* stc.l spc,@@-rn */
  { 0x4047, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,spc */
d1677 7
a1683 6
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr */
  { 0x406a, SETSSP | USES1 }			/* lds rm,fpscr */
d1688 5
a1692 9
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l rx_bank,@@-rn */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rx_bank */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,rx_bank */
};

static const struct sh_opcode sh_opcode42[] =
{
  { 0x400c, SETS1 | USES1 | USES2 },			/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },			/* shld rm,rn */
d1699 1
a1699 2
  { MAP (sh_opcode41), 0xf08f },
  { MAP (sh_opcode42), 0xf00f }
d1751 1
d1757 1
d1759 1
d1881 1
a1881 1
static const struct sh_major_opcode sh_opcodes[] =
d1901 20
d1989 4
d2017 2
d2140 3
d2156 3
d2227 2
d2231 14
d2274 22
a2295 1
	  prev_op = sh_insn_info (prev_insn);
@


1.6
log
@	* coffcode.h (bfd_coff_backend_data): Add _bfd_filnmlen field.
	(bfd_coff_filnmlen): Define.
	(bfd_coff_std_swap_table): Initialize new field.
	* coffgen.c (coff_fix_symbol_name): Use bfd_coff_filnmlen rather
	than FILNMLEN.
	(coff_write_symbols): Likewise.
	(coff_get_normalized_symtab): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize new field.
	* libcoff.h: Rebuild.
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d1387 1
d1392 1
d1400 1
d1405 1
d1419 1
d1424 1
d1432 1
d1436 4
d1442 4
d1878 14
d1905 1
a1905 1
      && ((insn & 0x0f00) >> 8) == reg)
d1908 1
a1908 1
      && ((insn & 0x00f0) >> 4) == reg)
d1916 38
d1977 1
a1977 1
      && ((insn & 0x0e00) >> 8) == (freg & 0xe))
d1980 1
a1980 1
      && ((insn & 0x00e0) >> 4) == (freg & 0xe))
d1989 28
d2044 3
a2046 3
  if ((f1 & SETSSP) != 0 && (f2 & USESSP) != 0)
    return true;
  if ((f2 & SETSSP) != 0 && (f1 & USESSP) != 0)
d2050 1
a2050 1
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
d2053 1
a2053 1
      && sh_insn_uses_reg (i2, op2, (i1 & 0x00f0) >> 4))
d2056 1
a2056 1
      && sh_insn_uses_reg (i2, op2, 0))
d2059 1
a2059 1
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
d2063 1
a2063 1
      && sh_insn_uses_reg (i1, op1, (i2 & 0x0f00) >> 8))
d2066 1
a2066 1
      && sh_insn_uses_reg (i1, op1, (i2 & 0x00f0) >> 4))
d2069 1
a2069 1
      && sh_insn_uses_reg (i1, op1, 0))
d2072 1
a2072 1
      && sh_insn_uses_freg (i1, op1, (i2 & 0x0f00) >> 8))
@


1.5
log
@	Based on patches from Donn Terry <donn@@interix.com>:
	* coffcode.h (enum coff_symbol_classification): Define.
	(bfd_coff_backend_data): Rename _bfd_coff_sym_is_global to
	_bfd_coff_classify_symbol.  Change return type.
	(bfd_coff_classify_symbol): Rename from bfd_coff_sym_is_global.
	(coff_slurp_symbol_table): Use coff_classify_symbol.
	(coff_classify_symbol): New static function.
	(coff_sym_is_global): Never define.
	(bfd_coff_std_swap_table): Initialize with coff_classify_symbol.
	* cofflink.c (coff_link_check_ar_symbols): Use
	bfd_coff_classify_symbol rather than bfd_coff_sym_is_global.
	(coff_link_add_symbols): Likewise.
	(_bfd_coff_link_input_bfd): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize with
	coff_classify_symbol.
	* libcoff.h: Rebuild.
@
text
@d2751 1
a2751 1
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ,
@


1.4
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d2768 1
a2768 1
  coff_sym_is_global, coff_compute_section_file_positions,
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2682 1
a2682 6
const bfd_target shcoff_vec =
{
  "coff-sh",			/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
d2684 9
a2692 14
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
d2694 2
a2695 61
  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE,
};

const bfd_target shlcoff_vec =
{
  "coff-shl",			/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little endian too*/

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},   
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE,
};
d2783 2
d2824 2
d2868 2
@


1.2
log
@	* libbfd.c (_bfd_generic_verify_endian_match): New function.
	* libbfd-in.h (_bfd_generic_verify_endian_match): Declare.
	* libbfd.h: Regenerate.
	* coff-sh.c (sh_merge_private_data): Delete.
	(coff_bfd_merge_private_bfd_data): Change to
	_bfd_generic_verify_endian_match.
	(elf32-sh.c): bfd_elf32_bfd_merge_private_bfd_data: Define.
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d61 10
a70 10
  { 0 },
  { 1 },
  { 2 },
  { 3 }, /* R_SH_PCREL8 */
  { 4 }, /* R_SH_PCREL16 */
  { 5 }, /* R_SH_HIGH8 */
  { 6 }, /* R_SH_IMM24 */
  { 7 }, /* R_SH_LOW16 */
  { 8 },
  { 9 }, /* R_SH_PCDISP8BY4 */
d86 1
a86 1
  { 11 }, /* R_SH_PCDISP8 */
d102 1
a102 1
  { 13 },
d118 7
a124 7
  { 15 },
  { 16 }, /* R_SH_IMM8 */
  { 17 }, /* R_SH_IMM8BY2 */
  { 18 }, /* R_SH_IMM8BY4 */
  { 19 }, /* R_SH_IMM4 */
  { 20 }, /* R_SH_IMM4BY2 */
  { 21 }, /* R_SH_IMM4BY4 */
d384 1
a384 1
     char **error_message;
d2415 1
a2415 1
     bfd *output_bfd;
@


1.1
log
@Initial revision
@
text
@a34 1
static boolean sh_merge_private_data PARAMS ((bfd *, bfd *));
d444 1
a444 25
/* This routine checks for linking big and little endian objects
   together.  */

static boolean
sh_merge_private_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	("%s: compiled for a %s endian system and target is %s endian",
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }

  return true;
}

#define coff_bfd_merge_private_bfd_data sh_merge_private_data
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

