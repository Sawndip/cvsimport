head	1.87;
access;
symbols
	sid-snapshot-20180601:1.87
	sid-snapshot-20180501:1.87
	sid-snapshot-20180401:1.87
	sid-snapshot-20180301:1.87
	sid-snapshot-20180201:1.87
	sid-snapshot-20180101:1.87
	sid-snapshot-20171201:1.87
	sid-snapshot-20171101:1.87
	sid-snapshot-20171001:1.87
	sid-snapshot-20170901:1.87
	sid-snapshot-20170801:1.87
	sid-snapshot-20170701:1.87
	sid-snapshot-20170601:1.87
	sid-snapshot-20170501:1.87
	sid-snapshot-20170401:1.87
	sid-snapshot-20170301:1.87
	sid-snapshot-20170201:1.87
	sid-snapshot-20170101:1.87
	sid-snapshot-20161201:1.87
	sid-snapshot-20161101:1.87
	sid-snapshot-20160901:1.87
	sid-snapshot-20160801:1.87
	sid-snapshot-20160701:1.87
	sid-snapshot-20160601:1.87
	sid-snapshot-20160501:1.87
	sid-snapshot-20160401:1.87
	sid-snapshot-20160301:1.87
	sid-snapshot-20160201:1.87
	sid-snapshot-20160101:1.87
	sid-snapshot-20151201:1.87
	sid-snapshot-20151101:1.87
	sid-snapshot-20151001:1.87
	sid-snapshot-20150901:1.87
	sid-snapshot-20150801:1.87
	sid-snapshot-20150701:1.87
	sid-snapshot-20150601:1.87
	sid-snapshot-20150501:1.87
	sid-snapshot-20150401:1.87
	sid-snapshot-20150301:1.87
	sid-snapshot-20150201:1.87
	sid-snapshot-20150101:1.87
	sid-snapshot-20141201:1.87
	sid-snapshot-20141101:1.87
	sid-snapshot-20141001:1.87
	sid-snapshot-20140901:1.87
	sid-snapshot-20140801:1.87
	sid-snapshot-20140701:1.87
	sid-snapshot-20140601:1.87
	sid-snapshot-20140501:1.87
	sid-snapshot-20140401:1.87
	sid-snapshot-20140301:1.87
	sid-snapshot-20140201:1.87
	sid-snapshot-20140101:1.87
	sid-snapshot-20131201:1.87
	sid-snapshot-20131101:1.87
	sid-snapshot-20131001:1.87
	binutils-2_24-branch:1.87.0.2
	binutils-2_24-branchpoint:1.87
	binutils-2_21_1:1.78.4.1
	sid-snapshot-20130901:1.87
	gdb_7_6_1-2013-08-30-release:1.86
	sid-snapshot-20130801:1.87
	sid-snapshot-20130701:1.87
	sid-snapshot-20130601:1.87
	sid-snapshot-20130501:1.87
	gdb_7_6-2013-04-26-release:1.86
	sid-snapshot-20130401:1.87
	binutils-2_23_2:1.84
	gdb_7_6-branch:1.86.0.2
	gdb_7_6-2013-03-12-branchpoint:1.86
	sid-snapshot-20130301:1.86
	sid-snapshot-20130201:1.86
	sid-snapshot-20130101:1.85
	sid-snapshot-20121201:1.85
	gdb_7_5_1-2012-11-29-release:1.83
	binutils-2_23_1:1.84
	sid-snapshot-20121101:1.85
	binutils-2_23:1.84
	sid-snapshot-20121001:1.84
	sid-snapshot-20120901:1.84
	gdb_7_5-2012-08-17-release:1.83
	sid-snapshot-20120801:1.84
	binutils-2_23-branch:1.84.0.2
	binutils-2_23-branchpoint:1.84
	gdb_7_5-branch:1.83.0.4
	gdb_7_5-2012-07-18-branchpoint:1.83
	sid-snapshot-20120701:1.83
	sid-snapshot-20120601:1.83
	sid-snapshot-20120501:1.83
	binutils-2_22_branch:1.80.0.4
	gdb_7_4_1-2012-04-26-release:1.83
	sid-snapshot-20120401:1.83
	sid-snapshot-20120301:1.83
	sid-snapshot-20120201:1.83
	gdb_7_4-2012-01-24-release:1.83
	sid-snapshot-20120101:1.83
	gdb_7_4-branch:1.83.0.2
	gdb_7_4-2011-12-13-branchpoint:1.83
	sid-snapshot-20111201:1.83
	binutils-2_22:1.80
	sid-snapshot-20111101:1.82
	sid-snapshot-20111001:1.81
	binutils-2_22-branch:1.80.0.2
	binutils-2_22-branchpoint:1.80
	gdb_7_3_1-2011-09-04-release:1.78
	sid-snapshot-20110901:1.80
	sid-snapshot-20110801:1.79
	gdb_7_3-2011-07-26-release:1.78
	sid-snapshot-20110701:1.79
	sid-snapshot-20110601:1.79
	sid-snapshot-20110501:1.78
	gdb_7_3-branch:1.78.0.6
	gdb_7_3-2011-04-01-branchpoint:1.78
	sid-snapshot-20110401:1.78
	sid-snapshot-20110301:1.78
	sid-snapshot-20110201:1.78
	sid-snapshot-20110101:1.78
	binutils-2_21:1.78
	sid-snapshot-20101201:1.78
	binutils-2_21-branch:1.78.0.4
	binutils-2_21-branchpoint:1.78
	sid-snapshot-20101101:1.78
	sid-snapshot-20101001:1.78
	binutils-2_20_1:1.74.2.2
	gdb_7_2-2010-09-02-release:1.78
	sid-snapshot-20100901:1.78
	sid-snapshot-20100801:1.78
	gdb_7_2-branch:1.78.0.2
	gdb_7_2-2010-07-07-branchpoint:1.78
	sid-snapshot-20100701:1.78
	sid-snapshot-20100601:1.78
	sid-snapshot-20100501:1.78
	sid-snapshot-20100401:1.77
	gdb_7_1-2010-03-18-release:1.77
	sid-snapshot-20100301:1.77
	gdb_7_1-branch:1.77.0.2
	gdb_7_1-2010-02-18-branchpoint:1.77
	sid-snapshot-20100201:1.77
	sid-snapshot-20100101:1.77
	gdb_7_0_1-2009-12-22-release:1.76
	sid-snapshot-20091201:1.76
	sid-snapshot-20091101:1.76
	binutils-2_20:1.74.2.2
	gdb_7_0-2009-10-06-release:1.76
	sid-snapshot-20091001:1.76
	gdb_7_0-branch:1.76.0.2
	gdb_7_0-2009-09-16-branchpoint:1.76
	arc-sim-20090309:1.65
	binutils-arc-20081103-branch:1.68.0.10
	binutils-arc-20081103-branchpoint:1.68
	binutils-2_20-branch:1.74.0.2
	binutils-2_20-branchpoint:1.74
	sid-snapshot-20090901:1.73
	sid-snapshot-20090801:1.72
	msnyder-checkpoint-072509-branch:1.72.0.4
	msnyder-checkpoint-072509-branchpoint:1.72
	sid-snapshot-20090701:1.72
	dje-cgen-play1-branch:1.72.0.2
	dje-cgen-play1-branchpoint:1.72
	sid-snapshot-20090601:1.72
	sid-snapshot-20090501:1.71
	sid-snapshot-20090401:1.70
	arc-20081103-branch:1.68.0.8
	arc-20081103-branchpoint:1.68
	arc-insight_6_8-branch:1.65.0.12
	arc-insight_6_8-branchpoint:1.65
	insight_6_8-branch:1.65.0.10
	insight_6_8-branchpoint:1.65
	sid-snapshot-20090301:1.69
	binutils-2_19_1:1.67
	sid-snapshot-20090201:1.68
	sid-snapshot-20090101:1.68
	reverse-20081226-branch:1.68.0.6
	reverse-20081226-branchpoint:1.68
	sid-snapshot-20081201:1.68
	multiprocess-20081120-branch:1.68.0.4
	multiprocess-20081120-branchpoint:1.68
	sid-snapshot-20081101:1.68
	binutils-2_19:1.67
	sid-snapshot-20081001:1.68
	reverse-20080930-branch:1.68.0.2
	reverse-20080930-branchpoint:1.68
	binutils-2_19-branch:1.67.0.2
	binutils-2_19-branchpoint:1.67
	sid-snapshot-20080901:1.67
	sid-snapshot-20080801:1.66
	reverse-20080717-branch:1.65.0.8
	reverse-20080717-branchpoint:1.65
	sid-snapshot-20080701:1.65
	msnyder-reverse-20080609-branch:1.65.0.6
	msnyder-reverse-20080609-branchpoint:1.65
	drow-reverse-20070409-branch:1.56.0.2
	drow-reverse-20070409-branchpoint:1.56
	sid-snapshot-20080601:1.65
	sid-snapshot-20080501:1.65
	sid-snapshot-20080403:1.65
	sid-snapshot-20080401:1.65
	gdb_6_8-2008-03-27-release:1.65
	sid-snapshot-20080301:1.65
	gdb_6_8-branch:1.65.0.4
	gdb_6_8-2008-02-26-branchpoint:1.65
	sid-snapshot-20080201:1.65
	sid-snapshot-20080101:1.65
	sid-snapshot-20071201:1.65
	sid-snapshot-20071101:1.65
	gdb_6_7_1-2007-10-29-release:1.65
	gdb_6_7-2007-10-10-release:1.65
	sid-snapshot-20071001:1.65
	gdb_6_7-branch:1.65.0.2
	gdb_6_7-2007-09-07-branchpoint:1.65
	binutils-2_18:1.64.2.1
	binutils-2_18-branch:1.64.0.2
	binutils-2_18-branchpoint:1.64
	insight_6_6-20070208-release:1.55
	binutils-csl-coldfire-4_1-32:1.54
	binutils-csl-sourcerygxx-4_1-32:1.54
	gdb_6_6-2006-12-18-release:1.55
	binutils-csl-innovasic-fido-3_4_4-33:1.54
	binutils-csl-sourcerygxx-3_4_4-32:1.48
	binutils-csl-coldfire-4_1-30:1.54
	binutils-csl-sourcerygxx-4_1-30:1.54
	binutils-csl-coldfire-4_1-28:1.54
	binutils-csl-sourcerygxx-4_1-29:1.54
	binutils-csl-sourcerygxx-4_1-28:1.54
	gdb_6_6-branch:1.55.0.2
	gdb_6_6-2006-11-15-branchpoint:1.55
	binutils-csl-arm-2006q3-27:1.54
	binutils-csl-sourcerygxx-4_1-27:1.54
	binutils-csl-arm-2006q3-26:1.54
	binutils-csl-sourcerygxx-4_1-26:1.54
	binutils-csl-sourcerygxx-4_1-25:1.54
	binutils-csl-sourcerygxx-4_1-24:1.54
	binutils-csl-sourcerygxx-4_1-23:1.54
	insight_6_5-20061003-release:1.54
	gdb-csl-symbian-6_4_50_20060226-12:1.54
	binutils-csl-sourcerygxx-4_1-21:1.54
	binutils-csl-arm-2006q3-21:1.54
	binutils-csl-sourcerygxx-4_1-22:1.54
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.54
	binutils-csl-sourcerygxx-4_1-20:1.54
	binutils-csl-arm-2006q3-19:1.54
	binutils-csl-sourcerygxx-4_1-19:1.54
	binutils-csl-sourcerygxx-4_1-18:1.54
	binutils-csl-renesas-4_1-9:1.54
	gdb-csl-sourcerygxx-3_4_4-25:1.54
	binutils-csl-sourcerygxx-3_4_4-25:1.48
	nickrob-async-20060828-mergepoint:1.55
	gdb-csl-symbian-6_4_50_20060226-11:1.54
	binutils-csl-renesas-4_1-8:1.54
	binutils-csl-renesas-4_1-7:1.54
	binutils-csl-renesas-4_1-6:1.54
	gdb-csl-sourcerygxx-4_1-17:1.54
	binutils-csl-sourcerygxx-4_1-17:1.54
	gdb-csl-20060226-branch-local-2:1.54
	gdb-csl-sourcerygxx-4_1-14:1.54
	binutils-csl-sourcerygxx-4_1-14:1.54
	binutils-csl-sourcerygxx-4_1-15:1.54
	gdb-csl-sourcerygxx-4_1-13:1.54
	binutils-csl-sourcerygxx-4_1-13:1.54
	binutils-2_17:1.54
	gdb-csl-sourcerygxx-4_1-12:1.54
	binutils-csl-sourcerygxx-4_1-12:1.54
	gdb-csl-sourcerygxx-3_4_4-21:1.54
	binutils-csl-sourcerygxx-3_4_4-21:1.54
	gdb_6_5-20060621-release:1.54
	binutils-csl-wrs-linux-3_4_4-24:1.48
	binutils-csl-wrs-linux-3_4_4-23:1.48
	gdb-csl-sourcerygxx-4_1-9:1.54
	binutils-csl-sourcerygxx-4_1-9:1.54
	gdb-csl-sourcerygxx-4_1-8:1.54
	binutils-csl-sourcerygxx-4_1-8:1.54
	gdb-csl-sourcerygxx-4_1-7:1.54
	binutils-csl-sourcerygxx-4_1-7:1.54
	gdb-csl-arm-2006q1-6:1.54
	binutils-csl-arm-2006q1-6:1.54
	gdb-csl-sourcerygxx-4_1-6:1.54
	binutils-csl-sourcerygxx-4_1-6:1.54
	binutils-csl-wrs-linux-3_4_4-22:1.48
	gdb-csl-symbian-6_4_50_20060226-10:1.54
	gdb-csl-symbian-6_4_50_20060226-9:1.54
	gdb-csl-symbian-6_4_50_20060226-8:1.54
	gdb-csl-coldfire-4_1-11:1.54
	binutils-csl-coldfire-4_1-11:1.54
	gdb-csl-sourcerygxx-3_4_4-19:1.54
	binutils-csl-sourcerygxx-3_4_4-19:1.54
	gdb-csl-coldfire-4_1-10:1.54
	gdb_6_5-branch:1.54.0.30
	gdb_6_5-2006-05-14-branchpoint:1.54
	binutils-csl-coldfire-4_1-10:1.54
	gdb-csl-sourcerygxx-4_1-5:1.54
	binutils-csl-sourcerygxx-4_1-5:1.54
	nickrob-async-20060513-branch:1.54.0.28
	nickrob-async-20060513-branchpoint:1.54
	gdb-csl-sourcerygxx-4_1-4:1.54
	binutils-csl-sourcerygxx-4_1-4:1.54
	msnyder-reverse-20060502-branch:1.54.0.26
	msnyder-reverse-20060502-branchpoint:1.54
	binutils-csl-wrs-linux-3_4_4-21:1.48
	gdb-csl-morpho-4_1-4:1.54
	binutils-csl-morpho-4_1-4:1.54
	gdb-csl-sourcerygxx-3_4_4-17:1.54
	binutils-csl-sourcerygxx-3_4_4-17:1.54
	binutils-csl-wrs-linux-3_4_4-20:1.48
	readline_5_1-import-branch:1.54.0.24
	readline_5_1-import-branchpoint:1.54
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.54
	binutils-2_17-branch:1.54.0.22
	binutils-2_17-branchpoint:1.54
	gdb-csl-symbian-20060226-branch:1.54.0.20
	gdb-csl-symbian-20060226-branchpoint:1.54
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.54
	msnyder-reverse-20060331-branch:1.54.0.18
	msnyder-reverse-20060331-branchpoint:1.54
	binutils-csl-2_17-branch:1.54.0.16
	binutils-csl-2_17-branchpoint:1.54
	gdb-csl-available-20060303-branch:1.54.0.14
	gdb-csl-available-20060303-branchpoint:1.54
	gdb-csl-20060226-branch:1.54.0.12
	gdb-csl-20060226-branchpoint:1.54
	gdb_6_4-20051202-release:1.54
	msnyder-fork-checkpoint-branch:1.54.0.10
	msnyder-fork-checkpoint-branchpoint:1.54
	gdb-csl-gxxpro-6_3-branch:1.54.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.54
	gdb_6_4-branch:1.54.0.6
	gdb_6_4-2005-11-01-branchpoint:1.54
	gdb-csl-arm-20051020-branch:1.54.0.4
	gdb-csl-arm-20051020-branchpoint:1.54
	binutils-csl-gxxpro-3_4-branch:1.48.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.48
	binutils-2_16_1:1.48
	msnyder-tracepoint-checkpoint-branch:1.54.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.54
	gdb-csl-arm-20050325-2005-q1b:1.49
	binutils-csl-arm-2005q1b:1.48
	binutils-2_16:1.48
	gdb-csl-arm-20050325-2005-q1a:1.49
	binutils-csl-arm-2005q1a:1.48
	csl-arm-20050325-branch:1.49.0.2
	csl-arm-20050325-branchpoint:1.49
	binutils-csl-arm-2005q1-branch:1.48.0.4
	binutils-csl-arm-2005q1-branchpoint:1.48
	binutils-2_16-branch:1.48.0.2
	binutils-2_16-branchpoint:1.48
	csl-arm-2004-q3d:1.45
	gdb_6_3-20041109-release:1.45
	gdb_6_3-branch:1.45.0.2
	gdb_6_3-20041019-branchpoint:1.45
	csl-arm-2004-q3:1.45
	drow_intercu-merge-20040921:1.45
	drow_intercu-merge-20040915:1.45
	jimb-gdb_6_2-e500-branch:1.43.0.6
	jimb-gdb_6_2-e500-branchpoint:1.43
	gdb_6_2-20040730-release:1.43
	gdb_6_2-branch:1.43.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.43
	gdb_6_1_1-20040616-release:1.41
	binutils-2_15:1.41
	binutils-2_15-branchpoint:1.41
	csl-arm-2004-q1a:1.41
	csl-arm-2004-q1:1.41
	gdb_6_1-2004-04-05-release:1.41
	drow_intercu-merge-20040402:1.41
	drow_intercu-merge-20040327:1.41
	ezannoni_pie-20040323-branch:1.41.0.14
	ezannoni_pie-20040323-branchpoint:1.41
	cagney_tramp-20040321-mergepoint:1.41
	cagney_tramp-20040309-branch:1.41.0.12
	cagney_tramp-20040309-branchpoint:1.41
	gdb_6_1-branch:1.41.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.41
	drow_intercu-20040221-branch:1.41.0.8
	drow_intercu-20040221-branchpoint:1.41
	binutils-2_15-branch:1.41.0.6
	cagney_bfdfile-20040213-branch:1.41.0.4
	cagney_bfdfile-20040213-branchpoint:1.41
	drow-cplus-merge-20040208:1.41
	carlton_dictionary-20040126-merge:1.41
	cagney_bigcore-20040122-branch:1.41.0.2
	cagney_bigcore-20040122-branchpoint:1.41
	drow-cplus-merge-20040113:1.41
	csl-arm-2003-q4:1.41
	drow-cplus-merge-20031224:1.41
	drow-cplus-merge-20031220:1.41
	carlton_dictionary-20031215-merge:1.41
	drow-cplus-merge-20031214:1.41
	carlton-dictionary-20031111-merge:1.41
	gdb_6_0-2003-10-04-release:1.38
	kettenis_sparc-20030918-branch:1.38.0.28
	kettenis_sparc-20030918-branchpoint:1.38
	carlton_dictionary-20030917-merge:1.38
	ezannoni_pie-20030916-branchpoint:1.38
	ezannoni_pie-20030916-branch:1.38.0.26
	cagney_x86i386-20030821-branch:1.38.0.24
	cagney_x86i386-20030821-branchpoint:1.38
	carlton_dictionary-20030805-merge:1.38
	carlton_dictionary-20030627-merge:1.38
	gdb_6_0-branch:1.38.0.22
	gdb_6_0-2003-06-23-branchpoint:1.38
	jimb-ppc64-linux-20030613-branch:1.38.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.38
	binutils-2_14:1.38
	cagney_convert-20030606-branch:1.38.0.18
	cagney_convert-20030606-branchpoint:1.38
	cagney_writestrings-20030508-branch:1.38.0.16
	cagney_writestrings-20030508-branchpoint:1.38
	jimb-ppc64-linux-20030528-branch:1.38.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.38
	carlton_dictionary-20030523-merge:1.38
	cagney_fileio-20030521-branch:1.38.0.12
	cagney_fileio-20030521-branchpoint:1.38
	kettenis_i386newframe-20030517-mergepoint:1.38
	jimb-ppc64-linux-20030509-branch:1.38.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.38
	kettenis_i386newframe-20030504-mergepoint:1.38
	carlton_dictionary-20030430-merge:1.38
	binutils-2_14-branch:1.38.0.8
	binutils-2_14-branchpoint:1.38
	kettenis_i386newframe-20030419-branch:1.38.0.6
	kettenis_i386newframe-20030419-branchpoint:1.38
	carlton_dictionary-20030416-merge:1.38
	cagney_frameaddr-20030409-mergepoint:1.38
	kettenis_i386newframe-20030406-branch:1.38.0.4
	kettenis_i386newframe-20030406-branchpoint:1.38
	cagney_frameaddr-20030403-branchpoint:1.38
	cagney_frameaddr-20030403-branch:1.38.0.2
	cagney_framebase-20030330-mergepoint:1.37
	cagney_framebase-20030326-branch:1.37.0.2
	cagney_framebase-20030326-branchpoint:1.37
	cagney_lazyid-20030317-branch:1.36.0.12
	cagney_lazyid-20030317-branchpoint:1.36
	kettenis-i386newframe-20030316-mergepoint:1.36
	offbyone-20030313-branch:1.36.0.10
	offbyone-20030313-branchpoint:1.36
	kettenis-i386newframe-20030308-branch:1.36.0.8
	kettenis-i386newframe-20030308-branchpoint:1.36
	carlton_dictionary-20030305-merge:1.36
	cagney_offbyone-20030303-branch:1.36.0.6
	cagney_offbyone-20030303-branchpoint:1.36
	carlton_dictionary-20030207-merge:1.36
	interps-20030202-branch:1.36.0.4
	interps-20030202-branchpoint:1.36
	cagney-unwind-20030108-branch:1.36.0.2
	cagney-unwind-20030108-branchpoint:1.36
	binutils-2_13_2_1:1.33.2.2
	binutils-2_13_2:1.33.2.2
	carlton_dictionary-20021223-merge:1.36
	gdb_5_3-2002-12-12-release:1.34
	carlton_dictionary-20021115-merge:1.35
	binutils-2_13_1:1.33.2.2
	kseitz_interps-20021105-merge:1.35
	kseitz_interps-20021103-merge:1.35
	drow-cplus-merge-20021020:1.34
	drow-cplus-merge-20021025:1.34
	carlton_dictionary-20021025-merge:1.35
	carlton_dictionary-20021011-merge:1.34
	drow-cplus-branch:1.34.0.12
	drow-cplus-branchpoint:1.34
	kseitz_interps-20020930-merge:1.34
	carlton_dictionary-20020927-merge:1.34
	carlton_dictionary-branch:1.34.0.10
	carlton_dictionary-20020920-branchpoint:1.34
	sid-20020905-branchpoint:1.34
	sid-20020905-branch:1.34.0.8
	gdb_5_3-branch:1.34.0.6
	gdb_5_3-2002-09-04-branchpoint:1.34
	kseitz_interps-20020829-merge:1.34
	cagney_sysregs-20020825-branch:1.34.0.4
	cagney_sysregs-20020825-branchpoint:1.34
	readline_4_3-import-branch:1.34.0.2
	readline_4_3-import-branchpoint:1.34
	binutils-2_13:1.33
	gdb_5_2_1-2002-07-23-release:1.31
	binutils-2_13-branchpoint:1.33
	binutils-2_13-branch:1.33.0.2
	kseitz_interps-20020528-branch:1.31.0.10
	kseitz_interps-20020528-branchpoint:1.31
	cagney_regbuf-20020515-branch:1.31.0.8
	cagney_regbuf-20020515-branchpoint:1.31
	binutils-2_12_1:1.31
	jimb-macro-020506-branch:1.31.0.6
	jimb-macro-020506-branchpoint:1.31
	gdb_5_2-2002-04-29-release:1.31
	binutils-2_12:1.31
	gdb_5_2-branch:1.31.0.4
	gdb_5_2-2002-03-03-branchpoint:1.31
	binutils-2_12-branch:1.31.0.2
	binutils-2_12-branchpoint:1.31
	gdb_5_1_1-2002-01-24-release:1.22
	gdb_5_1_0_1-2002-01-03-release:1.22
	cygnus_cvs_20020108_pre:1.30
	gdb_5_1_0_1-2002-01-03-branch:1.22.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.22
	gdb_5_1-2001-11-21-release:1.22
	gdb_s390-2001-09-26-branch:1.22.0.4
	gdb_s390-2001-09-26-branchpoint:1.22
	gdb_5_1-2001-07-29-branch:1.22.0.2
	gdb_5_1-2001-07-29-branchpoint:1.22
	binutils-2_11_2:1.18.2.2
	binutils-2_11_1:1.18.2.2
	binutils-2_11:1.18.2.1
	x86_64versiong3:1.19
	binutils-2_11-branch:1.18.0.2
	insight-precleanup-2001-01-01:1.17
	binutils-2_10_1:1.11
	binutils-2_10:1.11
	gdb-premipsmulti-2000-06-06-branch:1.13.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.13
	gdb_5_0-2000-05-19-release:1.12
	gdb_4_18_2-2000-05-18-release:1.12
	gdb_4_95_1-2000-05-11-snapshot:1.12
	gdb_4_95_0-2000-04-27-snapshot:1.12
	gdb_5_0-2000-04-10-branch:1.12.0.2
	gdb_5_0-2000-04-10-branchpoint:1.12
	binutils-2_10-branch:1.11.0.2
	binutils-2_10-branchpoint:1.11
	binutils_latest_snapshot:1.87
	repo-unification-2000-02-06:1.10
	binu_ss_19990721:1.3
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.87
date	2013.03.21.14.07.08;	author ktietz;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.18.17.42.29;	author ktietz;	state Exp;
branches;
next	1.84;

1.84
date	2012.07.24.21.06.57;	author ccoutant;	state Exp;
branches;
next	1.83;

1.83
date	2011.11.02.14.53.03;	author jbeulich;	state Exp;
branches;
next	1.82;

1.82
date	2011.10.06.08.59.36;	author ktietz;	state Exp;
branches;
next	1.81;

1.81
date	2011.09.30.10.39.44;	author gingold;	state Exp;
branches;
next	1.80;

1.80
date	2011.08.17.00.39.39;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2011.05.07.14.26.56;	author davek;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.27.14.42.50;	author nickc;	state Exp;
branches
	1.78.4.1;
next	1.77;

1.77
date	2009.12.11.13.42.01;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2009.09.05.07.56.21;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2009.05.21.12.52.37;	author davek;	state Exp;
branches;
next	1.71;

1.71
date	2009.04.14.09.47.43;	author davek;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.14.09.34.27;	author rsandifo;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.30.10.50.03;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.14.02.38.22;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2007.08.13.01.45.11;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2007.07.31.03.53.24;	author msnyder;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2007.07.27.18.54.04;	author msnyder;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.26.19.06.12;	author msnyder;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.26.18.43.24;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.26.02.01.49;	author msnyder;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.12.07.16.40;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.02.16.51.13;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.23.17.44.52;	author fnf;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.04.15.53.05;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.21.07.45.37;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.15.11.47.47;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.22.16.14.41;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.21.11.21.29;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.31.23.13.17;	author bje;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.04.11.30.54;	author amodra;	state Exp;
branches
	1.41.8.1;
next	1.40;

1.40
date	2003.10.20.14.38.39;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.16.04.11.05;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.01.13.08.05;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.25.20.55.57;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.25.03.19.29;	author danglin;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.34.10.1
	1.34.12.1;
next	1.33;

1.33
date	2002.06.25.06.21.48;	author amodra;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.25.15.13.52;	author nickc;	state Exp;
branches
	1.31.8.1
	1.31.10.1;
next	1.30;

1.30
date	2001.11.19.15.35.38;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.02.16.29.15;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.02.15.47.24;	author hjl;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.17.08.57.42;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.15.09.03.13;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.24.20.50.50;	author trix;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.07.23.50.04;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.23.11.45.52;	author kazu;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.08.18.34.31;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.28.01.33.15;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.16.20.35.08;	author nsd;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.26.15.09.43;	author cpopetz;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.07.00.58.06;	author twall;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.09.13.41.44;	author twall;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.13.22.10.36;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.09.11.15.16.14;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.09.11.14.41.11;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.09.07.04.28.27;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.09.07.02.11.54;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.18.05.59.47;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.08.09.04.04.17;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.19.49.27;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.05.41;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.78.4.1
date	2011.05.29.04.51.02;	author amodra;	state Exp;
branches;
next	;

1.74.2.1
date	2009.09.05.08.00.19;	author nickc;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;

1.64.2.1
date	2007.08.13.01.45.25;	author drow;	state Exp;
branches;
next	;

1.41.8.1
date	2004.09.16.17.00.14;	author drow;	state Exp;
branches;
next	;

1.34.10.1
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.34.10.2;

1.34.10.2
date	2002.12.23.19.37.30;	author carlton;	state Exp;
branches;
next	1.34.10.3;

1.34.10.3
date	2003.04.16.19.56.41;	author carlton;	state Exp;
branches;
next	1.34.10.4;

1.34.10.4
date	2003.11.11.23.50.09;	author carlton;	state Exp;
branches;
next	;

1.34.12.1
date	2003.12.14.20.26.35;	author drow;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.23.22.12.38;	author drow;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2002.10.28.18.45.43;	author drow;	state Exp;
branches;
next	;

1.31.8.1
date	2002.06.15.16.42.35;	author cagney;	state Exp;
branches;
next	;

1.31.10.1
date	2002.06.20.01.29.47;	author kseitz;	state Exp;
branches;
next	1.31.10.2;

1.31.10.2
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	1.31.10.3;

1.31.10.3
date	2002.08.09.18.34.10;	author kseitz;	state Exp;
branches;
next	1.31.10.4;

1.31.10.4
date	2002.11.03.22.01.34;	author ezannoni;	state Exp;
branches;
next	;

1.18.2.1
date	2001.02.07.23.51.04;	author nickc;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.87
log
@	* coffgen.c (coff_real_object_p): Make global.
	* peicode.h (coff_real_object_p): Add prototype.
	(FILHDR): Defined for COFF_IMAGE_WITH_PE as
	external_PEI_IMAGE_hdr structure.
	(coff_swap_filehdr_in): Handle variable header-size.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_in): Just handle amount
	of directory-entiries as specified in pe-header.
@
text
@/* Support for the generic parts of COFF, for BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* Most of this hacked by  Steve Chamberlain, sac@@cygnus.com.
   Split out of coffcode.h by Ian Taylor, ian@@cygnus.com.  */

/* This file contains COFF code that is not dependent on any
   particular COFF target.  There is only one version of this file in
   libbfd.a, so no target specific code may be put in here.  Or, to
   put it another way,

   ********** DO NOT PUT TARGET SPECIFIC CODE IN THIS FILE **********

   If you need to add some target specific behaviour, add a new hook
   function to bfd_coff_backend_data.

   Some of these functions are also called by the ECOFF routines.
   Those functions may not use any COFF specific information, such as
   coff_data (abfd).  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "libcoff.h"

/* Take a section header read from a coff file (in HOST byte order),
   and make a BFD "section" out of it.  This is used by ECOFF.  */

static bfd_boolean
make_a_section_from_file (bfd *abfd,
			  struct internal_scnhdr *hdr,
			  unsigned int target_index)
{
  asection *return_section;
  char *name;
  bfd_boolean result = TRUE;
  flagword flags;

  name = NULL;

  /* Handle long section names as in PE.  On reading, we want to
    accept long names if the format permits them at all, regardless
    of the current state of the flag that dictates if we would generate
    them in outputs; this construct checks if that is the case by
    attempting to set the flag, without changing its state; the call
    will fail for formats that do not support long names at all.  */
  if (bfd_coff_set_long_section_names (abfd, bfd_coff_long_section_names (abfd))
      && hdr->s_name[0] == '/')
    {
      char buf[SCNNMLEN];
      long strindex;
      char *p;
      const char *strings;

      /* Flag that this BFD uses long names, even though the format might
         expect them to be off by default.  This won't directly affect the
         format of any output BFD created from this one, but the information
         can be used to decide what to do.  */
      bfd_coff_set_long_section_names (abfd, TRUE);
      memcpy (buf, hdr->s_name + 1, SCNNMLEN - 1);
      buf[SCNNMLEN - 1] = '\0';
      strindex = strtol (buf, &p, 10);
      if (*p == '\0' && strindex >= 0)
	{
	  strings = _bfd_coff_read_string_table (abfd);
	  if (strings == NULL)
	    return FALSE;
	  /* FIXME: For extra safety, we should make sure that
             strindex does not run us past the end, but right now we
             don't know the length of the string table.  */
	  strings += strindex;
	  name = (char *) bfd_alloc (abfd,
                                     (bfd_size_type) strlen (strings) + 1 + 1);
	  if (name == NULL)
	    return FALSE;
	  strcpy (name, strings);
	}
    }

  if (name == NULL)
    {
      /* Assorted wastage to null-terminate the name, thanks AT&T! */
      name = (char *) bfd_alloc (abfd,
                                 (bfd_size_type) sizeof (hdr->s_name) + 1 + 1);
      if (name == NULL)
	return FALSE;
      strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
      name[sizeof (hdr->s_name)] = 0;
    }

  return_section = bfd_make_section_anyway (abfd, name);
  if (return_section == NULL)
    return FALSE;

  return_section->vma = hdr->s_vaddr;
  return_section->lma = hdr->s_paddr;
  return_section->size = hdr->s_size;
  return_section->filepos = hdr->s_scnptr;
  return_section->rel_filepos = hdr->s_relptr;
  return_section->reloc_count = hdr->s_nreloc;

  bfd_coff_set_alignment_hook (abfd, return_section, hdr);

  return_section->line_filepos = hdr->s_lnnoptr;

  return_section->lineno_count = hdr->s_nlnno;
  return_section->userdata = NULL;
  return_section->next = NULL;
  return_section->target_index = target_index;

  if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,
					 & flags))
    result = FALSE;

  return_section->flags = flags;

  /* At least on i386-coff, the line number count for a shared library
     section must be ignored.  */
  if ((return_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
    return_section->lineno_count = 0;

  if (hdr->s_nreloc != 0)
    return_section->flags |= SEC_RELOC;
  /* FIXME: should this check 'hdr->s_size > 0'.  */
  if (hdr->s_scnptr != 0)
    return_section->flags |= SEC_HAS_CONTENTS;

  /* Compress/decompress DWARF debug sections with names: .debug_* and
     .zdebug_*, after the section flags is set.  */
  if ((flags & SEC_DEBUGGING)
      && ((name[1] == 'd' && name[6] == '_')
	  || (name[1] == 'z' && name[7] == '_')))
    {
      enum { nothing, compress, decompress } action = nothing;
      char *new_name = NULL;

      if (bfd_is_section_compressed (abfd, return_section))
	{
	  /* Compressed section.  Check if we should decompress.  */
	  if ((abfd->flags & BFD_DECOMPRESS))
	    action = decompress;
	}
      else if (!bfd_is_section_compressed (abfd, return_section))
	{
	  /* Normal section.  Check if we should compress.  */
	  if ((abfd->flags & BFD_COMPRESS) && return_section->size != 0)
	    action = compress;
	}

      switch (action)
	{
	case nothing:
	  break;
	case compress:
	  if (!bfd_init_section_compress_status (abfd, return_section))
	    {
	      (*_bfd_error_handler)
		(_("%B: unable to initialize compress status for section %s"),
		 abfd, name);
	      return FALSE;
	    }
	  if (name[1] != 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len + 2);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      new_name[1] = 'z';
	      memcpy (new_name + 2, name + 1, len);
	    }
	  break;
	case decompress:
	  if (!bfd_init_section_decompress_status (abfd, return_section))
	    {
	      (*_bfd_error_handler)
		(_("%B: unable to initialize decompress status for section %s"),
		 abfd, name);
	      return FALSE;
	    }
	  if (name[1] == 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      memcpy (new_name + 1, name + 2, len - 1);
	    }
	  break;
	}
      if (new_name != NULL)
	bfd_rename_section (abfd, return_section, new_name);
    }

  return result;
}

/* Read in a COFF object and make it into a BFD.  This is used by
   ECOFF as well.  */
const bfd_target *
coff_real_object_p (bfd *,
                    unsigned,
                    struct internal_filehdr *,
                    struct internal_aouthdr *);
const bfd_target *
coff_real_object_p (bfd *abfd,
		    unsigned nscns,
		    struct internal_filehdr *internal_f,
		    struct internal_aouthdr *internal_a)
{
  flagword oflags = abfd->flags;
  bfd_vma ostart = bfd_get_start_address (abfd);
  void * tdata;
  void * tdata_save;
  bfd_size_type readsize;	/* Length of file_info.  */
  unsigned int scnhsz;
  char *external_sections;

  if (!(internal_f->f_flags & F_RELFLG))
    abfd->flags |= HAS_RELOC;
  if ((internal_f->f_flags & F_EXEC))
    abfd->flags |= EXEC_P;
  if (!(internal_f->f_flags & F_LNNO))
    abfd->flags |= HAS_LINENO;
  if (!(internal_f->f_flags & F_LSYMS))
    abfd->flags |= HAS_LOCALS;

  /* FIXME: How can we set D_PAGED correctly?  */
  if ((internal_f->f_flags & F_EXEC) != 0)
    abfd->flags |= D_PAGED;

  bfd_get_symcount (abfd) = internal_f->f_nsyms;
  if (internal_f->f_nsyms)
    abfd->flags |= HAS_SYMS;

  if (internal_a != (struct internal_aouthdr *) NULL)
    bfd_get_start_address (abfd) = internal_a->entry;
  else
    bfd_get_start_address (abfd) = 0;

  /* Set up the tdata area.  ECOFF uses its own routine, and overrides
     abfd->flags.  */
  tdata_save = abfd->tdata.any;
  tdata = bfd_coff_mkobject_hook (abfd, (void *) internal_f, (void *) internal_a);
  if (tdata == NULL)
    goto fail2;

  scnhsz = bfd_coff_scnhsz (abfd);
  readsize = (bfd_size_type) nscns * scnhsz;
  external_sections = (char *) bfd_alloc (abfd, readsize);
  if (!external_sections)
    goto fail;

  if (bfd_bread ((void *) external_sections, readsize, abfd) != readsize)
    goto fail;

  /* Set the arch/mach *before* swapping in sections; section header swapping
     may depend on arch/mach info.  */
  if (! bfd_coff_set_arch_mach_hook (abfd, (void *) internal_f))
    goto fail;

  /* Now copy data as required; construct all asections etc.  */
  if (nscns != 0)
    {
      unsigned int i;
      for (i = 0; i < nscns; i++)
	{
	  struct internal_scnhdr tmp;
	  bfd_coff_swap_scnhdr_in (abfd,
				   (void *) (external_sections + i * scnhsz),
				   (void *) & tmp);
	  if (! make_a_section_from_file (abfd, &tmp, i + 1))
	    goto fail;
	}
    }

  return abfd->xvec;

 fail:
  bfd_release (abfd, tdata);
 fail2:
  abfd->tdata.any = tdata_save;
  abfd->flags = oflags;
  bfd_get_start_address (abfd) = ostart;
  return (const bfd_target *) NULL;
}

/* Turn a COFF file into a BFD, but fail with bfd_error_wrong_format if it is
   not a COFF file.  This is also used by ECOFF.  */

const bfd_target *
coff_object_p (bfd *abfd)
{
  bfd_size_type filhsz;
  bfd_size_type aoutsz;
  unsigned int nscns;
  void * filehdr;
  struct internal_filehdr internal_f;
  struct internal_aouthdr internal_a;

  /* Figure out how much to read.  */
  filhsz = bfd_coff_filhsz (abfd);
  aoutsz = bfd_coff_aoutsz (abfd);

  filehdr = bfd_alloc (abfd, filhsz);
  if (filehdr == NULL)
    return NULL;
  if (bfd_bread (filehdr, filhsz, abfd) != filhsz)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      bfd_release (abfd, filehdr);
      return NULL;
    }
  bfd_coff_swap_filehdr_in (abfd, filehdr, &internal_f);
  bfd_release (abfd, filehdr);

  /* The XCOFF format has two sizes for the f_opthdr.  SMALL_AOUTSZ
     (less than aoutsz) used in object files and AOUTSZ (equal to
     aoutsz) in executables.  The bfd_coff_swap_aouthdr_in function
     expects this header to be aoutsz bytes in length, so we use that
     value in the call to bfd_alloc below.  But we must be careful to
     only read in f_opthdr bytes in the call to bfd_bread.  We should
     also attempt to catch corrupt or non-COFF binaries with a strange
     value for f_opthdr.  */
  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
      || internal_f.f_opthdr > aoutsz)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  nscns = internal_f.f_nscns;

  if (internal_f.f_opthdr)
    {
      void * opthdr;

      opthdr = bfd_alloc (abfd, aoutsz);
      if (opthdr == NULL)
	return NULL;
      if (bfd_bread (opthdr, (bfd_size_type) internal_f.f_opthdr, abfd)
	  != internal_f.f_opthdr)
	{
	  bfd_release (abfd, opthdr);
	  return NULL;
	}
      bfd_coff_swap_aouthdr_in (abfd, opthdr, (void *) &internal_a);
      bfd_release (abfd, opthdr);
    }

  return coff_real_object_p (abfd, nscns, &internal_f,
			     (internal_f.f_opthdr != 0
			      ? &internal_a
			      : (struct internal_aouthdr *) NULL));
}

/* Get the BFD section from a COFF symbol section number.  */

asection *
coff_section_from_bfd_index (bfd *abfd, int section_index)
{
  struct bfd_section *answer = abfd->sections;

  if (section_index == N_ABS)
    return bfd_abs_section_ptr;
  if (section_index == N_UNDEF)
    return bfd_und_section_ptr;
  if (section_index == N_DEBUG)
    return bfd_abs_section_ptr;

  while (answer)
    {
      if (answer->target_index == section_index)
	return answer;
      answer = answer->next;
    }

  /* We should not reach this point, but the SCO 3.2v4 /lib/libc_s.a
     has a bad symbol table in biglitpow.o.  */
  return bfd_und_section_ptr;
}

/* Get the upper bound of a COFF symbol table.  */

long
coff_get_symtab_upper_bound (bfd *abfd)
{
  if (!bfd_coff_slurp_symbol_table (abfd))
    return -1;

  return (bfd_get_symcount (abfd) + 1) * (sizeof (coff_symbol_type *));
}

/* Canonicalize a COFF symbol table.  */

long
coff_canonicalize_symtab (bfd *abfd, asymbol **alocation)
{
  unsigned int counter;
  coff_symbol_type *symbase;
  coff_symbol_type **location = (coff_symbol_type **) alocation;

  if (!bfd_coff_slurp_symbol_table (abfd))
    return -1;

  symbase = obj_symbols (abfd);
  counter = bfd_get_symcount (abfd);
  while (counter-- > 0)
    *location++ = symbase++;

  *location = NULL;

  return bfd_get_symcount (abfd);
}

/* Get the name of a symbol.  The caller must pass in a buffer of size
   >= SYMNMLEN + 1.  */

const char *
_bfd_coff_internal_syment_name (bfd *abfd,
				const struct internal_syment *sym,
				char *buf)
{
  /* FIXME: It's not clear this will work correctly if sizeof
     (_n_zeroes) != 4.  */
  if (sym->_n._n_n._n_zeroes != 0
      || sym->_n._n_n._n_offset == 0)
    {
      memcpy (buf, sym->_n._n_name, SYMNMLEN);
      buf[SYMNMLEN] = '\0';
      return buf;
    }
  else
    {
      const char *strings;

      BFD_ASSERT (sym->_n._n_n._n_offset >= STRING_SIZE_SIZE);
      strings = obj_coff_strings (abfd);
      if (strings == NULL)
	{
	  strings = _bfd_coff_read_string_table (abfd);
	  if (strings == NULL)
	    return NULL;
	}
      return strings + sym->_n._n_n._n_offset;
    }
}

/* Read in and swap the relocs.  This returns a buffer holding the
   relocs for section SEC in file ABFD.  If CACHE is TRUE and
   INTERNAL_RELOCS is NULL, the relocs read in will be saved in case
   the function is called again.  If EXTERNAL_RELOCS is not NULL, it
   is a buffer large enough to hold the unswapped relocs.  If
   INTERNAL_RELOCS is not NULL, it is a buffer large enough to hold
   the swapped relocs.  If REQUIRE_INTERNAL is TRUE, then the return
   value must be INTERNAL_RELOCS.  The function returns NULL on error.  */

struct internal_reloc *
_bfd_coff_read_internal_relocs (bfd *abfd,
				asection *sec,
				bfd_boolean cache,
				bfd_byte *external_relocs,
				bfd_boolean require_internal,
				struct internal_reloc *internal_relocs)
{
  bfd_size_type relsz;
  bfd_byte *free_external = NULL;
  struct internal_reloc *free_internal = NULL;
  bfd_byte *erel;
  bfd_byte *erel_end;
  struct internal_reloc *irel;
  bfd_size_type amt;

  if (sec->reloc_count == 0)
    return internal_relocs;	/* Nothing to do.  */

  if (coff_section_data (abfd, sec) != NULL
      && coff_section_data (abfd, sec)->relocs != NULL)
    {
      if (! require_internal)
	return coff_section_data (abfd, sec)->relocs;
      memcpy (internal_relocs, coff_section_data (abfd, sec)->relocs,
	      sec->reloc_count * sizeof (struct internal_reloc));
      return internal_relocs;
    }

  relsz = bfd_coff_relsz (abfd);

  amt = sec->reloc_count * relsz;
  if (external_relocs == NULL)
    {
      free_external = (bfd_byte *) bfd_malloc (amt);
      if (free_external == NULL)
	goto error_return;
      external_relocs = free_external;
    }

  if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
      || bfd_bread (external_relocs, amt, abfd) != amt)
    goto error_return;

  if (internal_relocs == NULL)
    {
      amt = sec->reloc_count;
      amt *= sizeof (struct internal_reloc);
      free_internal = (struct internal_reloc *) bfd_malloc (amt);
      if (free_internal == NULL)
	goto error_return;
      internal_relocs = free_internal;
    }

  /* Swap in the relocs.  */
  erel = external_relocs;
  erel_end = erel + relsz * sec->reloc_count;
  irel = internal_relocs;
  for (; erel < erel_end; erel += relsz, irel++)
    bfd_coff_swap_reloc_in (abfd, (void *) erel, (void *) irel);

  if (free_external != NULL)
    {
      free (free_external);
      free_external = NULL;
    }

  if (cache && free_internal != NULL)
    {
      if (coff_section_data (abfd, sec) == NULL)
	{
	  amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = bfd_zalloc (abfd, amt);
	  if (sec->used_by_bfd == NULL)
	    goto error_return;
	  coff_section_data (abfd, sec)->contents = NULL;
	}
      coff_section_data (abfd, sec)->relocs = free_internal;
    }

  return internal_relocs;

 error_return:
  if (free_external != NULL)
    free (free_external);
  if (free_internal != NULL)
    free (free_internal);
  return NULL;
}

/* Set lineno_count for the output sections of a COFF file.  */

int
coff_count_linenumbers (bfd *abfd)
{
  unsigned int limit = bfd_get_symcount (abfd);
  unsigned int i;
  int total = 0;
  asymbol **p;
  asection *s;

  if (limit == 0)
    {
      /* This may be from the backend linker, in which case the
         lineno_count in the sections is correct.  */
      for (s = abfd->sections; s != NULL; s = s->next)
	total += s->lineno_count;
      return total;
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    BFD_ASSERT (s->lineno_count == 0);

  for (p = abfd->outsymbols, i = 0; i < limit; i++, p++)
    {
      asymbol *q_maybe = *p;

      if (bfd_family_coff (bfd_asymbol_bfd (q_maybe)))
	{
	  coff_symbol_type *q = coffsymbol (q_maybe);

	  /* The AIX 4.1 compiler can sometimes generate line numbers
             attached to debugging symbols.  We try to simply ignore
             those here.  */
	  if (q->lineno != NULL
	      && q->symbol.section->owner != NULL)
	    {
	      /* This symbol has line numbers.  Increment the owning
	         section's linenumber count.  */
	      alent *l = q->lineno;

	      do
		{
		  asection * sec = q->symbol.section->output_section;

		  /* Do not try to update fields in read-only sections.  */
		  if (! bfd_is_const_section (sec))
		    sec->lineno_count ++;

		  ++total;
		  ++l;
		}
	      while (l->line_number != 0);
	    }
	}
    }

  return total;
}

/* Takes a bfd and a symbol, returns a pointer to the coff specific
   area of the symbol if there is one.  */

coff_symbol_type *
coff_symbol_from (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		  asymbol *symbol)
{
  if (!bfd_family_coff (bfd_asymbol_bfd (symbol)))
    return (coff_symbol_type *) NULL;

  if (bfd_asymbol_bfd (symbol)->tdata.coff_obj_data == (coff_data_type *) NULL)
    return (coff_symbol_type *) NULL;

  return (coff_symbol_type *) symbol;
}

static void
fixup_symbol_value (bfd *abfd,
		    coff_symbol_type *coff_symbol_ptr,
		    struct internal_syment *syment)
{
  /* Normalize the symbol flags.  */
  if (coff_symbol_ptr->symbol.section
      && bfd_is_com_section (coff_symbol_ptr->symbol.section))
    {
      /* A common symbol is undefined with a value.  */
      syment->n_scnum = N_UNDEF;
      syment->n_value = coff_symbol_ptr->symbol.value;
    }
  else if ((coff_symbol_ptr->symbol.flags & BSF_DEBUGGING) != 0
	   && (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING_RELOC) == 0)
    {
      syment->n_value = coff_symbol_ptr->symbol.value;
    }
  else if (bfd_is_und_section (coff_symbol_ptr->symbol.section))
    {
      syment->n_scnum = N_UNDEF;
      syment->n_value = 0;
    }
  /* FIXME: Do we need to handle the absolute section here?  */
  else
    {
      if (coff_symbol_ptr->symbol.section)
	{
	  syment->n_scnum =
	    coff_symbol_ptr->symbol.section->output_section->target_index;

	  syment->n_value = (coff_symbol_ptr->symbol.value
			     + coff_symbol_ptr->symbol.section->output_offset);
	  if (! obj_pe (abfd))
            {
              syment->n_value += (syment->n_sclass == C_STATLAB)
                ? coff_symbol_ptr->symbol.section->output_section->lma
                : coff_symbol_ptr->symbol.section->output_section->vma;
            }
	}
      else
	{
	  BFD_ASSERT (0);
	  /* This can happen, but I don't know why yet (steve@@cygnus.com) */
	  syment->n_scnum = N_ABS;
	  syment->n_value = coff_symbol_ptr->symbol.value;
	}
    }
}

/* Run through all the symbols in the symbol table and work out what
   their indexes into the symbol table will be when output.

   Coff requires that each C_FILE symbol points to the next one in the
   chain, and that the last one points to the first external symbol. We
   do that here too.  */

bfd_boolean
coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)
{
  unsigned int symbol_count = bfd_get_symcount (bfd_ptr);
  asymbol **symbol_ptr_ptr = bfd_ptr->outsymbols;
  unsigned int native_index = 0;
  struct internal_syment *last_file = NULL;
  unsigned int symbol_index;

  /* COFF demands that undefined symbols come after all other symbols.
     Since we don't need to impose this extra knowledge on all our
     client programs, deal with that here.  Sort the symbol table;
     just move the undefined symbols to the end, leaving the rest
     alone.  The O'Reilly book says that defined global symbols come
     at the end before the undefined symbols, so we do that here as
     well.  */
  /* @@@@ Do we have some condition we could test for, so we don't always
     have to do this?  I don't think relocatability is quite right, but
     I'm not certain.  [raeburn:19920508.1711EST]  */
  {
    asymbol **newsyms;
    unsigned int i;
    bfd_size_type amt;

    amt = sizeof (asymbol *) * ((bfd_size_type) symbol_count + 1);
    newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);
    if (!newsyms)
      return FALSE;
    bfd_ptr->outsymbols = newsyms;
    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) != 0
	  || (!bfd_is_und_section (symbol_ptr_ptr[i]->section)
	      && !bfd_is_com_section (symbol_ptr_ptr[i]->section)
	      && ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) != 0
		  || ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      == 0))))
	*newsyms++ = symbol_ptr_ptr[i];

    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) == 0
	  && !bfd_is_und_section (symbol_ptr_ptr[i]->section)
	  && (bfd_is_com_section (symbol_ptr_ptr[i]->section)
	      || ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) == 0
		  && ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      != 0))))
	*newsyms++ = symbol_ptr_ptr[i];

    *first_undef = newsyms - bfd_ptr->outsymbols;

    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) == 0
	  && bfd_is_und_section (symbol_ptr_ptr[i]->section))
	*newsyms++ = symbol_ptr_ptr[i];
    *newsyms = (asymbol *) NULL;
    symbol_ptr_ptr = bfd_ptr->outsymbols;
  }

  for (symbol_index = 0; symbol_index < symbol_count; symbol_index++)
    {
      coff_symbol_type *coff_symbol_ptr = coff_symbol_from (bfd_ptr, symbol_ptr_ptr[symbol_index]);
      symbol_ptr_ptr[symbol_index]->udata.i = symbol_index;
      if (coff_symbol_ptr && coff_symbol_ptr->native)
	{
	  combined_entry_type *s = coff_symbol_ptr->native;
	  int i;

	  if (s->u.syment.n_sclass == C_FILE)
	    {
	      if (last_file != NULL)
		last_file->n_value = native_index;
	      last_file = &(s->u.syment);
	    }
	  else
	    /* Modify the symbol values according to their section and
	       type.  */
	    fixup_symbol_value (bfd_ptr, coff_symbol_ptr, &(s->u.syment));

	  for (i = 0; i < s->u.syment.n_numaux + 1; i++)
	    s[i].offset = native_index++;
	}
      else
	native_index++;
    }

  obj_conv_table_size (bfd_ptr) = native_index;

  return TRUE;
}

/* Run thorough the symbol table again, and fix it so that all
   pointers to entries are changed to the entries' index in the output
   symbol table.  */

void
coff_mangle_symbols (bfd *bfd_ptr)
{
  unsigned int symbol_count = bfd_get_symcount (bfd_ptr);
  asymbol **symbol_ptr_ptr = bfd_ptr->outsymbols;
  unsigned int symbol_index;

  for (symbol_index = 0; symbol_index < symbol_count; symbol_index++)
    {
      coff_symbol_type *coff_symbol_ptr =
      coff_symbol_from (bfd_ptr, symbol_ptr_ptr[symbol_index]);

      if (coff_symbol_ptr && coff_symbol_ptr->native)
	{
	  int i;
	  combined_entry_type *s = coff_symbol_ptr->native;

	  if (s->fix_value)
	    {
	      /* FIXME: We should use a union here.  */
	      s->u.syment.n_value =
		(bfd_hostptr_t) ((combined_entry_type *)
			  ((bfd_hostptr_t) s->u.syment.n_value))->offset;
	      s->fix_value = 0;
	    }
	  if (s->fix_line)
	    {
	      /* The value is the offset into the line number entries
                 for the symbol's section.  On output, the symbol's
                 section should be N_DEBUG.  */
	      s->u.syment.n_value =
		(coff_symbol_ptr->symbol.section->output_section->line_filepos
		 + s->u.syment.n_value * bfd_coff_linesz (bfd_ptr));
	      coff_symbol_ptr->symbol.section =
		coff_section_from_bfd_index (bfd_ptr, N_DEBUG);
	      BFD_ASSERT (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING);
	    }
	  for (i = 0; i < s->u.syment.n_numaux; i++)
	    {
	      combined_entry_type *a = s + i + 1;
	      if (a->fix_tag)
		{
		  a->u.auxent.x_sym.x_tagndx.l =
		    a->u.auxent.x_sym.x_tagndx.p->offset;
		  a->fix_tag = 0;
		}
	      if (a->fix_end)
		{
		  a->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l =
		    a->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p->offset;
		  a->fix_end = 0;
		}
	      if (a->fix_scnlen)
		{
		  a->u.auxent.x_csect.x_scnlen.l =
		    a->u.auxent.x_csect.x_scnlen.p->offset;
		  a->fix_scnlen = 0;
		}
	    }
	}
    }
}

static void
coff_fix_symbol_name (bfd *abfd,
		      asymbol *symbol,
		      combined_entry_type *native,
		      bfd_size_type *string_size_p,
		      asection **debug_string_section_p,
		      bfd_size_type *debug_string_size_p)
{
  unsigned int name_length;
  union internal_auxent *auxent;
  char *name = (char *) (symbol->name);

  if (name == NULL)
    {
      /* COFF symbols always have names, so we'll make one up.  */
      symbol->name = "strange";
      name = (char *) symbol->name;
    }
  name_length = strlen (name);

  if (native->u.syment.n_sclass == C_FILE
      && native->u.syment.n_numaux > 0)
    {
      unsigned int filnmlen;

      if (bfd_coff_force_symnames_in_strings (abfd))
	{
          native->u.syment._n._n_n._n_offset =
	      (*string_size_p + STRING_SIZE_SIZE);
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *string_size_p += 6;  /* strlen(".file") + 1 */
	}
      else
  	strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);

      auxent = &(native + 1)->u.auxent;

      filnmlen = bfd_coff_filnmlen (abfd);

      if (bfd_coff_long_filenames (abfd))
	{
	  if (name_length <= filnmlen)
	    strncpy (auxent->x_file.x_fname, name, filnmlen);
	  else
	    {
	      auxent->x_file.x_n.x_offset = *string_size_p + STRING_SIZE_SIZE;
	      auxent->x_file.x_n.x_zeroes = 0;
	      *string_size_p += name_length + 1;
	    }
	}
      else
	{
	  strncpy (auxent->x_file.x_fname, name, filnmlen);
	  if (name_length > filnmlen)
	    name[filnmlen] = '\0';
	}
    }
  else
    {
      if (name_length <= SYMNMLEN && !bfd_coff_force_symnames_in_strings (abfd))
	/* This name will fit into the symbol neatly.  */
	strncpy (native->u.syment._n._n_name, symbol->name, SYMNMLEN);

      else if (!bfd_coff_symname_in_debug (abfd, &native->u.syment))
	{
	  native->u.syment._n._n_n._n_offset = (*string_size_p
						+ STRING_SIZE_SIZE);
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *string_size_p += name_length + 1;
	}
      else
	{
	  file_ptr filepos;
	  bfd_byte buf[4];
	  int prefix_len = bfd_coff_debug_string_prefix_length (abfd);

	  /* This name should be written into the .debug section.  For
	     some reason each name is preceded by a two byte length
	     and also followed by a null byte.  FIXME: We assume that
	     the .debug section has already been created, and that it
	     is large enough.  */
	  if (*debug_string_section_p == (asection *) NULL)
	    *debug_string_section_p = bfd_get_section_by_name (abfd, ".debug");
	  filepos = bfd_tell (abfd);
	  if (prefix_len == 4)
	    bfd_put_32 (abfd, (bfd_vma) (name_length + 1), buf);
	  else
	    bfd_put_16 (abfd, (bfd_vma) (name_length + 1), buf);

	  if (!bfd_set_section_contents (abfd,
					 *debug_string_section_p,
					 (void *) buf,
					 (file_ptr) *debug_string_size_p,
					 (bfd_size_type) prefix_len)
	      || !bfd_set_section_contents (abfd,
					    *debug_string_section_p,
					    (void *) symbol->name,
					    (file_ptr) (*debug_string_size_p
							+ prefix_len),
					    (bfd_size_type) name_length + 1))
	    abort ();
	  if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
	    abort ();
	  native->u.syment._n._n_n._n_offset =
	      *debug_string_size_p + prefix_len;
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *debug_string_size_p += name_length + 1 + prefix_len;
	}
    }
}

/* We need to keep track of the symbol index so that when we write out
   the relocs we can get the index for a symbol.  This method is a
   hack.  FIXME.  */

#define set_index(symbol, idx)	((symbol)->udata.i = (idx))

/* Write a symbol out to a COFF file.  */

static bfd_boolean
coff_write_symbol (bfd *abfd,
		   asymbol *symbol,
		   combined_entry_type *native,
		   bfd_vma *written,
		   bfd_size_type *string_size_p,
		   asection **debug_string_section_p,
		   bfd_size_type *debug_string_size_p)
{
  unsigned int numaux = native->u.syment.n_numaux;
  int type = native->u.syment.n_type;
  int n_sclass = (int) native->u.syment.n_sclass;
  asection *output_section = symbol->section->output_section
			       ? symbol->section->output_section
			       : symbol->section;
  void * buf;
  bfd_size_type symesz;

  if (native->u.syment.n_sclass == C_FILE)
    symbol->flags |= BSF_DEBUGGING;

  if (symbol->flags & BSF_DEBUGGING
      && bfd_is_abs_section (symbol->section))
    native->u.syment.n_scnum = N_DEBUG;

  else if (bfd_is_abs_section (symbol->section))
    native->u.syment.n_scnum = N_ABS;

  else if (bfd_is_und_section (symbol->section))
    native->u.syment.n_scnum = N_UNDEF;

  else
    native->u.syment.n_scnum =
      output_section->target_index;

  coff_fix_symbol_name (abfd, symbol, native, string_size_p,
			debug_string_section_p, debug_string_size_p);

  symesz = bfd_coff_symesz (abfd);
  buf = bfd_alloc (abfd, symesz);
  if (!buf)
    return FALSE;
  bfd_coff_swap_sym_out (abfd, &native->u.syment, buf);
  if (bfd_bwrite (buf, symesz, abfd) != symesz)
    return FALSE;
  bfd_release (abfd, buf);

  if (native->u.syment.n_numaux > 0)
    {
      bfd_size_type auxesz;
      unsigned int j;

      auxesz = bfd_coff_auxesz (abfd);
      buf = bfd_alloc (abfd, auxesz);
      if (!buf)
	return FALSE;
      for (j = 0; j < native->u.syment.n_numaux; j++)
	{
	  bfd_coff_swap_aux_out (abfd,
				 &((native + j + 1)->u.auxent),
				 type, n_sclass, (int) j,
				 native->u.syment.n_numaux,
				 buf);
	  if (bfd_bwrite (buf, auxesz, abfd) != auxesz)
	    return FALSE;
	}
      bfd_release (abfd, buf);
    }

  /* Store the index for use when we write out the relocs.  */
  set_index (symbol, *written);

  *written += numaux + 1;
  return TRUE;
}

/* Write out a symbol to a COFF file that does not come from a COFF
   file originally.  This symbol may have been created by the linker,
   or we may be linking a non COFF file to a COFF file.  */

bfd_boolean
coff_write_alien_symbol (bfd *abfd,
			 asymbol *symbol,
			 struct internal_syment *isym,
			 bfd_vma *written,
			 bfd_size_type *string_size_p,
			 asection **debug_string_section_p,
			 bfd_size_type *debug_string_size_p)
{
  combined_entry_type *native;
  combined_entry_type dummy[2];
  asection *output_section = symbol->section->output_section
			       ? symbol->section->output_section
			       : symbol->section;
  struct bfd_link_info *link_info = coff_data (abfd)->link_info;
  bfd_boolean ret;

  if ((!link_info || link_info->strip_discarded)
      && !bfd_is_abs_section (symbol->section)
      && symbol->section->output_section == bfd_abs_section_ptr)
    {
      symbol->name = "";
      if (isym != NULL)
        memset (isym, 0, sizeof(*isym));
      return TRUE;
    }
  native = dummy;
  native->u.syment.n_type = T_NULL;
  native->u.syment.n_flags = 0;
  native->u.syment.n_numaux = 0;
  if (bfd_is_und_section (symbol->section))
    {
      native->u.syment.n_scnum = N_UNDEF;
      native->u.syment.n_value = symbol->value;
    }
  else if (bfd_is_com_section (symbol->section))
    {
      native->u.syment.n_scnum = N_UNDEF;
      native->u.syment.n_value = symbol->value;
    }
  else if (symbol->flags & BSF_FILE)
    {
      native->u.syment.n_scnum = N_DEBUG;
      native->u.syment.n_numaux = 1;
    }
  else if (symbol->flags & BSF_DEBUGGING)
    {
      /* There isn't much point to writing out a debugging symbol
         unless we are prepared to convert it into COFF debugging
         format.  So, we just ignore them.  We must clobber the symbol
         name to keep it from being put in the string table.  */
      symbol->name = "";
      if (isym != NULL)
        memset (isym, 0, sizeof(*isym));
      return TRUE;
    }
  else
    {
      native->u.syment.n_scnum = output_section->target_index;
      native->u.syment.n_value = (symbol->value
				  + symbol->section->output_offset);
      if (! obj_pe (abfd))
	native->u.syment.n_value += output_section->vma;

      /* Copy the any flags from the file header into the symbol.
         FIXME: Why?  */
      {
	coff_symbol_type *c = coff_symbol_from (abfd, symbol);
	if (c != (coff_symbol_type *) NULL)
	  native->u.syment.n_flags = bfd_asymbol_bfd (&c->symbol)->flags;
      }
    }

  native->u.syment.n_type = 0;
  if (symbol->flags & BSF_FILE)
    native->u.syment.n_sclass = C_FILE;
  else if (symbol->flags & BSF_LOCAL)
    native->u.syment.n_sclass = C_STAT;
  else if (symbol->flags & BSF_WEAK)
    native->u.syment.n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
  else
    native->u.syment.n_sclass = C_EXT;

  ret = coff_write_symbol (abfd, symbol, native, written, string_size_p,
			   debug_string_section_p, debug_string_size_p);
  if (isym != NULL)
    *isym = native->u.syment;
  return ret;
}

/* Write a native symbol to a COFF file.  */

static bfd_boolean
coff_write_native_symbol (bfd *abfd,
			  coff_symbol_type *symbol,
			  bfd_vma *written,
			  bfd_size_type *string_size_p,
			  asection **debug_string_section_p,
			  bfd_size_type *debug_string_size_p)
{
  combined_entry_type *native = symbol->native;
  alent *lineno = symbol->lineno;
  struct bfd_link_info *link_info = coff_data (abfd)->link_info;

  if ((!link_info || link_info->strip_discarded)
      && !bfd_is_abs_section (symbol->symbol.section)
      && symbol->symbol.section->output_section == bfd_abs_section_ptr)
    {
      symbol->symbol.name = "";
      return TRUE;
    }

  /* If this symbol has an associated line number, we must store the
     symbol index in the line number field.  We also tag the auxent to
     point to the right place in the lineno table.  */
  if (lineno && !symbol->done_lineno && symbol->symbol.section->owner != NULL)
    {
      unsigned int count = 0;

      lineno[count].u.offset = *written;
      if (native->u.syment.n_numaux)
	{
	  union internal_auxent *a = &((native + 1)->u.auxent);

	  a->x_sym.x_fcnary.x_fcn.x_lnnoptr =
	    symbol->symbol.section->output_section->moving_line_filepos;
	}

      /* Count and relocate all other linenumbers.  */
      count++;
      while (lineno[count].line_number != 0)
	{
	  lineno[count].u.offset +=
	    (symbol->symbol.section->output_section->vma
	     + symbol->symbol.section->output_offset);
	  count++;
	}
      symbol->done_lineno = TRUE;

      if (! bfd_is_const_section (symbol->symbol.section->output_section))
	symbol->symbol.section->output_section->moving_line_filepos +=
	  count * bfd_coff_linesz (abfd);
    }

  return coff_write_symbol (abfd, &(symbol->symbol), native, written,
			    string_size_p, debug_string_section_p,
			    debug_string_size_p);
}

static void
null_error_handler (const char * fmt ATTRIBUTE_UNUSED, ...)
{
}

/* Write out the COFF symbols.  */

bfd_boolean
coff_write_symbols (bfd *abfd)
{
  bfd_size_type string_size;
  asection *debug_string_section;
  bfd_size_type debug_string_size;
  unsigned int i;
  unsigned int limit = bfd_get_symcount (abfd);
  bfd_vma written = 0;
  asymbol **p;

  string_size = 0;
  debug_string_section = NULL;
  debug_string_size = 0;

  /* If this target supports long section names, they must be put into
     the string table.  This is supported by PE.  This code must
     handle section names just as they are handled in
     coff_write_object_contents.  */
  if (bfd_coff_long_section_names (abfd))
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  size_t len;

	  len = strlen (o->name);
	  if (len > SCNNMLEN)
	    string_size += len + 1;
	}
    }

  /* Seek to the right place.  */
  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)
    return FALSE;

  /* Output all the symbols we have.  */
  written = 0;
  for (p = abfd->outsymbols, i = 0; i < limit; i++, p++)
    {
      asymbol *symbol = *p;
      coff_symbol_type *c_symbol = coff_symbol_from (abfd, symbol);

      if (c_symbol == (coff_symbol_type *) NULL
	  || c_symbol->native == (combined_entry_type *) NULL)
	{
	  if (!coff_write_alien_symbol (abfd, symbol, NULL, &written,
					&string_size, &debug_string_section,
					&debug_string_size))
	    return FALSE;
	}
      else
	{
	  if (coff_backend_info (abfd)->_bfd_coff_classify_symbol != NULL)
	    {
	      bfd_error_handler_type current_error_handler;
	      enum coff_symbol_classification sym_class;
	      unsigned char *n_sclass;

	      /* Suppress error reporting by bfd_coff_classify_symbol.
		 Error messages can be generated when we are processing a local
		 symbol which has no associated section and we do not have to
		 worry about this, all we need to know is that it is local.  */
	      current_error_handler = bfd_set_error_handler (null_error_handler);
	      sym_class = bfd_coff_classify_symbol (abfd,
                                                   &c_symbol->native->u.syment);
	      (void) bfd_set_error_handler (current_error_handler);

	      n_sclass = &c_symbol->native->u.syment.n_sclass;

	      /* If the symbol class has been changed (eg objcopy/ld script/etc)
		 we cannot retain the existing sclass from the original symbol.
		 Weak symbols only have one valid sclass, so just set it always.
		 If it is not local class and should be, set it C_STAT.
		 If it is global and not classified as global, or if it is
		 weak (which is also classified as global), set it C_EXT.  */

	      if (symbol->flags & BSF_WEAK)
		*n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
	      else if (symbol->flags & BSF_LOCAL && sym_class != COFF_SYMBOL_LOCAL)
		*n_sclass = C_STAT;
	      else if (symbol->flags & BSF_GLOBAL
		       && (sym_class != COFF_SYMBOL_GLOBAL
#ifdef COFF_WITH_PE
			   || *n_sclass == C_NT_WEAK
#endif
			   || *n_sclass == C_WEAKEXT))
		c_symbol->native->u.syment.n_sclass = C_EXT;
	    }

	  if (!coff_write_native_symbol (abfd, c_symbol, &written,
					 &string_size, &debug_string_section,
					 &debug_string_size))
	    return FALSE;
	}
    }

  obj_raw_syment_count (abfd) = written;

  /* Now write out strings.  */
  if (string_size != 0)
    {
      unsigned int size = string_size + STRING_SIZE_SIZE;
      bfd_byte buffer[STRING_SIZE_SIZE];

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd, size, buffer);
#else
 #error Change H_PUT_32
#endif
      if (bfd_bwrite ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd)
	  != sizeof (buffer))
	return FALSE;

      /* Handle long section names.  This code must handle section
	 names just as they are handled in coff_write_object_contents.  */
      if (bfd_coff_long_section_names (abfd))
	{
	  asection *o;

	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      size_t len;

	      len = strlen (o->name);
	      if (len > SCNNMLEN)
		{
		  if (bfd_bwrite (o->name, (bfd_size_type) (len + 1), abfd)
		      != len + 1)
		    return FALSE;
		}
	    }
	}

      for (p = abfd->outsymbols, i = 0;
	   i < limit;
	   i++, p++)
	{
	  asymbol *q = *p;
	  size_t name_length = strlen (q->name);
	  coff_symbol_type *c_symbol = coff_symbol_from (abfd, q);
	  size_t maxlen;

	  /* Figure out whether the symbol name should go in the string
	     table.  Symbol names that are short enough are stored
	     directly in the syment structure.  File names permit a
	     different, longer, length in the syment structure.  On
	     XCOFF, some symbol names are stored in the .debug section
	     rather than in the string table.  */

	  if (c_symbol == NULL
	      || c_symbol->native == NULL)
	    /* This is not a COFF symbol, so it certainly is not a
	       file name, nor does it go in the .debug section.  */
	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;

	  else if (bfd_coff_symname_in_debug (abfd,
					      &c_symbol->native->u.syment))
	    /* This symbol name is in the XCOFF .debug section.
	       Don't write it into the string table.  */
	    maxlen = name_length;

	  else if (c_symbol->native->u.syment.n_sclass == C_FILE
		   && c_symbol->native->u.syment.n_numaux > 0)
	    {
	      if (bfd_coff_force_symnames_in_strings (abfd))
		{
		  if (bfd_bwrite (".file", (bfd_size_type) 6, abfd) != 6)
		    return FALSE;
		}
	      maxlen = bfd_coff_filnmlen (abfd);
	    }
	  else
	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;

	  if (name_length > maxlen)
	    {
	      if (bfd_bwrite ((void *) (q->name), (bfd_size_type) name_length + 1,
			     abfd) != name_length + 1)
		return FALSE;
	    }
	}
    }
  else
    {
      /* We would normally not write anything here, but we'll write
         out 4 so that any stupid coff reader which tries to read the
         string table even when there isn't one won't croak.  */
      unsigned int size = STRING_SIZE_SIZE;
      bfd_byte buffer[STRING_SIZE_SIZE];

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd, size, buffer);
#else
 #error Change H_PUT_32
#endif
      if (bfd_bwrite ((void *) buffer, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;
    }

  /* Make sure the .debug section was created to be the correct size.
     We should create it ourselves on the fly, but we don't because
     BFD won't let us write to any section until we know how large all
     the sections are.  We could still do it by making another pass
     over the symbols.  FIXME.  */
  BFD_ASSERT (debug_string_size == 0
	      || (debug_string_section != (asection *) NULL
		  && (BFD_ALIGN (debug_string_size,
				 1 << debug_string_section->alignment_power)
		      == debug_string_section->size)));

  return TRUE;
}

bfd_boolean
coff_write_linenumbers (bfd *abfd)
{
  asection *s;
  bfd_size_type linesz;
  void * buff;

  linesz = bfd_coff_linesz (abfd);
  buff = bfd_alloc (abfd, linesz);
  if (!buff)
    return FALSE;
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (s->lineno_count)
	{
	  asymbol **q = abfd->outsymbols;
	  if (bfd_seek (abfd, s->line_filepos, SEEK_SET) != 0)
	    return FALSE;
	  /* Find all the linenumbers in this section.  */
	  while (*q)
	    {
	      asymbol *p = *q;
	      if (p->section->output_section == s)
		{
		  alent *l =
		  BFD_SEND (bfd_asymbol_bfd (p), _get_lineno,
			    (bfd_asymbol_bfd (p), p));
		  if (l)
		    {
		      /* Found a linenumber entry, output.  */
		      struct internal_lineno out;
		      memset ((void *) & out, 0, sizeof (out));
		      out.l_lnno = 0;
		      out.l_addr.l_symndx = l->u.offset;
		      bfd_coff_swap_lineno_out (abfd, &out, buff);
		      if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			  != linesz)
			return FALSE;
		      l++;
		      while (l->line_number)
			{
			  out.l_lnno = l->line_number;
			  out.l_addr.l_symndx = l->u.offset;
			  bfd_coff_swap_lineno_out (abfd, &out, buff);
			  if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			      != linesz)
			    return FALSE;
			  l++;
			}
		    }
		}
	      q++;
	    }
	}
    }
  bfd_release (abfd, buff);
  return TRUE;
}

alent *
coff_get_lineno (bfd *ignore_abfd ATTRIBUTE_UNUSED, asymbol *symbol)
{
  return coffsymbol (symbol)->lineno;
}

/* This function transforms the offsets into the symbol table into
   pointers to syments.  */

static void
coff_pointerize_aux (bfd *abfd,
		     combined_entry_type *table_base,
		     combined_entry_type *symbol,
		     unsigned int indaux,
		     combined_entry_type *auxent)
{
  unsigned int type = symbol->u.syment.n_type;
  unsigned int n_sclass = symbol->u.syment.n_sclass;

  if (coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
    {
      if ((*coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
	  (abfd, table_base, symbol, indaux, auxent))
	return;
    }

  /* Don't bother if this is a file or a section.  */
  if (n_sclass == C_STAT && type == T_NULL)
    return;
  if (n_sclass == C_FILE)
    return;

  /* Otherwise patch up.  */
#define N_TMASK coff_data  (abfd)->local_n_tmask
#define N_BTSHFT coff_data (abfd)->local_n_btshft

  if ((ISFCN (type) || ISTAG (n_sclass) || n_sclass == C_BLOCK
       || n_sclass == C_FCN)
      && auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l > 0)
    {
      auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p =
	table_base + auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
      auxent->fix_end = 1;
    }
  /* A negative tagndx is meaningless, but the SCO 3.2v4 cc can
     generate one, so we must be careful to ignore it.  */
  if (auxent->u.auxent.x_sym.x_tagndx.l > 0)
    {
      auxent->u.auxent.x_sym.x_tagndx.p =
	table_base + auxent->u.auxent.x_sym.x_tagndx.l;
      auxent->fix_tag = 1;
    }
}

/* Allocate space for the ".debug" section, and read it.
   We did not read the debug section until now, because
   we didn't want to go to the trouble until someone needed it.  */

static char *
build_debug_section (bfd *abfd)
{
  char *debug_section;
  file_ptr position;
  bfd_size_type sec_size;

  asection *sect = bfd_get_section_by_name (abfd, ".debug");

  if (!sect)
    {
      bfd_set_error (bfd_error_no_debug_section);
      return NULL;
    }

  sec_size = sect->size;
  debug_section = (char *) bfd_alloc (abfd, sec_size);
  if (debug_section == NULL)
    return NULL;

  /* Seek to the beginning of the `.debug' section and read it.
     Save the current position first; it is needed by our caller.
     Then read debug section and reset the file pointer.  */

  position = bfd_tell (abfd);
  if (bfd_seek (abfd, sect->filepos, SEEK_SET) != 0
      || bfd_bread (debug_section, sec_size, abfd) != sec_size
      || bfd_seek (abfd, position, SEEK_SET) != 0)
    return NULL;
  return debug_section;
}

/* Return a pointer to a malloc'd copy of 'name'.  'name' may not be
   \0-terminated, but will not exceed 'maxlen' characters.  The copy *will*
   be \0-terminated.  */

static char *
copy_name (bfd *abfd, char *name, size_t maxlen)
{
  size_t len;
  char *newname;

  for (len = 0; len < maxlen; ++len)
    if (name[len] == '\0')
      break;

  if ((newname = (char *) bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
    return NULL;

  strncpy (newname, name, len);
  newname[len] = '\0';
  return newname;
}

/* Read in the external symbols.  */

bfd_boolean
_bfd_coff_get_external_symbols (bfd *abfd)
{
  bfd_size_type symesz;
  bfd_size_type size;
  void * syms;

  if (obj_coff_external_syms (abfd) != NULL)
    return TRUE;

  symesz = bfd_coff_symesz (abfd);

  size = obj_raw_syment_count (abfd) * symesz;
  if (size == 0)
    return TRUE;

  syms = bfd_malloc (size);
  if (syms == NULL)
    return FALSE;

  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
      || bfd_bread (syms, size, abfd) != size)
    {
      if (syms != NULL)
	free (syms);
      return FALSE;
    }

  obj_coff_external_syms (abfd) = syms;

  return TRUE;
}

/* Read in the external strings.  The strings are not loaded until
   they are needed.  This is because we have no simple way of
   detecting a missing string table in an archive.  */

const char *
_bfd_coff_read_string_table (bfd *abfd)
{
  char extstrsize[STRING_SIZE_SIZE];
  bfd_size_type strsize;
  char *strings;
  file_ptr pos;

  if (obj_coff_strings (abfd) != NULL)
    return obj_coff_strings (abfd);

  if (obj_sym_filepos (abfd) == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      return NULL;
    }

  pos = obj_sym_filepos (abfd);
  pos += obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    return NULL;

  if (bfd_bread (extstrsize, (bfd_size_type) sizeof extstrsize, abfd)
      != sizeof extstrsize)
    {
      if (bfd_get_error () != bfd_error_file_truncated)
	return NULL;

      /* There is no string table.  */
      strsize = STRING_SIZE_SIZE;
    }
  else
    {
#if STRING_SIZE_SIZE == 4
      strsize = H_GET_32 (abfd, extstrsize);
#else
 #error Change H_GET_32
#endif
    }

  if (strsize < STRING_SIZE_SIZE)
    {
      (*_bfd_error_handler)
	(_("%B: bad string table size %lu"), abfd, (unsigned long) strsize);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  strings = (char *) bfd_malloc (strsize);
  if (strings == NULL)
    return NULL;

  if (bfd_bread (strings + STRING_SIZE_SIZE, strsize - STRING_SIZE_SIZE, abfd)
      != strsize - STRING_SIZE_SIZE)
    {
      free (strings);
      return NULL;
    }

  obj_coff_strings (abfd) = strings;

  return strings;
}

/* Free up the external symbols and strings read from a COFF file.  */

bfd_boolean
_bfd_coff_free_symbols (bfd *abfd)
{
  if (obj_coff_external_syms (abfd) != NULL
      && ! obj_coff_keep_syms (abfd))
    {
      free (obj_coff_external_syms (abfd));
      obj_coff_external_syms (abfd) = NULL;
    }
  if (obj_coff_strings (abfd) != NULL
      && ! obj_coff_keep_strings (abfd))
    {
      free (obj_coff_strings (abfd));
      obj_coff_strings (abfd) = NULL;
    }
  return TRUE;
}

/* Read a symbol table into freshly bfd_allocated memory, swap it, and
   knit the symbol names into a normalized form.  By normalized here I
   mean that all symbols have an n_offset pointer that points to a null-
   terminated string.  */

combined_entry_type *
coff_get_normalized_symtab (bfd *abfd)
{
  combined_entry_type *internal;
  combined_entry_type *internal_ptr;
  combined_entry_type *symbol_ptr;
  combined_entry_type *internal_end;
  size_t symesz;
  char *raw_src;
  char *raw_end;
  const char *string_table = NULL;
  char *debug_section = NULL;
  bfd_size_type size;

  if (obj_raw_syments (abfd) != NULL)
    return obj_raw_syments (abfd);

  size = obj_raw_syment_count (abfd) * sizeof (combined_entry_type);
  internal = (combined_entry_type *) bfd_zalloc (abfd, size);
  if (internal == NULL && size != 0)
    return NULL;
  internal_end = internal + obj_raw_syment_count (abfd);

  if (! _bfd_coff_get_external_symbols (abfd))
    return NULL;

  raw_src = (char *) obj_coff_external_syms (abfd);

  /* Mark the end of the symbols.  */
  symesz = bfd_coff_symesz (abfd);
  raw_end = (char *) raw_src + obj_raw_syment_count (abfd) * symesz;

  /* FIXME SOMEDAY.  A string table size of zero is very weird, but
     probably possible.  If one shows up, it will probably kill us.  */

  /* Swap all the raw entries.  */
  for (internal_ptr = internal;
       raw_src < raw_end;
       raw_src += symesz, internal_ptr++)
    {

      unsigned int i;
      bfd_coff_swap_sym_in (abfd, (void *) raw_src,
			    (void *) & internal_ptr->u.syment);
      symbol_ptr = internal_ptr;

      for (i = 0;
	   i < symbol_ptr->u.syment.n_numaux;
	   i++)
	{
	  internal_ptr++;
	  raw_src += symesz;
	  bfd_coff_swap_aux_in (abfd, (void *) raw_src,
				symbol_ptr->u.syment.n_type,
				symbol_ptr->u.syment.n_sclass,
				(int) i, symbol_ptr->u.syment.n_numaux,
				&(internal_ptr->u.auxent));
	  coff_pointerize_aux (abfd, internal, symbol_ptr, i,
			       internal_ptr);
	}
    }

  /* Free the raw symbols, but not the strings (if we have them).  */
  obj_coff_keep_strings (abfd) = TRUE;
  if (! _bfd_coff_free_symbols (abfd))
    return NULL;

  for (internal_ptr = internal; internal_ptr < internal_end;
       internal_ptr++)
    {
      if (internal_ptr->u.syment.n_sclass == C_FILE
	  && internal_ptr->u.syment.n_numaux > 0)
	{
	  /* Make a file symbol point to the name in the auxent, since
	     the text ".file" is redundant.  */
	  if ((internal_ptr + 1)->u.auxent.x_file.x_n.x_zeroes == 0)
	    {
	      /* The filename is a long one, point into the string table.  */
	      if (string_table == NULL)
		{
		  string_table = _bfd_coff_read_string_table (abfd);
		  if (string_table == NULL)
		    return NULL;
		}

	      internal_ptr->u.syment._n._n_n._n_offset =
		((bfd_hostptr_t)
		 (string_table
		  + (internal_ptr + 1)->u.auxent.x_file.x_n.x_offset));
	    }
	  else
	    {
	      /* Ordinary short filename, put into memory anyway.  The
                 Microsoft PE tools sometimes store a filename in
                 multiple AUX entries.  */
	      if (internal_ptr->u.syment.n_numaux > 1
		  && coff_data (abfd)->pe)
		internal_ptr->u.syment._n._n_n._n_offset =
		  ((bfd_hostptr_t)
		   copy_name (abfd,
			      (internal_ptr + 1)->u.auxent.x_file.x_fname,
			      internal_ptr->u.syment.n_numaux * symesz));
	      else
		internal_ptr->u.syment._n._n_n._n_offset =
		  ((bfd_hostptr_t)
		   copy_name (abfd,
			      (internal_ptr + 1)->u.auxent.x_file.x_fname,
			      (size_t) bfd_coff_filnmlen (abfd)));
	    }
	}
      else
	{
	  if (internal_ptr->u.syment._n._n_n._n_zeroes != 0)
	    {
	      /* This is a "short" name.  Make it long.  */
	      size_t i;
	      char *newstring;

	      /* Find the length of this string without walking into memory
	         that isn't ours.  */
	      for (i = 0; i < 8; ++i)
		if (internal_ptr->u.syment._n._n_name[i] == '\0')
		  break;

	      newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
	      if (newstring == NULL)
		return NULL;
	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i);
	      internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) newstring;
	      internal_ptr->u.syment._n._n_n._n_zeroes = 0;
	    }
	  else if (internal_ptr->u.syment._n._n_n._n_offset == 0)
	    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) "";
	  else if (!bfd_coff_symname_in_debug (abfd, &internal_ptr->u.syment))
	    {
	      /* Long name already.  Point symbol at the string in the
                 table.  */
	      if (string_table == NULL)
		{
		  string_table = _bfd_coff_read_string_table (abfd);
		  if (string_table == NULL)
		    return NULL;
		}
	      internal_ptr->u.syment._n._n_n._n_offset =
		((bfd_hostptr_t)
		 (string_table
		  + internal_ptr->u.syment._n._n_n._n_offset));
	    }
	  else
	    {
	      /* Long name in debug section.  Very similar.  */
	      if (debug_section == NULL)
		debug_section = build_debug_section (abfd);
	      internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t)
		(debug_section + internal_ptr->u.syment._n._n_n._n_offset);
	    }
	}
      internal_ptr += internal_ptr->u.syment.n_numaux;
    }

  obj_raw_syments (abfd) = internal;
  BFD_ASSERT (obj_raw_syment_count (abfd)
	      == (unsigned int) (internal_ptr - internal));

  return internal;
}

long
coff_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
{
  if (bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

asymbol *
coff_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new_symbol = (coff_symbol_type *) bfd_zalloc (abfd, amt);

  if (new_symbol == NULL)
    return NULL;
  new_symbol->symbol.section = 0;
  new_symbol->native = 0;
  new_symbol->lineno = NULL;
  new_symbol->done_lineno = FALSE;
  new_symbol->symbol.the_bfd = abfd;

  return & new_symbol->symbol;
}

/* Make a debugging symbol.  */

asymbol *
coff_bfd_make_debug_symbol (bfd *abfd,
			    void * ptr ATTRIBUTE_UNUSED,
			    unsigned long sz ATTRIBUTE_UNUSED)
{
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new_symbol = (coff_symbol_type *) bfd_alloc (abfd, amt);

  if (new_symbol == NULL)
    return NULL;
  /* @@@@ The 10 is a guess at a plausible maximum number of aux entries
     (but shouldn't be a constant).  */
  amt = sizeof (combined_entry_type) * 10;
  new_symbol->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
  if (!new_symbol->native)
    return NULL;
  new_symbol->symbol.section = bfd_abs_section_ptr;
  new_symbol->symbol.flags = BSF_DEBUGGING;
  new_symbol->lineno = NULL;
  new_symbol->done_lineno = FALSE;
  new_symbol->symbol.the_bfd = abfd;

  return & new_symbol->symbol;
}

void
coff_get_symbol_info (bfd *abfd, asymbol *symbol, symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);

  if (coffsymbol (symbol)->native != NULL
      && coffsymbol (symbol)->native->fix_value)
    ret->value = coffsymbol (symbol)->native->u.syment.n_value -
      (bfd_hostptr_t) obj_raw_syments (abfd);
}

/* Return the COFF syment for a symbol.  */

bfd_boolean
bfd_coff_get_syment (bfd *abfd,
		     asymbol *symbol,
		     struct internal_syment *psyment)
{
  coff_symbol_type *csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL || csym->native == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  *psyment = csym->native->u.syment;

  if (csym->native->fix_value)
    psyment->n_value = psyment->n_value -
      (bfd_hostptr_t) obj_raw_syments (abfd);

  /* FIXME: We should handle fix_line here.  */

  return TRUE;
}

/* Return the COFF auxent for a symbol.  */

bfd_boolean
bfd_coff_get_auxent (bfd *abfd,
		     asymbol *symbol,
		     int indx,
		     union internal_auxent *pauxent)
{
  coff_symbol_type *csym;
  combined_entry_type *ent;

  csym = coff_symbol_from (abfd, symbol);

  if (csym == NULL
      || csym->native == NULL
      || indx >= csym->native->u.syment.n_numaux)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  ent = csym->native + indx + 1;

  *pauxent = ent->u.auxent;

  if (ent->fix_tag)
    pauxent->x_sym.x_tagndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_tagndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_end)
    pauxent->x_sym.x_fcnary.x_fcn.x_endndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_fcnary.x_fcn.x_endndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_scnlen)
    pauxent->x_csect.x_scnlen.l =
      ((combined_entry_type *) pauxent->x_csect.x_scnlen.p
       - obj_raw_syments (abfd));

  return TRUE;
}

/* Print out information about COFF symbol.  */

void
coff_print_symbol (bfd *abfd,
		   void * filep,
		   asymbol *symbol,
		   bfd_print_symbol_type how)
{
  FILE * file = (FILE *) filep;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;

    case bfd_print_symbol_more:
      fprintf (file, "coff %s %s",
	       coffsymbol (symbol)->native ? "n" : "g",
	       coffsymbol (symbol)->lineno ? "l" : " ");
      break;

    case bfd_print_symbol_all:
      if (coffsymbol (symbol)->native)
	{
	  bfd_vma val;
	  unsigned int aux;
	  combined_entry_type *combined = coffsymbol (symbol)->native;
	  combined_entry_type *root = obj_raw_syments (abfd);
	  struct lineno_cache_entry *l = coffsymbol (symbol)->lineno;

	  fprintf (file, "[%3ld]", (long) (combined - root));

	  if (! combined->fix_value)
	    val = (bfd_vma) combined->u.syment.n_value;
	  else
	    val = combined->u.syment.n_value - (bfd_hostptr_t) root;

	  fprintf (file, "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x",
		   combined->u.syment.n_scnum,
		   combined->u.syment.n_flags,
		   combined->u.syment.n_type,
		   combined->u.syment.n_sclass,
		   combined->u.syment.n_numaux);
	  bfd_fprintf_vma (abfd, file, val);
	  fprintf (file, " %s", symbol->name);

	  for (aux = 0; aux < combined->u.syment.n_numaux; aux++)
	    {
	      combined_entry_type *auxp = combined + aux + 1;
	      long tagndx;

	      if (auxp->fix_tag)
		tagndx = auxp->u.auxent.x_sym.x_tagndx.p - root;
	      else
		tagndx = auxp->u.auxent.x_sym.x_tagndx.l;

	      fprintf (file, "\n");

	      if (bfd_coff_print_aux (abfd, file, root, combined, auxp, aux))
		continue;

	      switch (combined->u.syment.n_sclass)
		{
		case C_FILE:
		  fprintf (file, "File ");
		  break;

		case C_STAT:
		  if (combined->u.syment.n_type == T_NULL)
		    /* Probably a section symbol ?  */
		    {
		      fprintf (file, "AUX scnlen 0x%lx nreloc %d nlnno %d",
			       (unsigned long) auxp->u.auxent.x_scn.x_scnlen,
			       auxp->u.auxent.x_scn.x_nreloc,
			       auxp->u.auxent.x_scn.x_nlinno);
		      if (auxp->u.auxent.x_scn.x_checksum != 0
			  || auxp->u.auxent.x_scn.x_associated != 0
			  || auxp->u.auxent.x_scn.x_comdat != 0)
			fprintf (file, " checksum 0x%lx assoc %d comdat %d",
				 auxp->u.auxent.x_scn.x_checksum,
				 auxp->u.auxent.x_scn.x_associated,
				 auxp->u.auxent.x_scn.x_comdat);
		      break;
		    }
		    /* Otherwise fall through.  */
		case C_EXT:
		case C_AIX_WEAKEXT:
		  if (ISFCN (combined->u.syment.n_type))
		    {
		      long next, llnos;

		      if (auxp->fix_end)
			next = (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
			       - root);
		      else
			next = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      llnos = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr;
		      fprintf (file,
			       "AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld",
			       tagndx,
			       (unsigned long) auxp->u.auxent.x_sym.x_misc.x_fsize,
			       llnos, next);
		      break;
		    }
		  /* Otherwise fall through.  */
		default:
		  fprintf (file, "AUX lnno %d size 0x%x tagndx %ld",
			   auxp->u.auxent.x_sym.x_misc.x_lnsz.x_lnno,
			   auxp->u.auxent.x_sym.x_misc.x_lnsz.x_size,
			   tagndx);
		  if (auxp->fix_end)
		    fprintf (file, " endndx %ld",
			     ((long)
			      (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
			       - root)));
		  break;
		}
	    }

	  if (l)
	    {
	      fprintf (file, "\n%s :", l->u.sym->name);
	      l++;
	      while (l->line_number)
		{
		  fprintf (file, "\n%4d : ", l->line_number);
		  bfd_fprintf_vma (abfd, file, l->u.offset + symbol->section->vma);
		  l++;
		}
	    }
	}
      else
	{
	  bfd_print_symbol_vandf (abfd, (void *) file, symbol);
	  fprintf (file, " %-5s %s %s %s",
		   symbol->section->name,
		   coffsymbol (symbol)->native ? "n" : "g",
		   coffsymbol (symbol)->lineno ? "l" : " ",
		   symbol->name);
	}
    }
}

/* Return whether a symbol name implies a local symbol.  In COFF,
   local symbols generally start with ``.L''.  Most targets use this
   function for the is_local_label_name entry point, but some may
   override it.  */

bfd_boolean
_bfd_coff_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			       const char *name)
{
  return name[0] == '.' && name[1] == 'L';
}

/* Provided a BFD, a section and an offset (in bytes, not octets) into the
   section, calculate and return the name of the source file and the line
   nearest to the wanted location.  */

bfd_boolean
coff_find_nearest_line_with_names (bfd *abfd,
                                   const struct dwarf_debug_section *debug_sections,
                                   asection *section,
                                   asymbol **symbols,
                                   bfd_vma offset,
                                   const char **filename_ptr,
                                   const char **functionname_ptr,
                                   unsigned int *line_ptr)
{
  bfd_boolean found;
  unsigned int i;
  unsigned int line_base;
  coff_data_type *cof = coff_data (abfd);
  /* Run through the raw syments if available.  */
  combined_entry_type *p;
  combined_entry_type *pend;
  alent *l;
  struct coff_section_tdata *sec_data;
  bfd_size_type amt;

  /* Before looking through the symbol table, try to use a .stab
     section to find the information.  */
  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &coff_data(abfd)->line_info))
    return FALSE;

  if (found)
    return TRUE;

  /* Also try examining DWARF2 debugging information.  */
  if (_bfd_dwarf2_find_nearest_line (abfd, debug_sections,
                                     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, NULL, 0,
				     &coff_data(abfd)->dwarf2_find_line_info))
    return TRUE;

  *filename_ptr = 0;
  *functionname_ptr = 0;
  *line_ptr = 0;

  /* Don't try and find line numbers in a non coff file.  */
  if (!bfd_family_coff (abfd))
    return FALSE;

  if (cof == NULL)
    return FALSE;

  /* Find the first C_FILE symbol.  */
  p = cof->raw_syments;
  if (!p)
    return FALSE;

  pend = p + cof->raw_syment_count;
  while (p < pend)
    {
      if (p->u.syment.n_sclass == C_FILE)
	break;
      p += 1 + p->u.syment.n_numaux;
    }

  if (p < pend)
    {
      bfd_vma sec_vma;
      bfd_vma maxdiff;

      /* Look through the C_FILE symbols to find the best one.  */
      sec_vma = bfd_get_section_vma (abfd, section);
      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;
      maxdiff = (bfd_vma) 0 - (bfd_vma) 1;
      while (1)
	{
	  bfd_vma file_addr;
	  combined_entry_type *p2;

	  for (p2 = p + 1 + p->u.syment.n_numaux;
	       p2 < pend;
	       p2 += 1 + p2->u.syment.n_numaux)
	    {
	      if (p2->u.syment.n_scnum > 0
		  && (section
		      == coff_section_from_bfd_index (abfd,
						      p2->u.syment.n_scnum)))
		break;
	      if (p2->u.syment.n_sclass == C_FILE)
		{
		  p2 = pend;
		  break;
		}
	    }

	  file_addr = (bfd_vma) p2->u.syment.n_value;
	  /* PR 11512: Include the section address of the function name symbol.  */
	  if (p2->u.syment.n_scnum > 0)
	    file_addr += coff_section_from_bfd_index (abfd,
						      p2->u.syment.n_scnum)->vma;
	  /* We use <= MAXDIFF here so that if we get a zero length
             file, we actually use the next file entry.  */
	  if (p2 < pend
	      && offset + sec_vma >= file_addr
	      && offset + sec_vma - file_addr <= maxdiff)
	    {
	      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;
	      maxdiff = offset + sec_vma - p2->u.syment.n_value;
	    }

	  /* Avoid endless loops on erroneous files by ensuring that
	     we always move forward in the file.  */
	  if (p >= cof->raw_syments + p->u.syment.n_value)
	    break;

	  p = cof->raw_syments + p->u.syment.n_value;
	  if (p > pend || p->u.syment.n_sclass != C_FILE)
	    break;
	}
    }

  /* Now wander though the raw linenumbers of the section.  */
  /* If we have been called on this section before, and the offset we
     want is further down then we can prime the lookup loop.  */
  sec_data = coff_section_data (abfd, section);
  if (sec_data != NULL
      && sec_data->i > 0
      && offset >= sec_data->offset)
    {
      i = sec_data->i;
      *functionname_ptr = sec_data->function;
      line_base = sec_data->line_base;
    }
  else
    {
      i = 0;
      line_base = 0;
    }

  if (section->lineno != NULL)
    {
      bfd_vma last_value = 0;

      l = &section->lineno[i];

      for (; i < section->lineno_count; i++)
	{
	  if (l->line_number == 0)
	    {
	      /* Get the symbol this line number points at.  */
	      coff_symbol_type *coff = (coff_symbol_type *) (l->u.sym);
	      if (coff->symbol.value > offset)
		break;
	      *functionname_ptr = coff->symbol.name;
	      last_value = coff->symbol.value;
	      if (coff->native)
		{
		  combined_entry_type *s = coff->native;
		  s = s + 1 + s->u.syment.n_numaux;

		  /* In XCOFF a debugging symbol can follow the
		     function symbol.  */
		  if (s->u.syment.n_scnum == N_DEBUG)
		    s = s + 1 + s->u.syment.n_numaux;

		  /* S should now point to the .bf of the function.  */
		  if (s->u.syment.n_numaux)
		    {
		      /* The linenumber is stored in the auxent.  */
		      union internal_auxent *a = &((s + 1)->u.auxent);
		      line_base = a->x_sym.x_misc.x_lnsz.x_lnno;
		      *line_ptr = line_base;
		    }
		}
	    }
	  else
	    {
	      if (l->u.offset > offset)
		break;
	      *line_ptr = l->line_number + line_base - 1;
	    }
	  l++;
	}

      /* If we fell off the end of the loop, then assume that this
	 symbol has no line number info.  Otherwise, symbols with no
	 line number info get reported with the line number of the
	 last line of the last symbol which does have line number
	 info.  We use 0x100 as a slop to account for cases where the
	 last line has executable code.  */
      if (i >= section->lineno_count
	  && last_value != 0
	  && offset - last_value > 0x100)
	{
	  *functionname_ptr = NULL;
	  *line_ptr = 0;
	}
    }

  /* Cache the results for the next call.  */
  if (sec_data == NULL && section->owner == abfd)
    {
      amt = sizeof (struct coff_section_tdata);
      section->used_by_bfd = bfd_zalloc (abfd, amt);
      sec_data = (struct coff_section_tdata *) section->used_by_bfd;
    }
  if (sec_data != NULL)
    {
      sec_data->offset = offset;
      sec_data->i = i - 1;
      sec_data->function = *functionname_ptr;
      sec_data->line_base = line_base;
    }

  return TRUE;
}

bfd_boolean
coff_find_nearest_line (bfd *abfd,
			asection *section,
			asymbol **symbols,
			bfd_vma offset,
			const char **filename_ptr,
			const char **functionname_ptr,
			unsigned int *line_ptr)
{
  return coff_find_nearest_line_with_names (abfd, dwarf_debug_sections,
                                            section, symbols, offset,
                                            filename_ptr, functionname_ptr,
                                            line_ptr);
}

bfd_boolean
coff_find_nearest_line_discriminator (bfd *abfd,
				      asection *section,
				      asymbol **symbols,
				      bfd_vma offset,
				      const char **filename_ptr,
				      const char **functionname_ptr,
				      unsigned int *line_ptr,
				      unsigned int *discriminator)
{
  *discriminator = 0;
  return coff_find_nearest_line_with_names (abfd, dwarf_debug_sections,
                                            section, symbols, offset,
                                            filename_ptr, functionname_ptr,
                                            line_ptr);
}


bfd_boolean
coff_find_inliner_info (bfd *abfd,
			const char **filename_ptr,
			const char **functionname_ptr,
			unsigned int *line_ptr)
{
  bfd_boolean found;

  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
					 functionname_ptr, line_ptr,
					 &coff_data(abfd)->dwarf2_find_line_info);
  return (found);
}

int
coff_sizeof_headers (bfd *abfd, struct bfd_link_info *info)
{
  size_t size;

  if (!info->relocatable)
    size = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);
  else
    size = bfd_coff_filhsz (abfd);

  size += abfd->section_count * bfd_coff_scnhsz (abfd);
  return size;
}

/* Change the class of a coff symbol held by BFD.  */

bfd_boolean
bfd_coff_set_symbol_class (bfd *         abfd,
			   asymbol *     symbol,
			   unsigned int  symbol_class)
{
  coff_symbol_type * csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
  else if (csym->native == NULL)
    {
      /* This is an alien symbol which no native coff backend data.
	 We cheat here by creating a fake native entry for it and
	 then filling in the class.  This code is based on that in
	 coff_write_alien_symbol().  */

      combined_entry_type * native;
      bfd_size_type amt = sizeof (* native);

      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
      if (native == NULL)
	return FALSE;

      native->u.syment.n_type   = T_NULL;
      native->u.syment.n_sclass = symbol_class;

      if (bfd_is_und_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else if (bfd_is_com_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else
	{
	  native->u.syment.n_scnum =
	    symbol->section->output_section->target_index;
	  native->u.syment.n_value = (symbol->value
				      + symbol->section->output_offset);
	  if (! obj_pe (abfd))
	    native->u.syment.n_value += symbol->section->output_section->vma;

	  /* Copy the any flags from the file header into the symbol.
	     FIXME: Why?  */
	  native->u.syment.n_flags = bfd_asymbol_bfd (& csym->symbol)->flags;
	}

      csym->native = native;
    }
  else
    csym->native->u.syment.n_sclass = symbol_class;

  return TRUE;
}

struct coff_comdat_info *
bfd_coff_get_comdat_section (bfd *abfd, struct bfd_section *sec)
{
  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour
      && coff_section_data (abfd, sec) != NULL)
    return coff_section_data (abfd, sec)->comdat;
  else
    return NULL;
}

bfd_boolean
_bfd_coff_section_already_linked (bfd *abfd,
				  asection *sec,
				  struct bfd_link_info *info)
{
  flagword flags;
  const char *name, *key;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;
  struct coff_comdat_info *s_comdat;

  flags = sec->flags;
  if ((flags & SEC_LINK_ONCE) == 0)
    return FALSE;

  /* The COFF backend linker doesn't support group sections.  */
  if ((flags & SEC_GROUP) != 0)
    return FALSE;

  name = bfd_get_section_name (abfd, sec);
  s_comdat = bfd_coff_get_comdat_section (abfd, sec);

  if (s_comdat != NULL)
    key = s_comdat->name;
  else
    {
      if (CONST_STRNEQ (name, ".gnu.linkonce.")
	  && (key = strchr (name + sizeof (".gnu.linkonce.") - 1, '.')) != NULL)
	key++;
      else
	/* FIXME: gcc as of 2011-09 emits sections like .text$<key>,
	   .xdata$<key> and .pdata$<key> only the first of which has a
	   comdat key.  Should these all match the LTO IR key?  */
	key = name;
    }

  already_linked_list = bfd_section_already_linked_table_lookup (key);

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      struct coff_comdat_info *l_comdat;

      l_comdat = bfd_coff_get_comdat_section (l->sec->owner, l->sec);

      /* The section names must match, and both sections must be
	 comdat and have the same comdat name, or both sections must
	 be non-comdat.  LTO IR plugin sections are an exception.  They
	 are always named .gnu.linkonce.t.<key> (<key> is some string)
	 and match any comdat section with comdat name of <key>, and
	 any linkonce section with the same suffix, ie.
	 .gnu.linkonce.*.<key>.  */
      if (((s_comdat != NULL) == (l_comdat != NULL)
	   && strcmp (name, l->sec->name) == 0)
	  || (l->sec->owner->flags & BFD_PLUGIN) != 0)
	{
	  /* The section has already been linked.  See if we should
	     issue a warning.  */
	  return _bfd_handle_already_linked (sec, l, info);
	}
    }

  /* This is the first section with this name.  Record it.  */
  if (!bfd_section_already_linked_table_insert (already_linked_list, sec))
    info->callbacks->einfo (_("%F%P: already_linked_table: %E\n"));
  return FALSE;
}
@


1.86
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d224 6
a229 2

static const bfd_target *
@


1.85
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@d650 1
a650 1
  if (coff_symbol_ptr->symbol.section 
d1522 1
a1522 1
  
d1945 1
a1945 1
  
@


1.84
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d94 1
a94 1
                                     (bfd_size_type) strlen (strings) + 1);
d105 1
a105 1
                                 (bfd_size_type) sizeof (hdr->s_name) + 1);
d149 70
d2422 18
@


1.83
log
@Building EFI binaries, particularly larger ones (like e.g. Xen does), on Linux
(where relocatable objects are in ELF format) so far led to all local (aka
static) symbols to be discarded, making debugging quite a bit more difficult
(like Linux, Xen builds an internal symbol lookup table from nm output
generated on the binary produced by an earlier linking pass). Therefore, this
patch arranges to insert all (relevant) local symbols from non-COFF objects
into the final executable's symbol table between those coming from COFF input
files and the global ones.

bfd/
2011-11-02  Jan Beulich  <jbeulich@@suse.com>

	* coffgen.c (coff_write_alien_symbol): Make public. Add 'struct
	internal_syment *' parameter. Extend 'dummy' to an array with two
	elements. Set n_numaux early. Handle BSF_FILE.
	(coff_write_symbols): Pass NULL as new third argument to
	coff_write_alien_symbol().
	* cofflink.c (_bfd_coff_final_link): Don't use COFF-specific
	obj_raw_syment_count() on non-COFF input BFD. Insert local symbols
	from non-COFF input BFDs.
	* libcoff-in.h (coff_write_alien_symbol): Declare.
	* libcoff.h (coff_write_alien_symbol): Re-generate.
@
text
@d2156 1
a2156 1
				     line_ptr, 0,
@


1.82
log
@        * coffgen.c (coff_write_alien_symbol): Don't write
        symbol for discarded sections, if strip_discarded isn't
        explicit set to false.
        (coff_write_native_symbol): Likewise.
@
text
@d986 1
a986 1
static bfd_boolean
d989 1
d996 1
a996 1
  combined_entry_type dummy;
d1001 1
d1008 2
d1012 1
a1012 1
  native = &dummy;
d1015 1
d1026 5
d1038 2
d1060 3
a1062 1
  if (symbol->flags & BSF_LOCAL)
a1067 1
  native->u.syment.n_numaux = 0;
d1069 5
a1073 2
  return coff_write_symbol (abfd, symbol, native, written, string_size_p,
			    debug_string_section_p, debug_string_size_p);
d1189 2
a1190 2
	  if (!coff_write_alien_symbol (abfd, symbol, &written, &string_size,
					&debug_string_section,
@


1.81
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@d999 1
d1001 7
d1072 9
@


1.80
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d2088 8
a2095 7
coff_find_nearest_line (bfd *abfd,
			asection *section,
			asymbol **symbols,
			bfd_vma offset,
			const char **filename_ptr,
			const char **functionname_ptr,
			unsigned int *line_ptr)
d2120 2
a2121 1
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
d2304 15
@


1.79
log
@	PR ld/12365
	* coffgen.c (coff_write_symbol): Assume input section is its own
	output section if output_section member not set.
	(coff_write_alien_symbol): Likewise.
@
text
@d2402 67
@


1.78
log
@        PR binutils/11512
        * coffgen.c (coff_find_nearest_line): Incldue the section address
        of function name symbols in address comparisons.
@
text
@d918 3
d939 1
a939 1
      symbol->section->output_section->target_index;
d996 3
d1024 1
a1024 2
      native->u.syment.n_scnum =
	symbol->section->output_section->target_index;
d1028 1
a1028 1
	native->u.syment.n_value += symbol->section->output_section->vma;
@


1.78.4.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a917 3
  asection *output_section = symbol->section->output_section
			       ? symbol->section->output_section
			       : symbol->section;
d936 1
a936 1
      output_section->target_index;
a992 3
  asection *output_section = symbol->section->output_section
			       ? symbol->section->output_section
			       : symbol->section;
d1018 2
a1019 1
      native->u.syment.n_scnum = output_section->target_index;
d1023 1
a1023 1
	native->u.syment.n_value += output_section->vma;
@


1.77
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2155 1
d2174 5
d2182 2
a2183 2
	      && offset + sec_vma >= (bfd_vma) p2->u.syment.n_value
	      && offset + sec_vma - (bfd_vma) p2->u.syment.n_value <= maxdiff)
@


1.76
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d310 1
a310 1
coff_section_from_bfd_index (bfd *abfd, int index)
d314 1
a314 1
  if (index == N_ABS)
d316 1
a316 1
  if (index == N_UNDEF)
d318 1
a318 1
  if (index == N_DEBUG)
d323 1
a323 1
      if (answer->target_index == index)
@


1.75
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d93 2
a94 1
	  name = bfd_alloc (abfd, (bfd_size_type) strlen (strings) + 1);
d104 2
a105 1
      name = bfd_alloc (abfd, (bfd_size_type) sizeof (hdr->s_name) + 1);
d200 1
a200 1
  external_sections = bfd_alloc (abfd, readsize);
d442 1
a442 1
      free_external = bfd_malloc (amt);
d456 1
a456 1
      free_internal = bfd_malloc (amt);
d656 1
a656 1
    newsyms = bfd_alloc (bfd_ptr, amt);
d917 1
a917 1
  int n_sclass = native->u.syment.n_sclass;
d1453 1
a1453 1
  debug_section = bfd_alloc (abfd, sec_size);
d1483 1
a1483 1
  if ((newname = bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
d1578 1
a1578 1
  strings = bfd_malloc (strsize);
d1637 1
a1637 1
  internal = bfd_zalloc (abfd, size);
d1743 1
a1743 1
	      newstring = bfd_zalloc (abfd, (bfd_size_type) (i + 1));
d2343 1
a2343 1
      native = bfd_zalloc (abfd, amt);
@


1.74
log
@update copyright dates
@
text
@d915 1
a915 1
  int class = native->u.syment.n_sclass;
d961 1
a961 1
				 type, class, (int) j,
d1159 1
a1159 1
	      enum coff_symbol_classification class;
d1167 2
a1168 1
	      class = bfd_coff_classify_symbol (abfd, &c_symbol->native->u.syment);
d1170 1
a1170 1
	  
d1182 1
a1182 1
	      else if (symbol->flags & BSF_LOCAL && class != COFF_SYMBOL_LOCAL)
d1185 1
a1185 1
		       && (class != COFF_SYMBOL_GLOBAL
d1394 1
a1394 1
  unsigned int class = symbol->u.syment.n_sclass;
d1404 1
a1404 1
  if (class == C_STAT && type == T_NULL)
d1406 1
a1406 1
  if (class == C_FILE)
d1413 2
a1414 1
  if ((ISFCN (type) || ISTAG (class) || class == C_BLOCK || class == C_FCN)
d2321 1
a2321 1
			   unsigned int  class)
d2346 1
a2346 1
      native->u.syment.n_sclass = class;
d2375 1
a2375 1
    csym->native->u.syment.n_sclass = class;
@


1.74.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d915 1
a915 1
  int n_sclass = native->u.syment.n_sclass;
d961 1
a961 1
				 type, n_sclass, (int) j,
d1159 1
a1159 1
	      enum coff_symbol_classification sym_class;
d1167 1
a1167 2
	      sym_class = bfd_coff_classify_symbol (abfd,
                                                   &c_symbol->native->u.syment);
d1169 1
a1169 1

d1181 1
a1181 1
	      else if (symbol->flags & BSF_LOCAL && sym_class != COFF_SYMBOL_LOCAL)
d1184 1
a1184 1
		       && (sym_class != COFF_SYMBOL_GLOBAL
d1393 1
a1393 1
  unsigned int n_sclass = symbol->u.syment.n_sclass;
d1403 1
a1403 1
  if (n_sclass == C_STAT && type == T_NULL)
d1405 1
a1405 1
  if (n_sclass == C_FILE)
d1412 1
a1412 2
  if ((ISFCN (type) || ISTAG (n_sclass) || n_sclass == C_BLOCK
       || n_sclass == C_FCN)
d2319 1
a2319 1
			   unsigned int  symbol_class)
d2344 1
a2344 1
      native->u.syment.n_sclass = symbol_class;
d2373 1
a2373 1
    csym->native->u.syment.n_sclass = symbol_class;
@


1.74.2.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d93 1
a93 2
	  name = (char *) bfd_alloc (abfd,
                                     (bfd_size_type) strlen (strings) + 1);
d103 1
a103 2
      name = (char *) bfd_alloc (abfd,
                                 (bfd_size_type) sizeof (hdr->s_name) + 1);
d198 1
a198 1
  external_sections = (char *) bfd_alloc (abfd, readsize);
d440 1
a440 1
      free_external = (bfd_byte *) bfd_malloc (amt);
d454 1
a454 1
      free_internal = (struct internal_reloc *) bfd_malloc (amt);
d654 1
a654 1
    newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);
d915 1
a915 1
  int n_sclass = (int) native->u.syment.n_sclass;
d1451 1
a1451 1
  debug_section = (char *) bfd_alloc (abfd, sec_size);
d1481 1
a1481 1
  if ((newname = (char *) bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
d1576 1
a1576 1
  strings = (char *) bfd_malloc (strsize);
d1635 1
a1635 1
  internal = (combined_entry_type *) bfd_zalloc (abfd, size);
d1741 1
a1741 1
	      newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
d2341 1
a2341 1
      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
@


1.73
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.72
log
@	* coffgen.c (coff_print_symbol):  Use bfd_fprintf_vma, not
	fprintf_vma directly.
	* peXXigen.c (pe_print_edata):  Likewise.
	(pe_print_pdata):  Likewise.
	(_bfd_XX_print_ce_compressed_pdata):  Likewise.
	(_bfd_XX_print_private_bfd_data_common):  Likewise.
@
text
@d1797 1
a1797 1
  coff_symbol_type *new = bfd_zalloc (abfd, amt);
d1799 1
a1799 1
  if (new == NULL)
d1801 5
a1805 5
  new->symbol.section = 0;
  new->native = 0;
  new->lineno = NULL;
  new->done_lineno = FALSE;
  new->symbol.the_bfd = abfd;
d1807 1
a1807 1
  return & new->symbol;
d1818 1
a1818 1
  coff_symbol_type *new = bfd_alloc (abfd, amt);
d1820 1
a1820 1
  if (new == NULL)
d1825 2
a1826 2
  new->native = bfd_zalloc (abfd, amt);
  if (!new->native)
d1828 5
a1832 5
  new->symbol.section = bfd_abs_section_ptr;
  new->symbol.flags = BSF_DEBUGGING;
  new->lineno = NULL;
  new->done_lineno = FALSE;
  new->symbol.the_bfd = abfd;
d1834 1
a1834 1
  return & new->symbol;
@


1.71
log
@bfd/ChangeLog

	* coffgen.c (make_a_section_from_file):  Set the backend long
	section names enable if long section names found on input.
	* coffcode.h:  Extend long section names documentation to match.

binutils/ChangeLog

	* objcopy.c (enum long_section_name_handling):  New enum type.
	(enum command_line_switch):  Add OPTION_LONG_SECTION_NAMES.
	(copy_options[]):  Add entry for --long-section-names option.
	(copy_usage):  Document it.
	(set_long_section_mode):  New subroutine.
	(copy_file):  Call it.
	(copy_main):  Accept OPTION_LONG_SECTION_NAMES and parse arg.
	* doc/binutils.texi:  Update objcopy documentation with details
	of new option.
@
text
@d1962 1
a1962 10
#ifdef BFD64
	  /* fprintf_vma() on a 64-bit enabled host will always print a 64-bit
	     value, but really we want to display the address in the target's
	     address size.  Since we do not have a field in the bfd structure
	     to tell us this, we take a guess, based on the target's name.  */
	  if (strstr (bfd_get_target (abfd), "64") == NULL)
	    fprintf (file, "%08lx", (unsigned long) (val & 0xffffffff));
	  else
#endif
	    fprintf_vma (file, val);
d2045 1
a2045 1
		  fprintf_vma (file, l->u.offset + symbol->section->vma);
@


1.70
log
@include/coff/
	* internal.h (C_AIX_WEAKEXT): New macro.
	(C_WEAKEXT): Use the GNU definition in the generic part of the file,
	and conditionally reset it to C_AIX_WEAKEXT in the XCOFF part of
	the file.
	(CSECT_SYM_P): New macro.
	* xcoff.h (L_WEAK): Define.
	(EXTERN_SYM_P): New macro.

bfd/
	* coffcode.h (coff_pointerize_aux_hook): Update CSECT_SYM_P to
	check whether a symbol has csect information.
	(coff_print_aux): Likewise.
	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff_swap_aux_out): Likewise.
	(xcoff_reloc_type_br): Handle defweak symbols too.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff64_swap_aux_out): Likewise.
	(xcoff64_reloc_type_br): Handle defweak symbols too.
	* coffgen.c (coff_print_symbol): Handle auxillary function
	information for C_AIX_WEAKEXT too.
	* xcofflink.c (_bfd_xcoff_canonicalize_dynamic_symtab): Set BSF_WEAK
	instead of BSF_GLOBAL if the L_WEAK flag is set.
	(xcoff_dynamic_definition_p): New function.
	(xcoff_link_add_dynamic_symbols): Use it to decide whether ldsym
	defines h.  Don't change h if ldsym isn't the definition.  Otherwise,
	always take the symbol class from the ldsym.  Use weak bfd symbol
	types for weak ldsyms.
	(xcoff_link_add_symbols): Use CSECT_SYM_P and EXTERN_SYM_P.
	Fix the check for whether a definition is from a shared object.
	Allow redefinitions of weak symbols.
	(xcoff_link_check_ar_symbols): Use EXTERN_SYM_P.
	(xcoff_keep_symbol_p): Likewise.
	(bfd_xcoff_size_dynamic_sections): Use CSECT_SYM_P.
	(xcoff_link_input_bfd): Use CSECT_SYM_P and EXTERN_SYM_P.
	Add .loader entries for C_AIX_WEAKEXT as well as C_EXT symbols,
	but mark them as L_WEAK.
	(xcoff_write_global_symbol): Treat weak symbols as C_AIX_WEAKEXT
	instead of C_EXT if C_AIX_WEAKEXT == C_WEAKEXT.

gas/
	* config/tc-ppc.c (ppc_frob_symbol): Add csect information for
	C_AIX_WEAKEXT too.

ld/testsuite/
	* ld-powerpc/aix-glink-2a.s, ld-powerpc/aix-glink-2a.ex,
	ld-powerpc/aix-glink-2b.s, ld-powerpc/aix-glink-2c.s,
	ld-powerpc/aix-glink-2c.ex, ld-powerpc/aix-glink-2d.s,
	ld-powerpc/aix-glink-2-32.dd, ld-powerpc/aix-glink-2-64.dd,
	ld-powerpc/aix-weak-1a.s, ld-powerpc/aix-weak-1b.s,
	ld-powerpc/aix-weak-1-rel.hd, ld-powerpc/aix-weak-1-rel.nd,
	ld-powerpc/aix-weak-1-dso.hd, ld-powerpc/aix-weak-1-dso.nd,
	ld-powerpc/aix-weak-1-dso.dnd, ld-powerpc/aix-weak-1.ex,
	ld-powerpc/aix-weak-2a.s, ld-powerpc/aix-weak-2a.ex,
	ld-powerpc/aix-weak-2a.nd, ld-powerpc/aix-weak-2b.s,
	ld-powerpc/aix-weak-2b.nd, ld-powerpc/aix-weak-2c.s,
	ld-powerpc/aix-weak-2c.ex, ld-powerpc/aix-weak-2c.nd,
	ld-powerpc/aix-weak-2c.od, ld-powerpc/aix-weak-3a.s,
	ld-powerpc/aix-weak-3a.ex, ld-powerpc/aix-weak-3b.s,
	ld-powerpc/aix-weak-3b.ex, ld-powerpc/aix-weak-3-32.d,
	ld-powerpc/aix-weak-3-32.dd, ld-powerpc/aix-weak-3-64.d,
	ld-powerpc/aix-weak-3-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Replace tmp/aix-* with
	tmp/aix64-* in 64-bit ld options.
@
text
@d76 5
@


1.69
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d2009 1
@


1.68
log
@     * coffgen.c (coff_write_symbols): Check to see if a symbol's flags
       do not match it class and if necessary update the class.
       (null_error_handler): New function.  Suppresses the generation of
       bfd error messages.
     * coff64-rs6000.c (bfd_xcoff_backend_data): Update comment.
     * config/tc-tic4x.c (tic4x_globl): Call S_SET_EXTERNAL as well as
     S_SET_STORAGE_CLASS.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
d62 7
a68 2
  /* Handle long section names as in PE.  */
  if (bfd_coff_long_section_names (abfd)
@


1.67
log
@	* coffgen.c (coff_find_nearest_line): Correct cached line index.
@
text
@d1085 5
d1146 36
@


1.66
log
@Silence gcc printf warnings
@
text
@d2148 1
a2148 1
  /* If we have been called on this section before, and th. e offset we
d2235 1
a2235 1
      sec_data->i = i;
@


1.65
log
@	* coffgen.c (coff_get_normalized_symtab): Correct cast.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007
d1949 1
a1949 1
			       (long) auxp->u.auxent.x_scn.x_scnlen,
d1975 2
a1976 1
			       tagndx, auxp->u.auxent.x_sym.x_misc.x_fsize,
@


1.64
log
@2007-07-30  Michael Snyder  <msnyder@@access-company.com>

	* coffgen.c (_bfd_coff_read_internal_relocs): Revert change of
	2007-07-26.  Buffer still in use, can't be freed.
@
text
@d1696 1
a1696 1
	    internal_ptr->u.syment._n._n_n._n_offset = (bfd_vma) "";
@


1.64.2.1
log
@	* coffgen.c (coff_get_normalized_symtab): Correct cast.
@
text
@d1696 1
a1696 1
	    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) "";
@


1.63
log
@2007-07-27  Michael Snyder  <msnyder@@access-company.com>

	* coffgen.c (_bfd_coff_read_internal_relocs): Return if count is zero.
@
text
@d463 1
a463 1
  if (free_internal != NULL)
d465 1
a465 3
      if (cache)
	free (free_internal);
      else
d467 5
a471 9
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = bfd_zalloc (abfd, amt);
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	      coff_section_data (abfd, sec)->contents = NULL;
	    }
	  coff_section_data (abfd, sec)->relocs = free_internal;
d473 1
@


1.62
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* coffgen.c (fixup_symbol_value): Guard against null;
	bfd_is_com_section will dereference the section pointer.
@
text
@d412 3
d431 1
a431 1
      if (free_external == NULL && sec->reloc_count > 0)
d445 1
a445 1
      if (free_internal == NULL && sec->reloc_count > 0)
@


1.61
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* coffgen.c (_bfd_coff_read_internal_relocs): If internal_relocs
	are not to be cached, free the temporary buffer.
@
text
@d570 2
a571 1
  if (bfd_is_com_section (coff_symbol_ptr->symbol.section))
@


1.60
log
@2007-07-25  Michael Snyder  <msnyder@@access-company.com>

	* coffgen.c (_bfd_coff_get_external_symbols): Nothing to be done
	if size == 0; return and avoid possible null pointer issues.
@
text
@d460 1
a460 1
  if (cache && free_internal != NULL)
d462 3
a464 1
      if (coff_section_data (abfd, sec) == NULL)
d466 9
a474 5
	  amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = bfd_zalloc (abfd, amt);
	  if (sec->used_by_bfd == NULL)
	    goto error_return;
	  coff_section_data (abfd, sec)->contents = NULL;
a475 1
      coff_section_data (abfd, sec)->relocs = free_internal;
@


1.59
log
@Add support for building on a 64-bit Windows host.
@
text
@d1447 2
d1451 1
a1451 1
  if (syms == NULL && size != 0)
@


1.58
log
@Switch sources over to use the GPL version 3
@
text
@d729 2
a730 2
		(bfd_vma)((combined_entry_type *)
			  ((unsigned long) s->u.syment.n_value))->offset;
d1644 1
a1644 1
		((long)
d1656 1
a1656 1
		  ((long)
d1662 1
a1662 1
		  ((long)
d1686 1
a1686 1
	      internal_ptr->u.syment._n._n_n._n_offset = (long int) newstring;
d1690 1
a1690 1
	    internal_ptr->u.syment._n._n_n._n_offset = (long int) "";
d1702 1
a1702 1
		((long int)
d1711 1
a1711 1
	      internal_ptr->u.syment._n._n_n._n_offset = (long int)
d1788 1
a1788 1
      (unsigned long) obj_raw_syments (abfd);
d1811 1
a1811 1
      (unsigned long) obj_raw_syments (abfd);
d1897 1
a1897 1
	    val = combined->u.syment.n_value - (unsigned long) root;
@


1.57
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.56
log
@PR binutils/4292
* bfd.c (bfd_fprintf_vma): Do not print addresses of 32-bit
  targets as 64-bit values, even if running on a 64-bit host.
* coffgen.c (coff_print_symbol): Likewise.
* nm.c (value_format): Replace with value_format_32bit and
  value_format_64bit.
  (set_radix): Update setting of value_format.
  (set_print_width): New function.  Compute the address size of a
  given bfd and set the print_width global appropriately.
  (display_archive): Use set_print_width.
  (display_file): Likewise,
  (print_object_filename_sysv): Update use of print_width.
  (print_archive_member_sysv): Likewise.
  (print_symbol_filename_posix): Likewise.
  (print_sumbol_info_bfd, print_symbol_info_sysv): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d40 1
a41 1
#include "sysdep.h"
@


1.55
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d1904 10
a1913 1
	  fprintf_vma (file, val);
@


1.54
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d2241 1
a2241 1
coff_sizeof_headers (bfd *abfd, bfd_boolean reloc)
d2245 1
a2245 1
  if (! reloc)
@


1.53
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2226 14
@


1.52
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.51
log
@Update to ISO-C90 and fix formatting
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.50
log
@Use fprintf_vma to print vma values.
@
text
@d1898 1
a1898 1
	  fprintf (file, "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d)",
@


1.49
log
@Convert to ISO C90 formatting.
@
text
@d1898 1
a1898 3
#ifndef XCOFF64
	  fprintf (file,
		   "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%08lx %s",
d1903 3
a1905 15
		   combined->u.syment.n_numaux,
		   (unsigned long) val,
		   symbol->name);
#else
	  /* Print out the wide, 64 bit, symbol value.  */
	  fprintf (file,
		   "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%016llx %s",
		   combined->u.syment.n_scnum,
		   combined->u.syment.n_flags,
		   combined->u.syment.n_type,
		   combined->u.syment.n_sclass,
		   combined->u.syment.n_numaux,
		   val,
		   symbol->name);
#endif
d1984 2
a1985 4
		  fprintf (file, "\n%4d : 0x%lx",
			   l->line_number,
			   ((unsigned long)
			    (l->u.offset + symbol->section->vma)));
@


1.48
log
@	* coffgen.c (bfd_coff_get_comdat_section): Check that
	coff_section_data isn't NULL.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a45 29
static void coff_fix_symbol_name
  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_size_type *,
	   asection **, bfd_size_type *));
static bfd_boolean coff_write_symbol
  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_vma *,
	   bfd_size_type *, asection **, bfd_size_type *));
static bfd_boolean coff_write_alien_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma *, bfd_size_type *,
	   asection **, bfd_size_type *));
static bfd_boolean coff_write_native_symbol
  PARAMS ((bfd *, coff_symbol_type *, bfd_vma *, bfd_size_type *,
	   asection **, bfd_size_type *));
static void coff_pointerize_aux
  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
	   unsigned int, combined_entry_type *));
static bfd_boolean make_a_section_from_file
  PARAMS ((bfd *, struct internal_scnhdr *, unsigned int));
static const bfd_target *coff_real_object_p
  PARAMS ((bfd *, unsigned, struct internal_filehdr *,
	   struct internal_aouthdr *));
static void fixup_symbol_value
  PARAMS ((bfd *, coff_symbol_type *, struct internal_syment *));
static char *build_debug_section
  PARAMS ((bfd *));
static char *copy_name
  PARAMS ((bfd *, char *, size_t));

#define STRING_SIZE_SIZE (4)

d48 1
d50 3
a52 4
make_a_section_from_file (abfd, hdr, target_index)
     bfd *abfd;
     struct internal_scnhdr *hdr;
     unsigned int target_index;
d116 1
a116 1
  return_section->next = (asection *) NULL;
d132 1
a132 1
  /* FIXME: should this check 'hdr->s_size > 0' */
d143 4
a146 5
coff_real_object_p (abfd, nscns, internal_f, internal_a)
     bfd *abfd;
     unsigned nscns;
     struct internal_filehdr *internal_f;
     struct internal_aouthdr *internal_a;
d150 3
a152 3
  PTR tdata;
  PTR tdata_save;
  bfd_size_type readsize;	/* length of file_info */
d181 1
a181 1
  tdata = bfd_coff_mkobject_hook (abfd, (PTR) internal_f, (PTR) internal_a);
d187 1
a187 1
  external_sections = (char *) bfd_alloc (abfd, readsize);
d191 1
a191 1
  if (bfd_bread ((PTR) external_sections, readsize, abfd) != readsize)
d196 1
a196 1
  if (! bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f))
d207 2
a208 2
				   (PTR) (external_sections + i * scnhsz),
				   (PTR) & tmp);
d229 1
a229 2
coff_object_p (abfd)
     bfd *abfd;
d234 1
a234 1
  PTR filehdr;
d238 1
a238 1
  /* figure out how much to read */
d273 1
a273 1
      PTR opthdr;
d284 1
a284 1
      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) &internal_a);
d297 1
a297 3
coff_section_from_bfd_index (abfd, index)
     bfd *abfd;
     int index;
d323 1
a323 2
coff_get_symtab_upper_bound (abfd)
     bfd *abfd;
d334 1
a334 3
coff_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d357 3
a359 4
_bfd_coff_internal_syment_name (abfd, sym, buf)
     bfd *abfd;
     const struct internal_syment *sym;
     char *buf;
d396 6
a401 8
_bfd_coff_read_internal_relocs (abfd, sec, cache, external_relocs,
				require_internal, internal_relocs)
     bfd *abfd;
     asection *sec;
     bfd_boolean cache;
     bfd_byte *external_relocs;
     bfd_boolean require_internal;
     struct internal_reloc *internal_relocs;
d426 1
a426 1
      free_external = (bfd_byte *) bfd_malloc (amt);
d440 1
a440 1
      free_internal = (struct internal_reloc *) bfd_malloc (amt);
d451 1
a451 1
    bfd_coff_swap_reloc_in (abfd, (PTR) erel, (PTR) irel);
d464 1
a464 1
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d485 1
a485 2
coff_count_linenumbers (abfd)
     bfd *abfd;
d546 2
a547 3
coff_symbol_from (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
d559 3
a561 4
fixup_symbol_value (abfd, coff_symbol_ptr, syment)
     bfd *abfd;
     coff_symbol_type *coff_symbol_ptr;
     struct internal_syment *syment;
d563 1
a563 2

  /* Normalize the symbol flags */
d566 1
a566 1
      /* a common symbol is undefined with a value */
d615 1
a615 3
coff_renumber_symbols (bfd_ptr, first_undef)
     bfd *bfd_ptr;
     int *first_undef;
d620 1
a620 1
  struct internal_syment *last_file = (struct internal_syment *) NULL;
d639 1
a639 1
    newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);
d682 1
a682 1
	      if (last_file != (struct internal_syment *) NULL)
d687 3
a689 1
	    {
a690 5
	      /* Modify the symbol values according to their section and
	         type */

	      fixup_symbol_value (bfd_ptr, coff_symbol_ptr, &(s->u.syment));
	    }
d695 1
a695 3
	{
	  native_index++;
	}
d697 1
d708 1
a708 2
coff_mangle_symbols (bfd_ptr)
     bfd *bfd_ptr;
d771 6
a776 8
coff_fix_symbol_name (abfd, symbol, native, string_size_p,
		      debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     combined_entry_type *native;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
d782 1
a782 1
  if (name == (char *) NULL)
d784 1
a784 1
      /* coff symbols always have names, so we'll make one up */
d812 1
a812 3
	    {
	      strncpy (auxent->x_file.x_fname, name, filnmlen);
	    }
d830 3
a832 4
	{
	  /* This name will fit into the symbol neatly */
	  strncpy (native->u.syment._n._n_name, symbol->name, SYMNMLEN);
	}
d861 1
a861 1
					 (PTR) buf,
d866 1
a866 1
					    (PTR) symbol->name,
d890 7
a896 9
coff_write_symbol (abfd, symbol, native, written, string_size_p,
		   debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     combined_entry_type *native;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
d901 1
a901 1
  PTR buf;
d909 2
a910 3
    {
      native->u.syment.n_scnum = N_DEBUG;
    }
d912 2
a913 3
    {
      native->u.syment.n_scnum = N_ABS;
    }
d915 2
a916 3
    {
      native->u.syment.n_scnum = N_UNDEF;
    }
d918 2
a919 4
    {
      native->u.syment.n_scnum =
	symbol->section->output_section->target_index;
    }
d946 1
a946 3
				 type,
				 class,
				 (int) j,
d967 6
a972 8
coff_write_alien_symbol (abfd, symbol, written, string_size_p,
			 debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
d1033 6
a1038 8
coff_write_native_symbol (abfd, symbol, written, string_size_p,
			  debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     coff_symbol_type *symbol;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
d1049 1
d1083 1
a1083 2
coff_write_symbols (abfd)
     bfd *abfd;
d1115 1
a1115 1
  /* Seek to the right place */
d1119 1
a1119 2
  /* Output all the symbols we have */

d1145 1
a1145 2
  /* Now write out strings */

d1156 1
a1156 1
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd)
d1198 4
a1201 5
	    {
	      /* This is not a COFF symbol, so it certainly is not a
	         file name, nor does it go in the .debug section.  */
	      maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
	    }
d1204 4
a1207 5
	    {
	      /* This symbol name is in the XCOFF .debug section.
	         Don't write it into the string table.  */
	      maxlen = name_length;
	    }
d1223 1
a1223 1
	      if (bfd_bwrite ((PTR) (q->name), (bfd_size_type) name_length + 1,
d1242 1
a1242 1
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) STRING_SIZE_SIZE, abfd)
d1262 1
a1262 2
coff_write_linenumbers (abfd)
     bfd *abfd;
d1266 1
a1266 1
  PTR buff;
d1279 1
a1279 1
	  /* Find all the linenumbers in this section */
d1290 1
a1290 1
		      /* Found a linenumber entry, output */
d1292 1
a1292 1
		      memset ((PTR) & out, 0, sizeof (out));
d1321 1
a1321 3
coff_get_lineno (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
d1330 5
a1334 6
coff_pointerize_aux (abfd, table_base, symbol, indaux, auxent)
     bfd *abfd;
     combined_entry_type *table_base;
     combined_entry_type *symbol;
     unsigned int indaux;
     combined_entry_type *auxent;
d1346 1
a1346 1
  /* Don't bother if this is a file or a section */
d1352 2
a1353 2
  /* Otherwise patch up */
#define N_TMASK coff_data (abfd)->local_n_tmask
d1355 1
d1378 1
a1378 2
build_debug_section (abfd)
     bfd *abfd;
d1393 1
a1393 1
  debug_section = (PTR) bfd_alloc (abfd, sec_size);
d1412 1
d1414 1
a1414 4
copy_name (abfd, name, maxlen)
     bfd *abfd;
     char *name;
     size_t maxlen;
d1420 5
a1424 6
    {
      if (name[len] == '\0')
	{
	  break;
	}
    }
a1425 2
  if ((newname = (PTR) bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
    return (NULL);
d1434 1
a1434 2
_bfd_coff_get_external_symbols (abfd)
     bfd *abfd;
d1438 1
a1438 1
  PTR syms;
d1447 1
a1447 1
  syms = (PTR) bfd_malloc (size);
d1469 1
a1469 2
_bfd_coff_read_string_table (abfd)
     bfd *abfd;
d1516 1
a1516 1
  strings = (char *) bfd_malloc (strsize);
d1535 1
a1535 2
_bfd_coff_free_symbols (abfd)
     bfd *abfd;
d1558 1
a1558 2
coff_get_normalized_symtab (abfd)
     bfd *abfd;
d1575 1
a1575 1
  internal = (combined_entry_type *) bfd_zalloc (abfd, size);
d1585 1
a1585 1
  /* mark the end of the symbols */
d1592 1
a1592 1
  /* Swap all the raw entries */
d1599 2
a1600 2
      bfd_coff_swap_sym_in (abfd, (PTR) raw_src,
			    (PTR) & internal_ptr->u.syment);
d1609 1
a1609 1
	  bfd_coff_swap_aux_in (abfd, (PTR) raw_src,
d1630 2
a1631 2
	  /* make a file symbol point to the name in the auxent, since
	     the text ".file" is redundant */
d1634 1
a1634 1
	      /* the filename is a long one, point into the string table */
d1654 5
a1658 7
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				internal_ptr->u.syment.n_numaux * symesz));
		}
d1660 5
a1664 7
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				(size_t) bfd_coff_filnmlen (abfd)));
		}
d1675 1
a1675 1
	      /* find the length of this string without walking into memory
d1681 1
a1681 1
	      newstring = (PTR) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
d1683 1
a1683 1
		return (NULL);
d1721 2
a1722 2
  return (internal);
}				/* coff_get_normalized_symtab() */
d1725 1
a1725 3
coff_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
d1736 1
a1736 2
coff_make_empty_symbol (abfd)
     bfd *abfd;
d1739 2
a1740 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_zalloc (abfd, amt);
d1742 1
a1742 1
    return (NULL);
d1745 1
a1745 1
  new->lineno = (alent *) NULL;
d1748 2
a1749 1
  return &new->symbol;
d1755 3
a1757 4
coff_bfd_make_debug_symbol (abfd, ptr, sz)
     bfd *abfd;
     PTR ptr ATTRIBUTE_UNUSED;
     unsigned long sz ATTRIBUTE_UNUSED;
d1760 2
a1761 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, amt);
d1763 1
a1763 1
    return (NULL);
d1767 1
a1767 1
  new->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d1769 1
a1769 1
    return (NULL);
d1772 1
a1772 1
  new->lineno = (alent *) NULL;
d1775 2
a1776 1
  return &new->symbol;
d1780 1
a1780 4
coff_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
d1783 1
d1786 2
a1787 4
    {
      ret->value = coffsymbol (symbol)->native->u.syment.n_value -
	(unsigned long) obj_raw_syments (abfd);
    }
d1793 3
a1795 4
bfd_coff_get_syment (abfd, symbol, psyment)
     bfd *abfd;
     asymbol *symbol;
     struct internal_syment *psyment;
d1820 4
a1823 5
bfd_coff_get_auxent (abfd, symbol, indx, pauxent)
     bfd *abfd;
     asymbol *symbol;
     int indx;
     union internal_auxent *pauxent;
d1863 4
a1866 5
coff_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
     PTR filep;
     asymbol *symbol;
     bfd_print_symbol_type how;
d1868 1
a1868 1
  FILE *file = (FILE *) filep;
d1909 1
a1909 1
	  /* Print out the wide, 64 bit, symbol value */
d1944 1
a1944 1
		    /* probably a section symbol? */
d1959 1
a1959 1
		    /* else fall through */
d1977 1
a1977 1
		  /* else fall through */
d2008 1
a2008 1
	  bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d2024 2
a2025 3
_bfd_coff_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d2035 7
a2041 9
coff_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d2047 1
a2047 1
  /* Run through the raw syments if available */
d2076 1
a2076 1
  /* Don't try and find line numbers in a non coff file */
d2146 2
a2147 2
  /* Now wander though the raw linenumbers of the section */
  /* If we have been called on this section before, and the offset we
d2174 1
a2174 1
	      /* Get the symbol this line number points at */
d2228 1
a2228 1
      section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d2243 1
a2243 3
coff_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc;
d2248 1
a2248 3
    {
      size = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);
    }
d2250 1
a2250 3
    {
      size = bfd_coff_filhsz (abfd);
    }
d2257 1
d2259 3
a2261 4
bfd_coff_set_symbol_class (abfd, symbol, class)
     bfd *         abfd;
     asymbol *     symbol;
     unsigned int  class;
d2281 1
a2281 1
      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d2315 1
a2315 3
    {
      csym->native->u.syment.n_sclass = class;
    }
@


1.47
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d2430 2
a2431 1
  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
@


1.46
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d1158 1
a1158 1
  bfd_signed_vma written = 0;
@


1.45
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@a1129 18
#if 0
	  /* 13 april 92. sac
	     I've been told this, but still need proof:
	     > The second bug is also in `bfd/coffcode.h'.  This bug
	     > causes the linker to screw up the pc-relocations for
	     > all the line numbers in COFF code.  This bug isn't only
	     > specific to A29K implementations, but affects all
	     > systems using COFF format binaries.  Note that in COFF
	     > object files, the line number core offsets output by
	     > the assembler are relative to the start of each
	     > procedure, not to the start of the .text section.  This
	     > patch relocates the line numbers relative to the
	     > `native->u.syment.n_value' instead of the section
	     > virtual address.
	     > modular!olson@@cs.arizona.edu (Jon Olson)
	   */
	  lineno[count].u.offset += native->u.syment.n_value;
#else
a1132 1
#endif
a1400 53
#if 0

/* This is only called from coff_add_missing_symbols, which has been
   disabled.  */

asymbol *
coff_section_symbol (abfd, name)
     bfd *abfd;
     char *name;
{
  asection *sec = bfd_make_section_old_way (abfd, name);
  asymbol *sym;
  combined_entry_type *csym;

  sym = sec->symbol;
  csym = coff_symbol_from (abfd, sym)->native;
  /* Make sure back-end COFF stuff is there.  */
  if (csym == 0)
    {
      struct foo
	{
	  coff_symbol_type sym;
	  /* @@@@FIXME This shouldn't use a fixed size!!  */
	  combined_entry_type e[10];
	};
      struct foo *f;

      f = (struct foo *) bfd_zalloc (abfd, (bfd_size_type) sizeof (*f));
      if (!f)
	{
	  bfd_set_error (bfd_error_no_error);
	  return NULL;
	}
      coff_symbol_from (abfd, sym)->native = csym = f->e;
    }
  csym[0].u.syment.n_sclass = C_STAT;
  csym[0].u.syment.n_numaux = 1;
/*  SF_SET_STATICS (sym);       @@@@ ??? */
  csym[1].u.auxent.x_scn.x_scnlen = sec->size;
  csym[1].u.auxent.x_scn.x_nreloc = sec->reloc_count;
  csym[1].u.auxent.x_scn.x_nlinno = sec->lineno_count;

  if (sec->output_section == NULL)
    {
      sec->output_section = sec;
      sec->output_offset = 0;
    }

  return sym;
}

#endif /* 0 */

@


1.44
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1666 1
a1666 2
	(_("%s: bad string table size %lu"), bfd_archive_filename (abfd),
	 (unsigned long) strsize);
@


1.43
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2499 9
@


1.42
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@d134 1
a134 1
  return_section->_raw_size = hdr->s_size;
d1347 1
a1347 1
		      == bfd_section_size (abfd, debug_string_section))));
d1458 1
a1458 1
  csym[1].u.auxent.x_scn.x_scnlen = sec->_raw_size;
d1540 1
a1540 1
  sec_size = bfd_get_section_size (sect);
@


1.41
log
@	* aout-target.h, aoutf1.h, bfdio.c, bfdwin.c: Update copyright date.
	* coff-apollo.c, coff-sparc.c, coff-w65.c, coff-we32k.c: Ditto.
	* coff-z8k.c, coffgen.c, cpu-frv.c, cpu-h8500.c, cpu-hppa.c: Ditto.
	* cpu-ia64-opc.c, cpu-m10300.c, cpu-mips.c, cpu-msp430.c: Ditto.
	* cpu-rs6000.c, cpu-z8k.c, efi-app-ia32.c, elf32-am33lin.c: Ditto.
	* gen-aout.c, hash.c, hp300hpux.c, init.c, mach-o.c: Ditto.
	* nlm-target.h, nlm.c, som.h, stabs.c, sysdep.h, xsym.h: Ditto.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d1540 1
a1540 1
  sec_size = bfd_get_section_size_before_reloc (sect);
@


1.41.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d134 1
a134 1
  return_section->size = hdr->s_size;
d1347 1
a1347 1
		      == debug_string_section->size)));
d1458 1
a1458 1
  csym[1].u.auxent.x_scn.x_scnlen = sec->size;
d1540 1
a1540 1
  sec_size = sect->size;
d1666 2
a1667 1
	(_("%B: bad string table size %lu"), abfd, (unsigned long) strsize);
a2498 9

struct coff_comdat_info *
bfd_coff_get_comdat_section (bfd *abfd, struct bfd_section *sec)
{
  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
    return coff_section_data (abfd, sec)->comdat;
  else
    return NULL;
}
@


1.40
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d3 1
a3 1
   2000, 2001, 2002
@


1.39
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d332 1
a332 1
  struct sec *answer = abfd->sections;
@


1.38
log
@Fixes for iWMMXt contribution.
@
text
@d368 1
a368 1
coff_get_symtab (abfd, alocation)
@


1.37
log
@Add iWMMXt support
@
text
@a243 3
  bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f);
  /*  make_abs_section (abfd); */

@


1.36
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d229 1
a229 1
  /* Now copy data as required; construct all asections etc */
d244 1
@


1.35
log
@Files missed in previous commit.
@
text
@d49 1
a49 1
static boolean coff_write_symbol
d52 1
a52 1
static boolean coff_write_alien_symbol
d55 1
a55 1
static boolean coff_write_native_symbol
d61 1
a61 1
static boolean make_a_section_from_file
d77 1
a77 1
static boolean
d85 1
a85 1
  boolean result = true;
d106 1
a106 1
	    return false;
d113 1
a113 1
	    return false;
d123 1
a123 1
	return false;
d130 1
a130 1
    return false;
d150 1
a150 1
    result = false;
d426 1
a426 1
   relocs for section SEC in file ABFD.  If CACHE is true and
d431 1
a431 1
   the swapped relocs.  If REQUIRE_INTERNAL is true, then the return
d439 1
a439 1
     boolean cache;
d441 1
a441 1
     boolean require_internal;
d568 1
a568 1
		  
d659 1
a659 1
boolean
d688 1
a688 1
      return false;
d751 1
a751 1
  return true;
d946 1
a946 1
static boolean
d991 1
a991 1
    return false;
d994 1
a994 1
    return false;
d1005 1
a1005 1
	return false;
d1016 1
a1016 1
	    return false;
d1025 1
a1025 1
  return true;
d1032 1
a1032 1
static boolean
d1065 1
a1065 1
      return true;
d1100 1
a1100 1
static boolean
d1156 1
a1156 1
      symbol->done_lineno = true;
d1170 1
a1170 1
boolean
d1206 1
a1206 1
    return false;
d1222 1
a1222 1
	    return false;
d1229 1
a1229 1
	    return false;
d1249 1
a1249 1
	return false;
d1266 1
a1266 1
		    return false;
d1307 1
a1307 1
		    return false;
d1318 1
a1318 1
		return false;
d1337 1
a1337 1
	return false;
d1351 1
a1351 1
  return true;
d1354 1
a1354 1
boolean
d1365 1
a1365 1
    return false;
d1372 1
a1372 1
	    return false;
d1392 1
a1392 1
			return false;
d1401 1
a1401 1
			    return false;
d1411 1
a1411 1
  return true;
d1588 1
a1588 1
boolean
d1597 1
a1597 1
    return true;
d1605 1
a1605 1
    return false;
d1612 1
a1612 1
      return false;
d1617 1
a1617 1
  return true;
d1692 1
a1692 1
boolean
d1708 1
a1708 1
  return true;
d1780 1
a1780 1
  obj_coff_keep_strings (abfd) = true;
d1912 1
a1912 1
  new->done_lineno = false;
d1938 1
a1938 1
  new->done_lineno = false;
d1960 1
a1960 1
boolean
d1972 1
a1972 1
      return false;
d1983 1
a1983 1
  return true;
d1988 1
a1988 1
boolean
d2005 1
a2005 1
      return false;
d2027 1
a2027 1
  return true;
d2194 1
a2194 1
boolean
d2199 1
a2199 1
  return (boolean) (name[0] == '.' && name[1] == 'L');
d2206 1
a2206 1
boolean
d2217 1
a2217 1
  boolean found;
d2234 1
a2234 1
    return false;
d2237 1
a2237 1
    return true;
d2244 1
a2244 1
    return true;
d2252 1
a2252 1
    return false;
d2255 1
a2255 1
    return false;
d2260 1
a2260 1
    return false;
d2413 1
a2413 1
  return true;
d2419 1
a2419 1
     boolean reloc;
d2437 1
a2437 1
boolean
d2449 1
a2449 1
      return false;
d2463 1
a2463 1
	return false;
d2499 1
a2499 1
  return true;
@


1.34
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d2199 1
a2199 1
  return name[0] == '.' && name[1] == 'L';
@


1.34.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d49 1
a49 1
static bfd_boolean coff_write_symbol
d52 1
a52 1
static bfd_boolean coff_write_alien_symbol
d55 1
a55 1
static bfd_boolean coff_write_native_symbol
d61 1
a61 1
static bfd_boolean make_a_section_from_file
d77 1
a77 1
static bfd_boolean
d85 1
a85 1
  bfd_boolean result = TRUE;
d106 1
a106 1
	    return FALSE;
d113 1
a113 1
	    return FALSE;
d123 1
a123 1
	return FALSE;
d130 1
a130 1
    return FALSE;
d150 1
a150 1
    result = FALSE;
d229 1
a229 1
  /* Now copy data as required; construct all asections etc.  */
d244 2
d334 1
a334 1
  struct bfd_section *answer = abfd->sections;
d370 1
a370 1
coff_canonicalize_symtab (abfd, alocation)
d426 1
a426 1
   relocs for section SEC in file ABFD.  If CACHE is TRUE and
d431 1
a431 1
   the swapped relocs.  If REQUIRE_INTERNAL is TRUE, then the return
d439 1
a439 1
     bfd_boolean cache;
d441 1
a441 1
     bfd_boolean require_internal;
d568 1
a568 1

d659 1
a659 1
bfd_boolean
d688 1
a688 1
      return FALSE;
d751 1
a751 1
  return TRUE;
d946 1
a946 1
static bfd_boolean
d991 1
a991 1
    return FALSE;
d994 1
a994 1
    return FALSE;
d1005 1
a1005 1
	return FALSE;
d1016 1
a1016 1
	    return FALSE;
d1025 1
a1025 1
  return TRUE;
d1032 1
a1032 1
static bfd_boolean
d1065 1
a1065 1
      return TRUE;
d1100 1
a1100 1
static bfd_boolean
d1156 1
a1156 1
      symbol->done_lineno = TRUE;
d1170 1
a1170 1
bfd_boolean
d1206 1
a1206 1
    return FALSE;
d1222 1
a1222 1
	    return FALSE;
d1229 1
a1229 1
	    return FALSE;
d1249 1
a1249 1
	return FALSE;
d1266 1
a1266 1
		    return FALSE;
d1307 1
a1307 1
		    return FALSE;
d1318 1
a1318 1
		return FALSE;
d1337 1
a1337 1
	return FALSE;
d1351 1
a1351 1
  return TRUE;
d1354 1
a1354 1
bfd_boolean
d1365 1
a1365 1
    return FALSE;
d1372 1
a1372 1
	    return FALSE;
d1392 1
a1392 1
			return FALSE;
d1401 1
a1401 1
			    return FALSE;
d1411 1
a1411 1
  return TRUE;
d1588 1
a1588 1
bfd_boolean
d1597 1
a1597 1
    return TRUE;
d1605 1
a1605 1
    return FALSE;
d1612 1
a1612 1
      return FALSE;
d1617 1
a1617 1
  return TRUE;
d1692 1
a1692 1
bfd_boolean
d1708 1
a1708 1
  return TRUE;
d1780 1
a1780 1
  obj_coff_keep_strings (abfd) = TRUE;
d1912 1
a1912 1
  new->done_lineno = FALSE;
d1938 1
a1938 1
  new->done_lineno = FALSE;
d1960 1
a1960 1
bfd_boolean
d1972 1
a1972 1
      return FALSE;
d1983 1
a1983 1
  return TRUE;
d1988 1
a1988 1
bfd_boolean
d2005 1
a2005 1
      return FALSE;
d2027 1
a2027 1
  return TRUE;
d2194 1
a2194 1
bfd_boolean
d2206 1
a2206 1
bfd_boolean
d2217 1
a2217 1
  bfd_boolean found;
d2234 1
a2234 1
    return FALSE;
d2237 1
a2237 1
    return TRUE;
d2244 1
a2244 1
    return TRUE;
d2252 1
a2252 1
    return FALSE;
d2255 1
a2255 1
    return FALSE;
d2260 1
a2260 1
    return FALSE;
d2413 1
a2413 1
  return TRUE;
d2419 1
a2419 1
     bfd_boolean reloc;
d2437 1
a2437 1
bfd_boolean
d2449 1
a2449 1
      return FALSE;
d2463 1
a2463 1
	return FALSE;
d2499 1
a2499 1
  return TRUE;
@


1.34.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d2199 1
a2199 1
  return (boolean) (name[0] == '.' && name[1] == 'L');
@


1.34.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d49 1
a49 1
static bfd_boolean coff_write_symbol
d52 1
a52 1
static bfd_boolean coff_write_alien_symbol
d55 1
a55 1
static bfd_boolean coff_write_native_symbol
d61 1
a61 1
static bfd_boolean make_a_section_from_file
d77 1
a77 1
static bfd_boolean
d85 1
a85 1
  bfd_boolean result = TRUE;
d106 1
a106 1
	    return FALSE;
d113 1
a113 1
	    return FALSE;
d123 1
a123 1
	return FALSE;
d130 1
a130 1
    return FALSE;
d150 1
a150 1
    result = FALSE;
d426 1
a426 1
   relocs for section SEC in file ABFD.  If CACHE is TRUE and
d431 1
a431 1
   the swapped relocs.  If REQUIRE_INTERNAL is TRUE, then the return
d439 1
a439 1
     bfd_boolean cache;
d441 1
a441 1
     bfd_boolean require_internal;
d568 1
a568 1

d659 1
a659 1
bfd_boolean
d688 1
a688 1
      return FALSE;
d751 1
a751 1
  return TRUE;
d946 1
a946 1
static bfd_boolean
d991 1
a991 1
    return FALSE;
d994 1
a994 1
    return FALSE;
d1005 1
a1005 1
	return FALSE;
d1016 1
a1016 1
	    return FALSE;
d1025 1
a1025 1
  return TRUE;
d1032 1
a1032 1
static bfd_boolean
d1065 1
a1065 1
      return TRUE;
d1100 1
a1100 1
static bfd_boolean
d1156 1
a1156 1
      symbol->done_lineno = TRUE;
d1170 1
a1170 1
bfd_boolean
d1206 1
a1206 1
    return FALSE;
d1222 1
a1222 1
	    return FALSE;
d1229 1
a1229 1
	    return FALSE;
d1249 1
a1249 1
	return FALSE;
d1266 1
a1266 1
		    return FALSE;
d1307 1
a1307 1
		    return FALSE;
d1318 1
a1318 1
		return FALSE;
d1337 1
a1337 1
	return FALSE;
d1351 1
a1351 1
  return TRUE;
d1354 1
a1354 1
bfd_boolean
d1365 1
a1365 1
    return FALSE;
d1372 1
a1372 1
	    return FALSE;
d1392 1
a1392 1
			return FALSE;
d1401 1
a1401 1
			    return FALSE;
d1411 1
a1411 1
  return TRUE;
d1588 1
a1588 1
bfd_boolean
d1597 1
a1597 1
    return TRUE;
d1605 1
a1605 1
    return FALSE;
d1612 1
a1612 1
      return FALSE;
d1617 1
a1617 1
  return TRUE;
d1692 1
a1692 1
bfd_boolean
d1708 1
a1708 1
  return TRUE;
d1780 1
a1780 1
  obj_coff_keep_strings (abfd) = TRUE;
d1912 1
a1912 1
  new->done_lineno = FALSE;
d1938 1
a1938 1
  new->done_lineno = FALSE;
d1960 1
a1960 1
bfd_boolean
d1972 1
a1972 1
      return FALSE;
d1983 1
a1983 1
  return TRUE;
d1988 1
a1988 1
bfd_boolean
d2005 1
a2005 1
      return FALSE;
d2027 1
a2027 1
  return TRUE;
d2194 1
a2194 1
bfd_boolean
d2199 1
a2199 1
  return name[0] == '.' && name[1] == 'L';
d2206 1
a2206 1
bfd_boolean
d2217 1
a2217 1
  bfd_boolean found;
d2234 1
a2234 1
    return FALSE;
d2237 1
a2237 1
    return TRUE;
d2244 1
a2244 1
    return TRUE;
d2252 1
a2252 1
    return FALSE;
d2255 1
a2255 1
    return FALSE;
d2260 1
a2260 1
    return FALSE;
d2413 1
a2413 1
  return TRUE;
d2419 1
a2419 1
     bfd_boolean reloc;
d2437 1
a2437 1
bfd_boolean
d2449 1
a2449 1
      return FALSE;
d2463 1
a2463 1
	return FALSE;
d2499 1
a2499 1
  return TRUE;
@


1.34.10.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d229 1
a229 1
  /* Now copy data as required; construct all asections etc.  */
d243 2
@


1.34.10.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d332 1
a332 1
  struct bfd_section *answer = abfd->sections;
d368 1
a368 1
coff_canonicalize_symtab (abfd, alocation)
@


1.33
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d181 1
d210 1
d213 1
a213 1
    return 0;
d250 2
d277 1
a277 1
    return 0;
d282 2
a283 1
      return 0;
d300 1
a300 1
      return 0;
d310 1
a310 1
	return 0;
d314 2
a315 1
	  return 0;
d318 1
@


1.33.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a180 1
  PTR tdata_save;
a208 1
  tdata_save = abfd->tdata.any;
d211 1
a211 1
    goto fail2;
a247 2
 fail2:
  abfd->tdata.any = tdata_save;
d273 1
a273 1
    return NULL;
d278 1
a278 2
      bfd_release (abfd, filehdr);
      return NULL;
d295 1
a295 1
      return NULL;
d305 1
a305 1
	return NULL;
d309 1
a309 2
	  bfd_release (abfd, opthdr);
	  return NULL;
a311 1
      bfd_release (abfd, opthdr);
@


1.33.2.2
log
@Merge from mainline.
@
text
@d2199 1
a2199 1
  return (boolean) (name[0] == '.' && name[1] == 'L');
@


1.32
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d224 1
a224 1
  if (bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f) == false)
d291 1
a291 1
  if (bfd_coff_bad_format_hook (abfd, &internal_f) == false
d2416 1
a2416 1
  if (reloc == false)
@


1.31
log
@Don't mark info message for translation.
@
text
@d3 1
a3 1
   2000, 2001
d1441 2
a1442 1
      f = (struct foo *) bfd_alloc (abfd, (bfd_size_type) sizeof (*f));
a1447 1
      memset ((char *) f, 0, sizeof (*f));
d1838 1
a1838 1
	      newstring = (PTR) bfd_alloc (abfd, (bfd_size_type) (i + 1));
a1840 1
	      memset (newstring, 0, i + 1);
d1899 1
a1899 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, amt);
a1901 1
  memset (new, 0, sizeof *new);
d2454 1
a2454 1
      native = (combined_entry_type *) bfd_alloc (abfd, amt);
a2456 2

      memset (native, 0, sizeof (* native));
@


1.31.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d1441 1
a1441 2

      f = (struct foo *) bfd_zalloc (abfd, (bfd_size_type) sizeof (*f));
d1447 1
d1838 1
a1838 1
	      newstring = (PTR) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
d1841 1
d1900 1
a1900 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_zalloc (abfd, amt);
d1903 1
d2456 1
a2456 1
      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d2459 2
@


1.31.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d224 1
a224 1
  if (! bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f))
d291 1
a291 1
  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
d2416 1
a2416 1
  if (! reloc)
@


1.31.10.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a180 1
  PTR tdata_save;
a208 1
  tdata_save = abfd->tdata.any;
d211 1
a211 1
    goto fail2;
a247 2
 fail2:
  abfd->tdata.any = tdata_save;
d273 1
a273 1
    return NULL;
d278 1
a278 2
      bfd_release (abfd, filehdr);
      return NULL;
d295 1
a295 1
      return NULL;
d305 1
a305 1
	return NULL;
d309 1
a309 2
	  bfd_release (abfd, opthdr);
	  return NULL;
a311 1
      bfd_release (abfd, opthdr);
@


1.31.10.4
log
@merge from mainline
@
text
@d2199 1
a2199 1
  return (boolean) (name[0] == '.' && name[1] == 'L');
@


1.31.8.1
log
@merge from trunk
@
text
@d3 1
a3 1
   2000, 2001, 2002
d1441 1
a1441 2

      f = (struct foo *) bfd_zalloc (abfd, (bfd_size_type) sizeof (*f));
d1447 1
d1838 1
a1838 1
	      newstring = (PTR) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
d1841 1
d1900 1
a1900 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_zalloc (abfd, amt);
d1903 1
d2456 1
a2456 1
      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d2459 2
@


1.30
log
@Define and use bfd_is_const_section().
@
text
@d2138 1
a2138 1
			       _("AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld"),
@


1.29
log
@Add comment
@
text
@d558 1
a558 4
	      ++q->symbol.section->output_section->lineno_count;
	      ++total;
	      ++l;
	      while (l->line_number != 0)
d560 6
a566 1
		  ++q->symbol.section->output_section->lineno_count;
d569 1
d1151 3
a1153 2
      symbol->symbol.section->output_section->moving_line_filepos +=
	count * bfd_coff_linesz (abfd);
@


1.28
log
@2001-11-02  H.J. Lu  (hjl@@gnu.org)

	* coffgen.c (coff_object_p): Return 0 if the header is too big.
@
text
@d283 8
d305 1
a305 1
	return 0;;
@


1.27
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d283 2
a284 1
  if (bfd_coff_bad_format_hook (abfd, &internal_f) == false)
@


1.26
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d1057 1
a1057 1
      /* Copy the any flags from the the file header into the symbol.
d2471 1
a2471 1
	  /* Copy the any flags from the the file header into the symbol.
@


1.25
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1648 1
a1648 1
	(_("%s: bad string table size %lu"), bfd_get_filename (abfd),
@


1.24
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d71 1
a71 1
  PARAMS ((bfd *, char *, int));
d111 1
a111 1
	  name = bfd_alloc (abfd, strlen (strings) + 1);
d121 1
a121 1
      name = bfd_alloc (abfd, sizeof (hdr->s_name) + 1);
d151 1
a151 1
  
d181 1
a181 1
  size_t readsize;		/* length of file_info */
d214 1
a214 1
  readsize = nscns * scnhsz;
d219 1
a219 1
  if (bfd_read ((PTR) external_sections, 1, readsize, abfd) != readsize)
d260 3
a262 3
  unsigned int filhsz;
  unsigned int aoutsz;
  int nscns;
d274 1
a274 1
  if (bfd_read (filehdr, 1, filhsz, abfd) != filhsz)
d297 1
a297 1
      if (bfd_read (opthdr, 1, internal_f.f_opthdr, abfd)
d434 1
d448 1
d451 1
a451 1
      free_external = (bfd_byte *) bfd_malloc (sec->reloc_count * relsz);
d458 1
a458 2
      || (bfd_read (external_relocs, relsz, sec->reloc_count, abfd)
	  != relsz * sec->reloc_count))
d463 3
a465 3
      free_internal = ((struct internal_reloc *)
		       bfd_malloc (sec->reloc_count
				   * sizeof (struct internal_reloc)));
d488 2
a489 3
	  sec->used_by_bfd =
	    (PTR) bfd_zalloc (abfd,
			      sizeof (struct coff_section_tdata));
d664 1
d666 2
a667 2
    newsyms = (asymbol **) bfd_alloc (bfd_ptr,
				      sizeof (asymbol *) * (symbol_count + 1));
d760 2
a761 2
	      s->u.syment.n_value = 
		(bfd_vma)((combined_entry_type *) 
d880 1
a880 1
	  long filepos;
d893 1
a893 1
	    bfd_put_32 (abfd, name_length + 1, buf);
d895 1
a895 1
	    bfd_put_16 (abfd, name_length + 1, buf);
d905 2
a906 2
					    ((file_ptr) *debug_string_size_p
					     + prefix_len),
d974 1
a974 1
  if (bfd_write (buf, 1, symesz, abfd) != symesz)
d993 1
a993 1
				 j,
d996 1
a996 1
	  if (bfd_write (buf, 1, auxesz, abfd) != auxesz)
d1223 1
a1223 1
      bfd_h_put_32 (abfd, size, buffer);
d1225 1
a1225 1
 #error Change bfd_h_put_32
d1227 2
a1228 1
      if (bfd_write ((PTR) buffer, 1, sizeof (buffer), abfd) != sizeof (buffer))
d1244 2
a1245 1
		  if (bfd_write (o->name, 1, len + 1, abfd) != len + 1)
d1285 4
a1288 1
      		bfd_write (".file", 1, 6, abfd);
d1296 2
a1297 2
	      if (bfd_write ((PTR) (q->name), 1, name_length + 1, abfd)
		  != name_length + 1)
d1311 1
a1311 1
      bfd_h_put_32 (abfd, size, buffer);
d1313 1
a1313 1
 #error Change bfd_h_put_32
d1315 1
a1315 1
      if (bfd_write ((PTR) buffer, 1, STRING_SIZE_SIZE, abfd)
d1370 2
a1371 1
		      if (bfd_write (buff, 1, linesz, abfd) != linesz)
d1379 2
a1380 1
			  if (bfd_write (buff, 1, linesz, abfd) != linesz)
d1428 1
a1428 1
      f = (struct foo *) bfd_alloc (abfd, sizeof (*f));
d1511 2
a1512 1
  long position;
d1522 2
a1523 2
  debug_section = (PTR) bfd_alloc (abfd,
				   bfd_get_section_size_before_reloc (sect));
d1533 1
a1533 3
      || (bfd_read (debug_section,
		    bfd_get_section_size_before_reloc (sect), 1, abfd)
	  != bfd_get_section_size_before_reloc (sect))
d1546 1
a1546 1
     int maxlen;
d1548 1
a1548 1
  int len;
d1559 1
a1559 1
  if ((newname = (PTR) bfd_alloc (abfd, len + 1)) == NULL)
d1573 1
a1573 1
  size_t size;
d1588 1
a1588 1
      || bfd_read (syms, size, 1, abfd) != size)
d1609 1
a1609 1
  size_t strsize;
d1611 1
d1622 3
a1624 4
  if (bfd_seek (abfd,
		(obj_sym_filepos (abfd)
		 + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd)),
		SEEK_SET) != 0)
d1627 2
a1628 1
  if (bfd_read (extstrsize, sizeof extstrsize, 1, abfd) != sizeof extstrsize)
d1639 1
a1639 1
      strsize = bfd_h_get_32 (abfd, (bfd_byte *) extstrsize);
d1641 1
a1641 1
 #error Change bfd_h_get_32
d1658 1
a1658 2
  if (bfd_read (strings + STRING_SIZE_SIZE,
		strsize - STRING_SIZE_SIZE, 1, abfd)
d1704 1
a1704 1
  bfd_size_type symesz;
d1709 1
a1709 1
  unsigned long size;
d1752 1
a1752 1
				i, symbol_ptr->u.syment.n_numaux,
d1807 1
a1807 1
				bfd_coff_filnmlen (abfd)));
d1816 2
a1817 2
	      unsigned long i = 0;
	      char *newstring = NULL;
d1822 2
a1823 6
		{
		  if (internal_ptr->u.syment._n._n_name[i] == '\0')
		    {
		      break;
		    }		/* if end of string */
		}		/* possible lengths of this string.  */
d1825 2
a1826 1
	      if ((newstring = (PTR) bfd_alloc (abfd, ++i)) == NULL)
d1828 2
a1829 2
	      memset (newstring, 0, i);
	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i - 1);
d1886 2
a1887 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, sizeof (coff_symbol_type));
d1907 2
a1908 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, sizeof (coff_symbol_type));
d1913 2
a1914 1
  new->native = (combined_entry_type *) bfd_zalloc (abfd, sizeof (combined_entry_type) * 10);
d1960 1
a1960 1
    psyment->n_value = psyment->n_value - 
d2195 2
a2196 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d2208 1
d2383 2
a2384 3
      section->used_by_bfd =
	((PTR) bfd_zalloc (abfd,
			   sizeof (struct coff_section_tdata)));
d2441 1
d2443 1
a2443 1
      native = (combined_entry_type *) bfd_alloc (abfd, sizeof (* native));
@


1.23
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d2154 1
a2154 1
	  bfd_print_symbol_vandf ((PTR) file, symbol);
@


1.22
log
@Chnage styp_flags_to_sec_flags() to a boolean function
@
text
@d2109 8
d2119 2
a2120 8
			       tagndx,
			       auxp->u.auxent.x_sym.x_misc.x_fsize,
			       auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr,
			       (auxp->fix_end
				? ((long)
				   (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
				    - root))
				: auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l));
d2285 1
a2285 1
	  if (p - cof->raw_syments >= p->u.syment.n_value)
@


1.21
log
@Support for xcoff64
@
text
@d85 2
d147 6
a152 2
  return_section->flags = bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name,
							   return_section);
d164 2
a165 1
  return true;
@


1.20
log
@Update copyright notices
@
text
@d50 1
a50 1
  PARAMS ((bfd *, asymbol *, combined_entry_type *, unsigned int *,
d53 1
a53 1
  PARAMS ((bfd *, asymbol *, unsigned int *, bfd_size_type *,
d56 1
a56 1
  PARAMS ((bfd *, coff_symbol_type *, unsigned int *, bfd_size_type *,
d752 3
a754 2
	      s->u.syment.n_value =
		((combined_entry_type *) s->u.syment.n_value)->offset;
d925 1
a925 1
     unsigned int *written;
d1010 1
a1010 1
     unsigned int *written;
d1078 1
a1078 1
     unsigned int *written;
d1151 1
a1151 1
  unsigned int written = 0;
d1921 2
a1922 5
      combined_entry_type *psym;

      psym = ((combined_entry_type *)
	      coffsymbol (symbol)->native->u.syment.n_value);
      ret->value = (bfd_vma) (psym - obj_raw_syments (abfd));
d1946 2
a1947 2
    psyment->n_value = ((combined_entry_type *) psyment->n_value
			- obj_raw_syments (abfd));
d2024 1
a2024 1
	  unsigned long val;
d2033 1
a2033 1
	    val = (unsigned long) combined->u.syment.n_value;
d2035 1
a2035 3
	    val = ((unsigned long)
		   ((combined_entry_type *) combined->u.syment.n_value
		    - root));
d2037 1
d2045 11
d2058 1
@


1.19
log
@If stabs info is successfully found, do not attempt to find dwarf2 info
before returning.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999, 2000
@


1.18
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2191 3
a2198 3
    return true;

if (found)
@


1.18.2.1
log
@If stabs info is successfully found, do not attempt to find dwarf2 info
before returning.
@
text
@a2190 3
  if (found)
    return true;

d2196 3
@


1.18.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.17
log
@Generalize DWARF2 and COFF support.
@
text
@a2457 1

@


1.16
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@d2188 1
a2188 1
					     &coff_data (abfd)->line_info))
d2190 9
a2198 1
  if (found)
@


1.15
log
@2000-11-27  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
@
text
@a559 1
/*ARGSUSED*/
a1376 1
/*ARGSUSED */
a1908 1
/*ARGSUSED */
d2161 1
a2161 1
/*ARGSUSED*/
@


1.14
log
@	* bfd-in.h (bfd_family_coff): Define.
	* bfd-in2.h: Regenerate.
	* coffgen.c (coff_count_linenumbers, coff_symbol_from,
	coff_find_nearest_line): Check COFFness using bfd_family_coff()
	instead of bfd_target_coff_flavour.
	* cofflink.c (_bfd_coff_final_link): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Don't strcmp() target name to
	exclude XCOFF files.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Likewise.
	* targets.c (enum bfd_flavour): Add bfd_target_xcoff_flavour.
	* xcoff-target.h (TARGET_SYM): Use bfd_target_xcoff_flavour.
	* xcofflink.c (XCOFF_XVECP): Delete.
	(bfd_xcoff_link_record_set, bfd_xcoff_import_symbol,
	bfd_xcoff_export_symbol, bfd_xcoff_link_count_reloc,
	bfd_xcoff_record_link_assignment,
	bfd_xcoff_size_dynamic_sections): Replace XCOFF_XVECP() with
	check for bfd_target_xcoff_flavour.
@
text
@d63 1
a63 1
  PARAMS ((bfd *, unsigned, struct internal_filehdr *, 
d215 1
a215 1
     may depend on arch/mach info. */
a342 1

d694 1
a694 1
      symbol_ptr_ptr[symbol_index]->udata.i = symbol_index; 
d823 1
a823 1
          native->u.syment._n._n_n._n_offset = 
d902 1
a902 1
	  native->u.syment._n._n_n._n_offset = 
d1105 1
a1105 1
	  /* 13 april 92. sac 
d1273 1
a1273 1
	      if (bfd_coff_force_symnames_in_strings (abfd)) 
d1489 1
a1489 1
   we didn't want to go to the trouble until someone needed it. */
d1511 1
a1511 1
  /* Seek to the beginning of the `.debug' section and read it. 
a1524 1

d1612 1
a1612 1
    
d1813 1
a1813 1
		}		/* possible lengths of this string. */
d2408 1
a2408 1
      
d2416 1
a2416 1
      
d2419 1
a2419 1
      
d2438 1
a2438 1
	  
d2443 1
a2443 1
      
d2450 1
a2450 1
  
@


1.13
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@d528 1
a528 1
      if (bfd_asymbol_flavour (q_maybe) == bfd_target_coff_flavour)
d567 1
a567 1
  if (bfd_asymbol_flavour (symbol) != bfd_target_coff_flavour)
d2203 1
a2203 1
  if (abfd->xvec->flavour != bfd_target_coff_flavour)
@


1.12
log
@SEC_BLOCK, SEC_CLINK, and C_STATLAB added (TI COFF support).
@
text
@d822 10
a831 1
      strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);
d858 1
a858 1
      if (name_length <= SYMNMLEN)
d873 2
a874 1
	  bfd_byte buf[2];
d884 5
a888 1
	  bfd_put_16 (abfd, name_length + 1, buf);
d893 1
a893 1
					 (bfd_size_type) 2)
d898 1
a898 1
					     + 2),
d903 2
a904 1
	  native->u.syment._n._n_n._n_offset = *debug_string_size_p + 2;
d906 1
a906 1
	  *debug_string_size_p += name_length + 3;
d1262 1
a1262 1
	      maxlen = SYMNMLEN;
d1273 5
a1277 1
	    maxlen = bfd_coff_filnmlen (abfd);
d1279 1
a1279 1
	    maxlen = SYMNMLEN;
@


1.11
log
@Set arch/mach info prior to swapping in sections, so that the swapping
routines have access to the arch/mach info.
@
text
@d611 5
a615 2
	    syment->n_value +=
	      coff_symbol_ptr->symbol.section->output_section->vma;
@


1.10
log
@Apply Tim walls octest vs bytes patch
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d214 5
a234 3

  if (bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f) == false)
    goto fail;
@


1.9
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffgen.c (coff_print_symbol): Fix printing of aux record for
	function symbols.
@
text
@d2139 3
a2141 4
/* Provided a BFD, a section and an offset into the section, calculate
   and return the name of the source file and the line nearest to the
   wanted location.  */

@


1.8
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* syms.c (BSF_DEBUGGING_RELOC): Define.
	* coffgen.c (fixup_symbol_value): Relocate a symbol which has
	BSF_DEBUGGING_RELOC set.
	* bfd-in2.h: Rebuild.
@
text
@d2069 16
a2085 1

@


1.7
log
@	* coffcode.h (bfd_coff_backend_data): Add _bfd_filnmlen field.
	(bfd_coff_filnmlen): Define.
	(bfd_coff_std_swap_table): Initialize new field.
	* coffgen.c (coff_fix_symbol_name): Use bfd_coff_filnmlen rather
	than FILNMLEN.
	(coff_write_symbols): Likewise.
	(coff_get_normalized_symtab): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize new field.
	* libcoff.h: Rebuild.
@
text
@d588 2
a589 1
  else if (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING)
@


1.6
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* coffcode.h (sec_to_styp_flags): Write separate COFF_WITH_PE
	version.  Move COFF_WITH_PE specific code to new version.
	(stype_to_sec_flags): Likewise.  Add section parameter.
	* coffgen.c (make_a_section_from_file): Set target_index before
	calling styp_to_sec_flags.  Pass section to styp_to_sec_flags.
	* libcoff.h: Rebuild.
@
text
@d814 2
d819 2
d823 1
a823 1
	  if (name_length <= FILNMLEN)
d825 1
a825 1
	      strncpy (auxent->x_file.x_fname, name, FILNMLEN);
d836 3
a838 5
	  strncpy (auxent->x_file.x_fname, name, FILNMLEN);
	  if (name_length > FILNMLEN)
	    {
	      name[FILNMLEN] = '\0';
	    }
d1252 1
a1252 1
	    maxlen = FILNMLEN;
d1770 1
a1770 1
				FILNMLEN));
@


1.5
log
@comment changes from Donn Terry, and indentation changes
@
text
@a142 2
  return_section->flags = bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name);

d144 2
@


1.4
log
@1999-08-09  Eli Zaretskii  <eliz@@is.elta.co.il>

	* coffgen.c (coff_find_nearest_line): When looking for file, use
	last best match rather than first.  If address is beyond last line
	number record, don't return the last line as the correct value.
@
text
@d597 1
d1750 3
a1752 1
	      /* ordinary short filename, put into memory anyway */
d1756 5
a1760 3
		  internal_ptr->u.syment._n._n_n._n_offset = (long)
		    copy_name (abfd, (internal_ptr + 1)->u.auxent.x_file.x_fname,
			       internal_ptr->u.syment.n_numaux * symesz);
d1764 5
a1768 3
		  internal_ptr->u.syment._n._n_n._n_offset = (long)
		    copy_name (abfd, (internal_ptr + 1)->u.auxent.x_file.x_fname,
			       FILNMLEN);
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d2203 2
d2207 1
a2207 1
	      && offset + sec_vma - (bfd_vma) p2->u.syment.n_value < maxdiff)
d2244 2
d2257 1
d2285 14
@


1.2
log
@	* ecoff.c (_bfd_ecoff_write_armap): give the symtab element a
	reasonable mode until "ar x" is smart enough to skip it (fixes
	gcc/libgcc.a builds on mips-ecoff targets
	* coffcode.h (styp_to_sec_flags): Explain how COMDATs are supposed
	to work.  Hack to support MS import libraries, which use different
	COMDAT types than GNU.
	(coff_slurp_symbol_table): C_SECTION symbols are local; they refer
	to implied zero-length sections (see peicode below)
	* coffgen.c (coff_get_normalized_symtab): Properly read long MS
	filename symbols, which use one *or more* auxents.
	* coffswap.h (coff_swap_aux_in): ditto
	* peicode.h (coff_swap_sym_in): Build the implied zero-length
	sections
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d562 1
a562 1
     bfd *ignore_abfd;
d1354 1
a1354 1
     bfd *ignore_abfd;
d1860 2
a1861 2
     PTR ptr;
     unsigned long sz;
d2108 1
a2108 1
     bfd *abfd;
@


1.1
log
@Initial revision
@
text
@d1750 13
a1762 3
	      internal_ptr->u.syment._n._n_n._n_offset = (long)
		copy_name (abfd, (internal_ptr + 1)->u.auxent.x_file.x_fname,
			   FILNMLEN);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

