head	1.28;
access;
symbols
	sid-snapshot-20180601:1.28
	sid-snapshot-20180501:1.28
	sid-snapshot-20180401:1.28
	sid-snapshot-20180301:1.28
	sid-snapshot-20180201:1.28
	sid-snapshot-20180101:1.28
	sid-snapshot-20171201:1.28
	sid-snapshot-20171101:1.28
	sid-snapshot-20171001:1.28
	sid-snapshot-20170901:1.28
	sid-snapshot-20170801:1.28
	sid-snapshot-20170701:1.28
	sid-snapshot-20170601:1.28
	sid-snapshot-20170501:1.28
	sid-snapshot-20170401:1.28
	sid-snapshot-20170301:1.28
	sid-snapshot-20170201:1.28
	sid-snapshot-20170101:1.28
	sid-snapshot-20161201:1.28
	sid-snapshot-20161101:1.28
	sid-snapshot-20160901:1.28
	sid-snapshot-20160801:1.28
	sid-snapshot-20160701:1.28
	sid-snapshot-20160601:1.28
	sid-snapshot-20160501:1.28
	sid-snapshot-20160401:1.28
	sid-snapshot-20160301:1.28
	sid-snapshot-20160201:1.28
	sid-snapshot-20160101:1.28
	sid-snapshot-20151201:1.28
	sid-snapshot-20151101:1.28
	sid-snapshot-20151001:1.28
	sid-snapshot-20150901:1.28
	sid-snapshot-20150801:1.28
	sid-snapshot-20150701:1.28
	sid-snapshot-20150601:1.28
	sid-snapshot-20150501:1.28
	sid-snapshot-20150401:1.28
	sid-snapshot-20150301:1.28
	sid-snapshot-20150201:1.28
	sid-snapshot-20150101:1.28
	sid-snapshot-20141201:1.28
	sid-snapshot-20141101:1.28
	sid-snapshot-20141001:1.28
	sid-snapshot-20140901:1.28
	sid-snapshot-20140801:1.28
	sid-snapshot-20140701:1.28
	sid-snapshot-20140601:1.28
	sid-snapshot-20140501:1.28
	sid-snapshot-20140401:1.28
	sid-snapshot-20140301:1.28
	sid-snapshot-20140201:1.28
	sid-snapshot-20140101:1.28
	sid-snapshot-20131201:1.28
	sid-snapshot-20131101:1.28
	sid-snapshot-20131001:1.28
	binutils-2_24-branch:1.28.0.4
	binutils-2_24-branchpoint:1.28
	binutils-2_21_1:1.25
	sid-snapshot-20130901:1.28
	gdb_7_6_1-2013-08-30-release:1.28
	sid-snapshot-20130801:1.28
	sid-snapshot-20130701:1.28
	sid-snapshot-20130601:1.28
	sid-snapshot-20130501:1.28
	gdb_7_6-2013-04-26-release:1.28
	sid-snapshot-20130401:1.28
	binutils-2_23_2:1.27
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	sid-snapshot-20130301:1.28
	sid-snapshot-20130201:1.27
	sid-snapshot-20130101:1.27
	sid-snapshot-20121201:1.27
	gdb_7_5_1-2012-11-29-release:1.27
	binutils-2_23_1:1.27
	sid-snapshot-20121101:1.27
	binutils-2_23:1.27
	sid-snapshot-20121001:1.27
	sid-snapshot-20120901:1.27
	gdb_7_5-2012-08-17-release:1.27
	sid-snapshot-20120801:1.27
	binutils-2_23-branch:1.27.0.4
	binutils-2_23-branchpoint:1.27
	gdb_7_5-branch:1.27.0.2
	gdb_7_5-2012-07-18-branchpoint:1.27
	sid-snapshot-20120701:1.26
	sid-snapshot-20120601:1.26
	sid-snapshot-20120501:1.26
	binutils-2_22_branch:1.26.0.6
	gdb_7_4_1-2012-04-26-release:1.26
	sid-snapshot-20120401:1.26
	sid-snapshot-20120301:1.26
	sid-snapshot-20120201:1.26
	gdb_7_4-2012-01-24-release:1.26
	sid-snapshot-20120101:1.26
	gdb_7_4-branch:1.26.0.4
	gdb_7_4-2011-12-13-branchpoint:1.26
	sid-snapshot-20111201:1.26
	binutils-2_22:1.26
	sid-snapshot-20111101:1.26
	sid-snapshot-20111001:1.26
	binutils-2_22-branch:1.26.0.2
	binutils-2_22-branchpoint:1.26
	gdb_7_3_1-2011-09-04-release:1.25
	sid-snapshot-20110901:1.26
	sid-snapshot-20110801:1.26
	gdb_7_3-2011-07-26-release:1.25
	sid-snapshot-20110701:1.26
	sid-snapshot-20110601:1.25
	sid-snapshot-20110501:1.25
	gdb_7_3-branch:1.25.0.8
	gdb_7_3-2011-04-01-branchpoint:1.25
	sid-snapshot-20110401:1.25
	sid-snapshot-20110301:1.25
	sid-snapshot-20110201:1.25
	sid-snapshot-20110101:1.25
	binutils-2_21:1.25
	sid-snapshot-20101201:1.25
	binutils-2_21-branch:1.25.0.6
	binutils-2_21-branchpoint:1.25
	sid-snapshot-20101101:1.25
	sid-snapshot-20101001:1.25
	binutils-2_20_1:1.24
	gdb_7_2-2010-09-02-release:1.25
	sid-snapshot-20100901:1.25
	sid-snapshot-20100801:1.25
	gdb_7_2-branch:1.25.0.4
	gdb_7_2-2010-07-07-branchpoint:1.25
	sid-snapshot-20100701:1.25
	sid-snapshot-20100601:1.25
	sid-snapshot-20100501:1.25
	sid-snapshot-20100401:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.2
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.24
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.24
	gdb_7_0-2009-10-06-release:1.24
	sid-snapshot-20091001:1.24
	gdb_7_0-branch:1.24.0.4
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.23
	binutils-arc-20081103-branch:1.23.0.26
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.24.0.2
	binutils-2_20-branchpoint:1.24
	sid-snapshot-20090901:1.23
	sid-snapshot-20090801:1.23
	msnyder-checkpoint-072509-branch:1.23.0.24
	msnyder-checkpoint-072509-branchpoint:1.23
	sid-snapshot-20090701:1.23
	dje-cgen-play1-branch:1.23.0.22
	dje-cgen-play1-branchpoint:1.23
	sid-snapshot-20090601:1.23
	sid-snapshot-20090501:1.23
	sid-snapshot-20090401:1.23
	arc-20081103-branch:1.23.0.20
	arc-20081103-branchpoint:1.23
	arc-insight_6_8-branch:1.23.0.18
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.16
	insight_6_8-branchpoint:1.23
	sid-snapshot-20090301:1.23
	binutils-2_19_1:1.23
	sid-snapshot-20090201:1.23
	sid-snapshot-20090101:1.23
	reverse-20081226-branch:1.23.0.14
	reverse-20081226-branchpoint:1.23
	sid-snapshot-20081201:1.23
	multiprocess-20081120-branch:1.23.0.12
	multiprocess-20081120-branchpoint:1.23
	sid-snapshot-20081101:1.23
	binutils-2_19:1.23
	sid-snapshot-20081001:1.23
	reverse-20080930-branch:1.23.0.10
	reverse-20080930-branchpoint:1.23
	binutils-2_19-branch:1.23.0.8
	binutils-2_19-branchpoint:1.23
	sid-snapshot-20080901:1.23
	sid-snapshot-20080801:1.23
	reverse-20080717-branch:1.23.0.6
	reverse-20080717-branchpoint:1.23
	sid-snapshot-20080701:1.23
	msnyder-reverse-20080609-branch:1.23.0.4
	msnyder-reverse-20080609-branchpoint:1.23
	drow-reverse-20070409-branch:1.20.0.4
	drow-reverse-20070409-branchpoint:1.20
	sid-snapshot-20080601:1.23
	sid-snapshot-20080501:1.23
	sid-snapshot-20080403:1.23
	sid-snapshot-20080401:1.23
	gdb_6_8-2008-03-27-release:1.23
	sid-snapshot-20080301:1.23
	gdb_6_8-branch:1.23.0.2
	gdb_6_8-2008-02-26-branchpoint:1.23
	sid-snapshot-20080201:1.22
	sid-snapshot-20080101:1.22
	sid-snapshot-20071201:1.22
	sid-snapshot-20071101:1.22
	gdb_6_7_1-2007-10-29-release:1.22
	gdb_6_7-2007-10-10-release:1.22
	sid-snapshot-20071001:1.22
	gdb_6_7-branch:1.22.0.4
	gdb_6_7-2007-09-07-branchpoint:1.22
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	insight_6_6-20070208-release:1.20
	binutils-csl-coldfire-4_1-32:1.18
	binutils-csl-sourcerygxx-4_1-32:1.18
	gdb_6_6-2006-12-18-release:1.20
	binutils-csl-innovasic-fido-3_4_4-33:1.18
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.18
	binutils-csl-sourcerygxx-4_1-30:1.18
	binutils-csl-coldfire-4_1-28:1.18
	binutils-csl-sourcerygxx-4_1-29:1.18
	binutils-csl-sourcerygxx-4_1-28:1.18
	gdb_6_6-branch:1.20.0.2
	gdb_6_6-2006-11-15-branchpoint:1.20
	binutils-csl-arm-2006q3-27:1.18
	binutils-csl-sourcerygxx-4_1-27:1.18
	binutils-csl-arm-2006q3-26:1.18
	binutils-csl-sourcerygxx-4_1-26:1.18
	binutils-csl-sourcerygxx-4_1-25:1.18
	binutils-csl-sourcerygxx-4_1-24:1.18
	binutils-csl-sourcerygxx-4_1-23:1.18
	insight_6_5-20061003-release:1.18
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.18
	binutils-csl-arm-2006q3-21:1.18
	binutils-csl-sourcerygxx-4_1-22:1.18
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18
	binutils-csl-sourcerygxx-4_1-20:1.18
	binutils-csl-arm-2006q3-19:1.18
	binutils-csl-sourcerygxx-4_1-19:1.18
	binutils-csl-sourcerygxx-4_1-18:1.18
	binutils-csl-renesas-4_1-9:1.18
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.18
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.18
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.18
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	gdb_6_5-20060621-release:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.18
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.18
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.18
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.18
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.15
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.18
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.18.0.14
	gdb_6_5-2006-05-14-branchpoint:1.18
	binutils-csl-coldfire-4_1-10:1.18
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.18
	nickrob-async-20060513-branch:1.18.0.12
	nickrob-async-20060513-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.18
	msnyder-reverse-20060502-branch:1.18.0.10
	msnyder-reverse-20060502-branchpoint:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.15
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.18
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.15
	readline_5_1-import-branch:1.18.0.8
	readline_5_1-import-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.18.0.6
	binutils-2_17-branchpoint:1.18
	gdb-csl-symbian-20060226-branch:1.17.0.16
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.18.0.4
	msnyder-reverse-20060331-branchpoint:1.18
	binutils-csl-2_17-branch:1.18.0.2
	binutils-csl-2_17-branchpoint:1.18
	gdb-csl-available-20060303-branch:1.17.0.14
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.12
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.10
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.6
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.17.0.4
	gdb-csl-arm-20051020-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.15.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	gdb-csl-arm-20050325-2005-q1a:1.15
	binutils-csl-arm-2005q1a:1.15
	csl-arm-20050325-branch:1.15.0.6
	csl-arm-20050325-branchpoint:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.4
	gdb_6_3-20041019-branchpoint:1.14
	csl-arm-2004-q3:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.14.0.6
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.14
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.12
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.8
	drow_intercu-20040221-branchpoint:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	csl-arm-2003-q4:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.12.0.6
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.4
	cagney_x86i386-20030821-branch:1.12.0.2
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.11.0.28
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.26
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.24
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.22
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.20
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.18
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.16
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.14
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.12
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.10
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.8
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.6
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.4
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.2
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.10.0.8
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.6
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.4
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.14
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.12
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.10
	gdb_5_3-branch:1.9.0.8
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.6
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.4
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	kseitz_interps-20020528-branch:1.8.0.6
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.4
	cagney_regbuf-20020515-branchpoint:1.8
	binutils-2_12_1:1.6.2.1
	jimb-macro-020506-branch:1.8.0.2
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.28
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.13.14.22.50;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.13.00.59.15;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.02.14.40.41;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.15.53.39;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.07.19.36;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.13.09.28.49;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches
	1.10.8.1;
next	1.9;

1.9
date	2002.06.07.15.04.48;	author amodra;	state Exp;
branches
	1.9.12.1
	1.9.14.1;
next	1.8;

1.8
date	2002.04.04.19.53.38;	author drow;	state Exp;
branches
	1.8.4.1
	1.8.6.1;
next	1.7;

1.7
date	2002.03.28.03.27.46;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.02.05.58.41;	author amodra;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.20.00.21.57;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.12.10.30.05;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.13.8.1
date	2004.09.16.17.00.37;	author drow;	state Exp;
branches;
next	;

1.10.8.1
date	2003.03.16.14.01.44;	author kettenis;	state Exp;
branches;
next	;

1.9.12.1
date	2002.12.23.19.37.59;	author carlton;	state Exp;
branches;
next	1.9.12.2;

1.9.12.2
date	2003.04.16.19.56.47;	author carlton;	state Exp;
branches;
next	1.9.12.3;

1.9.12.3
date	2003.06.27.21.49.30;	author carlton;	state Exp;
branches;
next	1.9.12.4;

1.9.12.4
date	2003.12.15.23.59.53;	author carlton;	state Exp;
branches;
next	;

1.9.14.1
date	2003.12.14.20.26.52;	author drow;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.20.01.31.10;	author kseitz;	state Exp;
branches;
next	;

1.6.2.1
date	2002.04.04.14.53.01;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.28
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@/* BFD back-end for linux flavored sparc a.out binaries.
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_PAGE_SIZE	4096
#define ZMAGIC_DISK_BLOCK_SIZE	1024
#define SEGMENT_SIZE		TARGET_PAGE_SIZE
#define TEXT_START_ADDR		0x0

#define MACHTYPE_OK(mtype) ((mtype) == M_SPARC || (mtype) == M_UNKNOWN)

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"
#include "aout/ar.h"
#include "libaout.h"           /* BFD a.out internal data structures */

#define DEFAULT_ARCH bfd_arch_sparc
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (sparclinux_,OP)
#define TARGETNAME "a.out-sparc-linux"

extern const bfd_target MY(vec);

/* We always generate QMAGIC files in preference to ZMAGIC files.  It
   would be possible to make this a linker option, if that ever
   becomes important.  */

static void MY_final_link_callback
  (bfd *, file_ptr *, file_ptr *, file_ptr *);

static bfd_boolean
sparclinux_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
{
  obj_aout_subformat (abfd) = q_magic_format;
  return NAME(aout,final_link) (abfd, info, MY_final_link_callback);
}

#define MY_bfd_final_link sparclinux_bfd_final_link

/* Set the machine type correctly.  */

static bfd_boolean
sparclinux_write_object_contents (bfd *abfd)
{
  struct external_exec exec_bytes;
  struct internal_exec *execp = exec_hdr (abfd);

  N_SET_MACHTYPE (*execp, M_SPARC);

  obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;

  WRITE_HEADERS(abfd, execp);

  return TRUE;
}

#define MY_write_object_contents sparclinux_write_object_contents
/* Code to link against Linux a.out shared libraries.  */

/* See if a symbol name is a reference to the global offset table.  */

#ifndef GOT_REF_PREFIX
#define GOT_REF_PREFIX  "__GOT_"
#endif

#define IS_GOT_SYM(name)  (CONST_STRNEQ (name, GOT_REF_PREFIX))

/* See if a symbol name is a reference to the procedure linkage table.  */

#ifndef PLT_REF_PREFIX
#define PLT_REF_PREFIX  "__PLT_"
#endif

#define IS_PLT_SYM(name)  (CONST_STRNEQ (name, PLT_REF_PREFIX))

/* This string is used to generate specialized error messages.  */

#ifndef NEEDS_SHRLIB
#define NEEDS_SHRLIB "__NEEDS_SHRLIB_"
#endif

/* This special symbol is a set vector that contains a list of
   pointers to fixup tables.  It will be present in any dynamically
   linked file.  The linker generated fixup table should also be added
   to the list, and it should always appear in the second slot (the
   first one is a dummy with a magic number that is defined in
   crt0.o).  */

#ifndef SHARABLE_CONFLICTS
#define SHARABLE_CONFLICTS "__SHARABLE_CONFLICTS__"
#endif

/* We keep a list of fixups.  The terminology is a bit strange, but
   each fixup contains two 32 bit numbers.  A regular fixup contains
   an address and a pointer, and at runtime we should store the
   address at the location pointed to by the pointer.  A builtin fixup
   contains two pointers, and we should read the address using one
   pointer and store it at the location pointed to by the other
   pointer.  Builtin fixups come into play when we have duplicate
   __GOT__ symbols for the same variable.  The builtin fixup will copy
   the GOT pointer from one over into the other.  */

struct fixup
{
  struct fixup *next;
  struct linux_link_hash_entry *h;
  bfd_vma value;

  /* Nonzero if this is a jump instruction that needs to be fixed,
     zero if this is just a pointer */
  char jump;

  char builtin;
};

/* We don't need a special hash table entry structure, but we do need
   to keep some information between linker passes, so we use a special
   hash table.  */

struct linux_link_hash_entry
{
  struct aout_link_hash_entry root;
};

struct linux_link_hash_table
{
  struct aout_link_hash_table root;

  /* First dynamic object found in link.  */
  bfd *dynobj;

  /* Number of fixups.  */
  size_t fixup_count;

  /* Number of builtin fixups.  */
  size_t local_builtins;

  /* List of fixups.  */
  struct fixup *fixup_list;
};


/* Routine to create an entry in an Linux link hash table.  */

static struct bfd_hash_entry *
linux_link_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  struct linux_link_hash_entry *ret = (struct linux_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct linux_link_hash_entry *) NULL)
    ret = ((struct linux_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct linux_link_hash_entry)));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct linux_link_hash_entry *)
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
  if (ret != NULL)
    {
      /* Set local fields; there aren't any.  */
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a Linux link hash table.  */

static struct bfd_link_hash_table *
linux_link_hash_table_create (bfd *abfd)
{
  struct linux_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct linux_link_hash_table);

  ret = (struct linux_link_hash_table *) bfd_zmalloc (amt);
  if (ret == (struct linux_link_hash_table *) NULL)
    return (struct bfd_link_hash_table *) NULL;
  if (!NAME(aout,link_hash_table_init) (&ret->root, abfd,
					linux_link_hash_newfunc,
					sizeof (struct linux_link_hash_entry)))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  return &ret->root.root;
}

/* Look up an entry in a Linux link hash table.  */

#define linux_link_hash_lookup(table, string, create, copy, follow) \
  ((struct linux_link_hash_entry *) \
   aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			  (follow)))

/* Traverse a Linux link hash table.  */

#define linux_link_hash_traverse(table, func, info)		       \
  (aout_link_hash_traverse					       \
   (&(table)->root,						       \
    (bfd_boolean (*) (struct aout_link_hash_entry *, void *)) (func),  \
    (info)))

/* Get the Linux link hash table from the info structure.  This is
   just a cast.  */

#define linux_hash_table(p) ((struct linux_link_hash_table *) ((p)->hash))

/* Store the information for a new fixup.  */

static struct fixup *
new_fixup (struct bfd_link_info *info,
	   struct linux_link_hash_entry *h,
	   bfd_vma value,
	   int builtin)
{
  struct fixup *f;

  f = (struct fixup *) bfd_hash_allocate (&info->hash->table,
					  sizeof (struct fixup));
  if (f == NULL)
    return f;
  f->next = linux_hash_table (info)->fixup_list;
  linux_hash_table (info)->fixup_list = f;
  f->h = h;
  f->value = value;
  f->builtin = builtin;
  f->jump = 0;
  ++linux_hash_table (info)->fixup_count;
  return f;
}

/* We come here once we realize that we are going to link to a shared
   library.  We need to create a special section that contains the
   fixup table, and we ultimately need to add a pointer to this into
   the set vector for SHARABLE_CONFLICTS.  At this point we do not
   know the size of the section, but that's OK - we just need to
   create it for now.  */

static bfd_boolean
linux_link_create_dynamic_sections (bfd *abfd,
				    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  flagword flags;
  asection *s;

  /* Note that we set the SEC_IN_MEMORY flag.  */
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;

  /* We choose to use the name ".linux-dynamic" for the fixup table.
     Why not?  */
  s = bfd_make_section_with_flags (abfd, ".linux-dynamic", flags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;
  s->size = 0;
  s->contents = 0;

  return TRUE;
}

/* Function to add a single symbol to the linker hash table.  This is
   a wrapper around _bfd_generic_link_add_one_symbol which handles the
   tweaking needed for dynamic linking support.  */

static bfd_boolean
linux_add_one_symbol (struct bfd_link_info *info,
		      bfd *abfd,
		      const char *name,
		      flagword flags,
		      asection *section,
		      bfd_vma value,
		      const char *string,
		      bfd_boolean copy,
		      bfd_boolean collect,
		      struct bfd_link_hash_entry **hashp)
{
  struct linux_link_hash_entry *h;
  bfd_boolean insert;

  /* Look up and see if we already have this symbol in the hash table.
     If we do, and the defining entry is from a shared library, we
     need to create the dynamic sections.

     FIXME: What if abfd->xvec != info->output_bfd->xvec?  We may
     want to be able to link Linux a.out and ELF objects together,
     but serious confusion is possible.  */

  insert = FALSE;

  if (! info->relocatable
      && linux_hash_table (info)->dynobj == NULL
      && strcmp (name, SHARABLE_CONFLICTS) == 0
      && (flags & BSF_CONSTRUCTOR) != 0
      && abfd->xvec == info->output_bfd->xvec)
    {
      if (! linux_link_create_dynamic_sections (abfd, info))
	return FALSE;
      linux_hash_table (info)->dynobj = abfd;
      insert = TRUE;
    }

  if (bfd_is_abs_section (section)
      && abfd->xvec == info->output_bfd->xvec)
    {
      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,
				  FALSE, FALSE);
      if (h != NULL
	  && (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak))
	{
	  struct fixup *f;

	  if (hashp != NULL)
	    *hashp = (struct bfd_link_hash_entry *) h;

	  f = new_fixup (info, h, value, ! IS_PLT_SYM (name));
	  if (f == NULL)
	    return FALSE;
	  f->jump = IS_PLT_SYM (name);

	  return TRUE;
	}
    }

  /* Do the usual procedure for adding a symbol.  */
  if (! _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,
					  value, string, copy, collect,
					  hashp))
    return FALSE;

  /* Insert a pointer to our table in the set vector.  The dynamic
     linker requires this information.  */
  if (insert)
    {
      asection *s;

      /* Here we do our special thing to add the pointer to the
	 dynamic section in the SHARABLE_CONFLICTS set vector.  */
      s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
				   ".linux-dynamic");
      BFD_ASSERT (s != NULL);

      if (! (_bfd_generic_link_add_one_symbol
	     (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	      FALSE, FALSE, NULL)))
	return FALSE;
    }

  return TRUE;
}

/* We will crawl the hash table and come here for every global symbol.
   We will examine each entry and see if there are indications that we
   need to add a fixup.  There are two possible cases - one is where
   you have duplicate definitions of PLT or GOT symbols - these will
   have already been caught and added as "builtin" fixups.  If we find
   that the corresponding non PLT/GOT symbol is also present, we
   convert it to a regular fixup instead.

   This function is called via linux_link_hash_traverse.  */

static bfd_boolean
linux_tally_symbols (struct linux_link_hash_entry *h, void * data)
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;
  struct fixup *f, *f1;
  int is_plt;
  struct linux_link_hash_entry *h1, *h2;
  bfd_boolean exists;

  if (h->root.root.type == bfd_link_hash_undefined
      && CONST_STRNEQ (h->root.root.root.string, NEEDS_SHRLIB))
    {
      const char *name;
      char *p;
      char *alloc = NULL;

      name = h->root.root.root.string + sizeof NEEDS_SHRLIB - 1;
      p = strrchr (name, '_');
      if (p != NULL)
	alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);

      if (p == NULL || alloc == NULL)
	(*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
			       name);
      else
	{
	  strcpy (alloc, name);
	  p = strrchr (alloc, '_');
	  *p++ = '\0';
	  (*_bfd_error_handler)
	    (_("Output file requires shared library `%s.so.%s'\n"),
	     alloc, p);
	  free (alloc);
	}

      abort ();
    }

  /* If this symbol is not a PLT/GOT, we do not even need to look at
     it.  */
  is_plt = IS_PLT_SYM (h->root.root.root.string);

  if (is_plt || IS_GOT_SYM (h->root.root.root.string))
    {
      /* Look up this symbol twice.  Once just as a regular lookup,
	 and then again following all of the indirect links until we
	 reach a real symbol.  */
      h1 = linux_link_hash_lookup (linux_hash_table (info),
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, TRUE);
      /* h2 does not follow indirect symbols.  */
      h2 = linux_link_hash_lookup (linux_hash_table (info),
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, FALSE);

      /* The real symbol must exist but if it is also an ABS symbol,
	 there is no need to have a fixup.  This is because they both
	 came from the same library.  If on the other hand, we had to
	 use an indirect symbol to get to the real symbol, we add the
	 fixup anyway, since there are cases where these symbols come
	 from different shared libraries */
      if (h1 != NULL
	  && (((h1->root.root.type == bfd_link_hash_defined
		|| h1->root.root.type == bfd_link_hash_defweak)
	       && ! bfd_is_abs_section (h1->root.root.u.def.section))
	      || h2->root.root.type == bfd_link_hash_indirect))
	{
	  /* See if there is a "builtin" fixup already present
	     involving this symbol.  If so, convert it to a regular
	     fixup.  In the end, this relaxes some of the requirements
	     about the order of performing fixups.  */
	  exists = FALSE;
	  for (f1 = linux_hash_table (info)->fixup_list;
	       f1 != NULL;
	       f1 = f1->next)
	    {
	      if ((f1->h != h && f1->h != h1)
		  || (! f1->builtin && ! f1->jump))
		continue;
	      if (f1->h == h1)
		exists = TRUE;
	      if (! exists
		  && bfd_is_abs_section (h->root.root.u.def.section))
		{
		  f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);
		  f->jump = is_plt;
		}
	      f1->h = h1;
	      f1->jump = is_plt;
	      f1->builtin = 0;
	      exists = TRUE;
	    }
	  if (! exists
	      && bfd_is_abs_section (h->root.root.u.def.section))
	    {
	      f = new_fixup (info, h1, h->root.root.u.def.value, 0);
	      if (f == NULL)
		{
		  /* FIXME: No way to return error.  */
		  abort ();
		}
	      f->jump = is_plt;
	    }
	}

      /* Quick and dirty way of stripping these symbols from the
	 symtab.  */
      if (bfd_is_abs_section (h->root.root.u.def.section))
	h->root.written = TRUE;
    }

  return TRUE;
}

/* This is called to set the size of the .linux-dynamic section is.
   It is called by the Linux linker emulation before_allocation
   routine.  We have finished reading all of the input files, and now
   we just scan the hash tables to find out how many additional fixups
   are required.  */

bfd_boolean
bfd_sparclinux_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
{
  struct fixup *f;
  asection *s;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* First find the fixups...  */
  linux_link_hash_traverse (linux_hash_table (info),
			    linux_tally_symbols,
			    info);

  /* If there are builtin fixups, leave room for a marker.  This is
     used by the dynamic linker so that it knows that all that follow
     are builtin fixups instead of regular fixups.  */
  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
    {
      if (f->builtin)
	{
	  ++linux_hash_table (info)->fixup_count;
	  ++linux_hash_table (info)->local_builtins;
	  break;
	}
    }

  if (linux_hash_table (info)->dynobj == NULL)
    {
      if (linux_hash_table (info)->fixup_count > 0)
	abort ();
      return TRUE;
    }

  /* Allocate memory for our fixup table.  We will fill it in later.  */
  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
			       ".linux-dynamic");
  if (s != NULL)
    {
      s->size = linux_hash_table (info)->fixup_count + 1;
      s->size *= 8;
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  return TRUE;
}

/* We come here once we are ready to actually write the fixup table to
   the output file.  Scan the fixup tables and so forth and generate
   the stuff we need.  */

static bfd_boolean
linux_finish_dynamic_link (bfd *output_bfd, struct bfd_link_info *info)
{
  asection *s, *os, *is;
  bfd_byte *fixup_table;
  struct linux_link_hash_entry *h;
  struct fixup *f;
  unsigned int new_addr;
  int section_offset;
  unsigned int fixups_written;

  if (linux_hash_table (info)->dynobj == NULL)
    return TRUE;

  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
			       ".linux-dynamic");
  BFD_ASSERT (s != NULL);
  os = s->output_section;
  fixups_written = 0;

#ifdef LINUX_LINK_DEBUG
  printf ("Fixup table file offset: %x  VMA: %x\n",
	  os->filepos + s->output_offset,
	  os->vma + s->output_offset);
#endif

  fixup_table = s->contents;
  bfd_put_32 (output_bfd,
	      (bfd_vma) linux_hash_table (info)->fixup_count, fixup_table);
  fixup_table += 4;

  /* Fill in fixup table.  */
  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
    {
      if (f->builtin)
	continue;

      if (f->h->root.root.type != bfd_link_hash_defined
	  && f->h->root.root.type != bfd_link_hash_defweak)
	{
	  (*_bfd_error_handler)
	    (_("Symbol %s not defined for fixups\n"),
	     f->h->root.root.root.string);
	  continue;
	}

      is = f->h->root.root.u.def.section;
      section_offset = is->output_section->vma + is->output_offset;
      new_addr = f->h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
      printf ("Fixup(%d) %s: %x %x\n",f->jump, f->h->root.root.string,
	      new_addr, f->value);
#endif

      if (f->jump)
	{
	  /* Relative address */
	  new_addr = new_addr - (f->value + 5);
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value + 1, fixup_table);
	  fixup_table += 4;
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	}
      ++fixups_written;
    }

  if (linux_hash_table (info)->local_builtins != 0)
    {
      /* Special marker so we know to switch to the other type of fixup */
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
      fixup_table += 4;
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
      fixup_table += 4;
      ++fixups_written;
      for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
	{
	  if (! f->builtin)
	    continue;

	  if (f->h->root.root.type != bfd_link_hash_defined
	      && f->h->root.root.type != bfd_link_hash_defweak)
	    {
	      (*_bfd_error_handler)
		(_("Symbol %s not defined for fixups\n"),
		 f->h->root.root.root.string);
	      continue;
	    }

	  is = f->h->root.root.u.def.section;
	  section_offset = is->output_section->vma + is->output_offset;
	  new_addr = f->h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
	  printf ("Fixup(B) %s: %x %x\n", f->h->root.root.string,
		  new_addr, f->value);
#endif

	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
    }

  if (linux_hash_table (info)->fixup_count != fixups_written)
    {
      (*_bfd_error_handler) (_("Warning: fixup count mismatch\n"));
      while (linux_hash_table (info)->fixup_count > fixups_written)
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
    }

  h = linux_link_hash_lookup (linux_hash_table (info),
			      "__BUILTIN_FIXUPS__",
			      FALSE, FALSE, FALSE);

  if (h != NULL
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak))
    {
      is = h->root.root.u.def.section;
      section_offset = is->output_section->vma + is->output_offset;
      new_addr = h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
      printf ("Builtin fixup table at %x\n", new_addr);
#endif

      bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
    }
  else
    bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);

  if (bfd_seek (output_bfd, (file_ptr) (os->filepos + s->output_offset),
		SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite (s->contents, s->size, output_bfd) != s->size)
    return FALSE;

  return TRUE;
}

#define MY_bfd_link_hash_table_create linux_link_hash_table_create
#define MY_add_one_symbol linux_add_one_symbol
#define MY_finish_dynamic_link linux_finish_dynamic_link

#define MY_zmagic_contiguous 1

#include "aout-target.h"
@


1.27
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d203 1
a203 1
  ret = (struct linux_link_hash_table *) bfd_malloc (amt);
a213 5
  ret->dynobj = NULL;
  ret->fixup_count = 0;
  ret->local_builtins = 0;
  ret->fixup_list = NULL;

@


1.26
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d52 1
a52 4
  PARAMS ((bfd *, file_ptr *, file_ptr *, file_ptr *));

static bfd_boolean sparclinux_bfd_final_link
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
d55 1
a55 3
sparclinux_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
a64 2
static bfd_boolean sparclinux_write_object_contents PARAMS ((bfd *abfd));

d66 1
a66 2
sparclinux_write_object_contents (abfd)
     bfd *abfd;
a164 17
static struct bfd_hash_entry *linux_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *linux_link_hash_table_create
  PARAMS ((bfd *));
static struct fixup *new_fixup
  PARAMS ((struct bfd_link_info *, struct linux_link_hash_entry *,
	  bfd_vma, int));
static bfd_boolean linux_link_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean linux_add_one_symbol
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	  bfd_vma, const char *, bfd_boolean, bfd_boolean,
	  struct bfd_link_hash_entry **));
static bfd_boolean linux_tally_symbols
  PARAMS ((struct linux_link_hash_entry *, PTR));
static bfd_boolean linux_finish_dynamic_link
  PARAMS ((bfd *, struct bfd_link_info *));
d169 3
a171 4
linux_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d198 1
a198 2
linux_link_hash_table_create (abfd)
     bfd *abfd;
d234 1
a234 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d245 4
a248 5
new_fixup (info, h, value, builtin)
     struct bfd_link_info *info;
     struct linux_link_hash_entry *h;
     bfd_vma value;
     int builtin;
d274 2
a275 3
linux_link_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d278 1
a278 1
  register asection *s;
d300 10
a309 12
linux_add_one_symbol (info, abfd, name, flags, section, value, string,
		      copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
d520 2
a521 3
bfd_sparclinux_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d532 1
a532 1
			    (PTR) info);
d574 1
a574 3
linux_finish_dynamic_link (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d724 1
a724 1
  if (bfd_bwrite ((PTR) s->contents, s->size, output_bfd) != s->size)
@


1.25
log
@include/aout/
	* aout64.h (N_SHARED_LIB): Define as zero if not already defined.
	* sun4.h (N_SHARED_LIB): Define.
	* hp300hpux.h (N_SHARED_LIB): Don't define.
bfd/
	* aout-cris.c (N_SHARED_LIB): Don't define.
	* hp300bsd.c (N_SHARED_LIB): Don't define.
	* i386bsd.c (N_SHARED_LIB): Don't define.
	* i386linux.c (N_SHARED_LIB): Don't define.
	* i386lynx.c (N_SHARED_LIB): Don't define.
	* m68klinux.c (N_SHARED_LIB): Don't define.
	* m88kmach3.c (N_SHARED_LIB): Don't define.
	* mipsbsd.c (N_SHARED_LIB): Don't define.
	* newsos3.c (N_SHARED_LIB): Don't define.
	* pc532-mach.c (N_SHARED_LIB): Don't define.
	* pdp11.c (N_SHARED_LIB): Don't define.
	* sparclinux.c (N_SHARED_LIB): Don't define.
	* vaxbsd.c (N_SHARED_LIB): Don't define.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
a436 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct linux_link_hash_entry *) h->root.root.u.i.link;

@


1.24
log
@update copyright dates
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
a25 1
#define N_SHARED_LIB(x)		0
@


1.23
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.22
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2003, 2004, 2006, 2007 Free Software Foundation, Inc.
d349 3
a351 3
     FIXME: What if abfd->xvec != info->hash->creator?  We may want to
     be able to link Linux a.out and ELF objects together, but serious
     confusion is possible.  */
d359 1
a359 1
      && abfd->xvec == info->hash->creator)
d368 1
a368 1
      && abfd->xvec == info->hash->creator)
@


1.21
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 2
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */
@


1.20
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 1
a3 1
   2003, 2004, 2006 Free Software Foundation, Inc.
d30 1
a31 1
#include "sysdep.h"
@


1.19
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 14
a20 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
USA.  */
d97 1
a97 2
#define IS_GOT_SYM(name) \
  (strncmp (name, GOT_REF_PREFIX, sizeof GOT_REF_PREFIX - 1) == 0)
d105 1
a105 2
#define IS_PLT_SYM(name) \
  (strncmp (name, PLT_REF_PREFIX, sizeof PLT_REF_PREFIX - 1) == 0)
d429 1
a429 3
linux_tally_symbols (h, data)
     struct linux_link_hash_entry *h;
     PTR data;
d441 1
a441 2
      && strncmp (h->root.root.root.string, NEEDS_SHRLIB,
		  sizeof NEEDS_SHRLIB - 1) == 0)
@


1.18
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d316 1
a316 1
  s = bfd_make_section (abfd, ".linux-dynamic");
a317 1
      || ! bfd_set_section_flags (abfd, s, flags)
@


1.17
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d235 3
a237 2
  if (! NAME(aout,link_hash_table_init) (&ret->root, abfd,
					 linux_link_hash_newfunc))
@


1.16
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301,
@


1.15
log
@update copyright dates
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
@


1.14
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
@


1.13
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d320 1
a320 1
  s->_raw_size = 0;
d599 3
a601 3
      s->_raw_size = linux_hash_table (info)->fixup_count + 1;
      s->_raw_size *= 8;
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d766 1
a766 1
  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd) != s->_raw_size)
@


1.13.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d320 1
a320 1
  s->size = 0;
d599 3
a601 3
      s->size = linux_hash_table (info)->fixup_count + 1;
      s->size *= 8;
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->size);
d766 1
a766 1
  if (bfd_bwrite ((PTR) s->contents, s->size, output_bfd) != s->size)
@


1.12
log
@Correct spelling of "relocatable".
@
text
@d116 1
a116 1
   pointers to fixup tables.  It will be present in any dynamicly
@


1.11
log
@(BYTES_IN_WORD): Don't define.
@
text
@d357 1
a357 1
  if (! info->relocateable
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002
a26 1
#define BYTES_IN_WORD		4
@


1.10.8.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d27 1
@


1.9
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d22 6
a27 6
#define TARGET_PAGE_SIZE        4096
#define ZMAGIC_DISK_BLOCK_SIZE 1024
#define SEGMENT_SIZE TARGET_PAGE_SIZE
#define TEXT_START_ADDR        0x0
#define N_SHARED_LIB(x) 0
#define BYTES_IN_WORD 4
d55 1
a55 1
static boolean sparclinux_bfd_final_link
d58 1
a58 1
static boolean
d71 1
a71 1
static boolean sparclinux_write_object_contents PARAMS ((bfd *abfd));
d73 1
a73 1
static boolean
d86 1
a86 1
  return true;
d95 1
a95 1
#define        GOT_REF_PREFIX  "__GOT_"
d104 1
a104 1
#define        PLT_REF_PREFIX  "__PLT_"
d182 2
a183 2
          bfd_vma, int));
static boolean linux_link_create_dynamic_sections
d185 1
a185 1
static boolean linux_add_one_symbol
d187 3
a189 3
          bfd_vma, const char *, boolean, boolean,
          struct bfd_link_hash_entry **));
static boolean linux_tally_symbols
d191 1
a191 1
static boolean linux_finish_dynamic_link
d208 1
a208 1
          bfd_hash_allocate (table, sizeof (struct linux_link_hash_entry)));
d214 2
a215 2
        NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
                                      table, string));
d237 1
a237 1
                                        linux_link_hash_newfunc))
d256 1
a256 1
                         (follow)))
d260 4
a263 4
#define linux_link_hash_traverse(table, func, info)                    \
  (aout_link_hash_traverse                                             \
   (&(table)->root,                                                    \
    (boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d283 1
a283 1
                                         sizeof (struct fixup));
d303 1
a303 1
static boolean
d315 1
a315 1
     Why not? */
d320 1
a320 1
    return false;
d324 1
a324 1
  return true;
d331 1
a331 1
static boolean
d333 1
a333 1
                     copy, collect, hashp)
d341 2
a342 2
     boolean copy;
     boolean collect;
d346 1
a346 1
  boolean insert;
d356 1
a356 1
  insert = false;
d365 1
a365 1
       return false;
d367 1
a367 1
      insert = true;
d373 2
a374 2
      h = linux_link_hash_lookup (linux_hash_table (info), name, false,
                                 false, false);
d376 12
a387 12
         && (h->root.root.type == bfd_link_hash_defined
             || h->root.root.type == bfd_link_hash_defweak))
       {
         struct fixup *f;

         if (hashp != NULL)
           *hashp = (struct bfd_link_hash_entry *) h;

         f = new_fixup (info, h, value, ! IS_PLT_SYM (name));
         if (f == NULL)
           return false;
         f->jump = IS_PLT_SYM (name);
d389 2
a390 2
         return true;
       }
d395 3
a397 3
                                         value, string, copy, collect,
                                         hashp))
    return false;
d400 1
a400 1
     linker requires this information */
d406 1
a406 1
        dynamic section in the SHARABLE_CONFLICTS set vector.  */
d408 1
a408 1
                                  ".linux-dynamic");
d412 4
a415 4
            (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,
             BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	     false, false, NULL)))
       return false;
d418 1
a418 1
  return true;
d431 1
a431 1
static boolean
d440 1
a440 1
  boolean exists;
d447 1
a447 1
                 sizeof NEEDS_SHRLIB - 1) == 0)
d456 1
a456 1
       alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);
d459 2
a460 2
       (*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
                              name);
d462 9
a470 9
       {
         strcpy (alloc, name);
         p = strrchr (alloc, '_');
         *p++ = '\0';
         (*_bfd_error_handler)
           (_("Output file requires shared library `%s.so.%s'\n"),
            alloc, p);
         free (alloc);
       }
d482 2
a483 2
        and then again following all of the indirect links until we
        reach a real symbol.  */
d485 3
a487 3
                                  (h->root.root.root.string
                                   + sizeof PLT_REF_PREFIX - 1),
                                  false, false, true);
d490 3
a492 3
                                  (h->root.root.root.string
                                   + sizeof PLT_REF_PREFIX - 1),
                                  false, false, false);
d495 5
a499 5
        there is no need to have a fixup.  This is because they both
        came from the same library.  If on the other hand, we had to
        use an indirect symbol to get to the real symbol, we add the
        fixup anyway, since there are cases where these symbols come
        from different shared libraries */
d501 42
a542 42
         && (((h1->root.root.type == bfd_link_hash_defined
               || h1->root.root.type == bfd_link_hash_defweak)
              && ! bfd_is_abs_section (h1->root.root.u.def.section))
             || h2->root.root.type == bfd_link_hash_indirect))
       {
         /* See if there is a "builtin" fixup already present
            involving this symbol.  If so, convert it to a regular
            fixup.  In the end, this relaxes some of the requirements
            about the order of performing fixups.  */
         exists = false;
         for (f1 = linux_hash_table (info)->fixup_list;
              f1 != NULL;
              f1 = f1->next)
           {
             if ((f1->h != h && f1->h != h1)
                 || (! f1->builtin && ! f1->jump))
               continue;
             if (f1->h == h1)
              exists = true;
             if (! exists
                 && bfd_is_abs_section (h->root.root.u.def.section))
               {
                 f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);
                 f->jump = is_plt;
               }
             f1->h = h1;
             f1->jump = is_plt;
             f1->builtin = 0;
             exists = true;
           }
         if (! exists
             && bfd_is_abs_section (h->root.root.u.def.section))
           {
             f = new_fixup (info, h1, h->root.root.u.def.value, 0);
             if (f == NULL)
               {
                 /* FIXME: No way to return error.  */
                 abort ();
               }
             f->jump = is_plt;
           }
       }
d545 1
a545 1
        symtab.  */
d547 1
a547 1
       h->root.written = true;
d550 1
a550 1
  return true;
d559 1
a559 1
boolean
d568 1
a568 1
    return true;
d572 2
a573 2
                           linux_tally_symbols,
                           (PTR) info);
d581 5
a585 5
       {
         ++linux_hash_table (info)->fixup_count;
         ++linux_hash_table (info)->local_builtins;
         break;
       }
d591 2
a592 2
      abort ();
      return true;
d597 1
a597 1
                              ".linux-dynamic");
d604 1
a604 1
       return false;
d607 1
a607 1
  return true;
d614 1
a614 1
static boolean
d628 1
a628 1
    return true;
d631 1
a631 1
                              ".linux-dynamic");
d638 2
a639 2
         os->filepos + s->output_offset,
         os->vma + s->output_offset);
d651 1
a651 1
       continue;
d654 7
a660 7
         && f->h->root.root.type != bfd_link_hash_defweak)
       {
         (*_bfd_error_handler)
           (_("Symbol %s not defined for fixups\n"),
            f->h->root.root.root.string);
         continue;
       }
d668 1
a668 1
             new_addr, f->value);
d672 8
a679 8
       {
         /* Relative address */
         new_addr = new_addr - (f->value + 5);
	 bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
         fixup_table += 4;
         bfd_put_32 (output_bfd, f->value + 1, fixup_table);
         fixup_table += 4;
       }
d681 6
a686 6
       {
         bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
         fixup_table += 4;
         bfd_put_32 (output_bfd, f->value, fixup_table);
         fixup_table += 4;
       }
d699 16
a714 16
       {
         if (! f->builtin)
           continue;

         if (f->h->root.root.type != bfd_link_hash_defined
             && f->h->root.root.type != bfd_link_hash_defweak)
           {
             (*_bfd_error_handler)
               (_("Symbol %s not defined for fixups\n"),
                f->h->root.root.root.string);
             continue;
           }

         is = f->h->root.root.u.def.section;
         section_offset = is->output_section->vma + is->output_offset;
         new_addr = f->h->root.root.u.def.value + section_offset;
d717 2
a718 2
         printf ("Fixup(B) %s: %x %x\n", f->h->root.root.string,
                 new_addr, f->value);
d721 7
a727 7
         bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
         fixup_table += 4;
         bfd_put_32 (output_bfd, f->value, fixup_table);
         fixup_table += 4;
         ++fixups_written;
       }
  }
d733 7
a739 7
       {
         bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
         fixup_table += 4;
         bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
         fixup_table += 4;
         ++fixups_written;
       }
d743 2
a744 2
                             "__BUILTIN_FIXUPS__",
                             false, false, false);
d748 1
a748 1
         || h->root.root.type == bfd_link_hash_defweak))
d765 1
a765 1
    return false;
d767 2
a768 3
  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd)
      != s->_raw_size)
    return false;
d770 1
a770 1
  return true;
@


1.9.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d22 6
a27 5
#define TARGET_PAGE_SIZE	4096
#define ZMAGIC_DISK_BLOCK_SIZE	1024
#define SEGMENT_SIZE		TARGET_PAGE_SIZE
#define TEXT_START_ADDR		0x0
#define N_SHARED_LIB(x)		0
d55 1
a55 1
static bfd_boolean sparclinux_bfd_final_link
d58 1
a58 1
static bfd_boolean
d71 1
a71 1
static bfd_boolean sparclinux_write_object_contents PARAMS ((bfd *abfd));
d73 1
a73 1
static bfd_boolean
d86 1
a86 1
  return TRUE;
d95 1
a95 1
#define GOT_REF_PREFIX  "__GOT_"
d104 1
a104 1
#define PLT_REF_PREFIX  "__PLT_"
d117 1
a117 1
   pointers to fixup tables.  It will be present in any dynamically
d182 2
a183 2
	  bfd_vma, int));
static bfd_boolean linux_link_create_dynamic_sections
d185 1
a185 1
static bfd_boolean linux_add_one_symbol
d187 3
a189 3
	  bfd_vma, const char *, bfd_boolean, bfd_boolean,
	  struct bfd_link_hash_entry **));
static bfd_boolean linux_tally_symbols
d191 1
a191 1
static bfd_boolean linux_finish_dynamic_link
d208 1
a208 1
	   bfd_hash_allocate (table, sizeof (struct linux_link_hash_entry)));
d214 2
a215 2
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
d237 1
a237 1
					 linux_link_hash_newfunc))
d256 1
a256 1
			  (follow)))
d260 4
a263 4
#define linux_link_hash_traverse(table, func, info)		       \
  (aout_link_hash_traverse					       \
   (&(table)->root,						       \
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d283 1
a283 1
					  sizeof (struct fixup));
d303 1
a303 1
static bfd_boolean
d315 1
a315 1
     Why not?  */
d320 1
a320 1
    return FALSE;
d324 1
a324 1
  return TRUE;
d331 1
a331 1
static bfd_boolean
d333 1
a333 1
		      copy, collect, hashp)
d341 2
a342 2
     bfd_boolean copy;
     bfd_boolean collect;
d346 1
a346 1
  bfd_boolean insert;
d356 1
a356 1
  insert = FALSE;
d358 1
a358 1
  if (! info->relocatable
d365 1
a365 1
	return FALSE;
d367 1
a367 1
      insert = TRUE;
d373 2
a374 2
      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,
				  FALSE, FALSE);
d376 12
a387 12
	  && (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak))
	{
	  struct fixup *f;

	  if (hashp != NULL)
	    *hashp = (struct bfd_link_hash_entry *) h;

	  f = new_fixup (info, h, value, ! IS_PLT_SYM (name));
	  if (f == NULL)
	    return FALSE;
	  f->jump = IS_PLT_SYM (name);
d389 2
a390 2
	  return TRUE;
	}
d395 3
a397 3
					  value, string, copy, collect,
					  hashp))
    return FALSE;
d400 1
a400 1
     linker requires this information.  */
d406 1
a406 1
	 dynamic section in the SHARABLE_CONFLICTS set vector.  */
d408 1
a408 1
				   ".linux-dynamic");
d412 4
a415 4
	     (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	      FALSE, FALSE, NULL)))
	return FALSE;
d418 1
a418 1
  return TRUE;
d431 1
a431 1
static bfd_boolean
d440 1
a440 1
  bfd_boolean exists;
d447 1
a447 1
		  sizeof NEEDS_SHRLIB - 1) == 0)
d456 1
a456 1
	alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);
d459 2
a460 2
	(*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
			       name);
d462 9
a470 9
	{
	  strcpy (alloc, name);
	  p = strrchr (alloc, '_');
	  *p++ = '\0';
	  (*_bfd_error_handler)
	    (_("Output file requires shared library `%s.so.%s'\n"),
	     alloc, p);
	  free (alloc);
	}
d482 2
a483 2
	 and then again following all of the indirect links until we
	 reach a real symbol.  */
d485 3
a487 3
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, TRUE);
d490 3
a492 3
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, FALSE);
d495 5
a499 5
	 there is no need to have a fixup.  This is because they both
	 came from the same library.  If on the other hand, we had to
	 use an indirect symbol to get to the real symbol, we add the
	 fixup anyway, since there are cases where these symbols come
	 from different shared libraries */
d501 42
a542 42
	  && (((h1->root.root.type == bfd_link_hash_defined
		|| h1->root.root.type == bfd_link_hash_defweak)
	       && ! bfd_is_abs_section (h1->root.root.u.def.section))
	      || h2->root.root.type == bfd_link_hash_indirect))
	{
	  /* See if there is a "builtin" fixup already present
	     involving this symbol.  If so, convert it to a regular
	     fixup.  In the end, this relaxes some of the requirements
	     about the order of performing fixups.  */
	  exists = FALSE;
	  for (f1 = linux_hash_table (info)->fixup_list;
	       f1 != NULL;
	       f1 = f1->next)
	    {
	      if ((f1->h != h && f1->h != h1)
		  || (! f1->builtin && ! f1->jump))
		continue;
	      if (f1->h == h1)
		exists = TRUE;
	      if (! exists
		  && bfd_is_abs_section (h->root.root.u.def.section))
		{
		  f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);
		  f->jump = is_plt;
		}
	      f1->h = h1;
	      f1->jump = is_plt;
	      f1->builtin = 0;
	      exists = TRUE;
	    }
	  if (! exists
	      && bfd_is_abs_section (h->root.root.u.def.section))
	    {
	      f = new_fixup (info, h1, h->root.root.u.def.value, 0);
	      if (f == NULL)
		{
		  /* FIXME: No way to return error.  */
		  abort ();
		}
	      f->jump = is_plt;
	    }
	}
d545 1
a545 1
	 symtab.  */
d547 1
a547 1
	h->root.written = TRUE;
d550 1
a550 1
  return TRUE;
d559 1
a559 1
bfd_boolean
d568 1
a568 1
    return TRUE;
d572 2
a573 2
			    linux_tally_symbols,
			    (PTR) info);
d581 5
a585 5
	{
	  ++linux_hash_table (info)->fixup_count;
	  ++linux_hash_table (info)->local_builtins;
	  break;
	}
d591 2
a592 2
	abort ();
      return TRUE;
d597 1
a597 1
			       ".linux-dynamic");
d604 1
a604 1
	return FALSE;
d607 1
a607 1
  return TRUE;
d614 1
a614 1
static bfd_boolean
d628 1
a628 1
    return TRUE;
d631 1
a631 1
			       ".linux-dynamic");
d638 2
a639 2
	  os->filepos + s->output_offset,
	  os->vma + s->output_offset);
d651 1
a651 1
	continue;
d654 7
a660 7
	  && f->h->root.root.type != bfd_link_hash_defweak)
	{
	  (*_bfd_error_handler)
	    (_("Symbol %s not defined for fixups\n"),
	     f->h->root.root.root.string);
	  continue;
	}
d668 1
a668 1
	      new_addr, f->value);
d672 8
a679 8
	{
	  /* Relative address */
	  new_addr = new_addr - (f->value + 5);
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value + 1, fixup_table);
	  fixup_table += 4;
	}
d681 6
a686 6
	{
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	}
d699 16
a714 16
	{
	  if (! f->builtin)
	    continue;

	  if (f->h->root.root.type != bfd_link_hash_defined
	      && f->h->root.root.type != bfd_link_hash_defweak)
	    {
	      (*_bfd_error_handler)
		(_("Symbol %s not defined for fixups\n"),
		 f->h->root.root.root.string);
	      continue;
	    }

	  is = f->h->root.root.u.def.section;
	  section_offset = is->output_section->vma + is->output_offset;
	  new_addr = f->h->root.root.u.def.value + section_offset;
d717 2
a718 2
	  printf ("Fixup(B) %s: %x %x\n", f->h->root.root.string,
		  new_addr, f->value);
d721 7
a727 7
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
    }
d733 7
a739 7
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
d743 2
a744 2
			      "__BUILTIN_FIXUPS__",
			      FALSE, FALSE, FALSE);
d748 1
a748 1
	  || h->root.root.type == bfd_link_hash_defweak))
d765 1
a765 1
    return FALSE;
d767 3
a769 2
  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd) != s->_raw_size)
    return FALSE;
d771 1
a771 1
  return TRUE;
@


1.9.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d22 6
a27 6
#define TARGET_PAGE_SIZE	4096
#define ZMAGIC_DISK_BLOCK_SIZE	1024
#define SEGMENT_SIZE		TARGET_PAGE_SIZE
#define TEXT_START_ADDR		0x0
#define N_SHARED_LIB(x)		0
#define BYTES_IN_WORD		4
d55 1
a55 1
static bfd_boolean sparclinux_bfd_final_link
d58 1
a58 1
static bfd_boolean
d71 1
a71 1
static bfd_boolean sparclinux_write_object_contents PARAMS ((bfd *abfd));
d73 1
a73 1
static bfd_boolean
d86 1
a86 1
  return TRUE;
d95 1
a95 1
#define GOT_REF_PREFIX  "__GOT_"
d104 1
a104 1
#define PLT_REF_PREFIX  "__PLT_"
d182 2
a183 2
	  bfd_vma, int));
static bfd_boolean linux_link_create_dynamic_sections
d185 1
a185 1
static bfd_boolean linux_add_one_symbol
d187 3
a189 3
	  bfd_vma, const char *, bfd_boolean, bfd_boolean,
	  struct bfd_link_hash_entry **));
static bfd_boolean linux_tally_symbols
d191 1
a191 1
static bfd_boolean linux_finish_dynamic_link
d208 1
a208 1
	   bfd_hash_allocate (table, sizeof (struct linux_link_hash_entry)));
d214 2
a215 2
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
d237 1
a237 1
					 linux_link_hash_newfunc))
d256 1
a256 1
			  (follow)))
d260 4
a263 4
#define linux_link_hash_traverse(table, func, info)		       \
  (aout_link_hash_traverse					       \
   (&(table)->root,						       \
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d283 1
a283 1
					  sizeof (struct fixup));
d303 1
a303 1
static bfd_boolean
d315 1
a315 1
     Why not?  */
d320 1
a320 1
    return FALSE;
d324 1
a324 1
  return TRUE;
d331 1
a331 1
static bfd_boolean
d333 1
a333 1
		      copy, collect, hashp)
d341 2
a342 2
     bfd_boolean copy;
     bfd_boolean collect;
d346 1
a346 1
  bfd_boolean insert;
d356 1
a356 1
  insert = FALSE;
d365 1
a365 1
	return FALSE;
d367 1
a367 1
      insert = TRUE;
d373 2
a374 2
      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,
				  FALSE, FALSE);
d376 12
a387 12
	  && (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak))
	{
	  struct fixup *f;

	  if (hashp != NULL)
	    *hashp = (struct bfd_link_hash_entry *) h;

	  f = new_fixup (info, h, value, ! IS_PLT_SYM (name));
	  if (f == NULL)
	    return FALSE;
	  f->jump = IS_PLT_SYM (name);
d389 2
a390 2
	  return TRUE;
	}
d395 3
a397 3
					  value, string, copy, collect,
					  hashp))
    return FALSE;
d400 1
a400 1
     linker requires this information.  */
d406 1
a406 1
	 dynamic section in the SHARABLE_CONFLICTS set vector.  */
d408 1
a408 1
				   ".linux-dynamic");
d412 4
a415 4
	     (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	      FALSE, FALSE, NULL)))
	return FALSE;
d418 1
a418 1
  return TRUE;
d431 1
a431 1
static bfd_boolean
d440 1
a440 1
  bfd_boolean exists;
d447 1
a447 1
		  sizeof NEEDS_SHRLIB - 1) == 0)
d456 1
a456 1
	alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);
d459 2
a460 2
	(*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
			       name);
d462 9
a470 9
	{
	  strcpy (alloc, name);
	  p = strrchr (alloc, '_');
	  *p++ = '\0';
	  (*_bfd_error_handler)
	    (_("Output file requires shared library `%s.so.%s'\n"),
	     alloc, p);
	  free (alloc);
	}
d482 2
a483 2
	 and then again following all of the indirect links until we
	 reach a real symbol.  */
d485 3
a487 3
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, TRUE);
d490 3
a492 3
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, FALSE);
d495 5
a499 5
	 there is no need to have a fixup.  This is because they both
	 came from the same library.  If on the other hand, we had to
	 use an indirect symbol to get to the real symbol, we add the
	 fixup anyway, since there are cases where these symbols come
	 from different shared libraries */
d501 42
a542 42
	  && (((h1->root.root.type == bfd_link_hash_defined
		|| h1->root.root.type == bfd_link_hash_defweak)
	       && ! bfd_is_abs_section (h1->root.root.u.def.section))
	      || h2->root.root.type == bfd_link_hash_indirect))
	{
	  /* See if there is a "builtin" fixup already present
	     involving this symbol.  If so, convert it to a regular
	     fixup.  In the end, this relaxes some of the requirements
	     about the order of performing fixups.  */
	  exists = FALSE;
	  for (f1 = linux_hash_table (info)->fixup_list;
	       f1 != NULL;
	       f1 = f1->next)
	    {
	      if ((f1->h != h && f1->h != h1)
		  || (! f1->builtin && ! f1->jump))
		continue;
	      if (f1->h == h1)
		exists = TRUE;
	      if (! exists
		  && bfd_is_abs_section (h->root.root.u.def.section))
		{
		  f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);
		  f->jump = is_plt;
		}
	      f1->h = h1;
	      f1->jump = is_plt;
	      f1->builtin = 0;
	      exists = TRUE;
	    }
	  if (! exists
	      && bfd_is_abs_section (h->root.root.u.def.section))
	    {
	      f = new_fixup (info, h1, h->root.root.u.def.value, 0);
	      if (f == NULL)
		{
		  /* FIXME: No way to return error.  */
		  abort ();
		}
	      f->jump = is_plt;
	    }
	}
d545 1
a545 1
	 symtab.  */
d547 1
a547 1
	h->root.written = TRUE;
d550 1
a550 1
  return TRUE;
d559 1
a559 1
bfd_boolean
d568 1
a568 1
    return TRUE;
d572 2
a573 2
			    linux_tally_symbols,
			    (PTR) info);
d581 5
a585 5
	{
	  ++linux_hash_table (info)->fixup_count;
	  ++linux_hash_table (info)->local_builtins;
	  break;
	}
d591 2
a592 2
	abort ();
      return TRUE;
d597 1
a597 1
			       ".linux-dynamic");
d604 1
a604 1
	return FALSE;
d607 1
a607 1
  return TRUE;
d614 1
a614 1
static bfd_boolean
d628 1
a628 1
    return TRUE;
d631 1
a631 1
			       ".linux-dynamic");
d638 2
a639 2
	  os->filepos + s->output_offset,
	  os->vma + s->output_offset);
d651 1
a651 1
	continue;
d654 7
a660 7
	  && f->h->root.root.type != bfd_link_hash_defweak)
	{
	  (*_bfd_error_handler)
	    (_("Symbol %s not defined for fixups\n"),
	     f->h->root.root.root.string);
	  continue;
	}
d668 1
a668 1
	      new_addr, f->value);
d672 8
a679 8
	{
	  /* Relative address */
	  new_addr = new_addr - (f->value + 5);
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value + 1, fixup_table);
	  fixup_table += 4;
	}
d681 6
a686 6
	{
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	}
d699 16
a714 16
	{
	  if (! f->builtin)
	    continue;

	  if (f->h->root.root.type != bfd_link_hash_defined
	      && f->h->root.root.type != bfd_link_hash_defweak)
	    {
	      (*_bfd_error_handler)
		(_("Symbol %s not defined for fixups\n"),
		 f->h->root.root.root.string);
	      continue;
	    }

	  is = f->h->root.root.u.def.section;
	  section_offset = is->output_section->vma + is->output_offset;
	  new_addr = f->h->root.root.u.def.value + section_offset;
d717 2
a718 2
	  printf ("Fixup(B) %s: %x %x\n", f->h->root.root.string,
		  new_addr, f->value);
d721 7
a727 7
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
    }
d733 7
a739 7
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
d743 2
a744 2
			      "__BUILTIN_FIXUPS__",
			      FALSE, FALSE, FALSE);
d748 1
a748 1
	  || h->root.root.type == bfd_link_hash_defweak))
d765 1
a765 1
    return FALSE;
d767 3
a769 2
  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd) != s->_raw_size)
    return FALSE;
d771 1
a771 1
  return TRUE;
@


1.9.12.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d27 1
@


1.9.12.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d357 1
a357 1
  if (! info->relocatable
@


1.9.12.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d116 1
a116 1
   pointers to fixup tables.  It will be present in any dynamically
@


1.8
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d602 1
a602 1
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
a604 1
      memset (s->contents, 0, (size_t) s->_raw_size);
@


1.8.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d602 1
a602 1
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d605 1
@


1.8.4.1
log
@merge from trunk
@
text
@d602 1
a602 1
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d605 1
@


1.7
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d233 1
a233 1
  ret = (struct linux_link_hash_table *) bfd_alloc (abfd, amt);
@


1.6
log
@	* version.h: New file.
	* bfd-in.h: (BFD_VERSION): Substitute bfd_version.
	(BFD_VERSION_DATE): Define.
	(BFD_VERSION_STRING): Define.
	* configure.in: AC_SUBST bfd_version, bfd_version_date and
	bfd_version_string.
	(AC_OUTPUT <bfd-in3.h>): Depend on version.h.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.

	* bfd-in.h: Include "symcat.h".
	(CONCAT4): Redefine as for old CAT4.
	* aout-arm.c: Use equivalent CONCAT* macro in place of CAT* macros.
	Add warning regarding whitespace.
	* aout-cris.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aout-sparcle.c: Likewise.
	* aout-tic30.c: Likewise.
	* aout0.c: Likewise.
	* armnetbsd.c: Likewise.
	* demo64.c: Likewise.
	* elf-bfd.h: Likewise.
	* gen-aout.c: Likewise.
	* host-aout.c: Likewise.
	* hp300bsd.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386aout.c: Likewise.
	* i386bsd.c: Likewise.
	* i386dynix.c: Likewise.
	* i386freebsd.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386netbsd.c: Likewise.
	* libaout.h: Likewise.
	* m68k4knetbsd.c: Likewise.
	* m68klinux.c: Likewise.
	* m68klynx.c: Likewise.
	* m68knetbsd.c: Likewise.
	* m88kmach3.c: Likewise.
	* mipsbsd.c: Likewise.
	* newsos3.c: Likewise.
	* ns32knetbsd.c: Likewise.
	* pc532-mach.c: Likewise.
	* pdp11.c: Likewise.
	* riscix.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* sunos.c: Likewise.
	* targets.c: Likewise.
	* vaxnetbsd.c: Likewise.
	* vms-hdr.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001
d441 3
@


1.6.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002
a440 3

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct linux_link_hash_entry *) h->root.root.u.i.link;
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d40 4
a43 1
#define MY(OP) CAT(sparclinux_,OP)
@


1.4
log
@Update copyright notices
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000
d228 1
d230 1
a230 2
  ret = ((struct linux_link_hash_table *)
        bfd_alloc (abfd, sizeof (struct linux_link_hash_table)));
d410 2
a411 1
             BSF_GLOBAL | BSF_CONSTRUCTOR, s, 0, NULL, false, false, NULL)))
d450 1
a450 1
       alloc = (char *) bfd_malloc (strlen (name) + 1);
d594 2
a595 1
      s->_raw_size = 8 + linux_hash_table (info)->fixup_count * 8;
d638 2
a639 1
  bfd_put_32 (output_bfd, linux_hash_table (info)->fixup_count, fixup_table);
d670 1
a670 1
	 bfd_put_32 (output_bfd, new_addr, fixup_table);
d677 1
a677 1
         bfd_put_32 (output_bfd, new_addr, fixup_table);
d688 1
a688 1
      bfd_put_32 (output_bfd, 0, fixup_table);
d690 1
a690 1
      bfd_put_32 (output_bfd, 0, fixup_table);
d716 1
a716 1
         bfd_put_32 (output_bfd, new_addr, fixup_table);
d729 1
a729 1
         bfd_put_32 (output_bfd, 0, fixup_table);
d731 1
a731 1
         bfd_put_32 (output_bfd, 0, fixup_table);
d753 1
a753 1
      bfd_put_32 (output_bfd, new_addr, fixup_table);
d756 1
a756 1
    bfd_put_32 (output_bfd, 0, fixup_table);
d758 2
a759 1
  if (bfd_seek (output_bfd, os->filepos + s->output_offset, SEEK_SET) != 0)
d762 1
a762 1
  if (bfd_write ((PTR) s->contents, 1, s->_raw_size, output_bfd)
@


1.3
log
@2000-12-19  Kazu Hirata  <kazu@@hxi.com>

	* sco5-core.c: Fix formatting.
	* section.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* srec.c: Likewise.
	* stabs.c: Likewise.
	* stab-syms.c: Likewise.
	* sunos.c: Likewise.
	* syms.c: Likewise.
	* sysdep.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2000
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d98 1
a98 1
/* See if a symbol name is a reference to the procedure linkage table. */
d481 1
a481 1
      /* h2 does not follow indirect symbols. */
d538 1
a538 1
        symtab. */
d563 1
a563 1
  /* First find the fixups... */
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d303 1
a303 1
     struct bfd_link_info *info;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

