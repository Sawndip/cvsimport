head	1.33;
access;
symbols
	sid-snapshot-20180601:1.33
	sid-snapshot-20180501:1.33
	sid-snapshot-20180401:1.33
	sid-snapshot-20180301:1.33
	sid-snapshot-20180201:1.33
	sid-snapshot-20180101:1.33
	sid-snapshot-20171201:1.33
	sid-snapshot-20171101:1.33
	sid-snapshot-20171001:1.33
	sid-snapshot-20170901:1.33
	sid-snapshot-20170801:1.33
	sid-snapshot-20170701:1.33
	sid-snapshot-20170601:1.33
	sid-snapshot-20170501:1.33
	sid-snapshot-20170401:1.33
	sid-snapshot-20170301:1.33
	sid-snapshot-20170201:1.33
	sid-snapshot-20170101:1.33
	sid-snapshot-20161201:1.33
	sid-snapshot-20161101:1.33
	sid-snapshot-20160901:1.33
	sid-snapshot-20160801:1.33
	sid-snapshot-20160701:1.33
	sid-snapshot-20160601:1.33
	sid-snapshot-20160501:1.33
	sid-snapshot-20160401:1.33
	sid-snapshot-20160301:1.33
	sid-snapshot-20160201:1.33
	sid-snapshot-20160101:1.33
	sid-snapshot-20151201:1.33
	sid-snapshot-20151101:1.33
	sid-snapshot-20151001:1.33
	sid-snapshot-20150901:1.33
	sid-snapshot-20150801:1.33
	sid-snapshot-20150701:1.33
	sid-snapshot-20150601:1.33
	sid-snapshot-20150501:1.33
	sid-snapshot-20150401:1.33
	sid-snapshot-20150301:1.33
	sid-snapshot-20150201:1.33
	sid-snapshot-20150101:1.33
	sid-snapshot-20141201:1.33
	sid-snapshot-20141101:1.33
	sid-snapshot-20141001:1.33
	sid-snapshot-20140901:1.33
	sid-snapshot-20140801:1.33
	sid-snapshot-20140701:1.33
	sid-snapshot-20140601:1.33
	sid-snapshot-20140501:1.33
	sid-snapshot-20140401:1.33
	sid-snapshot-20140301:1.33
	sid-snapshot-20140201:1.33
	sid-snapshot-20140101:1.33
	sid-snapshot-20131201:1.33
	sid-snapshot-20131101:1.33
	sid-snapshot-20131001:1.33
	binutils-2_24-branch:1.33.0.2
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.29
	sid-snapshot-20130901:1.33
	gdb_7_6_1-2013-08-30-release:1.32
	sid-snapshot-20130801:1.33
	sid-snapshot-20130701:1.33
	sid-snapshot-20130601:1.33
	sid-snapshot-20130501:1.32
	gdb_7_6-2013-04-26-release:1.32
	sid-snapshot-20130401:1.32
	binutils-2_23_2:1.30
	gdb_7_6-branch:1.32.0.2
	gdb_7_6-2013-03-12-branchpoint:1.32
	sid-snapshot-20130301:1.32
	sid-snapshot-20130201:1.32
	sid-snapshot-20130101:1.30
	sid-snapshot-20121201:1.30
	gdb_7_5_1-2012-11-29-release:1.30
	binutils-2_23_1:1.30
	sid-snapshot-20121101:1.30
	binutils-2_23:1.30
	sid-snapshot-20121001:1.30
	sid-snapshot-20120901:1.30
	gdb_7_5-2012-08-17-release:1.30
	sid-snapshot-20120801:1.30
	binutils-2_23-branch:1.30.0.10
	binutils-2_23-branchpoint:1.30
	gdb_7_5-branch:1.30.0.8
	gdb_7_5-2012-07-18-branchpoint:1.30
	sid-snapshot-20120701:1.30
	sid-snapshot-20120601:1.30
	sid-snapshot-20120501:1.30
	binutils-2_22_branch:1.30.0.6
	gdb_7_4_1-2012-04-26-release:1.30
	sid-snapshot-20120401:1.30
	sid-snapshot-20120301:1.30
	sid-snapshot-20120201:1.30
	gdb_7_4-2012-01-24-release:1.30
	sid-snapshot-20120101:1.30
	gdb_7_4-branch:1.30.0.4
	gdb_7_4-2011-12-13-branchpoint:1.30
	sid-snapshot-20111201:1.30
	binutils-2_22:1.30
	sid-snapshot-20111101:1.30
	sid-snapshot-20111001:1.30
	binutils-2_22-branch:1.30.0.2
	binutils-2_22-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.29
	sid-snapshot-20110901:1.30
	sid-snapshot-20110801:1.30
	gdb_7_3-2011-07-26-release:1.29
	sid-snapshot-20110701:1.30
	sid-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	gdb_7_3-branch:1.29.0.10
	gdb_7_3-2011-04-01-branchpoint:1.29
	sid-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	binutils-2_21:1.29
	sid-snapshot-20101201:1.29
	binutils-2_21-branch:1.29.0.8
	binutils-2_21-branchpoint:1.29
	sid-snapshot-20101101:1.29
	sid-snapshot-20101001:1.29
	binutils-2_20_1:1.28.2.1
	gdb_7_2-2010-09-02-release:1.29
	sid-snapshot-20100901:1.29
	sid-snapshot-20100801:1.29
	gdb_7_2-branch:1.29.0.6
	gdb_7_2-2010-07-07-branchpoint:1.29
	sid-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	gdb_7_1-2010-03-18-release:1.29
	sid-snapshot-20100301:1.29
	gdb_7_1-branch:1.29.0.4
	gdb_7_1-2010-02-18-branchpoint:1.29
	sid-snapshot-20100201:1.29
	sid-snapshot-20100101:1.29
	gdb_7_0_1-2009-12-22-release:1.29
	sid-snapshot-20091201:1.29
	sid-snapshot-20091101:1.29
	binutils-2_20:1.28.2.1
	gdb_7_0-2009-10-06-release:1.29
	sid-snapshot-20091001:1.29
	gdb_7_0-branch:1.29.0.2
	gdb_7_0-2009-09-16-branchpoint:1.29
	arc-sim-20090309:1.27
	binutils-arc-20081103-branch:1.27.0.26
	binutils-arc-20081103-branchpoint:1.27
	binutils-2_20-branch:1.28.0.2
	binutils-2_20-branchpoint:1.28
	sid-snapshot-20090901:1.27
	sid-snapshot-20090801:1.27
	msnyder-checkpoint-072509-branch:1.27.0.24
	msnyder-checkpoint-072509-branchpoint:1.27
	sid-snapshot-20090701:1.27
	dje-cgen-play1-branch:1.27.0.22
	dje-cgen-play1-branchpoint:1.27
	sid-snapshot-20090601:1.27
	sid-snapshot-20090501:1.27
	sid-snapshot-20090401:1.27
	arc-20081103-branch:1.27.0.20
	arc-20081103-branchpoint:1.27
	arc-insight_6_8-branch:1.27.0.18
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.16
	insight_6_8-branchpoint:1.27
	sid-snapshot-20090301:1.27
	binutils-2_19_1:1.27
	sid-snapshot-20090201:1.27
	sid-snapshot-20090101:1.27
	reverse-20081226-branch:1.27.0.14
	reverse-20081226-branchpoint:1.27
	sid-snapshot-20081201:1.27
	multiprocess-20081120-branch:1.27.0.12
	multiprocess-20081120-branchpoint:1.27
	sid-snapshot-20081101:1.27
	binutils-2_19:1.27
	sid-snapshot-20081001:1.27
	reverse-20080930-branch:1.27.0.10
	reverse-20080930-branchpoint:1.27
	binutils-2_19-branch:1.27.0.8
	binutils-2_19-branchpoint:1.27
	sid-snapshot-20080901:1.27
	sid-snapshot-20080801:1.27
	reverse-20080717-branch:1.27.0.6
	reverse-20080717-branchpoint:1.27
	sid-snapshot-20080701:1.27
	msnyder-reverse-20080609-branch:1.27.0.4
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.23.0.24
	drow-reverse-20070409-branchpoint:1.23
	sid-snapshot-20080601:1.27
	sid-snapshot-20080501:1.27
	sid-snapshot-20080403:1.27
	sid-snapshot-20080401:1.27
	gdb_6_8-2008-03-27-release:1.27
	sid-snapshot-20080301:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	sid-snapshot-20080201:1.27
	sid-snapshot-20080101:1.26
	sid-snapshot-20071201:1.26
	sid-snapshot-20071101:1.26
	gdb_6_7_1-2007-10-29-release:1.25
	gdb_6_7-2007-10-10-release:1.25
	sid-snapshot-20071001:1.26
	gdb_6_7-branch:1.25.0.4
	gdb_6_7-2007-09-07-branchpoint:1.25
	binutils-2_18:1.25
	binutils-2_18-branch:1.25.0.2
	binutils-2_18-branchpoint:1.25
	insight_6_6-20070208-release:1.23
	binutils-csl-coldfire-4_1-32:1.23
	binutils-csl-sourcerygxx-4_1-32:1.23
	gdb_6_6-2006-12-18-release:1.23
	binutils-csl-innovasic-fido-3_4_4-33:1.23
	binutils-csl-sourcerygxx-3_4_4-32:1.18
	binutils-csl-coldfire-4_1-30:1.23
	binutils-csl-sourcerygxx-4_1-30:1.23
	binutils-csl-coldfire-4_1-28:1.23
	binutils-csl-sourcerygxx-4_1-29:1.23
	binutils-csl-sourcerygxx-4_1-28:1.23
	gdb_6_6-branch:1.23.0.22
	gdb_6_6-2006-11-15-branchpoint:1.23
	binutils-csl-arm-2006q3-27:1.23
	binutils-csl-sourcerygxx-4_1-27:1.23
	binutils-csl-arm-2006q3-26:1.23
	binutils-csl-sourcerygxx-4_1-26:1.23
	binutils-csl-sourcerygxx-4_1-25:1.23
	binutils-csl-sourcerygxx-4_1-24:1.23
	binutils-csl-sourcerygxx-4_1-23:1.23
	insight_6_5-20061003-release:1.23
	gdb-csl-symbian-6_4_50_20060226-12:1.23
	binutils-csl-sourcerygxx-4_1-21:1.23
	binutils-csl-arm-2006q3-21:1.23
	binutils-csl-sourcerygxx-4_1-22:1.23
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.23
	binutils-csl-sourcerygxx-4_1-20:1.23
	binutils-csl-arm-2006q3-19:1.23
	binutils-csl-sourcerygxx-4_1-19:1.23
	binutils-csl-sourcerygxx-4_1-18:1.23
	binutils-csl-renesas-4_1-9:1.23
	gdb-csl-sourcerygxx-3_4_4-25:1.22
	binutils-csl-sourcerygxx-3_4_4-25:1.18
	nickrob-async-20060828-mergepoint:1.23
	gdb-csl-symbian-6_4_50_20060226-11:1.23
	binutils-csl-renesas-4_1-8:1.23
	binutils-csl-renesas-4_1-7:1.23
	binutils-csl-renesas-4_1-6:1.23
	gdb-csl-sourcerygxx-4_1-17:1.23
	binutils-csl-sourcerygxx-4_1-17:1.23
	gdb-csl-20060226-branch-local-2:1.23
	gdb-csl-sourcerygxx-4_1-14:1.23
	binutils-csl-sourcerygxx-4_1-14:1.23
	binutils-csl-sourcerygxx-4_1-15:1.23
	gdb-csl-sourcerygxx-4_1-13:1.23
	binutils-csl-sourcerygxx-4_1-13:1.23
	binutils-2_17:1.23
	gdb-csl-sourcerygxx-4_1-12:1.23
	binutils-csl-sourcerygxx-4_1-12:1.23
	gdb-csl-sourcerygxx-3_4_4-21:1.23
	binutils-csl-sourcerygxx-3_4_4-21:1.23
	gdb_6_5-20060621-release:1.23
	binutils-csl-wrs-linux-3_4_4-24:1.18
	binutils-csl-wrs-linux-3_4_4-23:1.18
	gdb-csl-sourcerygxx-4_1-9:1.23
	binutils-csl-sourcerygxx-4_1-9:1.23
	gdb-csl-sourcerygxx-4_1-8:1.23
	binutils-csl-sourcerygxx-4_1-8:1.23
	gdb-csl-sourcerygxx-4_1-7:1.23
	binutils-csl-sourcerygxx-4_1-7:1.23
	gdb-csl-arm-2006q1-6:1.23
	binutils-csl-arm-2006q1-6:1.23
	gdb-csl-sourcerygxx-4_1-6:1.23
	binutils-csl-sourcerygxx-4_1-6:1.23
	binutils-csl-wrs-linux-3_4_4-22:1.18
	gdb-csl-symbian-6_4_50_20060226-10:1.23
	gdb-csl-symbian-6_4_50_20060226-9:1.23
	gdb-csl-symbian-6_4_50_20060226-8:1.23
	gdb-csl-coldfire-4_1-11:1.23
	binutils-csl-coldfire-4_1-11:1.23
	gdb-csl-sourcerygxx-3_4_4-19:1.23
	binutils-csl-sourcerygxx-3_4_4-19:1.23
	gdb-csl-coldfire-4_1-10:1.23
	gdb_6_5-branch:1.23.0.20
	gdb_6_5-2006-05-14-branchpoint:1.23
	binutils-csl-coldfire-4_1-10:1.23
	gdb-csl-sourcerygxx-4_1-5:1.23
	binutils-csl-sourcerygxx-4_1-5:1.23
	nickrob-async-20060513-branch:1.23.0.18
	nickrob-async-20060513-branchpoint:1.23
	gdb-csl-sourcerygxx-4_1-4:1.23
	binutils-csl-sourcerygxx-4_1-4:1.23
	msnyder-reverse-20060502-branch:1.23.0.16
	msnyder-reverse-20060502-branchpoint:1.23
	binutils-csl-wrs-linux-3_4_4-21:1.18
	gdb-csl-morpho-4_1-4:1.23
	binutils-csl-morpho-4_1-4:1.23
	gdb-csl-sourcerygxx-3_4_4-17:1.23
	binutils-csl-sourcerygxx-3_4_4-17:1.23
	binutils-csl-wrs-linux-3_4_4-20:1.18
	readline_5_1-import-branch:1.23.0.14
	readline_5_1-import-branchpoint:1.23
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.23
	binutils-2_17-branch:1.23.0.12
	binutils-2_17-branchpoint:1.23
	gdb-csl-symbian-20060226-branch:1.23.0.10
	gdb-csl-symbian-20060226-branchpoint:1.23
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.23
	msnyder-reverse-20060331-branch:1.23.0.8
	msnyder-reverse-20060331-branchpoint:1.23
	binutils-csl-2_17-branch:1.23.0.6
	binutils-csl-2_17-branchpoint:1.23
	gdb-csl-available-20060303-branch:1.23.0.4
	gdb-csl-available-20060303-branchpoint:1.23
	gdb-csl-20060226-branch:1.23.0.2
	gdb-csl-20060226-branchpoint:1.23
	gdb_6_4-20051202-release:1.22
	msnyder-fork-checkpoint-branch:1.22.0.8
	msnyder-fork-checkpoint-branchpoint:1.22
	gdb-csl-gxxpro-6_3-branch:1.22.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.22
	gdb_6_4-branch:1.22.0.4
	gdb_6_4-2005-11-01-branchpoint:1.22
	gdb-csl-arm-20051020-branch:1.22.0.2
	gdb-csl-arm-20051020-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.18.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.18
	binutils-2_16_1:1.18
	msnyder-tracepoint-checkpoint-branch:1.21.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.21
	gdb-csl-arm-20050325-2005-q1b:1.18
	binutils-csl-arm-2005q1b:1.18
	binutils-2_16:1.18
	gdb-csl-arm-20050325-2005-q1a:1.18
	binutils-csl-arm-2005q1a:1.18
	csl-arm-20050325-branch:1.18.0.6
	csl-arm-20050325-branchpoint:1.18
	binutils-csl-arm-2005q1-branch:1.18.0.4
	binutils-csl-arm-2005q1-branchpoint:1.18
	binutils-2_16-branch:1.18.0.2
	binutils-2_16-branchpoint:1.18
	csl-arm-2004-q3d:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.18
	gdb_6_3-20041019-branchpoint:1.16
	csl-arm-2004-q3:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.16.0.20
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.16
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	gdb_6_1-2004-04-05-release:1.16
	drow_intercu-merge-20040402:1.16
	drow_intercu-merge-20040327:1.16
	ezannoni_pie-20040323-branch:1.16.0.14
	ezannoni_pie-20040323-branchpoint:1.16
	cagney_tramp-20040321-mergepoint:1.16
	cagney_tramp-20040309-branch:1.16.0.12
	cagney_tramp-20040309-branchpoint:1.16
	gdb_6_1-branch:1.16.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.16
	drow_intercu-20040221-branch:1.16.0.8
	drow_intercu-20040221-branchpoint:1.16
	binutils-2_15-branch:1.16.0.6
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-merge-20040208:1.16
	carlton_dictionary-20040126-merge:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	drow-cplus-merge-20040113:1.16
	csl-arm-2003-q4:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.15.0.6
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.4
	cagney_x86i386-20030821-branch:1.15.0.2
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.18
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.14
	cagney_convert-20030606-branch:1.14.0.14
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.12
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.8
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	binutils-2_14-branch:1.14.0.4
	binutils-2_14-branchpoint:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.2
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.4
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.2
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.10
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.8
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.6
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.4
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.2
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.4
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.8.2.1
	binutils-2_13_2:1.8.2.1
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.8.2.1
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.14
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.12
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.10
	gdb_5_3-branch:1.8.0.8
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.6
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.4
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	kseitz_interps-20020528-branch:1.7.0.10
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.33
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2013.05.23.03.35.59;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.28.07.58.16;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.26.02.08.01;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2008.01.21.04.56.47;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.14.05.19.27;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.13.15.34.28;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.05.21.24.23;	author bwilson;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.17.19.44.55;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.04.15.53.31;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.07.19.26;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.24.20.16.56;	author bje;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.18.08.06.01;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.14.11.16.09;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.05.01.18.55;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.8.2.1
	1.8.12.1
	1.8.14.1;
next	1.7;

1.7
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	2001.08.17.08.57.41;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.17.03.19.01;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.23.20.27.53;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.07.20.00.31.39;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.28.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.25.2.1
date	2007.10.12.14.09.21;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2002.10.28.18.45.45;	author drow;	state Exp;
branches;
next	;

1.8.12.1
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2002.11.15.19.18.28;	author carlton;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2002.12.23.19.37.52;	author carlton;	state Exp;
branches;
next	1.8.12.4;

1.8.12.4
date	2003.03.06.00.56.18;	author carlton;	state Exp;
branches;
next	1.8.12.5;

1.8.12.5
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.8.12.6;

1.8.12.6
date	2003.05.01.00.46.42;	author carlton;	state Exp;
branches;
next	1.8.12.7;

1.8.12.7
date	2003.08.05.17.12.54;	author carlton;	state Exp;
branches;
next	1.8.12.8;

1.8.12.8
date	2003.12.15.23.59.50;	author carlton;	state Exp;
branches;
next	;

1.8.14.1
date	2003.12.14.20.26.46;	author drow;	state Exp;
branches;
next	;

1.7.10.1
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2002.11.05.20.33.26;	author ezannoni;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.33
log
@	* format.c (bfd_check_format_matches): Don't match a target in
	targ_selvecs if some other target is a better match.  If
	targets implement match priority, fall back to the first of
	the best matches.
@
text
@/* Generic BFD support for file formats.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002,
   2003, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/*
SECTION
	File formats

	A format is a BFD concept of high level file contents type. The
	formats supported by BFD are:

	o <<bfd_object>>

	The BFD may contain data, symbols, relocations and debug info.

	o <<bfd_archive>>

	The BFD contains other BFDs and an optional index.

	o <<bfd_core>>

	The BFD contains the result of an executable core dump.

SUBSECTION
	File format functions
*/

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"

/* IMPORT from targets.c.  */
extern const size_t _bfd_target_vector_entries;

/*
FUNCTION
	bfd_check_format

SYNOPSIS
	bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

DESCRIPTION
	Verify if the file attached to the BFD @@var{abfd} is compatible
	with the format @@var{format} (i.e., one of <<bfd_object>>,
	<<bfd_archive>> or <<bfd_core>>).

	If the BFD has been set to a specific target before the
	call, only the named target and format combination is
	checked. If the target has not been set, or has been set to
	<<default>>, then all the known target backends is
	interrogated to determine a match.  If the default target
	matches, it is used.  If not, exactly one target must recognize
	the file, or an error results.

	The function returns <<TRUE>> on success, otherwise <<FALSE>>
	with one of the following error codes:

	o <<bfd_error_invalid_operation>> -
	if <<format>> is not one of <<bfd_object>>, <<bfd_archive>> or
	<<bfd_core>>.

	o <<bfd_error_system_call>> -
	if an error occured during a read - even some file mismatches
	can cause bfd_error_system_calls.

	o <<file_not_recognised>> -
	none of the backends recognised the file format.

	o <<bfd_error_file_ambiguously_recognized>> -
	more than one backend recognised the file format.
*/

bfd_boolean
bfd_check_format (bfd *abfd, bfd_format format)
{
  return bfd_check_format_matches (abfd, format, NULL);
}

struct bfd_preserve
{
  void *marker;
  void *tdata;
  flagword flags;
  const struct bfd_arch_info *arch_info;
  struct bfd_section *sections;
  struct bfd_section *section_last;
  unsigned int section_count;
  struct bfd_hash_table section_htab;
};

/* When testing an object for compatibility with a particular target
   back-end, the back-end object_p function needs to set up certain
   fields in the bfd on successfully recognizing the object.  This
   typically happens in a piecemeal fashion, with failures possible at
   many points.  On failure, the bfd is supposed to be restored to its
   initial state, which is virtually impossible.  However, restoring a
   subset of the bfd state works in practice.  This function stores
   the subset.  */

static bfd_boolean
bfd_preserve_save (bfd *abfd, struct bfd_preserve *preserve)
{
  preserve->tdata = abfd->tdata.any;
  preserve->arch_info = abfd->arch_info;
  preserve->flags = abfd->flags;
  preserve->sections = abfd->sections;
  preserve->section_last = abfd->section_last;
  preserve->section_count = abfd->section_count;
  preserve->section_htab = abfd->section_htab;
  preserve->marker = bfd_alloc (abfd, 1);
  if (preserve->marker == NULL)
    return FALSE;

  return bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc,
			      sizeof (struct section_hash_entry));
}

/* Clear out a subset of BFD state.  */

static void
bfd_reinit (bfd *abfd)
{
  abfd->tdata.any = NULL;
  abfd->arch_info = &bfd_default_arch_struct;
  abfd->flags &= BFD_FLAGS_SAVED;
  bfd_section_list_clear (abfd);
}

/* Restores bfd state saved by bfd_preserve_save.  */

static void
bfd_preserve_restore (bfd *abfd, struct bfd_preserve *preserve)
{
  bfd_hash_table_free (&abfd->section_htab);

  abfd->tdata.any = preserve->tdata;
  abfd->arch_info = preserve->arch_info;
  abfd->flags = preserve->flags;
  abfd->section_htab = preserve->section_htab;
  abfd->sections = preserve->sections;
  abfd->section_last = preserve->section_last;
  abfd->section_count = preserve->section_count;

  /* bfd_release frees all memory more recently bfd_alloc'd than
     its arg, as well as its arg.  */
  bfd_release (abfd, preserve->marker);
  preserve->marker = NULL;
}

/* Called when the bfd state saved by bfd_preserve_save is no longer
   needed.  */

static void
bfd_preserve_finish (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_preserve *preserve)
{
  /* It would be nice to be able to free more memory here, eg. old
     tdata, but that's not possible since these blocks are sitting
     inside bfd_alloc'd memory.  The section hash is on a separate
     objalloc.  */
  bfd_hash_table_free (&preserve->section_htab);
  preserve->marker = NULL;
}

/*
FUNCTION
	bfd_check_format_matches

SYNOPSIS
	bfd_boolean bfd_check_format_matches
	  (bfd *abfd, bfd_format format, char ***matching);

DESCRIPTION
	Like <<bfd_check_format>>, except when it returns FALSE with
	<<bfd_errno>> set to <<bfd_error_file_ambiguously_recognized>>.  In that
	case, if @@var{matching} is not NULL, it will be filled in with
	a NULL-terminated list of the names of the formats that matched,
	allocated with <<malloc>>.
	Then the user may choose a format and try again.

	When done with the list that @@var{matching} points to, the caller
	should free it.
*/

bfd_boolean
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
{
  extern const bfd_target binary_vec;
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ, *match_targ;
  int match_count, best_count, best_match;
  int ar_match_index;
  struct bfd_preserve preserve;

  if (matching != NULL)
    *matching = NULL;

  if (!bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (abfd->format != bfd_unknown)
    return abfd->format == format;

  if (matching != NULL || *bfd_associated_vector != NULL)
    {
      bfd_size_type amt;

      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = (const bfd_target **) bfd_malloc (amt);
      if (!matching_vector)
	return FALSE;
    }

  /* Presume the answer is yes.  */
  abfd->format = format;
  save_targ = abfd->xvec;
  preserve.marker = NULL;

  /* If the target type was explicitly specified, just check that target.  */
  if (!abfd->target_defaulted)
    {
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)	/* rewind! */
	goto err_ret;

      right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));

      if (right_targ)
	goto ok_ret;

      /* For a long time the code has dropped through to check all
	 targets if the specified target was wrong.  I don't know why,
	 and I'm reluctant to change it.  However, in the case of an
	 archive, it can cause problems.  If the specified target does
	 not permit archives (e.g., the binary target), then we should
	 not allow some other target to recognize it as an archive, but
	 should instead allow the specified target to recognize it as an
	 object.  When I first made this change, it broke the PE target,
	 because the specified pei-i386 target did not recognize the
	 actual pe-i386 archive.  Since there may be other problems of
	 this sort, I changed this test to check only for the binary
	 target.  */
      if (format == bfd_archive && save_targ == &binary_vec)
	goto err_unrecog;
    }

  /* Since the target type was defaulted, check them all in the hope
     that one will be uniquely recognized.  */
  right_targ = NULL;
  ar_right_targ = NULL;
  match_targ = NULL;
  best_match = 256;
  best_count = 0;
  match_count = 0;
  ar_match_index = _bfd_target_vector_entries;

  for (target = bfd_target_vector; *target != NULL; target++)
    {
      const bfd_target *temp;

      /* Don't check the default target twice.  */
      if (*target == &binary_vec
	  || (!abfd->target_defaulted && *target == save_targ)
	  || (*target)->match_priority > best_match)
	continue;

      /* If we already tried a match, the bfd is modified and may
	 have sections attached, which will confuse the next
	 _bfd_check_format call.  */
      bfd_reinit (abfd);

      /* Change BFD's target temporarily.  */
      abfd->xvec = *target;

      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	goto err_ret;

      /* If _bfd_check_format neglects to set bfd_error, assume
	 bfd_error_wrong_format.  We didn't used to even pay any
	 attention to bfd_error, so I suspect that some
	 _bfd_check_format might have this problem.  */
      bfd_set_error (bfd_error_wrong_format);

      temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
      if (temp)
	{
	  match_targ = temp;
	  if (preserve.marker != NULL)
	    bfd_preserve_finish (abfd, &preserve);

	  if (abfd->format != bfd_archive
	      || (bfd_has_map (abfd)
		  && bfd_get_error () != bfd_error_wrong_object_format))
	    {
	      /* This format checks out as ok!  */
	      right_targ = temp;

	      /* If this is the default target, accept it, even if
		 other targets might match.  People who want those
		 other targets have to set the GNUTARGET variable.  */
	      if (temp == bfd_default_vector[0])
		goto ok_ret;

	      if (matching_vector)
		matching_vector[match_count] = temp;
	      match_count++;

	      if (temp->match_priority < best_match)
		{
		  best_match = temp->match_priority;
		  best_count = 0;
		}
	      best_count++;
	    }
	  else
	    {
	      /* An archive with no armap or objects of the wrong
		 type.  We want this target to match if we get no
		 better matches.  */
	      if (ar_right_targ != bfd_default_vector[0])
		ar_right_targ = *target;
	      if (matching_vector)
		matching_vector[ar_match_index] = *target;
	      ar_match_index++;
	    }

	  if (!bfd_preserve_save (abfd, &preserve))
	    goto err_ret;
	}
      else if (bfd_get_error () != bfd_error_wrong_format)
	goto err_ret;
    }

  if (best_count == 1)
    match_count = 1;

  if (match_count == 0)
    {
      /* Try partial matches.  */
      right_targ = ar_right_targ;

      if (right_targ == bfd_default_vector[0])
	{
	  match_count = 1;
	}
      else
	{
	  match_count = ar_match_index - _bfd_target_vector_entries;

	  if (matching_vector && match_count > 1)
	    memcpy (matching_vector,
		    matching_vector + _bfd_target_vector_entries,
		    sizeof (*matching_vector) * match_count);
	}
    }

  /* We have more than one equally good match.  If any of the best
     matches is a target in config.bfd targ_defvec or targ_selvecs,
     choose it.  */
  if (match_count > 1)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ
		&& right_targ->match_priority <= best_match)
	      break;

	  if (i >= 0)
	    {
	      match_count = 1;
	      break;
	    }
	}
    }

  /* We still have more than one equally good match, and at least some
     of the targets support match priority.  Choose the first of the
     best matches.  */
  if (match_count > 1 && best_count != match_count)
    {
      int i;

      for (i = 0; i < match_count; i++)
	{
	  right_targ = matching_vector[i];
	  if (right_targ->match_priority <= best_match)
	    break;
	}
      match_count = 1;
    }

  /* There is way too much undoing of half-known state here.  We
     really shouldn't iterate on live bfd's.  Note that saving the
     whole bfd and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);

  if (match_count == 1)
    {
      abfd->xvec = right_targ;
      /* If we come out of the loop knowing that the last target that
	 matched is the one we want, then ABFD should still be in a usable
	 state (except possibly for XVEC).  */
      if (match_targ != right_targ)
	{
	  bfd_reinit (abfd);
	  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	    goto err_ret;
	  match_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
	  BFD_ASSERT (match_targ != NULL);
	}

    ok_ret:
      /* If the file was opened for update, then `output_has_begun'
	 some time ago when the file was created.  Do not recompute
	 sections sizes or alignments in _bfd_set_section_contents.
	 We can not set this flag until after checking the format,
	 because it will interfere with creation of BFD sections.  */
      if (abfd->direction == both_direction)
	abfd->output_has_begun = TRUE;

      if (matching_vector)
	free (matching_vector);

      /* File position has moved, BTW.  */
      return TRUE;
    }

  if (match_count == 0)
    {
    err_unrecog:
      bfd_set_error (bfd_error_file_not_recognized);
    err_ret:
      abfd->xvec = save_targ;
      abfd->format = bfd_unknown;
      if (matching_vector)
	free (matching_vector);
      if (preserve.marker != NULL)
	bfd_preserve_restore (abfd, &preserve);
      return FALSE;
    }

  /* Restore original target type and format.  */
  abfd->xvec = save_targ;
  abfd->format = bfd_unknown;
  bfd_set_error (bfd_error_file_ambiguously_recognized);

  if (matching)
    {
      *matching = (char **) matching_vector;
      matching_vector[match_count] = NULL;
      /* Return target names.  This is a little nasty.  Maybe we
	 should do another bfd_malloc?  */
      while (--match_count >= 0)
	{
	  const char *name = matching_vector[match_count]->name;
	  *(const char **) &matching_vector[match_count] = name;
	}
    }
  return FALSE;
}

/*
FUNCTION
	bfd_set_format

SYNOPSIS
	bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

DESCRIPTION
	This function sets the file format of the BFD @@var{abfd} to the
	format @@var{format}. If the target set in the BFD does not
	support the format requested, the format is invalid, or the BFD
	is not open for writing, then an error occurs.
*/

bfd_boolean
bfd_set_format (bfd *abfd, bfd_format format)
{
  if (bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (abfd->format != bfd_unknown)
    return abfd->format == format;

  /* Presume the answer is yes.  */
  abfd->format = format;

  if (!BFD_SEND_FMT (abfd, _bfd_set_format, (abfd)))
    {
      abfd->format = bfd_unknown;
      return FALSE;
    }

  return TRUE;
}

/*
FUNCTION
	bfd_format_string

SYNOPSIS
	const char *bfd_format_string (bfd_format format);

DESCRIPTION
	Return a pointer to a const string
	<<invalid>>, <<object>>, <<archive>>, <<core>>, or <<unknown>>,
	depending upon the value of @@var{format}.
*/

const char *
bfd_format_string (bfd_format format)
{
  if (((int) format < (int) bfd_unknown)
      || ((int) format >= (int) bfd_type_end))
    return "invalid";

  switch (format)
    {
    case bfd_object:
      return "object";		/* Linker/assembler/compiler output.  */
    case bfd_archive:
      return "archive";		/* Object archive file.  */
    case bfd_core:
      return "core";		/* Core dump.  */
    default:
      return "unknown";
    }
}
@


1.32
log
@	* archive.c (bfd_generic_archive_p): Return target and keep
	ardata on partial matches.
	* format.c (bfd_check_format_matches): Adjust for above
	change.  Remove bfd_error_file_ambiguously_recognized dead
	code.
@
text
@d379 3
d391 2
a392 1
	    if (matching_vector[i] == right_targ)
d403 16
@


1.31
log
@	* bfd.c (struct bfd_preserve, bfd_preserve_save, bfd_preserve_restore,
	bfd_preserve_finish): Move to..
	* format.c: ..here, splitting out..
	(bfd_reinit): ..this.  New function.
	(bfd_check_format_matches): Use bfd_preserve_save/restore to
	keep bfd state for a match.
	* elfcode.h (elf_object_p): Don't use bfd_preserve_save/restore.
	* elfcore.h (elf_core_file_p): Likewise.
	* mach-o.c (bfd_mach_o_header_p): Likewise.
	* pef.c (bfd_pef_object_p, bfd_pef_xlib_object_p): Likewise.
	* xsym.c (bfd_sym_object_p): Likewise.
	* mmo.c (mmo_scan): Clear abfd->symcount.
	* opncls.c (_bfd_new_bfd): Use a smaller section hash table.
	* section.c (bfd_section_list_clear): Clear section_htab.count.
	* bfd-in2.h: Regenerate.
@
text
@a281 1
      bfd_error_type err;
a311 1
	}
d313 6
a318 4
      if (temp && (abfd->format != bfd_archive || bfd_has_map (abfd)))
	{
	  /* This format checks out as ok!  */
	  right_targ = temp;
d320 18
a337 11
	  /* If this is the default target, accept it, even if other
	     targets might match.  People who want those other targets
	     have to set the GNUTARGET variable.  */
	  if (temp == bfd_default_vector[0])
	    goto ok_ret;

	  if (matching_vector)
	    matching_vector[match_count] = temp;
	  match_count++;

	  if (temp->match_priority < best_match)
d339 8
a346 2
	      best_match = temp->match_priority;
	      best_count = 0;
d348 3
a350 14
	  best_count++;
	}
      else if (temp
	       || (err = bfd_get_error ()) == bfd_error_wrong_object_format
	       || err == bfd_error_file_ambiguously_recognized)
	{
	  /* An archive with no armap or objects of the wrong type,
	     or an ambiguous match.  We want this target to match
	     if we get no better matches.  */
	  if (ar_right_targ != bfd_default_vector[0])
	    ar_right_targ = *target;
	  if (matching_vector)
	    matching_vector[ar_match_index] = *target;
	  ar_match_index++;
d352 1
a352 4
      else if (err != bfd_error_wrong_format)
	goto err_ret;

      if (temp && !bfd_preserve_save (abfd, &preserve))
@


1.30
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d98 85
d212 1
a226 6
  /* Since the target type was defaulted, check them
     all in the hope that one will be uniquely recognized.  */
  save_targ = abfd->xvec;
  match_count = 0;
  ar_match_index = _bfd_target_vector_entries;

a236 6
  right_targ = 0;
  ar_right_targ = 0;
  match_targ = 0;
  best_match = 256;
  best_count = 0;

d239 2
d269 10
d290 7
a296 1
      abfd->xvec = *target;	/* Change BFD's target temporarily.  */
d309 5
a313 1
	match_targ = temp;
d352 3
d400 7
d415 1
d419 1
d433 3
a435 1
      return TRUE;			/* File position has moved, BTW.  */
d447 2
d452 3
a454 2
  abfd->xvec = save_targ;		/* Restore original target type.  */
  abfd->format = bfd_unknown;		/* Restore original format.  */
@


1.29
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d124 2
a125 2
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
  int match_count;
d159 3
d200 2
a201 1
	  || (!abfd->target_defaulted && *target == save_targ))
d216 2
d228 1
a228 4
	    {
	      match_count = 1;
	      break;
	    }
d233 7
d258 3
d303 11
a314 2
      abfd->xvec = right_targ;		/* Change BFD's target permanently.  */

@


1.28
log
@update copyright dates
@
text
@d152 1
a152 1
      matching_vector = bfd_malloc (amt);
@


1.28.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d152 1
a152 1
      matching_vector = (const bfd_target **) bfd_malloc (amt);
@


1.27
log
@	PR 4453
	* format.c (bfd_check_format_matches): Don't accept archives as
	fully matching unless they have a map.
@
text
@d3 1
a3 1
   2003, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.26
log
@	* format.c (bfd_check_format_matches): Record matching targets even
	when "matching" is NULL to allow bfd_associated_vector matches.
	Consolidate error return code.  Consolidate ok return code.  Always
	restore original target and format on error.
@
text
@d3 1
a3 1
   2003, 2005, 2007 Free Software Foundation, Inc.
d213 1
a213 1
      if (temp)
d231 2
a232 1
      else if ((err = bfd_get_error ()) == bfd_error_wrong_object_format
d235 3
a237 3
	  /* An archive with objects of the wrong type, or an
	     ambiguous match.  We want this target to match if we get
	     no better matches.  */
@


1.25
log
@Switch sources over to use the GPL version 3
@
text
@d128 3
d147 1
a147 1
  if (matching)
a150 1
      *matching = NULL;
d167 1
a167 5
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}
d172 1
a172 16
	{
	  abfd->xvec = right_targ;	/* Set the target as returned.  */

	  if (matching)
	    free (matching_vector);

	  /* If the file was opened for update, then `output_has_begun'
	     some time ago when the file was created.  Do not recompute
	     sections sizes or alignments in _bfd_set_section_contents.
	     We can not set this flag until after checking the format,
	     because it will interfere with creation of BFD sections.  */
	  if (abfd->direction == both_direction)
	    abfd->output_has_begun = TRUE;

	  return TRUE;			/* File position has moved, BTW.  */
	}
d187 1
a187 11
	{
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching)
	    free (matching_vector);

	  bfd_set_error (bfd_error_file_not_recognized);

	  return FALSE;
	}
d203 1
a203 5
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}
d227 1
a227 1
	  if (matching)
a228 1

d239 1
a239 1
	  if (matching)
d244 1
a244 9
	{
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching)
	    free (matching_vector);

	  return FALSE;
	}
d260 1
a260 1
	  if (matching && match_count > 1)
d267 1
a267 3
  if (match_count > 1
      && bfd_associated_vector != NULL
      && matching)
d289 1
a291 3
      if (matching)
	free (matching_vector);

d300 2
a304 3
  abfd->xvec = save_targ;		/* Restore original target type.  */
  abfd->format = bfd_unknown;		/* Restore original format.  */

d307 1
d309 4
a312 2

      if (matching)
d314 1
d316 6
a321 1
  else
d323 5
a327 3
      bfd_set_error (bfd_error_file_ambiguously_recognized);

      if (matching)
d329 2
a330 9
	  *matching = (char **) matching_vector;
	  matching_vector[match_count] = NULL;
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
a332 1

@


1.25.2.1
log
@	* format.c (bfd_check_format_matches): Record matching targets even
	when "matching" is NULL to allow bfd_associated_vector matches.
	Consolidate error return code.  Consolidate ok return code.  Always
	restore original target and format on error.
@
text
@a127 3
  if (matching != NULL)
    *matching = NULL;

d144 1
a144 1
  if (matching != NULL || *bfd_associated_vector != NULL)
d148 1
d165 5
a169 1
	goto err_ret;
d174 16
a189 1
	goto ok_ret;
d204 11
a214 1
	goto err_unrecog;
d230 5
a234 1
	goto err_ret;
d258 1
a258 1
	  if (matching_vector)
d260 1
d271 1
a271 1
	  if (matching_vector)
d276 9
a284 1
	goto err_ret;
d300 1
a300 1
	  if (matching_vector && match_count > 1)
d307 3
a309 1
  if (match_count > 1)
a330 1
    ok_ret:
d333 3
a343 2
      if (matching_vector)
	free (matching_vector);
d347 3
a351 1
    err_unrecog:
d353 2
a354 4
    err_ret:
      abfd->xvec = save_targ;
      abfd->format = bfd_unknown;
      if (matching_vector)
a355 1
      return FALSE;
d357 3
d361 1
a361 11
  abfd->xvec = save_targ;		/* Restore original target type.  */
  abfd->format = bfd_unknown;		/* Restore original format.  */
  bfd_set_error (bfd_error_file_ambiguously_recognized);

  if (matching)
    {
      *matching = (char **) matching_vector;
      matching_vector[match_count] = NULL;
      /* Return target names.  This is a little nasty.  Maybe we
	 should do another bfd_malloc?  */
      while (--match_count >= 0)
d363 9
a371 2
	  const char *name = matching_vector[match_count]->name;
	  *(const char **) &matching_vector[match_count] = name;
d374 1
@


1.24
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.23
log
@2005-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2008
	* elf.c (_bfd_elf_setup_sections): Return FALSE if
	elf_linked_to_section will be set to NULL.

	* format.c (bfd_check_format_matches): Don't check the default
	target twice.
@
text
@d3 1
a3 1
   2003, 2005 Free Software Foundation, Inc.
d45 1
a46 1
#include "sysdep.h"
@


1.22
log
@        * archive.c: Add missing SUBSECTION for documentation.
        * bfd.c: Likewise.
        * cache.c: Likewise.
        * corefile.c: Likewise.
        * format.c: Likewise.
        * init.c: Likewise.
        * libbfd.c: Likewise.
        * opncls.c: Likewise.
        * elf.c: Remove blank line after SECTION heading.
        * reloc.c: Change "howto manager" SECTION to a SUBSECTION.
@
text
@d220 3
a222 1
      if (*target == &binary_vec)
@


1.21
log
@	* elf.c (_bfd_elf_write_object_contents): Check for non-NULL
	elf_shstrtab.
	* format.c (bfd_check_format_matches): Set output_has_begun
	for both_direction.
	* section.c (bfd_set_section_contents): Use bfd_write_p.  Remove
	special case for both_direction.
@
text
@d41 2
@


1.20
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d176 8
d330 8
@


1.19
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.18
log
@update copyright dates
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.17
log
@	* coffcode.h (coff_sym_filepos): Remove GNU960 conditional code.
	* format.c (bfd_check_format_matches): Likewise.
	* archive.c (BFD_GNU960_ARMAG): Likewise.
	(bfd_generic_archive_p): Likewise.
	(_bfd_write_archive_contents): Likewise.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
@


1.16
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a247 10

#ifdef GNU960
	  /* Big- and little-endian b.out archives look the same, but it
	     doesn't matter: there is no difference in their headers, and
	     member file byte orders will (I hope) be handled appropriately
	     by bfd.  Ditto for big and little coff archives.  And the 4
	     coff/b.out object formats are unambiguous.  So accept the
	     first match we find.  */
	  break;
#endif
@


1.15
log
@Convert to C90 and a few tweaks.
@
text
@d428 1
a428 1
      return "object";		/* Linker/assember/compiler output.  */
@


1.14
log
@Only check associated vector if the matching_vector has been created.
@
text
@d89 1
a89 3
bfd_check_format (abfd, format)
     bfd *abfd;
     bfd_format format;
d99 2
a100 2
	bfd_boolean bfd_check_format_matches (bfd *abfd, bfd_format format,
					      char ***matching);
d115 1
a115 4
bfd_check_format_matches (abfd, format, matching)
     bfd *abfd;
     bfd_format format;
     char ***matching;
d146 1
a146 1
      matching_vector = (const bfd_target **) bfd_malloc (amt);
d163 1
a163 1
	    free ((PTR) matching_vector);
d174 1
a174 1
	    free ((PTR) matching_vector);
d197 1
a197 1
	    free ((PTR) matching_vector);
d218 1
a218 1
	    free ((PTR) matching_vector);
d277 1
a277 1
	    free ((PTR) matching_vector);
d330 1
a330 1
	free ((PTR) matching_vector);
d343 1
a343 1
	free ((PTR) matching_vector);
d381 1
a381 3
bfd_set_format (abfd, format)
     bfd *abfd;
     bfd_format format;
d419 1
a419 2
bfd_format_string (format)
     bfd_format format;
d421 2
a422 2
  if (((int)format <(int) bfd_unknown)
      || ((int)format >=(int) bfd_type_end))
@


1.13
log
@Fix memory leaks
@
text
@d308 3
a310 1
  if (match_count > 1 && bfd_associated_vector != NULL)
@


1.12
log
@Change embedded documentation to use consistent indentation and to split up
long lines.  Change informal style of description for functions lacking real
documentation.
@
text
@d166 5
a170 1
	return FALSE;
d221 5
a225 1
	return FALSE;
@


1.11
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 1
a55 1
	bfd_boolean bfd_check_format(bfd *abfd, bfd_format format);
d101 2
a102 1
	bfd_boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
d214 1
a214 1
      abfd->xvec = *target;	/* Change BFD's target temporarily */
d228 2
a229 1
	{		/* This format checks out as ok!  */
d284 1
d292 1
d294 3
a296 5
	    {
	      memcpy (matching_vector,
		      matching_vector + _bfd_target_vector_entries,
		      sizeof (*matching_vector) * match_count);
	    }
d366 1
a366 1
	bfd_boolean bfd_set_format(bfd *abfd, bfd_format format);
d407 1
a407 1
	const char *bfd_format_string(bfd_format format);
@


1.10
log
@	* config.bfd (sh-*-linux*): Use bfd_elf*_sh64*lin_vec as sh64
	vectors in target_selvecs.
	(shle-*-netbsdelf*): Use bfd_elf*_sh64*nbsd_vec as sh64 vectors
	in target_selvecs.
	(sh-*-netbsdelf*): Likewise.
	* configure.in (assocvecs): New variable.  Handle assocvecs like
	selvecs.
	* configure: Regenerate.
	* format.c (bfd_check_format_matches): Store bfd_target pointers
	in matching_vector instead of target names.  Select first target
	from bfd_associated_vector that matches a list of ambiguous targets.
	* targets.c (_bfd_associated_vector): New array.
	(bfd_associated_vector): New variable.
	(_bfd_target_vector): Add bfd_elf*_sh64*lin_vec.
	* libbfd-in.h (bfd_associated_vector): Declare.
	* libbfd.h: Regenerate.
@
text
@d55 1
a55 1
	boolean bfd_check_format(bfd *abfd, bfd_format format);
d70 1
a70 1
	The function returns <<true>> on success, otherwise <<false>>
d88 1
a88 1
boolean
d101 1
a101 1
	boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
d104 1
a104 1
	Like <<bfd_check_format>>, except when it returns false with
d115 1
a115 1
boolean
d132 1
a132 1
      return false;
d136 1
a136 1
    return (boolean) (abfd->format == format);
d152 1
a152 1
	return false;
d165 1
a165 1
	return false;
d176 1
a176 1
	  return true;			/* File position has moved, BTW.  */
d201 1
a201 1
	  return false;
d216 1
a216 1
	return false;
d274 1
a274 1
	  return false;
d325 1
a325 1
      return true;			/* File position has moved, BTW.  */
d356 1
a356 1
  return false;
d364 1
a364 1
	boolean bfd_set_format(bfd *abfd, bfd_format format);
d373 1
a373 1
boolean
d382 1
a382 1
      return false;
d386 1
a386 1
    return (boolean) (abfd->format == format);
d394 1
a394 1
      return false;
d397 1
a397 1
  return true;
@


1.9
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d122 3
a124 2
  const bfd_target * const *target, *save_targ, *right_targ, *ar_right_targ;
  char **matching_vector = NULL;
d149 2
a150 2
      amt = sizeof (char *) * 2 * _bfd_target_vector_entries;
      matching_vector = (char **) bfd_malloc (amt);
d174 1
a174 1
	    free (matching_vector);
d197 1
a197 1
	    free (matching_vector);
d240 1
a240 1
	    matching_vector[match_count] = temp->name;
d263 1
a263 1
	    matching_vector[ar_match_index] = (*target)->name;
d272 1
a272 1
	    free (matching_vector);
d293 21
a313 1
		      sizeof (char *) * match_count);
d323 1
a323 1
	free (matching_vector);
d336 1
a336 1
	free (matching_vector);
d344 1
a344 1
	  *matching = matching_vector;
d346 7
@


1.8
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d135 1
a135 1
    return abfd->format == format;
d358 1
a358 1
    return abfd->format == format;
@


1.8.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 1
a55 1
	bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
d70 1
a70 1
	The function returns <<TRUE>> on success, otherwise <<FALSE>>
d88 4
a91 2
bfd_boolean
bfd_check_format (bfd *abfd, bfd_format format)
d101 1
a101 2
	bfd_boolean bfd_check_format_matches
	  (bfd *abfd, bfd_format format, char ***matching);
d104 1
a104 1
	Like <<bfd_check_format>>, except when it returns FALSE with
d115 5
a119 2
bfd_boolean
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
d122 2
a123 3
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
d131 1
a131 1
      return FALSE;
d148 2
a149 2
      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = bfd_malloc (amt);
d151 1
a151 1
	return FALSE;
d164 1
a164 5
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}
d175 1
a175 1
	  return TRUE;			/* File position has moved, BTW.  */
d200 1
a200 1
	  return FALSE;
d212 1
a212 1
      abfd->xvec = *target;	/* Change BFD's target temporarily.  */
d215 1
a215 5
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}
d226 1
a226 2
	{
	  /* This format checks out as ok!  */
d239 1
a239 1
	    matching_vector[match_count] = temp;
d262 1
a262 1
	    matching_vector[ar_match_index] = *target;
d273 1
a273 1
	  return FALSE;
a280 1

a287 1

a288 21
	    memcpy (matching_vector,
		    matching_vector + _bfd_target_vector_entries,
		    sizeof (*matching_vector) * match_count);
	}
    }

  if (match_count > 1
      && bfd_associated_vector != NULL
      && matching)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ)
	      break;

	  if (i >= 0)
d290 3
a292 2
	      match_count = 1;
	      break;
d304 1
a304 1
      return TRUE;			/* File position has moved, BTW.  */
d323 1
a323 1
	  *matching = (char **) matching_vector;
a324 7
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
d328 1
a328 1
  return FALSE;
d336 1
a336 1
	bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
d345 4
a348 2
bfd_boolean
bfd_set_format (bfd *abfd, bfd_format format)
d354 1
a354 1
      return FALSE;
d366 1
a366 1
      return FALSE;
d369 1
a369 1
  return TRUE;
d377 1
a377 1
	const char *bfd_format_string (bfd_format format);
d386 2
a387 1
bfd_format_string (bfd_format format)
d389 2
a390 2
  if (((int) format < (int) bfd_unknown)
      || ((int) format >= (int) bfd_type_end))
d396 1
a396 1
      return "object";		/* Linker/assembler/compiler output.  */
@


1.8.2.1
log
@Merge from mainline.
@
text
@d135 1
a135 1
    return (boolean) (abfd->format == format);
d358 1
a358 1
    return (boolean) (abfd->format == format);
@


1.8.12.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d135 1
a135 1
    return (boolean) (abfd->format == format);
d358 1
a358 1
    return (boolean) (abfd->format == format);
@


1.8.12.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d122 2
a123 3
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
d148 2
a149 2
      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = (const bfd_target **) bfd_malloc (amt);
d173 1
a173 1
	    free ((PTR) matching_vector);
d196 1
a196 1
	    free ((PTR) matching_vector);
d239 1
a239 1
	    matching_vector[match_count] = temp;
d262 1
a262 1
	    matching_vector[ar_match_index] = *target;
d271 1
a271 1
	    free ((PTR) matching_vector);
d292 1
a292 21
		      sizeof (*matching_vector) * match_count);
	    }
	}
    }

  if (match_count > 1 && bfd_associated_vector != NULL)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ)
	      break;

	  if (i >= 0)
	    {
	      match_count = 1;
	      break;
d302 1
a302 1
	free ((PTR) matching_vector);
d315 1
a315 1
	free ((PTR) matching_vector);
d323 1
a323 1
	  *matching = (char **) matching_vector;
a324 7
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
@


1.8.12.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d55 1
a55 1
	bfd_boolean bfd_check_format(bfd *abfd, bfd_format format);
d70 1
a70 1
	The function returns <<TRUE>> on success, otherwise <<FALSE>>
d88 1
a88 1
bfd_boolean
d101 1
a101 1
	bfd_boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
d104 1
a104 1
	Like <<bfd_check_format>>, except when it returns FALSE with
d115 1
a115 1
bfd_boolean
d132 1
a132 1
      return FALSE;
d136 1
a136 1
    return abfd->format == format;
d152 1
a152 1
	return FALSE;
d165 1
a165 1
	return FALSE;
d176 1
a176 1
	  return TRUE;			/* File position has moved, BTW.  */
d201 1
a201 1
	  return FALSE;
d216 1
a216 1
	return FALSE;
d274 1
a274 1
	  return FALSE;
d325 1
a325 1
      return TRUE;			/* File position has moved, BTW.  */
d356 1
a356 1
  return FALSE;
d364 1
a364 1
	bfd_boolean bfd_set_format(bfd *abfd, bfd_format format);
d373 1
a373 1
bfd_boolean
d382 1
a382 1
      return FALSE;
d386 1
a386 1
    return abfd->format == format;
d394 1
a394 1
      return FALSE;
d397 1
a397 1
  return TRUE;
@


1.8.12.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 1
a55 1
	bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
d101 1
a101 2
	bfd_boolean bfd_check_format_matches (bfd *abfd, bfd_format format,
					      char ***matching);
d213 1
a213 1
      abfd->xvec = *target;	/* Change BFD's target temporarily.  */
d227 1
a227 2
	{
	  /* This format checks out as ok!  */
a281 1

a288 1

d290 5
a294 3
	    memcpy (matching_vector,
		    matching_vector + _bfd_target_vector_entries,
		    sizeof (*matching_vector) * match_count);
d364 1
a364 1
	bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
d405 1
a405 1
	const char *bfd_format_string (bfd_format format);
@


1.8.12.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d166 1
a166 5
	{
	  if (matching)
	    free ((PTR) matching_vector);
	  return FALSE;
	}
d217 1
a217 5
	{
	  if (matching)
	    free ((PTR) matching_vector);
	  return FALSE;
	}
@


1.8.12.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d308 1
a308 3
  if (match_count > 1
      && bfd_associated_vector != NULL
      && matching)
@


1.8.12.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d89 3
a91 1
bfd_check_format (bfd *abfd, bfd_format format)
d101 2
a102 2
	bfd_boolean bfd_check_format_matches
	  (bfd *abfd, bfd_format format, char ***matching);
d117 4
a120 1
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
d151 1
a151 1
      matching_vector = bfd_malloc (amt);
d168 1
a168 1
	    free (matching_vector);
d179 1
a179 1
	    free (matching_vector);
d202 1
a202 1
	    free (matching_vector);
d223 1
a223 1
	    free (matching_vector);
d282 1
a282 1
	    free (matching_vector);
d335 1
a335 1
	free (matching_vector);
d348 1
a348 1
	free (matching_vector);
d386 3
a388 1
bfd_set_format (bfd *abfd, bfd_format format)
d426 2
a427 1
bfd_format_string (bfd_format format)
d429 2
a430 2
  if (((int) format < (int) bfd_unknown)
      || ((int) format >= (int) bfd_type_end))
@


1.8.12.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d428 1
a428 1
      return "object";		/* Linker/assembler/compiler output.  */
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
d358 1
a358 1
    return (abfd->format == format) ? true : false;
@


1.7.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002
d358 1
a358 1
    return abfd->format == format;
@


1.7.10.2
log
@merge from mainline
@
text
@d135 1
a135 1
    return (boolean) (abfd->format == format);
d358 1
a358 1
    return (boolean) (abfd->format == format);
@


1.7.10.3
log
@merge from mainline
@
text
@d122 2
a123 3
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
d148 2
a149 2
      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = (const bfd_target **) bfd_malloc (amt);
d173 1
a173 1
	    free ((PTR) matching_vector);
d196 1
a196 1
	    free ((PTR) matching_vector);
d239 1
a239 1
	    matching_vector[match_count] = temp;
d262 1
a262 1
	    matching_vector[ar_match_index] = *target;
d271 1
a271 1
	    free ((PTR) matching_vector);
d292 1
a292 21
		      sizeof (*matching_vector) * match_count);
	    }
	}
    }

  if (match_count > 1 && bfd_associated_vector != NULL)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ)
	      break;

	  if (i >= 0)
	    {
	      match_count = 1;
	      break;
d302 1
a302 1
	free ((PTR) matching_vector);
d315 1
a315 1
	free ((PTR) matching_vector);
d323 1
a323 1
	  *matching = (char **) matching_vector;
a324 7
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
@


1.6
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d145 2
d148 2
a149 3
      matching_vector =
	(char **) bfd_malloc (sizeof (char *)
			      * 2 * _bfd_target_vector_entries);
d163 1
a163 1
      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)	/* rewind! */
d214 1
a214 1
      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)
@


1.5
log
@	* bfd.c (enum bfd_error): Add bfd_error_wrong_object_format.
	(bfd_errmsgs): Add corresponding message.
	* archive.c (bfd_generic_archive_p): Don't release bfd_ardata when
	finding an archive that contains different format object files.
	Return bfd_error_wrong_object_format for this case.
	* format.c: Formatting fixes.  s/CONST/const/.
	(bfd_check_format_matches): Accept archives that give
	bfd_error_wrong_object_format if no full match is found.  Tidy
	code handling matching_vector.  Don't return a pointer to freed
	memory in `matching'.  Handle ambiguous matches as for partial
	archive matches.
	* bfd-in2.h: Regenerate.
@
text
@d128 1
a128 2
      || abfd->format < bfd_unknown
      || abfd->format >= bfd_type_end)
d350 1
a350 2
      || abfd->format < bfd_unknown
      || abfd->format >= bfd_type_end)
@


1.4
log
@Update copyright notices
@
text
@d122 1
a122 1
  const bfd_target * const *target, *save_targ, *right_targ;
d125 1
d127 3
a129 3
  if (!bfd_read_p (abfd) ||
      ((int)(abfd->format) < (int)bfd_unknown) ||
      ((int)(abfd->format) >= (int)bfd_type_end))
d136 1
a136 1
    return (abfd->format == format)? true: false;
d142 1
d146 1
d148 2
a149 2
	(char **) bfd_malloc (sizeof (char *) *
			      (_bfd_target_vector_entries + 1));
a151 2
      matching_vector[0] = NULL;
      *matching = matching_vector;
d155 1
d207 1
a228 8
	  if (matching)
	    {
	      matching_vector[match_count] = temp->name;
	      matching_vector[match_count + 1] = NULL;
	    }

	  match_count++;

a233 5
	      if (matching)
		{
		  matching_vector[0] = temp->name;
		  matching_vector[1] = NULL;
		}
d237 6
d253 13
a265 1
      else if (bfd_get_error () != bfd_error_wrong_format)
d270 1
a270 2
	  if (matching && bfd_get_error ()
	      != bfd_error_file_ambiguously_recognized)
d277 20
d318 9
a326 1
    bfd_set_error (bfd_error_file_ambiguously_recognized);
d350 3
a352 3
  if (bfd_read_p (abfd) ||
      ((int)abfd->format < (int)bfd_unknown) ||
      ((int)abfd->format >= (int)bfd_type_end))
d378 1
a378 1
	CONST char *bfd_format_string(bfd_format format);
d386 1
a386 1
CONST char *
@


1.3
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd.c: Likewise.
	* bfd-in2.h: Likewise.
	* bfd-in.h: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* dwarf2.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* format.c: Likewise.
	* freebsd.h: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1999 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.2
log
@Fix formatting
@
text
@d26 1
a26 1
	formats supported by BFD are: 
a39 1

d70 1
a70 1
	with one of the following error codes:  
d111 1
a111 1
	should free it.  
d136 1
a136 1
  /* Since the target type was defaulted, check them 
d140 1
a140 1
  
d151 1
a151 1
  
d162 1
a162 1
      
d164 1
a164 1
      
d168 1
a168 1
	  
d171 1
a171 1
	  
d191 1
a191 1
	  
d194 1
a194 1
	  
d196 1
a196 1
	  
d204 1
a204 1
      
d207 1
a207 1
      
d209 1
a209 1
      
d212 1
a212 1
      
d220 1
a220 1
      
d224 1
a224 1
	  
d230 1
a230 1
	  
d232 1
a232 1
	  
d260 1
a260 1
	  
d264 1
a264 1
	  
d268 1
a268 1
  
d272 1
a272 1
      
d275 1
a275 1
      
d281 1
a281 1
  
d285 1
a285 1
      
d291 1
a291 1
  
a336 1

d354 2
a355 2
  if (((int)format <(int) bfd_unknown) 
      || ((int)format >=(int) bfd_type_end)) 
d357 1
a357 1
  
d362 1
a362 1
    case bfd_archive: 
d364 1
a364 1
    case bfd_core: 
d366 1
a366 1
    default: 
@


1.1
log
@Initial revision
@
text
@d128 5
a132 4
      ((int)(abfd->format) >= (int)bfd_type_end)) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
a136 1

a138 1

d141 1
d152 1
d155 1
a155 2

  /* presume the answer is yes */
d159 16
d176 24
a199 9
  if (!abfd->target_defaulted) {
    if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)	/* rewind! */
      return false;
    right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
    if (right_targ) {
      abfd->xvec = right_targ;		/* Set the target as returned */
      if (matching)
	free (matching_vector);
      return true;			/* File position has moved, BTW */
d202 10
a211 20
    /* For a long time the code has dropped through to check all
       targets if the specified target was wrong.  I don't know why,
       and I'm reluctant to change it.  However, in the case of an
       archive, it can cause problems.  If the specified target does
       not permit archives (e.g., the binary target), then we should
       not allow some other target to recognize it as an archive, but
       should instead allow the specified target to recognize it as an
       object.  When I first made this change, it broke the PE target,
       because the specified pei-i386 target did not recognize the
       actual pe-i386 archive.  Since there may be other problems of
       this sort, I changed this test to check only for the binary
       target.  */

    if (format == bfd_archive && save_targ == &binary_vec)
      {
	abfd->xvec = save_targ;
	abfd->format = bfd_unknown;
	if (matching)
	  free (matching_vector);
	bfd_set_error (bfd_error_file_not_recognized);
d213 13
a225 30
      }
  }

  for (target = bfd_target_vector; *target != NULL; target++) {
    const bfd_target *temp;

    if (*target == &binary_vec)
      continue;

    abfd->xvec = *target;	/* Change BFD's target temporarily */
    if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)
      return false;
    /* If _bfd_check_format neglects to set bfd_error, assume bfd_error_wrong_format.
       We didn't used to even pay any attention to bfd_error, so I suspect
       that some _bfd_check_format might have this problem.  */
    bfd_set_error (bfd_error_wrong_format);
    temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
    if (temp) {				/* This format checks out as ok! */
      right_targ = temp;
      if (matching)
	{
	  matching_vector[match_count] = temp->name;
	  matching_vector[match_count + 1] = NULL;
	}
      match_count++;
      /* If this is the default target, accept it, even if other targets
	 might match.  People who want those other targets have to set 
	 the GNUTARGET variable.  */
      if (temp == bfd_default_vector[0])
	{
d228 2
a229 2
	      matching_vector[0] = temp->name;
	      matching_vector[1] = NULL;
d231 23
a253 1
	  match_count = 1;
d255 1
d257 18
a274 13
#ifdef GNU960
      /* Big- and little-endian b.out archives look the same, but it doesn't
       * matter: there is no difference in their headers, and member file byte
       * orders will (I hope) be handled appropriately by bfd.  Ditto for big
       * and little coff archives.  And the 4 coff/b.out object formats are
       * unambiguous.  So accept the first match we find.
       */
      break;
#endif
    } else if (bfd_get_error () != bfd_error_wrong_format) {
      abfd->xvec = save_targ;
      abfd->format = bfd_unknown;
      if (matching && bfd_get_error () != bfd_error_file_ambiguously_recognized)
d276 2
a277 1
      return false;
a278 1
  }
d280 3
a282 9
  if (match_count == 1) {
    abfd->xvec = right_targ;		/* Change BFD's target permanently */
    if (matching)
      free (matching_vector);
    return true;			/* File position has moved, BTW */
  }

  abfd->xvec = save_targ;		/* Restore original target type */
  abfd->format = bfd_unknown;		/* Restore original format */
d286 1
d292 1
a307 1

a314 1

d317 5
a321 4
      ((int)abfd->format >= (int)bfd_type_end)) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
d324 1
a324 1
    return (abfd->format == format) ? true:false;
d326 1
a326 1
  /* presume the answer is yes */
d329 5
a333 4
  if (!BFD_SEND_FMT (abfd, _bfd_set_format, (abfd))) {
    abfd->format = bfd_unknown;
    return false;
  }
d360 11
a370 10
  switch (format) {
  case bfd_object:
    return "object";		/* linker/assember/compiler output */
  case bfd_archive: 
    return "archive";		/* object archive file */
  case bfd_core: 
    return "core";		/* core dump */
  default: 
    return "unknown";
  }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

