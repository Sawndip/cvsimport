head	1.118;
access;
symbols
	sid-snapshot-20180601:1.118
	sid-snapshot-20180501:1.118
	sid-snapshot-20180401:1.118
	sid-snapshot-20180301:1.118
	sid-snapshot-20180201:1.118
	sid-snapshot-20180101:1.118
	sid-snapshot-20171201:1.118
	sid-snapshot-20171101:1.118
	sid-snapshot-20171001:1.118
	sid-snapshot-20170901:1.118
	sid-snapshot-20170801:1.118
	sid-snapshot-20170701:1.118
	sid-snapshot-20170601:1.118
	sid-snapshot-20170501:1.118
	sid-snapshot-20170401:1.118
	sid-snapshot-20170301:1.118
	sid-snapshot-20170201:1.118
	sid-snapshot-20170101:1.118
	sid-snapshot-20161201:1.118
	sid-snapshot-20161101:1.118
	sid-snapshot-20160901:1.118
	sid-snapshot-20160801:1.118
	sid-snapshot-20160701:1.118
	sid-snapshot-20160601:1.118
	sid-snapshot-20160501:1.118
	sid-snapshot-20160401:1.118
	sid-snapshot-20160301:1.118
	sid-snapshot-20160201:1.118
	sid-snapshot-20160101:1.118
	sid-snapshot-20151201:1.118
	sid-snapshot-20151101:1.118
	sid-snapshot-20151001:1.118
	sid-snapshot-20150901:1.118
	sid-snapshot-20150801:1.118
	sid-snapshot-20150701:1.118
	sid-snapshot-20150601:1.118
	sid-snapshot-20150501:1.118
	sid-snapshot-20150401:1.118
	sid-snapshot-20150301:1.118
	sid-snapshot-20150201:1.118
	sid-snapshot-20150101:1.118
	sid-snapshot-20141201:1.118
	sid-snapshot-20141101:1.118
	sid-snapshot-20141001:1.118
	sid-snapshot-20140901:1.118
	sid-snapshot-20140801:1.118
	sid-snapshot-20140701:1.118
	sid-snapshot-20140601:1.118
	sid-snapshot-20140501:1.118
	sid-snapshot-20140401:1.118
	sid-snapshot-20140301:1.118
	sid-snapshot-20140201:1.118
	sid-snapshot-20140101:1.118
	sid-snapshot-20131201:1.118
	sid-snapshot-20131101:1.118
	sid-snapshot-20131001:1.118
	binutils-2_24-branch:1.118.0.4
	binutils-2_24-branchpoint:1.118
	binutils-2_21_1:1.103.2.1
	sid-snapshot-20130901:1.118
	gdb_7_6_1-2013-08-30-release:1.118
	sid-snapshot-20130801:1.118
	sid-snapshot-20130701:1.118
	sid-snapshot-20130601:1.118
	sid-snapshot-20130501:1.118
	gdb_7_6-2013-04-26-release:1.118
	sid-snapshot-20130401:1.118
	binutils-2_23_2:1.115
	gdb_7_6-branch:1.118.0.2
	gdb_7_6-2013-03-12-branchpoint:1.118
	sid-snapshot-20130301:1.118
	sid-snapshot-20130201:1.116
	sid-snapshot-20130101:1.115
	sid-snapshot-20121201:1.115
	gdb_7_5_1-2012-11-29-release:1.115
	binutils-2_23_1:1.115
	sid-snapshot-20121101:1.115
	binutils-2_23:1.115
	sid-snapshot-20121001:1.115
	sid-snapshot-20120901:1.115
	gdb_7_5-2012-08-17-release:1.115
	sid-snapshot-20120801:1.115
	binutils-2_23-branch:1.115.0.4
	binutils-2_23-branchpoint:1.115
	gdb_7_5-branch:1.115.0.2
	gdb_7_5-2012-07-18-branchpoint:1.115
	sid-snapshot-20120701:1.114
	sid-snapshot-20120601:1.112
	sid-snapshot-20120501:1.111
	binutils-2_22_branch:1.109.0.6
	gdb_7_4_1-2012-04-26-release:1.109
	sid-snapshot-20120401:1.111
	sid-snapshot-20120301:1.111
	sid-snapshot-20120201:1.111
	gdb_7_4-2012-01-24-release:1.109
	sid-snapshot-20120101:1.111
	gdb_7_4-branch:1.109.0.4
	gdb_7_4-2011-12-13-branchpoint:1.109
	sid-snapshot-20111201:1.109
	binutils-2_22:1.109
	sid-snapshot-20111101:1.109
	sid-snapshot-20111001:1.109
	binutils-2_22-branch:1.109.0.2
	binutils-2_22-branchpoint:1.109
	gdb_7_3_1-2011-09-04-release:1.105
	sid-snapshot-20110901:1.109
	sid-snapshot-20110801:1.109
	gdb_7_3-2011-07-26-release:1.105
	sid-snapshot-20110701:1.109
	sid-snapshot-20110601:1.106
	sid-snapshot-20110501:1.106
	gdb_7_3-branch:1.105.0.2
	gdb_7_3-2011-04-01-branchpoint:1.105
	sid-snapshot-20110401:1.105
	sid-snapshot-20110301:1.104
	sid-snapshot-20110201:1.104
	sid-snapshot-20110101:1.104
	binutils-2_21:1.103
	sid-snapshot-20101201:1.103
	binutils-2_21-branch:1.103.0.2
	binutils-2_21-branchpoint:1.103
	sid-snapshot-20101101:1.103
	sid-snapshot-20101001:1.102
	binutils-2_20_1:1.95.4.2
	gdb_7_2-2010-09-02-release:1.100
	sid-snapshot-20100901:1.101
	sid-snapshot-20100801:1.100
	gdb_7_2-branch:1.100.0.2
	gdb_7_2-2010-07-07-branchpoint:1.100
	sid-snapshot-20100701:1.100
	sid-snapshot-20100601:1.100
	sid-snapshot-20100501:1.99
	sid-snapshot-20100401:1.99
	gdb_7_1-2010-03-18-release:1.99
	sid-snapshot-20100301:1.99
	gdb_7_1-branch:1.99.0.2
	gdb_7_1-2010-02-18-branchpoint:1.99
	sid-snapshot-20100201:1.99
	sid-snapshot-20100101:1.98
	gdb_7_0_1-2009-12-22-release:1.97
	sid-snapshot-20091201:1.98
	sid-snapshot-20091101:1.98
	binutils-2_20:1.95.4.2
	gdb_7_0-2009-10-06-release:1.97
	sid-snapshot-20091001:1.98
	gdb_7_0-branch:1.97.0.2
	gdb_7_0-2009-09-16-branchpoint:1.97
	arc-sim-20090309:1.88
	binutils-arc-20081103-branch:1.91.0.10
	binutils-arc-20081103-branchpoint:1.91
	binutils-2_20-branch:1.95.0.4
	binutils-2_20-branchpoint:1.95
	sid-snapshot-20090901:1.95
	sid-snapshot-20090801:1.95
	msnyder-checkpoint-072509-branch:1.95.0.2
	msnyder-checkpoint-072509-branchpoint:1.95
	sid-snapshot-20090701:1.94
	dje-cgen-play1-branch:1.94.0.2
	dje-cgen-play1-branchpoint:1.94
	sid-snapshot-20090601:1.94
	sid-snapshot-20090501:1.94
	sid-snapshot-20090401:1.93
	arc-20081103-branch:1.91.0.8
	arc-20081103-branchpoint:1.91
	arc-insight_6_8-branch:1.88.0.6
	arc-insight_6_8-branchpoint:1.88
	insight_6_8-branch:1.88.0.4
	insight_6_8-branchpoint:1.88
	sid-snapshot-20090301:1.93
	binutils-2_19_1:1.91
	sid-snapshot-20090201:1.93
	sid-snapshot-20090101:1.93
	reverse-20081226-branch:1.93.0.2
	reverse-20081226-branchpoint:1.93
	sid-snapshot-20081201:1.91
	multiprocess-20081120-branch:1.91.0.6
	multiprocess-20081120-branchpoint:1.91
	sid-snapshot-20081101:1.91
	binutils-2_19:1.91
	sid-snapshot-20081001:1.91
	reverse-20080930-branch:1.91.0.4
	reverse-20080930-branchpoint:1.91
	binutils-2_19-branch:1.91.0.2
	binutils-2_19-branchpoint:1.91
	sid-snapshot-20080901:1.91
	sid-snapshot-20080801:1.91
	reverse-20080717-branch:1.90.0.4
	reverse-20080717-branchpoint:1.90
	sid-snapshot-20080701:1.90
	msnyder-reverse-20080609-branch:1.90.0.2
	msnyder-reverse-20080609-branchpoint:1.90
	drow-reverse-20070409-branch:1.81.0.2
	drow-reverse-20070409-branchpoint:1.81
	sid-snapshot-20080601:1.90
	sid-snapshot-20080501:1.90
	sid-snapshot-20080403:1.90
	sid-snapshot-20080401:1.90
	gdb_6_8-2008-03-27-release:1.88
	sid-snapshot-20080301:1.88
	gdb_6_8-branch:1.88.0.2
	gdb_6_8-2008-02-26-branchpoint:1.88
	sid-snapshot-20080201:1.88
	sid-snapshot-20080101:1.88
	sid-snapshot-20071201:1.87
	sid-snapshot-20071101:1.87
	gdb_6_7_1-2007-10-29-release:1.86
	gdb_6_7-2007-10-10-release:1.86
	sid-snapshot-20071001:1.86
	gdb_6_7-branch:1.86.0.2
	gdb_6_7-2007-09-07-branchpoint:1.86
	binutils-2_18:1.85
	binutils-2_18-branch:1.85.0.2
	binutils-2_18-branchpoint:1.85
	insight_6_6-20070208-release:1.79
	binutils-csl-coldfire-4_1-32:1.73.6.1
	binutils-csl-sourcerygxx-4_1-32:1.73.6.1
	gdb_6_6-2006-12-18-release:1.79
	binutils-csl-innovasic-fido-3_4_4-33:1.73.6.1
	binutils-csl-sourcerygxx-3_4_4-32:1.64.2.1
	binutils-csl-coldfire-4_1-30:1.73.6.1
	binutils-csl-sourcerygxx-4_1-30:1.73.6.1
	binutils-csl-coldfire-4_1-28:1.73.6.1
	binutils-csl-sourcerygxx-4_1-29:1.73.6.1
	binutils-csl-sourcerygxx-4_1-28:1.73.6.1
	gdb_6_6-branch:1.79.0.2
	gdb_6_6-2006-11-15-branchpoint:1.79
	binutils-csl-arm-2006q3-27:1.73.6.1
	binutils-csl-sourcerygxx-4_1-27:1.73.6.1
	binutils-csl-arm-2006q3-26:1.73.6.1
	binutils-csl-sourcerygxx-4_1-26:1.73.6.1
	binutils-csl-sourcerygxx-4_1-25:1.73.6.1
	binutils-csl-sourcerygxx-4_1-24:1.73.6.1
	binutils-csl-sourcerygxx-4_1-23:1.73.6.1
	insight_6_5-20061003-release:1.77
	gdb-csl-symbian-6_4_50_20060226-12:1.73
	binutils-csl-sourcerygxx-4_1-21:1.73.6.1
	binutils-csl-arm-2006q3-21:1.73.6.1
	binutils-csl-sourcerygxx-4_1-22:1.73.6.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.73.6.1
	binutils-csl-sourcerygxx-4_1-20:1.73.6.1
	binutils-csl-arm-2006q3-19:1.73.6.1
	binutils-csl-sourcerygxx-4_1-19:1.73.6.1
	binutils-csl-sourcerygxx-4_1-18:1.73.6.1
	binutils-csl-renesas-4_1-9:1.73.6.1
	gdb-csl-sourcerygxx-3_4_4-25:1.72
	binutils-csl-sourcerygxx-3_4_4-25:1.64.2.1
	nickrob-async-20060828-mergepoint:1.78
	gdb-csl-symbian-6_4_50_20060226-11:1.73
	binutils-csl-renesas-4_1-8:1.73
	binutils-csl-renesas-4_1-7:1.73
	binutils-csl-renesas-4_1-6:1.73
	gdb-csl-sourcerygxx-4_1-17:1.73
	binutils-csl-sourcerygxx-4_1-17:1.73
	gdb-csl-20060226-branch-local-2:1.73
	gdb-csl-sourcerygxx-4_1-14:1.73
	binutils-csl-sourcerygxx-4_1-14:1.73
	binutils-csl-sourcerygxx-4_1-15:1.73
	gdb-csl-sourcerygxx-4_1-13:1.73
	binutils-csl-sourcerygxx-4_1-13:1.73
	binutils-2_17:1.73.12.1
	gdb-csl-sourcerygxx-4_1-12:1.73
	binutils-csl-sourcerygxx-4_1-12:1.73
	gdb-csl-sourcerygxx-3_4_4-21:1.73
	binutils-csl-sourcerygxx-3_4_4-21:1.73
	gdb_6_5-20060621-release:1.77
	binutils-csl-wrs-linux-3_4_4-24:1.64
	binutils-csl-wrs-linux-3_4_4-23:1.64
	gdb-csl-sourcerygxx-4_1-9:1.73
	binutils-csl-sourcerygxx-4_1-9:1.73
	gdb-csl-sourcerygxx-4_1-8:1.73
	binutils-csl-sourcerygxx-4_1-8:1.73
	gdb-csl-sourcerygxx-4_1-7:1.73
	binutils-csl-sourcerygxx-4_1-7:1.73
	gdb-csl-arm-2006q1-6:1.73
	binutils-csl-arm-2006q1-6:1.73
	gdb-csl-sourcerygxx-4_1-6:1.73
	binutils-csl-sourcerygxx-4_1-6:1.73
	binutils-csl-wrs-linux-3_4_4-22:1.64
	gdb-csl-symbian-6_4_50_20060226-10:1.73
	gdb-csl-symbian-6_4_50_20060226-9:1.73
	gdb-csl-symbian-6_4_50_20060226-8:1.73
	gdb-csl-coldfire-4_1-11:1.73
	binutils-csl-coldfire-4_1-11:1.73
	gdb-csl-sourcerygxx-3_4_4-19:1.73
	binutils-csl-sourcerygxx-3_4_4-19:1.73
	gdb-csl-coldfire-4_1-10:1.73
	gdb_6_5-branch:1.77.0.4
	gdb_6_5-2006-05-14-branchpoint:1.77
	binutils-csl-coldfire-4_1-10:1.73
	gdb-csl-sourcerygxx-4_1-5:1.73
	binutils-csl-sourcerygxx-4_1-5:1.73
	nickrob-async-20060513-branch:1.77.0.2
	nickrob-async-20060513-branchpoint:1.77
	gdb-csl-sourcerygxx-4_1-4:1.73
	binutils-csl-sourcerygxx-4_1-4:1.73
	msnyder-reverse-20060502-branch:1.74.0.4
	msnyder-reverse-20060502-branchpoint:1.74
	binutils-csl-wrs-linux-3_4_4-21:1.64
	gdb-csl-morpho-4_1-4:1.73
	binutils-csl-morpho-4_1-4:1.73
	gdb-csl-sourcerygxx-3_4_4-17:1.73
	binutils-csl-sourcerygxx-3_4_4-17:1.73
	binutils-csl-wrs-linux-3_4_4-20:1.64
	readline_5_1-import-branch:1.74.0.2
	readline_5_1-import-branchpoint:1.74
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.73
	binutils-2_17-branch:1.73.0.12
	binutils-2_17-branchpoint:1.73
	gdb-csl-symbian-20060226-branch:1.73.0.10
	gdb-csl-symbian-20060226-branchpoint:1.73
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.73
	msnyder-reverse-20060331-branch:1.73.0.8
	msnyder-reverse-20060331-branchpoint:1.73
	binutils-csl-2_17-branch:1.73.0.6
	binutils-csl-2_17-branchpoint:1.73
	gdb-csl-available-20060303-branch:1.73.0.4
	gdb-csl-available-20060303-branchpoint:1.73
	gdb-csl-20060226-branch:1.73.0.2
	gdb-csl-20060226-branchpoint:1.73
	gdb_6_4-20051202-release:1.72
	msnyder-fork-checkpoint-branch:1.72.0.8
	msnyder-fork-checkpoint-branchpoint:1.72
	gdb-csl-gxxpro-6_3-branch:1.72.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.72
	gdb_6_4-branch:1.72.0.4
	gdb_6_4-2005-11-01-branchpoint:1.72
	gdb-csl-arm-20051020-branch:1.72.0.2
	gdb-csl-arm-20051020-branchpoint:1.72
	binutils-csl-gxxpro-3_4-branch:1.64.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.64.2.1
	binutils-2_16_1:1.64.2.1
	msnyder-tracepoint-checkpoint-branch:1.69.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.69
	gdb-csl-arm-20050325-2005-q1b:1.64
	binutils-csl-arm-2005q1b:1.64
	binutils-2_16:1.64
	gdb-csl-arm-20050325-2005-q1a:1.64
	binutils-csl-arm-2005q1a:1.64
	csl-arm-20050325-branch:1.64.0.6
	csl-arm-20050325-branchpoint:1.64
	binutils-csl-arm-2005q1-branch:1.64.0.4
	binutils-csl-arm-2005q1-branchpoint:1.64
	binutils-2_16-branch:1.64.0.2
	binutils-2_16-branchpoint:1.64
	csl-arm-2004-q3d:1.57
	gdb_6_3-20041109-release:1.57
	gdb_6_3-branch:1.57.0.2
	gdb_6_3-20041019-branchpoint:1.57
	csl-arm-2004-q3:1.57
	drow_intercu-merge-20040921:1.57
	drow_intercu-merge-20040915:1.57
	jimb-gdb_6_2-e500-branch:1.56.0.6
	jimb-gdb_6_2-e500-branchpoint:1.56
	gdb_6_2-20040730-release:1.56
	gdb_6_2-branch:1.56.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.56
	gdb_6_1_1-20040616-release:1.50
	binutils-2_15:1.50.6.1
	binutils-2_15-branchpoint:1.50
	csl-arm-2004-q1a:1.55
	csl-arm-2004-q1:1.54
	gdb_6_1-2004-04-05-release:1.50
	drow_intercu-merge-20040402:1.54
	drow_intercu-merge-20040327:1.52
	ezannoni_pie-20040323-branch:1.50.0.14
	ezannoni_pie-20040323-branchpoint:1.50
	cagney_tramp-20040321-mergepoint:1.50
	cagney_tramp-20040309-branch:1.50.0.12
	cagney_tramp-20040309-branchpoint:1.50
	gdb_6_1-branch:1.50.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.50
	drow_intercu-20040221-branch:1.50.0.8
	drow_intercu-20040221-branchpoint:1.50
	binutils-2_15-branch:1.50.0.6
	cagney_bfdfile-20040213-branch:1.50.0.4
	cagney_bfdfile-20040213-branchpoint:1.50
	drow-cplus-merge-20040208:1.50
	carlton_dictionary-20040126-merge:1.50
	cagney_bigcore-20040122-branch:1.50.0.2
	cagney_bigcore-20040122-branchpoint:1.50
	drow-cplus-merge-20040113:1.50
	csl-arm-2003-q4:1.50
	drow-cplus-merge-20031224:1.50
	drow-cplus-merge-20031220:1.50
	carlton_dictionary-20031215-merge:1.50
	drow-cplus-merge-20031214:1.50
	carlton-dictionary-20031111-merge:1.50
	gdb_6_0-2003-10-04-release:1.43
	kettenis_sparc-20030918-branch:1.49.0.6
	kettenis_sparc-20030918-branchpoint:1.49
	carlton_dictionary-20030917-merge:1.49
	ezannoni_pie-20030916-branchpoint:1.49
	ezannoni_pie-20030916-branch:1.49.0.4
	cagney_x86i386-20030821-branch:1.49.0.2
	cagney_x86i386-20030821-branchpoint:1.49
	carlton_dictionary-20030805-merge:1.47
	carlton_dictionary-20030627-merge:1.44
	gdb_6_0-branch:1.43.0.6
	gdb_6_0-2003-06-23-branchpoint:1.43
	jimb-ppc64-linux-20030613-branch:1.43.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.43
	binutils-2_14:1.40.22.1
	cagney_convert-20030606-branch:1.43.0.2
	cagney_convert-20030606-branchpoint:1.43
	cagney_writestrings-20030508-branch:1.41.0.4
	cagney_writestrings-20030508-branchpoint:1.41
	jimb-ppc64-linux-20030528-branch:1.42.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.42
	carlton_dictionary-20030523-merge:1.42
	cagney_fileio-20030521-branch:1.42.0.2
	cagney_fileio-20030521-branchpoint:1.42
	kettenis_i386newframe-20030517-mergepoint:1.41
	jimb-ppc64-linux-20030509-branch:1.41.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.41
	kettenis_i386newframe-20030504-mergepoint:1.40
	carlton_dictionary-20030430-merge:1.40
	binutils-2_14-branch:1.40.0.22
	binutils-2_14-branchpoint:1.40
	kettenis_i386newframe-20030419-branch:1.40.0.20
	kettenis_i386newframe-20030419-branchpoint:1.40
	carlton_dictionary-20030416-merge:1.40
	cagney_frameaddr-20030409-mergepoint:1.40
	kettenis_i386newframe-20030406-branch:1.40.0.18
	kettenis_i386newframe-20030406-branchpoint:1.40
	cagney_frameaddr-20030403-branchpoint:1.40
	cagney_frameaddr-20030403-branch:1.40.0.16
	cagney_framebase-20030330-mergepoint:1.40
	cagney_framebase-20030326-branch:1.40.0.14
	cagney_framebase-20030326-branchpoint:1.40
	cagney_lazyid-20030317-branch:1.40.0.12
	cagney_lazyid-20030317-branchpoint:1.40
	kettenis-i386newframe-20030316-mergepoint:1.40
	offbyone-20030313-branch:1.40.0.10
	offbyone-20030313-branchpoint:1.40
	kettenis-i386newframe-20030308-branch:1.40.0.8
	kettenis-i386newframe-20030308-branchpoint:1.40
	carlton_dictionary-20030305-merge:1.40
	cagney_offbyone-20030303-branch:1.40.0.6
	cagney_offbyone-20030303-branchpoint:1.40
	carlton_dictionary-20030207-merge:1.40
	interps-20030202-branch:1.40.0.4
	interps-20030202-branchpoint:1.40
	cagney-unwind-20030108-branch:1.40.0.2
	cagney-unwind-20030108-branchpoint:1.40
	binutils-2_13_2_1:1.33.2.1
	binutils-2_13_2:1.33.2.1
	carlton_dictionary-20021223-merge:1.40
	gdb_5_3-2002-12-12-release:1.33
	carlton_dictionary-20021115-merge:1.38
	binutils-2_13_1:1.33.2.1
	kseitz_interps-20021105-merge:1.36
	kseitz_interps-20021103-merge:1.36
	drow-cplus-merge-20021020:1.36
	drow-cplus-merge-20021025:1.36
	carlton_dictionary-20021025-merge:1.36
	carlton_dictionary-20021011-merge:1.36
	drow-cplus-branch:1.36.0.2
	drow-cplus-branchpoint:1.36
	kseitz_interps-20020930-merge:1.36
	carlton_dictionary-20020927-merge:1.36
	carlton_dictionary-branch:1.35.0.2
	carlton_dictionary-20020920-branchpoint:1.35
	sid-20020905-branchpoint:1.33
	sid-20020905-branch:1.33.0.10
	gdb_5_3-branch:1.33.0.8
	gdb_5_3-2002-09-04-branchpoint:1.33
	kseitz_interps-20020829-merge:1.33
	cagney_sysregs-20020825-branch:1.33.0.6
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.4
	readline_4_3-import-branchpoint:1.33
	binutils-2_13:1.33
	gdb_5_2_1-2002-07-23-release:1.28
	binutils-2_13-branchpoint:1.33
	binutils-2_13-branch:1.33.0.2
	kseitz_interps-20020528-branch:1.28.0.10
	kseitz_interps-20020528-branchpoint:1.28
	cagney_regbuf-20020515-branch:1.28.0.8
	cagney_regbuf-20020515-branchpoint:1.28
	binutils-2_12_1:1.28
	jimb-macro-020506-branch:1.28.0.6
	jimb-macro-020506-branchpoint:1.28
	gdb_5_2-2002-04-29-release:1.28
	binutils-2_12:1.28
	gdb_5_2-branch:1.28.0.4
	gdb_5_2-2002-03-03-branchpoint:1.28
	binutils-2_12-branch:1.28.0.2
	binutils-2_12-branchpoint:1.28
	gdb_5_1_1-2002-01-24-release:1.19
	gdb_5_1_0_1-2002-01-03-release:1.19
	cygnus_cvs_20020108_pre:1.28
	gdb_5_1_0_1-2002-01-03-branch:1.19.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.19
	gdb_5_1-2001-11-21-release:1.19
	gdb_s390-2001-09-26-branch:1.19.0.4
	gdb_s390-2001-09-26-branchpoint:1.19
	gdb_5_1-2001-07-29-branch:1.19.0.2
	gdb_5_1-2001-07-29-branchpoint:1.19
	binutils-2_11_2:1.16.2.2
	binutils-2_11_1:1.16.2.2
	binutils-2_11:1.16
	x86_64versiong3:1.16
	binutils-2_11-branch:1.16.0.2
	insight-precleanup-2001-01-01:1.14
	binutils-2_10_1:1.9
	binutils-2_10:1.9
	gdb-premipsmulti-2000-06-06-branch:1.10.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.10
	gdb_5_0-2000-05-19-release:1.9
	gdb_4_18_2-2000-05-18-release:1.9
	gdb_4_95_1-2000-05-11-snapshot:1.9
	gdb_4_95_0-2000-04-27-snapshot:1.9
	gdb_5_0-2000-04-10-branch:1.9.0.4
	gdb_5_0-2000-04-10-branchpoint:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.118
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.118
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2013.02.11.05.30.52;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2013.01.26.02.08.01;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2012.07.04.00.29.52;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2012.06.04.14.35.21;	author jkratoch;	state Exp;
branches;
next	1.113;

1.113
date	2012.06.01.16.37.56;	author jkratoch;	state Exp;
branches;
next	1.112;

1.112
date	2012.05.05.03.05.25;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2011.12.14.16.12.13;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2011.12.14.11.50.13;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2011.06.04.18.16.17;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2011.06.04.04.07.54;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2011.04.20.00.22.08;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2011.03.14.15.54.58;	author rsandifo;	state Exp;
branches;
next	1.104;

1.104
date	2010.12.31.02.43.21;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.18.12.24.07;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.99;

1.99
date	2010.01.19.13.50.55;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2009.09.28.09.45.33;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2009.09.09.15.03.53;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2009.07.23.13.00.20;	author nickc;	state Exp;
branches
	1.95.4.1;
next	1.94;

1.94
date	2009.04.30.15.47.10;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.01.12.21.28;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2007.12.24.16.55.39;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.16.14.42.14;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2007.08.14.08.04.47;	author jkratoch;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.04.16.31.00;	author hjl;	state Exp;
branches;
next	1.84;

1.84
date	2007.07.09.21.23.37;	author roland;	state Exp;
branches;
next	1.83;

1.83
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.05.19.50.12;	author brolley;	state Exp;
branches;
next	1.79;

1.79
date	2006.09.22.13.16.45;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.24.07.36.09;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.11.08.57.08;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.02.10.01.56;	author bje;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2006.04.18.09.41.36;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.23.11.46.01;	author amodra;	state Exp;
branches
	1.73.6.1
	1.73.12.1;
next	1.72;

1.72
date	2005.09.28.14.53.24;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.10.20.22.23;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.31.19.32.29;	author wilson;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.26.07.41.13;	author jakub;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.09.03.35.38;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.04.15.53.28;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.27.20.16.08;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2005.02.06.23.21.44;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.28.17.58.24;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.11.04.32.35;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.09.16.17.42;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.25.02.14.10;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.15.23.21.24;	author pbrook;	state Exp;
branches;
next	1.57;

1.57
date	2004.07.27.14.20.47;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.27.10.08.59;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.26.05.55.15;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.25.12.48.41;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.16.04.11.06;	author cagney;	state Exp;
branches
	1.50.6.1
	1.50.8.1;
next	1.49;

1.49
date	2003.08.07.08.38.09;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.07.07.25.34;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.04.09.39.46;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.08.08.08.00;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.04.01.50.11;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.06.02.12.04;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.21.00.56.05;	author roland;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.09.02.27.00;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches
	1.40.20.1
	1.40.22.1;
next	1.39;

1.39
date	2002.11.28.11.55.43;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.12.22.49.45;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.12.15.44.24;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.21.09.59.19;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2002.09.18.13.25.35;	author drow;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.09.18.02.39.43;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.18.14.09.06;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.06.00.29.20;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.05.13.31.57;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.19.23.54.26;	author amodra;	state Exp;
branches
	1.28.8.1
	1.28.10.1;
next	1.27;

1.27
date	2001.12.18.07.12.19;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.17.00.52.34;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.11.05.38.18;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.01.34.10;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.19.16.29.12;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.09.06.05.17;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.22.03.16.01;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.03.06.18.09;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.03.22.53.38;	author kazu;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.12.29.05.44.51;	author hp;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.27.07.52.24;	author hp;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.11.06.08.19;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.04.02.18.06;	author wilson;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.24.07.55.09;	author law;	state Exp;
branches;
next	1.9;

1.9
date	99.11.18.01.06.45;	author rth;	state Exp;
branches;
next	1.8;

1.8
date	99.09.13.06.45.13;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	99.09.11.20.14.57;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.07.13.18.21.27;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.07.07.17.50.55;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	99.06.12.17.56.25;	author mmitchel;	state Exp;
branches;
next	1.3;

1.3
date	99.06.02.18.16.48;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.13.01.00;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.103.2.1
date	2011.04.27.07.17.38;	author amodra;	state Exp;
branches;
next	;

1.95.4.1
date	2009.09.09.15.05.50;	author nickc;	state Exp;
branches;
next	1.95.4.2;

1.95.4.2
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.73.6.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.73.12.1
date	2006.05.11.09.03.10;	author nickc;	state Exp;
branches;
next	;

1.64.2.1
date	2005.05.30.13.13.17;	author drow;	state Exp;
branches;
next	;

1.50.6.1
date	2004.04.08.12.41.45;	author amodra;	state Exp;
branches;
next	;

1.50.8.1
date	2004.03.27.17.37.36;	author drow;	state Exp;
branches;
next	1.50.8.2;

1.50.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.50.8.3;

1.50.8.3
date	2004.09.16.17.00.32;	author drow;	state Exp;
branches;
next	;

1.40.20.1
date	2003.05.18.09.43.47;	author kettenis;	state Exp;
branches;
next	;

1.40.22.1
date	2003.06.06.02.16.19;	author drow;	state Exp;
branches;
next	1.40.22.2;

1.40.22.2
date	2003.07.08.15.04.59;	author amodra;	state Exp;
branches;
next	;

1.36.2.1
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.35.2.1
date	2002.09.27.20.02.55;	author carlton;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.11.15.19.18.28;	author carlton;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2002.12.23.19.37.49;	author carlton;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2003.05.23.18.40.28;	author carlton;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2003.06.27.21.49.24;	author carlton;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2003.08.05.17.12.53;	author carlton;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2003.11.11.23.50.24;	author carlton;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	;

1.28.8.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	1.28.8.2;

1.28.8.2
date	2002.06.21.15.56.25;	author cagney;	state Exp;
branches;
next	;

1.28.10.1
date	2002.06.20.01.30.45;	author kseitz;	state Exp;
branches;
next	1.28.10.2;

1.28.10.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.28.10.3;

1.28.10.3
date	2002.10.01.00.45.48;	author kseitz;	state Exp;
branches;
next	;

1.16.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.06.11.10.04.15;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.118
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@/* ELF executable support for BFD.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   Written by Fred Fish @@ Cygnus Support, from information published
   in "UNIX System V Release 4, Programmers Guide: ANSI C and
   Programming Support Tools".  Sufficient support for gdb.

   Rewritten by Mark Eichin @@ Cygnus Support, from information
   published in "System V Application Binary Interface", chapters 4
   and 5, as well as the various "Processor Supplement" documents
   derived from it. Added support for assembler and other object file
   utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael
   Meissner (Open Software Foundation), and Peter Hoogenboom (University
   of Utah) to finish and extend this.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Problems and other issues to resolve.

   (1)	BFD expects there to be some fixed number of "sections" in
	the object file.  I.E. there is a "section_count" variable in the
	bfd structure which contains the number of sections.  However, ELF
	supports multiple "views" of a file.  In particular, with current
	implementations, executable files typically have two tables, a
	program header table and a section header table, both of which
	partition the executable.

	In ELF-speak, the "linking view" of the file uses the section header
	table to access "sections" within the file, and the "execution view"
	uses the program header table to access "segments" within the file.
	"Segments" typically may contain all the data from one or more
	"sections".

	Note that the section header table is optional in ELF executables,
	but it is this information that is most useful to gdb.  If the
	section header table is missing, then gdb should probably try
	to make do with the program header table.  (FIXME)

   (2)  The code in this file is compiled twice, once in 32-bit mode and
	once in 64-bit mode.  More of it should be made size-independent
	and moved into elf.c.

   (3)	ELF section symbols are handled rather sloppily now.  This should
	be cleaned up, and ELF section symbols reconciled with BFD section
	symbols.

   (4)  We need a published spec for 64-bit ELF.  We've got some stuff here
	that we're using for SPARC V9 64-bit chips, but don't assume that
	it's cast in stone.
 */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"

/* Renaming structures, typedefs, macros and functions to be size-specific.  */
#define Elf_External_Ehdr	NAME(Elf,External_Ehdr)
#define Elf_External_Sym	NAME(Elf,External_Sym)
#define Elf_External_Shdr	NAME(Elf,External_Shdr)
#define Elf_External_Phdr	NAME(Elf,External_Phdr)
#define Elf_External_Rel	NAME(Elf,External_Rel)
#define Elf_External_Rela	NAME(Elf,External_Rela)
#define Elf_External_Dyn	NAME(Elf,External_Dyn)

#define elf_core_file_failing_command	NAME(bfd_elf,core_file_failing_command)
#define elf_core_file_failing_signal	NAME(bfd_elf,core_file_failing_signal)
#define elf_core_file_matches_executable_p \
  NAME(bfd_elf,core_file_matches_executable_p)
#define elf_core_file_pid		NAME(bfd_elf,core_file_pid)
#define elf_object_p			NAME(bfd_elf,object_p)
#define elf_core_file_p			NAME(bfd_elf,core_file_p)
#define elf_get_symtab_upper_bound	NAME(bfd_elf,get_symtab_upper_bound)
#define elf_get_dynamic_symtab_upper_bound \
  NAME(bfd_elf,get_dynamic_symtab_upper_bound)
#define elf_swap_reloc_in		NAME(bfd_elf,swap_reloc_in)
#define elf_swap_reloca_in		NAME(bfd_elf,swap_reloca_in)
#define elf_swap_reloc_out		NAME(bfd_elf,swap_reloc_out)
#define elf_swap_reloca_out		NAME(bfd_elf,swap_reloca_out)
#define elf_swap_symbol_in		NAME(bfd_elf,swap_symbol_in)
#define elf_swap_symbol_out		NAME(bfd_elf,swap_symbol_out)
#define elf_swap_phdr_in		NAME(bfd_elf,swap_phdr_in)
#define elf_swap_phdr_out		NAME(bfd_elf,swap_phdr_out)
#define elf_swap_dyn_in			NAME(bfd_elf,swap_dyn_in)
#define elf_swap_dyn_out		NAME(bfd_elf,swap_dyn_out)
#define elf_get_reloc_upper_bound	NAME(bfd_elf,get_reloc_upper_bound)
#define elf_canonicalize_reloc		NAME(bfd_elf,canonicalize_reloc)
#define elf_slurp_symbol_table		NAME(bfd_elf,slurp_symbol_table)
#define elf_canonicalize_symtab		NAME(bfd_elf,canonicalize_symtab)
#define elf_canonicalize_dynamic_symtab \
  NAME(bfd_elf,canonicalize_dynamic_symtab)
#define elf_get_synthetic_symtab \
  NAME(bfd_elf,get_synthetic_symtab)
#define elf_make_empty_symbol		NAME(bfd_elf,make_empty_symbol)
#define elf_get_symbol_info		NAME(bfd_elf,get_symbol_info)
#define elf_get_lineno			NAME(bfd_elf,get_lineno)
#define elf_set_arch_mach		NAME(bfd_elf,set_arch_mach)
#define elf_find_nearest_line		NAME(bfd_elf,find_nearest_line)
#define elf_sizeof_headers		NAME(bfd_elf,sizeof_headers)
#define elf_set_section_contents	NAME(bfd_elf,set_section_contents)
#define elf_no_info_to_howto		NAME(bfd_elf,no_info_to_howto)
#define elf_no_info_to_howto_rel	NAME(bfd_elf,no_info_to_howto_rel)
#define elf_find_section		NAME(bfd_elf,find_section)
#define elf_write_shdrs_and_ehdr	NAME(bfd_elf,write_shdrs_and_ehdr)
#define elf_write_out_phdrs		NAME(bfd_elf,write_out_phdrs)
#define elf_checksum_contents		NAME(bfd_elf,checksum_contents)
#define elf_write_relocs		NAME(bfd_elf,write_relocs)
#define elf_slurp_reloc_table		NAME(bfd_elf,slurp_reloc_table)

#if ARCH_SIZE == 64
#define ELF_R_INFO(X,Y)	ELF64_R_INFO(X,Y)
#define ELF_R_SYM(X)	ELF64_R_SYM(X)
#define ELF_R_TYPE(X)	ELF64_R_TYPE(X)
#define ELFCLASS	ELFCLASS64
#define FILE_ALIGN	8
#define LOG_FILE_ALIGN	3
#endif
#if ARCH_SIZE == 32
#define ELF_R_INFO(X,Y)	ELF32_R_INFO(X,Y)
#define ELF_R_SYM(X)	ELF32_R_SYM(X)
#define ELF_R_TYPE(X)	ELF32_R_TYPE(X)
#define ELFCLASS	ELFCLASS32
#define FILE_ALIGN	4
#define LOG_FILE_ALIGN	2
#endif

#if DEBUG & 2
static void elf_debug_section (int, Elf_Internal_Shdr *);
#endif
#if DEBUG & 1
static void elf_debug_file (Elf_Internal_Ehdr *);
#endif

/* Structure swapping routines */

/* Should perhaps use put_offset, put_word, etc.  For now, the two versions
   can be handled by explicitly specifying 32 bits or "the long type".  */
#if ARCH_SIZE == 64
#define H_PUT_WORD		H_PUT_64
#define H_PUT_SIGNED_WORD	H_PUT_S64
#define H_GET_WORD		H_GET_64
#define H_GET_SIGNED_WORD	H_GET_S64
#endif
#if ARCH_SIZE == 32
#define H_PUT_WORD		H_PUT_32
#define H_PUT_SIGNED_WORD	H_PUT_S32
#define H_GET_WORD		H_GET_32
#define H_GET_SIGNED_WORD	H_GET_S32
#endif

/* Translate an ELF symbol in external format into an ELF symbol in internal
   format.  */

bfd_boolean
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
{
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->st_name = H_GET_32 (abfd, src->st_name);
  if (signed_vma)
    dst->st_value = H_GET_SIGNED_WORD (abfd, src->st_value);
  else
    dst->st_value = H_GET_WORD (abfd, src->st_value);
  dst->st_size = H_GET_WORD (abfd, src->st_size);
  dst->st_info = H_GET_8 (abfd, src->st_info);
  dst->st_other = H_GET_8 (abfd, src->st_other);
  dst->st_shndx = H_GET_16 (abfd, src->st_shndx);
  if (dst->st_shndx == (SHN_XINDEX & 0xffff))
    {
      if (shndx == NULL)
	return FALSE;
      dst->st_shndx = H_GET_32 (abfd, shndx->est_shndx);
    }
  else if (dst->st_shndx >= (SHN_LORESERVE & 0xffff))
    dst->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
  dst->st_target_internal = 0;
  return TRUE;
}

/* Translate an ELF symbol in internal format into an ELF symbol in external
   format.  */

void
elf_swap_symbol_out (bfd *abfd,
		     const Elf_Internal_Sym *src,
		     void *cdst,
		     void *shndx)
{
  unsigned int tmp;
  Elf_External_Sym *dst = (Elf_External_Sym *) cdst;
  H_PUT_32 (abfd, src->st_name, dst->st_name);
  H_PUT_WORD (abfd, src->st_value, dst->st_value);
  H_PUT_WORD (abfd, src->st_size, dst->st_size);
  H_PUT_8 (abfd, src->st_info, dst->st_info);
  H_PUT_8 (abfd, src->st_other, dst->st_other);
  tmp = src->st_shndx;
  if (tmp >= (SHN_LORESERVE & 0xffff) && tmp < SHN_LORESERVE)
    {
      if (shndx == NULL)
	abort ();
      H_PUT_32 (abfd, tmp, shndx);
      tmp = SHN_XINDEX & 0xffff;
    }
  H_PUT_16 (abfd, tmp, dst->st_shndx);
}

/* Translate an ELF file header in external format into an ELF file header in
   internal format.  */

static void
elf_swap_ehdr_in (bfd *abfd,
		  const Elf_External_Ehdr *src,
		  Elf_Internal_Ehdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
  memcpy (dst->e_ident, src->e_ident, EI_NIDENT);
  dst->e_type = H_GET_16 (abfd, src->e_type);
  dst->e_machine = H_GET_16 (abfd, src->e_machine);
  dst->e_version = H_GET_32 (abfd, src->e_version);
  if (signed_vma)
    dst->e_entry = H_GET_SIGNED_WORD (abfd, src->e_entry);
  else
    dst->e_entry = H_GET_WORD (abfd, src->e_entry);
  dst->e_phoff = H_GET_WORD (abfd, src->e_phoff);
  dst->e_shoff = H_GET_WORD (abfd, src->e_shoff);
  dst->e_flags = H_GET_32 (abfd, src->e_flags);
  dst->e_ehsize = H_GET_16 (abfd, src->e_ehsize);
  dst->e_phentsize = H_GET_16 (abfd, src->e_phentsize);
  dst->e_phnum = H_GET_16 (abfd, src->e_phnum);
  dst->e_shentsize = H_GET_16 (abfd, src->e_shentsize);
  dst->e_shnum = H_GET_16 (abfd, src->e_shnum);
  dst->e_shstrndx = H_GET_16 (abfd, src->e_shstrndx);
}

/* Translate an ELF file header in internal format into an ELF file header in
   external format.  */

static void
elf_swap_ehdr_out (bfd *abfd,
		   const Elf_Internal_Ehdr *src,
		   Elf_External_Ehdr *dst)
{
  unsigned int tmp;
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
  memcpy (dst->e_ident, src->e_ident, EI_NIDENT);
  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_16 (abfd, src->e_type, dst->e_type);
  H_PUT_16 (abfd, src->e_machine, dst->e_machine);
  H_PUT_32 (abfd, src->e_version, dst->e_version);
  if (signed_vma)
    H_PUT_SIGNED_WORD (abfd, src->e_entry, dst->e_entry);
  else
    H_PUT_WORD (abfd, src->e_entry, dst->e_entry);
  H_PUT_WORD (abfd, src->e_phoff, dst->e_phoff);
  H_PUT_WORD (abfd, src->e_shoff, dst->e_shoff);
  H_PUT_32 (abfd, src->e_flags, dst->e_flags);
  H_PUT_16 (abfd, src->e_ehsize, dst->e_ehsize);
  H_PUT_16 (abfd, src->e_phentsize, dst->e_phentsize);
  tmp = src->e_phnum;
  if (tmp > PN_XNUM)
    tmp = PN_XNUM;
  H_PUT_16 (abfd, tmp, dst->e_phnum);
  H_PUT_16 (abfd, src->e_shentsize, dst->e_shentsize);
  tmp = src->e_shnum;
  if (tmp >= (SHN_LORESERVE & 0xffff))
    tmp = SHN_UNDEF;
  H_PUT_16 (abfd, tmp, dst->e_shnum);
  tmp = src->e_shstrndx;
  if (tmp >= (SHN_LORESERVE & 0xffff))
    tmp = SHN_XINDEX & 0xffff;
  H_PUT_16 (abfd, tmp, dst->e_shstrndx);
}

/* Translate an ELF section header table entry in external format into an
   ELF section header table entry in internal format.  */

static void
elf_swap_shdr_in (bfd *abfd,
		  const Elf_External_Shdr *src,
		  Elf_Internal_Shdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->sh_name = H_GET_32 (abfd, src->sh_name);
  dst->sh_type = H_GET_32 (abfd, src->sh_type);
  dst->sh_flags = H_GET_WORD (abfd, src->sh_flags);
  if (signed_vma)
    dst->sh_addr = H_GET_SIGNED_WORD (abfd, src->sh_addr);
  else
    dst->sh_addr = H_GET_WORD (abfd, src->sh_addr);
  dst->sh_offset = H_GET_WORD (abfd, src->sh_offset);
  dst->sh_size = H_GET_WORD (abfd, src->sh_size);
  dst->sh_link = H_GET_32 (abfd, src->sh_link);
  dst->sh_info = H_GET_32 (abfd, src->sh_info);
  dst->sh_addralign = H_GET_WORD (abfd, src->sh_addralign);
  dst->sh_entsize = H_GET_WORD (abfd, src->sh_entsize);
  dst->bfd_section = NULL;
  dst->contents = NULL;
}

/* Translate an ELF section header table entry in internal format into an
   ELF section header table entry in external format.  */

static void
elf_swap_shdr_out (bfd *abfd,
		   const Elf_Internal_Shdr *src,
		   Elf_External_Shdr *dst)
{
  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_32 (abfd, src->sh_name, dst->sh_name);
  H_PUT_32 (abfd, src->sh_type, dst->sh_type);
  H_PUT_WORD (abfd, src->sh_flags, dst->sh_flags);
  H_PUT_WORD (abfd, src->sh_addr, dst->sh_addr);
  H_PUT_WORD (abfd, src->sh_offset, dst->sh_offset);
  H_PUT_WORD (abfd, src->sh_size, dst->sh_size);
  H_PUT_32 (abfd, src->sh_link, dst->sh_link);
  H_PUT_32 (abfd, src->sh_info, dst->sh_info);
  H_PUT_WORD (abfd, src->sh_addralign, dst->sh_addralign);
  H_PUT_WORD (abfd, src->sh_entsize, dst->sh_entsize);
}

/* Translate an ELF program header table entry in external format into an
   ELF program header table entry in internal format.  */

void
elf_swap_phdr_in (bfd *abfd,
		  const Elf_External_Phdr *src,
		  Elf_Internal_Phdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->p_type = H_GET_32 (abfd, src->p_type);
  dst->p_flags = H_GET_32 (abfd, src->p_flags);
  dst->p_offset = H_GET_WORD (abfd, src->p_offset);
  if (signed_vma)
    {
      dst->p_vaddr = H_GET_SIGNED_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_SIGNED_WORD (abfd, src->p_paddr);
    }
  else
    {
      dst->p_vaddr = H_GET_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_WORD (abfd, src->p_paddr);
    }
  dst->p_filesz = H_GET_WORD (abfd, src->p_filesz);
  dst->p_memsz = H_GET_WORD (abfd, src->p_memsz);
  dst->p_align = H_GET_WORD (abfd, src->p_align);
}

void
elf_swap_phdr_out (bfd *abfd,
		   const Elf_Internal_Phdr *src,
		   Elf_External_Phdr *dst)
{
  const struct elf_backend_data *bed;
  bfd_vma p_paddr;

  bed = get_elf_backend_data (abfd);
  p_paddr = bed->want_p_paddr_set_to_zero ? 0 : src->p_paddr;

  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_32 (abfd, src->p_type, dst->p_type);
  H_PUT_WORD (abfd, src->p_offset, dst->p_offset);
  H_PUT_WORD (abfd, src->p_vaddr, dst->p_vaddr);
  H_PUT_WORD (abfd, p_paddr, dst->p_paddr);
  H_PUT_WORD (abfd, src->p_filesz, dst->p_filesz);
  H_PUT_WORD (abfd, src->p_memsz, dst->p_memsz);
  H_PUT_32 (abfd, src->p_flags, dst->p_flags);
  H_PUT_WORD (abfd, src->p_align, dst->p_align);
}

/* Translate an ELF reloc from external format to internal format.  */
void
elf_swap_reloc_in (bfd *abfd,
		   const bfd_byte *s,
		   Elf_Internal_Rela *dst)
{
  const Elf_External_Rel *src = (const Elf_External_Rel *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = 0;
}

void
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
{
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = H_GET_SIGNED_WORD (abfd, src->r_addend);
}

/* Translate an ELF reloc from internal format to external format.  */
void
elf_swap_reloc_out (bfd *abfd,
		    const Elf_Internal_Rela *src,
		    bfd_byte *d)
{
  Elf_External_Rel *dst = (Elf_External_Rel *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
}

void
elf_swap_reloca_out (bfd *abfd,
		     const Elf_Internal_Rela *src,
		     bfd_byte *d)
{
  Elf_External_Rela *dst = (Elf_External_Rela *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
  H_PUT_SIGNED_WORD (abfd, src->r_addend, dst->r_addend);
}

void
elf_swap_dyn_in (bfd *abfd,
		 const void *p,
		 Elf_Internal_Dyn *dst)
{
  const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;

  dst->d_tag = H_GET_WORD (abfd, src->d_tag);
  dst->d_un.d_val = H_GET_WORD (abfd, src->d_un.d_val);
}

void
elf_swap_dyn_out (bfd *abfd,
		  const Elf_Internal_Dyn *src,
		  void *p)
{
  Elf_External_Dyn *dst = (Elf_External_Dyn *) p;

  H_PUT_WORD (abfd, src->d_tag, dst->d_tag);
  H_PUT_WORD (abfd, src->d_un.d_val, dst->d_un.d_val);
}

/* ELF .o/exec file reading */

/* Begin processing a given object.

   First we validate the file by reading in the ELF header and checking
   the magic number.  */

static inline bfd_boolean
elf_file_p (Elf_External_Ehdr *x_ehdrp)
{
  return ((x_ehdrp->e_ident[EI_MAG0] == ELFMAG0)
	  && (x_ehdrp->e_ident[EI_MAG1] == ELFMAG1)
	  && (x_ehdrp->e_ident[EI_MAG2] == ELFMAG2)
	  && (x_ehdrp->e_ident[EI_MAG3] == ELFMAG3));
}

/* Check to see if the file associated with ABFD matches the target vector
   that ABFD points to.

   Note that we may be called several times with the same ABFD, but different
   target vectors, most of which will not match.  We have to avoid leaving
   any side effects in ABFD, or any data it points to (like tdata), if the
   file does not match the target vector.  */

const bfd_target *
elf_object_p (bfd *abfd)
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_External_Shdr x_shdr;	/* Section header table entry, external form */
  Elf_Internal_Shdr i_shdr;
  Elf_Internal_Shdr *i_shdrp;	/* Section header table, internal form */
  unsigned int shindex;
  const struct elf_backend_data *ebd;
  asection *s;
  bfd_size_type amt;
  const bfd_target *target;

  /* Read in the ELF header in external format.  */

  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry, and it must have a
     section header table (FIXME: See comments re sections at top of this
     file).  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    goto got_wrong_format_error;

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (abfd))
	goto got_wrong_format_error;
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (abfd))
	goto got_wrong_format_error;
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      goto got_wrong_format_error;
    }

  target = abfd->xvec;

  /* Allocate an instance of the elf_obj_tdata structure and hook it up to
     the tdata pointer in the bfd.  */

  if (! (*target->_bfd_set_format[bfd_object]) (abfd))
    goto got_no_match;

  /* Now that we know the byte order, swap in the rest of the header */
  i_ehdrp = elf_elfheader (abfd);
  elf_swap_ehdr_in (abfd, &x_ehdr, i_ehdrp);
#if DEBUG & 1
  elf_debug_file (i_ehdrp);
#endif

  /* Reject ET_CORE (header indicates core file, not object file) */
  if (i_ehdrp->e_type == ET_CORE)
    goto got_wrong_format_error;

  /* If this is a relocatable file and there is no section header
     table, then we're hosed.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_type == ET_REL)
    goto got_wrong_format_error;

  /* As a simple sanity check, verify that what BFD thinks is the
     size of each section header table entry actually matches the size
     recorded in the file, but only if there are any sections.  */
  if (i_ehdrp->e_shentsize != sizeof (x_shdr) && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

  /* Further sanity check.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

  ebd = get_elf_backend_data (abfd);
  if (ebd->s->arch_size != ARCH_SIZE)
    goto got_wrong_format_error;

  /* Check that the ELF e_machine field matches what this particular
     BFD format expects.  */
  if (ebd->elf_machine_code != i_ehdrp->e_machine
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2)
      && ebd->elf_machine_code != EM_NONE)
    goto got_wrong_format_error;

  if (i_ehdrp->e_type == ET_EXEC)
    abfd->flags |= EXEC_P;
  else if (i_ehdrp->e_type == ET_DYN)
    abfd->flags |= DYNAMIC;

  if (i_ehdrp->e_phnum > 0)
    abfd->flags |= D_PAGED;

  if (! bfd_default_set_arch_mach (abfd, ebd->arch, 0))
    {
      /* It's OK if this fails for the generic target.  */
      if (ebd->elf_machine_code != EM_NONE)
	goto got_no_match;
    }

  if (ebd->elf_machine_code != EM_NONE
      && i_ehdrp->e_ident[EI_OSABI] != ebd->elf_osabi
      && ebd->elf_osabi != ELFOSABI_NONE)
    goto got_wrong_format_error;

  if (i_ehdrp->e_shoff != 0)
    {
      bfd_signed_vma where = i_ehdrp->e_shoff;

      if (where != (file_ptr) where)
	goto got_wrong_format_error;

      /* Seek to the section header table in the file.  */
      if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
	goto got_no_match;

      /* Read the first section header at index 0, and convert to internal
	 form.  */
      if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);

      /* If the section count is zero, the actual count is in the first
	 section header.  */
      if (i_ehdrp->e_shnum == SHN_UNDEF)
	{
	  i_ehdrp->e_shnum = i_shdr.sh_size;
	  if (i_ehdrp->e_shnum >= SHN_LORESERVE
	      || i_ehdrp->e_shnum != i_shdr.sh_size
	      || i_ehdrp->e_shnum  == 0)
	    goto got_wrong_format_error;
	}

      /* And similarly for the string table index.  */
      if (i_ehdrp->e_shstrndx == (SHN_XINDEX & 0xffff))
	{
	  i_ehdrp->e_shstrndx = i_shdr.sh_link;
	  if (i_ehdrp->e_shstrndx != i_shdr.sh_link)
	    goto got_wrong_format_error;
	}

      /* And program headers.  */
      if (i_ehdrp->e_phnum == PN_XNUM && i_shdr.sh_info != 0)
	{
	  i_ehdrp->e_phnum = i_shdr.sh_info;
	  if (i_ehdrp->e_phnum != i_shdr.sh_info)
	    goto got_wrong_format_error;
	}

      /* Sanity check that we can read all of the section headers.
	 It ought to be good enough to just read the last one.  */
      if (i_ehdrp->e_shnum != 1)
	{
	  /* Check that we don't have a totally silly number of sections.  */
	  if (i_ehdrp->e_shnum > (unsigned int) -1 / sizeof (x_shdr)
	      || i_ehdrp->e_shnum > (unsigned int) -1 / sizeof (i_shdr))
	    goto got_wrong_format_error;

	  where += (i_ehdrp->e_shnum - 1) * sizeof (x_shdr);
	  if (where != (file_ptr) where)
	    goto got_wrong_format_error;
	  if ((bfd_size_type) where <= i_ehdrp->e_shoff)
	    goto got_wrong_format_error;

	  if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
	    goto got_no_match;
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	    goto got_no_match;

	  /* Back to where we were.  */
	  where = i_ehdrp->e_shoff + sizeof (x_shdr);
	  if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
	    goto got_no_match;
	}
    }

  /* Allocate space for a copy of the section header table in
     internal form.  */
  if (i_ehdrp->e_shnum != 0)
    {
      Elf_Internal_Shdr *shdrp;
      unsigned int num_sec;

      amt = sizeof (*i_shdrp) * i_ehdrp->e_shnum;
      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
      if (!i_shdrp)
	goto got_no_match;
      num_sec = i_ehdrp->e_shnum;
      elf_numsections (abfd) = num_sec;
      amt = sizeof (i_shdrp) * num_sec;
      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
      if (!elf_elfsections (abfd))
	goto got_no_match;

      memcpy (i_shdrp, &i_shdr, sizeof (*i_shdrp));
      for (shdrp = i_shdrp, shindex = 0; shindex < num_sec; shindex++)
	elf_elfsections (abfd)[shindex] = shdrp++;

      /* Read in the rest of the section header table and convert it
	 to internal form.  */
      for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
	{
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	    goto got_no_match;
	  elf_swap_shdr_in (abfd, &x_shdr, i_shdrp + shindex);

	  /* Sanity check sh_link and sh_info.  */
	  if (i_shdrp[shindex].sh_link >= num_sec)
	    {
	      /* PR 10478: Accept Solaris binaries with a sh_link
		 field set to SHN_BEFORE or SHN_AFTER.  */
	      switch (ebd->elf_machine_code)
		{
		case EM_386:
		case EM_486:
		case EM_X86_64:
		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (i_shdrp[shindex].sh_link == (SHN_LORESERVE & 0xffff) /* SHN_BEFORE */
		      || i_shdrp[shindex].sh_link == ((SHN_LORESERVE + 1) & 0xffff) /* SHN_AFTER */)
		    break;
		  /* Otherwise fall through.  */
		default:
		  goto got_wrong_format_error;
		}
	    }

	  if (((i_shdrp[shindex].sh_flags & SHF_INFO_LINK)
	       || i_shdrp[shindex].sh_type == SHT_RELA
	       || i_shdrp[shindex].sh_type == SHT_REL)
	      && i_shdrp[shindex].sh_info >= num_sec)
	    goto got_wrong_format_error;

	  /* If the section is loaded, but not page aligned, clear
	     D_PAGED.  */
	  if (i_shdrp[shindex].sh_size != 0
	      && (i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	      && i_shdrp[shindex].sh_type != SHT_NOBITS
	      && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
		   % ebd->minpagesize)
		  != 0))
	    abfd->flags &= ~D_PAGED;
	}
    }

  /* A further sanity check.  */
  if (i_ehdrp->e_shnum != 0)
    {
      if (i_ehdrp->e_shstrndx >= elf_numsections (abfd))
	{
	  /* PR 2257:
	     We used to just goto got_wrong_format_error here
	     but there are binaries in existance for which this test
	     will prevent the binutils from working with them at all.
	     So we are kind, and reset the string index value to 0
	     so that at least some processing can be done.  */
	  i_ehdrp->e_shstrndx = SHN_UNDEF;
	  _bfd_error_handler (_("warning: %s has a corrupt string table index - ignoring"), abfd->filename);
	}
    }
  else if (i_ehdrp->e_shstrndx != SHN_UNDEF)
    goto got_wrong_format_error;

  /* Read in the program headers.  */
  if (i_ehdrp->e_phnum == 0)
    elf_tdata (abfd)->phdr = NULL;
  else
    {
      Elf_Internal_Phdr *i_phdr;
      unsigned int i;

      amt = i_ehdrp->e_phnum * sizeof (Elf_Internal_Phdr);
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
      if (elf_tdata (abfd)->phdr == NULL)
	goto got_no_match;
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
	goto got_no_match;
      i_phdr = elf_tdata (abfd)->phdr;
      for (i = 0; i < i_ehdrp->e_phnum; i++, i_phdr++)
	{
	  Elf_External_Phdr x_phdr;

	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
	    goto got_no_match;
	  elf_swap_phdr_in (abfd, &x_phdr, i_phdr);
	}
    }

  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff != 0)
    {
      unsigned int num_sec;

      /* Once all of the section headers have been read and converted, we
	 can start processing them.  Note that the first section header is
	 a dummy placeholder entry, so we ignore it.  */
      num_sec = elf_numsections (abfd);
      for (shindex = 1; shindex < num_sec; shindex++)
	if (!bfd_section_from_shdr (abfd, shindex))
	  goto got_no_match;

      /* Set up ELF sections for SHF_GROUP and SHF_LINK_ORDER.  */
      if (! _bfd_elf_setup_sections (abfd))
	goto got_wrong_format_error;
    }

  /* Let the backend double check the format and override global
     information.  */
  if (ebd->elf_backend_object_p)
    {
      if (! (*ebd->elf_backend_object_p) (abfd))
	goto got_wrong_format_error;
    }

  /* Remember the entry point specified in the ELF file header.  */
  bfd_set_start_address (abfd, i_ehdrp->e_entry);

  /* If we have created any reloc sections that are associated with
     debugging sections, mark the reloc sections as debugging as well.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((elf_section_data (s)->this_hdr.sh_type == SHT_REL
	   || elf_section_data (s)->this_hdr.sh_type == SHT_RELA)
	  && elf_section_data (s)->this_hdr.sh_info > 0)
	{
	  unsigned long targ_index;
	  asection *targ_sec;

	  targ_index = elf_section_data (s)->this_hdr.sh_info;
	  targ_sec = bfd_section_from_elf_index (abfd, targ_index);
	  if (targ_sec != NULL
	      && (targ_sec->flags & SEC_DEBUGGING) != 0)
	    s->flags |= SEC_DEBUGGING;
	}
    }
  return target;

 got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);

 got_no_match:
  return NULL;
}

/* ELF .o/exec file writing */

/* Write out the relocs.  */

void
elf_write_relocs (bfd *abfd, asection *sec, void *data)
{
  bfd_boolean *failedp = (bfd_boolean *) data;
  Elf_Internal_Shdr *rela_hdr;
  bfd_vma addr_offset;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  size_t extsize;
  bfd_byte *dst_rela;
  unsigned int idx;
  asymbol *last_sym;
  int last_sym_idx;

  /* If we have already failed, don't do anything.  */
  if (*failedp)
    return;

  if ((sec->flags & SEC_RELOC) == 0)
    return;

  /* The linker backend writes the relocs out itself, and sets the
     reloc_count field to zero to inhibit writing them here.  Also,
     sometimes the SEC_RELOC flag gets set even when there aren't any
     relocs.  */
  if (sec->reloc_count == 0)
    return;

  /* If we have opened an existing file for update, reloc_count may be
     set even though we are not linking.  In that case we have nothing
     to do.  */
  if (sec->orelocation == NULL)
    return;

  rela_hdr = elf_section_data (sec)->rela.hdr;
  if (rela_hdr == NULL)
    rela_hdr = elf_section_data (sec)->rel.hdr;

  rela_hdr->sh_size = rela_hdr->sh_entsize * sec->reloc_count;
  rela_hdr->contents = (unsigned char *) bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  /* Figure out whether the relocations are RELA or REL relocations.  */
  if (rela_hdr->sh_type == SHT_RELA)
    {
      swap_out = elf_swap_reloca_out;
      extsize = sizeof (Elf_External_Rela);
    }
  else if (rela_hdr->sh_type == SHT_REL)
    {
      swap_out = elf_swap_reloc_out;
      extsize = sizeof (Elf_External_Rel);
    }
  else
    /* Every relocation section should be either an SHT_RELA or an
       SHT_REL section.  */
    abort ();

  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;

  /* orelocation has the data, reloc_count has the count...  */
  last_sym = 0;
  last_sym_idx = 0;
  dst_rela = rela_hdr->contents;

  for (idx = 0; idx < sec->reloc_count; idx++, dst_rela += extsize)
    {
      Elf_Internal_Rela src_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      src_rela.r_offset = ptr->address + addr_offset;
      src_rela.r_info = ELF_R_INFO (n, ptr->howto->type);
      src_rela.r_addend = ptr->addend;
      (*swap_out) (abfd, &src_rela, dst_rela);
    }
}

/* Write out the program headers.  */

int
elf_write_out_phdrs (bfd *abfd,
		     const Elf_Internal_Phdr *phdr,
		     unsigned int count)
{
  while (count--)
    {
      Elf_External_Phdr extphdr;
      elf_swap_phdr_out (abfd, phdr, &extphdr);
      if (bfd_bwrite (&extphdr, sizeof (Elf_External_Phdr), abfd)
	  != sizeof (Elf_External_Phdr))
	return -1;
      phdr++;
    }
  return 0;
}

/* Write out the section headers and the ELF file header.  */

bfd_boolean
elf_write_shdrs_and_ehdr (bfd *abfd)
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_External_Shdr *x_shdrp;	/* Section header table, external form */
  Elf_Internal_Shdr **i_shdrp;	/* Section header table, internal form */
  unsigned int count;
  bfd_size_type amt;

  i_ehdrp = elf_elfheader (abfd);
  i_shdrp = elf_elfsections (abfd);

  /* swap the header before spitting it out...  */

#if DEBUG & 1
  elf_debug_file (i_ehdrp);
#endif
  elf_swap_ehdr_out (abfd, i_ehdrp, &x_ehdr);
  amt = sizeof (x_ehdr);
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)
    return FALSE;

  /* Some fields in the first section header handle overflow of ehdr
     fields.  */
  if (i_ehdrp->e_phnum >= PN_XNUM)
    i_shdrp[0]->sh_info = i_ehdrp->e_phnum;
  if (i_ehdrp->e_shnum >= (SHN_LORESERVE & 0xffff))
    i_shdrp[0]->sh_size = i_ehdrp->e_shnum;
  if (i_ehdrp->e_shstrndx >= (SHN_LORESERVE & 0xffff))
    i_shdrp[0]->sh_link = i_ehdrp->e_shstrndx;

  /* at this point we've concocted all the ELF sections...  */
  amt = i_ehdrp->e_shnum;
  amt *= sizeof (*x_shdrp);
  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);
  if (!x_shdrp)
    return FALSE;

  for (count = 0; count < i_ehdrp->e_shnum; i_shdrp++, count++)
    {
#if DEBUG & 2
      elf_debug_section (count, *i_shdrp);
#endif
      elf_swap_shdr_out (abfd, *i_shdrp, x_shdrp + count);
    }
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0
      || bfd_bwrite (x_shdrp, amt, abfd) != amt)
    return FALSE;

  /* need to dump the string table too...  */

  return TRUE;
}

bfd_boolean
elf_checksum_contents (bfd *abfd,
		       void (*process) (const void *, size_t, void *),
		       void *arg)
{
  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);
  Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
  Elf_Internal_Phdr *i_phdrp = elf_tdata (abfd)->phdr;
  unsigned int count, num;

  {
    Elf_External_Ehdr x_ehdr;
    Elf_Internal_Ehdr i_ehdr;

    i_ehdr = *i_ehdrp;
    i_ehdr.e_phoff = i_ehdr.e_shoff = 0;
    elf_swap_ehdr_out (abfd, &i_ehdr, &x_ehdr);
    (*process) (&x_ehdr, sizeof x_ehdr, arg);
  }

  num = i_ehdrp->e_phnum;
  for (count = 0; count < num; count++)
    {
      Elf_External_Phdr x_phdr;
      elf_swap_phdr_out (abfd, &i_phdrp[count], &x_phdr);
      (*process) (&x_phdr, sizeof x_phdr, arg);
    }

  num = elf_numsections (abfd);
  for (count = 0; count < num; count++)
    {
      Elf_Internal_Shdr i_shdr;
      Elf_External_Shdr x_shdr;
      bfd_byte *contents, *free_contents;

      i_shdr = *i_shdrp[count];
      i_shdr.sh_offset = 0;

      elf_swap_shdr_out (abfd, &i_shdr, &x_shdr);
      (*process) (&x_shdr, sizeof x_shdr, arg);

      /* Process the section's contents, if it has some.
	 PR ld/12451: Read them in if necessary.  */
      if (i_shdr.sh_type == SHT_NOBITS)
	continue;
      free_contents = NULL;
      contents = i_shdr.contents;
      if (contents == NULL)
	{
	  asection *sec;

	  sec = bfd_section_from_elf_index (abfd, count);
	  if (sec != NULL)
	    {
	      contents = sec->contents;
	      if (contents == NULL)
		{
		  /* Force rereading from file.  */
		  sec->flags &= ~SEC_IN_MEMORY;
		  if (!bfd_malloc_and_get_section (abfd, sec, &free_contents))
		    continue;
		  contents = free_contents;
		}
	    }
	}
      if (contents != NULL)
	{
	  (*process) (contents, i_shdr.sh_size, arg);
	  if (free_contents != NULL)
	    free (free_contents);
	}
    }

  return TRUE;
}

long
elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
{
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Shdr *verhdr;
  unsigned long symcount;	/* Number of external ELF symbols */
  elf_symbol_type *sym;		/* Pointer to current bfd symbol */
  elf_symbol_type *symbase;	/* Buffer for generated bfd symbols */
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_External_Versym *xver;
  Elf_External_Versym *xverbuf = NULL;
  const struct elf_backend_data *ebd;
  bfd_size_type amt;

  /* Read each raw ELF symbol, converting from external ELF form to
     internal ELF form, and then using the information to create a
     canonical bfd symbol table entry.

     Note that we allocate the initial bfd canonical symbol buffer
     based on a one-to-one mapping of the ELF symbols to canonical
     symbols.  We actually use all the ELF symbols, so there will be no
     space left over at the end.  When we have all the symbols, we
     build the caller's pointer vector.  */

  if (! dynamic)
    {
      hdr = &elf_tdata (abfd)->symtab_hdr;
      verhdr = NULL;
    }
  else
    {
      hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      if (elf_dynversym (abfd) == 0)
	verhdr = NULL;
      else
	verhdr = &elf_tdata (abfd)->dynversym_hdr;
      if ((elf_dynverdef (abfd) != 0
	   && elf_tdata (abfd)->verdef == NULL)
	  || (elf_dynverref (abfd) != 0
	      && elf_tdata (abfd)->verref == NULL))
	{
	  if (!_bfd_elf_slurp_version_tables (abfd, FALSE))
	    return -1;
	}
    }

  ebd = get_elf_backend_data (abfd);
  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
  if (symcount == 0)
    sym = symbase = NULL;
  else
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return -1;

      amt = symcount;
      amt *= sizeof (elf_symbol_type);
      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);
      if (symbase == (elf_symbol_type *) NULL)
	goto error_return;

      /* Read the raw ELF version symbol information.  */
      if (verhdr != NULL
	  && verhdr->sh_size / sizeof (Elf_External_Versym) != symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s: version count (%ld) does not match symbol count (%ld)"),
	     abfd->filename,
	     (long) (verhdr->sh_size / sizeof (Elf_External_Versym)),
	     symcount);

	  /* Slurp in the symbols without the version information,
	     since that is more helpful than just quitting.  */
	  verhdr = NULL;
	}

      if (verhdr != NULL)
	{
	  if (bfd_seek (abfd, verhdr->sh_offset, SEEK_SET) != 0)
	    goto error_return;

	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (xverbuf == NULL && verhdr->sh_size != 0)
	    goto error_return;

	  if (bfd_bread (xverbuf, verhdr->sh_size, abfd) != verhdr->sh_size)
	    goto error_return;
	}

      /* Skip first symbol, which is a null dummy.  */
      xver = xverbuf;
      if (xver != NULL)
	++xver;
      isymend = isymbuf + symcount;
      for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
	{
	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));
	  sym->symbol.the_bfd = abfd;

	  sym->symbol.name = bfd_elf_sym_name (abfd, hdr, isym, NULL);

	  sym->symbol.value = isym->st_value;

	  if (isym->st_shndx == SHN_UNDEF)
	    {
	      sym->symbol.section = bfd_und_section_ptr;
	    }
	  else if (isym->st_shndx == SHN_ABS)
	    {
	      sym->symbol.section = bfd_abs_section_ptr;
	    }
	  else if (isym->st_shndx == SHN_COMMON)
	    {
	      sym->symbol.section = bfd_com_section_ptr;
	      if ((abfd->flags & BFD_PLUGIN) != 0)
		{
		  asection *xc = bfd_get_section_by_name (abfd, "COMMON");

		  if (xc == NULL)
		    {
		      flagword flags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP
					| SEC_EXCLUDE);
		      xc = bfd_make_section_with_flags (abfd, "COMMON", flags);
		      if (xc == NULL)
			goto error_return;
		    }
		  sym->symbol.section = xc;
		}
	      /* Elf puts the alignment into the `value' field, and
		 the size into the `size' field.  BFD wants to see the
		 size in the value field, and doesn't care (at the
		 moment) about the alignment.  */
	      sym->symbol.value = isym->st_size;
	    }
	  else
	    {
	      sym->symbol.section
		= bfd_section_from_elf_index (abfd, isym->st_shndx);
	      if (sym->symbol.section == NULL)
		{
		  /* This symbol is in a section for which we did not
		     create a BFD section.  Just use bfd_abs_section,
		     although it is wrong.  FIXME.  */
		  sym->symbol.section = bfd_abs_section_ptr;
		}
	    }

	  /* If this is a relocatable file, then the symbol value is
	     already section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    sym->symbol.value -= sym->symbol.section->vma;

	  switch (ELF_ST_BIND (isym->st_info))
	    {
	    case STB_LOCAL:
	      sym->symbol.flags |= BSF_LOCAL;
	      break;
	    case STB_GLOBAL:
	      if (isym->st_shndx != SHN_UNDEF && isym->st_shndx != SHN_COMMON)
		sym->symbol.flags |= BSF_GLOBAL;
	      break;
	    case STB_WEAK:
	      sym->symbol.flags |= BSF_WEAK;
	      break;
	    case STB_GNU_UNIQUE:
	      sym->symbol.flags |= BSF_GNU_UNIQUE;
	      break;
	    }

	  switch (ELF_ST_TYPE (isym->st_info))
	    {
	    case STT_SECTION:
	      sym->symbol.flags |= BSF_SECTION_SYM | BSF_DEBUGGING;
	      break;
	    case STT_FILE:
	      sym->symbol.flags |= BSF_FILE | BSF_DEBUGGING;
	      break;
	    case STT_FUNC:
	      sym->symbol.flags |= BSF_FUNCTION;
	      break;
	    case STT_COMMON:
	      /* FIXME: Do we have to put the size field into the value field
		 as we do with symbols in SHN_COMMON sections (see above) ?  */
	      /* Fall through.  */
	    case STT_OBJECT:
	      sym->symbol.flags |= BSF_OBJECT;
	      break;
	    case STT_TLS:
	      sym->symbol.flags |= BSF_THREAD_LOCAL;
	      break;
	    case STT_RELC:
	      sym->symbol.flags |= BSF_RELC;
	      break;
	    case STT_SRELC:
	      sym->symbol.flags |= BSF_SRELC;
	      break;
	    case STT_GNU_IFUNC:
	      sym->symbol.flags |= BSF_GNU_INDIRECT_FUNCTION;
	      break;
	    }

	  if (dynamic)
	    sym->symbol.flags |= BSF_DYNAMIC;

	  if (xver != NULL)
	    {
	      Elf_Internal_Versym iversym;

	      _bfd_elf_swap_versym_in (abfd, xver, &iversym);
	      sym->version = iversym.vs_vers;
	      xver++;
	    }

	  /* Do some backend-specific processing on this symbol.  */
	  if (ebd->elf_backend_symbol_processing)
	    (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
	}
    }

  /* Do some backend-specific processing on this symbol table.  */
  if (ebd->elf_backend_symbol_table_processing)
    (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);

  /* We rely on the zalloc to clear out the final symbol entry.  */

  symcount = sym - symbase;

  /* Fill in the user's symbol pointer vector if needed.  */
  if (symptrs)
    {
      long l = symcount;

      sym = symbase;
      while (l-- > 0)
	{
	  *symptrs++ = &sym->symbol;
	  sym++;
	}
      *symptrs = 0;		/* Final null pointer */
    }

  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return symcount;

error_return:
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return -1;
}

/* Read relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
   them.  */

static bfd_boolean
elf_slurp_reloc_table_from_section (bfd *abfd,
				    asection *asect,
				    Elf_Internal_Shdr *rel_hdr,
				    bfd_size_type reloc_count,
				    arelent *relents,
				    asymbol **symbols,
				    bfd_boolean dynamic)
{
  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
  void *allocated = NULL;
  bfd_byte *native_relocs;
  arelent *relent;
  unsigned int i;
  int entsize;
  unsigned int symcount;

  allocated = bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    goto error_return;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
    goto error_return;

  native_relocs = (bfd_byte *) allocated;

  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf_External_Rel)
	      || entsize == sizeof (Elf_External_Rela));

  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

  for (i = 0, relent = relents;
       i < reloc_count;
       i++, relent++, native_relocs += entsize)
    {
      Elf_Internal_Rela rela;

      if (entsize == sizeof (Elf_External_Rela))
	elf_swap_reloca_in (abfd, native_relocs, &rela);
      else
	elf_swap_reloc_in (abfd, native_relocs, &rela);

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a normal BFD reloc is always section relative,
	 and the address of a dynamic reloc is absolute..  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
	relent->address = rela.r_offset;
      else
	relent->address = rela.r_offset - asect->vma;

      if (ELF_R_SYM (rela.r_info) == STN_UNDEF)
	relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
      else if (ELF_R_SYM (rela.r_info) > symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): relocation %d has invalid symbol index %ld"),
	     abfd->filename, asect->name, i, ELF_R_SYM (rela.r_info));
	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	}
      else
	{
	  asymbol **ps;

	  ps = symbols + ELF_R_SYM (rela.r_info) - 1;

	  relent->sym_ptr_ptr = ps;
	}

      relent->addend = rela.r_addend;

      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
	(*ebd->elf_info_to_howto) (abfd, relent, &rela);
      else
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rela);
    }

  if (allocated != NULL)
    free (allocated);

  return TRUE;

 error_return:
  if (allocated != NULL)
    free (allocated);
  return FALSE;
}

/* Read in and swap the external relocs.  */

bfd_boolean
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = d->rel.hdr;
      reloc_count = rel_hdr ? NUM_SHDR_ENTRIES (rel_hdr) : 0;
      rel_hdr2 = d->rela.hdr;
      reloc_count2 = rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0;

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT ((rel_hdr && asect->rel_filepos == rel_hdr->sh_offset)
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));

    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }

  amt = (reloc_count + reloc_count2) * sizeof (arelent);
  relents = (arelent *) bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;

  if (rel_hdr
      && !elf_slurp_reloc_table_from_section (abfd, asect,
					      rel_hdr, reloc_count,
					      relents,
					      symbols, dynamic))
    return FALSE;

  if (rel_hdr2
      && !elf_slurp_reloc_table_from_section (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count,
					      symbols, dynamic))
    return FALSE;

  asect->relocation = relents;
  return TRUE;
}

#if DEBUG & 2
static void
elf_debug_section (int num, Elf_Internal_Shdr *hdr)
{
  fprintf (stderr, "\nSection#%d '%s' 0x%.8lx\n", num,
	   hdr->bfd_section != NULL ? hdr->bfd_section->name : "",
	   (long) hdr);
  fprintf (stderr,
	   "sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n",
	   (long) hdr->sh_name,
	   (long) hdr->sh_type,
	   (long) hdr->sh_flags);
  fprintf (stderr,
	   "sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n",
	   (long) hdr->sh_addr,
	   (long) hdr->sh_offset,
	   (long) hdr->sh_size);
  fprintf (stderr,
	   "sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n",
	   (long) hdr->sh_link,
	   (long) hdr->sh_info,
	   (long) hdr->sh_addralign);
  fprintf (stderr, "sh_entsize   = %ld\n",
	   (long) hdr->sh_entsize);
  fflush (stderr);
}
#endif

#if DEBUG & 1
static void
elf_debug_file (Elf_Internal_Ehdr *ehdrp)
{
  fprintf (stderr, "e_entry      = 0x%.8lx\n", (long) ehdrp->e_entry);
  fprintf (stderr, "e_phoff      = %ld\n", (long) ehdrp->e_phoff);
  fprintf (stderr, "e_phnum      = %ld\n", (long) ehdrp->e_phnum);
  fprintf (stderr, "e_phentsize  = %ld\n", (long) ehdrp->e_phentsize);
  fprintf (stderr, "e_shoff      = %ld\n", (long) ehdrp->e_shoff);
  fprintf (stderr, "e_shnum      = %ld\n", (long) ehdrp->e_shnum);
  fprintf (stderr, "e_shentsize  = %ld\n", (long) ehdrp->e_shentsize);
}
#endif

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for a target with the word size and byte order found in the
   remote memory.  */

bfd *
NAME(_bfd_elf,bfd_from_remote_memory)
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type))
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
  Elf_External_Phdr *x_phdrs;
  Elf_Internal_Phdr *i_phdrs, *last_phdr;
  bfd *nbfd;
  struct bfd_in_memory *bim;
  int contents_size;
  bfd_byte *contents;
  int err;
  unsigned int i;
  bfd_vma loadbase;
  bfd_boolean loadbase_set;

  /* Read in the ELF header in external format.  */
  err = target_read_memory (ehdr_vma, (bfd_byte *) &x_ehdr, sizeof x_ehdr);
  if (err)
    {
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry.  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  elf_swap_ehdr_in (templ, &x_ehdr, &i_ehdr);

  /* The file header tells where to find the program headers.
     These are what we use to actually choose what to read.  */

  if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  x_phdrs = (Elf_External_Phdr *)
      bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
  if (x_phdrs == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (bfd_byte *) x_phdrs,
			    i_ehdr.e_phnum * sizeof x_phdrs[0]);
  if (err)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }
  i_phdrs = (Elf_Internal_Phdr *) &x_phdrs[i_ehdr.e_phnum];

  contents_size = 0;
  last_phdr = NULL;
  loadbase = ehdr_vma;
  loadbase_set = FALSE;
  for (i = 0; i < i_ehdr.e_phnum; ++i)
    {
      elf_swap_phdr_in (templ, &x_phdrs[i], &i_phdrs[i]);
      if (i_phdrs[i].p_type == PT_LOAD)
	{
	  bfd_vma segment_end;
	  segment_end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
			 + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	  if (segment_end > (bfd_vma) contents_size)
	    contents_size = segment_end;

	  /* LOADADDR is the `Base address' from the gELF specification:
	     `lowest p_vaddr value for a PT_LOAD segment' is P_VADDR from the
	     first PT_LOAD as PT_LOADs are ordered by P_VADDR.  */
	  if (!loadbase_set && (i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    {
	      loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);
	      loadbase_set = TRUE;
	    }

	  last_phdr = &i_phdrs[i];
	}
    }
  if (last_phdr == NULL)
    {
      /* There were no PT_LOAD segments, so we don't have anything to read.  */
      free (x_phdrs);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Trim the last segment so we don't bother with zeros in the last page
     that are off the end of the file.  However, if the extra bit in that
     page includes the section headers, keep them.  */
  if ((bfd_vma) contents_size > last_phdr->p_offset + last_phdr->p_filesz
      && (bfd_vma) contents_size >= (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      contents_size = last_phdr->p_offset + last_phdr->p_filesz;
      if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
	contents_size = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;
    }
  else
    contents_size = last_phdr->p_offset + last_phdr->p_filesz;

  /* Now we know the size of the whole image we want read in.  */
  contents = (bfd_byte *) bfd_zmalloc (contents_size);
  if (contents == NULL)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  for (i = 0; i < i_ehdr.e_phnum; ++i)
    if (i_phdrs[i].p_type == PT_LOAD)
      {
	bfd_vma start = i_phdrs[i].p_offset & -i_phdrs[i].p_align;
	bfd_vma end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
		       + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	if (end > (bfd_vma) contents_size)
	  end = contents_size;
	err = target_read_memory ((loadbase + i_phdrs[i].p_vaddr)
				  & -i_phdrs[i].p_align,
				  contents + start, end - start);
	if (err)
	  {
	    free (x_phdrs);
	    free (contents);
	    bfd_set_error (bfd_error_system_call);
	    errno = err;
	    return NULL;
	  }
      }
  free (x_phdrs);

  /* If the segments visible in memory didn't include the section headers,
     then clear them from the file header.  */
  if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				 + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      memset (&x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);
      memset (&x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);
      memset (&x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);
    }

  /* This will normally have been in the first PT_LOAD segment.  But it
     conceivably could be missing, and we might have just changed it.  */
  memcpy (contents, &x_ehdr, sizeof x_ehdr);

  /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
  if (bim == NULL)
    {
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      free (bim);
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd->filename = "<in-memory>";
  nbfd->xvec = templ->xvec;
  bim->size = contents_size;
  bim->buffer = contents;
  nbfd->iostream = bim;
  nbfd->flags = BFD_IN_MEMORY;
  nbfd->iovec = &_bfd_memory_iovec;
  nbfd->origin = 0;
  nbfd->direction = read_direction;
  nbfd->mtime = time (NULL);
  nbfd->mtime_set = TRUE;

  if (loadbasep)
    *loadbasep = loadbase;
  return nbfd;
}

/* Function for ELF_R_INFO.  */

bfd_vma
NAME(elf,r_info) (bfd_vma sym, bfd_vma type)
{
  return ELF_R_INFO (sym, type);
}

/* Function for ELF_R_SYM.  */

bfd_vma
NAME(elf,r_sym) (bfd_vma r_info)
{
  return ELF_R_SYM (r_info);
}

#include "elfcore.h"

/* Size-dependent data and functions.  */
const struct elf_size_info NAME(_bfd_elf,size_info) = {
  sizeof (Elf_External_Ehdr),
  sizeof (Elf_External_Phdr),
  sizeof (Elf_External_Shdr),
  sizeof (Elf_External_Rel),
  sizeof (Elf_External_Rela),
  sizeof (Elf_External_Sym),
  sizeof (Elf_External_Dyn),
  sizeof (Elf_External_Note),
  4,
  1,
  ARCH_SIZE, LOG_FILE_ALIGN,
  ELFCLASS, EV_CURRENT,
  elf_write_out_phdrs,
  elf_write_shdrs_and_ehdr,
  elf_checksum_contents,
  elf_write_relocs,
  elf_swap_symbol_in,
  elf_swap_symbol_out,
  elf_slurp_reloc_table,
  elf_slurp_symbol_table,
  elf_swap_dyn_in,
  elf_swap_dyn_out,
  elf_swap_reloc_in,
  elf_swap_reloc_out,
  elf_swap_reloca_in,
  elf_swap_reloca_out
};
@


1.117
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d1155 1
a1155 1
      if ((elf_tdata (abfd)->dynverdef_section != 0
d1157 1
a1157 1
	  || (elf_tdata (abfd)->dynverref_section != 0
@


1.116
log
@	* bfd.c (struct bfd_preserve, bfd_preserve_save, bfd_preserve_restore,
	bfd_preserve_finish): Move to..
	* format.c: ..here, splitting out..
	(bfd_reinit): ..this.  New function.
	(bfd_check_format_matches): Use bfd_preserve_save/restore to
	keep bfd state for a match.
	* elfcode.h (elf_object_p): Don't use bfd_preserve_save/restore.
	* elfcore.h (elf_core_file_p): Likewise.
	* mach-o.c (bfd_mach_o_header_p): Likewise.
	* pef.c (bfd_pef_object_p, bfd_pef_xlib_object_p): Likewise.
	* xsym.c (bfd_sym_object_p): Likewise.
	* mmo.c (mmo_scan): Clear abfd->symcount.
	* opncls.c (_bfd_new_bfd): Use a smaller section hash table.
	* section.c (bfd_section_list_clear): Clear section_htab.count.
	* bfd-in2.h: Regenerate.
@
text
@d1074 1
d1082 7
a1088 5
      /* PR ld/12451:
	 Process the section's contents, if it has some.  Read them in if necessary.  */
      if (i_shdr.contents)
	(*process) (i_shdr.contents, i_shdr.sh_size, arg);
      else if (i_shdr.sh_type != SHT_NOBITS)
d1095 2
a1096 1
	      if (sec->contents == NULL)
d1100 1
a1100 1
		  if (! bfd_malloc_and_get_section (abfd, sec, & sec->contents))
d1102 1
a1103 2
	      if (sec->contents != NULL)
		(*process) (sec->contents, i_shdr.sh_size, arg);
d1106 6
@


1.115
log
@Check number of sections overflow

	* elf.c (assign_section_numbers): Check if number of sections
	>= SHN_LORESERVE.
	* elfcode.h (elf_object_p): Likewise.
@
text
@a497 1
  struct bfd_preserve preserve;
a501 2
  preserve.marker = NULL;

a538 3
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

a545 1
  preserve.marker = elf_tdata (abfd);
a837 2

  bfd_preserve_finish (abfd, &preserve);
a840 9
  /* There is way too much undoing of half-known state here.  The caller,
     bfd_check_format_matches, really shouldn't iterate on live bfd's to
     check match/no-match like it does.  We have to rely on that a call to
     bfd_default_set_arch_mach with the previously known mach, undoes what
     was done by the first bfd_default_set_arch_mach (with mach 0) here.
     For this to work, only elf-data and the mach may be changed by the
     target-specific elf_backend_object_p function.  Note that saving the
     whole bfd here and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
a843 2
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
@


1.114
log
@bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Make LEN argument
	of target_read_memory as bfd_size_type.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (elf_backend_bfd_from_remote_memory): Make LEN
	argument of target_read_memory as bfd_size_type.
	(_bfd_elf32_bfd_from_remote_memory): Likewise.
	(_bfd_elf64_bfd_from_remote_memory): Likewise.
	* elf.c (bfd_elf_bfd_from_remote_memory): Likewise.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): Likewise.

gdb/
	* symfile-mem.c: 3 new gdb_static_assert for target_read_memory_bfd
	parameters.
	(target_read_memory_bfd): New function.
	(symbol_file_add_from_memory): Use it.
@
text
@d636 3
a638 2
	  if (i_ehdrp->e_shnum != i_shdr.sh_size
	      || i_ehdrp->e_shnum == 0)
@


1.113
log
@bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Make LEN argument
	of target_read_memory as size_t.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (elf_backend_bfd_from_remote_memory): Make LEN
	argument of target_read_memory as size_t.
	(_bfd_elf32_bfd_from_remote_memory): Likewise.
	(_bfd_elf64_bfd_from_remote_memory): Likewise.
	* elf.c (bfd_elf_bfd_from_remote_memory): Likewise.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): Likewise.

gdb/
	* target.c (target_read_memory): Make LEN argument as size_t.
	* target.h (target_read_memory): Likewise.
@
text
@d1618 1
a1618 1
   int (*target_read_memory) (bfd_vma, bfd_byte *, size_t))
@


1.112
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d1618 1
a1618 1
   int (*target_read_memory) (bfd_vma, bfd_byte *, int))
@


1.111
log
@When computing checksums, skip the contents of sections with the SHT_NOBITS type.
Revert change to compress.c
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1453 1
a1453 1
	  relent->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;
@


1.110
log
@	PR ld/12451
	* elfcode.h (elf_checksum_contents): Read in the section's
	contents if they are not already available.
	* compress.c (bfd_get_full_section_contents): Use zmalloc to
	allocate the buffers so that excess bytes are guaranteed to be
	zero.
@
text
@d1101 1
a1101 1
	 Process the section's contents; reading them in if necessary.  */
d1104 1
a1104 1
      else
@


1.109
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1100 2
d1104 18
@


1.108
log
@Revert the last change on elf_object_p.

2011-06-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12842
	* elfcode.h (elf_object_p): Revert the last change.
@
text
@a501 1
  const bfd_target * const *target_ptr;
d590 3
a592 28
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
    {
      if (ebd->elf_machine_code != EM_NONE)
	goto got_wrong_format_error;

      /* This is the generic ELF target.  Let it match any ELF target
	 for which we do not have a specific backend.  */
      for (target_ptr = bfd_target_vector; *target_ptr != NULL; target_ptr++)
	{
	  const struct elf_backend_data *back;

	  if ((*target_ptr)->flavour != bfd_target_elf_flavour)
	    continue;
	  back = xvec_get_elf_backend_data (*target_ptr);
	  if (back->s->arch_size != ARCH_SIZE)
	    continue;
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
		  && back->elf_machine_alt1 == i_ehdrp->e_machine)
	      || (back->elf_machine_alt2 != 0
		  && back->elf_machine_alt2 == i_ehdrp->e_machine))
	    {
	      /* target_ptr is an ELF backend which matches this
		 object file, so reject the generic ELF target.  */
	      goto got_wrong_format_error;
	    }
	}
    }
d610 3
a612 37
      && i_ehdrp->e_ident[EI_OSABI] != ebd->elf_osabi)
    {
      if (ebd->elf_osabi != ELFOSABI_NONE)
	goto got_wrong_format_error;

      /* This is an ELFOSABI_NONE ELF target.  Let it match any ELF
	 target of the compatible machine for which we do not have a
	 backend with matching ELFOSABI.  */
      for (target_ptr = bfd_target_vector;
	   *target_ptr != NULL;
	   target_ptr++)
	{
	  const struct elf_backend_data *back;

	  /* Skip this target and targets with incompatible byte
	     order.  */
	  if (*target_ptr == target
	      || (*target_ptr)->flavour != bfd_target_elf_flavour
	      || (*target_ptr)->byteorder != target->byteorder
	      || ((*target_ptr)->header_byteorder
		  != target->header_byteorder))
	    continue;

	  back = xvec_get_elf_backend_data (*target_ptr);
	  if (back->elf_osabi == i_ehdrp->e_ident[EI_OSABI]
	      && (back->elf_machine_code == i_ehdrp->e_machine
		  || (back->elf_machine_alt1 != 0
		      && back->elf_machine_alt1 == i_ehdrp->e_machine)
		  || (back->elf_machine_alt2 != 0
		      && back->elf_machine_alt2 == i_ehdrp->e_machine)))
	    {
	      /* target_ptr is an ELF backend which matches this
		 object file, so reject the ELFOSABI_NONE ELF target.  */
	      goto got_wrong_format_error;
	    }
	}
    }
@


1.107
log
@	* archures.c (bfd_arch_get_compatible): If one arch is unknown,
	return the other arch.
	* elfcode.h (elf_object_p): Allow explicit match to generic ELF
	target.
@
text
@d598 3
a600 4
      if (abfd->target_defaulted)
	for (target_ptr = bfd_target_vector; *target_ptr != NULL; target_ptr++)
	  {
	    const struct elf_backend_data *back;
d602 16
a617 16
	    if ((*target_ptr)->flavour != bfd_target_elf_flavour)
	      continue;
	    back = xvec_get_elf_backend_data (*target_ptr);
	    if (back->s->arch_size != ARCH_SIZE)
	      continue;
	    if (back->elf_machine_code == i_ehdrp->e_machine
		|| (back->elf_machine_alt1 != 0
		    && back->elf_machine_alt1 == i_ehdrp->e_machine)
		|| (back->elf_machine_alt2 != 0
		    && back->elf_machine_alt2 == i_ehdrp->e_machine))
	      {
		/* target_ptr is an ELF backend which matches this
		   object file, so reject the generic ELF target.  */
		goto got_wrong_format_error;
	      }
	  }
@


1.106
log
@	PR ld/12365
bfd/
	* elfcode.h (elf_slurp_symbol_table): Put common plugin IR symbols
	in their own common section.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Don't lose flags
	if common section is pre-existing.
	(_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldfile.c (ldfile_try_open_bfd): Move code creating and switching
	to plugin IR BFD..
	* ldmain.c (add_archive_element): ..and similar code here..
	* plugin.c (plugin_maybe_claim): ..to here.  New function.
	(plugin_call_claim_file): Make static.
	(asymbol_from_plugin_symbol): Set ELF st_shndx for common syms.
	(plugin_multiple_common): New function.
	(plugin_call_all_symbols_read): Hook in plugin_multiple_common.
	* plugin.h (plugin_call_claim_file): Don't declare.
	(plugin_maybe_claim): Declare.
@
text
@d598 4
a601 3
      for (target_ptr = bfd_target_vector; *target_ptr != NULL; target_ptr++)
	{
	  const struct elf_backend_data *back;
d603 16
a618 16
	  if ((*target_ptr)->flavour != bfd_target_elf_flavour)
	    continue;
	  back = xvec_get_elf_backend_data (*target_ptr);
	  if (back->s->arch_size != ARCH_SIZE)
	    continue;
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
		  && back->elf_machine_alt1 == i_ehdrp->e_machine)
	      || (back->elf_machine_alt2 != 0
		  && back->elf_machine_alt2 == i_ehdrp->e_machine))
	    {
	      /* target_ptr is an ELF backend which matches this
		 object file, so reject the generic ELF target.  */
	      goto got_wrong_format_error;
	    }
	}
@


1.105
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1285 14
@


1.104
log
@Move elfXX_r_info/elfXX_r_sym to elfcode.h.

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfcode.h (NAME(elf,r_info)): New.
	(NAME(elf,r_sym)): Likewise.

	* elflink.c (elf64_r_info): Removed.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.
@
text
@d201 1
@


1.103
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d1858 16
@


1.103.2.1
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@a1283 14
	      if ((abfd->flags & BFD_PLUGIN) != 0)
		{
		  asection *xc = bfd_get_section_by_name (abfd, "COMMON");

		  if (xc == NULL)
		    {
		      flagword flags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP
					| SEC_EXCLUDE);
		      xc = bfd_make_section_with_flags (abfd, "COMMON", flags);
		      if (xc == NULL)
			goto error_return;
		    }
		  sym->symbol.section = xc;
		}
@


1.102
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d962 3
a964 1
  rela_hdr = &elf_section_data (sec)->rel_hdr;
d1535 4
a1538 4
      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);
d1541 1
a1541 1
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
d1565 5
a1569 4
  if (!elf_slurp_reloc_table_from_section (abfd, asect,
					   rel_hdr, reloc_count,
					   relents,
					   symbols, dynamic))
@


1.101
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d1469 1
a1469 1
      if (ELF_R_SYM (rela.r_info) == 0)
@


1.100
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d90 1
@


1.99
log
@        * elfcode.h (elf_swap_ehdr_out): Handle e_phnum > 0xffff.
	(elf_object_p): Read e_phnum extension.
	(elf_write_shdrs_and_ehdr): Write e_phnum extension.
        * elfcore.h (elf_core_file_p): Read e_phnum extension.  Sanity check
	that we can read last program header.
@
text
@d1844 2
@


1.98
log
@        PR 10478
        * elf.c (bfd_section_from_shdr): Allow SHN_BEFORE and SHN_AFTER
        section link values in x86 binaries.
        * elfcode.h (elf_object_p): Likewise.
        * readelf.c (get_elf_section_flags): Allow SHN_BEFORE and
        SHN_AFTER section link values in x86 binaries.
        (process_section_headers): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d282 4
a285 1
  H_PUT_16 (abfd, src->e_phnum, dst->e_phnum);
d707 8
d1086 2
@


1.97
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d764 1
a764 1
	      /* PR 10478: Accept sparc binaries with a sh_link
d768 3
@


1.96
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d179 2
a180 2
  const Elf_External_Sym *src = psrc;
  const Elf_External_Sym_Shndx *shndx = pshn;
d213 1
a213 1
  Elf_External_Sym *dst = cdst;
d442 1
a442 1
  const Elf_External_Dyn *src = p;
d453 1
a453 1
  Elf_External_Dyn *dst = p;
d739 1
a739 1
      i_shdrp = bfd_alloc (abfd, amt);
d745 1
a745 1
      elf_elfsections (abfd) = bfd_alloc (abfd, amt);
d826 1
a826 1
      elf_tdata (abfd)->phdr = bfd_alloc (abfd, amt);
d917 1
a917 1
  bfd_boolean *failedp = data;
d950 1
a950 1
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d1080 1
a1080 1
  x_shdrp = bfd_alloc (abfd, amt);
d1208 1
a1208 1
      symbase = bfd_zalloc (abfd, amt);
d1232 1
a1232 1
	  xverbuf = bfd_malloc (verhdr->sh_size);
d1421 1
a1421 1
  native_relocs = allocated;
d1542 1
a1542 1
  relents = bfd_alloc (abfd, amt);
d1693 2
a1694 1
  x_phdrs = bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
d1762 1
a1762 1
  contents = bfd_zmalloc (contents_size);
d1807 1
a1807 1
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
@


1.95
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d763 17
a779 1
	    goto got_wrong_format_error;
@


1.95.4.1
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d763 1
a763 17
	    {
	      /* PR 10478: Accept sparc binaries with a sh_link
		 field set to SHN_BEFORE or SHN_AFTER.  */
	      switch (ebd->elf_machine_code)
		{
		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (i_shdrp[shindex].sh_link == (SHN_LORESERVE & 0xffff) /* SHN_BEFORE */
		      || i_shdrp[shindex].sh_link == ((SHN_LORESERVE + 1) & 0xffff) /* SHN_AFTER */)
		    break;
		  /* Otherwise fall through.  */
		default:
		  goto got_wrong_format_error;
		}
	    }
@


1.95.4.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d179 2
a180 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
d213 1
a213 1
  Elf_External_Sym *dst = (Elf_External_Sym *) cdst;
d442 1
a442 1
  const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;
d453 1
a453 1
  Elf_External_Dyn *dst = (Elf_External_Dyn *) p;
d739 1
a739 1
      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d745 1
a745 1
      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
d826 1
a826 1
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d917 1
a917 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d950 1
a950 1
  rela_hdr->contents = (unsigned char *) bfd_alloc (abfd, rela_hdr->sh_size);
d1080 1
a1080 1
  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);
d1208 1
a1208 1
      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d1232 1
a1232 1
	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
d1421 1
a1421 1
  native_relocs = (bfd_byte *) allocated;
d1542 1
a1542 1
  relents = (arelent *) bfd_alloc (abfd, amt);
d1693 1
a1693 2
  x_phdrs = (Elf_External_Phdr *)
      bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
d1761 1
a1761 1
  contents = (bfd_byte *) bfd_zmalloc (contents_size);
d1806 1
a1806 1
  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
@


1.94
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d1285 3
@


1.93
log
@Remove STT_IFUNC support.
@
text
@d1314 3
@


1.92
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a1313 3
	    case STT_IFUNC:
	      sym->symbol.flags |= BSF_INDIRECT_FUNCTION;
	      break;
@


1.91
log
@	* elfcore.h (elf_core_file_p): Ensure we have a backend match
	with the correct arch size before rejecting the generic fallback.
	* elfcode.h (elf_object_p): Likewise.  Ensure arch size matches
	before accepting a target.
@
text
@d1314 3
@


1.90
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d577 2
d600 2
@


1.89
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d192 1
a192 1
  if (dst->st_shndx == SHN_XINDEX)
d198 2
d220 1
a220 1
  if (tmp > SHN_HIRESERVE)
d225 1
a225 1
      tmp = SHN_XINDEX;
d285 1
a285 1
  if (tmp >= SHN_LORESERVE)
d289 2
a290 2
  if (tmp >= SHN_LORESERVE)
    tmp = SHN_XINDEX;
a474 19
/* Determines if a given section index is valid.  */

static inline bfd_boolean
valid_section_index_p (unsigned index, unsigned num_sections)
{
  /* Note: We allow SHN_UNDEF as a valid section index.  */
  if (index < SHN_LORESERVE || index > SHN_HIRESERVE)
    return index < num_sections;

  /* We disallow the use of reserved indcies, except for those
     with OS or Application specific meaning.  The test make use
     of the knowledge that:
       SHN_LORESERVE == SHN_LOPROC
     and
       SHN_HIPROC == SHN_LOOS - 1  */
  /* XXX - Should we allow SHN_XINDEX as a valid index here ?  */
  return (index >= SHN_LOPROC && index <= SHN_HIOS);
}

d693 1
a693 1
      if (i_ehdrp->e_shstrndx == SHN_XINDEX)
a738 2
      if (num_sec > SHN_LORESERVE)
	num_sec += SHN_HIRESERVE + 1 - SHN_LORESERVE;
d746 1
a746 10
      shdrp = i_shdrp;
      shindex = 0;
      if (num_sec > SHN_LORESERVE)
	{
	  for ( ; shindex < SHN_LORESERVE; shindex++)
	    elf_elfsections (abfd)[shindex] = shdrp++;
	  for ( ; shindex < SHN_HIRESERVE + 1; shindex++)
	    elf_elfsections (abfd)[shindex] = i_shdrp;
	}
      for ( ; shindex < num_sec; shindex++)
d758 1
a758 1
	  if (! valid_section_index_p (i_shdrp[shindex].sh_link, num_sec))
d764 1
a764 1
	      && ! valid_section_index_p (i_shdrp[shindex].sh_info, num_sec))
d782 1
a782 1
      if (! valid_section_index_p (i_ehdrp->e_shstrndx, elf_numsections (abfd)))
d831 2
a832 6
	{
	  if (! bfd_section_from_shdr (abfd, shindex))
	    goto got_no_match;
	  if (shindex == SHN_LORESERVE - 1)
	    shindex += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
d1052 1
a1052 1
  if (i_ehdrp->e_shnum >= SHN_LORESERVE)
d1054 1
a1054 1
  if (i_ehdrp->e_shstrndx >= SHN_LORESERVE)
a1069 3

      if (count == SHN_LORESERVE - 1)
	i_shdrp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
@


1.88
log
@2007-12-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5449
	* elf.c (rewrite_elf_program_header): Don't adjust p_paddr if
	p_paddr is set to 0.
	(copy_private_bfd_data): Call rewrite_elf_program_header if
	p_paddr is set to 0.

	* elfcode.h (elf_swap_phdr_out): Set p_paddr to 0 if needed.

	* elfxx-ia64.c (ELF_MAXPAGESIZE): Don't redefine it for HPUX.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
a1272 13
	  else if (isym->st_shndx < SHN_LORESERVE
		   || isym->st_shndx > SHN_HIRESERVE)
	    {
	      sym->symbol.section = bfd_section_from_elf_index (abfd,
								isym->st_shndx);
	      if (sym->symbol.section == NULL)
		{
		  /* This symbol is in a section for which we did not
		     create a BFD section.  Just use bfd_abs_section,
		     although it is wrong.  FIXME.  */
		  sym->symbol.section = bfd_abs_section_ptr;
		}
	    }
d1287 11
a1297 1
	    sym->symbol.section = bfd_abs_section_ptr;
@


1.87
log
@Support the use of the STT_COMMON type.  (In source and object files only at the moment)
@
text
@d373 6
d383 1
a383 1
  H_PUT_WORD (abfd, src->p_paddr, dst->p_paddr);
@


1.86
log
@2007-08-14  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): LOADBASE is now
	initialized only on the first PT_LOAD.  New variable LOADBASE_SET.
	Removed PF_R checking for IA-64 vDSOs as redundant now.
	Code advisory: Roland McGrath
@
text
@d1326 4
@


1.85
log
@2007-08-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (xvec_get_elf_backend_data): Add const.

	* elfcode.h (elf_object_p): Use xvec_get_elf_backend_data.
	* elfcore.h (elf_core_file_p): Likewise.
@
text
@d1638 1
d1715 1
d1719 1
a1719 4
      /* IA-64 vDSO may have two mappings for one segment, where one mapping
	 is executable only, and one is read only.  We must not use the
	 executable one.  */
      if (i_phdrs[i].p_type == PT_LOAD && (i_phdrs[i].p_flags & PF_R))
d1727 8
a1734 2
	  if ((i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);
d1772 1
a1772 4
    /* IA-64 vDSO may have two mappings for one segment, where one mapping
       is executable only, and one is read only.  We must not use the
       executable one.  */
    if (i_phdrs[i].p_type == PT_LOAD && (i_phdrs[i].p_flags & PF_R))
@


1.84
log
@2007-07-09  Roland McGrath  <roland@@redhat.com>

	* elf-bfd.h (struct elf_size_info): Add checksum_contents hook.
	(bfd_elf32_checksum_contents, bfd_elf64_checksum_contents): Declare.
	* elfcode.h (elf_checksum_contents): New macro and function.
	(NAME(_bfd_elf,size_info)): Initialize checksum_contents hook.
@
text
@d608 1
a608 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
d661 1
a661 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
@


1.83
log
@Switch sources over to use the GPL version 3
@
text
@d125 1
d475 1
a475 1
  
d1109 47
d1854 1
@


1.82
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d18 16
a33 1
This file is part of BFD, the Binary File Descriptor library.
a34 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.81
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d68 1
a69 1
#include "sysdep.h"
@


1.80
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d503 2
d548 2
d553 1
a553 1
  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
a592 2
      const bfd_target * const *target_ptr;

d633 39
d892 1
a892 1
  return abfd->xvec;
@


1.79
log
@	* elfcode.h (elf_swap_symbol_in): Return bfd_boolean.  Don't abort
	on error.
	* elf-bfd.h (elf_size_info <swap_symbol_in>): Adjust decl.
	(bfd_elf32_swap_symbol_in, bfd_elf64_swap_symbol_in): Likewise.
	* elf.c (bfd_elf_get_elf_syms): Test return of swap_symbol_in,
	and report error.
	* elf32-arm.c (elf32_arm_swap_symbol_in): Return bfd_boolean.
@
text
@d1240 6
@


1.78
log
@Add support for AVR6 family
@
text
@d169 1
a169 1
void
d191 1
a191 1
	abort ();
d194 1
@


1.77
log
@PR ld/2607
* elfcode.h (valid_section_index_p): New function: Checks for a valid section
  index.  Allows indicies in the range SHN_LOPROC to SHN_HIOS.
  (elf_object_p): Use valid_section_index_p.
@
text
@d1367 1
@


1.76
log
@	* archive.c (bfd_generic_archive_p): Remove unused local variable
	`fail'.
	* dwarf2.c (decode_line_info): Remove unused local variable
	`basic_block'.
	* elfcode.h (elf_slurp_reloc_table_from_section): Remove unsed
	local varibale `s'.
	* tekhex.c (tekhex_write_object_contents): Remove unused local
	variable `bytes_written'.
	* aout-ns32k.c (MY_swap_std_reloc_out): Remove unused local
	variable `r_addend'.
	* elf32-dlx.c (dlx_rtype_to_howto): Remove breaks after returns.
	* elfxx-mips.c (_bfd_elf_mips_mach): Remove breaks after returns.
	(_bfd_ns32k_relocate_contents): Remove break after return.
	* elf.c (bfd_section_from_shdr): Remove breaks after returns.
@
text
@d462 19
d734 1
a734 3
	  if (i_shdrp[shindex].sh_link >= num_sec
	      || (i_shdrp[shindex].sh_link >= SHN_LORESERVE
		  && i_shdrp[shindex].sh_link <= SHN_HIRESERVE))
d740 1
a740 3
	      && (i_shdrp[shindex].sh_info >= num_sec
		  || (i_shdrp[shindex].sh_info >= SHN_LORESERVE
		      && i_shdrp[shindex].sh_info <= SHN_HIRESERVE)))
d758 1
a758 3
      if (i_ehdrp->e_shstrndx >= elf_numsections (abfd)
	  || (i_ehdrp->e_shstrndx >= SHN_LORESERVE
	      && i_ehdrp->e_shstrndx <= SHN_HIRESERVE))
@


1.75
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d1353 1
a1353 2
	  asymbol **ps, *s;

a1354 1
	  s = *ps;
@


1.74
log
@PR 2257
* elfcode.h (elf_object_p): Allow files with corrupt e_shstrndx fields to
  still be handled as ELF files.
* readelf.c (SECTION_NAME): Cope with a missing string table.
  (process_file_header): Cope with a corrupt e_shstrndx field.
  (process_section_headers): Correctly handle an e_shstrndx value of SHF_UNDEF.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d142 1
a142 1
#ifdef DEBUG
d144 2
a146 1
static char *elf_symbol_flags (flagword);
d549 1
a549 1
  /* As a simple sanity check, verify that the what BFD thinks is the
d1454 1
a1454 1
#ifdef DEBUG
d1480 1
d1482 1
a1493 71

static char *
elf_symbol_flags (flagword flags)
{
  static char buffer[1024];

  buffer[0] = '\0';
  if (flags & BSF_LOCAL)
    strcat (buffer, " local");

  if (flags & BSF_GLOBAL)
    strcat (buffer, " global");

  if (flags & BSF_DEBUGGING)
    strcat (buffer, " debug");

  if (flags & BSF_FUNCTION)
    strcat (buffer, " function");

  if (flags & BSF_KEEP)
    strcat (buffer, " keep");

  if (flags & BSF_KEEP_G)
    strcat (buffer, " keep_g");

  if (flags & BSF_WEAK)
    strcat (buffer, " weak");

  if (flags & BSF_SECTION_SYM)
    strcat (buffer, " section-sym");

  if (flags & BSF_OLD_COMMON)
    strcat (buffer, " old-common");

  if (flags & BSF_NOT_AT_END)
    strcat (buffer, " not-at-end");

  if (flags & BSF_CONSTRUCTOR)
    strcat (buffer, " constructor");

  if (flags & BSF_WARNING)
    strcat (buffer, " warning");

  if (flags & BSF_INDIRECT)
    strcat (buffer, " indirect");

  if (flags & BSF_FILE)
    strcat (buffer, " file");

  if (flags & DYNAMIC)
    strcat (buffer, " dynamic");

  if (flags & ~(BSF_LOCAL
		| BSF_GLOBAL
		| BSF_DEBUGGING
		| BSF_FUNCTION
		| BSF_KEEP
		| BSF_KEEP_G
		| BSF_WEAK
		| BSF_SECTION_SYM
		| BSF_OLD_COMMON
		| BSF_NOT_AT_END
		| BSF_CONSTRUCTOR
		| BSF_WARNING
		| BSF_INDIRECT
		| BSF_FILE
		| BSF_DYNAMIC))
    strcat (buffer, " unknown-bits");

  return buffer;
}
@


1.73
log
@	* elfcode.h (elf_object_p): Delay the setting of start_address
	until we're sure the backend matches the binary.
@
text
@d745 10
a754 1
	goto got_wrong_format_error;
d756 1
a756 1
  else if (i_ehdrp->e_shstrndx != 0)
@


1.73.6.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a460 19
/* Determines if a given section index is valid.  */

static inline bfd_boolean
valid_section_index_p (unsigned index, unsigned num_sections)
{
  /* Note: We allow SHN_UNDEF as a valid section index.  */
  if (index < SHN_LORESERVE || index > SHN_HIRESERVE)
    return index < num_sections;
  
  /* We disallow the use of reserved indcies, except for those
     with OS or Application specific meaning.  The test make use
     of the knowledge that:
       SHN_LORESERVE == SHN_LOPROC
     and
       SHN_HIPROC == SHN_LOOS - 1  */
  /* XXX - Should we allow SHN_XINDEX as a valid index here ?  */
  return (index >= SHN_LOPROC && index <= SHN_HIOS);
}

d548 1
a548 1
  /* As a simple sanity check, verify that what BFD thinks is the
d714 3
a716 1
	  if (! valid_section_index_p (i_shdrp[shindex].sh_link, num_sec))
d722 3
a724 1
	      && ! valid_section_index_p (i_shdrp[shindex].sh_info, num_sec))
d742 4
a745 11
      if (! valid_section_index_p (i_ehdrp->e_shstrndx, elf_numsections (abfd)))
	{
	  /* PR 2257:
	     We used to just goto got_wrong_format_error here
	     but there are binaries in existance for which this test
	     will prevent the binutils from working with them at all.
	     So we are kind, and reset the string index value to 0
	     so that at least some processing can be done.  */
	  i_ehdrp->e_shstrndx = SHN_UNDEF;
	  _bfd_error_handler (_("warning: %s has a corrupt string table index - ignoring"), abfd->filename);
	}
d747 1
a747 1
  else if (i_ehdrp->e_shstrndx != SHN_UNDEF)
d1343 1
a1343 1
	  asymbol **ps;
d1346 1
@


1.73.12.1
log
@Apply patches for ld/2607 and ld/2257
@
text
@a460 19
/* Determines if a given section index is valid.  */

static inline bfd_boolean
valid_section_index_p (unsigned index, unsigned num_sections)
{
  /* Note: We allow SHN_UNDEF as a valid section index.  */
  if (index < SHN_LORESERVE || index > SHN_HIRESERVE)
    return index < num_sections;
  
  /* We disallow the use of reserved indcies, except for those
     with OS or Application specific meaning.  The test make use
     of the knowledge that:
       SHN_LORESERVE == SHN_LOPROC
     and
       SHN_HIPROC == SHN_LOOS - 1  */
  /* XXX - Should we allow SHN_XINDEX as a valid index here ?  */
  return (index >= SHN_LOPROC && index <= SHN_HIOS);
}

d548 1
a548 1
  /* As a simple sanity check, verify that what BFD thinks is the
d714 3
a716 1
	  if (! valid_section_index_p (i_shdrp[shindex].sh_link, num_sec))
d722 3
a724 1
	      && ! valid_section_index_p (i_shdrp[shindex].sh_info, num_sec))
d742 4
a745 11
      if (! valid_section_index_p (i_ehdrp->e_shstrndx, elf_numsections (abfd)))
	{
	  /* PR 2257:
	     We used to just goto got_wrong_format_error here
	     but there are binaries in existance for which this test
	     will prevent the binutils from working with them at all.
	     So we are kind, and reset the string index value to 0
	     so that at least some processing can be done.  */
	  i_ehdrp->e_shstrndx = SHN_UNDEF;
	  _bfd_error_handler (_("warning: %s has a corrupt string table index - ignoring"), abfd->filename);
	}
d747 1
a747 1
  else if (i_ehdrp->e_shstrndx != SHN_UNDEF)
d1343 1
a1343 1
	  asymbol **ps;
d1346 1
@


1.72
log
@2005-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1321
	* elf-bfd.h (_bfd_elf_setup_group_pointers): Renamed to ...
	(_bfd_elf_setup_sections): This.
	* elf.c: Likewise.
	* elfcode.h (elf_object_p): Likewise.

	* elf.c (_bfd_elf_setup_sections): Process SHF_LINK_ORDER.
	(_bfd_elf_copy_private_section_data): Likewise.
@
text
@a609 3
  /* Remember the entry point specified in the ELF file header.  */
  bfd_set_start_address (abfd, i_ehdrp->e_entry);

d804 3
@


1.71
log
@	* elfcode.h (elf_write_relocs): Do nothing if there are no
	relocations.
@
text
@d794 2
a795 2
      /* Set up group pointers.  */
      if (! _bfd_elf_setup_group_pointers (abfd))
@


1.70
log
@Fix for IA-64 gdb backtrace of threads in syscalls, reported by Jeff Johnson.
* elfcode.h (NAME(bfd_elf,bfd_from_remote_memory)): Check for program
header PF_R flag on PT_LOAD segments.
@
text
@d878 6
@


1.69
log
@	* elfcode.h (elf_object_p): Fail if e_shoff != 0, e_shnum == 0 and
	first shdr has sh_size == 0.  Fail if e_shnum is large to cause
	arithmetic overflow when allocating the i_shdr array.
	Sanity check sh_link and sh_info fields.  Fix e_shstrndx sanity check.
@
text
@d1659 4
a1662 1
      if (i_phdrs[i].p_type == PT_LOAD)
d1709 4
a1712 1
    if (i_phdrs[i].p_type == PT_LOAD)
@


1.68
log
@	* elfcode.h (elf_object_p): Add more sanity checks on elf header.
@
text
@d635 2
a636 1
	  if (i_ehdrp->e_shnum != i_shdr.sh_size)
d653 2
a654 1
	  if (i_ehdrp->e_shnum > (unsigned int) -1 / sizeof (x_shdr))
a674 4
  /* A further sanity check.  */
  if (i_ehdrp->e_shstrndx >= i_ehdrp->e_shnum)
    goto got_wrong_format_error;

d716 14
d742 11
@


1.67
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d36 1
a36 1
        the object file.  I.E. there is a "section_count" variable in the
d615 5
d621 1
a621 1
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
d633 5
a637 1
	i_ehdrp->e_shnum = i_shdr.sh_size;
d641 30
a670 1
	i_ehdrp->e_shstrndx = i_shdr.sh_link;
d673 4
d1087 1
a1087 1
             since that is more helpful than just quitting.  */
d1152 1
a1152 1
             already section relative.  */
@


1.66
log
@Update the FSF address in the copyright/GPL notice
@
text
@d31 1
a31 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.65
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@d31 1
a31 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.64
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1072 1
a1072 1
	  sym->symbol.name = bfd_elf_sym_name (abfd, hdr, isym);
@


1.64.2.1
log
@	Backport from mainline:
	2005-05-29  Jakub Jelinek  <jakub@@redhat.com>
	* elfcode.h (elf_object_p): Fail if e_shoff != 0, e_shnum == 0 and
	first shdr has sh_size == 0.  Fail if e_shnum is large to cause
	arithmetic overflow when allocating the i_shdr array.
	Sanity check sh_link and sh_info fields.  Fix e_shstrndx sanity check.

	2005-05-18  H.J. Lu  <hongjiu.lu@@intel.com>
	* elf.c (group_signature): Undo the last change. Check if the
	symbol table section is correct.

	2005-05-17  Nick Clifton  <nickc@@redhat.com>
	* elf.c (group_signature): Check for a group section which is
	actually a (corrupt) symbol table section in disguise and prevent
	an infinite loop from occurring.

	2005-05-17  Tavis Ormandy <taviso@@gentoo.org>
	* elf.c (bfd_section_from_shdr): Add sanity check when parsing
	dynamic sections.

	2005-05-09  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_object_p): Add more sanity checks on elf header.
@
text
@d36 1
a36 1
	the object file.  I.E. there is a "section_count" variable in the
a614 5
      bfd_signed_vma where = i_ehdrp->e_shoff;

      if (where != (file_ptr) where)
	goto got_wrong_format_error;

d616 1
a616 1
      if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
d628 1
a628 6
	{
	  i_ehdrp->e_shnum = i_shdr.sh_size;
	  if (i_ehdrp->e_shnum != i_shdr.sh_size
	      || i_ehdrp->e_shnum == 0)
	    goto got_wrong_format_error;
	}
d632 1
a632 31
	{
	  i_ehdrp->e_shstrndx = i_shdr.sh_link;
	  if (i_ehdrp->e_shstrndx != i_shdr.sh_link)
	    goto got_wrong_format_error;
	}

      /* Sanity check that we can read all of the section headers.
	 It ought to be good enough to just read the last one.  */
      if (i_ehdrp->e_shnum != 1)
	{
	  /* Check that we don't have a totally silly number of sections.  */
	  if (i_ehdrp->e_shnum > (unsigned int) -1 / sizeof (x_shdr)
	      || i_ehdrp->e_shnum > (unsigned int) -1 / sizeof (i_shdr))
	    goto got_wrong_format_error;

	  where += (i_ehdrp->e_shnum - 1) * sizeof (x_shdr);
	  if (where != (file_ptr) where)
	    goto got_wrong_format_error;
	  if ((bfd_size_type) where <= i_ehdrp->e_shoff)
	    goto got_wrong_format_error;

	  if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
	    goto got_no_match;
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	    goto got_no_match;

	  /* Back to where we were.  */
	  where = i_ehdrp->e_shoff + sizeof (x_shdr);
	  if (bfd_seek (abfd, (file_ptr) where, SEEK_SET) != 0)
	    goto got_no_match;
	}
a675 14
	  /* Sanity check sh_link and sh_info.  */
	  if (i_shdrp[shindex].sh_link >= num_sec
	      || (i_shdrp[shindex].sh_link >= SHN_LORESERVE
		  && i_shdrp[shindex].sh_link <= SHN_HIRESERVE))
	    goto got_wrong_format_error;

	  if (((i_shdrp[shindex].sh_flags & SHF_INFO_LINK)
	       || i_shdrp[shindex].sh_type == SHT_RELA
	       || i_shdrp[shindex].sh_type == SHT_REL)
	      && (i_shdrp[shindex].sh_info >= num_sec
		  || (i_shdrp[shindex].sh_info >= SHN_LORESERVE
		      && i_shdrp[shindex].sh_info <= SHN_HIRESERVE)))
	    goto got_wrong_format_error;

a687 11
  /* A further sanity check.  */
  if (i_ehdrp->e_shnum != 0)
    {
      if (i_ehdrp->e_shstrndx >= elf_numsections (abfd)
	  || (i_ehdrp->e_shstrndx >= SHN_LORESERVE
	      && i_ehdrp->e_shstrndx <= SHN_HIRESERVE))
	goto got_wrong_format_error;
    }
  else if (i_ehdrp->e_shstrndx != 0)
    goto got_wrong_format_error;

d1045 1
a1045 1
	     since that is more helpful than just quitting.  */
d1110 1
a1110 1
	     already section relative.  */
@


1.63
log
@	* elf-bfd.h (elf_string_from_elf_strtab): Delete macro.
	* elf.c (bfd_elf_string_from_elf_section): Expand occurrence of
	elf_string_from_elf_strtab.
	(_bfd_elf_setup_group_pointers, bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): For SHT_SYMTAB, load SHT_SYMTAB_SHNDX too
	if it exists.  Don't do the reverse for SHT_SYMTAB_SHNDX.  For
	SHT_STRTAB, check whether the strtab is for symtab or dynsymtab by
	looking at cached symtab info first, before iterating over headers.
	For SHT_REL and SHT_RELA, load dynsymtab if needed.
	* elfcode.h (elf_object_p): Don't load section header stringtab
@
text
@d1502 1
a1502 1
   int (*target_read_memory) (bfd_vma, char *, int))
d1511 1
a1511 1
  char *contents;
d1517 1
a1517 1
  err = target_read_memory (ehdr_vma, (char *) &x_ehdr, sizeof x_ehdr);
d1577 1
a1577 1
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (char *) x_phdrs,
@


1.62
log
@	* elf-bfd.h (struct elf_backend_data): Add minpagesize.
	* elf32-arm.c (ELF_MINPAGESIZE): Define.
	* elf32-ppc.c (ELF_MINPAGESIZE): Define.
	* elfcode.h (elf_object_p): Use minpagesize instead of
	maxpagesize.
	* elfxx-target.h (ELF_MINPAGESIZE): Default to ELF_MAXPAGESIZE.
	(elfNN_bed): Include ELF_MINPAGESIZE.
@
text
@a477 1
  char *shstrtab;		/* Internal copy of section header stringtab */
a687 6
  if (i_ehdrp->e_shstrndx && i_ehdrp->e_shoff)
    {
      if (! bfd_section_from_shdr (abfd, i_ehdrp->e_shstrndx))
	goto got_no_match;
    }

d713 1
a713 7
  /* Read in the string table containing the names of the sections.  We
     will need the base pointer to this table later.  */
  /* We read this inline now, so that we don't have to go through
     bfd_section_from_shdr with it (since this particular strtab is
     used to find all of the ELF section names.) */

  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff)
a716 4
      shstrtab = bfd_elf_get_str_section (abfd, i_ehdrp->e_shstrndx);
      if (!shstrtab)
	goto got_no_match;

@


1.61
log
@bfd/
	* elfcode.h (elf_slurp_symbol_table): Use bfd_elf_sym_name so that
	canonical sections syms have a name.

gas/testsuite/
	Update for changed section syms.

ld/testsuite/
	Update for changed section syms.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d683 1
a683 1
		   % ebd->maxpagesize)
@


1.60
log
@	* elfcode.h (elf_slurp_reloc_table_from_section): Don't canonicalize
	ELF section symbols.
@
text
@d1089 1
a1089 3
	  sym->symbol.name = bfd_elf_string_from_elf_section (abfd,
							      hdr->sh_link,
							      isym->st_name);
d1218 1
a1218 1
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
@


1.59
log
@2004-11-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 574:
	* elfcode.h (elf_slurp_symbol_table): Handle STT_TLS.
@
text
@d1296 1
a1296 5
	  /* Canonicalize ELF section symbols.  FIXME: Why?  */
	  if ((s->flags & BSF_SECTION_SYM) == 0)
	    relent->sym_ptr_ptr = ps;
	  else
	    relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
@


1.58
log
@bfd/
	* elf-bfd.h (_bfd_elf_slurp_version_tables): Update prototype.
	* elf.c (_bfd_elf_print_private_bfd_data): Pass extra argument.
	(_bfd_elf_slurp_version_tables): Add extra argument.  Create extra
	default version definition for unversioned symbols.
	* elfcode.h (elf_slurp_symbol_table): Pass extra argument.
	* elflink.c (elf_link_add_object_symbols): Pass extra argument to
	_bfd_elf_slurp_version_tables.  Set default version for unversioned
	imported symbols.
include/
	* bfdlink.h (bfd_link_info): Add default_imported_symver.
ld/
	* ld.texinfo: Document --default-imported-symver.
	* ldmain.c (main): Set link_info.default_imported_symver.
	* lexsup.c (option_values): Add OPTION_DEFAULT_IMPORTED_SYMVER.
	(ld_options): Add --default-imported-symver.
	(parse_args): Handle OPTION_DEFAULT_IMPORTED_SYMVER.
@
text
@d1161 3
@


1.57
log
@2004-07-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 161/251
	* elf-bfd.h (bfd_elf_section_data): Add sec_group.
	(elf_sec_group): Defined.
	(bfd_elf_match_symbols_in_sections): New prototype.
	(_bfd_elf_setup_group_pointers): Likewise.

	* elf.c (bfd_elf_discard_group): Abort.
	(bfd_elf_set_group_contents): Also include relocation sections.
	Remove zero-fill for ld -r.
	(_bfd_elf_setup_group_pointers): New function.
	(elf_sort_elf_symbol): Likewise.
	(elf_sym_name_compare): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elfcode.h (elf_object_p): Call _bfd_elf_setup_group_pointers.

	* elflink.c (match_group_member): New.
	(elf_link_input_bfd): Check group member for discarded section.
	(try_match_symbols_in_sections): New function.
	(already_linked): Likewise.
	(_bfd_elf_section_already_linked): Support mixing comdat group
	and linkonce section.

	* libbfd-in.h (bfd_section_already_linked_table_traverse): New.
	* linker.c (bfd_section_already_linked_table_traverse): New.

	* libbfd.h: Regenerated.
@
text
@d1029 1
a1029 1
	  if (! _bfd_elf_slurp_version_tables (abfd))
@


1.56
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d745 4
@


1.55
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d1358 1
a1358 1
      if (asect->_raw_size == 0)
@


1.54
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d108 2
@


1.53
log
@	* elf-bfd.h (struct elf_reloc_cookie): Add r_sym_shift field.
	* elflink.h: Replace all occurrences of sizeof (Elf_External_*)
	where Elf_External_* is different for 64 and 32 bit, with
	corresponding elf_size_info field.
	(struct elf_final_link_info): Use "bfd_byte *" instead
	of "Elf_External_Sym *" for external_syms and symbuf.
	(elf_link_adjust_relocs): Set up r_type_mask and r_sym_shift local
	vars and use instead of ELF_R_INFO and ELF_R_TYPE macros.
	(struct elf_link_sort_rela): Add "sym_mask" alias for "offset".
	(elf_link_sort_cmp1): Use sym_mask field instead of ELF_R_SYM.
	(elf_link_sort_cmp2): Adjust.
	(elf_link_sort_relocs): Set up r_sym_mask local var instead of
	using ELF_R_SYM macro.  Set u.sym_mask.
	(elf_bfd_final_link): Call _bfd_elf_stringtab_init instead of macro
	version, elf_stringtab_init.  Ditto for bfd_section_from_elf_index
	vs. section_from_elf_index.  Adjust Elf_External_Sym pointer
	arithmetic.  Pass bed to elf_link_flush_output_syms.  Adjust
	Elf_External_Dyn pointer arithmentic.  Use bed swap_dyn_in and
	swap_syn_out functions.  Rearrange dyn swap in/out switch.
	(elf_link_output_sym): Adjust Elf_External_Sym pointer arithmentic.
	Pass bed to elf_link_flush_output_syms.  Use bed swap_symbol_out.
	(elf_link_flush_output_syms): Add elf_backend_data arg.
	(elf_link_check_versioned_symbol): Likewise.
	(elf_link_output_extsym): Pass bed to elf_link_check_versioned_symbol.
	Adjust Elf_External_Sym pointer arithmetic.  Use bed swap_symbol_out.
	(elf_link_input_bfd): Use bfd_section_from_elf_index.  Set up
	r_type_mask and r_sym_shift local vars and use instead of ELF_R_SYM,
	ELF_R_TYPE and ELF_R_INFO macros.
	(elf_reloc_link_order): Select ELF32_R_INFO or ELF64_R_INFO invocation
	based on size rather than using ELF_R_INFO.
	(elf_gc_mark): Set up r_sym_shift local var and use instead of
	ELF_R_SYM macro.
	(struct alloc_got_off_arg): New.
	(elf_gc_common_finalize_got_offsets): Use elf_size_info instead of
	ARCH_SIZE.  Pass get entry size down to elf_gc_allocate_got_offsets.
	(elf_gc_allocate_got_offsets): Adjust.
	(elf_reloc_symbol_deleted_p): Usee cookie.r_sym_shift instead of
	ELF_R_SYM.  Use bfd_section_from_elf_index.
	(elf_bfd_discard_info): Set cookie.r_sym_shift.
	* elfcode.h (elf_stringtab_init, section_from_elf_index): Delete.
	(elf_slurp_symbol_table): Use bfd_section_from_elf_index.
@
text
@a121 12
#define elf_bfd_discard_info		NAME(bfd_elf,discard_info)
#define elf_reloc_symbol_deleted_p	NAME(_bfd_elf,reloc_symbol_deleted_p)
#define elf_link_record_dynamic_symbol  _bfd_elf_link_record_dynamic_symbol
#define elf_bfd_final_link		NAME(bfd_elf,bfd_final_link)
#define elf_gc_sections			NAME(_bfd_elf,gc_sections)
#define elf_gc_common_finalize_got_offsets \
  NAME(_bfd_elf,gc_common_finalize_got_offsets)
#define elf_gc_common_final_link	NAME(_bfd_elf,gc_common_final_link)
#define elf_gc_record_vtinherit		NAME(_bfd_elf,gc_record_vtinherit)
#define elf_gc_record_vtentry		NAME(_bfd_elf,gc_record_vtentry)
#define elf_link_record_local_dynamic_symbol \
  NAME(_bfd_elf,link_record_local_dynamic_symbol)
a1721 1
#include "elflink.h"
@


1.52
log
@	* elfxx-target.h (bfd_elfNN_bfd_link_add_symbols): Define.
	* elf-bfd.h (_bfd_elf_link_add_archive_symbols): Delete.
	(_bfd_elf_sort_symbol, _bfd_elf_add_dt_needed_tag): Delete.
	(_bfd_elf_finalize_dynstr, bfd_elf32_bfd_link_add_symbols): Delete.
	(bfd_elf64_bfd_link_add_symbols): Delete.
	(bfd_elf_link_add_symbols): Declare.
	* elfcode.h (elf_bfd_link_add_symbols): Delete.
	* elflink.c: Include safe-ctype.h.
	(elf_add_dt_needed_tag): Rename from _bfd_elf_add_dt_needed_tag,
	make static.
	(elf_sort_symbol): Rename from _bfd_elf_sort_symbol, make static.
	(elf_finalize_dynstr): Rename from _bfd_elf_finalize_dynstr, make
	static.
	(elf_link_add_archive_symbols): Rename from
	_bfd_elf_link_add_archive_symbols, make static.
	(elf_link_add_object_symbols): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(bfd_elf_link_add_symbols): Likewise.
	(bfd_elf_size_dynamic_sections): Adjust.
	* elflink.h (elf_bfd_link_add_symbols): Delete.
	(elf_link_add_object_symbols): Delete.
	* elf32-gen.c (elf32_generic_link_add_symbols): Call
	bfd_elf_link_add_symbols.
	* elf64-gen.c (elf64_generic_link_add_symbols): Likewise.
@
text
@a151 4
#define elf_stringtab_init _bfd_elf_stringtab_init

#define section_from_elf_index bfd_section_from_elf_index

d1108 2
a1109 2
	      sym->symbol.section = section_from_elf_index (abfd,
							    isym->st_shndx);
@


1.51
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@a117 1
#define elf_bfd_link_add_symbols	NAME(bfd_elf,bfd_link_add_symbols)
@


1.50
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@a118 1
#define elf_add_dynamic_entry		NAME(bfd_elf,add_dynamic_entry)
@


1.50.6.1
log
@Merge from mainline
@
text
@d118 2
d124 12
d154 4
d1114 2
a1115 2
	      sym->symbol.section = bfd_section_from_elf_index (abfd,
								isym->st_shndx);
d1740 1
@


1.50.8.1
log
@Merge mainline to intercu branch.
@
text
@d118 2
@


1.50.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d122 12
d152 4
d1112 2
a1113 2
	      sym->symbol.section = bfd_section_from_elf_index (abfd,
								isym->st_shndx);
d1738 1
@


1.50.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a107 2
#define elf_get_synthetic_symtab \
  NAME(bfd_elf,get_synthetic_symtab)
a742 4

      /* Set up group pointers.  */
      if (! _bfd_elf_setup_group_pointers (abfd))
	goto got_wrong_format_error;
d1356 1
a1356 1
      if (asect->size == 0)
@


1.49
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d105 1
a105 1
#define elf_get_symtab			NAME(bfd_elf,get_symtab)
@


1.48
log
@	* elf-bfd.h: Remove PARAMS macro.  Replace PTR with void *.
	(NAME): Use ## rather than CONCAT4 macro.
	* elfcode.h: Remove one remaining PARAMS macro.
	* elf-eh-frame.c: Convert to C90, remove unneeded casts and prototypes.
	* elf-strtab.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf32-hppa.h: Likewise.
	* elf32-hppa.c: Likewise.
	(elf32_hppa_add_symbol_hook): Delete.
	(elf_backend_add_symbol_hook): Don't define.
	* libhppa.h: Convert to C90.  Replace INLINE with inline.
@
text
@d495 1
a495 1
  struct elf_backend_data *ebd;
d594 1
a594 1
	  struct elf_backend_data *back;
d598 1
a598 1
	  back = (struct elf_backend_data *) (*target_ptr)->backend_data;
d1011 1
a1011 1
  struct elf_backend_data *ebd;
d1241 1
a1241 1
  struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
@


1.47
log
@	* elfcode.h: Convert to C90, remove unneeded casts and prototypes.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf.c (sym_is_global): Remove INLINE.
	(align_file_position): Replace INLINE with inline.
	* elfcode.h (elf_swap_dyn_in, elf_swap_dyn_out): Remove INLINE.
	(elf_file_p): Replace INLINE with inline.
@
text
@d821 1
a821 1
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
@


1.46
log
@	* elfcode.h (elf_object_p): Allocate tdata via _bfd_set_format.
	* elfcore.h (elf_core_file_p): Likewise.
	* section.c (bfd_section_init): Remove prototype.
@
text
@a153 11
/* Static functions */

static void elf_swap_ehdr_in
  PARAMS ((bfd *, const Elf_External_Ehdr *, Elf_Internal_Ehdr *));
static void elf_swap_ehdr_out
  PARAMS ((bfd *, const Elf_Internal_Ehdr *, Elf_External_Ehdr *));
static void elf_swap_shdr_in
  PARAMS ((bfd *, const Elf_External_Shdr *, Elf_Internal_Shdr *));
static void elf_swap_shdr_out
  PARAMS ((bfd *, const Elf_Internal_Shdr *, Elf_External_Shdr *));

a157 6
static bfd_boolean elf_slurp_reloc_table_from_section
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));

static bfd_boolean elf_file_p PARAMS ((Elf_External_Ehdr *));

d159 3
a161 3
static void elf_debug_section PARAMS ((int, Elf_Internal_Shdr *));
static void elf_debug_file PARAMS ((Elf_Internal_Ehdr *));
static char *elf_symbol_flags PARAMS ((flagword));
d185 4
a188 5
elf_swap_symbol_in (abfd, psrc, pshn, dst)
     bfd *abfd;
     const PTR psrc;
     const PTR pshn;
     Elf_Internal_Sym *dst;
d190 2
a191 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
d215 4
a218 5
elf_swap_symbol_out (abfd, src, cdst, shndx)
     bfd *abfd;
     const Elf_Internal_Sym *src;
     PTR cdst;
     PTR shndx;
d221 1
a221 1
  Elf_External_Sym *dst = (Elf_External_Sym *) cdst;
d242 3
a244 4
elf_swap_ehdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Ehdr *src;
     Elf_Internal_Ehdr *dst;
d270 3
a272 4
elf_swap_ehdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Ehdr *src;
     Elf_External_Ehdr *dst;
d306 3
a308 4
elf_swap_shdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Shdr *src;
     Elf_Internal_Shdr *dst;
d333 3
a335 4
elf_swap_shdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Shdr *src;
     Elf_External_Shdr *dst;
d354 3
a356 4
elf_swap_phdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Phdr *src;
     Elf_Internal_Phdr *dst;
d379 3
a381 4
elf_swap_phdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Phdr *src;
     Elf_External_Phdr *dst;
d396 3
a398 4
elf_swap_reloc_in (abfd, s, dst)
     bfd *abfd;
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
d407 3
a409 4
elf_swap_reloca_in (abfd, s, dst)
     bfd *abfd;
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
d419 3
a421 4
elf_swap_reloc_out (abfd, src, d)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *d;
d429 3
a431 4
elf_swap_reloca_out (abfd, src, d)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *d;
d439 4
a442 5
INLINE void
elf_swap_dyn_in (abfd, p, dst)
     bfd *abfd;
     const PTR p;
     Elf_Internal_Dyn *dst;
d444 1
a444 1
  const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;
d450 4
a453 5
INLINE void
elf_swap_dyn_out (abfd, src, p)
     bfd *abfd;
     const Elf_Internal_Dyn *src;
     PTR p;
d455 1
a455 1
  Elf_External_Dyn *dst = (Elf_External_Dyn *) p;
d468 2
a469 3
static INLINE bfd_boolean
elf_file_p (x_ehdrp)
     Elf_External_Ehdr *x_ehdrp;
d486 1
a486 2
elf_object_p (abfd)
     bfd *abfd;
d504 1
a504 2
  if (bfd_bread ((PTR) & x_ehdr, (bfd_size_type) sizeof (x_ehdr), abfd)
      != sizeof (x_ehdr))
d638 1
a638 2
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
d660 1
a660 1
      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d668 1
a668 1
      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
d689 1
a689 2
	  if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	      != sizeof (x_shdr))
d720 1
a720 1
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d730 1
a730 2
	  if (bfd_bread ((PTR) &x_phdr, (bfd_size_type) sizeof x_phdr, abfd)
	      != sizeof x_phdr)
d816 1
a816 4
elf_write_relocs (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d818 1
a818 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d845 1
a845 1
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
d923 3
a925 4
elf_write_out_phdrs (abfd, phdr, count)
     bfd *abfd;
     const Elf_Internal_Phdr *phdr;
     unsigned int count;
d931 2
a932 2
      if (bfd_bwrite (&extphdr, (bfd_size_type) sizeof (Elf_External_Phdr),
		     abfd) != sizeof (Elf_External_Phdr))
d942 1
a942 2
elf_write_shdrs_and_ehdr (abfd)
     bfd *abfd;
d962 1
a962 1
      || bfd_bwrite ((PTR) & x_ehdr, amt, abfd) != amt)
d975 1
a975 1
  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);
d990 1
a990 1
      || bfd_bwrite ((PTR) x_shdrp, amt, abfd) != amt)
d999 1
a999 4
elf_slurp_symbol_table (abfd, symptrs, dynamic)
     bfd *abfd;
     asymbol **symptrs;		/* Buffer for generated bfd symbols */
     bfd_boolean dynamic;
d1059 1
a1059 1
      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d1083 1
a1083 1
	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
d1087 1
a1087 2
	  if (bfd_bread ((PTR) xverbuf, verhdr->sh_size, abfd)
	      != verhdr->sh_size)
d1233 7
a1239 9
elf_slurp_reloc_table_from_section (abfd, asect, rel_hdr, reloc_count,
				    relents, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
     asymbol **symbols;
     bfd_boolean dynamic;
d1242 1
a1242 1
  PTR allocated = NULL;
d1249 1
a1249 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d1258 1
a1258 1
  native_relocs = (bfd_byte *) allocated;
d1336 4
a1339 5
elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     bfd_boolean dynamic;
d1384 1
a1384 1
  relents = (arelent *) bfd_alloc (abfd, amt);
d1407 1
a1407 3
elf_debug_section (num, hdr)
     int num;
     Elf_Internal_Shdr *hdr;
d1433 1
a1433 2
elf_debug_file (ehdrp)
     Elf_Internal_Ehdr *ehdrp;
d1445 1
a1445 2
elf_symbol_flags (flags)
     flagword flags;
d1530 5
a1534 6
NAME(_bfd_elf,bfd_from_remote_memory) (templ, ehdr_vma, loadbasep,
				       target_read_memory)
     bfd *templ;
     bfd_vma ehdr_vma;
     bfd_vma *loadbasep;
     int (*target_read_memory) PARAMS ((bfd_vma vma, char *myaddr, int len));
d1603 1
a1603 2
  x_phdrs = (Elf_External_Phdr *)
    bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
d1664 1
a1664 1
  contents = (char *) bfd_zmalloc ((bfd_size_type) contents_size);
d1709 1
a1709 2
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
d1728 1
a1728 1
  nbfd->iostream = (PTR) bim;
@


1.45
log
@	* elf-bfd.h (_bfd_elf_create_linker_section) Don't declare.
	(_bfd_elf_find_pointer_linker_section): Likewise.
	(bfd_elf32_create_pointer_linker_section): Likewise.
	(bfd_elf32_finish_pointer_linker_section): Likewise.
	(bfd_elf64_create_pointer_linker_section): Likewise.
	(bfd_elf64_finish_pointer_linker_section): Likewise.
	(_bfd_elf_make_linker_section_rela): Likewise.
	* elfcode.h (elf_create_pointer_linker_section): Don't define.
	(elf_finish_pointer_linker_section): Likewise.
	* elflink.c (_bfd_elf_make_linker_section_rela): Delete.
	(_bfd_elf_create_linker_section): Move this function..
	(_bfd_elf_find_pointer_linker_section): ..and this..
	* elflink.h (elf_create_pointer_linker_section): ..and this..
	(elf_finish_pointer_linker_section): ..and this..
	* elf32-ppc.c: ..to here, renaming to the following, and adjusting
	calls.
	(elf_create_linker_section): Convert to C90, tidy.
	(elf_find_pointer_linker_section): Likewise.
	(elf_create_pointer_linker_section): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	* elf32-i370.c: Delete #if 0 code.
@
text
@d573 3
d579 1
a579 3
  amt = sizeof (struct elf_obj_tdata);
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
d581 1
a581 4
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

  elf_tdata (abfd) = preserve.marker;
@


1.44
log
@Correct spelling of "relocatable".
@
text
@a127 2
#define elf_create_pointer_linker_section NAME(bfd_elf,create_pointer_linker_section)
#define elf_finish_pointer_linker_section NAME(bfd_elf,finish_pointer_linker_section)
@


1.43
log
@	* elfcode.h (elf_slurp_reloc_table_from_section): Don't dereference
	NULL function pointers.
@
text
@d1190 1
a1190 1
	  /* If this is a relocateable file, then the symbol value is
@


1.42
log
@2003-05-19  Roland McGrath  <roland@@redhat.com>

	* elf.c (bfd_elf_bfd_from_remote_memory): New function.
	* bfd-in.h: Declare it.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): New function.
	* elf-bfd.h (struct elf_backend_data): New function pointer member
	elf_backend_bfd_from_remote_memory.
	(_bfd_elf32_bfd_from_remote_memory, _bfd_elf64_bfd_from_remote_memory):
	Declare them.
	* elfxx-target.h (elf_backend_bfd_from_remote_memory): New macro.
	(elfNN_bed): Add that to the initializer.
@
text
@d1366 3
a1368 1
      if (entsize == sizeof (Elf_External_Rela))
@


1.41
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1571 226
@


1.40
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
a123 2
#define elf_link_create_dynamic_sections \
  NAME(bfd_elf,link_create_dynamic_sections)
d1586 1
a1586 1
  ARCH_SIZE, FILE_ALIGN,
@


1.40.22.1
log
@	* elfcode.h (elf_slurp_reloc_table_from_section): Don't dereference
	NULL function pointers.
@
text
@d1368 1
a1368 3
      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
@


1.40.22.2
log
@	* elfcode.h (elf_object_p): Allocate tdata via _bfd_set_format.
	* elfcore.h (elf_core_file_p): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a576 3
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

d580 3
a582 1
  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
d584 4
a587 1
  preserve.marker = elf_tdata (abfd);
@


1.40.20.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d124 2
d1588 1
a1588 1
  ARCH_SIZE, LOG_FILE_ALIGN,
@


1.39
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d173 1
a173 1
static boolean elf_slurp_reloc_table_from_section
d175 1
a175 1
	   arelent *, asymbol **, boolean));
d177 1
a177 1
static boolean elf_file_p PARAMS ((Elf_External_Ehdr *));
d503 1
a503 1
static INLINE boolean
d864 1
a864 1
  boolean *failedp = (boolean *) data;
d894 1
a894 1
      *failedp = true;
d945 1
a945 1
	      *failedp = true;
d955 1
a955 1
	  *failedp = true;
d988 1
a988 1
boolean
d1011 1
a1011 1
    return false;
d1025 1
a1025 1
    return false;
d1033 1
a1033 1
      
d1039 1
a1039 1
    return false;
d1043 1
a1043 1
  return true;
d1050 1
a1050 1
     boolean dynamic;
d1284 1
a1284 1
static boolean
d1293 1
a1293 1
     boolean dynamic;
d1377 1
a1377 1
  return true;
d1382 1
a1382 1
  return false;
d1387 1
a1387 1
boolean
d1392 1
a1392 1
     boolean dynamic;
d1403 1
a1403 1
    return true;
d1409 1
a1409 1
	return true;
d1428 1
a1428 1
	return true;
d1439 1
a1439 1
    return false;
d1445 1
a1445 1
    return false;
d1452 1
a1452 1
    return false;
d1455 1
a1455 1
  return true;
@


1.38
log
@2002-11-13  H.J. Lu <hjl@@gnu.org>

	* elfcode.h (elf_object_p): Don't restore abfd->arch_info.
@
text
@d424 2
a425 2
INLINE void
elf_swap_reloc_in (abfd, src, dst)
d427 2
a428 2
     const Elf_External_Rel *src;
     Elf_Internal_Rel *dst;
d430 1
d433 1
d436 2
a437 2
INLINE void
elf_swap_reloca_in (abfd, src, dst)
d439 1
a439 1
     const Elf_External_Rela *src;
d442 1
d449 2
a450 2
INLINE void
elf_swap_reloc_out (abfd, src, dst)
d452 2
a453 2
     const Elf_Internal_Rel *src;
     Elf_External_Rel *dst;
d455 1
d460 2
a461 2
INLINE void
elf_swap_reloca_out (abfd, src, dst)
d464 1
a464 1
     Elf_External_Rela *dst;
d466 1
d866 4
a869 2
  Elf_External_Rela *outbound_relocas;
  Elf_External_Rel *outbound_relocs;
d871 2
a872 3
  int use_rela_p;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;
d900 4
a903 1
    use_rela_p = true;
d905 4
a908 1
    use_rela_p = false;
d914 7
d922 18
a939 5
  if (use_rela_p)
    {
      outbound_relocas = (Elf_External_Rela *) rela_hdr->contents;

      for (idx = 0; idx < sec->reloc_count; idx++)
d941 3
a943 37
	  Elf_Internal_Rela dst_rela;
	  Elf_External_Rela *src_rela;
	  arelent *ptr;
	  asymbol *sym;
	  int n;

	  ptr = sec->orelocation[idx];
	  src_rela = outbound_relocas + idx;

	  /* The address of an ELF reloc is section relative for an object
	     file, and absolute for an executable file or shared library.
	     The address of a BFD reloc is always section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	    dst_rela.r_offset = ptr->address;
	  else
	    dst_rela.r_offset = ptr->address + sec->vma;

	  sym = *ptr->sym_ptr_ptr;
	  if (sym == last_sym)
	    n = last_sym_idx;
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
	  else
	    {
	      last_sym = sym;
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
	    }

	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
d948 1
a948 5

	  dst_rela.r_info = ELF_R_INFO (n, ptr->howto->type);

	  dst_rela.r_addend = ptr->addend;
	  elf_swap_reloca_out (abfd, &dst_rela, src_rela);
a949 5
    }
  else
    /* REL relocations */
    {
      outbound_relocs = (Elf_External_Rel *) rela_hdr->contents;
d951 3
a953 1
      for (idx = 0; idx < sec->reloc_count; idx++)
d955 3
a957 43
	  Elf_Internal_Rel dst_rel;
	  Elf_External_Rel *src_rel;
	  arelent *ptr;
	  int n;
	  asymbol *sym;

	  ptr = sec->orelocation[idx];
	  sym = *ptr->sym_ptr_ptr;
	  src_rel = outbound_relocs + idx;

	  /* The address of an ELF reloc is section relative for an object
	     file, and absolute for an executable file or shared library.
	     The address of a BFD reloc is always section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	    dst_rel.r_offset = ptr->address;
	  else
	    dst_rel.r_offset = ptr->address + sec->vma;

	  if (sym == last_sym)
	    n = last_sym_idx;
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
	  else
	    {
	      last_sym = sym;
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
	    }

	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
	    {
	      *failedp = true;
	      return;
	    }

	  dst_rel.r_info = ELF_R_INFO (n, ptr->howto->type);
d959 4
a962 2
	  elf_swap_reloc_out (abfd, &dst_rel, src_rel);
	}
a1327 1
      Elf_Internal_Rel rel;
d1330 1
a1330 1
	elf_swap_reloca_in (abfd, (Elf_External_Rela *) native_relocs, &rela);
d1332 1
a1332 6
	{
	  elf_swap_reloc_in (abfd, (Elf_External_Rel *) native_relocs, &rel);
	  rela.r_offset = rel.r_offset;
	  rela.r_info = rel.r_info;
	  rela.r_addend = 0;
	}
d1371 1
a1371 1
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rel);
d1599 4
a1602 4
  NULL,
  NULL,
  NULL,
  NULL
@


1.37
log
@	* bfd.c (struct bfd_preserve): New.
	(bfd_preserve_save): New function.
	(bfd_preserve_restore): Ditto.
	(bfd_preserve_finish): Ditto.
	* bfd-in2.h: Regenerate.
	* mach-o.c: Formatting.
	(bfd_mach_o_scan_read_symtab_symbol): Make "value" unsigned.
	(bfd_mach_o_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_mach_o_core_p): Ditto.
	(bfd_mach_o_scan): Pass in mdata.
	* mach-o.h (bfd_mach_o_scan): Update prototype.
	* pef.c: Formatting.
	(bfd_pef_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_pef_xlib_object_p): Ditto.
	(bfd_pef_scan): Pass in mdata.  Move version check to bfd_pef_object_p.
	* pef.h (bfd_pef_scan): Update prototype.
	* xsym.c: Formatting, K&R fixes.
	(bfd_sym_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_sym_scan): New function split out from bfd_sym_object_p.
	* xsym.h (bfd_sym_scan): Declare.
	* elfcode.h (elf_object_p): Use bfd_preserve_save/restore/finish.
	(elf_core_file_p): Likewise.
	* targets.c (_bfd_target_vector): Revert 2002-11-08 change.
@
text
@a843 1
  abfd->arch_info = preserve.arch_info;
@


1.36
log
@	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* po/SRC-POTFILES.in: Regnerate.
@
text
@a507 10
struct bfd_preserve
{
  const struct bfd_arch_info *arch_info;
  struct elf_obj_tdata *tdata;
  struct bfd_hash_table section_htab;
  struct sec *sections;
  struct sec **section_tail;
  unsigned int section_count;
};

a528 1
  struct elf_obj_tdata *new_tdata = NULL;
d532 1
a532 1
  preserve.arch_info = abfd->arch_info;
d576 4
a579 2
  new_tdata = (struct elf_obj_tdata *) bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
a580 2
  preserve.tdata = elf_tdata (abfd);
  elf_tdata (abfd) = new_tdata;
d582 1
a582 11
  /* Clear section information, since there might be a recognized bfd that
     we now check if we can replace, and we don't want to append to it.  */
  preserve.sections = abfd->sections;
  preserve.section_tail = abfd->section_tail;
  preserve.section_count = abfd->section_count;
  preserve.section_htab = abfd->section_htab;
  abfd->sections = NULL;
  abfd->section_tail = &abfd->sections;
  abfd->section_count = 0;
  if (!bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc))
    goto got_no_match;
d615 4
a618 2
      && (ebd->elf_machine_alt1 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt2))
d828 2
a829 5
  /* It would be nice to be able to free more memory here, eg. old
     elf_elfsections, old tdata, but that's not possible since these
     blocks are sitting inside obj_alloc'd memory.  */
  bfd_hash_table_free (&preserve.section_htab);
  return (abfd->xvec);
d845 2
a846 11
  if (new_tdata != NULL)
    {
      /* bfd_release frees all memory more recently bfd_alloc'd than
	 its arg, as well as its arg.  */
      bfd_release (abfd, new_tdata);
      elf_tdata (abfd) = preserve.tdata;
      abfd->section_htab = preserve.section_htab;
      abfd->sections = preserve.sections;
      abfd->section_tail = preserve.section_tail;
      abfd->section_count = preserve.section_count;
    }
@


1.36.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d105 1
a105 1
#define elf_canonicalize_symtab		NAME(bfd_elf,canonicalize_symtab)
d124 2
d130 2
d158 11
d173 6
d180 3
a182 3
static void elf_debug_section (int, Elf_Internal_Shdr *);
static void elf_debug_file (Elf_Internal_Ehdr *);
static char *elf_symbol_flags (flagword);
d206 5
a210 4
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
d212 2
a213 2
  const Elf_External_Sym *src = psrc;
  const Elf_External_Sym_Shndx *shndx = pshn;
d237 5
a241 4
elf_swap_symbol_out (bfd *abfd,
		     const Elf_Internal_Sym *src,
		     void *cdst,
		     void *shndx)
d244 1
a244 1
  Elf_External_Sym *dst = cdst;
d265 4
a268 3
elf_swap_ehdr_in (bfd *abfd,
		  const Elf_External_Ehdr *src,
		  Elf_Internal_Ehdr *dst)
d294 4
a297 3
elf_swap_ehdr_out (bfd *abfd,
		   const Elf_Internal_Ehdr *src,
		   Elf_External_Ehdr *dst)
d331 4
a334 3
elf_swap_shdr_in (bfd *abfd,
		  const Elf_External_Shdr *src,
		  Elf_Internal_Shdr *dst)
d359 4
a362 3
elf_swap_shdr_out (bfd *abfd,
		   const Elf_Internal_Shdr *src,
		   Elf_External_Shdr *dst)
d381 4
a384 3
elf_swap_phdr_in (bfd *abfd,
		  const Elf_External_Phdr *src,
		  Elf_Internal_Phdr *dst)
d407 4
a410 3
elf_swap_phdr_out (bfd *abfd,
		   const Elf_Internal_Phdr *src,
		   Elf_External_Phdr *dst)
d424 5
a428 4
void
elf_swap_reloc_in (bfd *abfd,
		   const bfd_byte *s,
		   Elf_Internal_Rela *dst)
a429 1
  const Elf_External_Rel *src = (const Elf_External_Rel *) s;
a431 1
  dst->r_addend = 0;
d434 5
a438 4
void
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
a439 1
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
d446 5
a450 4
void
elf_swap_reloc_out (bfd *abfd,
		    const Elf_Internal_Rela *src,
		    bfd_byte *d)
a451 1
  Elf_External_Rel *dst = (Elf_External_Rel *) d;
d456 5
a460 4
void
elf_swap_reloca_out (bfd *abfd,
		     const Elf_Internal_Rela *src,
		     bfd_byte *d)
a461 1
  Elf_External_Rela *dst = (Elf_External_Rela *) d;
d467 5
a471 4
void
elf_swap_dyn_in (bfd *abfd,
		 const void *p,
		 Elf_Internal_Dyn *dst)
d473 1
a473 1
  const Elf_External_Dyn *src = p;
d479 5
a483 4
void
elf_swap_dyn_out (bfd *abfd,
		  const Elf_Internal_Dyn *src,
		  void *p)
d485 1
a485 1
  Elf_External_Dyn *dst = p;
d498 3
a500 2
static inline bfd_boolean
elf_file_p (Elf_External_Ehdr *x_ehdrp)
d508 10
d527 2
a528 1
elf_object_p (bfd *abfd)
d537 1
a537 1
  const struct elf_backend_data *ebd;
d539 1
d543 1
a543 1
  preserve.marker = NULL;
d547 2
a548 1
  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
a582 3
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

d586 17
a602 1
  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
a603 1
  preserve.marker = elf_tdata (abfd);
d636 2
a637 4
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
d648 1
a648 1
	  const struct elf_backend_data *back;
d652 1
a652 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
d692 2
a693 1
      if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d715 1
a715 1
      i_shdrp = bfd_alloc (abfd, amt);
d723 1
a723 1
      elf_elfsections (abfd) = bfd_alloc (abfd, amt);
d744 2
a745 1
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d776 1
a776 1
      elf_tdata (abfd)->phdr = bfd_alloc (abfd, amt);
d786 2
a787 1
	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
d847 5
a851 2
  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;
d866 12
a877 2
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
d886 4
a889 1
elf_write_relocs (bfd *abfd, asection *sec, void *data)
d891 1
a891 1
  bfd_boolean *failedp = data;
d893 2
a894 4
  bfd_vma addr_offset;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  size_t extsize;
  bfd_byte *dst_rela;
d896 3
a898 2
  asymbol *last_sym;
  int last_sym_idx;
d917 1
a917 1
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d920 1
a920 1
      *failedp = TRUE;
d926 1
a926 4
    {
      swap_out = elf_swap_reloca_out;
      extsize = sizeof (Elf_External_Rela);
    }
d928 1
a928 4
    {
      swap_out = elf_swap_reloc_out;
      extsize = sizeof (Elf_External_Rel);
    }
d934 4
a937 6
  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;
d939 1
a939 19
  /* orelocation has the data, reloc_count has the count...  */
  last_sym = 0;
  last_sym_idx = 0;
  dst_rela = rela_hdr->contents;

  for (idx = 0; idx < sec->reloc_count; idx++, dst_rela += extsize)
    {
      Elf_Internal_Rela src_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
d941 23
a963 3
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
d965 15
a979 1
	      *failedp = TRUE;
d982 5
a986 1
	  last_sym_idx = n;
d988 5
d994 1
a994 3
      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
d996 45
a1040 2
	  *failedp = TRUE;
	  return;
a1041 5

      src_rela.r_offset = ptr->address + addr_offset;
      src_rela.r_info = ELF_R_INFO (n, ptr->howto->type);
      src_rela.r_addend = ptr->addend;
      (*swap_out) (abfd, &src_rela, dst_rela);
d1048 4
a1051 3
elf_write_out_phdrs (bfd *abfd,
		     const Elf_Internal_Phdr *phdr,
		     unsigned int count)
d1057 2
a1058 2
      if (bfd_bwrite (&extphdr, sizeof (Elf_External_Phdr), abfd)
	  != sizeof (Elf_External_Phdr))
d1067 3
a1069 2
bfd_boolean
elf_write_shdrs_and_ehdr (bfd *abfd)
d1089 2
a1090 2
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)
    return FALSE;
d1102 1
a1102 1
  x_shdrp = bfd_alloc (abfd, amt);
d1104 1
a1104 1
    return FALSE;
d1112 1
a1112 1

d1117 2
a1118 2
      || bfd_bwrite (x_shdrp, amt, abfd) != amt)
    return FALSE;
d1122 1
a1122 1
  return TRUE;
d1126 4
a1129 1
elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
d1141 1
a1141 1
  const struct elf_backend_data *ebd;
d1189 1
a1189 1
      symbase = bfd_zalloc (abfd, amt);
d1213 1
a1213 1
	  xverbuf = bfd_malloc (verhdr->sh_size);
d1217 2
a1218 1
	  if (bfd_bread (xverbuf, verhdr->sh_size, abfd) != verhdr->sh_size)
d1271 1
a1271 1
	  /* If this is a relocatable file, then the symbol value is
d1363 10
a1372 8
static bfd_boolean
elf_slurp_reloc_table_from_section (bfd *abfd,
				    asection *asect,
				    Elf_Internal_Shdr *rel_hdr,
				    bfd_size_type reloc_count,
				    arelent *relents,
				    asymbol **symbols,
				    bfd_boolean dynamic)
d1374 2
a1375 2
  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
  void *allocated = NULL;
d1382 1
a1382 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d1391 1
a1391 1
  native_relocs = allocated;
d1407 1
d1410 1
a1410 1
	elf_swap_reloca_in (abfd, native_relocs, &rela);
d1412 6
a1417 1
	elf_swap_reloc_in (abfd, native_relocs, &rela);
d1453 1
a1453 3
      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
d1456 1
a1456 1
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rela);
d1462 1
a1462 1
  return TRUE;
d1467 1
a1467 1
  return FALSE;
d1472 6
a1477 5
bfd_boolean
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
d1488 1
a1488 1
    return TRUE;
d1494 1
a1494 1
	return TRUE;
d1513 1
a1513 1
	return TRUE;
d1522 1
a1522 1
  relents = bfd_alloc (abfd, amt);
d1524 1
a1524 1
    return FALSE;
d1530 1
a1530 1
    return FALSE;
d1537 1
a1537 1
    return FALSE;
d1540 1
a1540 1
  return TRUE;
d1545 3
a1547 1
elf_debug_section (int num, Elf_Internal_Shdr *hdr)
d1573 2
a1574 1
elf_debug_file (Elf_Internal_Ehdr *ehdrp)
d1586 2
a1587 1
elf_symbol_flags (flagword flags)
a1657 223
/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for a target with the word size and byte order found in the
   remote memory.  */

bfd *
NAME(_bfd_elf,bfd_from_remote_memory)
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
  Elf_External_Phdr *x_phdrs;
  Elf_Internal_Phdr *i_phdrs, *last_phdr;
  bfd *nbfd;
  struct bfd_in_memory *bim;
  int contents_size;
  char *contents;
  int err;
  unsigned int i;
  bfd_vma loadbase;

  /* Read in the ELF header in external format.  */
  err = target_read_memory (ehdr_vma, (char *) &x_ehdr, sizeof x_ehdr);
  if (err)
    {
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry.  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  elf_swap_ehdr_in (templ, &x_ehdr, &i_ehdr);

  /* The file header tells where to find the program headers.
     These are what we use to actually choose what to read.  */

  if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  x_phdrs = bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
  if (x_phdrs == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (char *) x_phdrs,
			    i_ehdr.e_phnum * sizeof x_phdrs[0]);
  if (err)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }
  i_phdrs = (Elf_Internal_Phdr *) &x_phdrs[i_ehdr.e_phnum];

  contents_size = 0;
  last_phdr = NULL;
  loadbase = ehdr_vma;
  for (i = 0; i < i_ehdr.e_phnum; ++i)
    {
      elf_swap_phdr_in (templ, &x_phdrs[i], &i_phdrs[i]);
      if (i_phdrs[i].p_type == PT_LOAD)
	{
	  bfd_vma segment_end;
	  segment_end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
			 + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	  if (segment_end > (bfd_vma) contents_size)
	    contents_size = segment_end;

	  if ((i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);

	  last_phdr = &i_phdrs[i];
	}
    }
  if (last_phdr == NULL)
    {
      /* There were no PT_LOAD segments, so we don't have anything to read.  */
      free (x_phdrs);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Trim the last segment so we don't bother with zeros in the last page
     that are off the end of the file.  However, if the extra bit in that
     page includes the section headers, keep them.  */
  if ((bfd_vma) contents_size > last_phdr->p_offset + last_phdr->p_filesz
      && (bfd_vma) contents_size >= (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      contents_size = last_phdr->p_offset + last_phdr->p_filesz;
      if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
	contents_size = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;
    }
  else
    contents_size = last_phdr->p_offset + last_phdr->p_filesz;

  /* Now we know the size of the whole image we want read in.  */
  contents = bfd_zmalloc (contents_size);
  if (contents == NULL)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  for (i = 0; i < i_ehdr.e_phnum; ++i)
    if (i_phdrs[i].p_type == PT_LOAD)
      {
	bfd_vma start = i_phdrs[i].p_offset & -i_phdrs[i].p_align;
	bfd_vma end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
		       + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	if (end > (bfd_vma) contents_size)
	  end = contents_size;
	err = target_read_memory ((loadbase + i_phdrs[i].p_vaddr)
				  & -i_phdrs[i].p_align,
				  contents + start, end - start);
	if (err)
	  {
	    free (x_phdrs);
	    free (contents);
	    bfd_set_error (bfd_error_system_call);
	    errno = err;
	    return NULL;
	  }
      }
  free (x_phdrs);

  /* If the segments visible in memory didn't include the section headers,
     then clear them from the file header.  */
  if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				 + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      memset (&x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);
      memset (&x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);
      memset (&x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);
    }

  /* This will normally have been in the first PT_LOAD segment.  But it
     conceivably could be missing, and we might have just changed it.  */
  memcpy (contents, &x_ehdr, sizeof x_ehdr);

  /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  if (bim == NULL)
    {
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      free (bim);
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd->filename = "<in-memory>";
  nbfd->xvec = templ->xvec;
  bim->size = contents_size;
  bim->buffer = contents;
  nbfd->iostream = bim;
  nbfd->flags = BFD_IN_MEMORY;
  nbfd->direction = read_direction;
  nbfd->mtime = time (NULL);
  nbfd->mtime_set = TRUE;

  if (loadbasep)
    *loadbasep = loadbase;
  return nbfd;
}

d1673 1
a1673 1
  ARCH_SIZE, LOG_FILE_ALIGN,
d1684 4
a1687 4
  elf_swap_reloc_in,
  elf_swap_reloc_out,
  elf_swap_reloca_in,
  elf_swap_reloca_out
@


1.35
log
@        * elfcode.h (elf_slurp_reloc_table_from_section): Check
        correct relocation count.
@
text
@d1380 1
a1380 1
  long symcount;
d1397 5
a1426 5

      if (dynamic)
	symcount = bfd_get_dynamic_symcount (abfd);
      else
	symcount = bfd_get_symcount (abfd);
@


1.35.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d1380 1
a1380 1
  unsigned int symcount;
a1396 5
  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

d1422 5
@


1.35.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d508 10
d539 1
d543 1
a543 1
  preserve.marker = NULL;
d587 2
a588 2
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
d590 13
a602 1
  if (!bfd_preserve_save (abfd, &preserve))
a604 2
  elf_tdata (abfd) = preserve.marker;

d636 2
a637 4
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
d847 5
a851 2
  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;
d866 12
a877 2
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
@


1.35.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d173 1
a173 1
static bfd_boolean elf_slurp_reloc_table_from_section
d175 1
a175 1
	   arelent *, asymbol **, bfd_boolean));
d177 1
a177 1
static bfd_boolean elf_file_p PARAMS ((Elf_External_Ehdr *));
d424 2
a425 2
void
elf_swap_reloc_in (abfd, s, dst)
d427 2
a428 2
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
a429 1
  const Elf_External_Rel *src = (const Elf_External_Rel *) s;
a431 1
  dst->r_addend = 0;
d434 2
a435 2
void
elf_swap_reloca_in (abfd, s, dst)
d437 1
a437 1
     const bfd_byte *s;
a439 1
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
d446 2
a447 2
void
elf_swap_reloc_out (abfd, src, d)
d449 2
a450 2
     const Elf_Internal_Rela *src;
     bfd_byte *d;
a451 1
  Elf_External_Rel *dst = (Elf_External_Rel *) d;
d456 2
a457 2
void
elf_swap_reloca_out (abfd, src, d)
d460 1
a460 1
     bfd_byte *d;
a461 1
  Elf_External_Rela *dst = (Elf_External_Rela *) d;
d498 1
a498 1
static INLINE bfd_boolean
d859 1
a859 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d861 2
a862 4
  bfd_vma addr_offset;
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
  size_t extsize;
  bfd_byte *dst_rela;
d864 3
a866 2
  asymbol *last_sym;
  int last_sym_idx;
d888 1
a888 1
      *failedp = TRUE;
d894 1
a894 4
    {
      swap_out = elf_swap_reloca_out;
      extsize = sizeof (Elf_External_Rela);
    }
d896 1
a896 4
    {
      swap_out = elf_swap_reloc_out;
      extsize = sizeof (Elf_External_Rel);
    }
d902 4
a905 6
  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;
d907 1
a907 19
  /* orelocation has the data, reloc_count has the count...  */
  last_sym = 0;
  last_sym_idx = 0;
  dst_rela = rela_hdr->contents;

  for (idx = 0; idx < sec->reloc_count; idx++, dst_rela += extsize)
    {
      Elf_Internal_Rela src_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
d909 37
a945 3
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
d947 1
a947 1
	      *failedp = TRUE;
d950 5
a954 1
	  last_sym_idx = n;
d956 5
d962 1
a962 3
      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
d964 45
a1008 2
	  *failedp = TRUE;
	  return;
a1009 5

      src_rela.r_offset = ptr->address + addr_offset;
      src_rela.r_info = ELF_R_INFO (n, ptr->howto->type);
      src_rela.r_addend = ptr->addend;
      (*swap_out) (abfd, &src_rela, dst_rela);
d1035 1
a1035 1
bfd_boolean
d1058 1
a1058 1
    return FALSE;
d1072 1
a1072 1
    return FALSE;
d1080 1
a1080 1

d1086 1
a1086 1
    return FALSE;
d1090 1
a1090 1
  return TRUE;
d1097 1
a1097 1
     bfd_boolean dynamic;
d1331 1
a1331 1
static bfd_boolean
d1340 1
a1340 1
     bfd_boolean dynamic;
d1375 1
d1378 1
a1378 1
	elf_swap_reloca_in (abfd, native_relocs, &rela);
d1380 6
a1385 1
	elf_swap_reloc_in (abfd, native_relocs, &rela);
d1424 1
a1424 1
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rela);
d1430 1
a1430 1
  return TRUE;
d1435 1
a1435 1
  return FALSE;
d1440 1
a1440 1
bfd_boolean
d1445 1
a1445 1
     bfd_boolean dynamic;
d1456 1
a1456 1
    return TRUE;
d1462 1
a1462 1
	return TRUE;
d1481 1
a1481 1
	return TRUE;
d1492 1
a1492 1
    return FALSE;
d1498 1
a1498 1
    return FALSE;
d1505 1
a1505 1
    return FALSE;
d1508 1
a1508 1
  return TRUE;
d1652 4
a1655 4
  elf_swap_reloc_in,
  elf_swap_reloc_out,
  elf_swap_reloca_in,
  elf_swap_reloca_out
@


1.35.2.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d124 2
a1572 226
/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for a target with the word size and byte order found in the
   remote memory.  */

bfd *
NAME(_bfd_elf,bfd_from_remote_memory) (templ, ehdr_vma, loadbasep,
				       target_read_memory)
     bfd *templ;
     bfd_vma ehdr_vma;
     bfd_vma *loadbasep;
     int (*target_read_memory) PARAMS ((bfd_vma vma, char *myaddr, int len));
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
  Elf_External_Phdr *x_phdrs;
  Elf_Internal_Phdr *i_phdrs, *last_phdr;
  bfd *nbfd;
  struct bfd_in_memory *bim;
  int contents_size;
  char *contents;
  int err;
  unsigned int i;
  bfd_vma loadbase;

  /* Read in the ELF header in external format.  */
  err = target_read_memory (ehdr_vma, (char *) &x_ehdr, sizeof x_ehdr);
  if (err)
    {
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry.  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  elf_swap_ehdr_in (templ, &x_ehdr, &i_ehdr);

  /* The file header tells where to find the program headers.
     These are what we use to actually choose what to read.  */

  if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  x_phdrs = (Elf_External_Phdr *)
    bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
  if (x_phdrs == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (char *) x_phdrs,
			    i_ehdr.e_phnum * sizeof x_phdrs[0]);
  if (err)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }
  i_phdrs = (Elf_Internal_Phdr *) &x_phdrs[i_ehdr.e_phnum];

  contents_size = 0;
  last_phdr = NULL;
  loadbase = ehdr_vma;
  for (i = 0; i < i_ehdr.e_phnum; ++i)
    {
      elf_swap_phdr_in (templ, &x_phdrs[i], &i_phdrs[i]);
      if (i_phdrs[i].p_type == PT_LOAD)
	{
	  bfd_vma segment_end;
	  segment_end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
			 + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	  if (segment_end > (bfd_vma) contents_size)
	    contents_size = segment_end;

	  if ((i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);

	  last_phdr = &i_phdrs[i];
	}
    }
  if (last_phdr == NULL)
    {
      /* There were no PT_LOAD segments, so we don't have anything to read.  */
      free (x_phdrs);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Trim the last segment so we don't bother with zeros in the last page
     that are off the end of the file.  However, if the extra bit in that
     page includes the section headers, keep them.  */
  if ((bfd_vma) contents_size > last_phdr->p_offset + last_phdr->p_filesz
      && (bfd_vma) contents_size >= (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      contents_size = last_phdr->p_offset + last_phdr->p_filesz;
      if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
	contents_size = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;
    }
  else
    contents_size = last_phdr->p_offset + last_phdr->p_filesz;

  /* Now we know the size of the whole image we want read in.  */
  contents = (char *) bfd_zmalloc ((bfd_size_type) contents_size);
  if (contents == NULL)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  for (i = 0; i < i_ehdr.e_phnum; ++i)
    if (i_phdrs[i].p_type == PT_LOAD)
      {
	bfd_vma start = i_phdrs[i].p_offset & -i_phdrs[i].p_align;
	bfd_vma end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
		       + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	if (end > (bfd_vma) contents_size)
	  end = contents_size;
	err = target_read_memory ((loadbase + i_phdrs[i].p_vaddr)
				  & -i_phdrs[i].p_align,
				  contents + start, end - start);
	if (err)
	  {
	    free (x_phdrs);
	    free (contents);
	    bfd_set_error (bfd_error_system_call);
	    errno = err;
	    return NULL;
	  }
      }
  free (x_phdrs);

  /* If the segments visible in memory didn't include the section headers,
     then clear them from the file header.  */
  if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				 + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      memset (&x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);
      memset (&x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);
      memset (&x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);
    }

  /* This will normally have been in the first PT_LOAD segment.  But it
     conceivably could be missing, and we might have just changed it.  */
  memcpy (contents, &x_ehdr, sizeof x_ehdr);

  /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  if (bim == NULL)
    {
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      free (bim);
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd->filename = "<in-memory>";
  nbfd->xvec = templ->xvec;
  bim->size = contents_size;
  bim->buffer = contents;
  nbfd->iostream = (PTR) bim;
  nbfd->flags = BFD_IN_MEMORY;
  nbfd->direction = read_direction;
  nbfd->mtime = time (NULL);
  nbfd->mtime_set = TRUE;

  if (loadbasep)
    *loadbasep = loadbase;
  return nbfd;
}

d1588 1
a1588 1
  ARCH_SIZE, LOG_FILE_ALIGN,
@


1.35.2.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1190 1
a1190 1
	  /* If this is a relocatable file, then the symbol value is
d1366 1
a1366 3
      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
@


1.35.2.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d128 2
d156 11
d171 6
d178 3
a180 3
static void elf_debug_section (int, Elf_Internal_Shdr *);
static void elf_debug_file (Elf_Internal_Ehdr *);
static char *elf_symbol_flags (flagword);
d204 5
a208 4
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
d210 2
a211 2
  const Elf_External_Sym *src = psrc;
  const Elf_External_Sym_Shndx *shndx = pshn;
d235 5
a239 4
elf_swap_symbol_out (bfd *abfd,
		     const Elf_Internal_Sym *src,
		     void *cdst,
		     void *shndx)
d242 1
a242 1
  Elf_External_Sym *dst = cdst;
d263 4
a266 3
elf_swap_ehdr_in (bfd *abfd,
		  const Elf_External_Ehdr *src,
		  Elf_Internal_Ehdr *dst)
d292 4
a295 3
elf_swap_ehdr_out (bfd *abfd,
		   const Elf_Internal_Ehdr *src,
		   Elf_External_Ehdr *dst)
d329 4
a332 3
elf_swap_shdr_in (bfd *abfd,
		  const Elf_External_Shdr *src,
		  Elf_Internal_Shdr *dst)
d357 4
a360 3
elf_swap_shdr_out (bfd *abfd,
		   const Elf_Internal_Shdr *src,
		   Elf_External_Shdr *dst)
d379 4
a382 3
elf_swap_phdr_in (bfd *abfd,
		  const Elf_External_Phdr *src,
		  Elf_Internal_Phdr *dst)
d405 4
a408 3
elf_swap_phdr_out (bfd *abfd,
		   const Elf_Internal_Phdr *src,
		   Elf_External_Phdr *dst)
d423 4
a426 3
elf_swap_reloc_in (bfd *abfd,
		   const bfd_byte *s,
		   Elf_Internal_Rela *dst)
d435 4
a438 3
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
d448 4
a451 3
elf_swap_reloc_out (bfd *abfd,
		    const Elf_Internal_Rela *src,
		    bfd_byte *d)
d459 4
a462 3
elf_swap_reloca_out (bfd *abfd,
		     const Elf_Internal_Rela *src,
		     bfd_byte *d)
d470 5
a474 4
void
elf_swap_dyn_in (bfd *abfd,
		 const void *p,
		 Elf_Internal_Dyn *dst)
d476 1
a476 1
  const Elf_External_Dyn *src = p;
d482 5
a486 4
void
elf_swap_dyn_out (bfd *abfd,
		  const Elf_Internal_Dyn *src,
		  void *p)
d488 1
a488 1
  Elf_External_Dyn *dst = p;
d501 3
a503 2
static inline bfd_boolean
elf_file_p (Elf_External_Ehdr *x_ehdrp)
d520 2
a521 1
elf_object_p (bfd *abfd)
d539 2
a540 1
  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
a574 3
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

d578 3
a580 1
  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
d582 4
a585 1
  preserve.marker = elf_tdata (abfd);
d676 2
a677 1
      if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d699 1
a699 1
      i_shdrp = bfd_alloc (abfd, amt);
d707 1
a707 1
      elf_elfsections (abfd) = bfd_alloc (abfd, amt);
d728 2
a729 1
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d760 1
a760 1
      elf_tdata (abfd)->phdr = bfd_alloc (abfd, amt);
d770 2
a771 1
	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
d857 4
a860 1
elf_write_relocs (bfd *abfd, asection *sec, void *data)
d862 1
a862 1
  bfd_boolean *failedp = data;
d889 1
a889 1
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d967 4
a970 3
elf_write_out_phdrs (bfd *abfd,
		     const Elf_Internal_Phdr *phdr,
		     unsigned int count)
d976 2
a977 2
      if (bfd_bwrite (&extphdr, sizeof (Elf_External_Phdr), abfd)
	  != sizeof (Elf_External_Phdr))
d987 2
a988 1
elf_write_shdrs_and_ehdr (bfd *abfd)
d1008 1
a1008 1
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)
d1021 1
a1021 1
  x_shdrp = bfd_alloc (abfd, amt);
d1036 1
a1036 1
      || bfd_bwrite (x_shdrp, amt, abfd) != amt)
d1045 4
a1048 1
elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
d1108 1
a1108 1
      symbase = bfd_zalloc (abfd, amt);
d1132 1
a1132 1
	  xverbuf = bfd_malloc (verhdr->sh_size);
d1136 2
a1137 1
	  if (bfd_bread (xverbuf, verhdr->sh_size, abfd) != verhdr->sh_size)
d1283 9
a1291 7
elf_slurp_reloc_table_from_section (bfd *abfd,
				    asection *asect,
				    Elf_Internal_Shdr *rel_hdr,
				    bfd_size_type reloc_count,
				    arelent *relents,
				    asymbol **symbols,
				    bfd_boolean dynamic)
d1294 1
a1294 1
  void *allocated = NULL;
d1301 1
a1301 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d1310 1
a1310 1
  native_relocs = allocated;
d1388 5
a1392 4
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
d1437 1
a1437 1
  relents = bfd_alloc (abfd, amt);
d1460 3
a1462 1
elf_debug_section (int num, Elf_Internal_Shdr *hdr)
d1488 2
a1489 1
elf_debug_file (Elf_Internal_Ehdr *ehdrp)
d1501 2
a1502 1
elf_symbol_flags (flagword flags)
d1587 6
a1592 5
NAME(_bfd_elf,bfd_from_remote_memory)
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
d1661 2
a1662 1
  x_phdrs = bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
d1723 1
a1723 1
  contents = bfd_zmalloc (contents_size);
d1768 2
a1769 1
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
d1788 1
a1788 1
  nbfd->iostream = bim;
@


1.35.2.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d495 1
a495 1
  const struct elf_backend_data *ebd;
d594 1
a594 1
	  const struct elf_backend_data *back;
d598 1
a598 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
d821 1
a821 1
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d1011 1
a1011 1
  const struct elf_backend_data *ebd;
d1241 1
a1241 1
  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
@


1.35.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d105 1
a105 1
#define elf_canonicalize_symtab		NAME(bfd_elf,canonicalize_symtab)
@


1.34
log
@        * bfd-in.h (bfd_get_dynamic_symcount): Define.
        * bfd.c (struct _bfd): Add dynsymcount.
        * bfd-in2.h: Regenerated.
        * elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
        abfd->dynsymcount.
        * elfcode.h (elf_slurp_reloc_table_from_section): Check
        for overflow.
@
text
@d1380 1
d1423 5
d1430 1
a1430 1
      else if (ELF_R_SYM (rela.r_info) > bfd_get_dynamic_symcount (abfd))
@


1.33
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d1424 7
@


1.33.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a1379 1
  unsigned int symcount;
a1395 5
  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

a1423 7
      else if (ELF_R_SYM (rela.r_info) > symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): relocation %d has invalid symbol index %ld"),
	     abfd->filename, asect->name, i, ELF_R_SYM (rela.r_info));
	  relent->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;
	}
@


1.32
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d1136 6
a1141 4
  Elf_Internal_Sym i_sym;
  Elf_External_Sym *x_symp = NULL;
  Elf_External_Sym_Shndx *x_shndx = NULL;
  Elf_External_Versym *x_versymp = NULL;
a1155 2
      Elf_Internal_Shdr *shndx_hdr;

a1156 1
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
a1157 13

      /* If we have a SHT_SYMTAB_SHNDX section for the symbol table,
	 read the raw contents.  */
      if (elf_elfsections (abfd) != NULL
	  && elf_elfsections (abfd)[shndx_hdr->sh_link] == hdr)
	{
	  amt = shndx_hdr->sh_size;
	  x_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (x_shndx == NULL
	      || bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) x_shndx, amt, abfd) != amt)
	    goto error_return;
	}
d1176 1
a1176 3
  if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0)
    goto error_return;

a1177 1

d1182 4
a1185 4
      unsigned long i;

      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0)
	goto error_return;
a1191 11
      sym = symbase;

      /* Temporarily allocate room for the raw ELF symbols.  */
      amt = symcount;
      amt *= sizeof (Elf_External_Sym);
      x_symp = (Elf_External_Sym *) bfd_malloc (amt);
      if (x_symp == NULL)
	goto error_return;

      if (bfd_bread ((PTR) x_symp, amt, abfd) != amt)
	goto error_return;
a1193 1

d1213 2
a1214 2
	  x_versymp = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (x_versymp == NULL && verhdr->sh_size != 0)
d1217 1
a1217 1
	  if (bfd_bread ((PTR) x_versymp, verhdr->sh_size, abfd)
d1223 5
a1227 1
      for (i = 1; i < symcount; i++)
d1229 1
a1229 7
	  elf_swap_symbol_in (abfd, (const PTR) (x_symp + i),
			      (const PTR) (x_shndx + (x_shndx ? i : 0)),
			      &i_sym);
	  memcpy (&sym->internal_elf_sym, &i_sym, sizeof (Elf_Internal_Sym));
#ifdef ELF_KEEP_EXTSYM
	  memcpy (&sym->native_elf_sym, x_symp + i, sizeof (Elf_External_Sym));
#endif
d1234 1
a1234 1
							      i_sym.st_name);
d1236 1
a1236 1
	  sym->symbol.value = i_sym.st_value;
d1238 1
a1238 1
	  if (i_sym.st_shndx == SHN_UNDEF)
d1242 2
a1243 2
	  else if (i_sym.st_shndx < SHN_LORESERVE
		   || i_sym.st_shndx > SHN_HIRESERVE)
d1246 1
a1246 1
							    i_sym.st_shndx);
d1255 1
a1255 1
	  else if (i_sym.st_shndx == SHN_ABS)
d1259 1
a1259 1
	  else if (i_sym.st_shndx == SHN_COMMON)
d1266 1
a1266 1
	      sym->symbol.value = i_sym.st_size;
d1276 1
a1276 1
	  switch (ELF_ST_BIND (i_sym.st_info))
d1282 1
a1282 2
	      if (i_sym.st_shndx != SHN_UNDEF
		  && i_sym.st_shndx != SHN_COMMON)
d1290 1
a1290 1
	  switch (ELF_ST_TYPE (i_sym.st_info))
d1309 1
a1309 1
	  if (x_versymp != NULL)
d1313 1
a1313 1
	      _bfd_elf_swap_versym_in (abfd, x_versymp + i, &iversym);
d1315 1
d1319 2
a1320 7
	  {
	    struct elf_backend_data *ebd = get_elf_backend_data (abfd);
	    if (ebd->elf_backend_symbol_processing)
	      (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
	  }

	  sym++;
d1325 2
a1326 5
  {
    struct elf_backend_data *ebd = get_elf_backend_data (abfd);
    if (ebd->elf_backend_symbol_table_processing)
      (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);
  }
d1346 4
a1349 6
  if (x_shndx != NULL)
    free (x_shndx);
  if (x_versymp != NULL)
    free (x_versymp);
  if (x_symp != NULL)
    free (x_symp);
d1353 4
a1356 6
  if (x_shndx != NULL)
    free (x_shndx);
  if (x_versymp != NULL)
    free (x_versymp);
  if (x_symp != NULL)
    free (x_symp);
@


1.31
log
@binutils/
	* readelf.c (get_file_header): Only read the first section header if
	e_shoff is non-zero.

bfd/
	* elfcode.h (elf_object_p): Sanity check eh_shoff == 0 implies
	e_shnum == 0.
	Only read the first section header if e_shoff is non-zero.
	Don't consider e_shstrndx if there are no sections.
@
text
@d562 3
a564 3
  if ((elf_file_p (&x_ehdr) == false) ||
      (x_ehdr.e_ident[EI_VERSION] != EV_CURRENT) ||
      (x_ehdr.e_ident[EI_CLASS] != ELFCLASS))
d824 1
a824 1
      if ((*ebd->elf_backend_object_p) (abfd) == false)
@


1.30
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d627 4
d684 22
a705 19
  /* Seek to the section header table in the file.  */
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
    goto got_no_match;

  /* Read the first section header at index 0, and convert to internal
     form.  */
  if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
      != sizeof (x_shdr))
    goto got_no_match;
  elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);

  /* If the section count is zero, the actual count is in the first
     section header.  */
  if (i_ehdrp->e_shnum == SHN_UNDEF)
    i_ehdrp->e_shnum = i_shdr.sh_size;

  /* And similarly for the string table index.  */
  if (i_ehdrp->e_shstrndx == SHN_XINDEX)
    i_ehdrp->e_shstrndx = i_shdr.sh_link;
d761 1
a761 1
  if (i_ehdrp->e_shstrndx)
d799 1
a799 1
  if (i_ehdrp->e_shstrndx != 0)
@


1.29
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d208 2
a209 2
     const PTR *psrc;
     const PTR *pshn;
d1247 2
a1248 2
	  elf_swap_symbol_in (abfd, (const PTR *) (x_symp + i),
			      (const PTR *) (x_shndx + (x_shndx ? i : 0)),
@


1.28
log
@	* elfcode.h (elf_slurp_symbol_table): Test elf_elfsections for NULL,
	as can happen with a core file, before dereferencing.
@
text
@d3 1
a3 1
   2001 Free Software Foundation, Inc.
d206 1
a206 1
elf_swap_symbol_in (abfd, src, shndx, dst)
d208 2
a209 2
     const Elf_External_Sym *src;
     const Elf_External_Sym_Shndx *shndx;
d212 2
d1247 3
a1249 2
	  elf_swap_symbol_in (abfd, x_symp + i,
			      x_shndx + (x_shndx != NULL ? i : 0), &i_sym);
d1701 1
@


1.28.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
d206 1
a206 1
elf_swap_symbol_in (abfd, psrc, pshn, dst)
d208 2
a209 2
     const PTR psrc;
     const PTR pshn;
a211 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
a624 4
  /* Further sanity check.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

d678 3
a680 5
  if (i_ehdrp->e_shoff != 0)
    {
      /* Seek to the section header table in the file.  */
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
	goto got_no_match;
d682 6
a687 6
      /* Read the first section header at index 0, and convert to internal
	 form.  */
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);
d689 8
a696 9
      /* If the section count is zero, the actual count is in the first
	 section header.  */
      if (i_ehdrp->e_shnum == SHN_UNDEF)
	i_ehdrp->e_shnum = i_shdr.sh_size;

      /* And similarly for the string table index.  */
      if (i_ehdrp->e_shstrndx == SHN_XINDEX)
	i_ehdrp->e_shstrndx = i_shdr.sh_link;
    }
d752 1
a752 1
  if (i_ehdrp->e_shstrndx && i_ehdrp->e_shoff)
d790 1
a790 1
  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff)
d1245 2
a1246 3
	  elf_swap_symbol_in (abfd, (const PTR) (x_symp + i),
			      (const PTR) (x_shndx + (x_shndx ? i : 0)),
			      &i_sym);
a1697 1
  elf_swap_symbol_in,
@


1.28.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d562 3
a564 3
  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
d824 1
a824 1
      if (! (*ebd->elf_backend_object_p) (abfd))
d1136 4
a1139 6
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_External_Versym *xver;
  Elf_External_Versym *xverbuf = NULL;
  struct elf_backend_data *ebd;
d1154 2
d1157 1
d1159 13
d1190 3
a1192 1
  ebd = get_elf_backend_data (abfd);
d1194 1
d1199 4
a1202 4
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return -1;
d1209 11
d1222 1
d1242 2
a1243 2
	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (xverbuf == NULL && verhdr->sh_size != 0)
d1246 1
a1246 1
	  if (bfd_bread ((PTR) xverbuf, verhdr->sh_size, abfd)
d1252 1
a1252 5
      xver = xverbuf;
      if (xver != NULL)
	++xver;
      isymend = isymbuf + symcount;
      for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
d1254 7
a1260 1
	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));
d1265 1
a1265 1
							      isym->st_name);
d1267 1
a1267 1
	  sym->symbol.value = isym->st_value;
d1269 1
a1269 1
	  if (isym->st_shndx == SHN_UNDEF)
d1273 2
a1274 2
	  else if (isym->st_shndx < SHN_LORESERVE
		   || isym->st_shndx > SHN_HIRESERVE)
d1277 1
a1277 1
							    isym->st_shndx);
d1286 1
a1286 1
	  else if (isym->st_shndx == SHN_ABS)
d1290 1
a1290 1
	  else if (isym->st_shndx == SHN_COMMON)
d1297 1
a1297 1
	      sym->symbol.value = isym->st_size;
d1307 1
a1307 1
	  switch (ELF_ST_BIND (isym->st_info))
d1313 2
a1314 1
	      if (isym->st_shndx != SHN_UNDEF && isym->st_shndx != SHN_COMMON)
d1322 1
a1322 1
	  switch (ELF_ST_TYPE (isym->st_info))
d1341 1
a1341 1
	  if (xver != NULL)
d1345 1
a1345 1
	      _bfd_elf_swap_versym_in (abfd, xver, &iversym);
a1346 1
	      xver++;
d1350 7
a1356 2
	  if (ebd->elf_backend_symbol_processing)
	    (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
d1361 5
a1365 2
  if (ebd->elf_backend_symbol_table_processing)
    (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);
d1385 6
a1390 4
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
d1394 6
a1399 4
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
@


1.28.10.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1379 1
  unsigned int symcount;
a1395 5
  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

a1423 7
      else if (ELF_R_SYM (rela.r_info) > symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): relocation %d has invalid symbol index %ld"),
	     abfd->filename, asect->name, i, ELF_R_SYM (rela.r_info));
	  relent->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;
	}
@


1.28.8.1
log
@merge from trunk
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
d206 1
a206 1
elf_swap_symbol_in (abfd, psrc, pshn, dst)
d208 2
a209 2
     const PTR psrc;
     const PTR pshn;
a211 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
d1245 2
a1246 3
	  elf_swap_symbol_in (abfd, (const PTR) (x_symp + i),
			      (const PTR) (x_shndx + (x_shndx ? i : 0)),
			      &i_sym);
a1697 1
  elf_swap_symbol_in,
@


1.28.8.2
log
@Merge with trunk.
@
text
@a626 4
  /* Further sanity check.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

d680 19
a698 22
  if (i_ehdrp->e_shoff != 0)
    {
      /* Seek to the section header table in the file.  */
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
	goto got_no_match;

      /* Read the first section header at index 0, and convert to internal
	 form.  */
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);

      /* If the section count is zero, the actual count is in the first
	 section header.  */
      if (i_ehdrp->e_shnum == SHN_UNDEF)
	i_ehdrp->e_shnum = i_shdr.sh_size;

      /* And similarly for the string table index.  */
      if (i_ehdrp->e_shstrndx == SHN_XINDEX)
	i_ehdrp->e_shstrndx = i_shdr.sh_link;
    }
d754 1
a754 1
  if (i_ehdrp->e_shstrndx && i_ehdrp->e_shoff)
d792 1
a792 1
  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff)
@


1.27
log
@	* elfcode.h (struct bfd_preserve): New.
	(elf_object_p): Replace preserved_* vars with instance of above.
	Save and restore arch_info pointer rather than arch, mach so that
	more cases can be restored.  Save and restore new section_tail,
	section_htab structure, and init appropriately.  Move "rest of
	section header" code so that i_shdrp needs no NULL initialisation.
	Free old section_htab on success.
	* elfcore.h (elf_core_file_p): Likewise.
@
text
@d1153 2
a1154 1
      if (elf_elfsections (abfd)[shndx_hdr->sh_link] == hdr)
@


1.26
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d506 10
d532 1
a532 1
  Elf_Internal_Shdr *i_shdrp = NULL; /* Section header table, internal form */
d536 1
a536 5
  struct elf_obj_tdata *preserved_tdata = elf_tdata (abfd);
  struct sec *preserved_sections = abfd->sections;
  unsigned int preserved_section_count = abfd->section_count;
  enum bfd_architecture previous_arch = bfd_get_arch (abfd);
  unsigned long previous_mach = bfd_get_mach (abfd);
d541 1
a541 4
  /* Clear section information, since there might be a recognized bfd that
     we now check if we can replace, and we don't want to append to it.  */
  abfd->sections = NULL;
  abfd->section_count = 0;
d588 1
d591 12
a729 1
    }
d731 8
a738 8
  /* Read in the rest of the section header table and convert it to
     internal form.  */
  for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
    {
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, i_shdrp + shindex);
d740 10
a749 9
      /* If the section is loaded, but not page aligned, clear
         D_PAGED.  */
      if (i_shdrp[shindex].sh_size != 0
	  && (i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	  && i_shdrp[shindex].sh_type != SHT_NOBITS
	  && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
	       % ebd->maxpagesize)
	      != 0))
	abfd->flags &= ~D_PAGED;
d751 1
d838 4
a853 1
  bfd_default_set_arch_mach (abfd, previous_arch, previous_mach);
d855 1
d857 1
d859 11
a869 5
    bfd_release (abfd, new_tdata);
  elf_tdata (abfd) = preserved_tdata;
  abfd->sections = preserved_sections;
  abfd->section_count = preserved_section_count;
  return (NULL);
@


1.25
log
@	* elfcode.h (elf_swap_ehdr_out): Adjust value written for e_shnum
	and e_shstrndx if out of range.
	(elf_object_p): Read extended values for e_shnum and e_shstrndx
	from the first section header.  Allocate space in elf_elfsections
	for reserved sections and set to NULLs.
	(elf_write_shdrs_and_ehdr): Set overflow fields in first section
	header.  Skip reserved sections in elf_elfsections.  Remove
	duplicate size calculation.
@
text
@d206 1
a206 1
elf_swap_symbol_in (abfd, src, dst)
d209 1
d223 6
d235 1
a235 1
elf_swap_symbol_out (abfd, src, cdst)
d239 1
d241 1
d248 9
a256 1
  H_PUT_16 (abfd, src->st_shndx, dst->st_shndx);
d687 1
d693 5
a697 3
      amt = sizeof (i_shdrp) * i_ehdrp->e_shnum;
      if (i_ehdrp->e_shnum > SHN_LORESERVE)
	amt += sizeof (i_shdrp) * (SHN_HIRESERVE + 1 - SHN_LORESERVE);
d705 1
a705 1
      if (i_ehdrp->e_shnum > SHN_LORESERVE)
d710 1
a710 1
	    elf_elfsections (abfd)[shindex] = NULL;
d712 1
a712 1
      for ( ; shindex < i_ehdrp->e_shnum; shindex++)
d775 2
d784 2
a785 2

      for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
d789 2
a835 5
  if (new_tdata != NULL
      && new_tdata->elf_sect_ptr != NULL)
    bfd_release (abfd, new_tdata->elf_sect_ptr);
  if (i_shdrp != NULL)
    bfd_release (abfd, i_shdrp);
d1101 1
d1117 2
d1120 1
d1122 12
d1153 1
a1153 1
    return -1;
d1164 1
a1164 1
	return -1;
d1170 1
a1170 1
	return -1;
d1177 1
a1177 1
      if (x_symp == NULL && symcount != 0)
d1216 2
a1217 1
	  elf_swap_symbol_in (abfd, x_symp + i, &i_sym);
d1230 6
a1235 1
	  if (i_sym.st_shndx > 0 && i_sym.st_shndx < SHN_LORESERVE)
a1259 4
	  else if (i_sym.st_shndx == SHN_UNDEF)
	    {
	      sym->symbol.section = bfd_und_section_ptr;
	    }
d1346 2
d1353 1
d1355 2
@


1.24
log
@2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* bfd-in.h (bfd_elf32_discard_info): Add prototype.
	(bfd_elf64_discard_info): Likewise.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_reloc_cookie): New.
	(struct elf_backend_data): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and elf_backend_write_section.
	(_bfd_elf32_reloc_symbol_deleted_p): Add prototype.
	(_bfd_elf64_reloc_symbol_deleted_p): Likewise.
	* elf32-mips.c (_bfd_elf32_mips_discard_info): New.
	(_bfd_elf32_mips_ignore_discarded_relocs): New.
	(_bfd_elf32_mips_write_section): New.
	(elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	* elfcode.h (elf_bfd_discard_info): Define.
	(elf_reloc_symbol_deleted_p): Define.
	* elflink.h (elf_link_input_bfd): Check
	elf_section_ignore_discarded_relocs.  Call
	bed->elf_backend_write_section if available.
	(elf_reloc_symbol_deleted_p): New.
	(elf_bfd_discard_info): New.
	(elf_section_ignore_discarded_relocs): New.
	* elfxx-target.h (elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	(elfNN_bed): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and
	elf_backend_write_section.
	* libbfd-in.h (_bfd_discard_section_stabs): Add prototype.
	* libbfd.h: Regenerate.
	* stabs.c (_bfd_discard_section_stabs): New.

2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(struct ld_emulation_xfer_struct): Use it.
@
text
@d280 1
d298 8
a305 2
  H_PUT_16 (abfd, src->e_shnum, dst->e_shnum);
  H_PUT_16 (abfd, src->e_shstrndx, dst->e_shstrndx);
d504 1
d645 20
d666 1
a666 2
     internal form, seek to the section header table in the file,
     read it in, and convert it to internal form.  */
d669 2
d673 2
d676 2
d679 1
a679 3
      if (!i_shdrp || !elf_elfsections (abfd))
	goto got_no_match;
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
d681 13
d695 4
a698 1
  for (shindex = 0; shindex < i_ehdrp->e_shnum; shindex++)
a703 1
      elf_elfsections (abfd)[shindex] = i_shdrp + shindex;
d1036 7
d1044 2
a1045 1
  amt = sizeof (*x_shdrp) * i_ehdrp->e_shnum;
d1050 1
a1050 1
  for (count = 0; count < i_ehdrp->e_shnum; count++)
d1053 1
a1053 1
      elf_debug_section (count, i_shdrp[count]);
d1055 4
a1058 1
      elf_swap_shdr_out (abfd, i_shdrp[count], x_shdrp + count);
a1059 2
  amt = i_ehdrp->e_shnum;
  amt *= sizeof (*x_shdrp);
@


1.23
log
@2001-10-19  H.J. Lu <hjl@@gnu.org>

	* elfcode.h (elf_object_p): Don't clear D_PAGED if the section
	size is empty.
@
text
@d126 2
@


1.22
log
@	* elf-bfd.h (struct bfd_elf_section_data): Add "group" and
	"next_in_group".  Fix gp and gp_size comments.
	* elf.c (union elf_internal_group): New.
	(setup_group): New function.
	(_bfd_elf_make_section_from_shdr): Set BFD flags for SHT_GROUP.
	Call setup_group for SHF_GROUP sections.
	(bfd_section_from_shdr): Build a BFD section for SHT_GROUP.
	(elf_fake_sections): Set header type for SEC_GROUP, and header
	flags for sections in a group.
	(set_group_contents): New function.
	(_bfd_elf_compute_section_file_positions): Call it.
	(assign_section_numbers): Set sh_link for SHT_GROUP.
	* elflink.h (gc_mark_hook): Handle section groups.
	* elfxx-target.h: Add SEC_GROUP to applicable_flags.
	* section.c (SEC_GROUP): Define.
	(struct sec): Comment fixes.
	* bfd-in2.h: Regenerate.

	* elf.c (bfd_elf_print_symbol): Formatting fix; migrate expression
	out of function args.
	(_bfd_elf_canonicalize_reloc): Similarly.
	(_bfd_elf_get_symtab): Here too.
	(_bfd_elf_canonicalize_dynamic_symtab): And here.
	* elfcode.h (elf_slurp_symbol_table): Don't recalculate size for
	bfd_bread, and remove unnecessary cast.
@
text
@d659 2
a660 1
      if ((i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
@


1.21
log
@	* elfcode.h (elf_object_p): Allow for no section header at all in
	non-ET_REL files.  Honor 0 for e_shnum, e_shstrndx, e_shoff.
@
text
@d1087 1
a1087 4
      if (bfd_bread ((PTR) x_symp,
		    (bfd_size_type) (symcount * sizeof (Elf_External_Sym)),
		    abfd)
	  != symcount * sizeof (Elf_External_Sym))
d1115 1
a1115 1
	  if (bfd_bread ((PTR) x_versymp, (bfd_size_type) verhdr->sh_size, abfd)
@


1.20
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d571 3
a573 2
  /* If there is no section header table, we're hosed.  */
  if (i_ehdrp->e_shoff == 0)
d578 2
a579 2
     recorded in the file.  */
  if (i_ehdrp->e_shentsize != sizeof (x_shdr))
d638 11
a648 8
  amt = sizeof (*i_shdrp) * i_ehdrp->e_shnum;
  i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
  amt = sizeof (i_shdrp) * i_ehdrp->e_shnum;
  elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
  if (!i_shdrp || !elf_elfsections (abfd))
    goto got_no_match;
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
    goto got_no_match;
d704 5
a708 3
  shstrtab = bfd_elf_get_str_section (abfd, i_ehdrp->e_shstrndx);
  if (!shstrtab)
    goto got_no_match;
d710 3
a712 3
  /* Once all of the section headers have been read and converted, we
     can start processing them.  Note that the first section header is
     a dummy placeholder entry, so we ignore it.  */
d714 5
a718 4
  for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
    {
      if (! bfd_section_from_shdr (abfd, shindex))
	goto got_no_match;
@


1.19
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@d188 4
a191 4
#define put_word	bfd_h_put_64
#define put_signed_word	bfd_h_put_signed_64
#define get_word	bfd_h_get_64
#define get_signed_word	bfd_h_get_signed_64
d194 4
a197 4
#define put_word	bfd_h_put_32
#define put_signed_word	bfd_h_put_signed_32
#define get_word	bfd_h_get_32
#define get_signed_word	bfd_h_get_signed_32
d211 1
a211 1
  dst->st_name = bfd_h_get_32 (abfd, (bfd_byte *) src->st_name);
d213 1
a213 1
    dst->st_value = get_signed_word (abfd, (bfd_byte *) src->st_value);
d215 5
a219 5
    dst->st_value = get_word (abfd, (bfd_byte *) src->st_value);
  dst->st_size = get_word (abfd, (bfd_byte *) src->st_size);
  dst->st_info = bfd_h_get_8 (abfd, (bfd_byte *) src->st_info);
  dst->st_other = bfd_h_get_8 (abfd, (bfd_byte *) src->st_other);
  dst->st_shndx = bfd_h_get_16 (abfd, (bfd_byte *) src->st_shndx);
d232 6
a237 6
  bfd_h_put_32 (abfd, src->st_name, dst->st_name);
  put_word (abfd, src->st_value, dst->st_value);
  put_word (abfd, src->st_size, dst->st_size);
  bfd_h_put_8 (abfd, src->st_info, dst->st_info);
  bfd_h_put_8 (abfd, src->st_other, dst->st_other);
  bfd_h_put_16 (abfd, src->st_shndx, dst->st_shndx);
d251 3
a253 3
  dst->e_type = bfd_h_get_16 (abfd, (bfd_byte *) src->e_type);
  dst->e_machine = bfd_h_get_16 (abfd, (bfd_byte *) src->e_machine);
  dst->e_version = bfd_h_get_32 (abfd, (bfd_byte *) src->e_version);
d255 1
a255 1
    dst->e_entry = get_signed_word (abfd, (bfd_byte *) src->e_entry);
d257 10
a266 10
    dst->e_entry = get_word (abfd, (bfd_byte *) src->e_entry);
  dst->e_phoff = get_word (abfd, (bfd_byte *) src->e_phoff);
  dst->e_shoff = get_word (abfd, (bfd_byte *) src->e_shoff);
  dst->e_flags = bfd_h_get_32 (abfd, (bfd_byte *) src->e_flags);
  dst->e_ehsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_ehsize);
  dst->e_phentsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_phentsize);
  dst->e_phnum = bfd_h_get_16 (abfd, (bfd_byte *) src->e_phnum);
  dst->e_shentsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shentsize);
  dst->e_shnum = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shnum);
  dst->e_shstrndx = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shstrndx);
d281 3
a283 3
  bfd_h_put_16 (abfd, src->e_type, dst->e_type);
  bfd_h_put_16 (abfd, src->e_machine, dst->e_machine);
  bfd_h_put_32 (abfd, src->e_version, dst->e_version);
d285 1
a285 1
    put_signed_word (abfd, src->e_entry, dst->e_entry);
d287 10
a296 10
    put_word (abfd, src->e_entry, dst->e_entry);
  put_word (abfd, src->e_phoff, dst->e_phoff);
  put_word (abfd, src->e_shoff, dst->e_shoff);
  bfd_h_put_32 (abfd, src->e_flags, dst->e_flags);
  bfd_h_put_16 (abfd, src->e_ehsize, dst->e_ehsize);
  bfd_h_put_16 (abfd, src->e_phentsize, dst->e_phentsize);
  bfd_h_put_16 (abfd, src->e_phnum, dst->e_phnum);
  bfd_h_put_16 (abfd, src->e_shentsize, dst->e_shentsize);
  bfd_h_put_16 (abfd, src->e_shnum, dst->e_shnum);
  bfd_h_put_16 (abfd, src->e_shstrndx, dst->e_shstrndx);
d310 3
a312 3
  dst->sh_name = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_name);
  dst->sh_type = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_type);
  dst->sh_flags = get_word (abfd, (bfd_byte *) src->sh_flags);
d314 1
a314 1
    dst->sh_addr = get_signed_word (abfd, (bfd_byte *) src->sh_addr);
d316 7
a322 7
    dst->sh_addr = get_word (abfd, (bfd_byte *) src->sh_addr);
  dst->sh_offset = get_word (abfd, (bfd_byte *) src->sh_offset);
  dst->sh_size = get_word (abfd, (bfd_byte *) src->sh_size);
  dst->sh_link = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_link);
  dst->sh_info = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_info);
  dst->sh_addralign = get_word (abfd, (bfd_byte *) src->sh_addralign);
  dst->sh_entsize = get_word (abfd, (bfd_byte *) src->sh_entsize);
d337 10
a346 10
  bfd_h_put_32 (abfd, src->sh_name, dst->sh_name);
  bfd_h_put_32 (abfd, src->sh_type, dst->sh_type);
  put_word (abfd, src->sh_flags, dst->sh_flags);
  put_word (abfd, src->sh_addr, dst->sh_addr);
  put_word (abfd, src->sh_offset, dst->sh_offset);
  put_word (abfd, src->sh_size, dst->sh_size);
  bfd_h_put_32 (abfd, src->sh_link, dst->sh_link);
  bfd_h_put_32 (abfd, src->sh_info, dst->sh_info);
  put_word (abfd, src->sh_addralign, dst->sh_addralign);
  put_word (abfd, src->sh_entsize, dst->sh_entsize);
d360 3
a362 3
  dst->p_type = bfd_h_get_32 (abfd, (bfd_byte *) src->p_type);
  dst->p_flags = bfd_h_get_32 (abfd, (bfd_byte *) src->p_flags);
  dst->p_offset = get_word (abfd, (bfd_byte *) src->p_offset);
d365 2
a366 2
      dst->p_vaddr = get_signed_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_signed_word (abfd, (bfd_byte *) src->p_paddr);
d370 2
a371 2
      dst->p_vaddr = get_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_word (abfd, (bfd_byte *) src->p_paddr);
d373 3
a375 3
  dst->p_filesz = get_word (abfd, (bfd_byte *) src->p_filesz);
  dst->p_memsz = get_word (abfd, (bfd_byte *) src->p_memsz);
  dst->p_align = get_word (abfd, (bfd_byte *) src->p_align);
d385 8
a392 8
  bfd_h_put_32 (abfd, src->p_type, dst->p_type);
  put_word (abfd, src->p_offset, dst->p_offset);
  put_word (abfd, src->p_vaddr, dst->p_vaddr);
  put_word (abfd, src->p_paddr, dst->p_paddr);
  put_word (abfd, src->p_filesz, dst->p_filesz);
  put_word (abfd, src->p_memsz, dst->p_memsz);
  bfd_h_put_32 (abfd, src->p_flags, dst->p_flags);
  put_word (abfd, src->p_align, dst->p_align);
d402 2
a403 2
  dst->r_offset = get_word (abfd, (bfd_byte *) src->r_offset);
  dst->r_info = get_word (abfd, (bfd_byte *) src->r_info);
d412 3
a414 3
  dst->r_offset = get_word (abfd, (bfd_byte *) src->r_offset);
  dst->r_info = get_word (abfd, (bfd_byte *) src->r_info);
  dst->r_addend = get_signed_word (abfd, (bfd_byte *) src->r_addend);
d424 2
a425 2
  put_word (abfd, src->r_offset, dst->r_offset);
  put_word (abfd, src->r_info, dst->r_info);
d434 3
a436 3
  put_word (abfd, src->r_offset, dst->r_offset);
  put_word (abfd, src->r_info, dst->r_info);
  put_signed_word (abfd, src->r_addend, dst->r_addend);
d447 2
a448 2
  dst->d_tag = get_word (abfd, src->d_tag);
  dst->d_un.d_val = get_word (abfd, src->d_un.d_val);
d459 2
a460 2
  put_word (abfd, src->d_tag, dst->d_tag);
  put_word (abfd, src->d_un.d_val, dst->d_un.d_val);
d506 1
d515 2
a516 1
  if (bfd_read ((PTR) & x_ehdr, sizeof (x_ehdr), 1, abfd) != sizeof (x_ehdr))
d554 2
a555 2
  new_tdata = ((struct elf_obj_tdata *)
	       bfd_zalloc (abfd, sizeof (struct elf_obj_tdata)));
d637 4
a640 5
  i_shdrp = ((Elf_Internal_Shdr *)
	     bfd_alloc (abfd, sizeof (*i_shdrp) * i_ehdrp->e_shnum));
  elf_elfsections (abfd) = ((Elf_Internal_Shdr **)
			    bfd_alloc (abfd,
				       sizeof (i_shdrp) * i_ehdrp->e_shnum));
d643 1
a643 1
  if (bfd_seek (abfd, i_ehdrp->e_shoff, SEEK_SET) != 0)
d647 2
a648 1
      if (bfd_read ((PTR) & x_shdr, sizeof x_shdr, 1, abfd) != sizeof (x_shdr))
d676 2
a677 4
      elf_tdata (abfd)->phdr = ((Elf_Internal_Phdr *)
				bfd_alloc (abfd,
					   (i_ehdrp->e_phnum
					    * sizeof (Elf_Internal_Phdr))));
d680 1
a680 1
      if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0)
d687 1
a687 1
	  if (bfd_read ((PTR) &x_phdr, sizeof x_phdr, 1, abfd)
d939 1
a939 1
     int count;
d945 2
a946 2
      if (bfd_write (&extphdr, sizeof (Elf_External_Phdr), 1, abfd)
	  != sizeof (Elf_External_Phdr))
d964 1
d975 1
d977 1
a977 2
      || (bfd_write ((PTR) & x_ehdr, sizeof (x_ehdr), 1, abfd)
	  != sizeof (x_ehdr)))
d981 2
a982 2
  x_shdrp = (Elf_External_Shdr *)
    bfd_alloc (abfd, sizeof (*x_shdrp) * (i_ehdrp->e_shnum));
d993 2
d996 1
a996 2
      || (bfd_write ((PTR) x_shdrp, sizeof (*x_shdrp), i_ehdrp->e_shnum, abfd)
	  != sizeof (*x_shdrp) * i_ehdrp->e_shnum))
d1018 1
d1052 1
a1052 1
  if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) == -1)
d1063 1
a1063 1
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) == -1)
d1066 3
a1068 2
      symbase = ((elf_symbol_type *)
		 bfd_zalloc (abfd, symcount * sizeof (elf_symbol_type)));
d1074 3
a1076 2
      x_symp = ((Elf_External_Sym *)
		bfd_malloc (symcount * sizeof (Elf_External_Sym)));
d1080 3
a1082 1
      if (bfd_read ((PTR) x_symp, sizeof (Elf_External_Sym), symcount, abfd)
d1111 1
a1111 1
	  if (bfd_read ((PTR) x_versymp, 1, verhdr->sh_size, abfd)
d1281 1
a1281 1
  allocated = (PTR) bfd_malloc ((size_t) rel_hdr->sh_size);
d1286 1
a1286 1
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd)
d1372 1
d1408 2
a1409 3
  relents = ((arelent *)
	     bfd_alloc (abfd,
			(reloc_count + reloc_count2) * sizeof (arelent)));
@


1.18
log
@2001-05-03  H.J. Lu  <hjl@@gnu.org>

	* elfcode.h: Include "libiberty.h".

	* elflink.h (elf_link_add_object_symbols): Set
	elf_dt_name (abfd) to basename of the bfd filename.
	(NAME(bfd_elf,size_dynamic_sections)): Set vn_file to basename
	of the bfd filename.
@
text
@d1376 1
a1376 1
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
d1378 1
a1378 3
      reloc_count2 = (rel_hdr2
		      ? (rel_hdr2->sh_size / rel_hdr2->sh_entsize)
		      : 0);
d1395 1
a1395 1
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
@


1.17
log
@Update copyright notices
@
text
@d69 1
@


1.16
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* ecoffswap.h: Fix formatting.
	* elf-bfd.h: Likewise.
	* elfarm-nabi.c: Likewise.
	* elfarm-oabi.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-target.h: Likewise.
@
text
@d2 2
a3 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999, 2000 Free
   Software Foundation, Inc.
@


1.16.2.1
log
@Update copyright notices.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
@


1.16.2.2
log
@Merge from mainline.
@
text
@d1375 1
a1375 1
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
d1377 3
a1379 1
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);
d1396 1
a1396 1
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
@


1.15
log
@	* elfcode.h (elf_object_p): Also restore the bfd mach field on
	error, by calling bfd_default_set_arch_mach with incoming
	values.
@
text
@d200 1
a200 1
   format. */
d222 1
a222 1
   format. */
a238 1

d240 1
a240 1
   internal format. */
d269 1
a269 1
   external format. */
d279 1
a279 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
a297 1

d299 1
a299 1
   ELF section header table entry in internal format. */
d327 1
a327 1
   ELF section header table entry in external format. */
d335 1
a335 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
a347 1

d349 1
a349 1
   ELF program header table entry in internal format. */
d383 1
a383 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
d394 1
a394 1
/* Translate an ELF reloc from external format to internal format. */
d416 1
a416 1
/* Translate an ELF reloc from internal format to external format. */
a463 1

d525 1
a525 1
     file). */
d568 1
a568 1
  /* If there is no section header table, we're hosed. */
d574 1
a574 1
     recorded in the file. */
d628 1
a628 1
  /* Remember the entry point specified in the ELF file header. */
d694 1
a694 1
     will need the base pointer to this table later. */
d821 1
a821 1
  /* orelocation has the data, reloc_count has the count... */
d967 1
a967 1
  /* swap the header before spitting it out... */
d978 1
a978 1
  /* at this point we've concocted all the ELF sections... */
d996 1
a996 1
  /* need to dump the string table too... */
d1024 1
a1024 1
     build the caller's pointer vector. */
a1418 1

@


1.14
log
@	* elfcode.h (elf_object_p): Preserve and clear abfd section
 	information.  Restore at error.
@
text
@d505 2
d747 10
@


1.13
log
@* elfcode.h (elf_object_p): Use bfd_set_start_address and not
bfd_get_start_address.
(elf_swap_ehdr_in): Sign extend e_entry when applicable.
(elf_swap_ehdr_out): Ditto.
@
text
@d503 2
d508 5
d755 2
@


1.12
log
@Fix hash section entry size to match ELF standard.  Override for alpha-linux.
	* elf64-alpha.c (alpha_elf_size_info): New.
	(elf_backend_size_info): Define to alpha_elf_size_info.
	* elfcode.h (elf_size_info): Change hash bucket size to 4.
@
text
@d2 2
a3 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999 Free Software
   Foundation, Inc.
d249 1
d254 4
a257 1
  dst->e_entry = get_word (abfd, (bfd_byte *) src->e_entry);
d278 1
d284 4
a287 1
  put_word (abfd, src->e_entry, dst->e_entry);
d624 1
a624 1
  bfd_get_start_address (abfd) = i_ehdrp->e_entry;
@


1.11
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d1528 1
a1528 1
  ARCH_SIZE / 8,
@


1.10
log
@        * elf-bfd.h: Add prototypes for bfd_elf32_write_relocs,
        bfd_elf32_slurp_reloc_table, bfd_elf64_write_relocs, and
        bfd_elf64_slurp_reloc_table.

        * elfcode.h (elf_write_relocs, elf_slurp_reloc_table): New
        definitions to get external names.
        (elf_write_relocs): Renamed from write_relocs and make global.
        (elf_slurp_reloc_table): Make global.
        (_bfd_elf,size_info): Use elf_write_relocs instead of write_relocs.
@
text
@d170 1
a170 1
static boolean elf_slurp_reloc_table_from_section 
d1227 1
a1227 1
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of 
d1352 1
a1352 1
      reloc_count2 = (rel_hdr2 
d1376 2
a1377 2
  relents = ((arelent *) 
	     bfd_alloc (abfd, 
d1387 2
a1388 2
  
  if (rel_hdr2 
d1395 1
a1395 1
  
@


1.9
log
@        * elf-bfd.h (struct elf_backend_data): Reorder collect and
        type_change_ok; add sign_extend_vma.
        * elf32-mips.c (elf_backend_sign_extend_vma): Define.
        * elfcode.h (elf_swap_symbol_in): Mind be->sign_extend_vma.
        (elf_swap_shdr_in, elf_swap_phdr_in): Likewise.
        * elfxx-target.h (elf_backend_sign_extend_vma): Default.
        (elfNN_bed): Follow struture changes.
@
text
@d121 2
a172 4
static boolean elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));

static void write_relocs PARAMS ((bfd *, asection *, PTR));
d747 2
a748 2
static void
write_relocs (abfd, sec, data)
d1326 1
a1326 1
static boolean
d1534 1
a1534 1
  write_relocs,
@


1.8
log
@
Hackery to handle ix86 "jmp constant" as a pc-relative jump to the given
absolute address.
@
text
@d210 2
d213 4
a216 1
  dst->st_value = get_word (abfd, (bfd_byte *) src->st_value);
d303 2
d308 4
a311 1
  dst->sh_addr = get_word (abfd, (bfd_byte *) src->sh_addr);
d354 2
d359 10
a368 2
  dst->p_vaddr = get_word (abfd, (bfd_byte *) src->p_vaddr);
  dst->p_paddr = get_word (abfd, (bfd_byte *) src->p_paddr);
@


1.7
log
@	* elfcode.h (write_relocs): Handle an absolute symbol in REL
	relocs as we do for RELA relocs.
@
text
@d874 2
a875 1
	  if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
@


1.6
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d860 2
@


1.5
log
@	* elflink.h (elf_link_create_dynamic_sections): Handle non-standard
	hash-entry sizes.
	(size_dynamic_sections): Likewise.
	(elf_link_output_extsym): Likewise.
	* elf.c: (elf_fake_sections): Likewise.
	* libbfd.c (bfd_get): New macro.
	(bfd_put): Likewise.
	* bfd-in2.h: Regenerated.
	* elf-bfd.h (elf_size_info): Add hash_entry_size,
	int_rels_per_ext_rel, swap_dyn_out, swap_reloc_in, swap_reloc_out,
	wap_reloca_in, and swap_reloca_out.
	* elflink.h (elf_link_read_relocs_from_section): Adjust to handle
	multiple internal relocations per external relocation.
	(link_read_relocs): Likewise.
	(elf_bfd_final_link): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	* elfcode.h (elf_swap_dyn_out): Adjust type to match
	elf_swap_dyn_in.
	(size_info): Add entries for new fields.
	* elf64-mips.c (mips_elf64_swap_reloc_out): Enable.
	(mips_elf64_be_swap_reloc_in): New function.
	(mips_elf64_be_swap_reloc_out): Likewise.
	(mips_elf64_be_swap_reloca_in): Likewise.
	(mips_elf64_be_swap_reloca_out): Likewise.
	(mips_elf64_size_info): Add entries for new fields.
@
text
@d133 2
@


1.4
log
@	* elfcode.h (elf_slurp_reloc_table_from_section): Don't assume
	asect->reloc_count is valid.
@
text
@d426 1
a426 1
elf_swap_dyn_out (abfd, src, dst)
d429 1
a429 1
     Elf_External_Dyn *dst;
d431 2
d1505 2
a1506 1

d1515 6
a1520 1
  elf_swap_dyn_in
@


1.3
log
@	* elf32-mips.c (elf_mips_howto_table): Add R_MIPS_JALR.
	* elf64-mips.c (mips_elf64_howto_table_rel): Likewise.
	(mips_elf64_howto_table_rela): Likewise.
	* elfcode.h (elf_slurp_reloc_table_from_section): New function,
	split out from ...
	(elf_slurp_reloc_table): Here.  Use it to handle the case where a
	single section has two associated relocation sections.
@
text
@d1338 4
d1348 1
d1351 3
a1353 2
  relents = (arelent *) bfd_alloc (abfd, 
				   asect->reloc_count * sizeof (arelent));
@


1.2
log
@	* elf-bfd.h (elf_backend_data): Remove use_rela_p.  Add
	may_use_rel_p, may_use_rela_p, default_use_rela_p.
	(bfd_elf_section_data): Add use_rela_p.
	* elf.c (bfd_section_from_shdr): Set use_rela_p appropriately.
	(_bfd_elf_new_section_hook): Likewise.
	(elf_fake_sections): Use may_use_rela_p, etc., instead of
	use_rela_p.
	(_bfd_elf_copy_private_section_data): Copy use_rela_p.
	* elfcode.h (write_relocs): Determine whether or not use rela
	relocs based on the relocation section header.
	* elflink.c (_bfd_elf_create_dynamic_sections): Use default_use_rela_p
	instead of use_rela_p.
	* elfxx-target.h (elf_backend_may_use_relp): New macro.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elfNN_bed): Use them.
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d166 3
d1202 2
a1203 1
/* Read in and swap the external relocs.  */
d1206 2
a1207 1
elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
d1210 3
a1216 3
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  bfd_size_type reloc_count;
a1218 1
  arelent *relents;
a1222 24
  if (asect->relocation != NULL)
    return true;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return true;

      rel_hdr = &d->rel_hdr;
      reloc_count = asect->reloc_count;

      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  && reloc_count == rel_hdr->sh_size / rel_hdr->sh_entsize);
    }
  else
    {
      if (asect->_raw_size == 0)
	return true;

      rel_hdr = &d->this_hdr;
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
    }

a1233 4
  relents = (arelent *) bfd_alloc (abfd, reloc_count * sizeof (arelent));
  if (relents == NULL)
    goto error_return;

a1287 2
  asect->relocation = relents;

d1297 70
@


1.1
log
@Initial revision
@
text
@d732 1
a732 1
  int use_rela_p = get_elf_backend_data (abfd)->use_rela_p;
d759 10
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

