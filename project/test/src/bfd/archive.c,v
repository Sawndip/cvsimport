head	1.99;
access;
symbols
	sid-snapshot-20180601:1.99
	sid-snapshot-20180501:1.99
	sid-snapshot-20180401:1.99
	sid-snapshot-20180301:1.99
	sid-snapshot-20180201:1.99
	sid-snapshot-20180101:1.99
	sid-snapshot-20171201:1.99
	sid-snapshot-20171101:1.99
	sid-snapshot-20171001:1.99
	sid-snapshot-20170901:1.99
	sid-snapshot-20170801:1.99
	sid-snapshot-20170701:1.99
	sid-snapshot-20170601:1.99
	sid-snapshot-20170501:1.99
	sid-snapshot-20170401:1.99
	sid-snapshot-20170301:1.99
	sid-snapshot-20170201:1.99
	sid-snapshot-20170101:1.99
	sid-snapshot-20161201:1.99
	sid-snapshot-20161101:1.99
	sid-snapshot-20160901:1.99
	sid-snapshot-20160801:1.99
	sid-snapshot-20160701:1.99
	sid-snapshot-20160601:1.99
	sid-snapshot-20160501:1.99
	sid-snapshot-20160401:1.99
	sid-snapshot-20160301:1.99
	sid-snapshot-20160201:1.99
	sid-snapshot-20160101:1.99
	sid-snapshot-20151201:1.99
	sid-snapshot-20151101:1.99
	sid-snapshot-20151001:1.99
	sid-snapshot-20150901:1.99
	sid-snapshot-20150801:1.99
	sid-snapshot-20150701:1.99
	sid-snapshot-20150601:1.99
	sid-snapshot-20150501:1.99
	sid-snapshot-20150401:1.99
	sid-snapshot-20150301:1.99
	sid-snapshot-20150201:1.99
	sid-snapshot-20150101:1.99
	sid-snapshot-20141201:1.99
	sid-snapshot-20141101:1.99
	sid-snapshot-20141001:1.99
	sid-snapshot-20140901:1.99
	sid-snapshot-20140801:1.99
	sid-snapshot-20140701:1.99
	sid-snapshot-20140601:1.99
	sid-snapshot-20140501:1.99
	sid-snapshot-20140401:1.99
	sid-snapshot-20140301:1.99
	sid-snapshot-20140201:1.99
	sid-snapshot-20140101:1.99
	sid-snapshot-20131201:1.99
	sid-snapshot-20131101:1.99
	sid-snapshot-20131001:1.99
	binutils-2_24-branch:1.99.0.2
	binutils-2_24-branchpoint:1.99
	binutils-2_21_1:1.69.2.4
	sid-snapshot-20130901:1.99
	gdb_7_6_1-2013-08-30-release:1.98
	sid-snapshot-20130801:1.99
	sid-snapshot-20130701:1.99
	sid-snapshot-20130601:1.99
	sid-snapshot-20130501:1.99
	gdb_7_6-2013-04-26-release:1.98
	sid-snapshot-20130401:1.98
	binutils-2_23_2:1.87.4.1
	gdb_7_6-branch:1.98.0.2
	gdb_7_6-2013-03-12-branchpoint:1.98
	sid-snapshot-20130301:1.98
	sid-snapshot-20130201:1.95
	sid-snapshot-20130101:1.93
	sid-snapshot-20121201:1.92
	gdb_7_5_1-2012-11-29-release:1.87
	binutils-2_23_1:1.87
	sid-snapshot-20121101:1.92
	binutils-2_23:1.87
	sid-snapshot-20121001:1.92
	sid-snapshot-20120901:1.92
	gdb_7_5-2012-08-17-release:1.87
	sid-snapshot-20120801:1.87
	binutils-2_23-branch:1.87.0.4
	binutils-2_23-branchpoint:1.87
	gdb_7_5-branch:1.87.0.2
	gdb_7_5-2012-07-18-branchpoint:1.87
	sid-snapshot-20120701:1.85
	sid-snapshot-20120601:1.84
	sid-snapshot-20120501:1.82
	binutils-2_22_branch:1.77.2.2.0.2
	gdb_7_4_1-2012-04-26-release:1.79
	sid-snapshot-20120401:1.82
	sid-snapshot-20120301:1.82
	sid-snapshot-20120201:1.81
	gdb_7_4-2012-01-24-release:1.79
	sid-snapshot-20120101:1.79
	gdb_7_4-branch:1.79.0.2
	gdb_7_4-2011-12-13-branchpoint:1.79
	sid-snapshot-20111201:1.79
	binutils-2_22:1.77.2.2
	sid-snapshot-20111101:1.79
	sid-snapshot-20111001:1.77
	binutils-2_22-branch:1.77.0.2
	binutils-2_22-branchpoint:1.77
	gdb_7_3_1-2011-09-04-release:1.74
	sid-snapshot-20110901:1.77
	sid-snapshot-20110801:1.77
	gdb_7_3-2011-07-26-release:1.74
	sid-snapshot-20110701:1.77
	sid-snapshot-20110601:1.77
	sid-snapshot-20110501:1.75
	gdb_7_3-branch:1.74.0.2
	gdb_7_3-2011-04-01-branchpoint:1.74
	sid-snapshot-20110401:1.74
	sid-snapshot-20110301:1.72
	sid-snapshot-20110201:1.70
	sid-snapshot-20110101:1.70
	binutils-2_21:1.69.2.1
	sid-snapshot-20101201:1.70
	binutils-2_21-branch:1.69.0.2
	binutils-2_21-branchpoint:1.69
	sid-snapshot-20101101:1.69
	sid-snapshot-20101001:1.68
	binutils-2_20_1:1.58.2.1
	gdb_7_2-2010-09-02-release:1.67
	sid-snapshot-20100901:1.68
	sid-snapshot-20100801:1.68
	gdb_7_2-branch:1.67.0.2
	gdb_7_2-2010-07-07-branchpoint:1.67
	sid-snapshot-20100701:1.67
	sid-snapshot-20100601:1.67
	sid-snapshot-20100501:1.66
	sid-snapshot-20100401:1.66
	gdb_7_1-2010-03-18-release:1.64
	sid-snapshot-20100301:1.64
	gdb_7_1-branch:1.64.0.2
	gdb_7_1-2010-02-18-branchpoint:1.64
	sid-snapshot-20100201:1.64
	sid-snapshot-20100101:1.60
	gdb_7_0_1-2009-12-22-release:1.59
	sid-snapshot-20091201:1.59
	sid-snapshot-20091101:1.59
	binutils-2_20:1.58.2.1
	gdb_7_0-2009-10-06-release:1.59
	sid-snapshot-20091001:1.59
	gdb_7_0-branch:1.59.0.2
	gdb_7_0-2009-09-16-branchpoint:1.59
	arc-sim-20090309:1.51
	binutils-arc-20081103-branch:1.55.0.12
	binutils-arc-20081103-branchpoint:1.55
	binutils-2_20-branch:1.58.0.2
	binutils-2_20-branchpoint:1.58
	sid-snapshot-20090901:1.57
	sid-snapshot-20090801:1.57
	msnyder-checkpoint-072509-branch:1.56.0.4
	msnyder-checkpoint-072509-branchpoint:1.56
	sid-snapshot-20090701:1.56
	dje-cgen-play1-branch:1.56.0.2
	dje-cgen-play1-branchpoint:1.56
	sid-snapshot-20090601:1.56
	sid-snapshot-20090501:1.56
	sid-snapshot-20090401:1.56
	arc-20081103-branch:1.55.0.10
	arc-20081103-branchpoint:1.55
	arc-insight_6_8-branch:1.51.0.10
	arc-insight_6_8-branchpoint:1.51
	insight_6_8-branch:1.51.0.8
	insight_6_8-branchpoint:1.51
	sid-snapshot-20090301:1.55
	binutils-2_19_1:1.55
	sid-snapshot-20090201:1.55
	sid-snapshot-20090101:1.55
	reverse-20081226-branch:1.55.0.8
	reverse-20081226-branchpoint:1.55
	sid-snapshot-20081201:1.55
	multiprocess-20081120-branch:1.55.0.6
	multiprocess-20081120-branchpoint:1.55
	sid-snapshot-20081101:1.55
	binutils-2_19:1.55
	sid-snapshot-20081001:1.55
	reverse-20080930-branch:1.55.0.4
	reverse-20080930-branchpoint:1.55
	binutils-2_19-branch:1.55.0.2
	binutils-2_19-branchpoint:1.55
	sid-snapshot-20080901:1.55
	sid-snapshot-20080801:1.54
	reverse-20080717-branch:1.54.0.4
	reverse-20080717-branchpoint:1.54
	sid-snapshot-20080701:1.54
	msnyder-reverse-20080609-branch:1.54.0.2
	msnyder-reverse-20080609-branchpoint:1.54
	drow-reverse-20070409-branch:1.47.0.4
	drow-reverse-20070409-branchpoint:1.47
	sid-snapshot-20080601:1.54
	sid-snapshot-20080501:1.54
	sid-snapshot-20080403:1.53
	sid-snapshot-20080401:1.53
	gdb_6_8-2008-03-27-release:1.51
	sid-snapshot-20080301:1.51
	gdb_6_8-branch:1.51.0.6
	gdb_6_8-2008-02-26-branchpoint:1.51
	sid-snapshot-20080201:1.51
	sid-snapshot-20080101:1.51
	sid-snapshot-20071201:1.51
	sid-snapshot-20071101:1.51
	gdb_6_7_1-2007-10-29-release:1.51
	gdb_6_7-2007-10-10-release:1.51
	sid-snapshot-20071001:1.51
	gdb_6_7-branch:1.51.0.4
	gdb_6_7-2007-09-07-branchpoint:1.51
	binutils-2_18:1.51
	binutils-2_18-branch:1.51.0.2
	binutils-2_18-branchpoint:1.51
	insight_6_6-20070208-release:1.47
	binutils-csl-coldfire-4_1-32:1.43
	binutils-csl-sourcerygxx-4_1-32:1.43
	gdb_6_6-2006-12-18-release:1.47
	binutils-csl-innovasic-fido-3_4_4-33:1.43
	binutils-csl-sourcerygxx-3_4_4-32:1.34
	binutils-csl-coldfire-4_1-30:1.43
	binutils-csl-sourcerygxx-4_1-30:1.43
	binutils-csl-coldfire-4_1-28:1.43
	binutils-csl-sourcerygxx-4_1-29:1.43
	binutils-csl-sourcerygxx-4_1-28:1.43
	gdb_6_6-branch:1.47.0.2
	gdb_6_6-2006-11-15-branchpoint:1.47
	binutils-csl-arm-2006q3-27:1.43
	binutils-csl-sourcerygxx-4_1-27:1.43
	binutils-csl-arm-2006q3-26:1.43
	binutils-csl-sourcerygxx-4_1-26:1.43
	binutils-csl-sourcerygxx-4_1-25:1.43
	binutils-csl-sourcerygxx-4_1-24:1.43
	binutils-csl-sourcerygxx-4_1-23:1.43
	insight_6_5-20061003-release:1.44
	gdb-csl-symbian-6_4_50_20060226-12:1.43
	binutils-csl-sourcerygxx-4_1-21:1.43
	binutils-csl-arm-2006q3-21:1.43
	binutils-csl-sourcerygxx-4_1-22:1.43
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.43
	binutils-csl-sourcerygxx-4_1-20:1.43
	binutils-csl-arm-2006q3-19:1.43
	binutils-csl-sourcerygxx-4_1-19:1.43
	binutils-csl-sourcerygxx-4_1-18:1.43
	binutils-csl-renesas-4_1-9:1.43
	gdb-csl-sourcerygxx-3_4_4-25:1.43
	binutils-csl-sourcerygxx-3_4_4-25:1.34
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.43
	binutils-csl-renesas-4_1-8:1.43
	binutils-csl-renesas-4_1-7:1.43
	binutils-csl-renesas-4_1-6:1.43
	gdb-csl-sourcerygxx-4_1-17:1.43
	binutils-csl-sourcerygxx-4_1-17:1.43
	gdb-csl-20060226-branch-local-2:1.43
	gdb-csl-sourcerygxx-4_1-14:1.43
	binutils-csl-sourcerygxx-4_1-14:1.43
	binutils-csl-sourcerygxx-4_1-15:1.43
	gdb-csl-sourcerygxx-4_1-13:1.43
	binutils-csl-sourcerygxx-4_1-13:1.43
	binutils-2_17:1.43
	gdb-csl-sourcerygxx-4_1-12:1.43
	binutils-csl-sourcerygxx-4_1-12:1.43
	gdb-csl-sourcerygxx-3_4_4-21:1.43
	binutils-csl-sourcerygxx-3_4_4-21:1.43
	gdb_6_5-20060621-release:1.44
	binutils-csl-wrs-linux-3_4_4-24:1.34
	binutils-csl-wrs-linux-3_4_4-23:1.34
	gdb-csl-sourcerygxx-4_1-9:1.43
	binutils-csl-sourcerygxx-4_1-9:1.43
	gdb-csl-sourcerygxx-4_1-8:1.43
	binutils-csl-sourcerygxx-4_1-8:1.43
	gdb-csl-sourcerygxx-4_1-7:1.43
	binutils-csl-sourcerygxx-4_1-7:1.43
	gdb-csl-arm-2006q1-6:1.43
	binutils-csl-arm-2006q1-6:1.43
	gdb-csl-sourcerygxx-4_1-6:1.43
	binutils-csl-sourcerygxx-4_1-6:1.43
	binutils-csl-wrs-linux-3_4_4-22:1.34
	gdb-csl-symbian-6_4_50_20060226-10:1.43
	gdb-csl-symbian-6_4_50_20060226-9:1.43
	gdb-csl-symbian-6_4_50_20060226-8:1.43
	gdb-csl-coldfire-4_1-11:1.43
	binutils-csl-coldfire-4_1-11:1.43
	gdb-csl-sourcerygxx-3_4_4-19:1.43
	binutils-csl-sourcerygxx-3_4_4-19:1.43
	gdb-csl-coldfire-4_1-10:1.43
	gdb_6_5-branch:1.44.0.4
	gdb_6_5-2006-05-14-branchpoint:1.44
	binutils-csl-coldfire-4_1-10:1.43
	gdb-csl-sourcerygxx-4_1-5:1.43
	binutils-csl-sourcerygxx-4_1-5:1.43
	nickrob-async-20060513-branch:1.44.0.2
	nickrob-async-20060513-branchpoint:1.44
	gdb-csl-sourcerygxx-4_1-4:1.43
	binutils-csl-sourcerygxx-4_1-4:1.43
	msnyder-reverse-20060502-branch:1.43.0.24
	msnyder-reverse-20060502-branchpoint:1.43
	binutils-csl-wrs-linux-3_4_4-21:1.34
	gdb-csl-morpho-4_1-4:1.43
	binutils-csl-morpho-4_1-4:1.43
	gdb-csl-sourcerygxx-3_4_4-17:1.43
	binutils-csl-sourcerygxx-3_4_4-17:1.43
	binutils-csl-wrs-linux-3_4_4-20:1.34
	readline_5_1-import-branch:1.43.0.22
	readline_5_1-import-branchpoint:1.43
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.43
	binutils-2_17-branch:1.43.0.20
	binutils-2_17-branchpoint:1.43
	gdb-csl-symbian-20060226-branch:1.43.0.18
	gdb-csl-symbian-20060226-branchpoint:1.43
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.43
	msnyder-reverse-20060331-branch:1.43.0.16
	msnyder-reverse-20060331-branchpoint:1.43
	binutils-csl-2_17-branch:1.43.0.14
	binutils-csl-2_17-branchpoint:1.43
	gdb-csl-available-20060303-branch:1.43.0.12
	gdb-csl-available-20060303-branchpoint:1.43
	gdb-csl-20060226-branch:1.43.0.10
	gdb-csl-20060226-branchpoint:1.43
	gdb_6_4-20051202-release:1.43
	msnyder-fork-checkpoint-branch:1.43.0.8
	msnyder-fork-checkpoint-branchpoint:1.43
	gdb-csl-gxxpro-6_3-branch:1.43.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.43
	gdb_6_4-branch:1.43.0.4
	gdb_6_4-2005-11-01-branchpoint:1.43
	gdb-csl-arm-20051020-branch:1.43.0.2
	gdb-csl-arm-20051020-branchpoint:1.43
	binutils-csl-gxxpro-3_4-branch:1.34.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.34
	binutils-2_16_1:1.34
	msnyder-tracepoint-checkpoint-branch:1.39.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.39
	gdb-csl-arm-20050325-2005-q1b:1.37
	binutils-csl-arm-2005q1b:1.34
	binutils-2_16:1.34
	gdb-csl-arm-20050325-2005-q1a:1.37
	binutils-csl-arm-2005q1a:1.34
	csl-arm-20050325-branch:1.37.0.2
	csl-arm-20050325-branchpoint:1.37
	binutils-csl-arm-2005q1-branch:1.34.0.4
	binutils-csl-arm-2005q1-branchpoint:1.34
	binutils-2_16-branch:1.34.0.2
	binutils-2_16-branchpoint:1.34
	csl-arm-2004-q3d:1.31
	gdb_6_3-20041109-release:1.31
	gdb_6_3-branch:1.31.0.4
	gdb_6_3-20041019-branchpoint:1.31
	csl-arm-2004-q3:1.31
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.28
	binutils-2_15:1.28.12.1
	binutils-2_15-branchpoint:1.28
	csl-arm-2004-q1a:1.29
	csl-arm-2004-q1:1.29
	gdb_6_1-2004-04-05-release:1.28
	drow_intercu-merge-20040402:1.29
	drow_intercu-merge-20040327:1.29
	ezannoni_pie-20040323-branch:1.29.0.2
	ezannoni_pie-20040323-branchpoint:1.29
	cagney_tramp-20040321-mergepoint:1.29
	cagney_tramp-20040309-branch:1.28.0.18
	cagney_tramp-20040309-branchpoint:1.28
	gdb_6_1-branch:1.28.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.28
	drow_intercu-20040221-branch:1.28.0.14
	drow_intercu-20040221-branchpoint:1.28
	binutils-2_15-branch:1.28.0.12
	cagney_bfdfile-20040213-branch:1.28.0.10
	cagney_bfdfile-20040213-branchpoint:1.28
	drow-cplus-merge-20040208:1.28
	carlton_dictionary-20040126-merge:1.28
	cagney_bigcore-20040122-branch:1.28.0.8
	cagney_bigcore-20040122-branchpoint:1.28
	drow-cplus-merge-20040113:1.28
	csl-arm-2003-q4:1.28
	drow-cplus-merge-20031224:1.28
	drow-cplus-merge-20031220:1.28
	carlton_dictionary-20031215-merge:1.28
	drow-cplus-merge-20031214:1.28
	carlton-dictionary-20031111-merge:1.28
	gdb_6_0-2003-10-04-release:1.27
	kettenis_sparc-20030918-branch:1.28.0.6
	kettenis_sparc-20030918-branchpoint:1.28
	carlton_dictionary-20030917-merge:1.28
	ezannoni_pie-20030916-branchpoint:1.28
	ezannoni_pie-20030916-branch:1.28.0.4
	cagney_x86i386-20030821-branch:1.28.0.2
	cagney_x86i386-20030821-branchpoint:1.28
	carlton_dictionary-20030805-merge:1.28
	carlton_dictionary-20030627-merge:1.27
	gdb_6_0-branch:1.27.0.36
	gdb_6_0-2003-06-23-branchpoint:1.27
	jimb-ppc64-linux-20030613-branch:1.27.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.27
	binutils-2_14:1.27
	cagney_convert-20030606-branch:1.27.0.32
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.27.0.30
	cagney_writestrings-20030508-branchpoint:1.27
	jimb-ppc64-linux-20030528-branch:1.27.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.27
	carlton_dictionary-20030523-merge:1.27
	cagney_fileio-20030521-branch:1.27.0.26
	cagney_fileio-20030521-branchpoint:1.27
	kettenis_i386newframe-20030517-mergepoint:1.27
	jimb-ppc64-linux-20030509-branch:1.27.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.27
	kettenis_i386newframe-20030504-mergepoint:1.27
	carlton_dictionary-20030430-merge:1.27
	binutils-2_14-branch:1.27.0.22
	binutils-2_14-branchpoint:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.20
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.18
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.16
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.27.0.14
	cagney_framebase-20030326-branchpoint:1.27
	cagney_lazyid-20030317-branch:1.27.0.12
	cagney_lazyid-20030317-branchpoint:1.27
	kettenis-i386newframe-20030316-mergepoint:1.27
	offbyone-20030313-branch:1.27.0.10
	offbyone-20030313-branchpoint:1.27
	kettenis-i386newframe-20030308-branch:1.27.0.8
	kettenis-i386newframe-20030308-branchpoint:1.27
	carlton_dictionary-20030305-merge:1.27
	cagney_offbyone-20030303-branch:1.27.0.6
	cagney_offbyone-20030303-branchpoint:1.27
	carlton_dictionary-20030207-merge:1.27
	interps-20030202-branch:1.27.0.4
	interps-20030202-branchpoint:1.27
	cagney-unwind-20030108-branch:1.27.0.2
	cagney-unwind-20030108-branchpoint:1.27
	binutils-2_13_2_1:1.23.2.2
	binutils-2_13_2:1.23.2.2
	carlton_dictionary-20021223-merge:1.27
	gdb_5_3-2002-12-12-release:1.24
	carlton_dictionary-20021115-merge:1.26
	binutils-2_13_1:1.23.2.2
	kseitz_interps-20021105-merge:1.26
	kseitz_interps-20021103-merge:1.26
	drow-cplus-merge-20021020:1.24
	drow-cplus-merge-20021025:1.25
	carlton_dictionary-20021025-merge:1.26
	carlton_dictionary-20021011-merge:1.24
	drow-cplus-branch:1.24.0.12
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.24
	carlton_dictionary-branch:1.24.0.10
	carlton_dictionary-20020920-branchpoint:1.24
	sid-20020905-branchpoint:1.24
	sid-20020905-branch:1.24.0.8
	gdb_5_3-branch:1.24.0.6
	gdb_5_3-2002-09-04-branchpoint:1.24
	kseitz_interps-20020829-merge:1.24
	cagney_sysregs-20020825-branch:1.24.0.4
	cagney_sysregs-20020825-branchpoint:1.24
	readline_4_3-import-branch:1.24.0.2
	readline_4_3-import-branchpoint:1.24
	binutils-2_13:1.23
	gdb_5_2_1-2002-07-23-release:1.20
	binutils-2_13-branchpoint:1.23
	binutils-2_13-branch:1.23.0.2
	kseitz_interps-20020528-branch:1.22.0.6
	kseitz_interps-20020528-branchpoint:1.22
	cagney_regbuf-20020515-branch:1.22.0.4
	cagney_regbuf-20020515-branchpoint:1.22
	binutils-2_12_1:1.20.2.1
	jimb-macro-020506-branch:1.22.0.2
	jimb-macro-020506-branchpoint:1.22
	gdb_5_2-2002-04-29-release:1.20
	binutils-2_12:1.20
	gdb_5_2-branch:1.20.0.4
	gdb_5_2-2002-03-03-branchpoint:1.20
	binutils-2_12-branch:1.20.0.2
	binutils-2_12-branchpoint:1.20
	gdb_5_1_1-2002-01-24-release:1.14
	gdb_5_1_0_1-2002-01-03-release:1.14
	cygnus_cvs_20020108_pre:1.20
	gdb_5_1_0_1-2002-01-03-branch:1.14.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.14
	gdb_5_1-2001-11-21-release:1.14
	gdb_s390-2001-09-26-branch:1.14.0.4
	gdb_s390-2001-09-26-branchpoint:1.14
	gdb_5_1-2001-07-29-branch:1.14.0.2
	gdb_5_1-2001-07-29-branchpoint:1.14
	binutils-2_11_2:1.13.2.1
	binutils-2_11_1:1.13.2.1
	binutils-2_11:1.13
	x86_64versiong3:1.13
	binutils-2_11-branch:1.13.0.2
	insight-precleanup-2001-01-01:1.13
	binutils-2_10_1:1.5.2.1
	binutils-2_10:1.5.2.1
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.4
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.99
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.99
date	2013.04.15.03.13.20;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2013.02.15.18.26.06;	author hjl;	state Exp;
branches;
next	1.97;

1.97
date	2013.02.15.15.53.42;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2013.02.15.14.37.38;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.28.07.58.16;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.93;

1.93
date	2012.12.09.18.01.39;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2012.08.20.14.32.30;	author tromey;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.17.01.06.27;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2012.08.16.14.24.44;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2012.08.09.06.25.52;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2012.08.07.13.47.14;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2012.07.13.14.22.42;	author nickc;	state Exp;
branches
	1.87.4.1;
next	1.86;

1.86
date	2012.07.03.16.25.16;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2012.06.29.17.36.21;	author hjl;	state Exp;
branches;
next	1.84;

1.84
date	2012.05.18.16.38.22;	author roland;	state Exp;
branches;
next	1.83;

1.83
date	2012.05.16.13.00.29;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2012.02.02.11.35.31;	author gingold;	state Exp;
branches;
next	1.81;

1.81
date	2012.01.20.14.42.57;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2012.01.10.11.51.09;	author gingold;	state Exp;
branches;
next	1.79;

1.79
date	2011.10.11.06.44.13;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2011.10.11.06.30.20;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2011.05.31.14.27.39;	author nickc;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2011.05.27.10.52.30;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.20.07.00.46;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2011.03.04.01.43.24;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.03.23.41.21;	author msnyder;	state Exp;
branches;
next	1.72;

1.72
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.71;

1.71
date	2011.02.28.07.46.37;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2010.11.12.22.10.18;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.29.12.10.23;	author hjl;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2010.07.22.14.48.54;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.25.10.14.13;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.01.09.47.13;	author gingold;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.26.01.40.40;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.13.08.48.26;	author gingold;	state Exp;
branches;
next	1.62;

1.62
date	2010.01.11.15.29.36;	author gingold;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.08.11.15.39;	author gingold;	state Exp;
branches;
next	1.60;

1.60
date	2009.12.11.13.42.00;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.02.07.18.35;	author amodra;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2009.07.28.06.22.01;	author jbeulich;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.11.04.36.39;	author cgd;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.10.18.49.09;	author palves;	state Exp;
branches;
next	1.54;

1.54
date	2008.04.22.00.12.23;	author ccoutant;	state Exp;
branches;
next	1.53;

1.53
date	2008.03.31.23.44.47;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.27.00.49.06;	author nemet;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.30.07.41.17;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.23.17.20.08;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.02.10.01.56;	author bje;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.05.21.24.23;	author bwilson;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.05.09.45.54;	author jakub;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.16.08.05.39;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.14.11.04.22;	author jakub;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.04.15.53.00;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.11.16.37.17;	author jakub;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.10.21.26.53;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.10.00.29.35;	author bje;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.03.11.40.56;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.24.20.16.55;	author bje;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.31.23.13.14;	author bje;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.19.14.46.59;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.05.15.39.11;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.15.12.23.10;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.29.10.06.38;	author amodra;	state Exp;
branches
	1.28.12.1
	1.28.14.1
	1.28.18.1;
next	1.27;

1.27
date	2002.11.30.08.39.34;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.21.01.58.48;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.24.10.1
	1.24.12.1;
next	1.23;

1.23
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.03.21.09.15.12;	author amodra;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2002.03.18.01.26.57;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.05.22.46.21;	author ths;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.19.05.33.11;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.19.23.42.47;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.17.03.19.01;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.25.21.41.20;	author aoliva;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.11.20.19.05.12;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.10.04.28.20;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.08.23.46.41;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.17.40.23;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.20.12.33.20;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.26.13.11.55;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.07.52.50;	author law;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.18.51.34;	author nickc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.12.10.01.41.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.19.49.24;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.27.22.48.49;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.87.4.1
date	2012.12.09.18.06.44;	author hjl;	state Exp;
branches;
next	;

1.77.2.1
date	2011.10.25.03.03.14;	author amodra;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2011.10.25.03.04.34;	author amodra;	state Exp;
branches;
next	;

1.69.2.1
date	2010.12.07.12.14.14;	author hjl;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2011.02.28.07.47.04;	author amodra;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2011.03.04.01.44.21;	author amodra;	state Exp;
branches;
next	1.69.2.4;

1.69.2.4
date	2011.05.29.04.50.56;	author amodra;	state Exp;
branches;
next	;

1.58.2.1
date	2009.09.09.21.40.17;	author nickc;	state Exp;
branches;
next	;

1.28.12.1
date	2004.03.15.13.17.38;	author amodra;	state Exp;
branches;
next	;

1.28.14.1
date	2004.03.27.17.37.30;	author drow;	state Exp;
branches;
next	1.28.14.2;

1.28.14.2
date	2004.09.16.17.00.11;	author drow;	state Exp;
branches;
next	;

1.28.18.1
date	2004.03.21.23.57.24;	author cagney;	state Exp;
branches;
next	;

1.24.10.1
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.24.10.2;

1.24.10.2
date	2002.12.23.19.37.22;	author carlton;	state Exp;
branches;
next	1.24.10.3;

1.24.10.3
date	2003.08.05.17.12.43;	author carlton;	state Exp;
branches;
next	;

1.24.12.1
date	2002.10.26.17.11.55;	author drow;	state Exp;
branches;
next	1.24.12.2;

1.24.12.2
date	2003.12.14.20.26.33;	author drow;	state Exp;
branches;
next	;

1.23.2.1
date	2002.09.23.22.12.37;	author drow;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.10.28.18.45.42;	author drow;	state Exp;
branches;
next	;

1.22.6.1
date	2002.07.22.21.46.38;	author kseitz;	state Exp;
branches;
next	1.22.6.2;

1.22.6.2
date	2002.08.09.18.34.10;	author kseitz;	state Exp;
branches;
next	1.22.6.3;

1.22.6.3
date	2002.11.03.22.01.33;	author ezannoni;	state Exp;
branches;
next	;

1.20.2.1
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	;

1.13.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2000.05.28.10.57.49;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.99
log
@	* archive.c (_bfd_archive_close_and_cleanup): Clear parent
	cache slot for archives.
@
text
@/* BFD back-end for archive files (libraries).
   Copyright 1990-2013 Free Software Foundation, Inc.
   Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

/*
@@setfilename archive-info
SECTION
	Archives

DESCRIPTION
	An archive (or library) is just another BFD.  It has a symbol
	table, although there's not much a user program will do with it.

	The big difference between an archive BFD and an ordinary BFD
	is that the archive doesn't have sections.  Instead it has a
	chain of BFDs that are considered its contents.  These BFDs can
	be manipulated like any other.  The BFDs contained in an
	archive opened for reading will all be opened for reading.  You
	may put either input or output BFDs into an archive opened for
	output; they will be handled correctly when the archive is closed.

	Use <<bfd_openr_next_archived_file>> to step through
	the contents of an archive opened for input.  You don't
	have to read the entire archive if you don't want
	to!  Read it until you find what you want.

	A BFD returned by <<bfd_openr_next_archived_file>> can be
	closed manually with <<bfd_close>>.  If you do not close it,
	then a second iteration through the members of an archive may
	return the same BFD.  If you close the archive BFD, then all
	the member BFDs will automatically be closed as well.

	Archive contents of output BFDs are chained through the
	<<archive_next>> pointer in a BFD.  The first one is findable
	through the <<archive_head>> slot of the archive.  Set it with
	<<bfd_set_archive_head>> (q.v.).  A given BFD may be in only
	one open output archive at a time.

	As expected, the BFD archive code is more general than the
	archive code of any given environment.  BFD archives may
	contain files of different formats (e.g., a.out and coff) and
	even different architectures.  You may even place archives
	recursively into archives!

	This can cause unexpected confusion, since some archive
	formats are more expressive than others.  For instance, Intel
	COFF archives can preserve long filenames; SunOS a.out archives
	cannot.  If you move a file from the first to the second
	format and back again, the filename may be truncated.
	Likewise, different a.out environments have different
	conventions as to how they truncate filenames, whether they
	preserve directory names in filenames, etc.  When
	interoperating with native tools, be sure your files are
	homogeneous.

	Beware: most of these formats do not react well to the
	presence of spaces in filenames.  We do the best we can, but
	can't always handle this case due to restrictions in the format of
	archives.  Many Unix utilities are braindead in regards to
	spaces and such in filenames anyway, so this shouldn't be much
	of a restriction.

	Archives are supported in BFD in <<archive.c>>.

SUBSECTION
	Archive functions
*/

/* Assumes:
   o - all archive elements start on an even boundary, newline padded;
   o - all arch headers are char *;
   o - all arch headers are the same size (across architectures).
*/

/* Some formats provide a way to cram a long filename into the short
   (16 chars) space provided by a BSD archive.  The trick is: make a
   special "file" in the front of the archive, sort of like the SYMDEF
   entry.  If the filename is too long to fit, put it in the extended
   name table, and use its index as the filename.  To prevent
   confusion prepend the index with a space.  This means you can't
   have filenames that start with a space, but then again, many Unix
   utilities can't handle that anyway.

   This scheme unfortunately requires that you stand on your head in
   order to write an archive since you need to put a magic file at the
   front, and need to touch every entry to do so.  C'est la vie.

   We support two variants of this idea:
   The SVR4 format (extended name table is named "//"),
   and an extended pseudo-BSD variant (extended name table is named
   "ARFILENAMES/").  The origin of the latter format is uncertain.

   BSD 4.4 uses a third scheme:  It writes a long filename
   directly after the header.  This allows 'ar q' to work.
*/

/* Summary of archive member names:

 Symbol table (must be first):
 "__.SYMDEF       " - Symbol table, Berkeley style, produced by ranlib.
 "/               " - Symbol table, system 5 style.

 Long name table (must be before regular file members):
 "//              " - Long name table, System 5 R4 style.
 "ARFILENAMES/    " - Long name table, non-standard extended BSD (not BSD 4.4).

 Regular file members with short names:
 "filename.o/     " - Regular file, System 5 style (embedded spaces ok).
 "filename.o      " - Regular file, Berkeley style (no embedded spaces).

 Regular files with long names (or embedded spaces, for BSD variants):
 "/18             " - SVR4 style, name at offset 18 in name table.
 "#1/23           " - Long name (or embedded spaces) 23 characters long,
		      BSD 4.4 style, full name follows header.
 " 18             " - Long name 18 characters long, extended pseudo-BSD.
 */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "libbfd.h"
#include "aout/ar.h"
#include "aout/ranlib.h"
#include "safe-ctype.h"
#include "hashtab.h"
#include "filenames.h"

#ifndef errno
extern int errno;
#endif

/* We keep a cache of archive filepointers to archive elements to
   speed up searching the archive by filepos.  We only add an entry to
   the cache when we actually read one.  We also don't sort the cache;
   it's generally short enough to search linearly.
   Note that the pointers here point to the front of the ar_hdr, not
   to the front of the contents!  */
struct ar_cache
{
  file_ptr ptr;
  bfd *arbfd;
};

#define ar_padchar(abfd) ((abfd)->xvec->ar_pad_char)
#define ar_maxnamelen(abfd) ((abfd)->xvec->ar_max_namelen)

#define arch_eltdata(bfd) ((struct areltdata *) ((bfd)->arelt_data))
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata (bfd)->arch_header)

/* True iff NAME designated a BSD 4.4 extended name.  */

#define is_bsd44_extended_name(NAME) \
  (NAME[0] == '#'  && NAME[1] == '1' && NAME[2] == '/' && ISDIGIT (NAME[3]))

void
_bfd_ar_spacepad (char *p, size_t n, const char *fmt, long val)
{
  static char buf[20];
  size_t len;

  snprintf (buf, sizeof (buf), fmt, val);
  len = strlen (buf);
  if (len < n)
    {
      memcpy (p, buf, len);
      memset (p + len, ' ', n - len);
    }
  else
    memcpy (p, buf, n);
}

bfd_boolean
_bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)
{
  static char buf[21];
  size_t len;

  snprintf (buf, sizeof (buf), "%-10" BFD_VMA_FMT "u", size);
  len = strlen (buf);
  if (len > n)
    {
      bfd_set_error (bfd_error_file_too_big);
      return FALSE;
    }
  if (len < n)
    {
      memcpy (p, buf, len);
      memset (p + len, ' ', n - len);
    }
  else
    memcpy (p, buf, n);
  return TRUE;
}

bfd_boolean
_bfd_generic_mkarchive (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct artdata);

  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == NULL)
    return FALSE;

  /* Already cleared by bfd_zalloc above.
     bfd_ardata (abfd)->cache = NULL;
     bfd_ardata (abfd)->archive_head = NULL;
     bfd_ardata (abfd)->symdefs = NULL;
     bfd_ardata (abfd)->extended_names = NULL;
     bfd_ardata (abfd)->extended_names_size = 0;
     bfd_ardata (abfd)->tdata = NULL;  */

  return TRUE;
}

/*
FUNCTION
	bfd_get_next_mapent

SYNOPSIS
	symindex bfd_get_next_mapent
	  (bfd *abfd, symindex previous, carsym **sym);

DESCRIPTION
	Step through archive @@var{abfd}'s symbol table (if it
	has one).  Successively update @@var{sym} with the next symbol's
	information, returning that symbol's (internal) index into the
	symbol table.

	Supply <<BFD_NO_MORE_SYMBOLS>> as the @@var{previous} entry to get
	the first one; returns <<BFD_NO_MORE_SYMBOLS>> when you've already
	got the last one.

	A <<carsym>> is a canonical archive symbol.  The only
	user-visible element is its name, a null-terminated string.
*/

symindex
bfd_get_next_mapent (bfd *abfd, symindex prev, carsym **entry)
{
  if (!bfd_has_map (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return BFD_NO_MORE_SYMBOLS;
    }

  if (prev == BFD_NO_MORE_SYMBOLS)
    prev = 0;
  else
    ++prev;
  if (prev >= bfd_ardata (abfd)->symdef_count)
    return BFD_NO_MORE_SYMBOLS;

  *entry = (bfd_ardata (abfd)->symdefs + prev);
  return prev;
}

/* To be called by backends only.  */

bfd *
_bfd_create_empty_archive_element_shell (bfd *obfd)
{
  return _bfd_new_bfd_contained_in (obfd);
}

/*
FUNCTION
	bfd_set_archive_head

SYNOPSIS
	bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

DESCRIPTION
	Set the head of the chain of
	BFDs contained in the archive @@var{output} to @@var{new_head}.
*/

bfd_boolean
bfd_set_archive_head (bfd *output_archive, bfd *new_head)
{
  output_archive->archive_head = new_head;
  return TRUE;
}

bfd *
_bfd_look_for_bfd_in_cache (bfd *arch_bfd, file_ptr filepos)
{
  htab_t hash_table = bfd_ardata (arch_bfd)->cache;
  struct ar_cache m;

  m.ptr = filepos;

  if (hash_table)
    {
      struct ar_cache *entry = (struct ar_cache *) htab_find (hash_table, &m);
      if (!entry)
	return NULL;
      else
	return entry->arbfd;
    }
  else
    return NULL;
}

static hashval_t
hash_file_ptr (const void * p)
{
  return (hashval_t) (((struct ar_cache *) p)->ptr);
}

/* Returns non-zero if P1 and P2 are equal.  */

static int
eq_file_ptr (const void * p1, const void * p2)
{
  struct ar_cache *arc1 = (struct ar_cache *) p1;
  struct ar_cache *arc2 = (struct ar_cache *) p2;
  return arc1->ptr == arc2->ptr;
}

/* The calloc function doesn't always take size_t (e.g. on VMS)
   so wrap it to avoid a compile time warning.   */

static void *
_bfd_calloc_wrapper (size_t a, size_t b)
{
  return calloc (a, b);
}

/* Kind of stupid to call cons for each one, but we don't do too many.  */

bfd_boolean
_bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)
{
  struct ar_cache *cache;
  htab_t hash_table = bfd_ardata (arch_bfd)->cache;

  /* If the hash table hasn't been created, create it.  */
  if (hash_table == NULL)
    {
      hash_table = htab_create_alloc (16, hash_file_ptr, eq_file_ptr,
				      NULL, _bfd_calloc_wrapper, free);
      if (hash_table == NULL)
	return FALSE;
      bfd_ardata (arch_bfd)->cache = hash_table;
    }

  /* Insert new_elt into the hash table by filepos.  */
  cache = (struct ar_cache *) bfd_zalloc (arch_bfd, sizeof (struct ar_cache));
  cache->ptr = filepos;
  cache->arbfd = new_elt;
  *htab_find_slot (hash_table, (const void *) cache, INSERT) = cache;

  /* Provide a means of accessing this from child.  */
  arch_eltdata (new_elt)->parent_cache = hash_table;
  arch_eltdata (new_elt)->key = filepos;

  return TRUE;
}

static bfd *
_bfd_find_nested_archive (bfd *arch_bfd, const char *filename)
{
  bfd *abfd;
  const char *target;

  /* PR 15140: Don't allow a nested archive pointing to itself.  */
  if (filename_cmp (filename, arch_bfd->filename) == 0)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  for (abfd = arch_bfd->nested_archives;
       abfd != NULL;
       abfd = abfd->archive_next)
    {
      if (filename_cmp (filename, abfd->filename) == 0)
	return abfd;
    }
  target = NULL;
  if (!arch_bfd->target_defaulted)
    target = arch_bfd->xvec->name;
  abfd = bfd_openr (filename, target);
  if (abfd)
    {
      abfd->archive_next = arch_bfd->nested_archives;
      arch_bfd->nested_archives = abfd;
    }
  return abfd;
}

/* The name begins with space.  Hence the rest of the name is an index into
   the string table.  */

static char *
get_extended_arelt_filename (bfd *arch, const char *name, file_ptr *originp)
{
  unsigned long table_index = 0;
  const char *endp;

  /* Should extract string so that I can guarantee not to overflow into
     the next region, but I'm too lazy.  */
  errno = 0;
  /* Skip first char, which is '/' in SVR4 or ' ' in some other variants.  */
  table_index = strtol (name + 1, (char **) &endp, 10);
  if (errno != 0 || table_index >= bfd_ardata (arch)->extended_names_size)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }
  /* In a thin archive, a member of an archive-within-an-archive
     will have the offset in the inner archive encoded here.  */
  if (bfd_is_thin_archive (arch) && endp != NULL && *endp == ':')
    {
      file_ptr origin = strtol (endp + 1, NULL, 10);

      if (errno != 0)
	{
	  bfd_set_error (bfd_error_malformed_archive);
	  return NULL;
	}
      *originp = origin;
    }
  else
    *originp = 0;

  return bfd_ardata (arch)->extended_names + table_index;
}

/* This functions reads an arch header and returns an areltdata pointer, or
   NULL on error.

   Presumes the file pointer is already in the right place (ie pointing
   to the ar_hdr in the file).   Moves the file pointer; on success it
   should be pointing to the front of the file contents; on failure it
   could have been moved arbitrarily.  */

void *
_bfd_generic_read_ar_hdr (bfd *abfd)
{
  return _bfd_generic_read_ar_hdr_mag (abfd, NULL);
}

/* Alpha ECOFF uses an optional different ARFMAG value, so we have a
   variant of _bfd_generic_read_ar_hdr which accepts a magic string.  */

void *
_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
{
  struct ar_hdr hdr;
  char *hdrp = (char *) &hdr;
  bfd_size_type parsed_size;
  struct areltdata *ared;
  char *filename = NULL;
  bfd_size_type namelen = 0;
  bfd_size_type allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);
  char *allocptr = 0;
  file_ptr origin = 0;
  unsigned int extra_size = 0;
  char fmag_save;
  int scan;

  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_no_more_archived_files);
      return NULL;
    }
  if (strncmp (hdr.ar_fmag, ARFMAG, 2) != 0
      && (mag == NULL
	  || strncmp (hdr.ar_fmag, mag, 2) != 0))
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  errno = 0;
  fmag_save = hdr.ar_fmag[0];
  hdr.ar_fmag[0] = 0;
  scan = sscanf (hdr.ar_size, "%" BFD_VMA_FMT "u", &parsed_size);
  hdr.ar_fmag[0] = fmag_save;
  if (scan != 1)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  /* Extract the filename from the archive - there are two ways to
     specify an extended name table, either the first char of the
     name is a space, or it's a slash.  */
  if ((hdr.ar_name[0] == '/'
       || (hdr.ar_name[0] == ' '
	   && memchr (hdr.ar_name, '/', ar_maxnamelen (abfd)) == NULL))
      && bfd_ardata (abfd)->extended_names != NULL)
    {
      filename = get_extended_arelt_filename (abfd, hdr.ar_name, &origin);
      if (filename == NULL)
	return NULL;
    }
  /* BSD4.4-style long filename.  */
  else if (is_bsd44_extended_name (hdr.ar_name))
    {
      /* BSD-4.4 extended name */
      namelen = atoi (&hdr.ar_name[3]);
      allocsize += namelen + 1;
      parsed_size -= namelen;
      extra_size = namelen;

      allocptr = (char *) bfd_zmalloc (allocsize);
      if (allocptr == NULL)
	return NULL;
      filename = (allocptr
		  + sizeof (struct areltdata)
		  + sizeof (struct ar_hdr));
      if (bfd_bread (filename, namelen, abfd) != namelen)
	{
	  free (allocptr);
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
      filename[namelen] = '\0';
    }
  else
    {
      /* We judge the end of the name by looking for '/' or ' '.
	 Note:  The SYSV format (terminated by '/') allows embedded
	 spaces, so only look for ' ' if we don't find '/'.  */

      char *e;
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
      if (e == NULL)
	{
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
	  if (e == NULL)
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
	}

      if (e != NULL)
	namelen = e - hdr.ar_name;
      else
	{
	  /* If we didn't find a termination character, then the name
	     must be the entire field.  */
	  namelen = ar_maxnamelen (abfd);
	}

      allocsize += namelen + 1;
    }

  if (!allocptr)
    {
      allocptr = (char *) bfd_zmalloc (allocsize);
      if (allocptr == NULL)
	return NULL;
    }

  ared = (struct areltdata *) allocptr;

  ared->arch_header = allocptr + sizeof (struct areltdata);
  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));
  ared->parsed_size = parsed_size;
  ared->extra_size = extra_size;
  ared->origin = origin;

  if (filename != NULL)
    ared->filename = filename;
  else
    {
      ared->filename = allocptr + (sizeof (struct areltdata) +
				   sizeof (struct ar_hdr));
      if (namelen)
	memcpy (ared->filename, hdr.ar_name, namelen);
      ared->filename[namelen] = '\0';
    }

  return ared;
}

/* Append the relative pathname for a member of the thin archive
   to the pathname of the directory containing the archive.  */

char *
_bfd_append_relative_path (bfd *arch, char *elt_name)
{
  const char *arch_name = arch->filename;
  const char *base_name = lbasename (arch_name);
  size_t prefix_len;
  char *filename;

  if (base_name == arch_name)
    return elt_name;

  prefix_len = base_name - arch_name;
  filename = (char *) bfd_alloc (arch, prefix_len + strlen (elt_name) + 1);
  if (filename == NULL)
    return NULL;

  strncpy (filename, arch_name, prefix_len);
  strcpy (filename + prefix_len, elt_name);
  return filename;
}

/* This is an internal function; it's mainly used when indexing
   through the archive symbol table, but also used to get the next
   element, since it handles the bookkeeping so nicely for us.  */

bfd *
_bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
{
  struct areltdata *new_areldata;
  bfd *n_nfd;
  char *filename;

  n_nfd = _bfd_look_for_bfd_in_cache (archive, filepos);
  if (n_nfd)
    return n_nfd;

  if (0 > bfd_seek (archive, filepos, SEEK_SET))
    return NULL;

  if ((new_areldata = (struct areltdata *) _bfd_read_ar_hdr (archive)) == NULL)
    return NULL;

  filename = new_areldata->filename;

  if (bfd_is_thin_archive (archive))
    {
      const char *target;

      /* This is a proxy entry for an external file.  */
      if (! IS_ABSOLUTE_PATH (filename))
	{
	  filename = _bfd_append_relative_path (archive, filename);
	  if (filename == NULL)
	    {
	      free (new_areldata);
	      return NULL;
	    }
	}

      if (new_areldata->origin > 0)
	{
	  /* This proxy entry refers to an element of a nested archive.
	     Locate the member of that archive and return a bfd for it.  */
	  bfd *ext_arch = _bfd_find_nested_archive (archive, filename);

	  if (ext_arch == NULL
	      || ! bfd_check_format (ext_arch, bfd_archive))
	    {
	      free (new_areldata);
	      return NULL;
	    }
	  n_nfd = _bfd_get_elt_at_filepos (ext_arch, new_areldata->origin);
	  if (n_nfd == NULL)
	    {
	      free (new_areldata);
	      return NULL;
	    }
	  n_nfd->proxy_origin = bfd_tell (archive);
	  return n_nfd;
	}
      /* It's not an element of a nested archive;
	 open the external file as a bfd.  */
      target = NULL;
      if (!archive->target_defaulted)
	target = archive->xvec->name;
      n_nfd = bfd_openr (filename, target);
      if (n_nfd == NULL)
	bfd_set_error (bfd_error_malformed_archive);
    }
  else
    {
      n_nfd = _bfd_create_empty_archive_element_shell (archive);
    }

  if (n_nfd == NULL)
    {
      free (new_areldata);
      return NULL;
    }

  n_nfd->proxy_origin = bfd_tell (archive);

  if (bfd_is_thin_archive (archive))
    {
      n_nfd->origin = 0;
    }
  else
    {
      n_nfd->origin = n_nfd->proxy_origin;
      n_nfd->filename = filename;
    }

  n_nfd->arelt_data = new_areldata;

  /* Copy BFD_COMPRESS and BFD_DECOMPRESS flags.  */
  n_nfd->flags |= archive->flags & (BFD_COMPRESS | BFD_DECOMPRESS);

  if (_bfd_add_bfd_to_archive_cache (archive, filepos, n_nfd))
    return n_nfd;

  free (new_areldata);
  n_nfd->arelt_data = NULL;
  return NULL;
}

/* Return the BFD which is referenced by the symbol in ABFD indexed by
   SYM_INDEX.  SYM_INDEX should have been returned by bfd_get_next_mapent.  */

bfd *
_bfd_generic_get_elt_at_index (bfd *abfd, symindex sym_index)
{
  carsym *entry;

  entry = bfd_ardata (abfd)->symdefs + sym_index;
  return _bfd_get_elt_at_filepos (abfd, entry->file_offset);
}

/*
FUNCTION
	bfd_openr_next_archived_file

SYNOPSIS
	bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);

DESCRIPTION
	Provided a BFD, @@var{archive}, containing an archive and NULL, open
	an input BFD on the first contained element and returns that.
	Subsequent calls should pass
	the archive and the previous return value to return a created
	BFD to the next contained element. NULL is returned when there
	are no more.
*/

bfd *
bfd_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  if ((bfd_get_format (archive) != bfd_archive)
      || (archive->direction == write_direction))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  return BFD_SEND (archive,
		   openr_next_archived_file, (archive, last_file));
}

bfd *
bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  file_ptr filestart;

  if (!last_file)
    filestart = bfd_ardata (archive)->first_file_filepos;
  else
    {
      bfd_size_type size = arelt_size (last_file);

      filestart = last_file->proxy_origin;
      if (! bfd_is_thin_archive (archive))
	filestart += size;
      /* Pad to an even boundary...
	 Note that last_file->origin can be odd in the case of
	 BSD-4.4-style element with a long odd size.  */
      filestart += filestart % 2;
    }

  return _bfd_get_elt_at_filepos (archive, filestart);
}

const bfd_target *
bfd_generic_archive_p (bfd *abfd)
{
  struct artdata *tdata_hold;
  char armag[SARMAG + 1];
  bfd_size_type amt;

  if (bfd_bread (armag, SARMAG, abfd) != SARMAG)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  bfd_is_thin_archive (abfd) = (strncmp (armag, ARMAGT, SARMAG) == 0);

  if (strncmp (armag, ARMAG, SARMAG) != 0
      && strncmp (armag, ARMAGB, SARMAG) != 0
      && ! bfd_is_thin_archive (abfd))
    return NULL;

  tdata_hold = bfd_ardata (abfd);

  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == NULL)
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  bfd_ardata (abfd)->first_file_filepos = SARMAG;
  /* Cleared by bfd_zalloc above.
     bfd_ardata (abfd)->cache = NULL;
     bfd_ardata (abfd)->archive_head = NULL;
     bfd_ardata (abfd)->symdefs = NULL;
     bfd_ardata (abfd)->extended_names = NULL;
     bfd_ardata (abfd)->extended_names_size = 0;
     bfd_ardata (abfd)->tdata = NULL;  */

  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd))
      || !BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      bfd_release (abfd, bfd_ardata (abfd));
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  if (abfd->target_defaulted && bfd_has_map (abfd))
    {
      bfd *first;

      /* This archive has a map, so we may presume that the contents
	 are object files.  Make sure that if the first file in the
	 archive can be recognized as an object file, it is for this
	 target.  If not, assume that this is the wrong format.  If
	 the first file is not an object file, somebody is doing
	 something weird, and we permit it so that ar -t will work.

	 This is done because any normal format will recognize any
	 normal archive, regardless of the format of the object files.
	 We do accept an empty archive.  */

      first = bfd_openr_next_archived_file (abfd, NULL);
      if (first != NULL)
	{
	  first->target_defaulted = FALSE;
	  if (bfd_check_format (first, bfd_object)
	      && first->xvec != abfd->xvec)
	    bfd_set_error (bfd_error_wrong_object_format);
	  /* And we ought to close `first' here too.  */
	}
    }

  return abfd->xvec;
}

/* Some constants for a 32 bit BSD archive structure.  We do not
   support 64 bit archives presently; so far as I know, none actually
   exist.  Supporting them would require changing these constants, and
   changing some H_GET_32 to H_GET_64.  */

/* The size of an external symdef structure.  */
#define BSD_SYMDEF_SIZE 8

/* The offset from the start of a symdef structure to the file offset.  */
#define BSD_SYMDEF_OFFSET_SIZE 4

/* The size of the symdef count.  */
#define BSD_SYMDEF_COUNT_SIZE 4

/* The size of the string count.  */
#define BSD_STRING_COUNT_SIZE 4

/* Read a BSD-style archive symbol table.  Returns FALSE on error,
   TRUE otherwise.  */

static bfd_boolean
do_slurp_bsd_armap (bfd *abfd)
{
  struct areltdata *mapdata;
  unsigned int counter;
  bfd_byte *raw_armap, *rbase;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  bfd_size_type parsed_size, amt;
  carsym *set;

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;
  parsed_size = mapdata->parsed_size;
  free (mapdata);

  raw_armap = (bfd_byte *) bfd_zalloc (abfd, parsed_size);
  if (raw_armap == NULL)
    return FALSE;

  if (bfd_bread (raw_armap, parsed_size, abfd) != parsed_size)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
    byebye:
      bfd_release (abfd, raw_armap);
      return FALSE;
    }

  ardata->symdef_count = H_GET_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;

  if (ardata->symdef_count * BSD_SYMDEF_SIZE >
      parsed_size - BSD_SYMDEF_COUNT_SIZE)
    {
      /* Probably we're using the wrong byte ordering.  */
      bfd_set_error (bfd_error_wrong_format);
      goto byebye;
    }

  ardata->cache = 0;
  rbase = raw_armap + BSD_SYMDEF_COUNT_SIZE;
  stringbase = ((char *) rbase
		+ ardata->symdef_count * BSD_SYMDEF_SIZE
		+ BSD_STRING_COUNT_SIZE);
  amt = ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  for (counter = 0, set = ardata->symdefs;
       counter < ardata->symdef_count;
       counter++, set++, rbase += BSD_SYMDEF_SIZE)
    {
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
    }

  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;
  /* FIXME, we should provide some way to free raw_ardata when
     we are done using the strings from it.  For now, it seems
     to be allocated on an objalloc anyway...  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/* Read a COFF archive symbol table.  Returns FALSE on error, TRUE
   otherwise.  */

static bfd_boolean
do_slurp_coff_armap (bfd *abfd)
{
  struct areltdata *mapdata;
  int *raw_armap, *rawptr;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  bfd_size_type stringsize;
  bfd_size_type parsed_size;
  carsym *carsyms;
  bfd_size_type nsymz;		/* Number of symbols in armap.  */
  bfd_vma (*swap) (const void *);
  char int_buf[sizeof (long)];
  bfd_size_type carsym_size, ptrsize;
  unsigned int i;

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;
  parsed_size = mapdata->parsed_size;
  free (mapdata);

  if (bfd_bread (int_buf, 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }
  /* It seems that all numeric information in a coff archive is always
     in big endian format, nomatter the host or target.  */
  swap = bfd_getb32;
  nsymz = bfd_getb32 (int_buf);
  stringsize = parsed_size - (4 * nsymz) - 4;

  /* ... except that some archive formats are broken, and it may be our
     fault - the i960 little endian coff sometimes has big and sometimes
     little, because our tools changed.  Here's a horrible hack to clean
     up the crap.  */

  if (stringsize > 0xfffff
      && bfd_get_arch (abfd) == bfd_arch_i960
      && bfd_get_flavour (abfd) == bfd_target_coff_flavour)
    {
      /* This looks dangerous, let's do it the other way around.  */
      nsymz = bfd_getl32 (int_buf);
      stringsize = parsed_size - (4 * nsymz) - 4;
      swap = bfd_getl32;
    }

  /* The coff armap must be read sequentially.  So we construct a
     bsd-style one in core all at once, for simplicity.  */

  if (nsymz > ~ (bfd_size_type) 0 / sizeof (carsym))
    return FALSE;

  carsym_size = (nsymz * sizeof (carsym));
  ptrsize = (4 * nsymz);

  if (carsym_size + stringsize + 1 <= carsym_size)
    return FALSE;

  ardata->symdefs = (struct carsym *) bfd_zalloc (abfd,
						  carsym_size + stringsize + 1);
  if (ardata->symdefs == NULL)
    return FALSE;
  carsyms = ardata->symdefs;
  stringbase = ((char *) ardata->symdefs) + carsym_size;

  /* Allocate and read in the raw offsets.  */
  raw_armap = (int *) bfd_alloc (abfd, ptrsize);
  if (raw_armap == NULL)
    goto release_symdefs;
  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto release_raw_armap;
    }

  /* OK, build the carsyms.  */
  for (i = 0; i < nsymz; i++)
    {
      rawptr = raw_armap + i;
      carsyms->file_offset = swap ((bfd_byte *) rawptr);
      carsyms->name = stringbase;
      stringbase += strlen (stringbase) + 1;
      carsyms++;
    }
  *stringbase = 0;

  ardata->symdef_count = nsymz;
  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;

  bfd_has_map (abfd) = TRUE;
  bfd_release (abfd, raw_armap);

  /* Check for a second archive header (as used by PE).  */
  {
    struct areltdata *tmp;

    bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET);
    tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);
    if (tmp != NULL)
      {
	if (tmp->arch_header[0] == '/'
	    && tmp->arch_header[1] == ' ')
	  {
	    ardata->first_file_filepos +=
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~(unsigned) 1;
	  }
	free (tmp);
      }
  }

  return TRUE;

release_raw_armap:
  bfd_release (abfd, raw_armap);
release_symdefs:
  bfd_release (abfd, (ardata)->symdefs);
  return FALSE;
}

/* This routine can handle either coff-style or bsd-style armaps
   (archive symbol table).  Returns FALSE on error, TRUE otherwise */

bfd_boolean
bfd_slurp_armap (bfd *abfd)
{
  char nextname[17];
  int i = bfd_bread (nextname, 16, abfd);

  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  if (CONST_STRNEQ (nextname, "__.SYMDEF       ")
      || CONST_STRNEQ (nextname, "__.SYMDEF/      ")) /* Old Linux archives.  */
    return do_slurp_bsd_armap (abfd);
  else if (CONST_STRNEQ (nextname, "/               "))
    return do_slurp_coff_armap (abfd);
  else if (CONST_STRNEQ (nextname, "/SYM64/         "))
    {
      /* 64bit ELF (Irix 6) archive.  */
#ifdef BFD64
      extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
      return bfd_elf64_archive_slurp_armap (abfd);
#else
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
#endif
    }
  else if (CONST_STRNEQ (nextname, "#1/20           "))
    {
      /* Mach-O has a special name for armap when the map is sorted by name.
	 However because this name has a space it is slightly more difficult
	 to check it.  */
      struct ar_hdr hdr;
      char extname[21];

      if (bfd_bread (&hdr, sizeof (hdr), abfd) != sizeof (hdr))
	return FALSE;
      /* Read the extended name.  We know its length.  */
      if (bfd_bread (extname, 20, abfd) != 20)
	return FALSE;
      if (bfd_seek (abfd, -(file_ptr) (sizeof (hdr) + 20), SEEK_CUR) != 0)
	return FALSE;
      if (CONST_STRNEQ (extname, "__.SYMDEF SORTED")
	  || CONST_STRNEQ (extname, "__.SYMDEF"))
	return do_slurp_bsd_armap (abfd);
    }

  bfd_has_map (abfd) = FALSE;
  return TRUE;
}

/* Returns FALSE on error, TRUE otherwise.  */
/* Flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
   header is in a slightly different order and the map name is '/'.
   This flavour is used by hp300hpux.  */

#define HPUX_SYMDEF_COUNT_SIZE 2

bfd_boolean
bfd_slurp_bsd_armap_f2 (bfd *abfd)
{
  struct areltdata *mapdata;
  char nextname[17];
  unsigned int counter;
  bfd_byte *raw_armap, *rbase;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  unsigned int stringsize;
  unsigned int left;
  bfd_size_type amt;
  carsym *set;
  int i = bfd_bread (nextname, 16, abfd);

  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  /* The archive has at least 16 bytes in it.  */
  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  if (CONST_STRNEQ (nextname, "__.SYMDEF       ")
      || CONST_STRNEQ (nextname, "__.SYMDEF/      ")) /* Old Linux archives.  */
    return do_slurp_bsd_armap (abfd);

  if (! CONST_STRNEQ (nextname, "/               "))
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;

  if (mapdata->parsed_size < HPUX_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE)
    {
      free (mapdata);
    wrong_format:
      bfd_set_error (bfd_error_wrong_format);
    byebye:
      return FALSE;
    }
  left = mapdata->parsed_size - HPUX_SYMDEF_COUNT_SIZE - BSD_STRING_COUNT_SIZE;

  amt = mapdata->parsed_size;
  free (mapdata);

  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
  if (raw_armap == NULL)
    goto byebye;

  if (bfd_bread (raw_armap, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto byebye;
    }

  ardata->symdef_count = H_GET_16 (abfd, raw_armap);

  ardata->cache = 0;

  stringsize = H_GET_32 (abfd, raw_armap + HPUX_SYMDEF_COUNT_SIZE);
  if (stringsize > left)
    goto wrong_format;
  left -= stringsize;

  /* Skip sym count and string sz.  */
  stringbase = ((char *) raw_armap
		+ HPUX_SYMDEF_COUNT_SIZE
		+ BSD_STRING_COUNT_SIZE);
  rbase = (bfd_byte *) stringbase + stringsize;
  amt = ardata->symdef_count * BSD_SYMDEF_SIZE;
  if (amt > left)
    goto wrong_format;

  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  for (counter = 0, set = ardata->symdefs;
       counter < ardata->symdef_count;
       counter++, set++, rbase += BSD_SYMDEF_SIZE)
    {
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
    }

  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;
  /* FIXME, we should provide some way to free raw_ardata when
     we are done using the strings from it.  For now, it seems
     to be allocated on an objalloc anyway...  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/** Extended name table.

  Normally archives support only 14-character filenames.

  Intel has extended the format: longer names are stored in a special
  element (the first in the archive, or second if there is an armap);
  the name in the ar_hdr is replaced by <space><index into filename
  element>.  Index is the P.R. of an int (decimal).  Data General have
  extended the format by using the prefix // for the special element.  */

/* Returns FALSE on error, TRUE otherwise.  */

bfd_boolean
_bfd_slurp_extended_name_table (bfd *abfd)
{
  char nextname[17];
  struct areltdata *namedata;
  bfd_size_type amt;

  /* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,
     we probably don't want to return TRUE.  */
  if (bfd_seek (abfd, bfd_ardata (abfd)->first_file_filepos, SEEK_SET) != 0)
    return FALSE;

  if (bfd_bread (nextname, 16, abfd) == 16)
    {
      if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
	return FALSE;

      if (! CONST_STRNEQ (nextname, "ARFILENAMES/    ")
	  && ! CONST_STRNEQ (nextname, "//              "))
	{
	  bfd_ardata (abfd)->extended_names = NULL;
	  bfd_ardata (abfd)->extended_names_size = 0;
	  return TRUE;
	}

      namedata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
      if (namedata == NULL)
	return FALSE;

      amt = namedata->parsed_size;
      if (amt + 1 == 0)
	goto byebye;

      bfd_ardata (abfd)->extended_names_size = amt;
      bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);
      if (bfd_ardata (abfd)->extended_names == NULL)
	{
	byebye:
	  free (namedata);
	  return FALSE;
	}

      if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_malformed_archive);
	  bfd_release (abfd, (bfd_ardata (abfd)->extended_names));
	  bfd_ardata (abfd)->extended_names = NULL;
	  goto byebye;
	}

      /* Since the archive is supposed to be printable if it contains
	 text, the entries in the list are newline-padded, not null
	 padded. In SVR4-style archives, the names also have a
	 trailing '/'.  DOS/NT created archive often have \ in them
	 We'll fix all problems here..  */
      {
	char *ext_names = bfd_ardata (abfd)->extended_names;
	char *temp = ext_names;
	char *limit = temp + namedata->parsed_size;
	for (; temp < limit; ++temp)
	  {
	    if (*temp == ARFMAG[1])
	      temp[temp > ext_names && temp[-1] == '/' ? -1 : 0] = '\0';
	    if (*temp == '\\')
	      *temp = '/';
	  }
	*limit = '\0';
      }

      /* Pad to an even boundary if you have to.  */
      bfd_ardata (abfd)->first_file_filepos = bfd_tell (abfd);
      bfd_ardata (abfd)->first_file_filepos +=
	(bfd_ardata (abfd)->first_file_filepos) % 2;

      free (namedata);
    }
  return TRUE;
}

#ifdef VMS

/* Return a copy of the stuff in the filename between any :]> and a
   semicolon.  */

static const char *
normalize (bfd *abfd, const char *file)
{
  const char *first;
  const char *last;
  char *copy;

  first = file + strlen (file) - 1;
  last = first + 1;

  while (first != file)
    {
      if (*first == ';')
	last = first;
      if (*first == ':' || *first == ']' || *first == '>')
	{
	  first++;
	  break;
	}
      first--;
    }

  copy = bfd_alloc (abfd, last - first + 1);
  if (copy == NULL)
    return NULL;

  memcpy (copy, first, last - first);
  copy[last - first] = 0;

  return copy;
}

#else
static const char *
normalize (bfd *abfd ATTRIBUTE_UNUSED, const char *file)
{
  return lbasename (file);
}
#endif

/* Adjust a relative path name based on the reference path.
   For example:

     Relative path  Reference path  Result
     -------------  --------------  ------
     bar.o          lib.a           bar.o
     foo/bar.o      lib.a           foo/bar.o
     bar.o          foo/lib.a       ../bar.o
     foo/bar.o      baz/lib.a       ../foo/bar.o
     bar.o          ../lib.a        <parent of current dir>/bar.o
   ; ../bar.o       ../lib.a        bar.o
   ; ../bar.o       lib.a           ../bar.o
     foo/bar.o      ../lib.a        <parent of current dir>/foo/bar.o
     bar.o          ../../lib.a     <grandparent>/<parent>/bar.o
     bar.o          foo/baz/lib.a   ../../bar.o

   Note - the semicolons above are there to prevent the BFD chew
   utility from interpreting those lines as prototypes to put into
   the autogenerated bfd.h header...

   Note - the string is returned in a static buffer.  */

static const char *
adjust_relative_path (const char * path, const char * ref_path)
{
  static char *pathbuf = NULL;
  static unsigned int pathbuf_len = 0;
  const char *pathp;
  const char *refp;
  char * lpath;
  char * rpath;
  unsigned int len;
  unsigned int dir_up = 0;
  unsigned int dir_down = 0;
  char *newp;
  char * pwd = getpwd ();
  const char * down;

  /* Remove symlinks, '.' and '..' from the paths, if possible.  */
  lpath = lrealpath (path);
  pathp = lpath == NULL ? path : lpath;

  rpath = lrealpath (ref_path);
  refp = rpath == NULL ? ref_path : rpath;

  /* Remove common leading path elements.  */
  for (;;)
    {
      const char *e1 = pathp;
      const char *e2 = refp;

      while (*e1 && ! IS_DIR_SEPARATOR (*e1))
	++e1;
      while (*e2 && ! IS_DIR_SEPARATOR (*e2))
	++e2;
      if (*e1 == '\0' || *e2 == '\0' || e1 - pathp != e2 - refp
	  || filename_ncmp (pathp, refp, e1 - pathp) != 0)
	break;
      pathp = e1 + 1;
      refp = e2 + 1;
    }

  len = strlen (pathp) + 1;
  /* For each leading path element in the reference path,
     insert "../" into the path.  */
  for (; *refp; ++refp)
    if (IS_DIR_SEPARATOR (*refp))
      {
	/* PR 12710:  If the path element is "../" then instead of
	   inserting "../" we need to insert the name of the directory
	   at the current level.  */
	if (refp > ref_path + 1
	    && refp[-1] == '.'
	    && refp[-2] == '.')
	  dir_down ++;
	else
	  dir_up ++;
      }

  /* If the lrealpath calls above succeeded then we should never
     see dir_up and dir_down both being non-zero.  */

  len += 3 * dir_up;

  if (dir_down)
    {
      down = pwd + strlen (pwd) - 1;

      while (dir_down && down > pwd)
	{
	  if (IS_DIR_SEPARATOR (*down))
	    --dir_down;
	}
      BFD_ASSERT (dir_down == 0);
      len += strlen (down) + 1;
    }
  else
    down = NULL;

  if (len > pathbuf_len)
    {
      if (pathbuf != NULL)
	free (pathbuf);
      pathbuf_len = 0;
      pathbuf = (char *) bfd_malloc (len);
      if (pathbuf == NULL)
	goto out;
      pathbuf_len = len;
    }

  newp = pathbuf;
  while (dir_up-- > 0)
    {
      /* FIXME: Support Windows style path separators as well.  */
      strcpy (newp, "../");
      newp += 3;
    }

  if (down)
    sprintf (newp, "%s/%s", down, pathp);
  else
    strcpy (newp, pathp);

 out:
  free (lpath);
  free (rpath);
  return pathbuf;
}

/* Build a BFD style extended name table.  */

bfd_boolean
_bfd_archive_bsd_construct_extended_name_table (bfd *abfd,
						char **tabloc,
						bfd_size_type *tablen,
						const char **name)
{
  *name = "ARFILENAMES/";
  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);
}

/* Build an SVR4 style extended name table.  */

bfd_boolean
_bfd_archive_coff_construct_extended_name_table (bfd *abfd,
						 char **tabloc,
						 bfd_size_type *tablen,
						 const char **name)
{
  *name = "//";
  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);
}

/* Follows archive_head and produces an extended name table if
   necessary.  Returns (in tabloc) a pointer to an extended name
   table, and in tablen the length of the table.  If it makes an entry
   it clobbers the filename so that the element may be written without
   further massage.  Returns TRUE if it ran successfully, FALSE if
   something went wrong.  A successful return may still involve a
   zero-length tablen!  */

bfd_boolean
_bfd_construct_extended_name_table (bfd *abfd,
				    bfd_boolean trailing_slash,
				    char **tabloc,
				    bfd_size_type *tablen)
{
  unsigned int maxname = ar_maxnamelen (abfd);
  bfd_size_type total_namelen = 0;
  bfd *current;
  char *strptr;
  const char *last_filename;
  long last_stroff;

  *tablen = 0;
  last_filename = NULL;

  /* Figure out how long the table should be.  */
  for (current = abfd->archive_head;
       current != NULL;
       current = current->archive_next)
    {
      const char *normal;
      unsigned int thislen;

      if (bfd_is_thin_archive (abfd))
	{
	  const char *filename = current->filename;

	  /* If the element being added is a member of another archive
	     (i.e., we are flattening), use the containing archive's name.  */
	  if (current->my_archive
	      && ! bfd_is_thin_archive (current->my_archive))
	    filename = current->my_archive->filename;

	  /* If the path is the same as the previous path seen,
	     reuse it.  This can happen when flattening a thin
	     archive that contains other archives.  */
	  if (last_filename && filename_cmp (last_filename, filename) == 0)
	    continue;

	  last_filename = filename;

	  /* If the path is relative, adjust it relative to
	     the containing archive. */
	  if (! IS_ABSOLUTE_PATH (filename)
	      && ! IS_ABSOLUTE_PATH (abfd->filename))
	    normal = adjust_relative_path (filename, abfd->filename);
	  else
	    normal = filename;

	  /* In a thin archive, always store the full pathname
	     in the extended name table.  */
	  total_namelen += strlen (normal) + 1;
	  if (trailing_slash)
	    /* Leave room for trailing slash.  */
	    ++total_namelen;

	  continue;
	}

      normal = normalize (current, current->filename);
      if (normal == NULL)
	return FALSE;

      thislen = strlen (normal);

      if (thislen > maxname
	  && (bfd_get_file_flags (abfd) & BFD_TRADITIONAL_FORMAT) != 0)
	thislen = maxname;

      if (thislen > maxname)
	{
	  /* Add one to leave room for \n.  */
	  total_namelen += thislen + 1;
	  if (trailing_slash)
	    {
	      /* Leave room for trailing slash.  */
	      ++total_namelen;
	    }
	}
      else
	{
	  struct ar_hdr *hdr = arch_hdr (current);
	  if (filename_ncmp (normal, hdr->ar_name, thislen) != 0
	      || (thislen < sizeof hdr->ar_name
		  && hdr->ar_name[thislen] != ar_padchar (current)))
	    {
	      /* Must have been using extended format even though it
		 didn't need to.  Fix it to use normal format.  */
	      memcpy (hdr->ar_name, normal, thislen);
	      if (thislen < maxname
		  || (thislen == maxname && thislen < sizeof hdr->ar_name))
		hdr->ar_name[thislen] = ar_padchar (current);
	    }
	}
    }

  if (total_namelen == 0)
    return TRUE;

  *tabloc = (char *) bfd_zalloc (abfd, total_namelen);
  if (*tabloc == NULL)
    return FALSE;

  *tablen = total_namelen;
  strptr = *tabloc;

  last_filename = NULL;
  last_stroff = 0;

  for (current = abfd->archive_head;
       current != NULL;
       current = current->archive_next)
    {
      const char *normal;
      unsigned int thislen;
      long stroff;
      const char *filename = current->filename;

      if (bfd_is_thin_archive (abfd))
	{
	  /* If the element being added is a member of another archive
	     (i.e., we are flattening), use the containing archive's name.  */
	  if (current->my_archive
	      && ! bfd_is_thin_archive (current->my_archive))
	    filename = current->my_archive->filename;
	  /* If the path is the same as the previous path seen,
	     reuse it.  This can happen when flattening a thin
	     archive that contains other archives.
	     If the path is relative, adjust it relative to
	     the containing archive.  */
	  if (last_filename && filename_cmp (last_filename, filename) == 0)
	    normal = last_filename;
	  else if (! IS_ABSOLUTE_PATH (filename)
		   && ! IS_ABSOLUTE_PATH (abfd->filename))
	    normal = adjust_relative_path (filename, abfd->filename);
	  else
	    normal = filename;
	}
      else
	{
	  normal = normalize (current, filename);
	  if (normal == NULL)
	    return FALSE;
	}

      thislen = strlen (normal);
      if (thislen > maxname || bfd_is_thin_archive (abfd))
	{
	  /* Works for now; may need to be re-engineered if we
	     encounter an oddball archive format and want to
	     generalise this hack.  */
	  struct ar_hdr *hdr = arch_hdr (current);
	  if (normal == last_filename)
	    stroff = last_stroff;
	  else
	    {
	      strcpy (strptr, normal);
	      if (! trailing_slash)
		strptr[thislen] = ARFMAG[1];
	      else
		{
		  strptr[thislen] = '/';
		  strptr[thislen + 1] = ARFMAG[1];
		}
	      stroff = strptr - *tabloc;
	      last_stroff = stroff;
	    }
	  hdr->ar_name[0] = ar_padchar (current);
	  if (bfd_is_thin_archive (abfd) && current->origin > 0)
	    {
	      int len = snprintf (hdr->ar_name + 1, maxname - 1, "%-ld:",
				  stroff);
	      _bfd_ar_spacepad (hdr->ar_name + 1 + len, maxname - 1 - len,
				"%-ld",
				current->origin - sizeof (struct ar_hdr));
	    }
	  else
	    _bfd_ar_spacepad (hdr->ar_name + 1, maxname - 1, "%-ld", stroff);
	  if (normal != last_filename)
	    {
	      strptr += thislen + 1;
	      if (trailing_slash)
		++strptr;
	      last_filename = filename;
	    }
	}
    }

  return TRUE;
}

/* Do not construct an extended name table but transforms name field into
   its extended form.  */

bfd_boolean
_bfd_archive_bsd44_construct_extended_name_table (bfd *abfd,
						  char **tabloc,
						  bfd_size_type *tablen,
						  const char **name)
{
  unsigned int maxname = ar_maxnamelen (abfd);
  bfd *current;

  *tablen = 0;
  *tabloc = NULL;
  *name = NULL;

  for (current = abfd->archive_head;
       current != NULL;
       current = current->archive_next)
    {
      const char *normal = normalize (current, current->filename);
      int has_space = 0;
      unsigned int len;

      if (normal == NULL)
	return FALSE;

      for (len = 0; normal[len]; len++)
	if (normal[len] == ' ')
	  has_space = 1;

      if (len > maxname || has_space)
	{
	  struct ar_hdr *hdr = arch_hdr (current);

	  len = (len + 3) & ~3;
	  arch_eltdata (current)->extra_size = len;
	  _bfd_ar_spacepad (hdr->ar_name, maxname, "#1/%lu", len);
	}
    }

  return TRUE;
}

/* Write an archive header.  */

bfd_boolean
_bfd_generic_write_ar_hdr (bfd *archive, bfd *abfd)
{
  struct ar_hdr *hdr = arch_hdr (abfd);

  if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))
    return FALSE;
  return TRUE;
}

/* Write an archive header using BSD4.4 convention.  */

bfd_boolean
_bfd_bsd44_write_ar_hdr (bfd *archive, bfd *abfd)
{
  struct ar_hdr *hdr = arch_hdr (abfd);

  if (is_bsd44_extended_name (hdr->ar_name))
    {
      /* This is a BSD 4.4 extended name.  */
      const char *fullname = normalize (abfd, abfd->filename);
      unsigned int len = strlen (fullname);
      unsigned int padded_len = (len + 3) & ~3;

      BFD_ASSERT (padded_len == arch_eltdata (abfd)->extra_size);

      if (!_bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
			    arch_eltdata (abfd)->parsed_size + padded_len))
	return FALSE;

      if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))
	return FALSE;

      if (bfd_bwrite (fullname, len, archive) != len)
	return FALSE;

      if (len & 3)
	{
	  static const char pad[3] = { 0, 0, 0 };

	  len = 4 - (len & 3);
	  if (bfd_bwrite (pad, len, archive) != len)
	    return FALSE;
	}
    }
  else
    {
      if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))
	return FALSE;
    }
  return TRUE;
}

/* A couple of functions for creating ar_hdrs.  */

#ifdef HPUX_LARGE_AR_IDS
/* Function to encode large UID/GID values according to HP.  */

static void
hpux_uid_gid_encode (char str[6], long int id)
{
  int cnt;

  str[5] = '@@' + (id & 3);
  id >>= 2;

  for (cnt = 4; cnt >= 0; --cnt, id >>= 6)
    str[cnt] = ' ' + (id & 0x3f);
}
#endif	/* HPUX_LARGE_AR_IDS */

#ifndef HAVE_GETUID
#define getuid() 0
#endif

#ifndef HAVE_GETGID
#define getgid() 0
#endif

/* Takes a filename, returns an arelt_data for it, or NULL if it can't
   make one.  The filename must refer to a filename in the filesystem.
   The filename field of the ar_hdr will NOT be initialized.  If member
   is set, and it's an in-memory bfd, we fake it.  */

static struct areltdata *
bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
{
  struct stat status;
  struct areltdata *ared;
  struct ar_hdr *hdr;
  bfd_size_type amt;

  if (member && (member->flags & BFD_IN_MEMORY) != 0)
    {
      /* Assume we just "made" the member, and fake it.  */
      struct bfd_in_memory *bim = (struct bfd_in_memory *) member->iostream;
      time (&status.st_mtime);
      status.st_uid = getuid ();
      status.st_gid = getgid ();
      status.st_mode = 0644;
      status.st_size = bim->size;
    }
  else if (stat (filename, &status) != 0)
    {
      bfd_set_error (bfd_error_system_call);
      return NULL;
    }

  /* If the caller requested that the BFD generate deterministic output,
     fake values for modification time, UID, GID, and file mode.  */
  if ((abfd->flags & BFD_DETERMINISTIC_OUTPUT) != 0)
    {
      status.st_mtime = 0;
      status.st_uid = 0;
      status.st_gid = 0;
      status.st_mode = 0644;
    }

  amt = sizeof (struct ar_hdr) + sizeof (struct areltdata);
  ared = (struct areltdata *) bfd_zmalloc (amt);
  if (ared == NULL)
    return NULL;
  hdr = (struct ar_hdr *) (((char *) ared) + sizeof (struct areltdata));

  /* ar headers are space padded, not null padded!  */
  memset (hdr, ' ', sizeof (struct ar_hdr));

  _bfd_ar_spacepad (hdr->ar_date, sizeof (hdr->ar_date), "%-12ld",
		    status.st_mtime);
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_uid > 99999)
    hpux_uid_gid_encode (hdr->ar_uid, (long) status.st_uid);
  else
#endif
    _bfd_ar_spacepad (hdr->ar_uid, sizeof (hdr->ar_uid), "%ld",
		      status.st_uid);
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_gid > 99999)
    hpux_uid_gid_encode (hdr->ar_gid, (long) status.st_gid);
  else
#endif
    _bfd_ar_spacepad (hdr->ar_gid, sizeof (hdr->ar_gid), "%ld",
		      status.st_gid);
  _bfd_ar_spacepad (hdr->ar_mode, sizeof (hdr->ar_mode), "%-8lo",
		    status.st_mode);
  if (!_bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size), status.st_size))
    {
      free (ared);
      return NULL;
    }
  memcpy (hdr->ar_fmag, ARFMAG, 2);
  ared->parsed_size = status.st_size;
  ared->arch_header = (char *) hdr;

  return ared;
}

/* Analogous to stat call.  */

int
bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
{
  struct ar_hdr *hdr;
  char *aloser;

  if (abfd->arelt_data == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  hdr = arch_hdr (abfd);

#define foo(arelt, stelt, size)				\
  buf->stelt = strtol (hdr->arelt, &aloser, size);	\
  if (aloser == hdr->arelt)	      			\
    return -1;

  /* Some platforms support special notations for large IDs.  */
#ifdef HPUX_LARGE_AR_IDS
# define foo2(arelt, stelt, size)					\
  if (hdr->arelt[5] == ' ')						\
    {									\
      foo (arelt, stelt, size);						\
    }									\
  else									\
    {									\
      int cnt;								\
      for (buf->stelt = cnt = 0; cnt < 5; ++cnt)			\
	{								\
	  if (hdr->arelt[cnt] < ' ' || hdr->arelt[cnt] > ' ' + 0x3f)	\
	    return -1;							\
	  buf->stelt <<= 6;						\
	  buf->stelt += hdr->arelt[cnt] - ' ';				\
	}								\
      if (hdr->arelt[5] < '@@' || hdr->arelt[5] > '@@' + 3)		\
	return -1;							\
      buf->stelt <<= 2;							\
      buf->stelt += hdr->arelt[5] - '@@';				\
    }
#else
# define foo2(arelt, stelt, size) foo (arelt, stelt, size)
#endif

  foo (ar_date, st_mtime, 10);
  foo2 (ar_uid, st_uid, 10);
  foo2 (ar_gid, st_gid, 10);
  foo (ar_mode, st_mode, 8);

  buf->st_size = arch_eltdata (abfd)->parsed_size;

  return 0;
}

void
bfd_dont_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  /* FIXME: This interacts unpleasantly with ar's quick-append option.
     Fortunately ic960 users will never use that option.  Fixing this
     is very hard; fortunately I know how to do it and will do so once
     intel's release is out the door.  */

  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename;
  size_t maxlen = ar_maxnamelen (abfd);

  if ((bfd_get_file_flags (abfd) & BFD_TRADITIONAL_FORMAT) != 0)
    {
      bfd_bsd_truncate_arname (abfd, pathname, arhdr);
      return;
    }

  filename = normalize (abfd, pathname);
  if (filename == NULL)
    {
      /* FIXME */
      abort ();
    }

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);

  /* Add the padding character if there is room for it.  */
  if (length < maxlen
      || (length == maxlen && length < sizeof hdr->ar_name))
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

void
bfd_bsd_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename = lbasename (pathname);
  size_t maxlen = ar_maxnamelen (abfd);

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);
  else
    {
      /* pathname: meet procrustes */
      memcpy (hdr->ar_name, filename, maxlen);
      length = maxlen;
    }

  if (length < maxlen)
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

/* Store name into ar header.  Truncates the name to fit.
   1> strip pathname to be just the basename.
   2> if it's short enuf to fit, stuff it in.
   3> If it doesn't end with .o, truncate it to fit
   4> truncate it before the .o, append .o, stuff THAT in.  */

/* This is what gnu ar does.  It's better but incompatible with the
   bsd ar.  */

void
bfd_gnu_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename = lbasename (pathname);
  size_t maxlen = ar_maxnamelen (abfd);

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);
  else
    {
      /* pathname: meet procrustes.  */
      memcpy (hdr->ar_name, filename, maxlen);
      if ((filename[length - 2] == '.') && (filename[length - 1] == 'o'))
	{
	  hdr->ar_name[maxlen - 2] = '.';
	  hdr->ar_name[maxlen - 1] = 'o';
	}
      length = maxlen;
    }

  if (length < 16)
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

/* The BFD is open for write and has its format set to bfd_archive.  */

bfd_boolean
_bfd_write_archive_contents (bfd *arch)
{
  bfd *current;
  char *etable = NULL;
  bfd_size_type elength = 0;
  const char *ename = NULL;
  bfd_boolean makemap = bfd_has_map (arch);
  /* If no .o's, don't bother to make a map.  */
  bfd_boolean hasobjects = FALSE;
  bfd_size_type wrote;
  int tries;
  char *armag;

  /* Verify the viability of all entries; if any of them live in the
     filesystem (as opposed to living in an archive open for input)
     then construct a fresh ar_hdr for them.  */
  for (current = arch->archive_head;
       current != NULL;
       current = current->archive_next)
    {
      /* This check is checking the bfds for the objects we're reading
	 from (which are usually either an object file or archive on
	 disk), not the archive entries we're writing to.  We don't
	 actually create bfds for the archive members, we just copy
	 them byte-wise when we write out the archive.  */
      if (bfd_write_p (current))
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  goto input_err;
	}
      if (!current->arelt_data)
	{
	  current->arelt_data =
	    bfd_ar_hdr_from_filesystem (arch, current->filename, current);
	  if (!current->arelt_data)
	    goto input_err;

	  /* Put in the file name.  */
	  BFD_SEND (arch, _bfd_truncate_arname,
		    (arch, current->filename, (char *) arch_hdr (current)));
	}

      if (makemap && ! hasobjects)
	{			/* Don't bother if we won't make a map!  */
	  if ((bfd_check_format (current, bfd_object)))
	    hasobjects = TRUE;
	}
    }

  if (!BFD_SEND (arch, _bfd_construct_extended_name_table,
		 (arch, &etable, &elength, &ename)))
    return FALSE;

  if (bfd_seek (arch, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  armag = ARMAG;
  if (bfd_is_thin_archive (arch))
    armag = ARMAGT;
  wrote = bfd_bwrite (armag, SARMAG, arch);
  if (wrote != SARMAG)
    return FALSE;

  if (makemap && hasobjects)
    {
      if (! _bfd_compute_and_write_armap (arch, (unsigned int) elength))
	return FALSE;
    }

  if (elength != 0)
    {
      struct ar_hdr hdr;

      memset (&hdr, ' ', sizeof (struct ar_hdr));
      memcpy (hdr.ar_name, ename, strlen (ename));
      /* Round size up to even number in archive header.  */
      if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
			    (elength + 1) & ~(bfd_size_type) 1))
	return FALSE;
      memcpy (hdr.ar_fmag, ARFMAG, 2);
      if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
	   != sizeof (struct ar_hdr))
	  || bfd_bwrite (etable, elength, arch) != elength)
	return FALSE;
      if ((elength % 2) == 1)
	{
	  if (bfd_bwrite (&ARFMAG[1], 1, arch) != 1)
	    return FALSE;
	}
    }

  for (current = arch->archive_head;
       current != NULL;
       current = current->archive_next)
    {
      char buffer[DEFAULT_BUFFERSIZE];
      bfd_size_type remaining = arelt_size (current);

      /* Write ar header.  */
      if (!_bfd_write_ar_hdr (arch, current))
	return FALSE;
      if (bfd_is_thin_archive (arch))
	continue;
      if (bfd_seek (current, (file_ptr) 0, SEEK_SET) != 0)
	goto input_err;

      while (remaining)
	{
	  unsigned int amt = DEFAULT_BUFFERSIZE;

	  if (amt > remaining)
	    amt = remaining;
	  errno = 0;
	  if (bfd_bread (buffer, amt, current) != amt)
	    {
	      if (bfd_get_error () != bfd_error_system_call)
		bfd_set_error (bfd_error_file_truncated);
	      goto input_err;
	    }
	  if (bfd_bwrite (buffer, amt, arch) != amt)
	    return FALSE;
	  remaining -= amt;
	}

      if ((arelt_size (current) % 2) == 1)
	{
	  if (bfd_bwrite (&ARFMAG[1], 1, arch) != 1)
	    return FALSE;
	}
    }

  if (makemap && hasobjects)
    {
      /* Verify the timestamp in the archive file.  If it would not be
	 accepted by the linker, rewrite it until it would be.  If
	 anything odd happens, break out and just return.  (The
	 Berkeley linker checks the timestamp and refuses to read the
	 table-of-contents if it is >60 seconds less than the file's
	 modified-time.  That painful hack requires this painful hack.  */
      tries = 1;
      do
	{
	  if (bfd_update_armap_timestamp (arch))
	    break;
	  (*_bfd_error_handler)
	    (_("Warning: writing archive was slow: rewriting timestamp\n"));
	}
      while (++tries < 6);
    }

  return TRUE;

 input_err:
  bfd_set_error (bfd_error_on_input, current, bfd_get_error ());
  return FALSE;
}

/* Note that the namidx for the first symbol is 0.  */

bfd_boolean
_bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
{
  char *first_name = NULL;
  bfd *current;
  file_ptr elt_no = 0;
  struct orl *map = NULL;
  unsigned int orl_max = 1024;		/* Fine initial default.  */
  unsigned int orl_count = 0;
  int stridx = 0;
  asymbol **syms = NULL;
  long syms_max = 0;
  bfd_boolean ret;
  bfd_size_type amt;

  /* Dunno if this is the best place for this info...  */
  if (elength != 0)
    elength += sizeof (struct ar_hdr);
  elength += elength % 2;

  amt = orl_max * sizeof (struct orl);
  map = (struct orl *) bfd_malloc (amt);
  if (map == NULL)
    goto error_return;

  /* We put the symbol names on the arch objalloc, and then discard
     them when done.  */
  first_name = (char *) bfd_alloc (arch, 1);
  if (first_name == NULL)
    goto error_return;

  /* Drop all the files called __.SYMDEF, we're going to make our own.  */
  while (arch->archive_head
	 && strcmp (arch->archive_head->filename, "__.SYMDEF") == 0)
    arch->archive_head = arch->archive_head->archive_next;

  /* Map over each element.  */
  for (current = arch->archive_head;
       current != NULL;
       current = current->archive_next, elt_no++)
    {
      if (bfd_check_format (current, bfd_object)
	  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)
	{
	  long storage;
	  long symcount;
	  long src_count;

	  storage = bfd_get_symtab_upper_bound (current);
	  if (storage < 0)
	    goto error_return;

	  if (storage != 0)
	    {
	      if (storage > syms_max)
		{
		  if (syms_max > 0)
		    free (syms);
		  syms_max = storage;
		  syms = (asymbol **) bfd_malloc (syms_max);
		  if (syms == NULL)
		    goto error_return;
		}
	      symcount = bfd_canonicalize_symtab (current, syms);
	      if (symcount < 0)
		goto error_return;

	      /* Now map over all the symbols, picking out the ones we
		 want.  */
	      for (src_count = 0; src_count < symcount; src_count++)
		{
		  flagword flags = (syms[src_count])->flags;
		  asection *sec = syms[src_count]->section;

		  if (((flags & (BSF_GLOBAL
				 | BSF_WEAK
				 | BSF_INDIRECT
				 | BSF_GNU_UNIQUE)) != 0
		       || bfd_is_com_section (sec))
		      && ! bfd_is_und_section (sec))
		    {
		      bfd_size_type namelen;
		      struct orl *new_map;

		      /* This symbol will go into the archive header.  */
		      if (orl_count == orl_max)
			{
			  orl_max *= 2;
			  amt = orl_max * sizeof (struct orl);
			  new_map = (struct orl *) bfd_realloc (map, amt);
			  if (new_map == NULL)
			    goto error_return;

			  map = new_map;
			}

		      namelen = strlen (syms[src_count]->name);
		      amt = sizeof (char *);
		      map[orl_count].name = (char **) bfd_alloc (arch, amt);
		      if (map[orl_count].name == NULL)
			goto error_return;
		      *(map[orl_count].name) = (char *) bfd_alloc (arch,
								   namelen + 1);
		      if (*(map[orl_count].name) == NULL)
			goto error_return;
		      strcpy (*(map[orl_count].name), syms[src_count]->name);
		      map[orl_count].u.abfd = current;
		      map[orl_count].namidx = stridx;

		      stridx += namelen + 1;
		      ++orl_count;
		    }
		}
	    }

	  /* Now ask the BFD to free up any cached information, so we
	     don't fill all of memory with symbol tables.  */
	  if (! bfd_free_cached_info (current))
	    goto error_return;
	}
    }

  /* OK, now we have collected all the data, let's write them out.  */
  ret = BFD_SEND (arch, write_armap,
		  (arch, elength, map, orl_count, stridx));

  if (syms_max > 0)
    free (syms);
  if (map != NULL)
    free (map);
  if (first_name != NULL)
    bfd_release (arch, first_name);

  return ret;

 error_return:
  if (syms_max > 0)
    free (syms);
  if (map != NULL)
    free (map);
  if (first_name != NULL)
    bfd_release (arch, first_name);

  return FALSE;
}

bfd_boolean
bsd_write_armap (bfd *arch,
		 unsigned int elength,
		 struct orl *map,
		 unsigned int orl_count,
		 int stridx)
{
  int padit = stridx & 1;
  unsigned int ranlibsize = orl_count * BSD_SYMDEF_SIZE;
  unsigned int stringsize = stridx + padit;
  /* Include 8 bytes to store ranlibsize and stringsize in output.  */
  unsigned int mapsize = ranlibsize + stringsize + 8;
  file_ptr firstreal;
  bfd *current = arch->archive_head;
  bfd *last_elt = current;	/* Last element arch seen.  */
  bfd_byte temp[4];
  unsigned int count;
  struct ar_hdr hdr;
  long uid, gid;

  firstreal = mapsize + elength + sizeof (struct ar_hdr) + SARMAG;

  /* If deterministic, we use 0 as the timestamp in the map.
     Some linkers may require that the archive filesystem modification
     time is less than (or near to) the archive map timestamp.  Those
     linkers should not be used with deterministic mode.  (GNU ld and
     Gold do not have this restriction.)  */
  bfd_ardata (arch)->armap_timestamp = 0;
  uid = 0;
  gid = 0;
  if ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0)
    {
      struct stat statbuf;

      if (stat (arch->filename, &statbuf) == 0)
	bfd_ardata (arch)->armap_timestamp = (statbuf.st_mtime
					      + ARMAP_TIME_OFFSET);
      uid = getuid();
      gid = getgid();
    }

  memset (&hdr, ' ', sizeof (struct ar_hdr));
  memcpy (hdr.ar_name, RANLIBMAG, strlen (RANLIBMAG));
  bfd_ardata (arch)->armap_datepos = (SARMAG
				      + offsetof (struct ar_hdr, ar_date[0]));
  _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
		    bfd_ardata (arch)->armap_timestamp);
  _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld", uid);
  _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld", gid);
  if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))
    return FALSE;
  memcpy (hdr.ar_fmag, ARFMAG, 2);
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return FALSE;
  H_PUT_32 (arch, ranlibsize, temp);
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;

  for (count = 0; count < orl_count; count++)
    {
      unsigned int offset;
      bfd_byte buf[BSD_SYMDEF_SIZE];

      if (map[count].u.abfd != last_elt)
	{
	  do
	    {
	      struct areltdata *ared = arch_eltdata (current);

	      firstreal += (ared->parsed_size + ared->extra_size
			    + sizeof (struct ar_hdr));
	      firstreal += firstreal % 2;
	      current = current->archive_next;
	    }
	  while (current != map[count].u.abfd);
	}

      /* The archive file format only has 4 bytes to store the offset
	 of the member.  Check to make sure that firstreal has not grown
	 too big.  */
      offset = (unsigned int) firstreal;
      if (firstreal != (file_ptr) offset)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return FALSE;
	}

      last_elt = current;
      H_PUT_32 (arch, map[count].namidx, buf);
      H_PUT_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);
      if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)
	  != BSD_SYMDEF_SIZE)
	return FALSE;
    }

  /* Now write the strings themselves.  */
  H_PUT_32 (arch, stringsize, temp);
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;
  for (count = 0; count < orl_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
    }

  /* The spec sez this should be a newline.  But in order to be
     bug-compatible for sun's ar we use a null.  */
  if (padit)
    {
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
    }

  return TRUE;
}

/* At the end of archive file handling, update the timestamp in the
   file, so the linker will accept it.

   Return TRUE if the timestamp was OK, or an unusual problem happened.
   Return FALSE if we updated the timestamp.  */

bfd_boolean
_bfd_archive_bsd_update_armap_timestamp (bfd *arch)
{
  struct stat archstat;
  struct ar_hdr hdr;

  /* If creating deterministic archives, just leave the timestamp as-is.  */
  if ((arch->flags & BFD_DETERMINISTIC_OUTPUT) != 0)
    return TRUE;

  /* Flush writes, get last-write timestamp from file, and compare it
     to the timestamp IN the file.  */
  bfd_flush (arch);
  if (bfd_stat (arch, &archstat) == -1)
    {
      bfd_perror (_("Reading archive file mod timestamp"));

      /* Can't read mod time for some reason.  */
      return TRUE;
    }
  if (((long) archstat.st_mtime) <= bfd_ardata (arch)->armap_timestamp)
    /* OK by the linker's rules.  */
    return TRUE;

  /* Update the timestamp.  */
  bfd_ardata (arch)->armap_timestamp = archstat.st_mtime + ARMAP_TIME_OFFSET;

  /* Prepare an ASCII version suitable for writing.  */
  memset (hdr.ar_date, ' ', sizeof (hdr.ar_date));
  _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
		    bfd_ardata (arch)->armap_timestamp);

  /* Write it into the file.  */
  bfd_ardata (arch)->armap_datepos = (SARMAG
				      + offsetof (struct ar_hdr, ar_date[0]));
  if (bfd_seek (arch, bfd_ardata (arch)->armap_datepos, SEEK_SET) != 0
      || (bfd_bwrite (hdr.ar_date, sizeof (hdr.ar_date), arch)
	  != sizeof (hdr.ar_date)))
    {
      bfd_perror (_("Writing updated armap timestamp"));

      /* Some error while writing.  */
      return TRUE;
    }

  /* We updated the timestamp successfully.  */
  return FALSE;
}

/* A coff armap looks like :
   lARMAG
   struct ar_hdr with name = '/'
   number of symbols
   offset of file for symbol 0
   offset of file for symbol 1

   offset of file for symbol n-1
   symbol name 0
   symbol name 1

   symbol name n-1  */

bfd_boolean
coff_write_armap (bfd *arch,
		  unsigned int elength,
		  struct orl *map,
		  unsigned int symbol_count,
		  int stridx)
{
  /* The size of the ranlib is the number of exported symbols in the
     archive * the number of bytes in an int, + an int for the count.  */
  unsigned int ranlibsize = (symbol_count * 4) + 4;
  unsigned int stringsize = stridx;
  unsigned int mapsize = stringsize + ranlibsize;
  file_ptr archive_member_file_ptr;
  bfd *current = arch->archive_head;
  unsigned int count;
  struct ar_hdr hdr;
  int padit = mapsize & 1;

  if (padit)
    mapsize++;

  /* Work out where the first object file will go in the archive.  */
  archive_member_file_ptr = (mapsize
			     + elength
			     + sizeof (struct ar_hdr)
			     + SARMAG);

  memset (&hdr, ' ', sizeof (struct ar_hdr));
  hdr.ar_name[0] = '/';
  if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))
    return FALSE;
  _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
		    ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0
		     ? time (NULL) : 0));
  /* This, at least, is what Intel coff sets the values to.  */
  _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld", 0);
  _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld", 0);
  _bfd_ar_spacepad (hdr.ar_mode, sizeof (hdr.ar_mode), "%-7lo", 0);
  memcpy (hdr.ar_fmag, ARFMAG, 2);

  /* Write the ar header for this item and the number of symbols.  */
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return FALSE;

  if (!bfd_write_bigendian_4byte_int (arch, symbol_count))
    return FALSE;

  /* Two passes, first write the file offsets for each symbol -
     remembering that each offset is on a two byte boundary.  */

  /* Write out the file offset for the file associated with each
     symbol, and remember to keep the offsets padded out.  */

  current = arch->archive_head;
  count = 0;
  while (current != NULL && count < symbol_count)
    {
      /* For each symbol which is used defined in this object, write
	 out the object file's address in the archive.  */

      while (count < symbol_count && map[count].u.abfd == current)
	{
	  unsigned int offset = (unsigned int) archive_member_file_ptr;

	  /* Catch an attempt to grow an archive past its 4Gb limit.  */
	  if (archive_member_file_ptr != (file_ptr) offset)
	    {
	      bfd_set_error (bfd_error_file_truncated);
	      return FALSE;
	    }
	  if (!bfd_write_bigendian_4byte_int (arch, offset))
	    return FALSE;
	  count++;
	}
      archive_member_file_ptr += sizeof (struct ar_hdr);
      if (! bfd_is_thin_archive (arch))
	{
	  /* Add size of this archive entry.  */
	  archive_member_file_ptr += arelt_size (current);
	  /* Remember about the even alignment.  */
	  archive_member_file_ptr += archive_member_file_ptr % 2;
	}
      current = current->archive_next;
    }

  /* Now write the strings themselves.  */
  for (count = 0; count < symbol_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
    }

  /* The spec sez this should be a newline.  But in order to be
     bug-compatible for arc960 we use a null.  */
  if (padit)
    {
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
    }

  return TRUE;
}

static int
archive_close_worker (void **slot, void *inf ATTRIBUTE_UNUSED)
{
  struct ar_cache *ent = (struct ar_cache *) *slot;

  bfd_close_all_done (ent->arbfd);
  return 1;
}

bfd_boolean
_bfd_archive_close_and_cleanup (bfd *abfd)
{
  if (bfd_read_p (abfd) && abfd->format == bfd_archive)
    {
      bfd *nbfd;
      bfd *next;
      htab_t htab;

      /* Close nested archives (if this bfd is a thin archive).  */
      for (nbfd = abfd->nested_archives; nbfd; nbfd = next)
	{
	  next = nbfd->archive_next;
	  bfd_close (nbfd);
	}

      htab = bfd_ardata (abfd)->cache;
      if (htab)
	{
	  htab_traverse_noresize (htab, archive_close_worker, NULL);
	  htab_delete (htab);
	  bfd_ardata (abfd)->cache = NULL;
	}
    }
  if (arch_eltdata (abfd) != NULL)
    {
      struct areltdata *ared = arch_eltdata (abfd);
      htab_t htab = (htab_t) ared->parent_cache;

      if (htab)
	{
	  struct ar_cache ent;
	  void **slot;

	  ent.ptr = ared->key;
	  slot = htab_find_slot (htab, &ent, NO_INSERT);
	  if (slot != NULL)
	    {
	      BFD_ASSERT (((struct ar_cache *) *slot)->arbfd == abfd);
	      htab_clear_slot (htab, slot);
	    }
	}
    }
  return TRUE;
}
@


1.98
log
@Don't allow a nested archive pointing to itself

	PR binutils/15151
	* archive.c (_bfd_find_nested_archive): Don't allow a nested
	archive pointing to itself.
	(_bfd_get_elt_at_filepos): Revert the last 2 changes.
@
text
@d2735 1
a2735 1
  else if (arch_eltdata (abfd) != NULL)
@


1.97
log
@Allow for some recursion when scanning archives.
@
text
@d382 7
a626 2
  static file_ptr prev_filepos;
  static unsigned int dup_filepos_count = 0;
a633 11
  /* PR15140: Prevent an infinite recursion scanning a malformed nested archive.  */
  if (filepos == prev_filepos)
    {
      if (++ dup_filepos_count > 100)
	{
	  bfd_set_error (bfd_error_malformed_archive);
	  return NULL;
	}
    }
  else
    dup_filepos_count = 0;
a641 1
  prev_filepos = filepos;
@


1.96
log
@	PR binutils/15140
	* ar.c (open_inarch): Fail on attempts to convert a normal archive
	to a thin archive or vice versa.
	* elfcomm.c (make_qualified_name): Handle corrupted thin
	archives.
	* readelf.c (process_archive): Likewise.
	* doc/binutils.texi: Clarify documentation describing thin
	archives.

	* archive.c (_bfd_get_elt_at_filepos): Prevent an infinite loop
	accessing a corrupt nested archive.
@
text
@d621 1
d629 1
a629 1
  /* PR15140: Prevent an inifnite recursion scanning a malformed nested archive.  */
d632 5
a636 2
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
d638 2
@


1.95
log
@	* archive.c (bfd_generic_archive_p): Return target and keep
	ardata on partial matches.
	* format.c (bfd_check_format_matches): Adjust for above
	change.  Remove bfd_error_file_ambiguously_recognized dead
	code.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012  Free Software Foundation, Inc.
d620 1
d628 6
d642 1
@


1.94
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d855 1
a855 5
	    {
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
	      return NULL;
	    }
@


1.93
log
@Properly check indicies bigger than 4Gb

	PR binutils/14933
	* archive.c (bsd_write_armap): Properly check indicies bigger
	than 4Gb.
@
text
@d2495 1
a2495 1
      
@


1.92
log
@	* vms-lib.c (_bfd_vms_lib_get_module): Use bfd_zmalloc for
	areltdata.
	* opncls.c (_bfd_delete_bfd): Free arelt_data.
	* mach-o.c (bfd_mach_o_fat_member_init): Use bfd_zmalloc for
	areltdata.
	* ecoff.c (_bfd_ecoff_slurp_armap): Use free for mapdata.
	* coff-rs6000.c (_bfd_xcoff_read_ar_hdr): Use bfd_zmalloc for
	areltdata.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.
	* archive64.c (bfd_elf64_archive_slurp_armap): Use free for
	areltdata.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Use bfd_zmalloc and
	free for areltdata.
	(_bfd_get_elt_at_filepos): Likewise.  Clear n_nfd->arelt_data on
	failure.
	(do_slurp_bsd_armap): Use bfd_zmalloc and free for areltdata.
	(do_slurp_coff_armap): Likewise.
	(_bfd_slurp_extended_name_table): Likewise.
	(bfd_slurp_bsd_armap_f2): Likewise.  Don't leak 'mapdata'.
@
text
@a2426 3
  file_ptr max_first_real = 1;

  max_first_real <<= 31;
d2469 1
d2489 2
a2490 1
      if (firstreal >= max_first_real)
@


1.91
log
@	PR binutils/14475:
	* archive.c (bfd_ar_hdr_from_filesystem): Revert last change.
	Instead malloc areltdata.
@
text
@d520 1
a520 1
      allocptr = (char *) bfd_zalloc (abfd, allocsize);
d528 1
d564 1
a564 1
      allocptr = (char *) bfd_zalloc (abfd, allocsize);
d647 4
a650 1
	    return NULL;
d662 1
a662 1
	      bfd_release (archive, new_areldata);
d668 1
a668 1
	      bfd_release (archive, new_areldata);
d690 1
a690 1
      bfd_release (archive, new_areldata);
d714 2
a715 1
  bfd_release (archive, new_areldata);
d902 1
a902 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d978 1
a978 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d1071 1
a1071 1
	bfd_release (abfd, tmp);
d1188 1
a1191 1
      bfd_release (abfd, mapdata);
d1197 2
d1300 1
a1300 1
	  bfd_release (abfd, namedata);
d1337 1
a1337 2
      /* FIXME, we can't release namedata here because it was allocated
	 below extended_names on the objalloc...  */
@


1.90
log
@	PR binutils/14475:
	* archive.c (bfd_ar_hdr_from_filesystem): Allocate areltdata on
	'member' BFD.  Don't try to free 'ared'.
@
text
@d1899 1
a1899 1
  ared = (struct areltdata *) bfd_zalloc (member, amt);
d1930 4
a1933 1
    return NULL;
@


1.89
log
@	* archive.c (SECTION Archives): Update documentation.
	(_bfd_delete_archive_data): Remove.
	(_bfd_add_bfd_to_archive_cache): Set 'parent_cache' and 'key'.
	(archive_close_worker, _bfd_archive_close_and_cleanup): New
	functions.
	* libbfd-in.h (struct areltdata <parent_cache, key>): New fields.
	(_bfd_delete_archive_data): Don't declare.
	(_bfd_archive_close_and_cleanup): Declare.
	(_bfd_generic_close_and_cleanup): Redefine.
	* libbfd.h: Rebuild.
	* opncls.c (_bfd_delete_bfd): Don't call _bfd_delete_archive_data.
	(bfd_close): Don't close nested thin archives here.
@
text
@d1899 1
a1899 1
  ared = (struct areltdata *) bfd_zalloc (abfd, amt);
d1930 1
a1930 4
    {
      free (ared);
      return NULL;
    }
@


1.88
log
@	* config/tc-i386.c (lex_got): Provide implementation for PE
	format.

	* gas/i386/secrel.s: Add test of <symbol>@@SECREL32.
	* gas/i386/secrel.d: Add expected disassembly.

	* scripttempl/pe.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.
	* scripttempl/pep.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.

	* archive.c (_bfd_delete_archive_data): New function.
	* libbfd-in.h (_bfd_delete_archive_data): Declare.
	* libbfd.h: Rebuild.
	* opncls.c (_bfd_delete_bfd): Call _bfd_delete_archive_data.
@
text
@d45 6
d52 4
a55 4
	<<next>> pointer in a BFD.  The first one is findable through
	the <<archive_head>> slot of the archive.  Set it with
	<<bfd_set_archive_head>> (q.v.).  A given BFD may be in only one
	open output archive at a time.
a301 13
/* Free the archive hash table, if it exists.  */

void
_bfd_delete_archive_data (bfd *abfd)
{
  struct artdata *ardata = bfd_ardata (abfd);

  BFD_ASSERT (abfd->format == bfd_archive);

  if (ardata && ardata->cache)
    htab_delete (ardata->cache);
}

d371 4
d2695 55
@


1.87
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d296 13
@


1.87.4.1
log
@Properly check indicies bigger than 4Gb

	PR binutils/14933
	* archive.c (bsd_write_armap): Properly check indicies bigger than
	4Gb.
@
text
@d2411 3
a2455 1
      unsigned int offset;
d2475 1
a2475 2
      offset = (unsigned int) firstreal;
      if (firstreal != (file_ptr) offset)
@


1.86
log
@	* archive.c (bsd_write_armap): Catch attempts to create an archive
	with indicies bigger than 4Gb.
	(coff_write_armap): Likewise.

	* readelf.c (process_archive): Display member indicies when
	dumping index.
@
text
@d150 2
a151 1
struct ar_cache {
d172 1
d301 1
d317 1
a317 1
hash_file_ptr (const PTR p)
d325 1
a325 1
eq_file_ptr (const PTR p1, const PTR p2)
@


1.85
log
@Simplify global symbol handling

	* archive.c (_bfd_compute_and_write_armap): Simplify global
	symbol handling.
@
text
@d2408 3
d2469 9
d2589 1
a2589 1
  unsigned int archive_member_file_ptr;
d2640 9
a2648 1
	  if (!bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr))
@


1.84
log
@* archive.c (_bfd_generic_read_ar_hdr_mag): Fix last change so as
not to clobber the ar_fmag field stored in ARED->arch_header.
@
text
@d2317 4
a2320 4
		  if ((flags & BSF_GLOBAL
		       || flags & BSF_WEAK
		       || flags & BSF_INDIRECT
		       || flags & BSF_GNU_UNIQUE
@


1.83
log
@	* archive.c (_bfd_generic_read_ar_hdr_mag):  Ensure sscanf
	stops at end of ar_size field.
@
text
@d376 1
a376 1
        return abfd;
d416 4
a419 4
        {
          bfd_set_error (bfd_error_malformed_archive);
          return NULL;
        }
d458 2
d476 1
d478 3
a480 1
  if (sscanf (hdr.ar_size, "%" BFD_VMA_FMT "u", &parsed_size) != 1)
d630 5
a634 5
        {
          filename = _bfd_append_relative_path (archive, filename);
          if (filename == NULL)
            return NULL;
        }
d637 20
a656 20
        {
          /* This proxy entry refers to an element of a nested archive.
             Locate the member of that archive and return a bfd for it.  */
          bfd *ext_arch = _bfd_find_nested_archive (archive, filename);

          if (ext_arch == NULL
              || ! bfd_check_format (ext_arch, bfd_archive))
            {
              bfd_release (archive, new_areldata);
              return NULL;
            }
          n_nfd = _bfd_get_elt_at_filepos (ext_arch, new_areldata->origin);
          if (n_nfd == NULL)
            {
              bfd_release (archive, new_areldata);
              return NULL;
            }
          n_nfd->proxy_origin = bfd_tell (archive);
          return n_nfd;
        }
d658 1
a658 1
         open the external file as a bfd.  */
d756 1
a756 1
        filestart += size;
d1002 1
a1002 1
                                                  carsym_size + stringsize + 1);
d1102 2
a1103 2
         However because this name has a space it is slightly more difficult
         to check it.  */
d1108 1
a1108 1
        return FALSE;
d1111 1
a1111 1
        return FALSE;
d1113 1
a1113 1
        return FALSE;
d1115 2
a1116 2
          || CONST_STRNEQ (extname, "__.SYMDEF"))
        return do_slurp_bsd_armap (abfd);
d1273 1
a1273 1
        goto byebye;
d1299 1
a1299 1
        char *ext_names = bfd_ardata (abfd)->extended_names;
d1389 1
a1389 1
   
d1412 1
a1412 1
 
d1438 1
a1438 1
	   at the current level.  */	
d1449 1
a1449 1
  
d1554 2
a1555 2
        {
          const char *filename = current->filename;
d1557 25
a1581 25
          /* If the element being added is a member of another archive
             (i.e., we are flattening), use the containing archive's name.  */
          if (current->my_archive
              && ! bfd_is_thin_archive (current->my_archive))
            filename = current->my_archive->filename;

          /* If the path is the same as the previous path seen,
             reuse it.  This can happen when flattening a thin
             archive that contains other archives.  */
          if (last_filename && filename_cmp (last_filename, filename) == 0)
            continue;

          last_filename = filename;

          /* If the path is relative, adjust it relative to
             the containing archive. */
          if (! IS_ABSOLUTE_PATH (filename)
              && ! IS_ABSOLUTE_PATH (abfd->filename))
            normal = adjust_relative_path (filename, abfd->filename);
          else
            normal = filename;

          /* In a thin archive, always store the full pathname
             in the extended name table.  */
          total_namelen += strlen (normal) + 1;
d1586 2
a1587 2
          continue;
        }
d1617 1
a1617 1
	         didn't need to.  Fix it to use normal format.  */
d1649 19
a1667 19
        {
          /* If the element being added is a member of another archive
             (i.e., we are flattening), use the containing archive's name.  */
          if (current->my_archive
              && ! bfd_is_thin_archive (current->my_archive))
            filename = current->my_archive->filename;
          /* If the path is the same as the previous path seen,
             reuse it.  This can happen when flattening a thin
             archive that contains other archives.
             If the path is relative, adjust it relative to
             the containing archive.  */
          if (last_filename && filename_cmp (last_filename, filename) == 0)
            normal = last_filename;
          else if (! IS_ABSOLUTE_PATH (filename)
                   && ! IS_ABSOLUTE_PATH (abfd->filename))
            normal = adjust_relative_path (filename, abfd->filename);
          else
            normal = filename;
        }
d1669 5
a1673 5
        {
          normal = normalize (current, filename);
          if (normal == NULL)
            return FALSE;
        }
d1684 2
a1685 2
          else
            {
d1688 1
a1688 1
	        strptr[thislen] = ARFMAG[1];
d1690 4
a1693 4
	        {
	          strptr[thislen] = '/';
	          strptr[thislen + 1] = ARFMAG[1];
	        }
d1701 1
a1701 1
	                          stroff);
d1703 2
a1704 2
                                "%-ld",
                                current->origin - sizeof (struct ar_hdr));
d1707 3
a1709 3
            _bfd_ar_spacepad (hdr->ar_name + 1, maxname - 1, "%-ld", stroff);
          if (normal != last_filename)
            {
d1712 2
a1713 2
	        ++strptr;
              last_filename = filename;
d1726 3
a1728 3
                                                  char **tabloc,
                                                  bfd_size_type *tablen,
                                                  const char **name)
d1749 2
a1750 2
        if (normal[len] == ' ')
          has_space = 1;
d1754 1
a1754 1
          struct ar_hdr *hdr = arch_hdr (current);
d1756 3
a1758 3
          len = (len + 3) & ~3;
          arch_eltdata (current)->extra_size = len;
          _bfd_ar_spacepad (hdr->ar_name, maxname, "#1/%lu", len);
d1794 2
a1795 2
                            arch_eltdata (abfd)->parsed_size + padded_len))
        return FALSE;
d1798 1
a1798 1
        return FALSE;
d1801 1
a1801 1
        return FALSE;
d1804 2
a1805 2
        {
          static const char pad[3] = { 0, 0, 0 };
d1807 4
a1810 4
          len = 4 - (len & 3);
          if (bfd_bwrite (pad, len, archive) != len)
            return FALSE;
        }
d1815 1
a1815 1
        return FALSE;
d1895 1
a1895 1
                    status.st_mtime);
d1904 1
a1904 1
                      status.st_uid);
d1913 1
a1913 1
                      status.st_gid);
d1915 1
a1915 1
                    status.st_mode);
d2161 2
a2162 2
                            (elength + 1) & ~(bfd_size_type) 1))
        return FALSE;
d2184 1
a2184 1
        return FALSE;
d2186 1
a2186 1
        continue;
d2311 1
a2311 1
                 want.  */
d2345 1
a2345 1
                                                                   namelen + 1);
d2435 1
a2435 1
                    bfd_ardata (arch)->armap_timestamp);
d2456 1
a2456 1
              struct areltdata *ared = arch_eltdata (current);
d2459 1
a2459 1
                            + sizeof (struct ar_hdr));
d2533 1
a2533 1
                    bfd_ardata (arch)->armap_timestamp);
d2597 2
a2598 2
                    ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0
                     ? time (NULL) : 0));
d2634 6
a2639 6
        {
          /* Add size of this archive entry.  */
          archive_member_file_ptr += arelt_size (current);
          /* Remember about the even alignment.  */
          archive_member_file_ptr += archive_member_file_ptr % 2;
        }
@


1.82
log
@2012-02-02  Tristan Gingold  <gingold@@adacore.com>

	* archive.c (bfd_slurp_armap): Fix thinko in cast.
@
text
@d474 1
@


1.81
log
@	PR binutils/13534
	* archive.c (_bfd_ar_sizepad): New function. Correctly install and
	pad the size field in an archive header.
	(_bfd_generic_read_ar_hdr_mag): Use the correct type and scan
	function for the archive size field.
	(bfd_generic_openr_next_archived_file): Likewise.
	(do_slurp_coff_armap): Likewise.
	(_bfd_write_archive_contents): Likewise.
	(_bfd_bsd44_write_ar_hdr): Use the new function.
	(bfd_ar_hdr_from_filesystem): Likewise.
	(_bfd_write_archive_contents): Likewise.
	(bsd_write_armap): Likewise.
	(coff_write_armap): Likewise.
	* archive64.c (bfd_elf64_archive_write_armap): Likewise.
	* bfdio.c (bfd_bread): Use correct type for archive element
	sizes.
	* ar.c (open_inarch): Likewise.
	(extract_file): Likewise.
	* libbfd-in.h (struct areltdata): Use correct types for
	parsed_size and extra_size fields.
	Prototype _bfd_ar_sizepad function.
	* libbfd.h: Regenerate.
@
text
@d1106 1
a1106 1
      if (bfd_seek (abfd, (file_ptr) -(sizeof (hdr) + 20), SEEK_CUR) != 0)
@


1.80
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (bfd_tell): Handle nested archives.
	(bfd_seek): Ditto.
	* cache.c (bfd_cache_lookup_worker): Ditto.
	* archive.c (_bfd_get_elt_at_filepos): Remove code dealing with
	nested archives.
	(bfd_generic_openr_next_archived_file): Likewise.
@
text
@d3 2
a4 2
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d181 23
d450 1
a450 1
  size_t parsed_size;
d474 1
a474 2
  parsed_size = strtol (hdr.ar_size, NULL, 10);
  if (errno != 0)
d746 1
a746 1
      unsigned int size = arelt_size (last_file);
d942 1
a942 1
  unsigned int parsed_size;
d1787 3
a1789 2
      _bfd_ar_spacepad (hdr->ar_size, sizeof (hdr->ar_size), "%-10ld",
                        arch_eltdata (abfd)->parsed_size + padded_len);
d1796 1
d1910 5
a1914 2
  _bfd_ar_spacepad (hdr->ar_size, sizeof (hdr->ar_size), "%-10ld",
                    status.st_size);
d2154 3
a2156 2
      _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld",
                        (elength + 1) & ~(bfd_size_type) 1);
d2174 1
a2174 1
      unsigned int remaining = arelt_size (current);
d2432 2
a2433 1
  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld", mapsize);
d2588 2
a2589 2
  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld",
                    mapsize);
@


1.79
log
@	PR binutils/13278
	* archive.c (bfd_generic_archive_p): Only check first element
	when target_defaulted.
	(_bfd_construct_extended_name_table): Use ar_maxnamelen.
	(_bfd_archive_bsd44_construct_extended_name_table): Likewise.
@
text
@a583 6
  if (archive->my_archive)
    {
      filepos += archive->origin;
      archive = archive->my_archive;
    }

a728 2
      if (archive->my_archive)
	filestart -= archive->origin;
@


1.78
log
@	PR binutils/13257
	* archive.c (_bfd_find_nested_archive, _bfd_get_elt_at_filepos): Open
	thin archive element using container target if not defaulted.
@
text
@d796 1
a796 1
  if (bfd_has_map (abfd))
d1515 1
a1515 1
  unsigned int maxname = abfd->xvec->ar_max_namelen;
d1710 1
a1710 1
  unsigned int maxname = abfd->xvec->ar_max_namelen;
@


1.77
log
@	* archive.c (adjust_relative_path): Fix comment to prevent it
	corrupting the auto-generated bfd.h.
@
text
@d346 1
d355 4
a358 1
  abfd = bfd_openr (filename, NULL);
d604 2
d637 4
a640 1
      n_nfd = bfd_openr (filename, NULL);
@


1.77.2.1
log
@	PR binutils/13257
	2011-10-11  Alan Modra  <amodra@@gmail.com>
	* archive.c (_bfd_find_nested_archive, _bfd_get_elt_at_filepos): Open
	thin archive element using container target if not defaulted.
@
text
@a345 1
  const char *target;
d354 1
a354 4
  target = NULL;
  if (!arch_bfd->target_defaulted)
    target = arch_bfd->xvec->name;
  abfd = bfd_openr (filename, target);
a599 2
      const char *target;

d631 1
a631 4
      target = NULL;
      if (!archive->target_defaulted)
	target = archive->xvec->name;
      n_nfd = bfd_openr (filename, target);
@


1.77.2.2
log
@	PR binutils/13278
	2011-10-11  Alan Modra  <amodra@@gmail.com>
	* archive.c (bfd_generic_archive_p): Only check first element
	when target_defaulted.
	(_bfd_construct_extended_name_table): Use ar_maxnamelen.
	(_bfd_archive_bsd44_construct_extended_name_table): Likewise.
@
text
@d796 1
a796 1
  if (abfd->target_defaulted && bfd_has_map (abfd))
d1515 1
a1515 1
  unsigned int maxname = ar_maxnamelen (abfd);
d1710 1
a1710 1
  unsigned int maxname = ar_maxnamelen (abfd);
@


1.76
log
@	PR binutils/12710
	* archive.c (_bfd_get_elt_at_filepos): Set correct error value if
	unable to read a file pointed to by an entry in a thin archive.
	(adjust_relative_path): Use lrealpath to canonicalize paths.
	Handle the case where the reference path is above the current
	path in the directory tree.
@
text
@d1349 2
a1350 2
     ../bar.o       ../lib.a        bar.o
     ../bar.o       lib.a           ../bar.o
d1355 3
a1357 1
     Note - the returned string is in a static buffer.  */
d1359 2
@


1.75
log
@	* archive.c (_bfd_get_elt_at_filepos): Don't release n_nfd.
	* elflink.c (elf_link_add_object_symbols): Delete redundant code.
@
text
@d632 2
d722 1
d756 1
a756 1
    return 0;
d1339 17
a1355 1
/* Adjust a relative path name based on the reference path.  */
d1361 8
a1368 5
  static int pathbuf_len = 0;
  const char *pathp = path;
  const char *refp = ref_path;
  int element_count = 0;
  int len;
d1370 2
d1373 7
d1397 1
d1402 31
a1432 2
      ++element_count;
  len = 3 * element_count + strlen (path) + 1;
d1441 1
a1441 1
	return path;
d1446 1
a1446 1
  while (element_count-- > 0)
a1451 1
  strcpy (newp, pathp);
d1453 8
@


1.74
log
@	* archive.c (bsd_write_armap): Don't call stat in deterministic
	mode, and don't use st_mtime if stat returns error.
@
text
@a663 4
  /* Huh?  */
  /* FIXME:  n_nfd isn't allocated in the archive's memory pool.
     If we reach this point, I think bfd_release will abort.  */
  bfd_release (archive, n_nfd);
@


1.73
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* archive.c (_bfd_slurp_extended_name_table): Fail if bfd_seek fails.
@
text
@a2303 1
  struct stat statbuf;
d2308 8
a2315 1
  stat (arch->filename, &statbuf);
d2318 5
a2322 3
      /* Remember the timestamp, to keep it holy.  But fudge it a little.  */
      bfd_ardata (arch)->armap_timestamp = (statbuf.st_mtime
                                            + ARMAP_TIME_OFFSET);
a2325 11
  else
    {
      /* If deterministic, we use 0 as the timestamp in the map.
         Some linkers may require that the archive filesystem modification
         time is less than (or near to) the archive map timestamp.  Those
         linkers should not be used with deterministic mode.  (GNU ld and
         Gold do not have this restriction.)  */
      bfd_ardata (arch)->armap_timestamp = 0;
      uid = 0;
      gid = 0;
    }
@


1.72
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@d1223 3
a1225 1
  bfd_seek (abfd, bfd_ardata (abfd)->first_file_filepos, SEEK_SET);
@


1.71
log
@	PR 12513
	* archive.c (bfd_slurp_bsd_armap_f2): Sanity check parsed_size and
	stringsize.  Properly sanity check symdef_count.  Remove redundant
	bfd_release.
@
text
@d351 1
a351 1
      if (strcmp (filename, abfd->filename) == 0)
d1362 1
a1362 1
	  || strncmp (pathp, refp, e1 - pathp) != 0)
d1467 1
a1467 1
          if (last_filename && strcmp (last_filename, filename) == 0)
d1513 1
a1513 1
	  if (strncmp (normal, hdr->ar_name, thislen) != 0
d1561 1
a1561 1
          if (last_filename && strcmp (last_filename, filename) == 0)
@


1.70
log
@Properly copy BFD_COMPRESS and BFD_DECOMPRESS to archive element.

2010-11-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* archive.c (_bfd_get_elt_at_filepos): Copy BFD_COMPRESS and
	BFD_DECOMPRESS.
	(bfd_openr_next_archived_file): Revert the last change.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1112 1
d1140 1
a1140 3
  amt = mapdata->parsed_size;
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
  if (raw_armap == NULL)
d1142 2
d1148 6
a1158 2
    byebyebye:
      bfd_release (abfd, raw_armap);
a1163 8
  if (ardata->symdef_count * BSD_SYMDEF_SIZE
      > mapdata->parsed_size - HPUX_SYMDEF_COUNT_SIZE)
    {
      /* Probably we're using the wrong byte ordering.  */
      bfd_set_error (bfd_error_wrong_format);
      goto byebyebye;
    }

d1167 4
d1177 3
@


1.69
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d658 3
a702 2
  bfd *abfd;

d710 1
a710 1
  abfd = BFD_SEND (archive,
a711 6

  /* Copy BFD_COMPRESS and BFD_DECOMPRESS flags.  */
  if (abfd)
    abfd->flags |= archive->flags & (BFD_COMPRESS | BFD_DECOMPRESS);

  return abfd;
@


1.69.2.1
log
@Properly copy BFD_COMPRESS and BFD_DECOMPRESS to archive element.

2010-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* archive.c (_bfd_get_elt_at_filepos): Copy BFD_COMPRESS and
	BFD_DECOMPRESS.
	(bfd_openr_next_archived_file): Revert the last change.
@
text
@a657 3
  /* Copy BFD_COMPRESS and BFD_DECOMPRESS flags.  */
  n_nfd->flags |= archive->flags & (BFD_COMPRESS | BFD_DECOMPRESS);

d700 2
d709 1
a709 1
  return BFD_SEND (archive,
d711 6
@


1.69.2.2
log
@	PR 12513
	* archive.c (bfd_slurp_bsd_armap_f2): Sanity check parsed_size and
	stringsize.  Properly sanity check symdef_count.  Remove redundant
	bfd_release.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a1111 1
  unsigned int left;
d1139 3
a1141 1
  if (mapdata->parsed_size < HPUX_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE)
a1142 2
    wrong_format:
      bfd_set_error (bfd_error_wrong_format);
a1146 6
  left = mapdata->parsed_size - HPUX_SYMDEF_COUNT_SIZE - BSD_STRING_COUNT_SIZE;

  amt = mapdata->parsed_size;
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
  if (raw_armap == NULL)
    goto byebye;
d1152 2
d1159 8
a1169 4
  if (stringsize > left)
    goto wrong_format;
  left -= stringsize;

a1175 3
  if (amt > left)
    goto wrong_format;

@


1.69.2.3
log
@	* archive.c (bsd_write_armap): Don't call stat in deterministic
	mode, and don't use st_mtime if stat returns error.
@
text
@d2302 1
d2307 1
a2307 8
  /* If deterministic, we use 0 as the timestamp in the map.
     Some linkers may require that the archive filesystem modification
     time is less than (or near to) the archive map timestamp.  Those
     linkers should not be used with deterministic mode.  (GNU ld and
     Gold do not have this restriction.)  */
  bfd_ardata (arch)->armap_timestamp = 0;
  uid = 0;
  gid = 0;
d2310 3
a2312 5
      struct stat statbuf;

      if (stat (arch->filename, &statbuf) == 0)
	bfd_ardata (arch)->armap_timestamp = (statbuf.st_mtime
					      + ARMAP_TIME_OFFSET);
d2316 11
@


1.69.2.4
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d664 4
@


1.68
log
@	* archive.c (_bfd_archive_bsd44_construct_extended_name_table):
	Correct format specifier.
@
text
@d700 2
d709 1
a709 1
  return BFD_SEND (archive,
d711 6
@


1.67
log
@        PR ld/11624
        * archive.c (_bfd_calloc_wrapper): New function.
        (_bfd_add_bfd_to_archive_cache): Use it.

        * configure.in: Add alpha*-*-*vms* to list of natives.
        * configure: Regenerate.

        * vms-misc.c: Define globalref if necessary.
        (vms_convert_to_var_unix_filename): Rename to
        _bfd_vms_convert_to_var_unix_filename and export.
        * vms.h: Add prototype for _bfd_vms_convert_to_var_unix_filename.
        * vms-alpha.c (vms_close_and_cleanup): Update invocation of
        vms_convert_to_var_unix_filename.
@
text
@d1652 1
a1652 1
          _bfd_ar_spacepad (hdr->ar_name, maxname, "#1/%u", len);
@


1.66
log
@2010-04-01  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Include time.h. Add prototypes for vms_get_module_name,
	vms_time_to_time_t and vms_rawtime_to_time_t.
	* vms.c (vms_alpha_vec): Add archives support.
	* vms-misc.c: Include safe-ctype.h
	(vms_get_module_name): New function.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	* vms-hdr.c (_bfd_vms_write_hdr): Put module name creation to the
	vms_get_module_name function.  Use this function.
	* targets.c: Declare vms_lib_txt_vec.  Add it to _bfd_target_vector.
	* libbfd-in.h: Add prototype for _bfd_append_relative_path.
	Add prototypes for vms-lib.c
	* libbfd.h: Regenerate.
	* configure.in (TDEFINES): Add an entry for vms_lib_txt_vec.  Add
	vms-lib.lo to vms_alpha_vec.
	* config.bfd (targ_cpu): Add targ_selvecs for alpha*-*-*vms*.
	* configure: Regenerate.
	* bfd.c: Add selective_search field.
	* bfd-in2.h: Regenerate.
	* archive.c (append_relative_path): Rename to
	_bfd_append_relative_path and make it public.
	(_bfd_get_elt_at_filepos): Adjust for above renaming.
	* Makefile.am (BFD32_BACKENDS): Add vms-lib.lo
	(BFD32_BACKENDS_CFILES): Add vms-lib.c
	* Makefile.in: Regenerate.
@
text
@d306 9
d327 1
a327 1
				      NULL, calloc, free);
@


1.65
log
@	* archive.c (_bfd_compute_and_write_armap): Allow symbols flagged
	as unique in the armap.
@
text
@d539 2
a540 2
static char *
append_relative_path (bfd *arch, char *elt_name)
d594 1
a594 1
          filename = append_relative_path (archive, filename);
@


1.64
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d2199 1
@


1.63
log
@2010-01-13  Tristan Gingold  <gingold@@adacore.com>

	* archive.c (normalize): Use lbasename.
	(bfd_bsd_truncate_arname): Ditto.
	(bfd_gnu_truncate_arname): Ditto.
@
text
@a106 1
   We currently can read BSD 4.4 archives, but not write them.
a126 1
		      Implemented for reading, not writing.
d160 5
d421 1
d457 2
a458 6
  /* BSD4.4-style long filename.
     Only implemented for reading, so far!  */
  else if (hdr.ar_name[0] == '#'
	   && hdr.ar_name[1] == '1'
	   && hdr.ar_name[2] == '/'
	   && ISDIGIT (hdr.ar_name[3]))
d464 1
d519 1
d1074 2
a1075 1
      if (CONST_STRNEQ (extname, "__.SYMDEF SORTED"))
d1605 97
a2059 1
      struct ar_hdr *hdr = arch_hdr (current);
d2062 2
a2063 3
      if (bfd_bwrite (hdr, sizeof (*hdr), arch)
	  != sizeof (*hdr))
	return FALSE;
d2336 4
a2339 1
	      firstreal += arelt_size (current) + sizeof (struct ar_hdr);
@


1.62
log
@2010-01-11  Tristan Gingold  <gingold@@adacore.com>

        * archive.c (bfd_slurp_armap): Also check for Mach-O sorted armap.
@
text
@d1315 1
a1315 17
  const char *filename = strrchr (file, '/');

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
  if (filename != NULL)
    filename++;
  else
    filename = file;
  return filename;
d1807 1
a1807 1
  const char *filename = strrchr (pathname, '/');
a1809 16
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

  if (filename == NULL)
    filename = pathname;
  else
    ++filename;

d1839 1
a1839 1
  const char *filename = strrchr (pathname, '/');
a1841 17
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');

    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

  if (filename == NULL)
    filename = pathname;
  else
    ++filename;

@


1.61
log
@2010-01-08  Tristan Gingold  <gingold@@adacore.com>

	* archive.c: Remove bfd_special_undocumented_glue.
@
text
@d1057 18
@


1.60
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a1705 16
/* This is magic required by the "ar" program.  Since it's
   undocumented, it's undocumented.  You may think that it would take
   a strong stomach to write this, and it does, but it takes even a
   stronger stomach to try to code around such a thing!  */

struct ar_hdr *bfd_special_undocumented_glue (bfd *, const char *);

struct ar_hdr *
bfd_special_undocumented_glue (bfd *abfd, const char *filename)
{
  struct areltdata *ar_elt = bfd_ar_hdr_from_filesystem (abfd, filename, 0);
  if (ar_elt == NULL)
    return NULL;
  return (struct ar_hdr *) ar_elt->arch_header;
}

@


1.59
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d357 1
a357 1
  unsigned long index = 0;
d364 2
a365 2
  index = strtol (name + 1, (char **) &endp, 10);
  if (errno != 0 || index >= bfd_ardata (arch)->extended_names_size)
d386 1
a386 1
  return bfd_ardata (arch)->extended_names + index;
d659 1
a659 1
   INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */
d662 1
a662 1
_bfd_generic_get_elt_at_index (bfd *abfd, symindex index)
d666 1
a666 1
  entry = bfd_ardata (abfd)->symdefs + index;
@


1.58
log
@update copyright dates
@
text
@d184 1
a184 1
  abfd->tdata.aout_ar_data = bfd_zalloc (abfd, amt);
d322 1
a322 1
  cache = bfd_zalloc (arch_bfd, sizeof (struct ar_cache));
d465 1
a465 1
      allocptr = bfd_zalloc (abfd, allocsize);
d486 1
a486 1
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d489 1
a489 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d491 1
a491 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d508 1
a508 1
      allocptr = bfd_zalloc (abfd, allocsize);
d549 1
a549 1
  filename = bfd_alloc (arch, prefix_len + strlen (elt_name) + 1);
d582 1
a582 1
  if ((new_areldata = _bfd_read_ar_hdr (archive)) == NULL)
d748 1
a748 1
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
d838 1
a838 1
  mapdata = _bfd_read_ar_hdr (abfd);
d844 1
a844 1
  raw_armap = bfd_zalloc (abfd, parsed_size);
d873 1
a873 1
  ardata->symdefs = bfd_alloc (abfd, amt);
d914 1
a914 1
  mapdata = _bfd_read_ar_hdr (abfd);
d959 2
a960 1
  ardata->symdefs = bfd_zalloc (abfd, carsym_size + stringsize + 1);
d967 1
a967 1
  raw_armap = bfd_alloc (abfd, ptrsize);
d1002 1
a1002 1
    tmp = _bfd_read_ar_hdr (abfd);
d1102 1
a1102 1
  mapdata = _bfd_read_ar_hdr (abfd);
d1107 1
a1107 1
  raw_armap = bfd_zalloc (abfd, amt);
d1143 1
a1143 1
  ardata->symdefs = bfd_alloc (abfd, amt);
d1200 1
a1200 1
      namedata = _bfd_read_ar_hdr (abfd);
d1209 1
a1209 1
      bfd_ardata (abfd)->extended_names = bfd_zalloc (abfd, amt + 1);
d1359 1
a1359 1
      pathbuf = bfd_malloc (len);
d1509 1
a1509 1
  *tabloc = bfd_zalloc (abfd, total_namelen);
d1643 1
a1643 1
      struct bfd_in_memory *bim = member->iostream;
d1667 1
a1667 1
  ared = bfd_zalloc (abfd, amt);
d2092 1
a2092 1
  map = bfd_malloc (amt);
d2098 1
a2098 1
  first_name = bfd_alloc (arch, 1);
d2130 1
a2130 1
		  syms = bfd_malloc (syms_max);
d2159 1
a2159 1
			  new_map = bfd_realloc (map, amt);
d2168 1
a2168 1
		      map[orl_count].name = bfd_alloc (arch, amt);
d2171 2
a2172 1
		      *(map[orl_count].name) = bfd_alloc (arch, namelen + 1);
@


1.58.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d184 1
a184 1
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
d322 1
a322 1
  cache = (struct ar_cache *) bfd_zalloc (arch_bfd, sizeof (struct ar_cache));
d465 1
a465 1
      allocptr = (char *) bfd_zalloc (abfd, allocsize);
d486 1
a486 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d489 1
a489 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d491 1
a491 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d508 1
a508 1
      allocptr = (char *) bfd_zalloc (abfd, allocsize);
d549 1
a549 1
  filename = (char *) bfd_alloc (arch, prefix_len + strlen (elt_name) + 1);
d582 1
a582 1
  if ((new_areldata = (struct areltdata *) _bfd_read_ar_hdr (archive)) == NULL)
d748 1
a748 1
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d838 1
a838 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d844 1
a844 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, parsed_size);
d873 1
a873 1
  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);
d914 1
a914 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d959 1
a959 2
  ardata->symdefs = (struct carsym *) bfd_zalloc (abfd,
                                                  carsym_size + stringsize + 1);
d966 1
a966 1
  raw_armap = (int *) bfd_alloc (abfd, ptrsize);
d1001 1
a1001 1
    tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d1101 1
a1101 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d1106 1
a1106 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
d1142 1
a1142 1
  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);
d1199 1
a1199 1
      namedata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d1208 1
a1208 1
      bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);
d1358 1
a1358 1
      pathbuf = (char *) bfd_malloc (len);
d1508 1
a1508 1
  *tabloc = (char *) bfd_zalloc (abfd, total_namelen);
d1642 1
a1642 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) member->iostream;
d1666 1
a1666 1
  ared = (struct areltdata *) bfd_zalloc (abfd, amt);
d2091 1
a2091 1
  map = (struct orl *) bfd_malloc (amt);
d2097 1
a2097 1
  first_name = (char *) bfd_alloc (arch, 1);
d2129 1
a2129 1
		  syms = (asymbol **) bfd_malloc (syms_max);
d2158 1
a2158 1
			  new_map = (struct orl *) bfd_realloc (map, amt);
d2167 1
a2167 1
		      map[orl_count].name = (char **) bfd_alloc (arch, amt);
d2170 1
a2170 2
		      *(map[orl_count].name) = (char *) bfd_alloc (arch,
                                                                   namelen + 1);
@


1.57
log
@bfd/
2009-07-28  Jan Beulich  <jbeulich@@novell.com>

	* archive.c (get_extended_arelt_filename): Remove redundant
	range check on index.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.56
log
@[bfd/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* bfd.c (BFD_DETERMINISTIC_OUTPUT): New flag.
	* bfd-in2.h: Regenerate.
	* archive.c (bfd_ar_hdr_from_filesystem): If BFD_DETERMINISTIC_OUTPUT
	flag is set, use 0 for uid, gid, and timestamp, and use 0644 for file
	mode.
	(bsd_write_armap): Likewise.
	(_bfd_archive_bsd_update_armap_timestamp): If BFD_DETERMINISTIC_OUTPUT
	flag is set, do nothing.
	(coff_write_armap): If BFD_DETERMINISTIC_OUTPUT flag is set, use 0
	for timestamp.

[binutils/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* ar.c (deterministic): New global variable.
	(main): Recognize new 'D' option, which enables 'deterministic mode'.
	(usage): Document new 'D' option.
	(write_archive): Set BFD_DETERMINISTIC_OUTPUT in output archive's
	flags if deterministic mode was requested.
	* doc/binutils.texi (ar): Document deterministic mode ('D' option).

[binutils/testsuite/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* binutils-all/ar.exp (deterministic_archive): New test.
@
text
@d376 1
a376 1
      if (errno != 0 || index >= bfd_ardata (arch)->extended_names_size)
@


1.55
log
@	* archive.c (_bfd_archive_bsd_update_armap_timestamp): Cast stat
	st_mtime to long before comparison.
@
text
@d1655 10
d2233 1
d2238 20
a2259 2
  /* Remember the timestamp, to keep it holy.  But fudge it a little.  */
  bfd_ardata (arch)->armap_timestamp = statbuf.st_mtime + ARMAP_TIME_OFFSET;
d2264 2
a2265 2
  _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld", getuid ());
  _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld", getgid ());
d2333 4
d2421 2
a2422 1
                    time (NULL));
@


1.54
log
@	* archive.c (_bfd_write_archive_contents): Fix incorrect use of
	ARFMAG.
@
text
@d2314 1
a2314 1
  if (archstat.st_mtime <= bfd_ardata (arch)->armap_timestamp)
@


1.53
log
@	PR 6006
	* archive.c (_bfd_slurp_extended_name_table): Change
	ARFMAG[0] to ARFMAG[1].
	(_bfd_construct_extended_name_table): Likewise.
@
text
@d1985 1
a1985 1
	  if (bfd_bwrite (ARFMAG, 1, arch) != 1)
d2027 1
a2027 1
	  if (bfd_bwrite (ARFMAG, 1, arch) != 1)
@


1.52
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@d1236 1
a1236 1
	    if (*temp == ARFMAG[0])
d1567 1
a1567 1
	        strptr[thislen] = ARFMAG[0];
d1571 1
a1571 1
	          strptr[thislen + 1] = ARFMAG[0];
@


1.51
log
@	* archive.c (do_slurp_bsd_armap, do_slurp_coff_armap,
	bfd_slurp_armap): Improve function comment.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d140 1
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata(bfd)->arch_header)
d330 21
d355 1
a355 1
get_extended_arelt_filename (bfd *arch, const char *name)
d358 1
d364 1
a364 1
  index = strtol (name + 1, NULL, 10);
d370 15
d417 1
d449 1
a449 1
      filename = get_extended_arelt_filename (abfd, hdr.ar_name);
d518 1
d534 24
d567 1
d585 42
a626 1
  n_nfd = _bfd_create_empty_archive_element_shell (archive);
d633 12
a644 1
  n_nfd->origin = bfd_tell (archive);
a645 1
  n_nfd->filename = new_areldata->filename;
d651 2
d689 2
a690 2
  if ((bfd_get_format (archive) != bfd_archive) ||
      (archive->direction == write_direction))
d710 3
a712 1
      filestart = last_file->origin + size;
d738 5
a742 2
  if (strncmp (armag, ARMAG, SARMAG) != 0 &&
      strncmp (armag, ARMAGB, SARMAG) != 0)
d1236 1
a1236 1
	    if (*temp == '\012')
d1316 60
d1418 2
d1422 1
d1432 36
d1515 3
d1524 2
d1527 26
a1552 3
      normal = normalize (current, current->filename);
      if (normal == NULL)
	return FALSE;
d1555 1
a1555 1
      if (thislen > maxname)
d1561 24
a1584 3
	  strcpy (strptr, normal);
	  if (! trailing_slash)
	    strptr[thislen] = '\012';
d1586 7
a1592 3
	    {
	      strptr[thislen] = '/';
	      strptr[thislen + 1] = '\012';
a1593 6
	  hdr->ar_name[0] = ar_padchar (current);
          _bfd_ar_spacepad (hdr->ar_name + 1, maxname - 1, "%-ld",
                            strptr - *tabloc);
	  strptr += thislen + 1;
	  if (trailing_slash)
	    ++strptr;
d1865 1
d1883 2
a1884 1
    {				/* pathname: meet procrustes */
d1912 1
d1956 4
a1959 1
  wrote = bfd_bwrite (ARMAG, SARMAG, arch);
d1985 1
a1985 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d2002 2
d2006 1
d2010 1
d2024 1
d2027 1
a2027 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d2092 2
a2093 2
  while (arch->archive_head &&
	 strcmp (arch->archive_head->filename, "__.SYMDEF") == 0)
d2134 4
a2137 4
		  if ((flags & BSF_GLOBAL ||
		       flags & BSF_WEAK ||
		       flags & BSF_INDIRECT ||
		       bfd_is_com_section (sec))
d2422 8
a2429 4
      /* Add size of this archive entry.  */
      archive_member_file_ptr += arelt_size (current) + sizeof (struct ar_hdr);
      /* Remember aboout the even alignment.  */
      archive_member_file_ptr += archive_member_file_ptr % 2;
@


1.50
log
@Switch sources over to use the GPL version 3
@
text
@d701 2
a702 1
/* Returns FALSE on error, TRUE otherwise.  */
d772 2
a773 1
/* Returns FALSE on error, TRUE otherwise.  */
d900 2
a901 2
/* This routine can handle either coff-style or bsd-style armaps.
   Returns FALSE on error, TRUE otherwise */
@


1.49
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.48
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1237 3
a1239 1
  for (current = abfd->archive_head; current != NULL; current = current->next)
d1291 3
a1293 2
  for (current = abfd->archive_head; current != NULL; current =
       current->next)
d1643 3
a1645 1
  for (current = arch->archive_head; current; current = current->next)
d1713 3
a1715 1
  for (current = arch->archive_head; current; current = current->next)
d1812 1
a1812 1
    arch->archive_head = arch->archive_head->next;
d1817 1
a1817 1
       current = current->next, elt_no++)
d1974 1
a1974 1
	      current = current->next;
d2144 1
a2144 1
      current = current->next;
@


1.47
log
@	* bfd.c (bfd_error_type): Add bfd_error_on_input.
	(input_bfd, input_error): New static vars.
	(bfd_set_error): Handle bfd_error_on_input.
	(bfd_errmsg): Likewise.
	(bfd_perror): Simplify.
	* archive.c (_bfd_write_archive_contents): Report errors on input.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d132 1
a133 1
#include "sysdep.h"
@


1.46
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d1650 1
a1650 1
	  return FALSE;
d1657 1
a1657 1
	    return FALSE;
d1719 1
a1719 1
	return FALSE;
d1729 2
a1730 2
		bfd_set_error (bfd_error_malformed_archive);
	      return FALSE;
d1763 4
@


1.45
log
@* archive.c (hpux_uid_gid_encode): Fix thinko decrementing "cnt" variable.
@
text
@d915 2
a916 2
  if (!strncmp (nextname, "__.SYMDEF       ", 16)
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* old Linux archives */
d918 1
a918 1
  else if (!strncmp (nextname, "/               ", 16))
d920 1
a920 1
  else if (!strncmp (nextname, "/SYM64/         ", 16))
d966 2
a967 2
  if (!strncmp (nextname, "__.SYMDEF       ", 16)
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* Old Linux archives.  */
d970 1
a970 1
  if (strncmp (nextname, "/               ", 16))
d1066 2
a1067 2
      if (strncmp (nextname, "ARFILENAMES/    ", 16) != 0 &&
	  strncmp (nextname, "//              ", 16) != 0)
@


1.44
log
@	* archive.c (bfd_generic_archive_p): Remove unused local variable
	`fail'.
	* dwarf2.c (decode_line_info): Remove unused local variable
	`basic_block'.
	* elfcode.h (elf_slurp_reloc_table_from_section): Remove unsed
	local varibale `s'.
	* tekhex.c (tekhex_write_object_contents): Remove unused local
	variable `bytes_written'.
	* aout-ns32k.c (MY_swap_std_reloc_out): Remove unused local
	variable `r_addend'.
	* elf32-dlx.c (dlx_rtype_to_howto): Remove breaks after returns.
	* elfxx-mips.c (_bfd_elf_mips_mach): Remove breaks after returns.
	(_bfd_ns32k_relocate_contents): Remove break after return.
	* elf.c (bfd_section_from_shdr): Remove breaks after returns.
@
text
@d1339 1
a1339 1
  for (cnt = 4; cnt >= 0; ++cnt, id >>= 6)
@


1.43
log
@        * archive.c: Add missing SUBSECTION for documentation.
        * bfd.c: Likewise.
        * cache.c: Likewise.
        * corefile.c: Likewise.
        * format.c: Likewise.
        * init.c: Likewise.
        * libbfd.c: Likewise.
        * opncls.c: Likewise.
        * elf.c: Remove blank line after SECTION heading.
        * reloc.c: Change "howto manager" SECTION to a SUBSECTION.
@
text
@a668 2
	  bfd_boolean fail;

a669 1
	  fail = FALSE;
@


1.42
log
@	* libbfd-in.h (struct artdata): Add extended_names_size field.
	* libbfd.h: Rebuilt.
	* coff-rs600.c (_bfd_xcoff_archive_p): Don't clear fields in freshly
	allocated object by bfd_zalloc.
	* coff64-rs6000.c (xcoff64_archive_p): Likewise.
	* ecoff.c (_bfd_ecoff_archive_p): Likewise.
	* archive.c (_bfd_generic_mkarchive, bfd_generic_archive_p): Likewise.
	(get_extended_arelt_filename): Fail if index is bigger or equal to
	extended_names_size.
	(_bfd_generic_read_ar_hdr_mag): Don't set bfd_error_malformed_archive,
	get_extended_arelt_filename already did that.
	(_bfd_slurp_extended_name_table): Initialize extended_names_size field.
	Allocate one extra byte and clear it, in case extended names table
	is not terminated.
@
text
@d77 2
@


1.41
log
@* archive.c: Include "libiberty.h".
@
text
@d185 7
a191 5
  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
  bfd_ardata (abfd)->tdata = NULL;
d340 1
a340 1
  if (errno != 0)
d410 1
a410 4
	{
	  bfd_set_error (bfd_error_malformed_archive);
	  return NULL;
	}
d631 7
a637 5
  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
  bfd_ardata (abfd)->tdata = NULL;
d1071 1
d1080 5
a1084 1
      bfd_ardata (abfd)->extended_names = bfd_zalloc (abfd, amt);
d1107 2
a1108 1
	char *temp = bfd_ardata (abfd)->extended_names;
d1113 1
a1113 1
	      temp[temp[-1] == '/' ? -1 : 0] = '\0';
d1117 1
@


1.40
log
@	* elf.c (bfd_section_from_shdr): Fail if name is NULL.
	Prevent endless recursion on broken objects.

	* archive.c (do_slurp_coff_armap): Check for overflows.
@
text
@d132 1
@


1.39
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d824 3
d830 3
@


1.38
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.37
log
@	* libbfd-in.h (_bfd_ar_spacepad): New prototype.
	* libbfd.h: Rebuilt.
	* archive.c (_bfd_ar_spacepad): New function.
	(_bfd_construct_extended_name_table, _bfd_write_archive_contents,
	bsd_write_armap, _bfd_archive_bsd_update_armap_timestamp,
	coff_write_armap): Use it.
	(bfd_ar_hdr_from_filesystem): Likewise.  Fix HP-UX large
	uid/gid support.
	* archive64.c (bfd_elf64_archive_write_armap): Use _bfd_ar_spacepad.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.36
log
@* archive.c (_bfd_look_for_bfd_in_cache): Move declaration of
has_table to the start of the function.
@
text
@d124 1
a124 1
 "#1/23           " - Long name (or embedded paces) 23 characters long,
d158 16
a173 1

d1301 2
a1302 11
	  /* We know there will always be enough room (one of the few
	     cases where you may safely use sprintf).  */
	  sprintf ((hdr->ar_name) + 1, "%-d", (unsigned) (strptr - *tabloc));
	  /* Kinda Kludgy.  We should just use the returned value of
	     sprintf but not all implementations get this right.  */
	  {
	    char *temp = hdr->ar_name + 2;
	    for (; temp < hdr->ar_name + maxname; temp++)
	      if (*temp == '\0')
		*temp = ' ';
	  }
a1348 1
  char *temp, *temp1;
d1376 2
a1377 4
  strncpy (hdr->ar_fmag, ARFMAG, 2);

  /* Goddamned sprintf doesn't permit MAXIMUM field lengths.  */
  sprintf ((hdr->ar_date), "%-12ld", (long) status.st_mtime);
d1382 1
a1382 1
    hpux_uid_gid_encode (hdr->ar_gid, (long) status.st_uid);
d1385 2
a1386 1
    sprintf ((hdr->ar_uid), "%ld", (long) status.st_uid);
d1391 1
a1391 1
    hpux_uid_gid_encode (hdr->ar_uid, (long) status.st_gid);
d1394 7
a1400 14
  sprintf ((hdr->ar_gid), "%ld", (long) status.st_gid);
  sprintf ((hdr->ar_mode), "%-8o", (unsigned int) status.st_mode);
  sprintf ((hdr->ar_size), "%-10ld", (long) status.st_size);
  /* Correct for a lossage in sprintf whereby it null-terminates.  I cannot
     understand how these C losers could design such a ramshackle bunch of
     IO operations.  */
  temp = (char *) hdr;
  temp1 = temp + sizeof (struct ar_hdr) - 2;
  for (; temp < temp1; temp++)
    {
      if (*temp == '\0')
	*temp = ' ';
    }
  strncpy (hdr->ar_fmag, ARFMAG, 2);
a1620 1
  unsigned int i;
d1677 2
a1678 2
      memset (&hdr, 0, sizeof (struct ar_hdr));
      strcpy (hdr.ar_name, ename);
d1680 3
a1682 6
      sprintf (&(hdr.ar_size[0]), "%-10d",
	       (int) ((elength + 1) & ~(bfd_size_type) 1));
      strncpy (hdr.ar_fmag, ARFMAG, 2);
      for (i = 0; i < sizeof (struct ar_hdr); i++)
	if (((char *) (&hdr))[i] == '\0')
	  (((char *) (&hdr))[i]) = ' ';
a1915 1
  unsigned int i;
d1920 2
a1921 2
  memset (&hdr, 0, sizeof (struct ar_hdr));
  sprintf (hdr.ar_name, RANLIBMAG);
d1926 6
a1931 8
  sprintf (hdr.ar_date, "%ld", bfd_ardata (arch)->armap_timestamp);
  sprintf (hdr.ar_uid, "%ld", (long) getuid ());
  sprintf (hdr.ar_gid, "%ld", (long) getgid ());
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  strncpy (hdr.ar_fmag, ARFMAG, 2);
  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';
a1995 1
  unsigned int i;
d2015 3
a2017 5
  memset (hdr.ar_date, 0, sizeof (hdr.ar_date));
  sprintf (hdr.ar_date, "%ld", bfd_ardata (arch)->armap_timestamp);
  for (i = 0; i < sizeof (hdr.ar_date); i++)
    if (hdr.ar_date[i] == '\0')
      (hdr.ar_date)[i] = ' ';
a2064 1
  unsigned int i;
d2076 1
a2076 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2078 4
a2081 2
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  sprintf (hdr.ar_date, "%ld", (long) time (NULL));
d2083 4
a2086 8
  sprintf ((hdr.ar_uid), "%d", 0);
  sprintf ((hdr.ar_gid), "%d", 0);
  sprintf ((hdr.ar_mode), "%-7o", (unsigned) 0);
  strncpy (hdr.ar_fmag, ARFMAG, 2);

  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';
@


1.35
log
@	* archive.c: Include hashtab.h.
	(struct ar_cache): Rename `arelt' to `arbfd' and remove `next'.
	(_bfd_look_for_bfd_in_cache): Reimplement using htab_find.
	(hash_file_ptr): New function.
	(eq_file_ptr): Likewise.
	(_bfd_add_bfd_to_archive_cache): Reimplement using a hash table.
	* libbfd-in.h: Include hashtab.h.
	(struct artdata): Change `cache' member type to htab_t.
	* libbfd.h: Rebuild.
@
text
@d250 1
a253 1
  htab_t hash_table = bfd_ardata (arch_bfd)->cache;
@


1.34
log
@update copyright dates
@
text
@d136 1
d150 1
a150 2
  bfd *arelt;
  struct ar_cache *next;
d250 2
a251 1
  struct ar_cache *current;
d253 18
a270 4
  for (current = bfd_ardata (arch_bfd)->cache; current != NULL;
       current = current->next)
    if (current->ptr == filepos)
      return current->arelt;
d272 8
a279 1
  return NULL;
d287 2
a288 5
  bfd_size_type amt = sizeof (struct ar_cache);

  struct ar_cache *new_cache = bfd_zalloc (arch_bfd, amt);
  if (new_cache == NULL)
    return FALSE;
d290 2
a291 6
  new_cache->ptr = filepos;
  new_cache->arelt = new_elt;
  new_cache->next = NULL;
  if (bfd_ardata (arch_bfd)->cache == NULL)
    bfd_ardata (arch_bfd)->cache = new_cache;
  else
d293 6
a298 1
      struct ar_cache *current = bfd_ardata (arch_bfd)->cache;
d300 5
a304 4
      while (current->next != NULL)
	current = current->next;
      current->next = new_cache;
    }
@


1.33
log
@	* coffcode.h (coff_sym_filepos): Remove GNU960 conditional code.
	* format.c (bfd_check_format_matches): Likewise.
	* archive.c (BFD_GNU960_ARMAG): Likewise.
	(bfd_generic_archive_p): Likewise.
	(_bfd_write_archive_contents): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
@


1.32
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@a140 4
#ifdef GNU960
#define BFD_GNU960_ARMAG(abfd)	(BFD_COFF_FILE_P((abfd)) ? ARMAG : ARMAGB)
#endif

a579 4
#ifdef GNU960
  if (strncmp (armag, BFD_GNU960_ARMAG (abfd), SARMAG) != 0)
    return 0;
#else
a582 1
#endif
a1645 3
#ifdef GNU960
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), SARMAG, arch);
#else
a1646 1
#endif
@


1.31
log
@Add code to cope with nested archives.
@
text
@a644 8
#if 0
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's close to impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
	      bfd_close (first);
	      bfd_release (abfd, bfd_ardata (abfd));
#endif
a778 1
#if 1
a792 1
#endif
a1084 3
#if 0
      bfd_release (abfd, namedata);
#endif
d1644 1
a1644 5
	  if ((bfd_check_format (current, bfd_object))
#if 0				/* FIXME -- these are not set correctly */
	      && ((bfd_get_file_flags (current) & HAS_SYMS))
#endif
	    )
@


1.30
log
@PR/136 - Have bfd_cache_lookup_worker() abort rather than return an
(unchecked-for) NULL.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d470 6
d558 3
a563 1
      filestart = last_file->origin + size;
@


1.29
log
@	* bfd-in.h (bfd_getb64, bfd_getl64): Replace bfd_byte* with void*.
	(bfd_getb32, bfd_getl32, bfd_getb16, bfd_getl16): Likewise.
	(bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_getb_signed_32, bfd_getl_signed_32): Likewise.
	(bfd_getb_signed_16, bfd_getl_signed_16): Likewise.
	(bfd_putb64, bfd_putl64, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb16, bfd_putl16, bfd_get_bits, bfd_put_bits): Likewise.
	* libbfd.c: Likewise in function definitions.
	(bfd_put_8): Mask with 0xff rather than casting to char.
	(bfd_putb16, bfd_putl16, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Likewise.
	(H_PUT_64, H_PUT_32, H_PUT_16, H_PUT_8): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16, H_PUT_S8): Likewise.
	(H_GET_64, H_GET_32, H_GET_16, H_GET_8): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16, H_GET_S8): Likewise.
	* libaout.h (H_PUT_64 H_PUT_32, H_PUT_16): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16): Likewise.
	(H_GET_64, H_GET_32, H_GET_16): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16): Likewise.
	* archive.c (do_slurp_coff_armap): Update swap prototype.
	* coff-tic54x.c (tic54x_getl32): Replace bfd_byte* with void*.
	(tic54x_getl_signed_32): Likewise.
	(tic54x_putl32): Likewise.  Mask with 0xff rather than casting to char.
	* mach-o.c (bfd_mach_o_read_header): Update get32 prototype.
	* pdp11.c (bfd_getp32): Make static, replace bfd_byte* with void*.
	(bfd_getp_signed_32, bfd_putp32): Likewise.
	* targets.c (struct bfd_target): Use void* in place of bfd_byte* for
	bfd_getx64, bfd_getx_signed_64, bfd_putx64, bfd_getx32,
	bfd_getx_signed_32, bfd_putx32, bfd_getx16, bfd_getx_signed_16,
	bfd_putx16, bfd_h_getx64, bfd_h_getx_signed_64, bfd_h_putx64,
	bfd_h_getx32, bfd_h_getx_signed_32, bfd_h_putx32, bfd_h_getx16,
	bfd_h_getx_signed_16, bfd_h_putx16.
	* aix386-core.c (NO_GET, NO_GETS, NO_PUT): Update prototypes.
	* hppabsd-core.c: Similarly.  Rename NO_SIGNED_GET to NO_GETS.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d224 1
a224 1
/* To be called by backends only */
d264 2
a265 1
/* Kind of stupid to call cons for each one, but we don't do too many */
d320 1
a320 2
   could have been moved arbitrarily.
*/
d673 1
a673 1
/* Returns FALSE on error, TRUE otherwise */
d904 2
a905 2
/* Returns FALSE on error, TRUE otherwise */
/* flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
d935 1
a935 1
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* old Linux archives */
d1299 1
a1299 1
/** A couple of functions for creating ar_hdrs */
d1768 1
a1768 1
  unsigned int orl_max = 1024;		/* fine initial default */
d1770 1
a1770 1
  int stridx = 0;		/* string index */
d1919 1
a1919 1
  bfd *last_elt = current;	/* last element arch seen */
d1963 1
a1963 1
	}			/* if new archive element */
d2061 1
a2061 2
   symbol name n-1
*/
a2105 1

@


1.28
log
@Convert to C90 and a few tweaks.
@
text
@d756 1
a756 1
  bfd_vma (*swap) (const bfd_byte *);
@


1.28.14.1
log
@Merge mainline to intercu branch.
@
text
@d756 1
a756 1
  bfd_vma (*swap) (const void *);
@


1.28.14.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d224 1
a224 1
/* To be called by backends only.  */
d264 1
a264 2
/* Kind of stupid to call cons for each one, but we don't do too many.  */

d319 2
a320 1
   could have been moved arbitrarily.  */
a469 6
  if (archive->my_archive)
    {
      filepos += archive->origin;
      archive = archive->my_archive;
    }

a551 3
      filestart = last_file->origin + size;
      if (archive->my_archive)
	filestart -= archive->origin;
d555 1
d673 1
a673 1
/* Returns FALSE on error, TRUE otherwise.  */
d904 2
a905 2
/* Returns FALSE on error, TRUE otherwise.  */
/* Flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
d935 1
a935 1
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* Old Linux archives.  */
d1299 1
a1299 1
/* A couple of functions for creating ar_hdrs.  */
d1768 1
a1768 1
  unsigned int orl_max = 1024;		/* Fine initial default.  */
d1770 1
a1770 1
  int stridx = 0;
d1919 1
a1919 1
  bfd *last_elt = current;	/* Last element arch seen.  */
d1963 1
a1963 1
	}
d2061 2
a2062 1
   symbol name n-1  */
d2107 1
@


1.28.18.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d756 1
a756 1
  bfd_vma (*swap) (const void *);
@


1.28.12.1
log
@	* bfd-in.h (bfd_getb64, bfd_getl64): Replace bfd_byte* with void*.
	(bfd_getb32, bfd_getl32, bfd_getb16, bfd_getl16): Likewise.
	(bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_getb_signed_32, bfd_getl_signed_32): Likewise.
	(bfd_getb_signed_16, bfd_getl_signed_16): Likewise.
	(bfd_putb64, bfd_putl64, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb16, bfd_putl16, bfd_get_bits, bfd_put_bits): Likewise.
	* libbfd.c: Likewise in function definitions.
	(bfd_put_8): Mask with 0xff rather than casting to char.
	(bfd_putb16, bfd_putl16, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Likewise.
	(H_PUT_64, H_PUT_32, H_PUT_16, H_PUT_8): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16, H_PUT_S8): Likewise.
	(H_GET_64, H_GET_32, H_GET_16, H_GET_8): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16, H_GET_S8): Likewise.
	* libaout.h (H_PUT_64 H_PUT_32, H_PUT_16): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16): Likewise.
	(H_GET_64, H_GET_32, H_GET_16): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16): Likewise.
	* archive.c (do_slurp_coff_armap): Update swap prototype.
	* coff-tic54x.c (tic54x_getl32): Replace bfd_byte* with void*.
	(tic54x_getl_signed_32): Likewise.
	(tic54x_putl32): Likewise.  Mask with 0xff rather than casting to char.
	* mach-o.c (bfd_mach_o_read_header): Update get32 prototype.
	* pdp11.c (bfd_getp32): Make static, replace bfd_byte* with void*.
	(bfd_getp_signed_32, bfd_putp32): Likewise.
	* targets.c (struct bfd_target): Use void* in place of bfd_byte* for
	bfd_getx64, bfd_getx_signed_64, bfd_putx64, bfd_getx32,
	bfd_getx_signed_32, bfd_putx32, bfd_getx16, bfd_getx_signed_16,
	bfd_putx16, bfd_h_getx64, bfd_h_getx_signed_64, bfd_h_putx64,
	bfd_h_getx32, bfd_h_getx_signed_32, bfd_h_putx32, bfd_h_getx16,
	bfd_h_getx_signed_16, bfd_h_putx16.
	* aix386-core.c (NO_GET, NO_GETS, NO_PUT): Update prototypes.
	* hppabsd-core.c: Similarly.  Rename NO_SIGNED_GET to NO_GETS.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d756 1
a756 1
  bfd_vma (*swap) (const void *);
@


1.27
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *)arch_eltdata(bfd)->arch_header)
a162 12
static char *get_extended_arelt_filename
  PARAMS ((bfd *arch, const char *name));
static bfd_boolean do_slurp_bsd_armap
  PARAMS ((bfd *abfd));
static bfd_boolean do_slurp_coff_armap
  PARAMS ((bfd *abfd));
bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *abfd));
static const char *normalize
  PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem
  PARAMS ((bfd *abfd, const char *, bfd *member));
d165 1
a165 2
_bfd_generic_mkarchive (abfd)
     bfd *abfd;
d169 1
a169 1
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
d187 2
a188 1
	symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);
d205 1
a205 4
bfd_get_next_mapent (abfd, prev, entry)
     bfd *abfd;
     symindex prev;
     carsym **entry;
d227 1
a227 2
_bfd_create_empty_archive_element_shell (obfd)
     bfd *obfd;
d237 1
a237 1
	bfd_boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d245 1
a245 3
bfd_set_archive_head (output_archive, new_head)
     bfd *output_archive;
     bfd *new_head;
a246 1

d252 1
a252 3
_bfd_look_for_bfd_in_cache (arch_bfd, filepos)
     bfd *arch_bfd;
     file_ptr filepos;
d266 1
a266 3
_bfd_add_bfd_to_archive_cache (arch_bfd, filepos, new_elt)
     bfd *arch_bfd, *new_elt;
     file_ptr filepos;
d270 1
a270 1
  struct ar_cache *new_cache = (struct ar_cache *) bfd_zalloc (arch_bfd, amt);
d276 1
a276 1
  new_cache->next = (struct ar_cache *) NULL;
d295 1
a295 3
get_extended_arelt_filename (arch, name)
     bfd *arch;
     const char *name;
d322 2
a323 3
PTR
_bfd_generic_read_ar_hdr (abfd)
     bfd *abfd;
d325 1
a325 1
  return _bfd_generic_read_ar_hdr_mag (abfd, (const char *) NULL);
d331 2
a332 4
PTR
_bfd_generic_read_ar_hdr_mag (abfd, mag)
     bfd *abfd;
     const char *mag;
d343 1
a343 2
  if (bfd_bread ((PTR) hdrp, (bfd_size_type) sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
d413 1
a413 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d416 1
a416 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d418 1
a418 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d443 1
a443 1
  memcpy ((char *) ared->arch_header, (char *) &hdr, sizeof (struct ar_hdr));
d453 1
a453 1
	memcpy (ared->filename, hdr.ar_name, (size_t) namelen);
d457 1
a457 1
  return (PTR) ared;
d465 1
a465 3
_bfd_get_elt_at_filepos (archive, filepos)
     bfd *archive;
     file_ptr filepos;
d477 1
a477 1
  if ((new_areldata = (struct areltdata *) _bfd_read_ar_hdr (archive)) == NULL)
d483 1
a483 1
      bfd_release (archive, (PTR) new_areldata);
d488 1
a488 1
  n_nfd->arelt_data = (PTR) new_areldata;
d495 2
a496 2
  bfd_release (archive, (PTR) n_nfd);
  bfd_release (archive, (PTR) new_areldata);
d504 1
a504 3
_bfd_generic_get_elt_at_index (abfd, index)
     bfd *abfd;
     symindex index;
d517 1
a517 1
	bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);
d529 1
a529 3
bfd_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d539 1
a539 3
		   openr_next_archived_file,
		   (archive,
		    last_file));
d543 1
a543 3
bfd_generic_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d563 1
a563 2
bfd_generic_archive_p (abfd)
     bfd *abfd;
d569 1
a569 1
  if (bfd_bread ((PTR) armag, (bfd_size_type) SARMAG, abfd) != SARMAG)
d588 1
a588 1
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d627 1
a627 1
      first = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
d642 1
a642 1
	      (void) bfd_close (first);
d676 1
a676 2
do_slurp_bsd_armap (abfd)
     bfd *abfd;
d686 1
a686 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d690 1
a690 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d692 2
a693 2
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, parsed_size);
  if (raw_armap == (bfd_byte *) NULL)
d696 1
a696 1
  if (bfd_bread ((PTR) raw_armap, parsed_size, abfd) != parsed_size)
d701 1
a701 1
      bfd_release (abfd, (PTR) raw_armap);
d720 2
a721 2
  amt = (bfd_size_type) ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d746 1
a746 2
do_slurp_coff_armap (abfd)
     bfd *abfd;
d756 1
a756 1
  bfd_vma (*swap) PARAMS ((const bfd_byte *));
d761 1
a761 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d765 1
a765 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d767 1
a767 1
  if (bfd_bread ((PTR) int_buf, (bfd_size_type) 4, abfd) != 4)
d776 1
a776 1
  nsymz = bfd_getb32 ((PTR) int_buf);
d790 1
a790 1
      nsymz = bfd_getl32 ((PTR) int_buf);
d802 1
a802 1
  ardata->symdefs = (carsym *) bfd_zalloc (abfd, carsym_size + stringsize + 1);
d809 1
a809 1
  raw_armap = (int *) bfd_alloc (abfd, ptrsize);
d812 2
a813 2
  if (bfd_bread ((PTR) raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread ((PTR) stringbase, stringsize, abfd) != stringsize))
d824 1
a824 1
      carsyms->file_offset = swap ((PTR) rawptr);
d837 1
a837 1
  bfd_release (abfd, (PTR) raw_armap);
d844 1
a844 1
    tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d860 1
a860 1
  bfd_release (abfd, (PTR) raw_armap);
d862 1
a862 1
  bfd_release (abfd, (PTR) (ardata)->symdefs);
d870 1
a870 2
bfd_slurp_armap (abfd)
     bfd *abfd;
d873 1
a873 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d892 1
d912 1
a912 2
bfd_slurp_bsd_armap_f2 (abfd)
     bfd *abfd;
d923 1
a923 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d944 1
a944 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d949 1
a949 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
d953 1
a953 1
      bfd_release (abfd, (PTR) mapdata);
d957 1
a957 1
  if (bfd_bread ((PTR) raw_armap, amt, abfd) != amt)
d962 1
a962 1
      bfd_release (abfd, (PTR) raw_armap);
d966 1
a966 1
  ardata->symdef_count = H_GET_16 (abfd, (PTR) raw_armap);
d984 2
a985 2
  amt = (bfd_size_type) ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d1020 1
a1020 2
_bfd_slurp_extended_name_table (abfd)
     bfd *abfd;
d1029 1
a1029 1
  if (bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd) == 16)
d1041 1
a1041 1
      namedata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d1050 1
a1050 1
	  bfd_release (abfd, (PTR) namedata);
d1054 1
a1054 1
      if (bfd_bread ((PTR) bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1058 1
a1058 1
	  bfd_release (abfd, (PTR) (bfd_ardata (abfd)->extended_names));
d1100 1
a1100 3
normalize (abfd, file)
     bfd *abfd;
     const char *file;
d1121 1
a1121 1
  copy = (char *) bfd_alloc (abfd, (bfd_size_type) (last - first + 1));
d1133 1
a1133 3
normalize (abfd, file)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *file;
d1147 1
a1147 1
  if (filename != (char *) NULL)
d1158 4
a1161 5
_bfd_archive_bsd_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
d1170 4
a1173 5
_bfd_archive_coff_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
d1188 4
a1191 5
_bfd_construct_extended_name_table (abfd, trailing_slash, tabloc, tablen)
     bfd *abfd;
     bfd_boolean trailing_slash;
     char **tabloc;
     bfd_size_type *tablen;
d1305 1
a1305 3
hpux_uid_gid_encode (str, id)
     char str[6];
     long int id;
d1331 1
a1331 4
bfd_ar_hdr_from_filesystem (abfd, filename, member)
     bfd *abfd;
     const char *filename;
     bfd *member;
d1342 1
a1342 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) member->iostream;
d1356 1
a1356 1
  ared = (struct areltdata *) bfd_zalloc (abfd, amt);
d1362 1
a1362 1
  memset ((PTR) hdr, ' ', sizeof (struct ar_hdr));
d1408 1
a1408 2
struct ar_hdr *bfd_special_undocumented_glue
  PARAMS ((bfd *, const char *));
d1411 1
a1411 3
bfd_special_undocumented_glue (abfd, filename)
     bfd *abfd;
     const char *filename;
d1422 1
a1422 3
bfd_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
d1477 1
a1477 4
bfd_dont_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1514 1
a1514 4
bfd_bsd_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1562 1
a1562 4
bfd_gnu_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1607 1
a1607 2
_bfd_write_archive_contents (arch)
     bfd *arch;
d1638 1
a1638 1
	    (PTR) bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1643 2
a1644 3
	  BFD_SEND (arch, _bfd_truncate_arname, (arch,
						 current->filename,
					      (char *) arch_hdr (current)));
d1665 1
a1665 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), (bfd_size_type) SARMAG, arch);
d1667 1
a1667 1
  wrote = bfd_bwrite (ARMAG, (bfd_size_type) SARMAG, arch);
d1682 1
a1682 1
      memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d1691 1
a1691 1
      if ((bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d1697 1
a1697 1
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
d1709 1
a1709 1
      if (bfd_bwrite ((PTR) hdr, (bfd_size_type) sizeof (*hdr), arch)
d1720 1
a1720 1
	  if (bfd_bread (buffer, (bfd_size_type) amt, current) != amt)
d1726 1
a1726 1
	  if (bfd_bwrite (buffer, (bfd_size_type) amt, arch) != amt)
d1732 1
a1732 1
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
d1762 1
a1762 3
_bfd_compute_and_write_armap (arch, elength)
     bfd *arch;
     unsigned int elength;
d1781 2
a1782 2
  amt = (bfd_size_type) orl_max * sizeof (struct orl);
  map = (struct orl *) bfd_malloc (amt);
d1788 1
a1788 1
  first_name = bfd_alloc (arch, (bfd_size_type) 1);
d1799 1
a1799 1
       current != (bfd *) NULL;
d1820 1
a1820 1
		  syms = (asymbol **) bfd_malloc ((bfd_size_type) syms_max);
d1848 3
a1850 3
			  amt = (bfd_size_type) orl_max * sizeof (struct orl);
			  new_map = (struct orl *) bfd_realloc (map, amt);
			  if (new_map == (struct orl *) NULL)
d1858 1
a1858 1
		      map[orl_count].name = (char **) bfd_alloc (arch, amt);
d1906 5
a1910 6
bsd_write_armap (arch, elength, map, orl_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d1929 1
a1929 1
  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d1943 1
a1943 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d1947 1
a1947 1
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
d1968 1
a1968 1
      if (bfd_bwrite (buf, (bfd_size_type) BSD_SYMDEF_SIZE, arch)
d1975 1
a1975 1
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
d1981 1
a1981 1
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
d1989 1
a1989 1
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
d2003 1
a2003 2
_bfd_archive_bsd_update_armap_timestamp (arch)
     bfd *arch;
d2037 1
a2037 1
      || (bfd_bwrite (hdr.ar_date, (bfd_size_type) sizeof (hdr.ar_date), arch)
d2065 5
a2069 6
coff_write_armap (arch, elength, map, symbol_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int symbol_count;
     int stridx;
d2092 1
a2092 1
  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d2108 1
a2108 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d2123 1
a2123 1
  while (current != (bfd *) NULL && count < symbol_count)
d2135 1
a2135 2
      archive_member_file_ptr += (arelt_size (current)
				  + sizeof (struct ar_hdr));
d2146 1
a2146 1
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
d2154 1
a2154 1
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
@


1.26
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d163 12
a174 9
static char *get_extended_arelt_filename PARAMS ((bfd *arch,
						  const char *name));
static boolean do_slurp_bsd_armap PARAMS ((bfd *abfd));
static boolean do_slurp_coff_armap PARAMS ((bfd *abfd));
boolean bfd_elf64_archive_slurp_armap PARAMS ((bfd *abfd));
static const char *normalize PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem PARAMS ((bfd *abfd,
							     const char *,
							     bfd *member));
d176 1
a176 1
boolean
d184 1
a184 1
    return false;
d192 1
a192 1
  return true;
d253 1
a253 1
	boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d260 1
a260 1
boolean
d267 1
a267 1
  return true;
d286 1
a286 1
boolean
d295 1
a295 1
    return false;
d311 1
a311 1
  return true;
d670 1
a670 1
	  boolean fail;
d672 2
a673 2
	  first->target_defaulted = false;
	  fail = false;
d713 1
a713 1
/* Returns false on error, true otherwise */
d715 1
a715 1
static boolean
d729 1
a729 1
    return false;
d735 1
a735 1
    return false;
d743 1
a743 1
      return false;
d764 1
a764 1
    return false;
d780 2
a781 2
  bfd_has_map (abfd) = true;
  return true;
d784 1
a784 1
/* Returns false on error, true otherwise.  */
d786 1
a786 1
static boolean
d805 1
a805 1
    return false;
d813 1
a813 1
      return false;
d846 1
a846 1
    return false;
d878 1
a878 1
  bfd_has_map (abfd) = true;
d899 1
a899 1
  return true;
d905 1
a905 1
  return false;
d909 1
a909 1
   Returns false on error, true otherwise */
d911 1
a911 1
boolean
d919 1
a919 1
    return true;
d921 1
a921 1
    return false;
d924 1
a924 1
    return false;
d938 1
a938 1
      return false;
d942 2
a943 2
  bfd_has_map (abfd) = false;
  return true;
d946 1
a946 1
/* Returns false on error, true otherwise */
d953 1
a953 1
boolean
d969 1
a969 1
    return true;
d971 1
a971 1
    return false;
d975 1
a975 1
    return false;
d983 2
a984 2
      bfd_has_map (abfd) = false;
      return true;
d989 1
a989 1
    return false;
d997 1
a997 1
      return false;
d1030 1
a1030 1
    return false;
d1046 2
a1047 2
  bfd_has_map (abfd) = true;
  return true;
d1060 1
a1060 1
/* Returns false on error, true otherwise.  */
d1062 1
a1062 1
boolean
d1071 1
a1071 1
     we probably don't want to return true.  */
d1076 1
a1076 1
	return false;
d1082 1
a1082 1
	  return true;
d1087 1
a1087 1
	return false;
d1095 1
a1095 1
	  return false;
d1135 1
a1135 1
  return true;
d1205 1
a1205 1
boolean
d1213 1
a1213 1
  return _bfd_construct_extended_name_table (abfd, false, tabloc, tablen);
d1218 1
a1218 1
boolean
d1226 1
a1226 1
  return _bfd_construct_extended_name_table (abfd, true, tabloc, tablen);
d1233 1
a1233 1
   further massage.  Returns true if it ran successfully, false if
d1237 1
a1237 1
boolean
d1240 1
a1240 1
     boolean trailing_slash;
d1259 1
a1259 1
	return false;
d1295 1
a1295 1
    return true;
d1299 1
a1299 1
    return false;
d1312 1
a1312 1
	return false;
d1347 1
a1347 1
  return true;
d1464 2
a1465 1
struct ar_hdr *bfd_special_undocumented_glue PARAMS ((bfd *, const char *));
d1676 1
a1676 1
boolean
d1684 3
a1686 2
  boolean makemap = bfd_has_map (arch);
  boolean hasobjects = false;	/* If no .o's, don't bother to make a map.  */
d1704 1
a1704 1
	  return false;
d1711 1
a1711 1
	    return false;
d1726 1
a1726 1
	    hasobjects = true;
d1732 1
a1732 1
    return false;
d1735 1
a1735 1
    return false;
d1742 1
a1742 1
    return false;
d1747 1
a1747 1
	return false;
d1766 1
a1766 1
	return false;
d1770 1
a1770 1
	    return false;
d1783 1
a1783 1
	return false;
d1785 1
a1785 1
	return false;
d1796 1
a1796 1
	      return false;
d1799 1
a1799 1
	    return false;
d1805 1
a1805 1
	    return false;
d1828 1
a1828 1
  return true;
d1833 1
a1833 1
boolean
d1847 1
a1847 1
  boolean ret;
d1976 1
a1976 1
  return false;
d1979 1
a1979 1
boolean
d2020 1
a2020 1
    return false;
d2023 1
a2023 1
    return false;
d2045 1
a2045 1
	return false;
d2051 1
a2051 1
    return false;
d2057 1
a2057 1
	return false;
d2065 1
a2065 1
	return false;
d2068 1
a2068 1
  return true;
d2074 2
a2075 2
   Return true if the timestamp was OK, or an unusual problem happened.
   Return false if we updated the timestamp.  */
d2077 1
a2077 1
boolean
d2093 1
a2093 1
      return true;
d2097 1
a2097 1
    return true;
d2119 1
a2119 1
      return true;
d2123 1
a2123 1
  return false;
d2140 1
a2140 1
boolean
d2187 1
a2187 1
    return false;
d2190 1
a2190 1
    return false;
d2208 1
a2208 1
	    return false;
d2225 1
a2225 1
	return false;
d2233 1
a2233 1
	return false;
d2236 1
a2236 1
  return true;
@


1.25
log
@	* archive.c (_bfd_archive_bsd_update_armap_timestamp): Replace
	perror with bfd_perror.
@
text
@d439 1
a439 1
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d442 1
a442 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d444 1
a444 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
@


1.24
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d2085 1
a2085 1
      perror (_("Reading archive file mod timestamp"));
d2111 1
a2111 2
      /* FIXME: bfd can't call perror.  */
      perror (_("Writing updated armap timestamp"));
@


1.24.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d2085 1
a2085 1
      bfd_perror (_("Reading archive file mod timestamp"));
d2111 2
a2112 1
      bfd_perror (_("Writing updated armap timestamp"));
@


1.24.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata(bfd)->arch_header)
d163 9
d173 3
a175 2
bfd_boolean
_bfd_generic_mkarchive (bfd *abfd)
d179 1
a179 1
  abfd->tdata.aout_ar_data = bfd_zalloc (abfd, amt);
d181 1
a181 1
    return FALSE;
d189 1
a189 1
  return TRUE;
d197 1
a197 2
	symindex bfd_get_next_mapent
	  (bfd *abfd, symindex previous, carsym **sym);
d214 4
a217 1
bfd_get_next_mapent (bfd *abfd, symindex prev, carsym **entry)
d239 2
a240 1
_bfd_create_empty_archive_element_shell (bfd *obfd)
d250 1
a250 1
	bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
d257 4
a260 2
bfd_boolean
bfd_set_archive_head (bfd *output_archive, bfd *new_head)
d262 1
d264 1
a264 1
  return TRUE;
d268 3
a270 1
_bfd_look_for_bfd_in_cache (bfd *arch_bfd, file_ptr filepos)
d283 4
a286 2
bfd_boolean
_bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)
d290 1
a290 1
  struct ar_cache *new_cache = bfd_zalloc (arch_bfd, amt);
d292 1
a292 1
    return FALSE;
d296 1
a296 1
  new_cache->next = NULL;
d308 1
a308 1
  return TRUE;
d315 3
a317 1
get_extended_arelt_filename (bfd *arch, const char *name)
d344 3
a346 2
void *
_bfd_generic_read_ar_hdr (bfd *abfd)
d348 1
a348 1
  return _bfd_generic_read_ar_hdr_mag (abfd, NULL);
d354 4
a357 2
void *
_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
d368 2
a369 1
  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))
d469 1
a469 1
  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));
d479 1
a479 1
	memcpy (ared->filename, hdr.ar_name, namelen);
d483 1
a483 1
  return ared;
d491 3
a493 1
_bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
d505 1
a505 1
  if ((new_areldata = _bfd_read_ar_hdr (archive)) == NULL)
d511 1
a511 1
      bfd_release (archive, new_areldata);
d516 1
a516 1
  n_nfd->arelt_data = new_areldata;
d523 2
a524 2
  bfd_release (archive, n_nfd);
  bfd_release (archive, new_areldata);
d532 3
a534 1
_bfd_generic_get_elt_at_index (bfd *abfd, symindex index)
d547 1
a547 1
	bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
d559 3
a561 1
bfd_openr_next_archived_file (bfd *archive, bfd *last_file)
d571 3
a573 1
		   openr_next_archived_file, (archive, last_file));
d577 3
a579 1
bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
d599 2
a600 1
bfd_generic_archive_p (bfd *abfd)
d606 1
a606 1
  if (bfd_bread (armag, SARMAG, abfd) != SARMAG)
d625 1
a625 1
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
d664 1
a664 1
      first = bfd_openr_next_archived_file (abfd, NULL);
d667 1
a667 1
	  bfd_boolean fail;
d669 2
a670 2
	  first->target_defaulted = FALSE;
	  fail = FALSE;
d679 1
a679 1
	      bfd_close (first);
d710 1
a710 1
/* Returns FALSE on error, TRUE otherwise */
d712 3
a714 2
static bfd_boolean
do_slurp_bsd_armap (bfd *abfd)
d724 1
a724 1
  mapdata = _bfd_read_ar_hdr (abfd);
d726 1
a726 1
    return FALSE;
d728 1
a728 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d730 3
a732 3
  raw_armap = bfd_zalloc (abfd, parsed_size);
  if (raw_armap == NULL)
    return FALSE;
d734 1
a734 1
  if (bfd_bread (raw_armap, parsed_size, abfd) != parsed_size)
d739 2
a740 2
      bfd_release (abfd, raw_armap);
      return FALSE;
d758 2
a759 2
  amt = ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = bfd_alloc (abfd, amt);
d761 1
a761 1
    return FALSE;
d777 2
a778 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d781 1
a781 1
/* Returns FALSE on error, TRUE otherwise.  */
d783 3
a785 2
static bfd_boolean
do_slurp_coff_armap (bfd *abfd)
d795 1
a795 1
  bfd_vma (*swap) (const bfd_byte *);
d800 1
a800 1
  mapdata = _bfd_read_ar_hdr (abfd);
d802 1
a802 1
    return FALSE;
d804 1
a804 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d806 1
a806 1
  if (bfd_bread (int_buf, 4, abfd) != 4)
d810 1
a810 1
      return FALSE;
d815 1
a815 1
  nsymz = bfd_getb32 (int_buf);
d829 1
a829 1
      nsymz = bfd_getl32 (int_buf);
d841 1
a841 1
  ardata->symdefs = bfd_zalloc (abfd, carsym_size + stringsize + 1);
d843 1
a843 1
    return FALSE;
d848 1
a848 1
  raw_armap = bfd_alloc (abfd, ptrsize);
d851 2
a852 2
  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))
d863 1
a863 1
      carsyms->file_offset = swap ((bfd_byte *) rawptr);
d875 2
a876 2
  bfd_has_map (abfd) = TRUE;
  bfd_release (abfd, raw_armap);
d883 1
a883 1
    tmp = _bfd_read_ar_hdr (abfd);
d896 1
a896 1
  return TRUE;
d899 1
a899 1
  bfd_release (abfd, raw_armap);
d901 2
a902 2
  bfd_release (abfd, (ardata)->symdefs);
  return FALSE;
d906 1
a906 1
   Returns FALSE on error, TRUE otherwise */
d908 3
a910 2
bfd_boolean
bfd_slurp_armap (bfd *abfd)
d913 1
a913 1
  int i = bfd_bread (nextname, 16, abfd);
d916 1
a916 1
    return TRUE;
d918 1
a918 1
    return FALSE;
d921 1
a921 1
    return FALSE;
a931 1
      extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
d935 1
a935 1
      return FALSE;
d939 2
a940 2
  bfd_has_map (abfd) = FALSE;
  return TRUE;
d943 1
a943 1
/* Returns FALSE on error, TRUE otherwise */
d950 3
a952 2
bfd_boolean
bfd_slurp_bsd_armap_f2 (bfd *abfd)
d963 1
a963 1
  int i = bfd_bread (nextname, 16, abfd);
d966 1
a966 1
    return TRUE;
d968 1
a968 1
    return FALSE;
d972 1
a972 1
    return FALSE;
d980 2
a981 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d984 1
a984 1
  mapdata = _bfd_read_ar_hdr (abfd);
d986 1
a986 1
    return FALSE;
d989 1
a989 1
  raw_armap = bfd_zalloc (abfd, amt);
d993 2
a994 2
      bfd_release (abfd, mapdata);
      return FALSE;
d997 1
a997 1
  if (bfd_bread (raw_armap, amt, abfd) != amt)
d1002 1
a1002 1
      bfd_release (abfd, raw_armap);
d1006 1
a1006 1
  ardata->symdef_count = H_GET_16 (abfd, raw_armap);
d1024 2
a1025 2
  amt = ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = bfd_alloc (abfd, amt);
d1027 1
a1027 1
    return FALSE;
d1043 2
a1044 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d1057 1
a1057 1
/* Returns FALSE on error, TRUE otherwise.  */
d1059 3
a1061 2
bfd_boolean
_bfd_slurp_extended_name_table (bfd *abfd)
d1068 1
a1068 1
     we probably don't want to return TRUE.  */
d1070 1
a1070 1
  if (bfd_bread (nextname, 16, abfd) == 16)
d1073 1
a1073 1
	return FALSE;
d1079 1
a1079 1
	  return TRUE;
d1082 1
a1082 1
      namedata = _bfd_read_ar_hdr (abfd);
d1084 1
a1084 1
	return FALSE;
d1091 2
a1092 2
	  bfd_release (abfd, namedata);
	  return FALSE;
d1095 1
a1095 1
      if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1099 1
a1099 1
	  bfd_release (abfd, (bfd_ardata (abfd)->extended_names));
d1132 1
a1132 1
  return TRUE;
d1141 3
a1143 1
normalize (bfd *abfd, const char *file)
d1164 1
a1164 1
  copy = bfd_alloc (abfd, last - first + 1);
d1176 3
a1178 1
normalize (bfd *abfd ATTRIBUTE_UNUSED, const char *file)
d1192 1
a1192 1
  if (filename != NULL)
d1202 6
a1207 5
bfd_boolean
_bfd_archive_bsd_construct_extended_name_table (bfd *abfd,
						char **tabloc,
						bfd_size_type *tablen,
						const char **name)
d1210 1
a1210 1
  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);
d1215 6
a1220 5
bfd_boolean
_bfd_archive_coff_construct_extended_name_table (bfd *abfd,
						 char **tabloc,
						 bfd_size_type *tablen,
						 const char **name)
d1223 1
a1223 1
  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);
d1230 1
a1230 1
   further massage.  Returns TRUE if it ran successfully, FALSE if
d1234 6
a1239 5
bfd_boolean
_bfd_construct_extended_name_table (bfd *abfd,
				    bfd_boolean trailing_slash,
				    char **tabloc,
				    bfd_size_type *tablen)
d1256 1
a1256 1
	return FALSE;
d1292 1
a1292 1
    return TRUE;
d1296 1
a1296 1
    return FALSE;
d1309 1
a1309 1
	return FALSE;
d1344 1
a1344 1
  return TRUE;
d1353 3
a1355 1
hpux_uid_gid_encode (char str[6], long int id)
d1381 4
a1384 1
bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
d1395 1
a1395 1
      struct bfd_in_memory *bim = member->iostream;
d1409 1
a1409 1
  ared = bfd_zalloc (abfd, amt);
d1415 1
a1415 1
  memset (hdr, ' ', sizeof (struct ar_hdr));
d1461 1
a1461 1
struct ar_hdr *bfd_special_undocumented_glue (bfd *, const char *);
d1464 3
a1466 1
bfd_special_undocumented_glue (bfd *abfd, const char *filename)
d1477 3
a1479 1
bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
d1534 4
a1537 1
bfd_dont_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1574 4
a1577 1
bfd_bsd_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1625 4
a1628 1
bfd_gnu_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1672 3
a1674 2
bfd_boolean
_bfd_write_archive_contents (bfd *arch)
d1680 2
a1681 3
  bfd_boolean makemap = bfd_has_map (arch);
  /* If no .o's, don't bother to make a map.  */
  bfd_boolean hasobjects = FALSE;
d1699 1
a1699 1
	  return FALSE;
d1704 1
a1704 1
	    bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1706 1
a1706 1
	    return FALSE;
d1709 3
a1711 2
	  BFD_SEND (arch, _bfd_truncate_arname,
		    (arch, current->filename, (char *) arch_hdr (current)));
d1721 1
a1721 1
	    hasobjects = TRUE;
d1727 1
a1727 1
    return FALSE;
d1730 1
a1730 1
    return FALSE;
d1732 1
a1732 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), SARMAG, arch);
d1734 1
a1734 1
  wrote = bfd_bwrite (ARMAG, SARMAG, arch);
d1737 1
a1737 1
    return FALSE;
d1742 1
a1742 1
	return FALSE;
d1749 1
a1749 1
      memset (&hdr, 0, sizeof (struct ar_hdr));
d1758 1
a1758 1
      if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d1761 1
a1761 1
	return FALSE;
d1764 2
a1765 2
	  if (bfd_bwrite ("\012", 1, arch) != 1)
	    return FALSE;
d1776 1
a1776 1
      if (bfd_bwrite (hdr, sizeof (*hdr), arch)
d1778 1
a1778 1
	return FALSE;
d1780 1
a1780 1
	return FALSE;
d1787 1
a1787 1
	  if (bfd_bread (buffer, amt, current) != amt)
d1791 1
a1791 1
	      return FALSE;
d1793 2
a1794 2
	  if (bfd_bwrite (buffer, amt, arch) != amt)
	    return FALSE;
d1799 2
a1800 2
	  if (bfd_bwrite ("\012", 1, arch) != 1)
	    return FALSE;
d1823 1
a1823 1
  return TRUE;
d1828 4
a1831 2
bfd_boolean
_bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
d1842 1
a1842 1
  bfd_boolean ret;
d1850 2
a1851 2
  amt = orl_max * sizeof (struct orl);
  map = bfd_malloc (amt);
d1857 1
a1857 1
  first_name = bfd_alloc (arch, 1);
d1868 1
a1868 1
       current != NULL;
d1889 1
a1889 1
		  syms = bfd_malloc (syms_max);
d1917 3
a1919 3
			  amt = orl_max * sizeof (struct orl);
			  new_map = bfd_realloc (map, amt);
			  if (new_map == NULL)
d1927 1
a1927 1
		      map[orl_count].name = bfd_alloc (arch, amt);
d1971 1
a1971 1
  return FALSE;
d1974 7
a1980 6
bfd_boolean
bsd_write_armap (bfd *arch,
		 unsigned int elength,
		 struct orl *map,
		 unsigned int orl_count,
		 int stridx)
d1999 1
a1999 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2013 1
a2013 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2015 1
a2015 1
    return FALSE;
d2017 2
a2018 2
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;
d2038 1
a2038 1
      if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)
d2040 1
a2040 1
	return FALSE;
d2045 2
a2046 2
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;
d2051 2
a2052 2
      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
d2059 2
a2060 2
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
d2063 1
a2063 1
  return TRUE;
d2069 2
a2070 2
   Return TRUE if the timestamp was OK, or an unusual problem happened.
   Return FALSE if we updated the timestamp.  */
d2072 3
a2074 2
bfd_boolean
_bfd_archive_bsd_update_armap_timestamp (bfd *arch)
d2088 1
a2088 1
      return TRUE;
d2092 1
a2092 1
    return TRUE;
d2108 1
a2108 1
      || (bfd_bwrite (hdr.ar_date, sizeof (hdr.ar_date), arch)
d2114 1
a2114 1
      return TRUE;
d2118 1
a2118 1
  return FALSE;
d2135 7
a2141 6
bfd_boolean
coff_write_armap (bfd *arch,
		  unsigned int elength,
		  struct orl *map,
		  unsigned int symbol_count,
		  int stridx)
d2164 1
a2164 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2180 1
a2180 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2182 1
a2182 1
    return FALSE;
d2185 1
a2185 1
    return FALSE;
d2195 1
a2195 1
  while (current != NULL && count < symbol_count)
d2203 1
a2203 1
	    return FALSE;
d2207 2
a2208 1
      archive_member_file_ptr += arelt_size (current) + sizeof (struct ar_hdr);
d2219 2
a2220 2
      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
d2227 2
a2228 2
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
d2231 1
a2231 1
  return TRUE;
@


1.24.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d439 1
a439 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d442 1
a442 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d444 1
a444 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d2085 1
a2085 1
      bfd_perror (_("Reading archive file mod timestamp"));
d2111 2
a2112 1
      bfd_perror (_("Writing updated armap timestamp"));
@


1.24.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d163 9
a171 12
static char *get_extended_arelt_filename
  PARAMS ((bfd *arch, const char *name));
static bfd_boolean do_slurp_bsd_armap
  PARAMS ((bfd *abfd));
static bfd_boolean do_slurp_coff_armap
  PARAMS ((bfd *abfd));
bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *abfd));
static const char *normalize
  PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem
  PARAMS ((bfd *abfd, const char *, bfd *member));
d173 1
a173 1
bfd_boolean
d181 1
a181 1
    return FALSE;
d189 1
a189 1
  return TRUE;
d250 1
a250 1
	bfd_boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d257 1
a257 1
bfd_boolean
d264 1
a264 1
  return TRUE;
d283 1
a283 1
bfd_boolean
d292 1
a292 1
    return FALSE;
d308 1
a308 1
  return TRUE;
d667 1
a667 1
	  bfd_boolean fail;
d669 2
a670 2
	  first->target_defaulted = FALSE;
	  fail = FALSE;
d710 1
a710 1
/* Returns FALSE on error, TRUE otherwise */
d712 1
a712 1
static bfd_boolean
d726 1
a726 1
    return FALSE;
d732 1
a732 1
    return FALSE;
d740 1
a740 1
      return FALSE;
d761 1
a761 1
    return FALSE;
d777 2
a778 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d781 1
a781 1
/* Returns FALSE on error, TRUE otherwise.  */
d783 1
a783 1
static bfd_boolean
d802 1
a802 1
    return FALSE;
d810 1
a810 1
      return FALSE;
d843 1
a843 1
    return FALSE;
d875 1
a875 1
  bfd_has_map (abfd) = TRUE;
d896 1
a896 1
  return TRUE;
d902 1
a902 1
  return FALSE;
d906 1
a906 1
   Returns FALSE on error, TRUE otherwise */
d908 1
a908 1
bfd_boolean
d916 1
a916 1
    return TRUE;
d918 1
a918 1
    return FALSE;
d921 1
a921 1
    return FALSE;
d935 1
a935 1
      return FALSE;
d939 2
a940 2
  bfd_has_map (abfd) = FALSE;
  return TRUE;
d943 1
a943 1
/* Returns FALSE on error, TRUE otherwise */
d950 1
a950 1
bfd_boolean
d966 1
a966 1
    return TRUE;
d968 1
a968 1
    return FALSE;
d972 1
a972 1
    return FALSE;
d980 2
a981 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d986 1
a986 1
    return FALSE;
d994 1
a994 1
      return FALSE;
d1027 1
a1027 1
    return FALSE;
d1043 2
a1044 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d1057 1
a1057 1
/* Returns FALSE on error, TRUE otherwise.  */
d1059 1
a1059 1
bfd_boolean
d1068 1
a1068 1
     we probably don't want to return TRUE.  */
d1073 1
a1073 1
	return FALSE;
d1079 1
a1079 1
	  return TRUE;
d1084 1
a1084 1
	return FALSE;
d1092 1
a1092 1
	  return FALSE;
d1132 1
a1132 1
  return TRUE;
d1202 1
a1202 1
bfd_boolean
d1210 1
a1210 1
  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);
d1215 1
a1215 1
bfd_boolean
d1223 1
a1223 1
  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);
d1230 1
a1230 1
   further massage.  Returns TRUE if it ran successfully, FALSE if
d1234 1
a1234 1
bfd_boolean
d1237 1
a1237 1
     bfd_boolean trailing_slash;
d1256 1
a1256 1
	return FALSE;
d1292 1
a1292 1
    return TRUE;
d1296 1
a1296 1
    return FALSE;
d1309 1
a1309 1
	return FALSE;
d1344 1
a1344 1
  return TRUE;
d1461 1
a1461 2
struct ar_hdr *bfd_special_undocumented_glue
  PARAMS ((bfd *, const char *));
d1672 1
a1672 1
bfd_boolean
d1680 2
a1681 3
  bfd_boolean makemap = bfd_has_map (arch);
  /* If no .o's, don't bother to make a map.  */
  bfd_boolean hasobjects = FALSE;
d1699 1
a1699 1
	  return FALSE;
d1706 1
a1706 1
	    return FALSE;
d1721 1
a1721 1
	    hasobjects = TRUE;
d1727 1
a1727 1
    return FALSE;
d1730 1
a1730 1
    return FALSE;
d1737 1
a1737 1
    return FALSE;
d1742 1
a1742 1
	return FALSE;
d1761 1
a1761 1
	return FALSE;
d1765 1
a1765 1
	    return FALSE;
d1778 1
a1778 1
	return FALSE;
d1780 1
a1780 1
	return FALSE;
d1791 1
a1791 1
	      return FALSE;
d1794 1
a1794 1
	    return FALSE;
d1800 1
a1800 1
	    return FALSE;
d1823 1
a1823 1
  return TRUE;
d1828 1
a1828 1
bfd_boolean
d1842 1
a1842 1
  bfd_boolean ret;
d1971 1
a1971 1
  return FALSE;
d1974 1
a1974 1
bfd_boolean
d2015 1
a2015 1
    return FALSE;
d2018 1
a2018 1
    return FALSE;
d2040 1
a2040 1
	return FALSE;
d2046 1
a2046 1
    return FALSE;
d2052 1
a2052 1
	return FALSE;
d2060 1
a2060 1
	return FALSE;
d2063 1
a2063 1
  return TRUE;
d2069 2
a2070 2
   Return TRUE if the timestamp was OK, or an unusual problem happened.
   Return FALSE if we updated the timestamp.  */
d2072 1
a2072 1
bfd_boolean
d2088 1
a2088 1
      return TRUE;
d2092 1
a2092 1
    return TRUE;
d2114 1
a2114 1
      return TRUE;
d2118 1
a2118 1
  return FALSE;
d2135 1
a2135 1
bfd_boolean
d2182 1
a2182 1
    return FALSE;
d2185 1
a2185 1
    return FALSE;
d2203 1
a2203 1
	    return FALSE;
d2220 1
a2220 1
	return FALSE;
d2228 1
a2228 1
	return FALSE;
d2231 1
a2231 1
  return TRUE;
@


1.24.10.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata(bfd)->arch_header)
d163 12
d177 2
a178 1
_bfd_generic_mkarchive (bfd *abfd)
d182 1
a182 1
  abfd->tdata.aout_ar_data = bfd_zalloc (abfd, amt);
d200 1
a200 2
	symindex bfd_get_next_mapent
	  (bfd *abfd, symindex previous, carsym **sym);
d217 4
a220 1
bfd_get_next_mapent (bfd *abfd, symindex prev, carsym **entry)
d242 2
a243 1
_bfd_create_empty_archive_element_shell (bfd *obfd)
d253 1
a253 1
	bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
d261 3
a263 1
bfd_set_archive_head (bfd *output_archive, bfd *new_head)
d265 1
d271 3
a273 1
_bfd_look_for_bfd_in_cache (bfd *arch_bfd, file_ptr filepos)
d287 3
a289 1
_bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)
d293 1
a293 1
  struct ar_cache *new_cache = bfd_zalloc (arch_bfd, amt);
d299 1
a299 1
  new_cache->next = NULL;
d318 3
a320 1
get_extended_arelt_filename (bfd *arch, const char *name)
d347 3
a349 2
void *
_bfd_generic_read_ar_hdr (bfd *abfd)
d351 1
a351 1
  return _bfd_generic_read_ar_hdr_mag (abfd, NULL);
d357 4
a360 2
void *
_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
d371 2
a372 1
  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))
d442 1
a442 1
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d445 1
a445 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d447 1
a447 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d472 1
a472 1
  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));
d482 1
a482 1
	memcpy (ared->filename, hdr.ar_name, namelen);
d486 1
a486 1
  return ared;
d494 3
a496 1
_bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
d508 1
a508 1
  if ((new_areldata = _bfd_read_ar_hdr (archive)) == NULL)
d514 1
a514 1
      bfd_release (archive, new_areldata);
d519 1
a519 1
  n_nfd->arelt_data = new_areldata;
d526 2
a527 2
  bfd_release (archive, n_nfd);
  bfd_release (archive, new_areldata);
d535 3
a537 1
_bfd_generic_get_elt_at_index (bfd *abfd, symindex index)
d550 1
a550 1
	bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
d562 3
a564 1
bfd_openr_next_archived_file (bfd *archive, bfd *last_file)
d574 3
a576 1
		   openr_next_archived_file, (archive, last_file));
d580 3
a582 1
bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
d602 2
a603 1
bfd_generic_archive_p (bfd *abfd)
d609 1
a609 1
  if (bfd_bread (armag, SARMAG, abfd) != SARMAG)
d628 1
a628 1
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
d667 1
a667 1
      first = bfd_openr_next_archived_file (abfd, NULL);
d682 1
a682 1
	      bfd_close (first);
d716 2
a717 1
do_slurp_bsd_armap (bfd *abfd)
d727 1
a727 1
  mapdata = _bfd_read_ar_hdr (abfd);
d731 1
a731 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d733 2
a734 2
  raw_armap = bfd_zalloc (abfd, parsed_size);
  if (raw_armap == NULL)
d737 1
a737 1
  if (bfd_bread (raw_armap, parsed_size, abfd) != parsed_size)
d742 1
a742 1
      bfd_release (abfd, raw_armap);
d761 2
a762 2
  amt = ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = bfd_alloc (abfd, amt);
d787 2
a788 1
do_slurp_coff_armap (bfd *abfd)
d798 1
a798 1
  bfd_vma (*swap) (const bfd_byte *);
d803 1
a803 1
  mapdata = _bfd_read_ar_hdr (abfd);
d807 1
a807 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d809 1
a809 1
  if (bfd_bread (int_buf, 4, abfd) != 4)
d818 1
a818 1
  nsymz = bfd_getb32 (int_buf);
d832 1
a832 1
      nsymz = bfd_getl32 (int_buf);
d844 1
a844 1
  ardata->symdefs = bfd_zalloc (abfd, carsym_size + stringsize + 1);
d851 1
a851 1
  raw_armap = bfd_alloc (abfd, ptrsize);
d854 2
a855 2
  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))
d866 1
a866 1
      carsyms->file_offset = swap ((bfd_byte *) rawptr);
d879 1
a879 1
  bfd_release (abfd, raw_armap);
d886 1
a886 1
    tmp = _bfd_read_ar_hdr (abfd);
d902 1
a902 1
  bfd_release (abfd, raw_armap);
d904 1
a904 1
  bfd_release (abfd, (ardata)->symdefs);
d912 2
a913 1
bfd_slurp_armap (bfd *abfd)
d916 1
a916 1
  int i = bfd_bread (nextname, 16, abfd);
a934 1
      extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
d954 2
a955 1
bfd_slurp_bsd_armap_f2 (bfd *abfd)
d966 1
a966 1
  int i = bfd_bread (nextname, 16, abfd);
d987 1
a987 1
  mapdata = _bfd_read_ar_hdr (abfd);
d992 1
a992 1
  raw_armap = bfd_zalloc (abfd, amt);
d996 1
a996 1
      bfd_release (abfd, mapdata);
d1000 1
a1000 1
  if (bfd_bread (raw_armap, amt, abfd) != amt)
d1005 1
a1005 1
      bfd_release (abfd, raw_armap);
d1009 1
a1009 1
  ardata->symdef_count = H_GET_16 (abfd, raw_armap);
d1027 2
a1028 2
  amt = ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = bfd_alloc (abfd, amt);
d1063 2
a1064 1
_bfd_slurp_extended_name_table (bfd *abfd)
d1073 1
a1073 1
  if (bfd_bread (nextname, 16, abfd) == 16)
d1085 1
a1085 1
      namedata = _bfd_read_ar_hdr (abfd);
d1094 1
a1094 1
	  bfd_release (abfd, namedata);
d1098 1
a1098 1
      if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1102 1
a1102 1
	  bfd_release (abfd, (bfd_ardata (abfd)->extended_names));
d1144 3
a1146 1
normalize (bfd *abfd, const char *file)
d1167 1
a1167 1
  copy = bfd_alloc (abfd, last - first + 1);
d1179 3
a1181 1
normalize (bfd *abfd ATTRIBUTE_UNUSED, const char *file)
d1195 1
a1195 1
  if (filename != NULL)
d1206 5
a1210 4
_bfd_archive_bsd_construct_extended_name_table (bfd *abfd,
						char **tabloc,
						bfd_size_type *tablen,
						const char **name)
d1219 5
a1223 4
_bfd_archive_coff_construct_extended_name_table (bfd *abfd,
						 char **tabloc,
						 bfd_size_type *tablen,
						 const char **name)
d1238 5
a1242 4
_bfd_construct_extended_name_table (bfd *abfd,
				    bfd_boolean trailing_slash,
				    char **tabloc,
				    bfd_size_type *tablen)
d1356 3
a1358 1
hpux_uid_gid_encode (char str[6], long int id)
d1384 4
a1387 1
bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
d1398 1
a1398 1
      struct bfd_in_memory *bim = member->iostream;
d1412 1
a1412 1
  ared = bfd_zalloc (abfd, amt);
d1418 1
a1418 1
  memset (hdr, ' ', sizeof (struct ar_hdr));
d1464 2
a1465 1
struct ar_hdr *bfd_special_undocumented_glue (bfd *, const char *);
d1468 3
a1470 1
bfd_special_undocumented_glue (bfd *abfd, const char *filename)
d1481 3
a1483 1
bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
d1538 4
a1541 1
bfd_dont_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1578 4
a1581 1
bfd_bsd_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1629 4
a1632 1
bfd_gnu_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1677 2
a1678 1
_bfd_write_archive_contents (bfd *arch)
d1709 1
a1709 1
	    bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1714 3
a1716 2
	  BFD_SEND (arch, _bfd_truncate_arname,
		    (arch, current->filename, (char *) arch_hdr (current)));
d1737 1
a1737 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), SARMAG, arch);
d1739 1
a1739 1
  wrote = bfd_bwrite (ARMAG, SARMAG, arch);
d1754 1
a1754 1
      memset (&hdr, 0, sizeof (struct ar_hdr));
d1763 1
a1763 1
      if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d1769 1
a1769 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d1781 1
a1781 1
      if (bfd_bwrite (hdr, sizeof (*hdr), arch)
d1792 1
a1792 1
	  if (bfd_bread (buffer, amt, current) != amt)
d1798 1
a1798 1
	  if (bfd_bwrite (buffer, amt, arch) != amt)
d1804 1
a1804 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d1834 3
a1836 1
_bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
d1855 2
a1856 2
  amt = orl_max * sizeof (struct orl);
  map = bfd_malloc (amt);
d1862 1
a1862 1
  first_name = bfd_alloc (arch, 1);
d1873 1
a1873 1
       current != NULL;
d1894 1
a1894 1
		  syms = bfd_malloc (syms_max);
d1922 3
a1924 3
			  amt = orl_max * sizeof (struct orl);
			  new_map = bfd_realloc (map, amt);
			  if (new_map == NULL)
d1932 1
a1932 1
		      map[orl_count].name = bfd_alloc (arch, amt);
d1980 6
a1985 5
bsd_write_armap (bfd *arch,
		 unsigned int elength,
		 struct orl *map,
		 unsigned int orl_count,
		 int stridx)
d2004 1
a2004 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2018 1
a2018 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2022 1
a2022 1
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
d2043 1
a2043 1
      if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)
d2050 1
a2050 1
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
d2056 1
a2056 1
      if (bfd_bwrite (*map[count].name, len, arch) != len)
d2064 1
a2064 1
      if (bfd_bwrite ("", 1, arch) != 1)
d2078 2
a2079 1
_bfd_archive_bsd_update_armap_timestamp (bfd *arch)
d2113 1
a2113 1
      || (bfd_bwrite (hdr.ar_date, sizeof (hdr.ar_date), arch)
d2141 6
a2146 5
coff_write_armap (bfd *arch,
		  unsigned int elength,
		  struct orl *map,
		  unsigned int symbol_count,
		  int stridx)
d2169 1
a2169 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2185 1
a2185 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2200 1
a2200 1
  while (current != NULL && count < symbol_count)
d2212 2
a2213 1
      archive_member_file_ptr += arelt_size (current) + sizeof (struct ar_hdr);
d2224 1
a2224 1
      if (bfd_bwrite (*map[count].name, len, arch) != len)
d2232 1
a2232 1
      if (bfd_bwrite ("", 1, arch) != 1)
@


1.23
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@a605 2
  tdata_hold = abfd->tdata.aout_ar_data;

d622 2
a623 2
  /* We are setting bfd_ardata(abfd) here, but since bfd_ardata
     involves a cast, we can't do it as the left operand of assignment.  */
d625 1
a625 2
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);

d627 4
a630 1
    return NULL;
d639 2
a640 1
  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd)))
a641 2
      bfd_release (abfd, bfd_ardata (abfd));
      abfd->tdata.aout_ar_data = tdata_hold;
a643 5
      return NULL;
    }

  if (!BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
    {
d645 1
a645 3
      abfd->tdata.aout_ar_data = tdata_hold;
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
a680 1
	      abfd->tdata.aout_ar_data = tdata_hold;
d683 1
@


1.23.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d606 2
d624 4
a627 1
  tdata_hold = bfd_ardata (abfd);
a628 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d630 1
a630 4
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }
d639 1
a639 2
  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd))
      || !BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
d641 2
d645 5
d651 3
a653 1
      bfd_ardata (abfd) = tdata_hold;
d689 1
a691 1
	      bfd_ardata (abfd) = tdata_hold;
@


1.23.2.2
log
@Merge from mainline.
@
text
@d439 1
a439 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d442 1
a442 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d444 1
a444 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
@


1.22
log
@	* coff64-rs6000.c (_bfd_xcoff64_put_symbol_name): Prototype.
	Whitespace changes.
	* archive.c: Update copyright date.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d1749 1
a1749 1
      if (_bfd_compute_and_write_armap (arch, (unsigned int) elength) != true)
d1879 2
a1880 2
      if ((bfd_check_format (current, bfd_object) == true)
	  && ((bfd_get_file_flags (current) & HAS_SYMS)))
@


1.22.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1749 1
a1749 1
      if (! _bfd_compute_and_write_armap (arch, (unsigned int) elength))
d1879 2
a1880 2
      if (bfd_check_format (current, bfd_object)
	  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)
@


1.22.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d606 2
d624 4
a627 1
  tdata_hold = bfd_ardata (abfd);
a628 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d630 1
a630 4
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }
d639 1
a639 2
  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd))
      || !BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
d641 2
d645 5
d651 3
a653 1
      bfd_ardata (abfd) = tdata_hold;
d689 1
a691 1
	      bfd_ardata (abfd) = tdata_hold;
@


1.22.6.3
log
@merge from mainline
@
text
@d439 1
a439 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d442 1
a442 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d444 1
a444 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d2085 1
a2085 1
      bfd_perror (_("Reading archive file mod timestamp"));
d2111 2
a2112 1
      bfd_perror (_("Writing updated armap timestamp"));
@


1.21
log
@	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.
@
text
@d3 1
a3 1
   2000, 2001
@


1.20
log
@	* Makefile.am: split up BFD_LIBS like statements in BFD32_LIBS and
	BFD64_LIBS, make the latter depending on the availability of BFD64.
	Add archive64.c source file.
	* archive64.c: New file implementing bfd_elf64_archive_slurp_armap
	and bfd_elf64_archive_write_armap, code from elf64-mips.c
	* archive.c (bfd_slurp_armap): Add ELF64 archive support.
	* config.bfd (mips*-*-irix6*): Allow with BFD64 only.
	(mips64*el-*-linux*): Likewise.
	(mips*el-*-linux*): Likewise. Reorder entries.
	* configure.in (bfd_libs): Define in dependency of BFD64 and
	AC_SUBST it.
	* elf64-mips.c (mips_elf64_slurp_armap): Remove, use
	bfd_elf64_archive_slurp_armap instead.
	(mips_elf64_write_armap): Remove, use bfd_elf64_archive_write_armap
	instead.
@
text
@d2193 2
a2194 1
  bfd_write_bigendian_4byte_int (arch, symbol_count);
d2211 2
a2212 1
	  bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr);
@


1.20.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d2193 1
a2193 2
  if (!bfd_write_bigendian_4byte_int (arch, symbol_count))
    return false;
d2210 1
a2210 2
	  if (!bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr))
	    return false;
@


1.19
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d167 1
d938 4
a941 1
      /* Irix 6 archive--must be recognized by code in elf64-mips.c.  */
d944 1
@


1.18
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2148 1
a2148 1
     archive * the number of bytes in a int, + an int for the count.  */
@


1.17
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d135 1
a135 1
#include <ctype.h>
d410 1
a410 1
	   && isdigit ((unsigned char) hdr.ar_name[3]))
@


1.16
log
@	* archive.c (offsetof): Remove define.
	* elf.c: Likewise.
	* oasys.c: Likewise
	* sysdep.h (offsetof): Define.
@
text
@d3 1
a3 1
   2000
d176 1
a176 2
  abfd->tdata.aout_ar_data = ((struct artdata *)
			      bfd_zalloc (abfd, sizeof (struct artdata)));
d178 1
d287 1
a287 3
  struct ar_cache *new_cache = ((struct ar_cache *)
				bfd_zalloc (arch_bfd,
					    sizeof (struct ar_cache)));
d289 1
d360 1
a360 1
  unsigned int parsed_size;
d363 2
a364 2
  unsigned int namelen = 0;
  unsigned int allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);
d367 1
a367 1
  if (bfd_read ((PTR) hdrp, 1, sizeof (struct ar_hdr), abfd)
d423 1
a423 1
      if (bfd_read (filename, 1, namelen, abfd) != namelen)
d478 1
a478 1
	memcpy (ared->filename, hdr.ar_name, namelen);
d603 1
d607 1
a607 1
  if (bfd_read ((PTR) armag, 1, SARMAG, abfd) != SARMAG)
d625 2
a626 2
  abfd->tdata.aout_ar_data = ((struct artdata *)
			      bfd_zalloc (abfd, sizeof (struct artdata)));
d703 1
a703 1
   changing some bfd_h_get_32 to bfd_h_get_64.  */
d728 1
a728 1
  unsigned int parsed_size;
d741 1
a741 1
  if (bfd_read ((PTR) raw_armap, 1, parsed_size, abfd) != parsed_size)
d750 1
a750 1
  ardata->symdef_count = bfd_h_get_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;
d765 2
a766 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * sizeof (carsym)));
d774 2
a775 2
      set->name = bfd_h_get_32 (abfd, rbase) + stringbase;
      set->file_offset = bfd_h_get_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d798 1
a798 1
  unsigned int stringsize;
d801 1
a801 1
  unsigned int nsymz;		/* Number of symbols in armap.  */
d804 2
a805 1
  unsigned int carsym_size, ptrsize, i;
d813 1
a813 1
  if (bfd_read ((PTR) int_buf, 1, 4, abfd) != 4)
d858 2
a859 2
  if (bfd_read ((PTR) raw_armap, 1, ptrsize, abfd) != ptrsize
      || bfd_read ((PTR) stringbase, 1, stringsize, abfd) != stringsize)
d889 1
a889 1
    bfd_seek (abfd,   ardata->first_file_filepos, SEEK_SET);
d897 1
a897 1
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~1;
d920 1
a920 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d927 1
a927 1
  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
d964 1
d966 1
a966 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d974 1
a974 1
  if (bfd_seek (abfd, -16L, SEEK_CUR) != 0)
d991 2
a992 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, mapdata->parsed_size);
d1000 1
a1000 2
  if (bfd_read ((PTR) raw_armap, 1, mapdata->parsed_size, abfd) !=
      mapdata->parsed_size)
d1009 1
a1009 1
  ardata->symdef_count = bfd_h_get_16 (abfd, (PTR) raw_armap);
d1021 1
a1021 1
  stringsize = bfd_h_get_32 (abfd, raw_armap + HPUX_SYMDEF_COUNT_SIZE);
d1027 2
a1028 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * BSD_SYMDEF_SIZE));
d1036 2
a1037 2
      set->name = bfd_h_get_32 (abfd, rbase) + stringbase;
      set->file_offset = bfd_h_get_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d1068 1
d1073 1
a1073 1
  if (bfd_read ((PTR) nextname, 1, 16, abfd) == 16)
d1075 1
a1075 1
      if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
d1089 2
a1090 2
      bfd_ardata (abfd)->extended_names =
	bfd_zalloc (abfd, namedata->parsed_size);
d1098 1
a1098 2
      if (bfd_read ((PTR) bfd_ardata (abfd)->extended_names, 1,
		    namedata->parsed_size, abfd) != namedata->parsed_size)
d1148 2
a1149 2
  CONST char *first;
  CONST char *last;
d1167 1
a1167 1
  copy = (char *) bfd_alloc (abfd, last - first + 1);
d1245 1
a1245 1
  unsigned int total_namelen = 0;
d1393 1
d1411 2
a1412 2
  ared = (struct areltdata *) bfd_zalloc (abfd, sizeof (struct ar_hdr) +
					  sizeof (struct areltdata));
d1539 1
a1539 1
     CONST char *pathname;
d1579 1
a1579 1
     CONST char *pathname;
d1583 3
a1585 3
  int length;
  CONST char *filename = strrchr (pathname, '/');
  int maxlen = ar_maxnamelen (abfd);
d1630 1
a1630 1
     CONST char *pathname;
d1634 3
a1636 3
  int length;
  CONST char *filename = strrchr (pathname, '/');
  int maxlen = ar_maxnamelen (abfd);
d1735 1
a1735 1
  wrote = bfd_write (BFD_GNU960_ARMAG (arch), 1, SARMAG, arch);
d1737 1
a1737 1
  wrote = bfd_write (ARMAG, 1, SARMAG, arch);
d1744 1
a1744 1
      if (_bfd_compute_and_write_armap (arch, elength) != true)
d1756 1
a1756 1
	       (int) ((elength + 1) & ~1));
d1761 1
a1761 1
      if ((bfd_write ((char *) &hdr, 1, sizeof (struct ar_hdr), arch)
d1763 1
a1763 1
	  || bfd_write (etable, 1, elength, arch) != elength)
d1767 1
a1767 1
	  if (bfd_write ("\012", 1, 1, arch) != 1)
d1779 2
a1780 1
      if (bfd_write ((char *) hdr, 1, sizeof (*hdr), arch) != sizeof (*hdr))
d1790 1
a1790 1
	  if (bfd_read (buffer, amt, 1, current) != amt)
d1796 1
a1796 1
	  if (bfd_write (buffer, amt, 1, arch) != amt)
d1802 1
a1802 1
	  if (bfd_write ("\012", 1, 1, arch) != 1)
d1840 2
a1841 2
  int orl_max = 1024;		/* fine initial default */
  int orl_count = 0;
d1846 1
d1853 2
a1854 1
  map = (struct orl *) bfd_malloc (orl_max * sizeof (struct orl));
d1860 1
a1860 1
  first_name = bfd_alloc (arch, 1);
d1892 1
a1892 1
		  syms = (asymbol **) bfd_malloc ((size_t) syms_max);
d1913 1
a1913 1
		      size_t namelen;
d1920 2
a1921 3
			  new_map =
			    ((struct orl *)
			     bfd_realloc (map, orl_max * sizeof (struct orl)));
d1929 2
a1930 3
		      map[orl_count].name = ((char **)
					     bfd_alloc (arch,
							sizeof (char *)));
d1937 2
a1938 2
		      (map[orl_count]).pos = (file_ptr) current;
		      (map[orl_count]).namidx = stridx;
d2016 1
a2016 1
  if (bfd_write ((char *) &hdr, 1, sizeof (struct ar_hdr), arch)
d2019 2
a2020 2
  bfd_h_put_32 (arch, (bfd_vma) ranlibsize, temp);
  if (bfd_write (temp, 1, sizeof (temp), arch) != sizeof (temp))
d2027 1
a2027 1
      if (((bfd *) (map[count]).pos) != last_elt)
d2035 1
a2035 1
	  while (current != (bfd *) (map[count]).pos);
d2039 4
a2042 3
      bfd_h_put_32 (arch, map[count].namidx, buf);
      bfd_h_put_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);
      if (bfd_write (buf, BSD_SYMDEF_SIZE, 1, arch) != BSD_SYMDEF_SIZE)
d2047 2
a2048 2
  bfd_h_put_32 (arch, stringsize, temp);
  if (bfd_write (temp, 1, sizeof (temp), arch) != sizeof (temp))
d2054 1
a2054 1
      if (bfd_write (*map[count].name, 1, len, arch) != len)
d2062 1
a2062 1
      if (bfd_write ("", 1, 1, arch) != 1)
d2111 1
a2111 1
      || (bfd_write (hdr.ar_date, sizeof (hdr.ar_date), 1, arch)
d2152 1
a2152 1
  file_ptr archive_member_file_ptr;
d2184 1
a2184 1
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), arch)
d2203 1
a2203 1
      while (count < symbol_count && ((bfd *) (map[count]).pos) == current)
d2221 1
a2221 1
      if (bfd_write (*map[count].name, 1, len, arch) != len)
d2229 1
a2229 1
      if (bfd_write ("", 1, 1, arch) != 1)
@


1.15
log
@	* bfd.c (enum bfd_error): Add bfd_error_wrong_object_format.
	(bfd_errmsgs): Add corresponding message.
	* archive.c (bfd_generic_archive_p): Don't release bfd_ardata when
	finding an archive that contains different format object files.
	Return bfd_error_wrong_object_format for this case.
	* format.c: Formatting fixes.  s/CONST/const/.
	(bfd_check_format_matches): Accept archives that give
	bfd_error_wrong_object_format if no full match is found.  Tidy
	code handling matching_vector.  Don't return a pointer to freed
	memory in `matching'.  Handle ambiguous matches as for partial
	archive matches.
	* bfd-in2.h: Regenerate.
@
text
@a144 6
/* Define offsetof for those systems which lack it */

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

@


1.14
log
@Update copyright notices
@
text
@d687 5
d695 2
a696 1
	      bfd_set_error (bfd_error_wrong_format);
d699 1
a699 3

	  /* We ought to close first here, but we can't, because we
             have no way to remove it from the archive cache.  FIXME.  */
@


1.13
log
@* archive.c (coff_write_armap): Don't write more than symbol_count
`archive_member_file_ptr's.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.13.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
@


1.12
log
@2000-11-20  Kazu Hirata  <kazu@@hxi.com>

	* aix386-core.c: Fix formatting.
	* aout-adobe.c: Likewise.
	* aout-arm.c: Likewise.
	* aout-encap.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aout-target.h: Likewise.
	* aout-tic30.c: Likewise.
	* aoutf1.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
@
text
@d2201 1
a2201 1
      while (((bfd *) (map[count]).pos) == current)
@


1.11
log
@2000-11-09  Kazu Hirata  <kazu@@hxi.com>

	* archive.c: Fix formatting.
	* archures.c: Likewise.
@
text
@d165 1
a165 1
#define arch_eltdata(bfd) ((struct areltdata *)((bfd)->arelt_data))
d898 1
a898 1
	      (tmp->parsed_size + sizeof(struct ar_hdr) + 1) & ~1;
@


1.10
log
@2000-09-08  Kazu Hirata  <kazu@@hxi.com>

	* archive.c: Fix formatting.
	* coff-arm.c: Likewise.
	* doc/chew.c: Likewise.
@
text
@d155 2
a156 4
   to the front of the contents!
*/
struct ar_cache
{
d412 1
a412 1
     Only implemented for reading, so far! */
d447 1
a447 1
          e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d449 1
a449 1
            e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d527 1
a527 1
  /* huh? */
a560 1

d781 1
a781 1
  /* Pad to an even boundary if you have to */
d790 2
a791 1
/* Returns false on error, true otherwise */
d836 1
a836 1
      /* This looks dangerous, let's do it the other way around */
d867 1
a867 1
  /* OK, build the carsyms */
d880 1
a880 1
  /* Pad to an even boundary if you have to */
d886 1
a886 1
  /* Check for a second archive header (as used by PE) */
d973 1
a973 1
  /* The archive has at least 16 bytes in it */
d1022 1
a1022 1
  /* skip sym count and string sz */
d1042 1
a1042 1
  /* Pad to an even boundary if you have to */
d1059 3
a1061 1
  extended the format by using the prefix // for the special element */
a1062 1
/* Returns false on error, true otherwise */
d1116 7
a1122 6
	for (; temp < limit; ++temp) {
	  if (*temp == '\012')
	    temp[temp[-1] == '/' ? -1 : 0] = '\0';
	  if (*temp == '\\')
	    *temp = '/';
	}
d1125 1
a1125 1
      /* Pad to an even boundary if you have to */
d1132 3
a1134 1
      /* bfd_release (abfd, namedata); */
d1142 2
a1143 1
   semicolon */
d1252 1
a1252 1
  /* Figure out how long the table should be */
d1335 1
a1335 1
	     sprintf but not all implementations get this right */
d1355 1
d1397 1
a1397 1
      /* Assume we just "made" the member, and fake it */
d1399 3
a1401 3
      time(&status.st_mtime);
      status.st_uid = getuid();
      status.st_gid = getgid();
d1417 1
a1417 1
  /* ar headers are space padded, not null padded! */
d1422 1
a1422 1
  /* Goddamned sprintf doesn't permit MAXIMUM field lengths */
d1444 1
a1444 1
     IO operations */
d1460 3
a1462 3
    undocumented, it's undocumented.  You may think that it would take
    a strong stomach to write this, and it does, but it takes even a
    stronger stomach to try to code around such a thing!  */
d1477 2
a1478 1
/* Analogous to stat call */
d1495 5
a1499 3
#define foo(arelt, stelt, size)  \
  buf->stelt = strtol (hdr->arelt, &aloser, size); \
  if (aloser == hdr->arelt) return -1;
d1502 20
a1521 15
# define foo2(arelt, stelt, size) \
  if (hdr->arelt[5] == ' ') { foo (arelt, stelt, size); } \
  else { \
    int cnt; \
    for (buf->stelt = cnt = 0; cnt < 5; ++cnt) \
      { \
	if (hdr->arelt[cnt] < ' ' || hdr->arelt[cnt] > ' ' + 0x3f) \
	  return -1; \
	buf->stelt <<= 6; \
	buf->stelt += hdr->arelt[cnt] - ' '; \
      } \
    if (hdr->arelt[5] < '@@' || hdr->arelt[5] > '@@' + 3) return -1; \
    buf->stelt <<= 2; \
    buf->stelt += hdr->arelt[5] - '@@'; \
  }
d1673 1
a1673 1
/* The BFD is open for write and has its format set to bfd_archive */
d1684 1
a1684 1
  boolean hasobjects = false;	/* if no .o's, don't bother to make a map */
d1711 1
a1711 1
	  /* Put in the file name */
d1718 1
a1718 1
	{			/* don't bother if we won't make a map! */
d1778 1
a1778 1
      /* write ar header */
d1828 1
a1828 1
/* Note that the namidx for the first symbol is 0 */
d1861 1
a1861 2
  /* Drop all the files called __.SYMDEF, we're going to make our
     own */
d1866 1
a1866 1
  /* Map over each element */
d1897 2
a1898 1
	      /* Now map over all the symbols, picking out the ones we want */
d1913 1
a1913 1
		      /* This symbol will go into the archive header */
d1952 1
a1952 1
  /* OK, now we have collected all the data, let's write them out */
d2044 1
a2044 1
  /* now write the strings themselves */
d2087 3
a2089 1
      return true;		/* Can't read mod time for some reason */
d2092 2
a2093 1
    return true;		/* OK by the linker's rules */
d2114 3
a2116 1
      return true;		/* Some error while writing */
d2119 2
a2120 1
  return false;			/* We updated the timestamp successfully.  */
d2146 1
a2146 1
     archive * the number of bytes in a int, + an int for the count */
d2160 1
a2160 1
  /* work out where the first object file will go in the archive */
d2170 1
a2170 1
  /* This, at least, is what Intel coff sets the values to.: */
d2180 1
a2180 1
  /* Write the ar header for this item and the number of symbols */
d2198 2
a2199 2
      /* For each symbol which is used defined in this object, write out
	 the object file's address in the archive */
d2206 1
a2206 1
      /* Add size of this archive entry */
d2209 1
a2209 1
      /* remember aboout the even alignment */
d2214 1
a2214 1
  /* now write the strings themselves */
@


1.9
log
@* archive.c (_bfd_write_archive_contents): Add an informative
comment.
@
text
@d319 1
a319 1
   the string table. */
d329 1
a329 1
     the next region, but I'm too lazy. */
d331 1
a331 1
  /* Skip first char, which is '/' in SVR4 or ' ' in some other variants. */
d443 1
a443 1
	 spaces, so only look for ' ' if we don't find '/'. */
d598 1
a598 1
	 BSD-4.4-style element with a long odd size. */
a605 1

d632 1
a632 1
     involves a cast, we can't do it as the left operand of assignment. */
d739 1
a739 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more. */
d788 1
a788 1
     to be allocated on an objalloc anyway... */
d805 1
a805 1
  unsigned int nsymz;		/* Number of symbols in armap. */
d814 1
a814 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more. */
d823 1
a823 1
     in big endian format, nomatter the host or target. */
d846 1
a846 1
     bsd-style one in core all at once, for simplicity. */
d857 1
a857 1
  /* Allocate and read in the raw offsets. */
a884 1

a887 1

d952 1
a952 1
   This flavour is used by hp300hpux. */
d1048 1
a1048 1
     to be allocated on an objalloc anyway... */
d1131 1
a1131 1
	 below extended_names on the objalloc... */
a1182 1

d1317 1
a1317 1
	     generalise this hack. */
d1329 1
a1329 1
	     cases where you may safely use sprintf). */
d1378 1
a1378 1
   is set, and it's an in-memory bfd, we fake it. */
a1472 1

d1533 1
a1533 1
     intel's release is out the door. */
d1613 1
a1613 1
   bsd ar. */
d1834 1
a1834 1
  /* Dunno if this is the best place for this info... */
d1975 1
a1975 1
  /* Include 8 bytes to store ranlibsize and stringsize in output. */
d2045 1
a2045 1
     bug-compatible for sun's ar we use a null. */
d2206 1
a2206 1
     bug-compatible for arc960 we use a null. */
@


1.8
log
@Correct pointer comparisons relying on NULL less than any other pointer.
Alexander Aganichev's fix for ieee.c
@
text
@d1687 5
@


1.7
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d1191 1
a1191 1
    if (bslash > filename)
d1584 1
a1584 1
    if (bslash > filename)
d1635 1
a1635 1
    if (bslash > filename)
@


1.6
log
@
        * archive.c (hpux_uid_gid_encode): New function.
        (bfd_ar_hdr_from_filesystem): Use it if HPUX_LARGE_AR_IDS is
        defined and the ID is greater than 99999.
        (bfd_generic_stat_arch_elt): If HPUX_LARGE_AR_IDS is defined decode
        special uid/gid fields into 32 bit values.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d1186 11
d1580 11
d1630 11
@


1.5
log
@Revert previous patch.
@
text
@d897 1
a897 1
    if (tmp != NULL) 
d900 1
a900 1
	    && tmp->arch_header[1] == ' ') 
d1343 17
d1413 15
a1427 1
  sprintf ((hdr->ar_uid), "%ld", (long) status.st_uid);
d1487 20
d1509 2
a1510 2
  foo (ar_uid, st_uid, 10);
  foo (ar_gid, st_gid, 10);
@


1.5.2.1
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a1185 11

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
a1517 11
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

a1556 11

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif
@


1.4
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a1806 2
		  size_t namelen;
		  struct orl *new_map;
d1808 5
a1812 3
		  if (bfd_is_und_section (sec))
		    continue;
		  else if (bfd_is_com_section (sec))
d1814 3
a1816 6
		      if (! bfd_allow_commons_in_armap (arch))
			continue;
		    }
		  else if ((flags & (BSF_GLOBAL | BSF_WEAK | BSF_INDIRECT)) == 0)
		    continue;
		  
d1845 1
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d1807 2
d1810 3
a1812 5
		  if ((flags & BSF_GLOBAL ||
		       flags & BSF_WEAK ||
		       flags & BSF_INDIRECT ||
		       bfd_is_com_section (sec))
		      && ! bfd_is_und_section (sec))
d1814 6
a1819 3
		      size_t namelen;
		      struct orl *new_map;

a1847 1
		    }
@


1.2
log
@	* configure.in: Check whether getuid and getgid exist.
	* archive.c: Define getuid and getgid as macros if HAVE_GETUID or
	HAVE_GETGID are not defined, respectively.
	(bfd_write_armap): Don't special case on _WIN32 for getuid and
	getgid.
	* configure.host: Set ac_cv_func_get{ug}id for *-*-windows*.
	* configure, config.in: Rebuild.
@
text
@d1181 1
a1181 1
     bfd *abfd;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d1343 8
a1911 1
#ifndef _WIN32
a1913 4
#else
  sprintf (hdr.ar_uid, "%ld", (long) 666);
  sprintf (hdr.ar_gid, "%ld", (long) 42);
#endif
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

