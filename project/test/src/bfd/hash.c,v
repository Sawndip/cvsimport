head	1.36;
access;
symbols
	sid-snapshot-20180601:1.36
	sid-snapshot-20180501:1.36
	sid-snapshot-20180401:1.36
	sid-snapshot-20180301:1.36
	sid-snapshot-20180201:1.36
	sid-snapshot-20180101:1.36
	sid-snapshot-20171201:1.36
	sid-snapshot-20171101:1.36
	sid-snapshot-20171001:1.36
	sid-snapshot-20170901:1.36
	sid-snapshot-20170801:1.36
	sid-snapshot-20170701:1.36
	sid-snapshot-20170601:1.36
	sid-snapshot-20170501:1.36
	sid-snapshot-20170401:1.36
	sid-snapshot-20170301:1.36
	sid-snapshot-20170201:1.36
	sid-snapshot-20170101:1.36
	sid-snapshot-20161201:1.36
	sid-snapshot-20161101:1.36
	sid-snapshot-20160901:1.36
	sid-snapshot-20160801:1.36
	sid-snapshot-20160701:1.36
	sid-snapshot-20160601:1.36
	sid-snapshot-20160501:1.36
	sid-snapshot-20160401:1.36
	sid-snapshot-20160301:1.36
	sid-snapshot-20160201:1.36
	sid-snapshot-20160101:1.36
	sid-snapshot-20151201:1.36
	sid-snapshot-20151101:1.36
	sid-snapshot-20151001:1.36
	sid-snapshot-20150901:1.36
	sid-snapshot-20150801:1.36
	sid-snapshot-20150701:1.36
	sid-snapshot-20150601:1.36
	sid-snapshot-20150501:1.36
	sid-snapshot-20150401:1.36
	sid-snapshot-20150301:1.36
	sid-snapshot-20150201:1.36
	sid-snapshot-20150101:1.36
	sid-snapshot-20141201:1.36
	sid-snapshot-20141101:1.36
	sid-snapshot-20141001:1.36
	sid-snapshot-20140901:1.36
	sid-snapshot-20140801:1.36
	sid-snapshot-20140701:1.36
	sid-snapshot-20140601:1.36
	sid-snapshot-20140501:1.36
	sid-snapshot-20140401:1.36
	sid-snapshot-20140301:1.36
	sid-snapshot-20140201:1.36
	sid-snapshot-20140101:1.36
	sid-snapshot-20131201:1.36
	sid-snapshot-20131101:1.36
	sid-snapshot-20131001:1.36
	binutils-2_24-branch:1.36.0.2
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.31.6.1
	sid-snapshot-20130901:1.36
	gdb_7_6_1-2013-08-30-release:1.35
	sid-snapshot-20130801:1.36
	sid-snapshot-20130701:1.36
	sid-snapshot-20130601:1.35
	sid-snapshot-20130501:1.35
	gdb_7_6-2013-04-26-release:1.35
	sid-snapshot-20130401:1.35
	binutils-2_23_2:1.35
	gdb_7_6-branch:1.35.0.6
	gdb_7_6-2013-03-12-branchpoint:1.35
	sid-snapshot-20130301:1.35
	sid-snapshot-20130201:1.35
	sid-snapshot-20130101:1.35
	sid-snapshot-20121201:1.35
	gdb_7_5_1-2012-11-29-release:1.35
	binutils-2_23_1:1.35
	sid-snapshot-20121101:1.35
	binutils-2_23:1.35
	sid-snapshot-20121001:1.35
	sid-snapshot-20120901:1.35
	gdb_7_5-2012-08-17-release:1.35
	sid-snapshot-20120801:1.35
	binutils-2_23-branch:1.35.0.4
	binutils-2_23-branchpoint:1.35
	gdb_7_5-branch:1.35.0.2
	gdb_7_5-2012-07-18-branchpoint:1.35
	sid-snapshot-20120701:1.34
	sid-snapshot-20120601:1.34
	sid-snapshot-20120501:1.34
	binutils-2_22_branch:1.34.0.6
	gdb_7_4_1-2012-04-26-release:1.34
	sid-snapshot-20120401:1.34
	sid-snapshot-20120301:1.34
	sid-snapshot-20120201:1.34
	gdb_7_4-2012-01-24-release:1.34
	sid-snapshot-20120101:1.34
	gdb_7_4-branch:1.34.0.4
	gdb_7_4-2011-12-13-branchpoint:1.34
	sid-snapshot-20111201:1.34
	binutils-2_22:1.34
	sid-snapshot-20111101:1.34
	sid-snapshot-20111001:1.34
	binutils-2_22-branch:1.34.0.2
	binutils-2_22-branchpoint:1.34
	gdb_7_3_1-2011-09-04-release:1.32
	sid-snapshot-20110901:1.34
	sid-snapshot-20110801:1.34
	gdb_7_3-2011-07-26-release:1.32
	sid-snapshot-20110701:1.34
	sid-snapshot-20110601:1.33
	sid-snapshot-20110501:1.33
	gdb_7_3-branch:1.32.0.2
	gdb_7_3-2011-04-01-branchpoint:1.32
	sid-snapshot-20110401:1.32
	sid-snapshot-20110301:1.32
	sid-snapshot-20110201:1.32
	sid-snapshot-20110101:1.32
	binutils-2_21:1.31
	sid-snapshot-20101201:1.32
	binutils-2_21-branch:1.31.0.6
	binutils-2_21-branchpoint:1.31
	sid-snapshot-20101101:1.31
	sid-snapshot-20101001:1.31
	binutils-2_20_1:1.29.2.1
	gdb_7_2-2010-09-02-release:1.31
	sid-snapshot-20100901:1.31
	sid-snapshot-20100801:1.31
	gdb_7_2-branch:1.31.0.4
	gdb_7_2-2010-07-07-branchpoint:1.31
	sid-snapshot-20100701:1.31
	sid-snapshot-20100601:1.31
	sid-snapshot-20100501:1.31
	sid-snapshot-20100401:1.31
	gdb_7_1-2010-03-18-release:1.31
	sid-snapshot-20100301:1.31
	gdb_7_1-branch:1.31.0.2
	gdb_7_1-2010-02-18-branchpoint:1.31
	sid-snapshot-20100201:1.31
	sid-snapshot-20100101:1.31
	gdb_7_0_1-2009-12-22-release:1.30
	sid-snapshot-20091201:1.30
	sid-snapshot-20091101:1.30
	binutils-2_20:1.29.2.1
	gdb_7_0-2009-10-06-release:1.30
	sid-snapshot-20091001:1.30
	gdb_7_0-branch:1.30.0.2
	gdb_7_0-2009-09-16-branchpoint:1.30
	arc-sim-20090309:1.27
	binutils-arc-20081103-branch:1.27.0.26
	binutils-arc-20081103-branchpoint:1.27
	binutils-2_20-branch:1.29.0.2
	binutils-2_20-branchpoint:1.29
	sid-snapshot-20090901:1.28
	sid-snapshot-20090801:1.27
	msnyder-checkpoint-072509-branch:1.27.0.24
	msnyder-checkpoint-072509-branchpoint:1.27
	sid-snapshot-20090701:1.27
	dje-cgen-play1-branch:1.27.0.22
	dje-cgen-play1-branchpoint:1.27
	sid-snapshot-20090601:1.27
	sid-snapshot-20090501:1.27
	sid-snapshot-20090401:1.27
	arc-20081103-branch:1.27.0.20
	arc-20081103-branchpoint:1.27
	arc-insight_6_8-branch:1.27.0.18
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.16
	insight_6_8-branchpoint:1.27
	sid-snapshot-20090301:1.27
	binutils-2_19_1:1.27
	sid-snapshot-20090201:1.27
	sid-snapshot-20090101:1.27
	reverse-20081226-branch:1.27.0.14
	reverse-20081226-branchpoint:1.27
	sid-snapshot-20081201:1.27
	multiprocess-20081120-branch:1.27.0.12
	multiprocess-20081120-branchpoint:1.27
	sid-snapshot-20081101:1.27
	binutils-2_19:1.27
	sid-snapshot-20081001:1.27
	reverse-20080930-branch:1.27.0.10
	reverse-20080930-branchpoint:1.27
	binutils-2_19-branch:1.27.0.8
	binutils-2_19-branchpoint:1.27
	sid-snapshot-20080901:1.27
	sid-snapshot-20080801:1.27
	reverse-20080717-branch:1.27.0.6
	reverse-20080717-branchpoint:1.27
	sid-snapshot-20080701:1.27
	msnyder-reverse-20080609-branch:1.27.0.4
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.24.0.2
	drow-reverse-20070409-branchpoint:1.24
	sid-snapshot-20080601:1.27
	sid-snapshot-20080501:1.27
	sid-snapshot-20080403:1.27
	sid-snapshot-20080401:1.27
	gdb_6_8-2008-03-27-release:1.27
	sid-snapshot-20080301:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	sid-snapshot-20080201:1.27
	sid-snapshot-20080101:1.27
	sid-snapshot-20071201:1.27
	sid-snapshot-20071101:1.27
	gdb_6_7_1-2007-10-29-release:1.26
	gdb_6_7-2007-10-10-release:1.26
	sid-snapshot-20071001:1.27
	gdb_6_7-branch:1.26.0.4
	gdb_6_7-2007-09-07-branchpoint:1.26
	binutils-2_18:1.26
	binutils-2_18-branch:1.26.0.2
	binutils-2_18-branchpoint:1.26
	insight_6_6-20070208-release:1.23
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	gdb_6_6-2006-12-18-release:1.23
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	gdb_6_6-branch:1.23.0.2
	gdb_6_6-2006-11-15-branchpoint:1.23
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	insight_6_5-20061003-release:1.22
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.23
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.22.0.4
	gdb_6_5-2006-05-14-branchpoint:1.22
	binutils-csl-coldfire-4_1-10:1.20
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.22.0.2
	nickrob-async-20060513-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.21.0.2
	msnyder-reverse-20060502-branchpoint:1.21
	binutils-csl-wrs-linux-3_4_4-21:1.14
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.14
	readline_5_1-import-branch:1.20.0.8
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.20.0.6
	binutils-2_17-branchpoint:1.20
	gdb-csl-symbian-20060226-branch:1.19.0.6
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.20.0.4
	msnyder-reverse-20060331-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.2
	binutils-csl-2_17-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.18.0.10
	msnyder-fork-checkpoint-branchpoint:1.18
	gdb-csl-gxxpro-6_3-branch:1.18.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.6
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.4
	gdb-csl-arm-20051020-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.14.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	msnyder-tracepoint-checkpoint-branch:1.18.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.18
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.14
	csl-arm-20050325-branch:1.16.0.2
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.14.0.6
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.4
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.2
	gdb_6_3-20041019-branchpoint:1.14
	csl-arm-2004-q3:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.14
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.12
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.8
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.42
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.40
	cagney_x86i386-20030821-branch:1.9.0.38
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.36
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.9
	binutils-2_14:1.9
	cagney_convert-20030606-branch:1.9.0.32
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.30
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.26
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	binutils-2_14-branch:1.9.0.22
	binutils-2_14-branchpoint:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.20
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.18
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.16
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.14
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.12
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.10
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.8
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.6
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.4
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.2
	cagney-unwind-20030108-branchpoint:1.9
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.14
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.12
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.10
	gdb_5_3-branch:1.8.0.8
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.6
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.4
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	kseitz_interps-20020528-branch:1.7.0.2
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.6.0.8
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.36
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2013.06.24.14.28.17;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.13.14.22.49;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.03.16.16.32;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.20.12.52.14;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2010.11.08.02.48.54;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches
	1.31.6.1;
next	1.30;

1.30
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.19.12.08.34;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.20.01.38.38;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.06.03.04.12;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.03.04.20.52;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.01.19.36.27;	author dj;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.29.10.33.40;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.15.53.31;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.07.19.26;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.22.21.52.52;	author hp;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.22.16.14.41;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.05.18.09.38;	author roland;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.24.07.49.10;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.21.15.38.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.01.06.33.01;	author kazu;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2003.11.04.11.30.54;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.25.09.40.44;	author amodra;	state Exp;
branches
	1.8.12.1
	1.8.14.1;
next	1.7;

1.7
date	2002.05.17.09.52.04;	author nickc;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.23.20.27.54;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.11.19.49.36;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.04.13.25.22;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.31.6.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	;

1.29.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.11.8.1
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	;

1.8.12.1
date	2002.12.23.19.37.53;	author carlton;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.11.11.23.50.27;	author carlton;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.12.15.23.59.50;	author carlton;	state Exp;
branches;
next	;

1.8.14.1
date	2003.12.14.20.26.46;	author drow;	state Exp;
branches;
next	;

1.7.2.1
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.15.16.42.39;	author cagney;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.36
log
@	PR 15657
	* hash.c (_bfd_stringtab_add): Copy the string if COPY is true.
@
text
@/* hash.c -- hash table routines for BFD
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2010, 2011, 2012   Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "objalloc.h"
#include "libiberty.h"

/*
SECTION
	Hash Tables

@@cindex Hash tables
	BFD provides a simple set of hash table functions.  Routines
	are provided to initialize a hash table, to free a hash table,
	to look up a string in a hash table and optionally create an
	entry for it, and to traverse a hash table.  There is
	currently no routine to delete an string from a hash table.

	The basic hash table does not permit any data to be stored
	with a string.  However, a hash table is designed to present a
	base class from which other types of hash tables may be
	derived.  These derived types may store additional information
	with the string.  Hash tables were implemented in this way,
	rather than simply providing a data pointer in a hash table
	entry, because they were designed for use by the linker back
	ends.  The linker may create thousands of hash table entries,
	and the overhead of allocating private data and storing and
	following pointers becomes noticeable.

	The basic hash table code is in <<hash.c>>.

@@menu
@@* Creating and Freeing a Hash Table::
@@* Looking Up or Entering a String::
@@* Traversing a Hash Table::
@@* Deriving a New Hash Table Type::
@@end menu

INODE
Creating and Freeing a Hash Table, Looking Up or Entering a String, Hash Tables, Hash Tables
SUBSECTION
	Creating and freeing a hash table

@@findex bfd_hash_table_init
@@findex bfd_hash_table_init_n
	To create a hash table, create an instance of a <<struct
	bfd_hash_table>> (defined in <<bfd.h>>) and call
	<<bfd_hash_table_init>> (if you know approximately how many
	entries you will need, the function <<bfd_hash_table_init_n>>,
	which takes a @@var{size} argument, may be used).
	<<bfd_hash_table_init>> returns <<FALSE>> if some sort of
	error occurs.

@@findex bfd_hash_newfunc
	The function <<bfd_hash_table_init>> take as an argument a
	function to use to create new entries.  For a basic hash
	table, use the function <<bfd_hash_newfunc>>.  @@xref{Deriving
	a New Hash Table Type}, for why you would want to use a
	different value for this argument.

@@findex bfd_hash_allocate
	<<bfd_hash_table_init>> will create an objalloc which will be
	used to allocate new entries.  You may allocate memory on this
	objalloc using <<bfd_hash_allocate>>.

@@findex bfd_hash_table_free
	Use <<bfd_hash_table_free>> to free up all the memory that has
	been allocated for a hash table.  This will not free up the
	<<struct bfd_hash_table>> itself, which you must provide.

@@findex bfd_hash_set_default_size
	Use <<bfd_hash_set_default_size>> to set the default size of
	hash table to use.

INODE
Looking Up or Entering a String, Traversing a Hash Table, Creating and Freeing a Hash Table, Hash Tables
SUBSECTION
	Looking up or entering a string

@@findex bfd_hash_lookup
	The function <<bfd_hash_lookup>> is used both to look up a
	string in the hash table and to create a new entry.

	If the @@var{create} argument is <<FALSE>>, <<bfd_hash_lookup>>
	will look up a string.  If the string is found, it will
	returns a pointer to a <<struct bfd_hash_entry>>.  If the
	string is not found in the table <<bfd_hash_lookup>> will
	return <<NULL>>.  You should not modify any of the fields in
	the returns <<struct bfd_hash_entry>>.

	If the @@var{create} argument is <<TRUE>>, the string will be
	entered into the hash table if it is not already there.
	Either way a pointer to a <<struct bfd_hash_entry>> will be
	returned, either to the existing structure or to a newly
	created one.  In this case, a <<NULL>> return means that an
	error occurred.

	If the @@var{create} argument is <<TRUE>>, and a new entry is
	created, the @@var{copy} argument is used to decide whether to
	copy the string onto the hash table objalloc or not.  If
	@@var{copy} is passed as <<FALSE>>, you must be careful not to
	deallocate or modify the string as long as the hash table
	exists.

INODE
Traversing a Hash Table, Deriving a New Hash Table Type, Looking Up or Entering a String, Hash Tables
SUBSECTION
	Traversing a hash table

@@findex bfd_hash_traverse
	The function <<bfd_hash_traverse>> may be used to traverse a
	hash table, calling a function on each element.  The traversal
	is done in a random order.

	<<bfd_hash_traverse>> takes as arguments a function and a
	generic <<void *>> pointer.  The function is called with a
	hash table entry (a <<struct bfd_hash_entry *>>) and the
	generic pointer passed to <<bfd_hash_traverse>>.  The function
	must return a <<boolean>> value, which indicates whether to
	continue traversing the hash table.  If the function returns
	<<FALSE>>, <<bfd_hash_traverse>> will stop the traversal and
	return immediately.

INODE
Deriving a New Hash Table Type, , Traversing a Hash Table, Hash Tables
SUBSECTION
	Deriving a new hash table type

	Many uses of hash tables want to store additional information
	which each entry in the hash table.  Some also find it
	convenient to store additional information with the hash table
	itself.  This may be done using a derived hash table.

	Since C is not an object oriented language, creating a derived
	hash table requires sticking together some boilerplate
	routines with a few differences specific to the type of hash
	table you want to create.

	An example of a derived hash table is the linker hash table.
	The structures for this are defined in <<bfdlink.h>>.  The
	functions are in <<linker.c>>.

	You may also derive a hash table from an already derived hash
	table.  For example, the a.out linker backend code uses a hash
	table derived from the linker hash table.

@@menu
@@* Define the Derived Structures::
@@* Write the Derived Creation Routine::
@@* Write Other Derived Routines::
@@end menu

INODE
Define the Derived Structures, Write the Derived Creation Routine, Deriving a New Hash Table Type, Deriving a New Hash Table Type
SUBSUBSECTION
	Define the derived structures

	You must define a structure for an entry in the hash table,
	and a structure for the hash table itself.

	The first field in the structure for an entry in the hash
	table must be of the type used for an entry in the hash table
	you are deriving from.  If you are deriving from a basic hash
	table this is <<struct bfd_hash_entry>>, which is defined in
	<<bfd.h>>.  The first field in the structure for the hash
	table itself must be of the type of the hash table you are
	deriving from itself.  If you are deriving from a basic hash
	table, this is <<struct bfd_hash_table>>.

	For example, the linker hash table defines <<struct
	bfd_link_hash_entry>> (in <<bfdlink.h>>).  The first field,
	<<root>>, is of type <<struct bfd_hash_entry>>.  Similarly,
	the first field in <<struct bfd_link_hash_table>>, <<table>>,
	is of type <<struct bfd_hash_table>>.

INODE
Write the Derived Creation Routine, Write Other Derived Routines, Define the Derived Structures, Deriving a New Hash Table Type
SUBSUBSECTION
	Write the derived creation routine

	You must write a routine which will create and initialize an
	entry in the hash table.  This routine is passed as the
	function argument to <<bfd_hash_table_init>>.

	In order to permit other hash tables to be derived from the
	hash table you are creating, this routine must be written in a
	standard way.

	The first argument to the creation routine is a pointer to a
	hash table entry.  This may be <<NULL>>, in which case the
	routine should allocate the right amount of space.  Otherwise
	the space has already been allocated by a hash table type
	derived from this one.

	After allocating space, the creation routine must call the
	creation routine of the hash table type it is derived from,
	passing in a pointer to the space it just allocated.  This
	will initialize any fields used by the base hash table.

	Finally the creation routine must initialize any local fields
	for the new hash table type.

	Here is a boilerplate example of a creation routine.
	@@var{function_name} is the name of the routine.
	@@var{entry_type} is the type of an entry in the hash table you
	are creating.  @@var{base_newfunc} is the name of the creation
	routine of the hash table type your hash table is derived
	from.

EXAMPLE

.struct bfd_hash_entry *
.@@var{function_name} (struct bfd_hash_entry *entry,
.                     struct bfd_hash_table *table,
.                     const char *string)
.{
.  struct @@var{entry_type} *ret = (@@var{entry_type} *) entry;
.
. {* Allocate the structure if it has not already been allocated by a
.    derived class.  *}
.  if (ret == NULL)
.    {
.      ret = bfd_hash_allocate (table, sizeof (* ret));
.      if (ret == NULL)
.        return NULL;
.    }
.
. {* Call the allocation method of the base class.  *}
.  ret = ((@@var{entry_type} *)
.	 @@var{base_newfunc} ((struct bfd_hash_entry *) ret, table, string));
.
. {* Initialize the local fields here.  *}
.
.  return (struct bfd_hash_entry *) ret;
.}

DESCRIPTION
	The creation routine for the linker hash table, which is in
	<<linker.c>>, looks just like this example.
	@@var{function_name} is <<_bfd_link_hash_newfunc>>.
	@@var{entry_type} is <<struct bfd_link_hash_entry>>.
	@@var{base_newfunc} is <<bfd_hash_newfunc>>, the creation
	routine for a basic hash table.

	<<_bfd_link_hash_newfunc>> also initializes the local fields
	in a linker hash table entry: <<type>>, <<written>> and
	<<next>>.

INODE
Write Other Derived Routines, , Write the Derived Creation Routine, Deriving a New Hash Table Type
SUBSUBSECTION
	Write other derived routines

	You will want to write other routines for your new hash table,
	as well.

	You will want an initialization routine which calls the
	initialization routine of the hash table you are deriving from
	and initializes any other local fields.  For the linker hash
	table, this is <<_bfd_link_hash_table_init>> in <<linker.c>>.

	You will want a lookup routine which calls the lookup routine
	of the hash table you are deriving from and casts the result.
	The linker hash table uses <<bfd_link_hash_lookup>> in
	<<linker.c>> (this actually takes an additional argument which
	it uses to decide how to return the looked up value).

	You may want a traversal routine.  This should just call the
	traversal routine of the hash table you are deriving from with
	appropriate casts.  The linker hash table uses
	<<bfd_link_hash_traverse>> in <<linker.c>>.

	These routines may simply be defined as macros.  For example,
	the a.out backend linker hash table, which is derived from the
	linker hash table, uses macros for the lookup and traversal
	routines.  These are <<aout_link_hash_lookup>> and
	<<aout_link_hash_traverse>> in aoutx.h.
*/

/* The default number of entries to use when creating a hash table.  */
#define DEFAULT_SIZE 4051

/* The following function returns a nearest prime number which is
   greater than N, and near a power of two.  Copied from libiberty.
   Returns zero for ridiculously large N to signify an error.  */

static unsigned long
higher_prime_number (unsigned long n)
{
  /* These are primes that are near, but slightly smaller than, a
     power of two.  */
  static const unsigned long primes[] =
    {
      (unsigned long) 31,
      (unsigned long) 61,
      (unsigned long) 127,
      (unsigned long) 251,
      (unsigned long) 509,
      (unsigned long) 1021,
      (unsigned long) 2039,
      (unsigned long) 4093,
      (unsigned long) 8191,
      (unsigned long) 16381,
      (unsigned long) 32749,
      (unsigned long) 65521,
      (unsigned long) 131071,
      (unsigned long) 262139,
      (unsigned long) 524287,
      (unsigned long) 1048573,
      (unsigned long) 2097143,
      (unsigned long) 4194301,
      (unsigned long) 8388593,
      (unsigned long) 16777213,
      (unsigned long) 33554393,
      (unsigned long) 67108859,
      (unsigned long) 134217689,
      (unsigned long) 268435399,
      (unsigned long) 536870909,
      (unsigned long) 1073741789,
      (unsigned long) 2147483647,
					/* 4294967291L */
      ((unsigned long) 2147483647) + ((unsigned long) 2147483644),
  };

  const unsigned long *low = &primes[0];
  const unsigned long *high = &primes[sizeof (primes) / sizeof (primes[0])];

  while (low != high)
    {
      const unsigned long *mid = low + (high - low) / 2;
      if (n >= *mid)
	low = mid + 1;
      else
	high = mid;
    }

  if (n >= *low)
    return 0;

  return *low;
}

static unsigned long bfd_default_hash_table_size = DEFAULT_SIZE;

/* Create a new hash table, given a number of entries.  */

bfd_boolean
bfd_hash_table_init_n (struct bfd_hash_table *table,
		       struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
							  struct bfd_hash_table *,
							  const char *),
		       unsigned int entsize,
		       unsigned int size)
{
  unsigned long alloc;

  alloc = size;
  alloc *= sizeof (struct bfd_hash_entry *);
  if (alloc / sizeof (struct bfd_hash_entry *) != size)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  table->memory = (void *) objalloc_create ();
  if (table->memory == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  table->table = (struct bfd_hash_entry **)
      objalloc_alloc ((struct objalloc *) table->memory, alloc);
  if (table->table == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  memset ((void *) table->table, 0, alloc);
  table->size = size;
  table->entsize = entsize;
  table->count = 0;
  table->frozen = 0;
  table->newfunc = newfunc;
  return TRUE;
}

/* Create a new hash table with the default number of entries.  */

bfd_boolean
bfd_hash_table_init (struct bfd_hash_table *table,
		     struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
							struct bfd_hash_table *,
							const char *),
		     unsigned int entsize)
{
  return bfd_hash_table_init_n (table, newfunc, entsize,
				bfd_default_hash_table_size);
}

/* Free a hash table.  */

void
bfd_hash_table_free (struct bfd_hash_table *table)
{
  objalloc_free ((struct objalloc *) table->memory);
  table->memory = NULL;
}

static inline unsigned long
bfd_hash_hash (const char *string, unsigned int *lenp)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int len;
  unsigned int c;

  hash = 0;
  len = 0;
  s = (const unsigned char *) string;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
    }
  len = (s - (const unsigned char *) string) - 1;
  hash += len + (len << 17);
  hash ^= hash >> 2;
  if (lenp != NULL)
    *lenp = len;
  return hash;
}

/* Look up a string in a hash table.  */

struct bfd_hash_entry *
bfd_hash_lookup (struct bfd_hash_table *table,
		 const char *string,
		 bfd_boolean create,
		 bfd_boolean copy)
{
  unsigned long hash;
  struct bfd_hash_entry *hashp;
  unsigned int len;
  unsigned int _index;

  hash = bfd_hash_hash (string, &len);
  _index = hash % table->size;
  for (hashp = table->table[_index];
       hashp != NULL;
       hashp = hashp->next)
    {
      if (hashp->hash == hash
	  && strcmp (hashp->string, string) == 0)
	return hashp;
    }

  if (! create)
    return NULL;

  if (copy)
    {
      char *new_string;

      new_string = (char *) objalloc_alloc ((struct objalloc *) table->memory,
                                            len + 1);
      if (!new_string)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
      memcpy (new_string, string, len + 1);
      string = new_string;
    }

  return bfd_hash_insert (table, string, hash);
}

/* Insert an entry in a hash table.  */

struct bfd_hash_entry *
bfd_hash_insert (struct bfd_hash_table *table,
		 const char *string,
		 unsigned long hash)
{
  struct bfd_hash_entry *hashp;
  unsigned int _index;

  hashp = (*table->newfunc) (NULL, table, string);
  if (hashp == NULL)
    return NULL;
  hashp->string = string;
  hashp->hash = hash;
  _index = hash % table->size;
  hashp->next = table->table[_index];
  table->table[_index] = hashp;
  table->count++;

  if (!table->frozen && table->count > table->size * 3 / 4)
    {
      unsigned long newsize = higher_prime_number (table->size);
      struct bfd_hash_entry **newtable;
      unsigned int hi;
      unsigned long alloc = newsize * sizeof (struct bfd_hash_entry *);

      /* If we can't find a higher prime, or we can't possibly alloc
	 that much memory, don't try to grow the table.  */
      if (newsize == 0 || alloc / sizeof (struct bfd_hash_entry *) != newsize)
	{
	  table->frozen = 1;
	  return hashp;
	}

      newtable = ((struct bfd_hash_entry **)
		  objalloc_alloc ((struct objalloc *) table->memory, alloc));
      if (newtable == NULL)
	{
	  table->frozen = 1;
	  return hashp;
	}
      memset (newtable, 0, alloc);

      for (hi = 0; hi < table->size; hi ++)
	while (table->table[hi])
	  {
	    struct bfd_hash_entry *chain = table->table[hi];
	    struct bfd_hash_entry *chain_end = chain;

	    while (chain_end->next && chain_end->next->hash == chain->hash)
	      chain_end = chain_end->next;

	    table->table[hi] = chain_end->next;
	    _index = chain->hash % newsize;
	    chain_end->next = newtable[_index];
	    newtable[_index] = chain;
	  }
      table->table = newtable;
      table->size = newsize;
    }

  return hashp;
}

/* Rename an entry in a hash table.  */

void
bfd_hash_rename (struct bfd_hash_table *table,
		 const char *string,
		 struct bfd_hash_entry *ent)
{
  unsigned int _index;
  struct bfd_hash_entry **pph;

  _index = ent->hash % table->size;
  for (pph = &table->table[_index]; *pph != NULL; pph = &(*pph)->next)
    if (*pph == ent)
      break;
  if (*pph == NULL)
    abort ();

  *pph = ent->next;
  ent->string = string;
  ent->hash = bfd_hash_hash (string, NULL);
  _index = ent->hash % table->size;
  ent->next = table->table[_index];
  table->table[_index] = ent;
}

/* Replace an entry in a hash table.  */

void
bfd_hash_replace (struct bfd_hash_table *table,
		  struct bfd_hash_entry *old,
		  struct bfd_hash_entry *nw)
{
  unsigned int _index;
  struct bfd_hash_entry **pph;

  _index = old->hash % table->size;
  for (pph = &table->table[_index];
       (*pph) != NULL;
       pph = &(*pph)->next)
    {
      if (*pph == old)
	{
	  *pph = nw;
	  return;
	}
    }

  abort ();
}

/* Allocate space in a hash table.  */

void *
bfd_hash_allocate (struct bfd_hash_table *table,
		   unsigned int size)
{
  void * ret;

  ret = objalloc_alloc ((struct objalloc *) table->memory, size);
  if (ret == NULL && size != 0)
    bfd_set_error (bfd_error_no_memory);
  return ret;
}

/* Base method for creating a new hash table entry.  */

struct bfd_hash_entry *
bfd_hash_newfunc (struct bfd_hash_entry *entry,
		  struct bfd_hash_table *table,
		  const char *string ATTRIBUTE_UNUSED)
{
  if (entry == NULL)
    entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
                                                         sizeof (* entry));
  return entry;
}

/* Traverse a hash table.  */

void
bfd_hash_traverse (struct bfd_hash_table *table,
		   bfd_boolean (*func) (struct bfd_hash_entry *, void *),
		   void * info)
{
  unsigned int i;

  table->frozen = 1;
  for (i = 0; i < table->size; i++)
    {
      struct bfd_hash_entry *p;

      for (p = table->table[i]; p != NULL; p = p->next)
	if (! (*func) (p, info))
	  goto out;
    }
 out:
  table->frozen = 0;
}

unsigned long
bfd_hash_set_default_size (unsigned long hash_size)
{
  /* Extend this prime list if you want more granularity of hash table size.  */
  static const unsigned long hash_size_primes[] =
    {
      31, 61, 127, 251, 509, 1021, 2039, 4091, 8191, 16381, 32749, 65537
    };
  unsigned int _index;

  /* Work out best prime number near the hash_size.  */
  for (_index = 0; _index < ARRAY_SIZE (hash_size_primes) - 1; ++_index)
    if (hash_size <= hash_size_primes[_index])
      break;

  bfd_default_hash_table_size = hash_size_primes[_index];
  return bfd_default_hash_table_size;
}

/* A few different object file formats (a.out, COFF, ELF) use a string
   table.  These functions support adding strings to a string table,
   returning the byte offset, and writing out the table.

   Possible improvements:
   + look for strings matching trailing substrings of other strings
   + better data structures?  balanced trees?
   + look at reducing memory use elsewhere -- maybe if we didn't have
     to construct the entire symbol table at once, we could get by
     with smaller amounts of VM?  (What effect does that have on the
     string table reductions?)  */

/* An entry in the strtab hash table.  */

struct strtab_hash_entry
{
  struct bfd_hash_entry root;
  /* Index in string table.  */
  bfd_size_type index;
  /* Next string in strtab.  */
  struct strtab_hash_entry *next;
};

/* The strtab hash table.  */

struct bfd_strtab_hash
{
  struct bfd_hash_table table;
  /* Size of strtab--also next available index.  */
  bfd_size_type size;
  /* First string in strtab.  */
  struct strtab_hash_entry *first;
  /* Last string in strtab.  */
  struct strtab_hash_entry *last;
  /* Whether to precede strings with a two byte length, as in the
     XCOFF .debug section.  */
  bfd_boolean xcoff;
};

/* Routine to create an entry in a strtab.  */

static struct bfd_hash_entry *
strtab_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table,
		     const char *string)
{
  struct strtab_hash_entry *ret = (struct strtab_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct strtab_hash_entry *) bfd_hash_allocate (table,
                                                          sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = (struct strtab_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string);

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->index = (bfd_size_type) -1;
      ret->next = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Look up an entry in an strtab.  */

#define strtab_hash_lookup(t, string, create, copy) \
  ((struct strtab_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))

/* Create a new strtab.  */

struct bfd_strtab_hash *
_bfd_stringtab_init (void)
{
  struct bfd_strtab_hash *table;
  bfd_size_type amt = sizeof (* table);

  table = (struct bfd_strtab_hash *) bfd_malloc (amt);
  if (table == NULL)
    return NULL;

  if (!bfd_hash_table_init (&table->table, strtab_hash_newfunc,
			    sizeof (struct strtab_hash_entry)))
    {
      free (table);
      return NULL;
    }

  table->size = 0;
  table->first = NULL;
  table->last = NULL;
  table->xcoff = FALSE;

  return table;
}

/* Create a new strtab in which the strings are output in the format
   used in the XCOFF .debug section: a two byte length precedes each
   string.  */

struct bfd_strtab_hash *
_bfd_xcoff_stringtab_init (void)
{
  struct bfd_strtab_hash *ret;

  ret = _bfd_stringtab_init ();
  if (ret != NULL)
    ret->xcoff = TRUE;
  return ret;
}

/* Free a strtab.  */

void
_bfd_stringtab_free (struct bfd_strtab_hash *table)
{
  bfd_hash_table_free (&table->table);
  free (table);
}

/* Get the index of a string in a strtab, adding it if it is not
   already present.  If HASH is FALSE, we don't really use the hash
   table, and we don't eliminate duplicate strings.  If COPY is true
   then store a copy of STR if creating a new entry.  */

bfd_size_type
_bfd_stringtab_add (struct bfd_strtab_hash *tab,
		    const char *str,
		    bfd_boolean hash,
		    bfd_boolean copy)
{
  struct strtab_hash_entry *entry;

  if (hash)
    {
      entry = strtab_hash_lookup (tab, str, TRUE, copy);
      if (entry == NULL)
	return (bfd_size_type) -1;
    }
  else
    {
      entry = (struct strtab_hash_entry *) bfd_hash_allocate (&tab->table,
                                                              sizeof (* entry));
      if (entry == NULL)
	return (bfd_size_type) -1;
      if (! copy)
	entry->root.string = str;
      else
	{
	  size_t len = strlen (str) + 1;
	  char *n;

	  n = (char *) bfd_hash_allocate (&tab->table, len);
	  if (n == NULL)
	    return (bfd_size_type) -1;
          memcpy (n, str, len);
	  entry->root.string = n;
	}
      entry->index = (bfd_size_type) -1;
      entry->next = NULL;
    }

  if (entry->index == (bfd_size_type) -1)
    {
      entry->index = tab->size;
      tab->size += strlen (str) + 1;
      if (tab->xcoff)
	{
	  entry->index += 2;
	  tab->size += 2;
	}
      if (tab->first == NULL)
	tab->first = entry;
      else
	tab->last->next = entry;
      tab->last = entry;
    }

  return entry->index;
}

/* Get the number of bytes in a strtab.  */

bfd_size_type
_bfd_stringtab_size (struct bfd_strtab_hash *tab)
{
  return tab->size;
}

/* Write out a strtab.  ABFD must already be at the right location in
   the file.  */

bfd_boolean
_bfd_stringtab_emit (bfd *abfd, struct bfd_strtab_hash *tab)
{
  bfd_boolean xcoff;
  struct strtab_hash_entry *entry;

  xcoff = tab->xcoff;

  for (entry = tab->first; entry != NULL; entry = entry->next)
    {
      const char *str;
      size_t len;

      str = entry->root.string;
      len = strlen (str) + 1;

      if (xcoff)
	{
	  bfd_byte buf[2];

	  /* The output length includes the null byte.  */
	  bfd_put_16 (abfd, (bfd_vma) len, buf);
	  if (bfd_bwrite ((void *) buf, (bfd_size_type) 2, abfd) != 2)
	    return FALSE;
	}

      if (bfd_bwrite ((void *) str, (bfd_size_type) len, abfd) != len)
	return FALSE;
    }

  return TRUE;
}
@


1.35
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d811 2
a812 1
   table, and we don't eliminate duplicate strings.  */
d838 1
d841 1
a841 1
	  n = (char *) bfd_hash_allocate (&tab->table, strlen (str) + 1);
d844 1
@


1.34
log
@	PR ld/12682
	* hash.c (higher_primer_number): Add more, small, prime numbers.
	(bfd_hash_set_default_size): Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010, 2011  Free Software Foundation, Inc.
d541 1
a541 1
      memset ((PTR) newtable, 0, alloc);
@


1.33
log
@bfd/
	* hash.c (bfd_default_hash_table_size): Make it an unsigned long.
	(bfd_hash_table_init_n): Overflow checking.
	(bfd_hash_set_default_size): Return current size.  Take unsigned long
	arg.  Add 65537 to hash_size primes.
	* bfd-in.h (bfd_hash_set_default_size): Update prototype.
	* bfd-in2.h: Regenerate.
gas/
	* hash.c (set_gas_hash_table_size): Use bfd_hash_set_default_size.
	(hash_new_sized): New function, split out from..
	(hash_new): ..here.
ld/
	* ld.h (ld_config_type <hash_table_size>): Make it an unsigned long.
@
text
@d313 29
a341 20
  static const unsigned long primes[] = {
    (unsigned long) 127,
    (unsigned long) 2039,
    (unsigned long) 32749,
    (unsigned long) 65521,
    (unsigned long) 131071,
    (unsigned long) 262139,
    (unsigned long) 524287,
    (unsigned long) 1048573,
    (unsigned long) 2097143,
    (unsigned long) 4194301,
    (unsigned long) 8388593,
    (unsigned long) 16777213,
    (unsigned long) 33554393,
    (unsigned long) 67108859,
    (unsigned long) 134217689,
    (unsigned long) 268435399,
    (unsigned long) 536870909,
    (unsigned long) 1073741789,
    (unsigned long) 2147483647,
d343 1
a343 1
    ((unsigned long) 2147483647) + ((unsigned long) 2147483644),
d669 1
a669 1
      251, 509, 1021, 2039, 4051, 8599, 16699, 32749, 65537
@


1.32
log
@bfd/
	* hash.c (bfd_hash_hash): Extract from..
	(bfd_hash_lookup): ..here.
	(bfd_hash_rename): New function.
	* section.c (bfd_rename_section): New function.
	* bfd-in.h (bfd_hash_rename): Declare.
	* bfd-in2.h: Regenerate.
	* elf.c (_bfd_elf_make_section_from_shdr): Rename input sections
	when compressing or decompressing.  Don't assert name match.
	* elf64-hppa.c (get_reloc_section): Don't assert name match.
	* elfxx-ia64.c (get_reloc_section): Likewise.
binutils/
	* objcopy.c (copy_main): No need to rename sections when compressing
	or decompressing.
binutils/testsuite/
	* binutils-all/objdump.W: Adjust expected result for debug section
	rename.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010 Free Software Foundation, Inc.
d355 1
a355 1
static size_t bfd_default_hash_table_size = DEFAULT_SIZE;
d367 1
a367 1
  unsigned int alloc;
d369 7
a375 1
  alloc = size * sizeof (struct bfd_hash_entry *);
d654 2
a655 2
void
bfd_hash_set_default_size (bfd_size_type hash_size)
d658 1
a658 1
  static const bfd_size_type hash_size_primes[] =
d660 1
a660 1
      251, 509, 1021, 2039, 4051, 8599, 16699, 32749
d662 1
a662 1
  size_t _index;
d670 1
@


1.31
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2006, 2007, 2009 Free Software Foundation, Inc.
d415 2
a416 7
/* Look up a string in a hash table.  */

struct bfd_hash_entry *
bfd_hash_lookup (struct bfd_hash_table *table,
		 const char *string,
		 bfd_boolean create,
		 bfd_boolean copy)
d420 1
a421 3
  struct bfd_hash_entry *hashp;
  unsigned int len;
  unsigned int _index;
d434 17
d452 1
d549 25
@


1.31.6.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010 Free Software Foundation, Inc.
d415 7
a421 2
static inline unsigned long
bfd_hash_hash (const char *string, unsigned int *lenp)
d425 2
d428 1
a428 1
  unsigned int c;
a440 17
  if (lenp != NULL)
    *lenp = len;
  return hash;
}

/* Look up a string in a hash table.  */

struct bfd_hash_entry *
bfd_hash_lookup (struct bfd_hash_table *table,
		 const char *string,
		 bfd_boolean create,
		 bfd_boolean copy)
{
  unsigned long hash;
  struct bfd_hash_entry *hashp;
  unsigned int len;
  unsigned int _index;
a441 1
  hash = bfd_hash_hash (string, &len);
a537 25
/* Rename an entry in a hash table.  */

void
bfd_hash_rename (struct bfd_hash_table *table,
		 const char *string,
		 struct bfd_hash_entry *ent)
{
  unsigned int _index;
  struct bfd_hash_entry **pph;

  _index = ent->hash % table->size;
  for (pph = &table->table[_index]; *pph != NULL; pph = &(*pph)->next)
    if (*pph == ent)
      break;
  if (*pph == NULL)
    abort ();

  *pph = ent->next;
  ent->string = string;
  ent->hash = bfd_hash_hash (string, NULL);
  _index = ent->hash % table->size;
  ent->next = table->table[_index];
  table->table[_index] = ent;
}

@


1.30
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d428 1
a428 1
  unsigned int index;
d442 2
a443 2
  index = hash % table->size;
  for (hashp = table->table[index];
d481 1
a481 1
  unsigned int index;
d488 3
a490 3
  index = hash % table->size;
  hashp->next = table->table[index];
  table->table[index] = hashp;
d527 3
a529 3
	    index = chain->hash % newsize;
	    chain_end->next = newtable[index];
	    newtable[index] = chain;
d545 1
a545 1
  unsigned int index;
d548 2
a549 2
  index = old->hash % table->size;
  for (pph = &table->table[index];
d620 1
a620 1
  size_t index;
d623 2
a624 2
  for (index = 0; index < ARRAY_SIZE (hash_size_primes) - 1; ++index)
    if (hash_size <= hash_size_primes[index])
d627 1
a627 1
  bfd_default_hash_table_size = hash_size_primes[index];
@


1.29
log
@update copyright dates
@
text
@d377 2
a378 1
  table->table = objalloc_alloc ((struct objalloc *) table->memory, alloc);
d411 1
a411 1
  objalloc_free (table->memory);
d585 2
a586 1
    entry = bfd_hash_allocate (table, sizeof (* entry));
d681 2
a682 1
    ret = bfd_hash_allocate (table, sizeof (* ret));
d714 1
a714 1
  table = bfd_malloc (amt);
d777 2
a778 1
      entry = bfd_hash_allocate (&tab->table, sizeof (* entry));
d787 1
a787 1
	  n = bfd_hash_allocate (&tab->table, strlen (str) + 1);
@


1.29.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d377 1
a377 2
  table->table = (struct bfd_hash_entry **)
      objalloc_alloc ((struct objalloc *) table->memory, alloc);
d410 1
a410 1
  objalloc_free ((struct objalloc *) table->memory);
d584 1
a584 2
    entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
                                                         sizeof (* entry));
d679 1
a679 2
    ret = (struct strtab_hash_entry *) bfd_hash_allocate (table,
                                                          sizeof (* ret));
d711 1
a711 1
  table = (struct bfd_strtab_hash *) bfd_malloc (amt);
d774 1
a774 2
      entry = (struct strtab_hash_entry *) bfd_hash_allocate (&tab->table,
                                                              sizeof (* entry));
d783 1
a783 1
	  n = (char *) bfd_hash_allocate (&tab->table, strlen (str) + 1);
@


1.28
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
@


1.27
log
@	* bfd-in.h (bfd_hash_insert): Declare.
	* bfd-in2.h: Regenerate.
	* hash.c (bfd_hash_insert): New function.  Split out from..
	(bfd_hash_lookup): ..here.
	* merge.c (sec_merge_hash_lookup): Use bfd_hash_insert.
@
text
@d456 1
a456 1
      char *new;
d458 3
a460 2
      new = objalloc_alloc ((struct objalloc *) table->memory, len + 1);
      if (!new)
d465 2
a466 2
      memcpy (new, string, len + 1);
      string = new;
@


1.26
log
@Switch sources over to use the GPL version 3
@
text
@a453 3
  hashp = (*table->newfunc) (NULL, table, string);
  if (hashp == NULL)
    return NULL;
d467 17
d486 1
d508 5
a519 1
	    int index;
@


1.25
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.24
log
@	PR 3532
	* bfd-in.h (struct bfd_hash_table): Reorganize.  Add "frozen".
	* hash.c (bfd_hash_table_init_n): Init frozen.
	(bfd_hash_lookup): Don't grow if frozen.
	(bfd_hash_traverse): Freeze hash table during traversal.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@


1.23
log
@	* hash.c (bfd_hash_lookup): Correct stray line.
@
text
@d386 1
d475 1
a475 1
  if (table->count > table->size * 3 / 4)
d486 1
a486 2
	  /* Lie.  Stops us trying to grow again for a while.  */
	  table->count = 0;
d576 1
d583 1
a583 1
	  return;
d585 2
@


1.22
log
@	* hash.c (DEFAULT_SIZE): Revert last change.
	(higher_prime_number): Correct test for no larger prime.  Don't
	abort on error, instead return 0.  Depopulate primes[].
	(bfd_hash_lookup): If we overflow size, refuse to grow table.
@
text
@a457 1
  table->count ++;
d472 1
@


1.21
log
@* bfd-in.h (bfd_hash_table): Add count field.
* bfd-in2.h: Regenerate.
* hash.c (higher_prime_number): New.
(bfd_hash_table_inint_n): Init count field.
(bfd_hash_lookup): Grow table as needed.
@
text
@d301 1
a301 1
#define DEFAULT_SIZE (4093)
d304 2
a305 1
   greater than N, and near a power of two.  Copied from libiberty.  */
a312 4
    (unsigned long) 7,
    (unsigned long) 13,
    (unsigned long) 31,
    (unsigned long) 61,
a313 3
    (unsigned long) 251,
    (unsigned long) 509,
    (unsigned long) 1021,
a314 3
    (unsigned long) 4093,
    (unsigned long) 8191,
    (unsigned long) 16381,
d337 1
a337 1
  const unsigned long *high = &primes[sizeof(primes) / sizeof(primes[0])];
d348 2
a349 6
  /* If we've run out of primes, abort.  */
  if (n > *low)
    {
      fprintf (stderr, "Cannot find prime bigger than %lu\n", n);
      abort ();
    }
d476 1
a476 1
      int newsize = higher_prime_number (table->size);
d479 1
a479 1
      unsigned int alloc;
d481 8
a488 1
      alloc = newsize * sizeof (struct bfd_hash_entry *);
d502 1
a502 1
	      chain_end = chain_end->next; 
@


1.20
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d301 66
a366 1
#define DEFAULT_SIZE 4051
d398 1
d471 1
d487 32
@


1.19
log
@(bfd_hash_set_default_size): Add more entries to the hash_size_primes table.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d311 1
d332 1
d343 2
a344 1
							const char *))
d346 2
a347 1
  return bfd_hash_table_init_n (table, newfunc, bfd_default_hash_table_size);
d598 2
a599 1
  if (! bfd_hash_table_init (& table->table, strtab_hash_newfunc))
@


1.18
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d495 1
a495 1
      1021, 4051, 8599, 16699
@


1.17
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.16
log
@	* hash.c (strtab_hash_newfunc): Fix typo in allocated size.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.15
log
@Convert to ISO C90 formatting.
@
text
@d558 1
a558 1
    ret = bfd_hash_allocate (table, sizeof (* entry));
@


1.14
log
@2004-10-04  Roland McGrath  <roland@@redhat.com>

	* hash.c (bfd_hash_set_default_size): Use const for table.
	Use size_t instead of int for variable compared to sizeof results.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2004
d233 3
a235 4
.@@var{function_name} (entry, table, string)
.     struct bfd_hash_entry *entry;
.     struct bfd_hash_table *table;
.     const char *string;
d241 1
a241 1
.  if (ret == (@@var{entry_type} *) NULL)
d243 2
a244 3
.      ret = ((@@var{entry_type} *)
.	      bfd_hash_allocate (table, sizeof (@@var{entry_type})));
.      if (ret == (@@var{entry_type} *) NULL)
d307 5
a311 6
bfd_hash_table_init_n (table, newfunc, size)
     struct bfd_hash_table *table;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
     unsigned int size;
d317 1
a317 1
  table->memory = (PTR) objalloc_create ();
d323 1
a323 2
  table->table = ((struct bfd_hash_entry **)
		  objalloc_alloc ((struct objalloc *) table->memory, alloc));
d329 1
a329 1
  memset ((PTR) table->table, 0, alloc);
d338 4
a341 5
bfd_hash_table_init (table, newfunc)
     struct bfd_hash_table *table;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d349 1
a349 2
bfd_hash_table_free (table)
     struct bfd_hash_table *table;
d351 1
a351 1
  objalloc_free ((struct objalloc *) table->memory);
d358 8
a365 9
bfd_hash_lookup (table, string, create, copy)
     struct bfd_hash_table *table;
     const char *string;
     bfd_boolean create;
     bfd_boolean copy;
{
  register const unsigned char *s;
  register unsigned long hash;
  register unsigned int c;
d384 1
a384 1
       hashp != (struct bfd_hash_entry *) NULL;
d393 1
a393 1
    return (struct bfd_hash_entry *) NULL;
d395 3
a397 3
  hashp = (*table->newfunc) ((struct bfd_hash_entry *) NULL, table, string);
  if (hashp == (struct bfd_hash_entry *) NULL)
    return (struct bfd_hash_entry *) NULL;
d402 1
a402 2
      new = (char *) objalloc_alloc ((struct objalloc *) table->memory,
				     len + 1);
d406 1
a406 1
	  return (struct bfd_hash_entry *) NULL;
d422 3
a424 4
bfd_hash_replace (table, old, nw)
     struct bfd_hash_table *table;
     struct bfd_hash_entry *old;
     struct bfd_hash_entry *nw;
d431 1
a431 1
       (*pph) != (struct bfd_hash_entry *) NULL;
a443 14
/* Base method for creating a new hash table entry.  */

struct bfd_hash_entry *
bfd_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string ATTRIBUTE_UNUSED;
{
  if (entry == (struct bfd_hash_entry *) NULL)
    entry = ((struct bfd_hash_entry *)
	     bfd_hash_allocate (table, sizeof (struct bfd_hash_entry)));
  return entry;
}

d446 3
a448 4
PTR
bfd_hash_allocate (table, size)
     struct bfd_hash_table *table;
     unsigned int size;
d450 1
a450 1
  PTR ret;
d458 12
d473 3
a475 4
bfd_hash_traverse (table, func, info)
     struct bfd_hash_table *table;
     bfd_boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
     PTR info;
d484 2
a485 4
	{
	  if (! (*func) (p, info))
	    return;
	}
a545 3
static struct bfd_hash_entry *strtab_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

d549 3
a551 4
strtab_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d557 3
a559 4
  if (ret == (struct strtab_hash_entry *) NULL)
    ret = ((struct strtab_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct strtab_hash_entry)));
  if (ret == (struct strtab_hash_entry *) NULL)
d563 2
a564 2
  ret = ((struct strtab_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
d585 1
a585 1
_bfd_stringtab_init ()
d588 1
a588 1
  bfd_size_type amt = sizeof (struct bfd_strtab_hash);
d590 1
a590 1
  table = (struct bfd_strtab_hash *) bfd_malloc (amt);
d594 1
a594 1
  if (! bfd_hash_table_init (&table->table, strtab_hash_newfunc))
d613 1
a613 1
_bfd_xcoff_stringtab_init ()
d626 1
a626 2
_bfd_stringtab_free (table)
     struct bfd_strtab_hash *table;
d637 4
a640 5
_bfd_stringtab_add (tab, str, hash, copy)
     struct bfd_strtab_hash *tab;
     const char *str;
     bfd_boolean hash;
     bfd_boolean copy;
d642 1
a642 1
  register struct strtab_hash_entry *entry;
d652 1
a652 3
      entry = ((struct strtab_hash_entry *)
	       bfd_hash_allocate (&tab->table,
				  sizeof (struct strtab_hash_entry)));
d661 1
a661 1
	  n = (char *) bfd_hash_allocate (&tab->table, strlen (str) + 1);
d692 1
a692 2
_bfd_stringtab_size (tab)
     struct bfd_strtab_hash *tab;
d701 1
a701 3
_bfd_stringtab_emit (abfd, tab)
     register bfd *abfd;
     struct bfd_strtab_hash *tab;
d703 2
a704 2
  register bfd_boolean xcoff;
  register struct strtab_hash_entry *entry;
d722 1
a722 1
	  if (bfd_bwrite ((PTR) buf, (bfd_size_type) 2, abfd) != 2)
d726 1
a726 1
      if (bfd_bwrite ((PTR) str, (bfd_size_type) len, abfd) != len)
@


1.13
log
@Remove bogus inode
@
text
@a506 1
  int index;
d508 1
a508 1
  static bfd_size_type hash_size_primes[] =
d512 1
@


1.12
log
@Add --hash-size switch to the linker
@
text
@a56 1
@@* Changing the default Hash Table Size::
@


1.11
log
@	* coff-rs6000.c: Remove ARGSUSED and VARARGS.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* elf32-vax.c: Likewise.
	* hash.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* ihex.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* pdp11.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* section.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 1
d57 1
d92 4
d304 2
a305 1
#define DEFAULT_SIZE (4051)
d349 1
a349 1
  return bfd_hash_table_init_n (table, newfunc, DEFAULT_SIZE);
d503 18
@


1.11.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2004
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a25 1
#include "libiberty.h"
a89 4
@@findex bfd_hash_set_default_size
	Use <<bfd_hash_set_default_size>> to set the default size of
	hash table to use.

d298 1
a298 2
#define DEFAULT_SIZE 4051
static size_t bfd_default_hash_table_size = DEFAULT_SIZE;
d342 1
a342 1
  return bfd_hash_table_init_n (table, newfunc, bfd_default_hash_table_size);
a497 18
void
bfd_hash_set_default_size (bfd_size_type hash_size)
{
  int index;
  /* Extend this prime list if you want more granularity of hash table size.  */
  static bfd_size_type hash_size_primes[] =
    {
      1021, 4051, 8599, 16699
    };

  /* Work out best prime number near the hash_size.  */
  for (index = 0; index < ARRAY_SIZE (hash_size_primes) - 1; ++index)
    if (hash_size <= hash_size_primes[index])
      break;

  bfd_default_hash_table_size = hash_size_primes[index];
}

@


1.10
log
@	* aout-target.h, aoutf1.h, bfdio.c, bfdwin.c: Update copyright date.
	* coff-apollo.c, coff-sparc.c, coff-w65.c, coff-we32k.c: Ditto.
	* coff-z8k.c, coffgen.c, cpu-frv.c, cpu-h8500.c, cpu-hppa.c: Ditto.
	* cpu-ia64-opc.c, cpu-m10300.c, cpu-mips.c, cpu-msp430.c: Ditto.
	* cpu-rs6000.c, cpu-z8k.c, efi-app-ia32.c, elf32-am33lin.c: Ditto.
	* gen-aout.c, hash.c, hp300hpux.c, init.c, mach-o.c: Ditto.
	* nlm-target.h, nlm.c, som.h, stabs.c, sysdep.h, xsym.h: Ditto.
@
text
@a448 1
/*ARGSUSED*/
@


1.9
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002
@


1.8
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d70 1
a70 1
	<<bfd_hash_table_init>> returns <<false>> if some sort of
d99 1
a99 1
	If the @@var{create} argument is <<false>>, <<bfd_hash_lookup>>
d106 1
a106 1
	If the @@var{create} argument is <<true>>, the string will be
d113 1
a113 1
	If the @@var{create} argument is <<true>>, and a new entry is
d116 1
a116 1
	@@var{copy} is passed as <<false>>, you must be careful not to
d136 1
a136 1
	<<false>>, <<bfd_hash_traverse>> will stop the traversal and
d302 1
a302 1
boolean
d318 1
a318 1
      return false;
d325 1
a325 1
      return false;
d330 1
a330 1
  return true;
d335 1
a335 1
boolean
d361 2
a362 2
     boolean create;
     boolean copy;
d482 1
a482 1
     boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
d535 1
a535 1
  boolean xcoff;
d600 1
a600 1
  table->xcoff = false;
d616 1
a616 1
    ret->xcoff = true;
d631 1
a631 1
   already present.  If HASH is false, we don't really use the hash
d638 2
a639 2
     boolean hash;
     boolean copy;
d645 1
a645 1
      entry = strtab_hash_lookup (tab, str, true, copy);
d702 1
a702 1
boolean
d707 1
a707 1
  register boolean xcoff;
d727 1
a727 1
	    return false;
d731 1
a731 1
	return false;
d734 1
a734 1
  return true;
@


1.8.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003
d70 1
a70 1
	<<bfd_hash_table_init>> returns <<FALSE>> if some sort of
d99 1
a99 1
	If the @@var{create} argument is <<FALSE>>, <<bfd_hash_lookup>>
d106 1
a106 1
	If the @@var{create} argument is <<TRUE>>, the string will be
d113 1
a113 1
	If the @@var{create} argument is <<TRUE>>, and a new entry is
d116 1
a116 1
	@@var{copy} is passed as <<FALSE>>, you must be careful not to
d136 1
a136 1
	<<FALSE>>, <<bfd_hash_traverse>> will stop the traversal and
d302 1
a302 1
bfd_boolean
d318 1
a318 1
      return FALSE;
d325 1
a325 1
      return FALSE;
d330 1
a330 1
  return TRUE;
d335 1
a335 1
bfd_boolean
d361 2
a362 2
     bfd_boolean create;
     bfd_boolean copy;
d449 1
d482 1
a482 1
     bfd_boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
d535 1
a535 1
  bfd_boolean xcoff;
d600 1
a600 1
  table->xcoff = FALSE;
d616 1
a616 1
    ret->xcoff = TRUE;
d631 1
a631 1
   already present.  If HASH is FALSE, we don't really use the hash
d638 2
a639 2
     bfd_boolean hash;
     bfd_boolean copy;
d645 1
a645 1
      entry = strtab_hash_lookup (tab, str, TRUE, copy);
d702 1
a702 1
bfd_boolean
d707 1
a707 1
  register bfd_boolean xcoff;
d727 1
a727 1
	    return FALSE;
d731 1
a731 1
	return FALSE;
d734 1
a734 1
  return TRUE;
@


1.8.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d70 1
a70 1
	<<bfd_hash_table_init>> returns <<FALSE>> if some sort of
d99 1
a99 1
	If the @@var{create} argument is <<FALSE>>, <<bfd_hash_lookup>>
d106 1
a106 1
	If the @@var{create} argument is <<TRUE>>, the string will be
d113 1
a113 1
	If the @@var{create} argument is <<TRUE>>, and a new entry is
d116 1
a116 1
	@@var{copy} is passed as <<FALSE>>, you must be careful not to
d136 1
a136 1
	<<FALSE>>, <<bfd_hash_traverse>> will stop the traversal and
d302 1
a302 1
bfd_boolean
d318 1
a318 1
      return FALSE;
d325 1
a325 1
      return FALSE;
d330 1
a330 1
  return TRUE;
d335 1
a335 1
bfd_boolean
d361 2
a362 2
     bfd_boolean create;
     bfd_boolean copy;
d482 1
a482 1
     bfd_boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
d535 1
a535 1
  bfd_boolean xcoff;
d600 1
a600 1
  table->xcoff = FALSE;
d616 1
a616 1
    ret->xcoff = TRUE;
d631 1
a631 1
   already present.  If HASH is FALSE, we don't really use the hash
d638 2
a639 2
     bfd_boolean hash;
     bfd_boolean copy;
d645 1
a645 1
      entry = strtab_hash_lookup (tab, str, TRUE, copy);
d702 1
a702 1
bfd_boolean
d707 1
a707 1
  register bfd_boolean xcoff;
d727 1
a727 1
	    return FALSE;
d731 1
a731 1
	return FALSE;
d734 1
a734 1
  return TRUE;
@


1.8.12.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003
@


1.8.12.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d449 1
@


1.7
log
@Remove computation of len from inside hash loop.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001
d410 1
a410 1
      strcpy (new, string);
@


1.7.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002
d410 1
a410 1
      memcpy (new, string, len + 1);
@


1.6
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a377 1
      ++len;
d379 1
@


1.6.8.1
log
@merge from trunk
@
text
@d378 1
a379 1
  len = (s - (const unsigned char *) string) - 1;
@


1.5
log
@Update copyright notices
@
text
@d585 1
d587 1
a587 2
  table = ((struct bfd_strtab_hash *)
	   bfd_malloc (sizeof (struct bfd_strtab_hash)));
d714 2
a715 2
      register const char *str;
      register size_t len;
d725 2
a726 2
	  bfd_put_16 (abfd, len, buf);
	  if (bfd_write ((PTR) buf, 1, 2, abfd) != 2)
d730 1
a730 1
      if (bfd_write ((PTR) str, 1, len, abfd) != len)
@


1.4
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd.c: Likewise.
	* bfd-in2.h: Likewise.
	* bfd-in.h: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* dwarf2.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* format.c: Likewise.
	* freebsd.h: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 97, 1999 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1997, 1999, 2001
   Free Software Foundation, Inc.
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d271 1
a271 1
	as well.  
d369 1
a369 1
  
@


1.2
log
@Franz Sirl <Franz.Sirl-kernel@@lauterbach.com>
        * elf32-ppc.c (ppc_elf_relocate_section): Don't barf on out of
        range undefweak symbols.
        * hash.c: Add missing comma after @@xref{}
        * linker.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1997 Free Software Foundation, Inc.
d453 1
a453 1
     const char *string;
@


1.1
log
@Initial revision
@
text
@d76 1
a76 1
	a New Hash Table Type} for why you would want to use a
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

