head	1.193;
access;
symbols
	sid-snapshot-20180601:1.193
	sid-snapshot-20180501:1.193
	sid-snapshot-20180401:1.193
	sid-snapshot-20180301:1.193
	sid-snapshot-20180201:1.193
	sid-snapshot-20180101:1.193
	sid-snapshot-20171201:1.193
	sid-snapshot-20171101:1.193
	sid-snapshot-20171001:1.193
	sid-snapshot-20170901:1.193
	sid-snapshot-20170801:1.193
	sid-snapshot-20170701:1.193
	sid-snapshot-20170601:1.193
	sid-snapshot-20170501:1.193
	sid-snapshot-20170401:1.193
	sid-snapshot-20170301:1.193
	sid-snapshot-20170201:1.193
	sid-snapshot-20170101:1.193
	sid-snapshot-20161201:1.193
	sid-snapshot-20161101:1.193
	sid-snapshot-20160901:1.193
	sid-snapshot-20160801:1.193
	sid-snapshot-20160701:1.193
	sid-snapshot-20160601:1.193
	sid-snapshot-20160501:1.193
	sid-snapshot-20160401:1.193
	sid-snapshot-20160301:1.193
	sid-snapshot-20160201:1.193
	sid-snapshot-20160101:1.193
	sid-snapshot-20151201:1.193
	sid-snapshot-20151101:1.193
	sid-snapshot-20151001:1.193
	sid-snapshot-20150901:1.193
	sid-snapshot-20150801:1.193
	sid-snapshot-20150701:1.193
	sid-snapshot-20150601:1.193
	sid-snapshot-20150501:1.193
	sid-snapshot-20150401:1.193
	sid-snapshot-20150301:1.193
	sid-snapshot-20150201:1.193
	sid-snapshot-20150101:1.193
	sid-snapshot-20141201:1.193
	sid-snapshot-20141101:1.193
	sid-snapshot-20141001:1.193
	sid-snapshot-20140901:1.193
	sid-snapshot-20140801:1.193
	sid-snapshot-20140701:1.193
	sid-snapshot-20140601:1.193
	sid-snapshot-20140501:1.193
	sid-snapshot-20140401:1.193
	sid-snapshot-20140301:1.193
	sid-snapshot-20140201:1.193
	sid-snapshot-20140101:1.193
	sid-snapshot-20131201:1.193
	sid-snapshot-20131101:1.193
	sid-snapshot-20131001:1.192
	binutils-2_24-branch:1.192.0.2
	binutils-2_24-branchpoint:1.192
	binutils-2_21_1:1.174
	sid-snapshot-20130901:1.192
	gdb_7_6_1-2013-08-30-release:1.190
	sid-snapshot-20130801:1.192
	sid-snapshot-20130701:1.192
	sid-snapshot-20130601:1.192
	sid-snapshot-20130501:1.192
	gdb_7_6-2013-04-26-release:1.190
	sid-snapshot-20130401:1.192
	binutils-2_23_2:1.187
	gdb_7_6-branch:1.190.0.2
	gdb_7_6-2013-03-12-branchpoint:1.190
	sid-snapshot-20130301:1.190
	sid-snapshot-20130201:1.189
	sid-snapshot-20130101:1.188
	sid-snapshot-20121201:1.188
	gdb_7_5_1-2012-11-29-release:1.186
	binutils-2_23_1:1.187
	sid-snapshot-20121101:1.188
	binutils-2_23:1.187
	sid-snapshot-20121001:1.188
	sid-snapshot-20120901:1.187
	gdb_7_5-2012-08-17-release:1.186
	sid-snapshot-20120801:1.187
	binutils-2_23-branch:1.187.0.2
	binutils-2_23-branchpoint:1.187
	gdb_7_5-branch:1.186.0.2
	gdb_7_5-2012-07-18-branchpoint:1.186
	sid-snapshot-20120701:1.185
	sid-snapshot-20120601:1.184
	sid-snapshot-20120501:1.183
	binutils-2_22_branch:1.180.0.4
	gdb_7_4_1-2012-04-26-release:1.182
	sid-snapshot-20120401:1.182
	sid-snapshot-20120301:1.182
	sid-snapshot-20120201:1.182
	gdb_7_4-2012-01-24-release:1.182
	sid-snapshot-20120101:1.182
	gdb_7_4-branch:1.182.0.2
	gdb_7_4-2011-12-13-branchpoint:1.182
	sid-snapshot-20111201:1.182
	binutils-2_22:1.180
	sid-snapshot-20111101:1.182
	sid-snapshot-20111001:1.181
	binutils-2_22-branch:1.180.0.2
	binutils-2_22-branchpoint:1.180
	gdb_7_3_1-2011-09-04-release:1.175
	sid-snapshot-20110901:1.180
	sid-snapshot-20110801:1.180
	gdb_7_3-2011-07-26-release:1.175
	sid-snapshot-20110701:1.180
	sid-snapshot-20110601:1.176
	sid-snapshot-20110501:1.176
	gdb_7_3-branch:1.175.0.2
	gdb_7_3-2011-04-01-branchpoint:1.175
	sid-snapshot-20110401:1.175
	sid-snapshot-20110301:1.174
	sid-snapshot-20110201:1.174
	sid-snapshot-20110101:1.174
	binutils-2_21:1.174
	sid-snapshot-20101201:1.174
	binutils-2_21-branch:1.174.0.2
	binutils-2_21-branchpoint:1.174
	sid-snapshot-20101101:1.174
	sid-snapshot-20101001:1.172
	binutils-2_20_1:1.166
	gdb_7_2-2010-09-02-release:1.168
	sid-snapshot-20100901:1.170
	sid-snapshot-20100801:1.168
	gdb_7_2-branch:1.168.0.4
	gdb_7_2-2010-07-07-branchpoint:1.168
	sid-snapshot-20100701:1.168
	sid-snapshot-20100601:1.168
	sid-snapshot-20100501:1.168
	sid-snapshot-20100401:1.168
	gdb_7_1-2010-03-18-release:1.168
	sid-snapshot-20100301:1.168
	gdb_7_1-branch:1.168.0.2
	gdb_7_1-2010-02-18-branchpoint:1.168
	sid-snapshot-20100201:1.167
	sid-snapshot-20100101:1.167
	gdb_7_0_1-2009-12-22-release:1.166
	sid-snapshot-20091201:1.167
	sid-snapshot-20091101:1.167
	binutils-2_20:1.166
	gdb_7_0-2009-10-06-release:1.166
	sid-snapshot-20091001:1.167
	gdb_7_0-branch:1.166.0.10
	gdb_7_0-2009-09-16-branchpoint:1.166
	arc-sim-20090309:1.165
	binutils-arc-20081103-branch:1.165.0.20
	binutils-arc-20081103-branchpoint:1.165
	binutils-2_20-branch:1.166.0.8
	binutils-2_20-branchpoint:1.166
	sid-snapshot-20090901:1.166
	sid-snapshot-20090801:1.166
	msnyder-checkpoint-072509-branch:1.166.0.6
	msnyder-checkpoint-072509-branchpoint:1.166
	sid-snapshot-20090701:1.166
	dje-cgen-play1-branch:1.166.0.4
	dje-cgen-play1-branchpoint:1.166
	sid-snapshot-20090601:1.166
	sid-snapshot-20090501:1.166
	sid-snapshot-20090401:1.166
	arc-20081103-branch:1.165.0.18
	arc-20081103-branchpoint:1.165
	arc-insight_6_8-branch:1.165.0.16
	arc-insight_6_8-branchpoint:1.165
	insight_6_8-branch:1.165.0.14
	insight_6_8-branchpoint:1.165
	sid-snapshot-20090301:1.166
	binutils-2_19_1:1.165
	sid-snapshot-20090201:1.166
	sid-snapshot-20090101:1.166
	reverse-20081226-branch:1.166.0.2
	reverse-20081226-branchpoint:1.166
	sid-snapshot-20081201:1.166
	multiprocess-20081120-branch:1.165.0.12
	multiprocess-20081120-branchpoint:1.165
	sid-snapshot-20081101:1.165
	binutils-2_19:1.165
	sid-snapshot-20081001:1.165
	reverse-20080930-branch:1.165.0.10
	reverse-20080930-branchpoint:1.165
	binutils-2_19-branch:1.165.0.8
	binutils-2_19-branchpoint:1.165
	sid-snapshot-20080901:1.165
	sid-snapshot-20080801:1.165
	reverse-20080717-branch:1.165.0.6
	reverse-20080717-branchpoint:1.165
	sid-snapshot-20080701:1.165
	msnyder-reverse-20080609-branch:1.165.0.4
	msnyder-reverse-20080609-branchpoint:1.165
	drow-reverse-20070409-branch:1.158.0.2
	drow-reverse-20070409-branchpoint:1.158
	sid-snapshot-20080601:1.165
	sid-snapshot-20080501:1.165
	sid-snapshot-20080403:1.165
	sid-snapshot-20080401:1.165
	gdb_6_8-2008-03-27-release:1.165
	sid-snapshot-20080301:1.165
	gdb_6_8-branch:1.165.0.2
	gdb_6_8-2008-02-26-branchpoint:1.165
	sid-snapshot-20080201:1.163
	sid-snapshot-20080101:1.163
	sid-snapshot-20071201:1.163
	sid-snapshot-20071101:1.163
	gdb_6_7_1-2007-10-29-release:1.162
	gdb_6_7-2007-10-10-release:1.162
	sid-snapshot-20071001:1.162
	gdb_6_7-branch:1.162.0.4
	gdb_6_7-2007-09-07-branchpoint:1.162
	binutils-2_18:1.162
	binutils-2_18-branch:1.162.0.2
	binutils-2_18-branchpoint:1.162
	insight_6_6-20070208-release:1.154
	binutils-csl-coldfire-4_1-32:1.150
	binutils-csl-sourcerygxx-4_1-32:1.150
	gdb_6_6-2006-12-18-release:1.154
	binutils-csl-innovasic-fido-3_4_4-33:1.150
	binutils-csl-sourcerygxx-3_4_4-32:1.126.2.2
	binutils-csl-coldfire-4_1-30:1.150
	binutils-csl-sourcerygxx-4_1-30:1.150
	binutils-csl-coldfire-4_1-28:1.150
	binutils-csl-sourcerygxx-4_1-29:1.150
	binutils-csl-sourcerygxx-4_1-28:1.150
	gdb_6_6-branch:1.154.0.2
	gdb_6_6-2006-11-15-branchpoint:1.154
	binutils-csl-arm-2006q3-27:1.150
	binutils-csl-sourcerygxx-4_1-27:1.150
	binutils-csl-arm-2006q3-26:1.150
	binutils-csl-sourcerygxx-4_1-26:1.150
	binutils-csl-sourcerygxx-4_1-25:1.150
	binutils-csl-sourcerygxx-4_1-24:1.150
	binutils-csl-sourcerygxx-4_1-23:1.150
	insight_6_5-20061003-release:1.150
	gdb-csl-symbian-6_4_50_20060226-12:1.148
	binutils-csl-sourcerygxx-4_1-21:1.150
	binutils-csl-arm-2006q3-21:1.150
	binutils-csl-sourcerygxx-4_1-22:1.150
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.150
	binutils-csl-sourcerygxx-4_1-20:1.150
	binutils-csl-arm-2006q3-19:1.150
	binutils-csl-sourcerygxx-4_1-19:1.150
	binutils-csl-sourcerygxx-4_1-18:1.150
	binutils-csl-renesas-4_1-9:1.150
	gdb-csl-sourcerygxx-3_4_4-25:1.147
	binutils-csl-sourcerygxx-3_4_4-25:1.126.2.2
	nickrob-async-20060828-mergepoint:1.152
	gdb-csl-symbian-6_4_50_20060226-11:1.148
	binutils-csl-renesas-4_1-8:1.150
	binutils-csl-renesas-4_1-7:1.150
	binutils-csl-renesas-4_1-6:1.150
	gdb-csl-sourcerygxx-4_1-17:1.148
	binutils-csl-sourcerygxx-4_1-17:1.150
	gdb-csl-20060226-branch-local-2:1.148
	gdb-csl-sourcerygxx-4_1-14:1.148
	binutils-csl-sourcerygxx-4_1-14:1.150
	binutils-csl-sourcerygxx-4_1-15:1.150
	gdb-csl-sourcerygxx-4_1-13:1.148
	binutils-csl-sourcerygxx-4_1-13:1.150
	binutils-2_17:1.150
	gdb-csl-sourcerygxx-4_1-12:1.148
	binutils-csl-sourcerygxx-4_1-12:1.150
	gdb-csl-sourcerygxx-3_4_4-21:1.148
	binutils-csl-sourcerygxx-3_4_4-21:1.150
	gdb_6_5-20060621-release:1.150
	binutils-csl-wrs-linux-3_4_4-24:1.126
	binutils-csl-wrs-linux-3_4_4-23:1.126
	gdb-csl-sourcerygxx-4_1-9:1.148
	binutils-csl-sourcerygxx-4_1-9:1.150
	gdb-csl-sourcerygxx-4_1-8:1.148
	binutils-csl-sourcerygxx-4_1-8:1.150
	gdb-csl-sourcerygxx-4_1-7:1.148
	binutils-csl-sourcerygxx-4_1-7:1.150
	gdb-csl-arm-2006q1-6:1.148
	binutils-csl-arm-2006q1-6:1.150
	gdb-csl-sourcerygxx-4_1-6:1.148
	binutils-csl-sourcerygxx-4_1-6:1.150
	binutils-csl-wrs-linux-3_4_4-22:1.126
	gdb-csl-symbian-6_4_50_20060226-10:1.148
	gdb-csl-symbian-6_4_50_20060226-9:1.148
	gdb-csl-symbian-6_4_50_20060226-8:1.148
	gdb-csl-coldfire-4_1-11:1.148
	binutils-csl-coldfire-4_1-11:1.150
	gdb-csl-sourcerygxx-3_4_4-19:1.148
	binutils-csl-sourcerygxx-3_4_4-19:1.150
	gdb-csl-coldfire-4_1-10:1.148
	gdb_6_5-branch:1.150.0.14
	gdb_6_5-2006-05-14-branchpoint:1.150
	binutils-csl-coldfire-4_1-10:1.150
	gdb-csl-sourcerygxx-4_1-5:1.148
	binutils-csl-sourcerygxx-4_1-5:1.150
	nickrob-async-20060513-branch:1.150.0.12
	nickrob-async-20060513-branchpoint:1.150
	gdb-csl-sourcerygxx-4_1-4:1.148
	binutils-csl-sourcerygxx-4_1-4:1.150
	msnyder-reverse-20060502-branch:1.150.0.10
	msnyder-reverse-20060502-branchpoint:1.150
	binutils-csl-wrs-linux-3_4_4-21:1.126
	gdb-csl-morpho-4_1-4:1.148
	binutils-csl-morpho-4_1-4:1.150
	gdb-csl-sourcerygxx-3_4_4-17:1.148
	binutils-csl-sourcerygxx-3_4_4-17:1.150
	binutils-csl-wrs-linux-3_4_4-20:1.126
	readline_5_1-import-branch:1.150.0.8
	readline_5_1-import-branchpoint:1.150
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.148
	binutils-2_17-branch:1.150.0.6
	binutils-2_17-branchpoint:1.150
	gdb-csl-symbian-20060226-branch:1.148.0.4
	gdb-csl-symbian-20060226-branchpoint:1.148
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.148
	msnyder-reverse-20060331-branch:1.150.0.4
	msnyder-reverse-20060331-branchpoint:1.150
	binutils-csl-2_17-branch:1.150.0.2
	binutils-csl-2_17-branchpoint:1.150
	gdb-csl-available-20060303-branch:1.149.0.2
	gdb-csl-available-20060303-branchpoint:1.149
	gdb-csl-20060226-branch:1.148.0.2
	gdb-csl-20060226-branchpoint:1.148
	gdb_6_4-20051202-release:1.147
	msnyder-fork-checkpoint-branch:1.147.0.8
	msnyder-fork-checkpoint-branchpoint:1.147
	gdb-csl-gxxpro-6_3-branch:1.147.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.147
	gdb_6_4-branch:1.147.0.4
	gdb_6_4-2005-11-01-branchpoint:1.147
	gdb-csl-arm-20051020-branch:1.147.0.2
	gdb-csl-arm-20051020-branchpoint:1.147
	binutils-csl-gxxpro-3_4-branch:1.126.2.2.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.126.2.2
	binutils-2_16_1:1.126.2.2
	msnyder-tracepoint-checkpoint-branch:1.139.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.139
	gdb-csl-arm-20050325-2005-q1b:1.127
	binutils-csl-arm-2005q1b:1.126
	binutils-2_16:1.126
	gdb-csl-arm-20050325-2005-q1a:1.127
	binutils-csl-arm-2005q1a:1.126
	csl-arm-20050325-branch:1.127.0.2
	csl-arm-20050325-branchpoint:1.127
	binutils-csl-arm-2005q1-branch:1.126.0.4
	binutils-csl-arm-2005q1-branchpoint:1.126
	binutils-2_16-branch:1.126.0.2
	binutils-2_16-branchpoint:1.126
	csl-arm-2004-q3d:1.125
	gdb_6_3-20041109-release:1.124
	gdb_6_3-branch:1.124.0.2
	gdb_6_3-20041019-branchpoint:1.124
	csl-arm-2004-q3:1.124
	drow_intercu-merge-20040921:1.124
	drow_intercu-merge-20040915:1.122
	jimb-gdb_6_2-e500-branch:1.121.0.6
	jimb-gdb_6_2-e500-branchpoint:1.121
	gdb_6_2-20040730-release:1.121
	gdb_6_2-branch:1.121.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.121
	gdb_6_1_1-20040616-release:1.113
	binutils-2_15:1.113.4.1
	binutils-2_15-branchpoint:1.113
	csl-arm-2004-q1a:1.118
	csl-arm-2004-q1:1.117
	gdb_6_1-2004-04-05-release:1.113
	drow_intercu-merge-20040402:1.117
	drow_intercu-merge-20040327:1.116
	ezannoni_pie-20040323-branch:1.114.0.2
	ezannoni_pie-20040323-branchpoint:1.114
	cagney_tramp-20040321-mergepoint:1.113
	cagney_tramp-20040309-branch:1.113.0.10
	cagney_tramp-20040309-branchpoint:1.113
	gdb_6_1-branch:1.113.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.113
	drow_intercu-20040221-branch:1.113.0.6
	drow_intercu-20040221-branchpoint:1.113
	binutils-2_15-branch:1.113.0.4
	cagney_bfdfile-20040213-branch:1.113.0.2
	cagney_bfdfile-20040213-branchpoint:1.113
	drow-cplus-merge-20040208:1.112
	carlton_dictionary-20040126-merge:1.112
	cagney_bigcore-20040122-branch:1.112.0.2
	cagney_bigcore-20040122-branchpoint:1.112
	drow-cplus-merge-20040113:1.112
	csl-arm-2003-q4:1.112
	drow-cplus-merge-20031224:1.112
	drow-cplus-merge-20031220:1.112
	carlton_dictionary-20031215-merge:1.112
	drow-cplus-merge-20031214:1.112
	carlton-dictionary-20031111-merge:1.110
	gdb_6_0-2003-10-04-release:1.99
	kettenis_sparc-20030918-branch:1.105.0.6
	kettenis_sparc-20030918-branchpoint:1.105
	carlton_dictionary-20030917-merge:1.105
	ezannoni_pie-20030916-branchpoint:1.105
	ezannoni_pie-20030916-branch:1.105.0.4
	cagney_x86i386-20030821-branch:1.105.0.2
	cagney_x86i386-20030821-branchpoint:1.105
	carlton_dictionary-20030805-merge:1.103
	carlton_dictionary-20030627-merge:1.100
	gdb_6_0-branch:1.99.0.6
	gdb_6_0-2003-06-23-branchpoint:1.99
	jimb-ppc64-linux-20030613-branch:1.99.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.99
	binutils-2_14:1.97
	cagney_convert-20030606-branch:1.99.0.2
	cagney_convert-20030606-branchpoint:1.99
	cagney_writestrings-20030508-branch:1.98.0.8
	cagney_writestrings-20030508-branchpoint:1.98
	jimb-ppc64-linux-20030528-branch:1.98.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.98
	carlton_dictionary-20030523-merge:1.98
	cagney_fileio-20030521-branch:1.98.0.4
	cagney_fileio-20030521-branchpoint:1.98
	kettenis_i386newframe-20030517-mergepoint:1.98
	jimb-ppc64-linux-20030509-branch:1.98.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.98
	kettenis_i386newframe-20030504-mergepoint:1.97
	carlton_dictionary-20030430-merge:1.97
	binutils-2_14-branch:1.97.0.2
	binutils-2_14-branchpoint:1.97
	kettenis_i386newframe-20030419-branch:1.96.0.2
	kettenis_i386newframe-20030419-branchpoint:1.96
	carlton_dictionary-20030416-merge:1.96
	cagney_frameaddr-20030409-mergepoint:1.96
	kettenis_i386newframe-20030406-branch:1.94.0.14
	kettenis_i386newframe-20030406-branchpoint:1.94
	cagney_frameaddr-20030403-branchpoint:1.94
	cagney_frameaddr-20030403-branch:1.94.0.12
	cagney_framebase-20030330-mergepoint:1.94
	cagney_framebase-20030326-branch:1.94.0.10
	cagney_framebase-20030326-branchpoint:1.94
	cagney_lazyid-20030317-branch:1.94.0.8
	cagney_lazyid-20030317-branchpoint:1.94
	kettenis-i386newframe-20030316-mergepoint:1.94
	offbyone-20030313-branch:1.94.0.6
	offbyone-20030313-branchpoint:1.94
	kettenis-i386newframe-20030308-branch:1.94.0.4
	kettenis-i386newframe-20030308-branchpoint:1.94
	carlton_dictionary-20030305-merge:1.94
	cagney_offbyone-20030303-branch:1.94.0.2
	cagney_offbyone-20030303-branchpoint:1.94
	carlton_dictionary-20030207-merge:1.93
	interps-20030202-branch:1.91.0.2
	interps-20030202-branchpoint:1.91
	cagney-unwind-20030108-branch:1.88.0.2
	cagney-unwind-20030108-branchpoint:1.88
	binutils-2_13_2_1:1.77.2.5
	binutils-2_13_2:1.77.2.5
	carlton_dictionary-20021223-merge:1.87
	gdb_5_3-2002-12-12-release:1.78
	carlton_dictionary-20021115-merge:1.85
	binutils-2_13_1:1.77.2.5
	kseitz_interps-20021105-merge:1.85
	kseitz_interps-20021103-merge:1.85
	drow-cplus-merge-20021020:1.84
	drow-cplus-merge-20021025:1.85
	carlton_dictionary-20021025-merge:1.85
	carlton_dictionary-20021011-merge:1.82
	drow-cplus-branch:1.81.0.2
	drow-cplus-branchpoint:1.81
	kseitz_interps-20020930-merge:1.81
	carlton_dictionary-20020927-merge:1.81
	carlton_dictionary-branch:1.80.0.2
	carlton_dictionary-20020920-branchpoint:1.80
	sid-20020905-branchpoint:1.78
	sid-20020905-branch:1.78.0.8
	gdb_5_3-branch:1.78.0.6
	gdb_5_3-2002-09-04-branchpoint:1.78
	kseitz_interps-20020829-merge:1.78
	cagney_sysregs-20020825-branch:1.78.0.4
	cagney_sysregs-20020825-branchpoint:1.78
	readline_4_3-import-branch:1.78.0.2
	readline_4_3-import-branchpoint:1.78
	binutils-2_13:1.77.2.1
	gdb_5_2_1-2002-07-23-release:1.59
	binutils-2_13-branchpoint:1.77
	binutils-2_13-branch:1.77.0.2
	kseitz_interps-20020528-branch:1.62.0.6
	kseitz_interps-20020528-branchpoint:1.62
	cagney_regbuf-20020515-branch:1.62.0.4
	cagney_regbuf-20020515-branchpoint:1.62
	binutils-2_12_1:1.56.2.4
	jimb-macro-020506-branch:1.62.0.2
	jimb-macro-020506-branchpoint:1.62
	gdb_5_2-2002-04-29-release:1.59
	binutils-2_12:1.56.2.2
	gdb_5_2-branch:1.59.0.2
	gdb_5_2-2002-03-03-branchpoint:1.59
	binutils-2_12-branch:1.56.0.2
	binutils-2_12-branchpoint:1.56
	gdb_5_1_1-2002-01-24-release:1.28
	gdb_5_1_0_1-2002-01-03-release:1.28
	cygnus_cvs_20020108_pre:1.52
	gdb_5_1_0_1-2002-01-03-branch:1.28.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.28
	gdb_5_1-2001-11-21-release:1.28
	gdb_s390-2001-09-26-branch:1.28.0.4
	gdb_s390-2001-09-26-branchpoint:1.28
	gdb_5_1-2001-07-29-branch:1.28.0.2
	gdb_5_1-2001-07-29-branchpoint:1.28
	binutils-2_11_2:1.19.2.4
	binutils-2_11_1:1.19.2.4
	binutils-2_11:1.19.2.1
	x86_64versiong3:1.22
	binutils-2_11-branch:1.19.0.2
	insight-precleanup-2001-01-01:1.17
	binutils-2_10_1:1.7.2.3
	binutils-2_10:1.7.2.1
	gdb-premipsmulti-2000-06-06-branch:1.10.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.10
	gdb_5_0-2000-05-19-release:1.8
	gdb_4_18_2-2000-05-18-release:1.8
	gdb_4_95_1-2000-05-11-snapshot:1.8
	gdb_4_95_0-2000-04-27-snapshot:1.8
	gdb_5_0-2000-04-10-branch:1.8.0.2
	gdb_5_0-2000-04-10-branchpoint:1.8
	binutils-2_10-branch:1.7.0.2
	binutils-2_10-branchpoint:1.7
	binutils_latest_snapshot:1.193
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.193
date	2013.10.09.19.40.04;	author roland;	state Exp;
branches;
next	1.192;

1.192
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches
	1.192.2.1;
next	1.191;

1.191
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2013.02.18.02.56.58;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.188;

1.188
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.187;

1.187
date	2012.07.24.21.06.58;	author ccoutant;	state Exp;
branches;
next	1.186;

1.186
date	2012.07.13.14.22.47;	author nickc;	state Exp;
branches;
next	1.185;

1.185
date	2012.06.29.14.46.01;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.183;

1.183
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2011.10.19.07.17.18;	author amodra;	state Exp;
branches;
next	1.181;

1.181
date	2011.09.30.10.39.45;	author gingold;	state Exp;
branches;
next	1.180;

1.180
date	2011.06.24.17.38.17;	author rth;	state Exp;
branches
	1.180.2.1;
next	1.179;

1.179
date	2011.06.22.16.18.24;	author rth;	state Exp;
branches;
next	1.178;

1.178
date	2011.06.15.15.04.12;	author rth;	state Exp;
branches;
next	1.177;

1.177
date	2011.06.13.00.59.12;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2011.04.12.23.23.02;	author rth;	state Exp;
branches;
next	1.175;

1.175
date	2011.03.29.21.18.16;	author rth;	state Exp;
branches;
next	1.174;

1.174
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.173;

1.173
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.172;

1.172
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.171;

1.171
date	2010.09.20.16.09.02;	author rth;	state Exp;
branches;
next	1.170;

1.170
date	2010.08.25.14.53.44;	author hjl;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.09.23.58.52;	author rth;	state Exp;
branches;
next	1.168;

1.168
date	2010.02.04.09.16.40;	author nickc;	state Exp;
branches;
next	1.167;

1.167
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.166;

1.166
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.165;

1.165
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.18.09.13.51;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2007.07.10.04.08.11;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2007.04.10.18.00.25;	author rth;	state Exp;
branches;
next	1.158;

1.158
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.156;

1.156
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2006.12.06.07.25.29;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.152;

1.152
date	2006.06.23.02.58.01;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.148;

1.148
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.147;

1.147
date	2005.08.15.15.39.08;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2005.07.08.06.20.01;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2005.07.08.00.26.48;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2005.07.01.04.46.08;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2005.05.31.22.53.44;	author rth;	state Exp;
branches;
next	1.140;

1.140
date	2005.05.30.21.22.40;	author rth;	state Exp;
branches;
next	1.139;

1.139
date	2005.05.29.23.13.39;	author rth;	state Exp;
branches;
next	1.138;

1.138
date	2005.05.26.16.14.33;	author rth;	state Exp;
branches;
next	1.137;

1.137
date	2005.05.26.07.14.03;	author rth;	state Exp;
branches;
next	1.136;

1.136
date	2005.05.25.20.00.40;	author rth;	state Exp;
branches;
next	1.135;

1.135
date	2005.05.23.01.26.58;	author rth;	state Exp;
branches;
next	1.134;

1.134
date	2005.05.22.22.13.21;	author rth;	state Exp;
branches;
next	1.133;

1.133
date	2005.05.22.22.07.31;	author rth;	state Exp;
branches;
next	1.132;

1.132
date	2005.05.07.13.22.51;	author hjl;	state Exp;
branches;
next	1.131;

1.131
date	2005.05.05.14.33.54;	author hjl;	state Exp;
branches;
next	1.130;

1.130
date	2005.05.04.15.53.23;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2005.05.04.11.00.16;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2005.03.20.23.36.18;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2005.02.01.01.11.11;	author amodra;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2004.10.21.15.28.25;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.06.29.13.46.33;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.22.01.56.30;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2004.04.27.03.13.14;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2004.03.25.12.48.38;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.09.10.30.13;	author nickc;	state Exp;
branches
	1.113.4.1
	1.113.6.1;
next	1.112;

1.112
date	2003.12.04.03.03.27;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.110;

1.110
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.21.19.24.52;	author drow;	state Exp;
branches;
next	1.105;

1.105
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.103;

1.103
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.102;

1.102
date	2003.07.18.21.09.28;	author rth;	state Exp;
branches;
next	1.101;

1.101
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.25.06.40.20;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.30.15.50.11;	author jakub;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.09.02.27.05;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2003.04.21.22.17.12;	author rth;	state Exp;
branches;
next	1.96;

1.96
date	2003.04.09.20.08.14;	author rth;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2003.04.09.16.19.52;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches
	1.94.12.1;
next	1.93;

1.93
date	2003.02.07.09.30.33;	author jakub;	state Exp;
branches;
next	1.92;

1.92
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2003.01.22.00.47.58;	author rth;	state Exp;
branches;
next	1.90;

1.90
date	2003.01.21.08.59.25;	author rth;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.20.18.06.21;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2002.12.28.21.15.35;	author jakub;	state Exp;
branches;
next	1.87;

1.87
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2002.11.28.11.55.41;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2002.10.23.20.21.21;	author jakub;	state Exp;
branches;
next	1.84;

1.84
date	2002.10.15.17.14.51;	author rth;	state Exp;
branches;
next	1.83;

1.83
date	2002.10.15.01.07.52;	author rth;	state Exp;
branches;
next	1.82;

1.82
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.22.22.32.49;	author hjl;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2002.09.17.08.48.54;	author amodra;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2002.09.17.02.24.34;	author obrien;	state Exp;
branches;
next	1.78;

1.78
date	2002.07.20.04.09.30;	author thorpej;	state Exp;
branches;
next	1.77;

1.77
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.07.15.04.48;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.05.13.32.00;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.02.08.35.51;	author rth;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.02.06.23.30;	author rth;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.02.03.58.40;	author rth;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.02.02.28.44;	author rth;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.01.21.56.41;	author rth;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.01.21.28.59;	author rth;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.01.21.25.33;	author rth;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.30.22.01.28;	author rth;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.02.17.46.59;	author rth;	state Exp;
branches
	1.62.4.1
	1.62.6.1;
next	1.61;

1.61
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.28.03.27.44;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.19.12.40.27;	author jakub;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.15.21.26.05;	author rth;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.15.02.10.35;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.09.22.53.53;	author rth;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2002.01.26.08.41.30;	author rth;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.23.21.51.53;	author rth;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.22.09.51.58;	author rth;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.17.22.44.12;	author jakub;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.28.19.15.11;	author jakub;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.21.14.25.09;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.11.18.26.27;	author rth;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.11.18.21.11;	author rth;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.09.20.50.00;	author rth;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.09.20.42.11;	author rth;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.09.06.58.06;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.05.03.00.13;	author rth;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.31.19.20.12;	author jakub;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.26.11.46.03;	author aj;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.24.11.17.29;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.17.15.56.58;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.17.09.19.10;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.12.04.24.44;	author hjl;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.11.19.03.10;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.04.23.22.31;	author rth;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.03.04.46.27;	author aj;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.09.00.29.58;	author rth;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.07.06.19.58;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.30.09.52.27;	author rth;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.27.00.04.09;	author rth;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.12.19.23.16;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.09.01.54.51;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.15.19.22.28;	author rth;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.14.20.46.24;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.15.18.07.28;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.02.18.06;	author wilson;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.23.14.15.30;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.03.12.42.18;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.24.20.50.30;	author hjl;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.03.26.42;	author meissner;	state Exp;
branches;
next	1.3;

1.3
date	99.07.13.18.21.24;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.06.18.04.25.56;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.192.2.1
date	2013.10.09.19.40.28;	author roland;	state Exp;
branches;
next	;

1.180.2.1
date	2012.05.11.12.24.29;	author nickc;	state Exp;
branches;
next	;

1.126.2.1
date	2005.05.22.22.14.17;	author rth;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2005.05.23.00.01.29;	author rth;	state Exp;
branches;
next	;

1.113.4.1
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.113.6.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.113.6.2;

1.113.6.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.113.6.3;

1.113.6.3
date	2004.09.16.17.00.28;	author drow;	state Exp;
branches;
next	1.113.6.4;

1.113.6.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.96.2.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.96.2.2;

1.96.2.2
date	2003.05.18.09.43.44;	author kettenis;	state Exp;
branches;
next	;

1.94.12.1
date	2003.04.10.21.33.45;	author cagney;	state Exp;
branches;
next	;

1.81.2.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.81.2.2;

1.81.2.2
date	2003.12.14.20.26.42;	author drow;	state Exp;
branches;
next	;

1.80.2.1
date	2002.09.27.20.02.54;	author carlton;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.80.2.3;

1.80.2.3
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.80.2.4;

1.80.2.4
date	2002.12.23.19.37.46;	author carlton;	state Exp;
branches;
next	1.80.2.5;

1.80.2.5
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.80.2.6;

1.80.2.6
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.80.2.7;

1.80.2.7
date	2003.04.16.19.56.44;	author carlton;	state Exp;
branches;
next	1.80.2.8;

1.80.2.8
date	2003.05.01.00.46.41;	author carlton;	state Exp;
branches;
next	1.80.2.9;

1.80.2.9
date	2003.05.23.18.40.25;	author carlton;	state Exp;
branches;
next	1.80.2.10;

1.80.2.10
date	2003.06.27.21.49.19;	author carlton;	state Exp;
branches;
next	1.80.2.11;

1.80.2.11
date	2003.08.05.17.12.50;	author carlton;	state Exp;
branches;
next	1.80.2.12;

1.80.2.12
date	2003.09.17.21.27.53;	author carlton;	state Exp;
branches;
next	1.80.2.13;

1.80.2.13
date	2003.11.11.23.50.22;	author carlton;	state Exp;
branches;
next	1.80.2.14;

1.80.2.14
date	2003.12.15.23.59.34;	author carlton;	state Exp;
branches;
next	;

1.77.2.1
date	2002.07.20.04.18.02;	author thorpej;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	1.77.2.3;

1.77.2.3
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	1.77.2.4;

1.77.2.4
date	2002.10.15.01.17.04;	author rth;	state Exp;
branches;
next	1.77.2.5;

1.77.2.5
date	2002.10.28.18.45.44;	author drow;	state Exp;
branches;
next	;

1.62.4.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.62.6.1
date	2002.06.20.01.30.26;	author kseitz;	state Exp;
branches;
next	1.62.6.2;

1.62.6.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	1.62.6.3;

1.62.6.3
date	2002.10.01.00.45.47;	author kseitz;	state Exp;
branches;
next	1.62.6.4;

1.62.6.4
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.56.2.1
date	2002.02.15.21.24.36;	author rth;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2002.02.19.13.10.25;	author jakub;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	1.56.2.4;

1.56.2.4
date	2002.05.02.17.48.14;	author rth;	state Exp;
branches;
next	1.56.2.5;

1.56.2.5
date	2002.07.20.04.24.21;	author thorpej;	state Exp;
branches;
next	;

1.19.2.1
date	2001.01.30.09.53.00;	author rth;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.05.04.23.23.02;	author rth;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.06.11.10.04.13;	author amodra;	state Exp;
branches;
next	;

1.7.2.1
date	2000.04.04.11.23.34;	author amodra;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2000.10.23.12.38.15;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.193
log
@bfd/
	* elf64-alpha.c (elf64_alpha_relax_tls_get_addr): Cast switch
	expression to int to silence over-eager compiler warnings.
@
text
@/* Alpha specific support for 64-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
   Contributed by Richard Henderson <rth@@tamu.edu>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* We need a published ABI spec for this.  Until one comes out, don't
   assume this'll remain unchanged forever.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"

#include "elf/alpha.h"

#define ALPHAECOFF

#define NO_COFF_RELOCS
#define NO_COFF_SYMBOLS
#define NO_COFF_LINENOS

/* Get the ECOFF swapping routines.  Needed for the debug information.  */
#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "coff/alpha.h"
#include "aout/ar.h"
#include "libcoff.h"
#include "libecoff.h"
#define ECOFF_64
#include "ecoffswap.h"


/* Instruction data for plt generation and relaxation.  */

#define OP_LDA		0x08
#define OP_LDAH		0x09
#define OP_LDQ		0x29
#define OP_BR		0x30
#define OP_BSR		0x34

#define INSN_LDA	(OP_LDA << 26)
#define INSN_LDAH	(OP_LDAH << 26)
#define INSN_LDQ	(OP_LDQ << 26)
#define INSN_BR		(OP_BR << 26)

#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e
#define INSN_SUBQ	0x40000520
#define INSN_S4SUBQ	0x40000560
#define INSN_UNOP	0x2ffe0000

#define INSN_JSR	0x68004000
#define INSN_JMP	0x68000000
#define INSN_JSR_MASK	0xfc00c000

#define INSN_A(I,A)		(I | (A << 21))
#define INSN_AB(I,A,B)		(I | (A << 21) | (B << 16))
#define INSN_ABC(I,A,B,C)	(I | (A << 21) | (B << 16) | C)
#define INSN_ABO(I,A,B,O)	(I | (A << 21) | (B << 16) | ((O) & 0xffff))
#define INSN_AD(I,A,D)		(I | (A << 21) | (((D) >> 2) & 0x1fffff))

/* PLT/GOT Stuff */

/* Set by ld emulation.  Putting this into the link_info or hash structure
   is simply working too hard.  */
#ifdef USE_SECUREPLT
bfd_boolean elf64_alpha_use_secureplt = TRUE;
#else
bfd_boolean elf64_alpha_use_secureplt = FALSE;
#endif

#define OLD_PLT_HEADER_SIZE	32
#define OLD_PLT_ENTRY_SIZE	12
#define NEW_PLT_HEADER_SIZE	36
#define NEW_PLT_ENTRY_SIZE	4

#define PLT_HEADER_SIZE \
  (elf64_alpha_use_secureplt ? NEW_PLT_HEADER_SIZE : OLD_PLT_HEADER_SIZE)
#define PLT_ENTRY_SIZE \
  (elf64_alpha_use_secureplt ? NEW_PLT_ENTRY_SIZE : OLD_PLT_ENTRY_SIZE)

#define MAX_GOT_SIZE		(64*1024)

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so"


/* Used to implement multiple .got subsections.  */
struct alpha_elf_got_entry
{
  struct alpha_elf_got_entry *next;

  /* Which .got subsection?  */
  bfd *gotobj;

  /* The addend in effect for this entry.  */
  bfd_vma addend;

  /* The .got offset for this entry.  */
  int got_offset;

  /* The .plt offset for this entry.  */
  int plt_offset;

  /* How many references to this entry?  */
  int use_count;

  /* The relocation type of this entry.  */
  unsigned char reloc_type;

  /* How a LITERAL is used.  */
  unsigned char flags;

  /* Have we initialized the dynamic relocation for this entry?  */
  unsigned char reloc_done;

  /* Have we adjusted this entry for SEC_MERGE?  */
  unsigned char reloc_xlated;
};

struct alpha_elf_reloc_entry
{
  struct alpha_elf_reloc_entry *next;

  /* Which .reloc section? */
  asection *srel;

  /* What kind of relocation? */
  unsigned int rtype;

  /* Is this against read-only section? */
  unsigned int reltext : 1;

  /* How many did we find?  */
  unsigned long count;
};

struct alpha_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Cumulative flags for all the .got entries.  */
  int flags;

  /* Contexts in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR	 0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	 0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	 0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	 0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	 0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	 0x20
#define ALPHA_ELF_LINK_HASH_LU_JSRDIRECT 0x40
#define ALPHA_ELF_LINK_HASH_LU_PLT	 0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	 0x80

  /* Used to implement multiple .got subsections.  */
  struct alpha_elf_got_entry *got_entries;

  /* Used to count non-got, non-plt relocations for delayed sizing
     of relocation sections.  */
  struct alpha_elf_reloc_entry *reloc_entries;
};

/* Alpha ELF linker hash table.  */

struct alpha_elf_link_hash_table
{
  struct elf_link_hash_table root;

  /* The head of a list of .got subsections linked through
     alpha_elf_tdata(abfd)->got_link_next.  */
  bfd *got_list;

  /* The most recent relax pass that we've seen.  The GOTs
     should be regenerated if this doesn't match.  */
  int relax_trip;
};

/* Look up an entry in a Alpha ELF linker hash table.  */

#define alpha_elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct alpha_elf_link_hash_entry *)					\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse a Alpha ELF linker hash table.  */

#define alpha_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the Alpha ELF linker hash table from a link_info structure.  */

#define alpha_elf_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == ALPHA_ELF_DATA ? ((struct alpha_elf_link_hash_table *) ((p)->hash)) : NULL)

/* Get the object's symbols as our own entry type.  */

#define alpha_elf_sym_hashes(abfd) \
  ((struct alpha_elf_link_hash_entry **)elf_sym_hashes(abfd))

/* Should we do dynamic things to this symbol?  This differs from the
   generic version in that we never need to consider function pointer
   equality wrt PLT entries -- we don't create a PLT entry if a symbol's
   address is ever taken.  */

static inline bfd_boolean
alpha_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
			    struct bfd_link_info *info)
{
  return _bfd_elf_dynamic_symbol_p (h, info, 0);
}

/* Create an entry in a Alpha ELF linker hash table.  */

static struct bfd_hash_entry *
elf64_alpha_link_hash_newfunc (struct bfd_hash_entry *entry,
			       struct bfd_hash_table *table,
			       const char *string)
{
  struct alpha_elf_link_hash_entry *ret =
    (struct alpha_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct alpha_elf_link_hash_entry *) NULL)
    ret = ((struct alpha_elf_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct alpha_elf_link_hash_entry)));
  if (ret == (struct alpha_elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct alpha_elf_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct alpha_elf_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->flags = 0;
      ret->got_entries = NULL;
      ret->reloc_entries = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a Alpha ELF linker hash table.  */

static struct bfd_link_hash_table *
elf64_alpha_bfd_link_hash_table_create (bfd *abfd)
{
  struct alpha_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct alpha_elf_link_hash_table);

  ret = (struct alpha_elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == (struct alpha_elf_link_hash_table *) NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      elf64_alpha_link_hash_newfunc,
				      sizeof (struct alpha_elf_link_hash_entry),
				      ALPHA_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Alpha ELF follows MIPS ELF in using a special find_nearest_line
   routine in order to handle the ECOFF debugging information.  */

struct alpha_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

/* We have some private fields hanging off of the elf_tdata structure.  */

struct alpha_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* For every input file, these are the got entries for that object's
     local symbols.  */
  struct alpha_elf_got_entry ** local_got_entries;

  /* For every input file, this is the object that owns the got that
     this input file uses.  */
  bfd *gotobj;

  /* For every got, this is a linked list through the objects using this got */
  bfd *in_got_link_next;

  /* For every got, this is a link to the next got subsegment.  */
  bfd *got_link_next;

  /* For every got, this is the section.  */
  asection *got;

  /* For every got, this is it's total number of words.  */
  int total_got_size;

  /* For every got, this is the sum of the number of words required
     to hold all of the member object's local got.  */
  int local_got_size;

  /* Used by elf64_alpha_find_nearest_line entry point.  */
  struct alpha_elf_find_line *find_line_info;

};

#define alpha_elf_tdata(abfd) \
  ((struct alpha_elf_obj_tdata *) (abfd)->tdata.any)

#define is_alpha_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_tdata (bfd) != NULL \
   && elf_object_id (bfd) == ALPHA_ELF_DATA)

static bfd_boolean
elf64_alpha_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct alpha_elf_obj_tdata),
				  ALPHA_ELF_DATA);
}

static bfd_boolean
elf64_alpha_object_p (bfd *abfd)
{
  /* Set the right machine number for an Alpha ELF file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_alpha, 0);
}

/* A relocation function which doesn't do anything.  */

static bfd_reloc_status_type
elf64_alpha_reloc_nil (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc,
		       asymbol *sym ATTRIBUTE_UNUSED,
		       void * data ATTRIBUTE_UNUSED, asection *sec,
		       bfd *output_bfd, char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_ok;
}

/* A relocation function used for an unsupported reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_bad (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc,
		       asymbol *sym ATTRIBUTE_UNUSED,
		       void * data ATTRIBUTE_UNUSED, asection *sec,
		       bfd *output_bfd, char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_notsupported;
}

/* Do the work of the GPDISP relocation.  */

static bfd_reloc_status_type
elf64_alpha_do_reloc_gpdisp (bfd *abfd, bfd_vma gpdisp, bfd_byte *p_ldah,
			     bfd_byte *p_lda)
{
  bfd_reloc_status_type ret = bfd_reloc_ok;
  bfd_vma addend;
  unsigned long i_ldah, i_lda;

  i_ldah = bfd_get_32 (abfd, p_ldah);
  i_lda = bfd_get_32 (abfd, p_lda);

  /* Complain if the instructions are not correct.  */
  if (((i_ldah >> 26) & 0x3f) != 0x09
      || ((i_lda >> 26) & 0x3f) != 0x08)
    ret = bfd_reloc_dangerous;

  /* Extract the user-supplied offset, mirroring the sign extensions
     that the instructions perform.  */
  addend = ((i_ldah & 0xffff) << 16) | (i_lda & 0xffff);
  addend = (addend ^ 0x80008000) - 0x80008000;

  gpdisp += addend;

  if ((bfd_signed_vma) gpdisp < -(bfd_signed_vma) 0x80000000
      || (bfd_signed_vma) gpdisp >= (bfd_signed_vma) 0x7fff8000)
    ret = bfd_reloc_overflow;

  /* compensate for the sign extension again.  */
  i_ldah = ((i_ldah & 0xffff0000)
	    | (((gpdisp >> 16) + ((gpdisp >> 15) & 1)) & 0xffff));
  i_lda = (i_lda & 0xffff0000) | (gpdisp & 0xffff);

  bfd_put_32 (abfd, (bfd_vma) i_ldah, p_ldah);
  bfd_put_32 (abfd, (bfd_vma) i_lda, p_lda);

  return ret;
}

/* The special function for the GPDISP reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_gpdisp (bfd *abfd, arelent *reloc_entry,
			  asymbol *sym ATTRIBUTE_UNUSED, void * data,
			  asection *input_section, bfd *output_bfd,
			  char **err_msg)
{
  bfd_reloc_status_type ret;
  bfd_vma gp, relocation;
  bfd_vma high_address;
  bfd_byte *p_ldah, *p_lda;

  /* Don't do anything if we're not doing a final link.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  high_address = bfd_get_section_limit (abfd, input_section);
  if (reloc_entry->address > high_address
      || reloc_entry->address + reloc_entry->addend > high_address)
    return bfd_reloc_outofrange;

  /* The gp used in the portion of the output object to which this
     input object belongs is cached on the input bfd.  */
  gp = _bfd_get_gp_value (abfd);

  relocation = (input_section->output_section->vma
		+ input_section->output_offset
		+ reloc_entry->address);

  p_ldah = (bfd_byte *) data + reloc_entry->address;
  p_lda = p_ldah + reloc_entry->addend;

  ret = elf64_alpha_do_reloc_gpdisp (abfd, gp - relocation, p_ldah, p_lda);

  /* Complain if the instructions are not correct.  */
  if (ret == bfd_reloc_dangerous)
    *err_msg = _("GPDISP relocation did not find ldah and lda instructions");

  return ret;
}

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)


#define SKIP_HOWTO(N) \
  HOWTO(N, 0, 0, 0, 0, 0, complain_overflow_dont, elf64_alpha_reloc_bad, 0, 0, 0, 0, 0)

static reloc_howto_type elf64_alpha_howto_table[] =
{
  HOWTO (R_ALPHA_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_nil,	/* special_function */
	 "NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit reference to a symbol.  */
  HOWTO (R_ALPHA_REFLONG,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "REFLONG",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit reference to a symbol.  */
  HOWTO (R_ALPHA_REFQUAD,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "REFQUAD",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit GP relative offset.  This is just like REFLONG except
     that when the value is used the value of the gp register will be
     added in.  */
  HOWTO (R_ALPHA_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GPREL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used for an instruction that refers to memory off the GP register.  */
  HOWTO (R_ALPHA_LITERAL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "ELF_LITERAL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This reloc only appears immediately following an ELF_LITERAL reloc.
     It identifies a use of the literal.  The symbol index is special:
     1 means the literal address is in the base register of a memory
     format instruction; 2 means the literal address is in the byte
     offset register of a byte-manipulation instruction; 3 means the
     literal address is in the target register of a jsr instruction.
     This does not actually do any relocation.  */
  HOWTO (R_ALPHA_LITUSE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_nil,	/* special_function */
	 "LITUSE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Load the gp register.  This is always used for a ldah instruction
     which loads the upper 16 bits of the gp register.  The symbol
     index of the GPDISP instruction is an offset in bytes to the lda
     instruction that loads the lower 16 bits.  The value to use for
     the relocation is the difference between the GP value and the
     current location; the load will always be done against a register
     holding the current address.

     NOTE: Unlike ECOFF, partial in-place relocation is not done.  If
     any offset is present in the instructions, it is an offset from
     the register to the ldah instruction.  This lets us avoid any
     stupid hackery like inventing a gp value to do partial relocation
     against.  Also unlike ECOFF, we do the whole relocation off of
     the GPDISP rather than a GPDISP_HI16/GPDISP_LO16 pair.  An odd,
     space consuming bit, that, since all the information was present
     in the GPDISP_HI16 reloc.  */
  HOWTO (R_ALPHA_GPDISP,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_gpdisp, /* special_function */
	 "GPDISP",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 21 bit branch.  */
  HOWTO (R_ALPHA_BRADDR,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "BRADDR",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A hint for a jump to a register.  */
  HOWTO (R_ALPHA_HINT,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 14,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "HINT",		/* name */
	 FALSE,			/* partial_inplace */
	 0x3fff,		/* src_mask */
	 0x3fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "SREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 32 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "SREL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 64 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "SREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Skip 12 - 16; deprecated ECOFF relocs.  */
  SKIP_HOWTO (12),
  SKIP_HOWTO (13),
  SKIP_HOWTO (14),
  SKIP_HOWTO (15),
  SKIP_HOWTO (16),

  /* The high 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELHIGH,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GPRELHIGH",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELLOW,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GPRELLOW",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from the GP to the target.  */
  HOWTO (R_ALPHA_GPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Skip 20 - 23; deprecated ECOFF relocs.  */
  SKIP_HOWTO (20),
  SKIP_HOWTO (21),
  SKIP_HOWTO (22),
  SKIP_HOWTO (23),

  /* Misc ELF relocations.  */

  /* A dynamic relocation to copy the target into our .dynbss section.  */
  /* Not generated, as all Alpha objects use PIC, so it is not needed.  It
     is present because every other ELF has one, but should not be used
     because .dynbss is an ugly thing.  */
  HOWTO (R_ALPHA_COPY,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "COPY",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation for a .got entry.  */
  HOWTO (R_ALPHA_GLOB_DAT,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "GLOB_DAT",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation for a .plt entry.  */
  HOWTO (R_ALPHA_JMP_SLOT,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "JMP_SLOT",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation to add the base of the DSO to a 64-bit field.  */
  HOWTO (R_ALPHA_RELATIVE,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "RELATIVE",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A 21 bit branch that adjusts for gp loads.  */
  HOWTO (R_ALPHA_BRSGP,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "BRSGP",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Creates a tls_index for the symbol in the got.  */
  HOWTO (R_ALPHA_TLSGD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TLSGD",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a tls_index for the (current) module in the got.  */
  HOWTO (R_ALPHA_TLSLDM,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TLSLDM",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a DTP module entry.  */
  HOWTO (R_ALPHA_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "DTPMOD64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from DTP to the target.  */
  HOWTO (R_ALPHA_GOTDTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GOTDTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "DTPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "DTPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "DTPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "DTPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from TP to the target.  */
  HOWTO (R_ALPHA_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "GOTTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "TPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* A mapping from BFD reloc types to Alpha ELF reloc types.  */

struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  int elf_reloc_val;
};

static const struct elf_reloc_map elf64_alpha_reloc_map[] =
{
  {BFD_RELOC_NONE,			R_ALPHA_NONE},
  {BFD_RELOC_32,			R_ALPHA_REFLONG},
  {BFD_RELOC_64,			R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,			R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,			R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_ELF_LITERAL,		R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,		R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,		R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,		R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,			R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,			R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,			R_ALPHA_SREL64},
  {BFD_RELOC_ALPHA_GPREL_HI16,		R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_GPREL_LO16,		R_ALPHA_GPRELLOW},
  {BFD_RELOC_GPREL16,			R_ALPHA_GPREL16},
  {BFD_RELOC_ALPHA_BRSGP,		R_ALPHA_BRSGP},
  {BFD_RELOC_ALPHA_TLSGD,		R_ALPHA_TLSGD},
  {BFD_RELOC_ALPHA_TLSLDM,		R_ALPHA_TLSLDM},
  {BFD_RELOC_ALPHA_DTPMOD64,		R_ALPHA_DTPMOD64},
  {BFD_RELOC_ALPHA_GOTDTPREL16,		R_ALPHA_GOTDTPREL},
  {BFD_RELOC_ALPHA_DTPREL64,		R_ALPHA_DTPREL64},
  {BFD_RELOC_ALPHA_DTPREL_HI16,		R_ALPHA_DTPRELHI},
  {BFD_RELOC_ALPHA_DTPREL_LO16,		R_ALPHA_DTPRELLO},
  {BFD_RELOC_ALPHA_DTPREL16,		R_ALPHA_DTPREL16},
  {BFD_RELOC_ALPHA_GOTTPREL16,		R_ALPHA_GOTTPREL},
  {BFD_RELOC_ALPHA_TPREL64,		R_ALPHA_TPREL64},
  {BFD_RELOC_ALPHA_TPREL_HI16,		R_ALPHA_TPRELHI},
  {BFD_RELOC_ALPHA_TPREL_LO16,		R_ALPHA_TPRELLO},
  {BFD_RELOC_ALPHA_TPREL16,		R_ALPHA_TPREL16},
};

/* Given a BFD reloc type, return a HOWTO structure.  */

static reloc_howto_type *
elf64_alpha_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				   bfd_reloc_code_real_type code)
{
  const struct elf_reloc_map *i, *e;
  i = e = elf64_alpha_reloc_map;
  e += sizeof (elf64_alpha_reloc_map) / sizeof (struct elf_reloc_map);
  for (; i != e; ++i)
    {
      if (i->bfd_reloc_val == code)
	return &elf64_alpha_howto_table[i->elf_reloc_val];
    }
  return 0;
}

static reloc_howto_type *
elf64_alpha_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				   const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (elf64_alpha_howto_table)
	    / sizeof (elf64_alpha_howto_table[0]));
       i++)
    if (elf64_alpha_howto_table[i].name != NULL
	&& strcasecmp (elf64_alpha_howto_table[i].name, r_name) == 0)
      return &elf64_alpha_howto_table[i];

  return NULL;
}

/* Given an Alpha ELF reloc type, fill in an arelent structure.  */

static void
elf64_alpha_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			   Elf_Internal_Rela *dst)
{
  unsigned r_type = ELF64_R_TYPE(dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_ALPHA_max);
  cache_ptr->howto = &elf64_alpha_howto_table[r_type];
}

/* These two relocations create a two-word entry in the got.  */
#define alpha_got_entry_size(r_type) \
  (r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)

/* This is PT_TLS segment p_vaddr.  */
#define alpha_get_dtprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma)

/* Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */
#define alpha_get_tprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma					\
   - align_power ((bfd_vma) 16,						\
		  elf_hash_table (info)->tls_sec->alignment_power))

/* Handle an Alpha specific section when reading an object file.  This
   is called when bfd_section_from_shdr finds a section with an unknown
   type.
   FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure
   how to.  */

static bfd_boolean
elf64_alpha_section_from_shdr (bfd *abfd,
			       Elf_Internal_Shdr *hdr,
			       const char *name,
			       int shindex)
{
  asection *newsect;

  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_ALPHA_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return FALSE;
      break;
    default:
      return FALSE;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;
  newsect = hdr->bfd_section;

  if (hdr->sh_type == SHT_ALPHA_DEBUG)
    {
      if (! bfd_set_section_flags (abfd, newsect,
				   (bfd_get_section_flags (abfd, newsect)
				    | SEC_DEBUGGING)))
	return FALSE;
    }

  return TRUE;
}

/* Convert Alpha specific section flags to bfd internal section flags.  */

static bfd_boolean
elf64_alpha_section_flags (flagword *flags, const Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_flags & SHF_ALPHA_GPREL)
    *flags |= SEC_SMALL_DATA;

  return TRUE;
}

/* Set the correct type for an Alpha ELF section.  We do this by the
   section name, which is a hack, but ought to work.  */

static bfd_boolean
elf64_alpha_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_ALPHA_DEBUG;
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if ((abfd->flags & DYNAMIC) != 0 )
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if ((sec->flags & SEC_SMALL_DATA)
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_ALPHA_GPREL;

  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */

static bfd_boolean
elf64_alpha_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			     Elf_Internal_Sym *sym,
			     const char **namep ATTRIBUTE_UNUSED,
			     flagword *flagsp ATTRIBUTE_UNUSED,
			     asection **secp, bfd_vma *valp)
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && sym->st_size <= elf_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section_with_flags (abfd, ".scommon",
					       (SEC_ALLOC
						| SEC_IS_COMMON
						| SEC_LINKER_CREATED));
	  if (scomm == NULL)
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}

/* Create the .got section.  */

static bfd_boolean
elf64_alpha_create_got_section (bfd *abfd,
				struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  flagword flags;
  asection *s;

  if (! is_alpha_elf (abfd))
    return FALSE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  alpha_elf_tdata (abfd)->got = s;

  /* Make sure the object's gotobj is set to itself so that we default
     to every object with its own .got.  We'll merge .gots later once
     we've collected each object's info.  */
  alpha_elf_tdata (abfd)->gotobj = abfd;

  return TRUE;
}

/* Create all the dynamic sections.  */

static bfd_boolean
elf64_alpha_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  asection *s;
  flagword flags;
  struct elf_link_hash_entry *h;

  if (! is_alpha_elf (abfd))
    return FALSE;

  /* We need to create .plt, .rela.plt, .got, and .rela.got sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED
	   | (elf64_alpha_use_secureplt ? SEC_READONLY : 0));
  s = bfd_make_section_anyway_with_flags (abfd, ".plt", flags);
  if (s == NULL || ! bfd_set_section_alignment (abfd, s, 4))
    return FALSE;

  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
     .plt section.  */
  h = _bfd_elf_define_linkage_sym (abfd, info, s,
				   "_PROCEDURE_LINKAGE_TABLE_");
  elf_hash_table (info)->hplt = h;
  if (h == NULL)
    return FALSE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);
  s = bfd_make_section_anyway_with_flags (abfd, ".rela.plt", flags);
  if (s == NULL || ! bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  if (elf64_alpha_use_secureplt)
    {
      flags = SEC_ALLOC | SEC_LINKER_CREATED;
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
      if (s == NULL || ! bfd_set_section_alignment (abfd, s, 3))
	return FALSE;
    }

  /* We may or may not have created a .got section for this object, but
     we definitely havn't done the rest of the work.  */

  if (alpha_elf_tdata(abfd)->gotobj == NULL)
    {
      if (!elf64_alpha_create_got_section (abfd, info))
	return FALSE;
    }

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);
  s = bfd_make_section_anyway_with_flags (abfd, ".rela.got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the
     dynobj's .got section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  h = _bfd_elf_define_linkage_sym (abfd, info, alpha_elf_tdata(abfd)->got,
				   "_GLOBAL_OFFSET_TABLE_");
  elf_hash_table (info)->hgot = h;
  if (h == NULL)
    return FALSE;

  return TRUE;
}

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */

static bfd_boolean
elf64_alpha_read_ecoff_info (bfd *abfd, asection *section,
			     struct ecoff_debug_info *debug)
{
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));

  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;

  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = (type) bfd_malloc (amt);				\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
	goto error_return;						\
    }

  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, void *);
#undef READ

  debug->fdr = NULL;

  return TRUE;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return FALSE;
}

/* Alpha ELF local labels start with '$'.  */

static bfd_boolean
elf64_alpha_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED, const char *name)
{
  return name[0] == '$';
}

static bfd_boolean
elf64_alpha_find_nearest_line (bfd *abfd, asection *section, asymbol **symbols,
			       bfd_vma offset, const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *line_ptr)
{
  asection *msec;

  if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
                                     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, NULL, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return TRUE;

  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct alpha_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

      /* If we are called during a link, alpha_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;

      fi = alpha_elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;
	  bfd_size_type amt = sizeof (struct alpha_elf_find_line);

	  fi = (struct alpha_elf_find_line *) bfd_zalloc (abfd, amt);
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  if (!elf64_alpha_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  /* Swap in the FDR information.  */
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, fraw_src, fdr_ptr);

	  alpha_elf_tdata (abfd)->find_line_info = fi;

	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}

      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
	{
	  msec->flags = origflags;
	  return TRUE;
	}

      msec->flags = origflags;
    }

  /* Fall back on the generic ELF find_nearest_line routine.  */

  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
}

/* Structure used to pass information to alpha_elf_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  bfd_boolean failed;
};

static bfd_boolean
elf64_alpha_output_extsym (struct alpha_elf_link_hash_entry *h, void * data)
{
  struct extsym_info *einfo = (struct extsym_info *) data;
  bfd_boolean strip;
  asection *sec, *output_section;

  if (h->root.indx == -2)
    strip = FALSE;
  else if ((h->root.def_dynamic
	    || h->root.ref_dynamic
	    || h->root.root.type == bfd_link_hash_new)
	   && !h->root.def_regular
	   && !h->root.ref_regular)
    strip = TRUE;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
  else
    strip = FALSE;

  if (strip)
    return TRUE;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Search for and possibly create a got entry.  */

static struct alpha_elf_got_entry *
get_got_entry (bfd *abfd, struct alpha_elf_link_hash_entry *h,
	       unsigned long r_type, unsigned long r_symndx,
	       bfd_vma r_addend)
{
  struct alpha_elf_got_entry *gotent;
  struct alpha_elf_got_entry **slot;

  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */

      struct alpha_elf_got_entry **local_got_entries;

      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);

	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;

	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
    {
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->plt_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
    }
  else
    gotent->use_count += 1;

  return gotent;
}

static bfd_boolean
elf64_alpha_want_plt (struct alpha_elf_link_hash_entry *ah)
{
  return ((ah->root.type == STT_FUNC
	  || ah->root.root.type == bfd_link_hash_undefweak
	  || ah->root.root.type == bfd_link_hash_undefined)
	  && (ah->flags & ALPHA_ELF_LINK_HASH_LU_PLT) != 0
	  && (ah->flags & ~ALPHA_ELF_LINK_HASH_LU_PLT) == 0);
}

/* Handle dynamic relocations when doing an Alpha ELF link.  */

static bfd_boolean
elf64_alpha_check_relocs (bfd *abfd, struct bfd_link_info *info,
			  asection *sec, const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  asection *sreloc;
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  bfd_size_type amt;

  if (info->relocatable)
    return TRUE;

  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  BFD_ASSERT (is_alpha_elf (abfd));

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    elf_hash_table (info)->dynobj = dynobj = abfd;

  sreloc = NULL;
  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = alpha_elf_sym_hashes (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; ++rel)
    {
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };

      unsigned long r_symndx, r_type;
      struct alpha_elf_link_hash_entry *h;
      unsigned int gotent_flags;
      bfd_boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.root.non_ir_ref = 1;
	  h->root.ref_regular = 1;
	}

      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = FALSE;
      if (h && ((info->shared
		 && (!info->symbolic
		     || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !h->root.def_regular
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = TRUE;

      need = 0;
      gotent_flags = 0;
      r_type = ELF64_R_TYPE (rel->r_info);
      addend = rel->r_addend;

      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  need = NEED_GOT | NEED_GOT_ENTRY;

	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 6)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;

	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;

	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL16:
	case R_ALPHA_GPREL32:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_BRSGP:
	  need = NEED_GOT;
	  break;

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;

	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the STN_UNDEF (0) symbol so that they all match.  */
	  r_symndx = STN_UNDEF;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;

	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_ALPHA_TPREL64:
	  if (info->shared && !info->pie)
	    {
	      info->flags |= DF_STATIC_TLS;
	      need = NEED_DYNREL;
	    }
	  else if (maybe_dynamic)
	    need = NEED_DYNREL;
	  break;
	}

      if (need & NEED_GOT)
	{
	  if (alpha_elf_tdata(abfd)->gotobj == NULL)
	    {
	      if (!elf64_alpha_create_got_section (abfd, info))
		return FALSE;
	    }
	}

      if (need & NEED_GOT_ENTRY)
	{
	  struct alpha_elf_got_entry *gotent;

	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
	    return FALSE;

	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;

		  /* Make a guess as to whether a .plt entry is needed.  */
		  /* ??? It appears that we won't make it into
		     adjust_dynamic_symbol for symbols that remain
		     totally undefined.  Copying this check here means
		     we can create a plt entry for them too.  */
		  h->root.needs_plt
		    = (maybe_dynamic && elf64_alpha_want_plt (h));
		}
	    }
	}

      if (need & NEED_DYNREL)
	{
	  /* We need to create the section here now whether we eventually
	     use it or not so that it gets mapped to an output section by
	     the linker.  If not used, we'll kill it in size_dynamic_sections.  */
	  if (sreloc == NULL)
	    {
	      sreloc = _bfd_elf_make_dynamic_reloc_section
		(sec, dynobj, 3, abfd, /*rela?*/ TRUE);

	      if (sreloc == NULL)
		return FALSE;
	    }

	  if (h)
	    {
	      /* Since we havn't seen all of the input symbols yet, we
		 don't know whether we'll actually need a dynamic relocation
		 entry for this reloc.  So make a record of it.  Once we
		 find out if this thing needs dynamic relocation we'll
		 expand the relocation sections by the appropriate amount.  */

	      struct alpha_elf_reloc_entry *rent;

	      for (rent = h->reloc_entries; rent; rent = rent->next)
		if (rent->rtype == r_type && rent->srel == sreloc)
		  break;

	      if (!rent)
		{
		  amt = sizeof (struct alpha_elf_reloc_entry);
		  rent = (struct alpha_elf_reloc_entry *) bfd_alloc (abfd, amt);
		  if (!rent)
		    return FALSE;

		  rent->srel = sreloc;
		  rent->rtype = r_type;
		  rent->count = 1;
		  rent->reltext = (sec->flags & SEC_READONLY) != 0;

		  rent->next = h->reloc_entries;
		  h->reloc_entries = rent;
		}
	      else
		rent->count++;
	    }
	  else if (info->shared)
	    {
	      /* If this is a shared library, and the section is to be
		 loaded into memory, we need a RELATIVE reloc.  */
	      sreloc->size += sizeof (Elf64_External_Rela);
	      if (sec->flags & SEC_READONLY)
		info->flags |= DF_TEXTREL;
	    }
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf64_alpha_gc_mark_hook (asection *sec, struct bfd_link_info *info,
			  Elf_Internal_Rela *rel,
			  struct elf_link_hash_entry *h, Elf_Internal_Sym *sym)
{
  /* These relocations don't really reference a symbol.  Instead we store
     extra data in their addend slot.  Ignore the symbol.  */
  switch (ELF64_R_TYPE (rel->r_info))
    {
    case R_ALPHA_LITUSE:
    case R_ALPHA_GPDISP:
    case R_ALPHA_HINT:
      return NULL;
    }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf64_alpha_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			   asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = alpha_elf_sym_hashes (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx, r_type;
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;
	}

      r_type = ELF64_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  /* ??? Ignore re-computation of gotent_flags.  We're not
	     carrying a use-count for each bit in that mask.  */

	case R_ALPHA_TLSGD:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  /* Fetch the got entry from the tables.  */
	  gotent = get_got_entry (abfd, h, r_type, r_symndx, rel->r_addend);

	  /* The got entry *must* exist, since we should have created it
	     before during check_relocs.  Also note that get_got_entry
	     assumed this was going to be another use, and so incremented
	     the use count again.  Thus the use count must be at least the
	     one real use and the "use" we just added.  */
	  if (gotent == NULL || gotent->use_count < 2)
	    {
	      abort ();
	      return FALSE;
	    }
	  gotent->use_count -= 2;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf64_alpha_adjust_dynamic_symbol (struct bfd_link_info *info,
				   struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;
  struct alpha_elf_link_hash_entry *ah;

  dynobj = elf_hash_table(info)->dynobj;
  ah = (struct alpha_elf_link_hash_entry *)h;

  /* Now that we've seen all of the input symbols, finalize our decision
     about whether this symbol should get a .plt entry.  Irritatingly, it
     is common for folk to leave undefined symbols in shared libraries,
     and they still expect lazy binding; accept undefined symbols in lieu
     of STT_FUNC.  */
  if (alpha_elf_dynamic_symbol_p (h, info) && elf64_alpha_want_plt (ah))
    {
      h->needs_plt = TRUE;

      s = bfd_get_linker_section (dynobj, ".plt");
      if (!s && !elf64_alpha_create_dynamic_sections (dynobj, info))
	return FALSE;

      /* We need one plt entry per got subsection.  Delay allocation of
	 the actual plt entries until size_plt_section, called from
	 size_dynamic_sections or during relaxation.  */

      return TRUE;
    }
  else
    h->needs_plt = FALSE;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  The Alpha, since it uses .got entries for all
     symbols even in regular objects, does not need the hackery of a
     .dynbss section and COPY dynamic relocations.  */

  return TRUE;
}

/* Record STO_ALPHA_NOPV and STO_ALPHA_STD_GPLOAD.  */

static void
elf64_alpha_merge_symbol_attribute (struct elf_link_hash_entry *h,
				    const Elf_Internal_Sym *isym,
				    bfd_boolean definition,
				    bfd_boolean dynamic)
{
  if (!dynamic && definition)
    h->other = ((h->other & ELF_ST_VISIBILITY (-1))
		| (isym->st_other & ~ELF_ST_VISIBILITY (-1)));
}

/* Symbol versioning can create new symbols, and make our old symbols
   indirect to the new ones.  Consolidate the got and reloc information
   in these situations.  */

static void
elf64_alpha_copy_indirect_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
{
  struct alpha_elf_link_hash_entry *hi
    = (struct alpha_elf_link_hash_entry *) ind;
  struct alpha_elf_link_hash_entry *hs
    = (struct alpha_elf_link_hash_entry *) dir;

  /* Do the merging in the superclass.  */
  _bfd_elf_link_hash_copy_indirect(info, dir, ind);

  /* Merge the flags.  Whee.  */
  hs->flags |= hi->flags;

  /* ??? It's unclear to me what's really supposed to happen when
     "merging" defweak and defined symbols, given that we don't
     actually throw away the defweak.  This more-or-less copies
     the logic related to got and plt entries in the superclass.  */
  if (ind->root.type != bfd_link_hash_indirect)
    return;

  /* Merge the .got entries.  Cannibalize the old symbol's list in
     doing so, since we don't need it anymore.  */

  if (hs->got_entries == NULL)
    hs->got_entries = hi->got_entries;
  else
    {
      struct alpha_elf_got_entry *gi, *gs, *gin, *gsh;

      gsh = hs->got_entries;
      for (gi = hi->got_entries; gi ; gi = gin)
	{
	  gin = gi->next;
	  for (gs = gsh; gs ; gs = gs->next)
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
	  gi->next = hs->got_entries;
	  hs->got_entries = gi;
	got_found:;
	}
    }
  hi->got_entries = NULL;

  /* And similar for the reloc entries.  */

  if (hs->reloc_entries == NULL)
    hs->reloc_entries = hi->reloc_entries;
  else
    {
      struct alpha_elf_reloc_entry *ri, *rs, *rin, *rsh;

      rsh = hs->reloc_entries;
      for (ri = hi->reloc_entries; ri ; ri = rin)
	{
	  rin = ri->next;
	  for (rs = rsh; rs ; rs = rs->next)
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
	      {
		rs->count += ri->count;
		goto found_reloc;
	      }
	  ri->next = hs->reloc_entries;
	  hs->reloc_entries = ri;
	found_reloc:;
	}
    }
  hi->reloc_entries = NULL;
}

/* Is it possible to merge two object file's .got tables?  */

static bfd_boolean
elf64_alpha_can_merge_gots (bfd *a, bfd *b)
{
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;

  /* Trivial quick fallout test.  */
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
    return TRUE;

  /* By their nature, local .got entries cannot be merged.  */
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
    return FALSE;

  /* Failing the common trivial comparison, we must effectively
     perform the merge.  Not actually performing the merge means that
     we don't have to store undo information in case we fail.  */
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes (bsub);
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (bsub)->symtab_hdr;
      int i, n;

      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
	{
	  struct alpha_elf_got_entry *ae, *be;
	  struct alpha_elf_link_hash_entry *h;

	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  for (be = h->got_entries; be ; be = be->next)
	    {
	      if (be->use_count == 0)
	        continue;
	      if (be->gotobj != b)
	        continue;

	      for (ae = h->got_entries; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  goto global_found;

	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
	        return FALSE;
	    global_found:;
	    }
	}
    }

  return TRUE;
}

/* Actually merge two .got tables.  */

static void
elf64_alpha_merge_gots (bfd *a, bfd *b)
{
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;

  /* Remember local expansion.  */
  {
    int e = alpha_elf_tdata (b)->local_got_size;
    total += e;
    alpha_elf_tdata (a)->local_got_size += e;
  }

  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_got_entry **local_got_entries;
      struct alpha_elf_link_hash_entry **hashes;
      Elf_Internal_Shdr *symtab_hdr;
      int i, n;

      /* Let the local .got entries know they are part of a new subsegment.  */
      local_got_entries = alpha_elf_tdata (bsub)->local_got_entries;
      if (local_got_entries)
        {
	  n = elf_tdata (bsub)->symtab_hdr.sh_info;
	  for (i = 0; i < n; ++i)
	    {
	      struct alpha_elf_got_entry *ent;
	      for (ent = local_got_entries[i]; ent; ent = ent->next)
	        ent->gotobj = a;
	    }
        }

      /* Merge the global .got entries.  */
      hashes = alpha_elf_sym_hashes (bsub);
      symtab_hdr = &elf_tdata (bsub)->symtab_hdr;

      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
        {
	  struct alpha_elf_got_entry *ae, *be, **pbe, **start;
	  struct alpha_elf_link_hash_entry *h;

	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  pbe = start = &h->got_entries;
	  while ((be = *pbe) != NULL)
	    {
	      if (be->use_count == 0)
	        {
		  *pbe = be->next;
		  memset (be, 0xa5, sizeof (*be));
		  goto kill;
	        }
	      if (be->gotobj != b)
	        goto next;

	      for (ae = *start; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  {
		    ae->flags |= be->flags;
		    ae->use_count += be->use_count;
		    *pbe = be->next;
		    memset (be, 0xa5, sizeof (*be));
		    goto kill;
		  }
	      be->gotobj = a;
	      total += alpha_got_entry_size (be->reloc_type);

	    next:;
	      pbe = &be->next;
	    kill:;
	    }
        }

      alpha_elf_tdata (bsub)->gotobj = a;
    }
  alpha_elf_tdata (a)->total_got_size = total;

  /* Merge the two in_got chains.  */
  {
    bfd *next;

    bsub = a;
    while ((next = alpha_elf_tdata (bsub)->in_got_link_next) != NULL)
      bsub = next;

    alpha_elf_tdata (bsub)->in_got_link_next = b;
  }
}

/* Calculate the offsets for the got entries.  */

static bfd_boolean
elf64_alpha_calc_got_offsets_for_symbol (struct alpha_elf_link_hash_entry *h,
					 void * arg ATTRIBUTE_UNUSED)
{
  struct alpha_elf_got_entry *gotent;

  for (gotent = h->got_entries; gotent; gotent = gotent->next)
    if (gotent->use_count > 0)
      {
	struct alpha_elf_obj_tdata *td;
	bfd_size_type *plge;

	td = alpha_elf_tdata (gotent->gotobj);
	plge = &td->got->size;
	gotent->got_offset = *plge;
	*plge += alpha_got_entry_size (gotent->reloc_type);
      }

  return TRUE;
}

static void
elf64_alpha_calc_got_offsets (struct bfd_link_info *info)
{
  bfd *i, *got_list;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return;
  got_list = htab->got_list;

  /* First, zero out the .got sizes, as we may be recalculating the
     .got after optimizing it.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    alpha_elf_tdata(i)->got->size = 0;

  /* Next, fill in the offsets for all the global entries.  */
  alpha_elf_link_hash_traverse (htab,
				elf64_alpha_calc_got_offsets_for_symbol,
				NULL);

  /* Finally, fill in the offsets for the local entries.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->size;
      bfd *j;

      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k]; gotent; gotent = gotent->next)
	      if (gotent->use_count > 0)
	        {
		  gotent->got_offset = got_offset;
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
	        }
	}

      alpha_elf_tdata(i)->got->size = got_offset;
    }
}

/* Constructs the gots.  */

static bfd_boolean
elf64_alpha_size_got_sections (struct bfd_link_info *info)
{
  bfd *i, *got_list, *cur_got_obj = NULL;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;
  got_list = htab->got_list;

  /* On the first time through, pretend we have an existing got list
     consisting of all of the input files.  */
  if (got_list == NULL)
    {
      for (i = info->input_bfds; i ; i = i->link_next)
	{
	  bfd *this_got;

	  if (! is_alpha_elf (i))
	    continue;

	  this_got = alpha_elf_tdata (i)->gotobj;
	  if (this_got == NULL)
	    continue;

	  /* We are assuming no merging has yet occurred.  */
	  BFD_ASSERT (this_got == i);

          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
	    {
	      /* Yikes! A single object file has too many entries.  */
	      (*_bfd_error_handler)
	        (_("%B: .got subsegment exceeds 64K (size %d)"),
	         i, alpha_elf_tdata (this_got)->total_got_size);
	      return FALSE;
	    }

	  if (got_list == NULL)
	    got_list = this_got;
	  else
	    alpha_elf_tdata(cur_got_obj)->got_link_next = this_got;
	  cur_got_obj = this_got;
	}

      /* Strange degenerate case of no got references.  */
      if (got_list == NULL)
	return TRUE;

      htab->got_list = got_list;
    }

  cur_got_obj = got_list;
  if (cur_got_obj == NULL)
    return FALSE;

  i = alpha_elf_tdata(cur_got_obj)->got_link_next;
  while (i != NULL)
    {
      if (elf64_alpha_can_merge_gots (cur_got_obj, i))
	{
	  elf64_alpha_merge_gots (cur_got_obj, i);

	  alpha_elf_tdata(i)->got->size = 0;
	  i = alpha_elf_tdata(i)->got_link_next;
	  alpha_elf_tdata(cur_got_obj)->got_link_next = i;
	}
      else
	{
	  cur_got_obj = i;
	  i = alpha_elf_tdata(i)->got_link_next;
	}
    }

  /* Once the gots have been merged, fill in the got offsets for
     everything therein.  */
  elf64_alpha_calc_got_offsets (info);

  return TRUE;
}

static bfd_boolean
elf64_alpha_size_plt_section_1 (struct alpha_elf_link_hash_entry *h,
				void * data)
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;
  bfd_boolean saw_one = FALSE;

  /* If we didn't need an entry before, we still don't.  */
  if (!h->root.needs_plt)
    return TRUE;

  /* For each LITERAL got entry still in use, allocate a plt entry.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      {
	if (splt->size == 0)
	  splt->size = PLT_HEADER_SIZE;
	gotent->plt_offset = splt->size;
	splt->size += PLT_ENTRY_SIZE;
	saw_one = TRUE;
      }

  /* If there weren't any, there's no longer a need for the PLT entry.  */
  if (!saw_one)
    h->root.needs_plt = FALSE;

  return TRUE;
}

/* Called from relax_section to rebuild the PLT in light of potential changes
   in the function's status.  */

static void
elf64_alpha_size_plt_section (struct bfd_link_info *info)
{
  asection *splt, *spltrel, *sgotplt;
  unsigned long entries;
  bfd *dynobj;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return;

  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_linker_section (dynobj, ".plt");
  if (splt == NULL)
    return;

  splt->size = 0;

  alpha_elf_link_hash_traverse (htab,
				elf64_alpha_size_plt_section_1, splt);

  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_linker_section (dynobj, ".rela.plt");
  entries = 0;
  if (splt->size)
    {
      if (elf64_alpha_use_secureplt)
	entries = (splt->size - NEW_PLT_HEADER_SIZE) / NEW_PLT_ENTRY_SIZE;
      else
	entries = (splt->size - OLD_PLT_HEADER_SIZE) / OLD_PLT_ENTRY_SIZE;
    }
  spltrel->size = entries * sizeof (Elf64_External_Rela);

  /* When using the secureplt, we need two words somewhere in the data
     segment for the dynamic linker to tell us where to go.  This is the
     entire contents of the .got.plt section.  */
  if (elf64_alpha_use_secureplt)
    {
      sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
      sgotplt->size = entries ? 16 : 0;
    }
}

static bfd_boolean
elf64_alpha_always_size_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
{
  bfd *i;
  struct alpha_elf_link_hash_table * htab;

  if (info->relocatable)
    return TRUE;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (!elf64_alpha_size_got_sections (info))
    return FALSE;

  /* Allocate space for all of the .got subsections.  */
  i = htab->got_list;
  for ( ; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      asection *s = alpha_elf_tdata(i)->got;
      if (s->size > 0)
	{
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->size);
	  if (s->contents == NULL)
	    return FALSE;
	}
    }

  return TRUE;
}

/* The number of dynamic relocations required by a static relocation.  */

static int
alpha_dynamic_entries_for_reloc (int r_type, int dynamic, int shared, int pie)
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
      return dynamic || shared;
    case R_ALPHA_GOTTPREL:
      return dynamic || (shared && !pie);
    case R_ALPHA_GOTDTPREL:
      return dynamic;

    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
      return dynamic || shared;
    case R_ALPHA_TPREL64:
      return dynamic || (shared && !pie);

    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
    default:
      return 0;
    }
}

/* Work out the sizes of the dynamic relocation entries.  */

static bfd_boolean
elf64_alpha_calc_dynrel_sizes (struct alpha_elf_link_hash_entry *h,
			       struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;

  /* If the symbol was defined as a common symbol in a regular object
     file, and there was no definition in any dynamic object, then the
     linker will have allocated space for the symbol in a common
     section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been
     set.  This is done for dynamic symbols in
     elf_adjust_dynamic_symbol but this is not done for non-dynamic
     symbols, somehow.  */
  if (!h->root.def_regular
      && h->root.ref_regular
      && !h->root.def_dynamic
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak)
      && !(h->root.root.u.def.section->owner->flags & DYNAMIC))
    h->root.def_regular = 1;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

  for (relent = h->reloc_entries; relent; relent = relent->next)
    {
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared, info->pie);
      if (entries)
	{
	  relent->srel->size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
	}
    }

  return TRUE;
}

/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */

static bfd_boolean
elf64_alpha_size_rela_got_1 (struct alpha_elf_link_hash_entry *h,
			     struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;

  /* If we're using a plt for this symbol, then all of its relocations
     for its got entries go into .rela.plt.  */
  if (h->root.needs_plt)
    return TRUE;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type, dynamic,
						  info->shared, info->pie);

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf64_External_Rela) * entries;
    }

  return TRUE;
}

/* Set the sizes of the dynamic relocation sections.  */

static void
elf64_alpha_size_rela_got_section (struct bfd_link_info *info)
{
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return;

  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */

  entries = 0;
  for (i = htab->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;

      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared, info->pie));
	}
    }

  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_linker_section (dynobj, ".rela.got");
  if (!srel)
    {
      BFD_ASSERT (entries == 0);
      return;
    }
  srel->size = sizeof (Elf64_External_Rela) * entries;

  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (htab,
				elf64_alpha_size_rela_got_1, info);
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf64_alpha_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean relplt;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = elf_hash_table(info)->dynobj;
  BFD_ASSERT(dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Now that we've seen all of the input files, we can decide which
	 symbols need dynamic relocation entries and which don't.  We've
	 collected information in check_relocs that we can now apply to
	 size the dynamic relocation sections.  */
      alpha_elf_link_hash_traverse (htab,
				    elf64_alpha_calc_dynrel_sizes, info);

      elf64_alpha_size_rela_got_section (info);
      elf64_alpha_size_plt_section (info);
    }
  /* else we're not dynamic and by definition we don't need such things.  */

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relplt = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if (!(s->flags & SEC_LINKER_CREATED))
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      if (strcmp (name, ".rela.plt") == 0)
		relplt = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".got")
	       && strcmp (name, ".plt") != 0
	       && strcmp (name, ".dynbss") != 0)
	{
	  /* It's not one of our dynamic sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the output file.
	     This is to handle .rela.bss and .rela.plt.  We must create it
	     in create_dynamic_sections, because it must be created before
	     the linker maps input sections to output sections.  The
	     linker does that before adjust_dynamic_symbol is called, and
	     it is that function which decides whether anything needs to
	     go into these sections.  */
	  if (!CONST_STRNEQ (name, ".got"))
	    s->flags |= SEC_EXCLUDE;
	}
      else if ((s->flags & SEC_HAS_CONTENTS) != 0)
	{
	  /* Allocate memory for the section contents.  */
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf64_alpha_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (relplt)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;

	  if (elf64_alpha_use_secureplt
	      && !add_dynamic_entry (DT_ALPHA_PLTRO, 1))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	return FALSE;

      if (info->flags & DF_TEXTREL)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* These functions do relaxation for Alpha ELF.

   Currently I'm only handling what I can do with existing compiler
   and assembler support, which means no instructions are removed,
   though some may be nopped.  At this time GCC does not emit enough
   information to do all of the relaxing that is possible.  It will
   take some not small amount of work for that to happen.

   There are a couple of interesting papers that I once read on this
   subject, that I cannot find references to at the moment, that
   related to Alpha in particular.  They are by David Wall, then of
   DEC WRL.  */

struct alpha_relax_info
{
  bfd *abfd;
  asection *sec;
  bfd_byte *contents;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *relocs, *relend;
  struct bfd_link_info *link_info;
  bfd_vma gp;
  bfd *gotobj;
  asection *tsec;
  struct alpha_elf_link_hash_entry *h;
  struct alpha_elf_got_entry **first_gotent;
  struct alpha_elf_got_entry *gotent;
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
  unsigned char other;
};

static Elf_Internal_Rela *
elf64_alpha_find_reloc_at_ofs (Elf_Internal_Rela *rel,
			       Elf_Internal_Rela *relend,
			       bfd_vma offset, int type)
{
  while (rel < relend)
    {
      if (rel->r_offset == offset
	  && ELF64_R_TYPE (rel->r_info) == (unsigned int) type)
	return rel;
      ++rel;
    }
  return NULL;
}

static bfd_boolean
elf64_alpha_relax_got_load (struct alpha_relax_info *info, bfd_vma symval,
			    Elf_Internal_Rela *irel, unsigned long r_type)
{
  unsigned int insn;
  bfd_signed_vma disp;

  /* Get the instruction.  */
  insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);

  if (insn >> 26 != OP_LDQ)
    {
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
      ((*_bfd_error_handler)
       ("%B: %A+0x%lx: warning: %s relocation against unexpected insn",
	info->abfd, info->sec,
	(unsigned long) irel->r_offset, howto->name));
      return TRUE;
    }

  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL
      && (info->link_info->shared && !info->link_info->pie))
    return TRUE;

  if (r_type == R_ALPHA_LITERAL)
    {
      /* Look for nice constant addresses.  This includes the not-uncommon
	 special case of 0 for undefweak symbols.  */
      if ((info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	  || (!info->link_info->shared
	      && (symval >= (bfd_vma)-0x8000 || symval < 0x8000)))
	{
	  disp = 0;
	  insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
	  insn |= (symval & 0xffff);
	  r_type = R_ALPHA_NONE;
	}
      else
	{
	  disp = symval - info->gp;
	  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
	  r_type = R_ALPHA_GPREL16;
	}
    }
  else
    {
      bfd_vma dtp_base, tp_base;

      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);

      insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);

      switch (r_type)
	{
	case R_ALPHA_GOTDTPREL:
	  r_type = R_ALPHA_DTPREL16;
	  break;
	case R_ALPHA_GOTTPREL:
	  r_type = R_ALPHA_TPREL16;
	  break;
	default:
	  BFD_ASSERT (0);
	  return FALSE;
	}
    }

  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;

  bfd_put_32 (info->abfd, (bfd_vma) insn, info->contents + irel->r_offset);
  info->changed_contents = TRUE;

  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
  info->changed_relocs = TRUE;

  /* ??? Search forward through this basic block looking for insns
     that use the target register.  Stop after an insn modifying the
     register is seen, or after a branch or call.

     Any such memory load insn may be substituted by a load directly
     off the GP.  This allows the memory load insn to be issued before
     the calculated GP register would otherwise be ready.

     Any such jsr insn can be replaced by a bsr if it is in range.

     This would mean that we'd have to _add_ relocations, the pain of
     which gives one pause.  */

  return TRUE;
}

static bfd_vma
elf64_alpha_relax_opt_call (struct alpha_relax_info *info, bfd_vma symval)
{
  /* If the function has the same gp, and we can identify that the
     function does not use its function pointer, we can eliminate the
     address load.  */

  /* If the symbol is marked NOPV, we are being told the function never
     needs its procedure value.  */
  if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_NOPV)
    return symval;

  /* If the symbol is marked STD_GP, we are being told the function does
     a normal ldgp in the first two words.  */
  else if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_STD_GPLOAD)
    ;

  /* Otherwise, we may be able to identify a GP load in the first two
     words, which we can then skip.  */
  else
    {
      Elf_Internal_Rela *tsec_relocs, *tsec_relend, *tsec_free, *gpdisp;
      bfd_vma ofs;

      /* Load the relocations from the section that the target symbol is in.  */
      if (info->sec == info->tsec)
	{
	  tsec_relocs = info->relocs;
	  tsec_relend = info->relend;
	  tsec_free = NULL;
	}
      else
	{
	  tsec_relocs = (_bfd_elf_link_read_relocs
		         (info->abfd, info->tsec, NULL,
			 (Elf_Internal_Rela *) NULL,
			 info->link_info->keep_memory));
	  if (tsec_relocs == NULL)
	    return 0;
	  tsec_relend = tsec_relocs + info->tsec->reloc_count;
	  tsec_free = (info->link_info->keep_memory ? NULL : tsec_relocs);
	}

      /* Recover the symbol's offset within the section.  */
      ofs = (symval - info->tsec->output_section->vma
	     - info->tsec->output_offset);

      /* Look for a GPDISP reloc.  */
      gpdisp = (elf64_alpha_find_reloc_at_ofs
		(tsec_relocs, tsec_relend, ofs, R_ALPHA_GPDISP));

      if (!gpdisp || gpdisp->r_addend != 4)
	{
	  if (tsec_free)
	    free (tsec_free);
	  return 0;
	}
      if (tsec_free)
        free (tsec_free);
    }

  /* We've now determined that we can skip an initial gp load.  Verify
     that the call and the target use the same gp.   */
  if (info->link_info->output_bfd->xvec != info->tsec->owner->xvec
      || info->gotobj != alpha_elf_tdata (info->tsec->owner)->gotobj)
    return 0;

  return symval + 8;
}

static bfd_boolean
elf64_alpha_relax_with_lituse (struct alpha_relax_info *info,
			       bfd_vma symval, Elf_Internal_Rela *irel)
{
  Elf_Internal_Rela *urel, *irelend = info->relend;
  int flags, count, i;
  bfd_signed_vma disp;
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
  unsigned int lit_insn;

  lit_insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);
  if (lit_insn >> 26 != OP_LDQ)
    {
      ((*_bfd_error_handler)
       ("%B: %A+0x%lx: warning: LITERAL relocation against unexpected insn",
	info->abfd, info->sec,
	(unsigned long) irel->r_offset));
      return TRUE;
    }

  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

  /* Summarize how this particular LITERAL is used.  */
  for (urel = irel+1, flags = count = 0; urel < irelend; ++urel, ++count)
    {
      if (ELF64_R_TYPE (urel->r_info) != R_ALPHA_LITUSE)
	break;
      if (urel->r_addend <= 6)
	flags |= 1 << urel->r_addend;
    }

  /* A little preparation for the loop...  */
  disp = symval - info->gp;

  for (urel = irel+1, i = 0; i < count; ++i, ++urel)
    {
      unsigned int insn;
      int insn_disp;
      bfd_signed_vma xdisp;

      insn = bfd_get_32 (info->abfd, info->contents + urel->r_offset);

      switch (urel->r_addend)
	{
	case LITUSE_ALPHA_ADDR:
	default:
	  /* This type is really just a placeholder to note that all
	     uses cannot be optimized, but to still allow some.  */
	  all_optimized = FALSE;
	  break;

	case LITUSE_ALPHA_BASE:
	  /* We can always optimize 16-bit displacements.  */

	  /* Extract the displacement from the instruction, sign-extending
	     it if necessary, then test whether it is within 16 or 32 bits
	     displacement from GP.  */
	  insn_disp = ((insn & 0xffff) ^ 0x8000) - 0x8000;

	  xdisp = disp + insn_disp;
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);

	  if (fits16)
	    {
	      /* Take the op code and dest from this insn, take the base
		 register from the literal insn.  Leave the offset alone.  */
	      insn = (insn & 0xffe0ffff) | (lit_insn & 0x001f0000);
	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPREL16);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;

	      bfd_put_32 (info->abfd, (bfd_vma) insn,
			  info->contents + urel->r_offset);
	      info->changed_contents = TRUE;
	    }

	  /* If all mem+byte, we can optimize 32-bit mem displacements.  */
	  else if (fits32 && !(flags & ~6))
	    {
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb.  */

	      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELHIGH);
	      lit_insn = (OP_LDAH << 26) | (lit_insn & 0x03ff0000);
	      bfd_put_32 (info->abfd, (bfd_vma) lit_insn,
			  info->contents + irel->r_offset);
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;

	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELLOW);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;
	    }
	  else
	    all_optimized = FALSE;
	  break;

	case LITUSE_ALPHA_BYTOFF:
	  /* We can always optimize byte instructions.  */

	  /* FIXME: sanity check the insn for byte op.  Check that the
	     literal dest reg is indeed Rb in the byte insn.  */

	  insn &= ~ (unsigned) 0x001ff000;
	  insn |= ((symval & 7) << 13) | 0x1000;

	  urel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  urel->r_addend = 0;
	  info->changed_relocs = TRUE;

	  bfd_put_32 (info->abfd, (bfd_vma) insn,
		      info->contents + urel->r_offset);
	  info->changed_contents = TRUE;
	  break;

	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
	case LITUSE_ALPHA_JSRDIRECT:
	  {
	    bfd_vma optdest, org;
	    bfd_signed_vma odisp;

	    /* For undefined weak symbols, we're mostly interested in getting
	       rid of the got entry whenever possible, so optimize this to a
	       use of the zero register.  */
	    if (info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	      {
		insn |= 31 << 16;
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);

		info->changed_contents = TRUE;
		break;
	      }

	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
	    odisp = (optdest ? optdest : symval) - org;

	    if (odisp >= -0x400000 && odisp < 0x400000)
	      {
		Elf_Internal_Rela *xrel;

		/* Preserve branch prediction call stack when possible.  */
		if ((insn & INSN_JSR_MASK) == INSN_JSR)
		  insn = (OP_BSR << 26) | (insn & 0x03e00000);
		else
		  insn = (OP_BR << 26) | (insn & 0x03e00000);

		urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					     R_ALPHA_BRADDR);
		urel->r_addend = irel->r_addend;

		if (optdest)
		  urel->r_addend += optdest - symval;
		else
		  all_optimized = FALSE;

		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);

		/* Kill any HINT reloc that might exist for this insn.  */
		xrel = (elf64_alpha_find_reloc_at_ofs
			(info->relocs, info->relend, urel->r_offset,
			 R_ALPHA_HINT));
		if (xrel)
		  xrel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
	      }
	    else
	      all_optimized = FALSE;

	    /* Even if the target is not in range for a direct branch,
	       if we share a GP, we can eliminate the gp reload.  */
	    if (optdest)
	      {
		Elf_Internal_Rela *gpdisp
		  = (elf64_alpha_find_reloc_at_ofs
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
		if (gpdisp)
		  {
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
		    bfd_byte *p_lda = p_ldah + gpdisp->r_addend;
		    unsigned int ldah = bfd_get_32 (info->abfd, p_ldah);
		    unsigned int lda = bfd_get_32 (info->abfd, p_lda);

		    /* Verify that the instruction is "ldah $29,0($26)".
		       Consider a function that ends in a noreturn call,
		       and that the next function begins with an ldgp,
		       and that by accident there is no padding between.
		       In that case the insn would use $27 as the base.  */
		    if (ldah == 0x27ba0000 && lda == 0x23bd0000)
		      {
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_ldah);
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_lda);

			gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
		      }
		  }
	      }
	  }
	  break;
	}
    }

  /* If all cases were optimized, we can reduce the use count on this
     got entry by one, possibly eliminating it.  */
  if (all_optimized)
    {
      if (--info->gotent->use_count == 0)
	{
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
	}

      /* If the literal instruction is no longer needed (it may have been
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
	 so just nop it out.  */
      if (!lit_reused)
	{
	  irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  info->changed_relocs = TRUE;

	  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP,
		      info->contents + irel->r_offset);
	  info->changed_contents = TRUE;
	}

      return TRUE;
    }
  else
    return elf64_alpha_relax_got_load (info, symval, irel, R_ALPHA_LITERAL);
}

static bfd_boolean
elf64_alpha_relax_tls_get_addr (struct alpha_relax_info *info, bfd_vma symval,
				Elf_Internal_Rela *irel, bfd_boolean is_gd)
{
  bfd_byte *pos[5];
  unsigned int insn, tlsgd_reg;
  Elf_Internal_Rela *gpdisp, *hint;
  bfd_boolean dynamic, use_gottprel;
  unsigned long new_symndx;

  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);

  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;

  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;

  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return TRUE;

  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return TRUE;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return TRUE;

  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return TRUE;

  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;

  /* Beware of the compiler hoisting part of the sequence out a loop
     and adjusting the destination register for the TLSGD insn.  If this
     happens, there will be a move into $16 before the JSR insn, so only
     transformations of the first insn pair should use this register.  */
  tlsgd_reg = bfd_get_32 (info->abfd, pos[0]);
  tlsgd_reg = (tlsgd_reg >> 21) & 31;

  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
    return TRUE;

  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;

    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];

    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;

    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);

    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }

  /* Change

	lda	$16,x($gp)			!tlsgd!1
	ldq	$27,__tls_get_addr($gp)		!literal!1
	jsr	$26,($27),__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)			!gpdisp!2
	lda	$29,0($29)			!gpdisp!2
     to
	ldq	$16,x($gp)			!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)			!tprel
	unop
     or
	ldah	$16,x($gp)			!tprelhi
	lda	$16,x($16)			!tprello

     as appropriate.  */

  use_gottprel = FALSE;
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : STN_UNDEF;

  /* Some compilers warn about a Boolean-looking expression being
     used in a switch.  The explicit cast silences them.  */
  switch ((int) (!dynamic && !info->link_info->shared))
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
	disp = symval - tp_base;

	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (tlsgd_reg << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && pos[0] + 4 == pos[1])
	  {
	    insn = (OP_LDAH << 26) | (tlsgd_reg << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (tlsgd_reg << 21) | (tlsgd_reg << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */

    default:
      use_gottprel = TRUE;

      insn = (OP_LDQ << 26) | (tlsgd_reg << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
    }

  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);

  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);

  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);

  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;

  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;

      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
	{
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return FALSE;

	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;

	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }

	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
    }

  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_section (bfd *abfd, asection *sec,
			   struct bfd_link_info *link_info, bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isymbuf = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (link_info);
  if (htab == NULL)
    return FALSE;

  /* There's nothing to change, yet.  */
  *again = FALSE;

  if (link_info->relocatable
      || ((sec->flags & (SEC_CODE | SEC_RELOC | SEC_ALLOC))
	  != (SEC_CODE | SEC_RELOC | SEC_ALLOC))
      || sec->reloc_count == 0)
    return TRUE;

  BFD_ASSERT (is_alpha_elf (abfd));

  /* Make sure our GOT and PLT tables are up-to-date.  */
  if (htab->relax_trip != link_info->relax_trip)
    {
      htab->relax_trip = link_info->relax_trip;

      /* This should never fail after the initial round, since the only
	 error is GOT overflow, and relaxation only shrinks the table.  */
      if (!elf64_alpha_size_got_sections (link_info))
	abort ();
      if (elf_hash_table (link_info)->dynamic_sections_created)
	{
	  elf64_alpha_size_plt_section (link_info);
	  elf64_alpha_size_rela_got_section (link_info);
	}
    }

  symtab_hdr = &elf_symtab_hdr (abfd);
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    return FALSE;

  memset(&info, 0, sizeof (info));
  info.abfd = abfd;
  info.sec = sec;
  info.link_info = link_info;
  info.symtab_hdr = symtab_hdr;
  info.relocs = internal_relocs;
  info.relend = irelend = internal_relocs + sec->reloc_count;

  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
  info.gotobj = alpha_elf_tdata (abfd)->gotobj;
  if (info.gotobj)
    {
      asection *sgot = alpha_elf_tdata (info.gotobj)->got;
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
    }

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
  else
    {
      if (!bfd_malloc_and_get_section (abfd, sec, &info.contents))
	goto error_return;
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      struct alpha_elf_got_entry *gotent;
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);

      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	  break;

	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the STN_UNDEF (0) symbol so that they all match.  */
	  r_symndx = STN_UNDEF;
	  break;

	default:
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  isym = isymbuf + r_symndx;

	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.link_info);
	    }
	  else
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }

	  info.h = NULL;
	  info.other = isym->st_other;
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
	}
      else
	{
	  unsigned long indx;
	  struct alpha_elf_link_hash_entry *h;

	  indx = r_symndx - symtab_hdr->sh_info;
	  h = alpha_elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefined)
	    continue;

	  /* If the symbol isn't defined in the current module,
	     again we can't do anything.  */
	  if (h->root.root.type == bfd_link_hash_undefweak)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else if (!h->root.def_regular)
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }

	  info.h = h;
	  info.other = h->root.other;
	  info.first_gotent = &h->got_entries;
	}

      /* Search for the got entry to be used by this relocation.  */
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
      info.gotent = gotent;

      symval += info.tsec->output_section->vma + info.tsec->output_offset;
      symval += irel->r_addend;

      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);

	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
	    }
	  break;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
	    goto error_return;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
	    goto error_return;
	  break;
	}
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    {
      if (!info.changed_contents && !link_info->keep_memory)
	free (info.contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = info.contents;
	}
    }

  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!info.changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

  *again = info.changed_contents || info.changed_relocs;

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    free (info.contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)
   into the next available slot in SREL.  */

static void
elf64_alpha_emit_dynrel (bfd *abfd, struct bfd_link_info *info,
			 asection *sec, asection *srel, bfd_vma offset,
			 long dynindx, long rtype, bfd_vma addend)
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (srel != NULL);

  outrel.r_info = ELF64_R_INFO (dynindx, rtype);
  outrel.r_addend = addend;

  offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if ((offset | 1) != (bfd_vma) -1)
    outrel.r_offset = sec->output_section->vma + sec->output_offset + offset;
  else
    memset (&outrel, 0, sizeof (outrel));

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count <= srel->size);
}

/* Relocate an Alpha ELF section for a relocatable link.

   We don't have to change anything unless the reloc is against a section
   symbol, in which case we have to adjust according to where the section
   symbol winds up in the output section.  */

static bfd_boolean
elf64_alpha_relocate_section_r (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info ATTRIBUTE_UNUSED,
				bfd *input_bfd, asection *input_section,
				bfd_byte *contents ATTRIBUTE_UNUSED,
				Elf_Internal_Rela *relocs,
				Elf_Internal_Sym *local_syms,
				asection **local_sections)
{
  unsigned long symtab_hdr_sh_info;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct elf_link_hash_entry **sym_hashes;
  bfd_boolean ret_val = TRUE;

  symtab_hdr_sh_info = elf_symtab_hdr (input_bfd).sh_info;
  sym_hashes = elf_sym_hashes (input_bfd);

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      unsigned long r_type;

      r_type = ELF64_R_TYPE (rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
	}

      /* The symbol associated with GPDISP and LITUSE is
	 immaterial.  Only the addend is significant.  */
      if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	continue;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr_sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	}
      else
	{
	  struct elf_link_hash_entry *h;

	  h = sym_hashes[r_symndx - symtab_hdr_sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    continue;

	  sym = NULL;
	  sec = h->root.u.def.section;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend,
					 elf64_alpha_howto_table + r_type, 0,
					 contents);

      if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	rel->r_addend += sec->output_offset;
    }

  return ret_val;
}

/* Relocate an Alpha ELF section.  */

static bfd_boolean
elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			      bfd *input_bfd, asection *input_section,
			      bfd_byte *contents, Elf_Internal_Rela *relocs,
			      Elf_Internal_Sym *local_syms,
			      asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  asection *sgot, *srel, *srelgot;
  bfd *dynobj, *gotobj;
  bfd_vma gp, tp_base, dtp_base;
  struct alpha_elf_got_entry **local_got_entries;
  bfd_boolean ret_val;

  BFD_ASSERT (is_alpha_elf (input_bfd));

  /* Handle relocatable links with a smaller loop.  */
  if (info->relocatable)
    return elf64_alpha_relocate_section_r (output_bfd, info, input_bfd,
					   input_section, contents, relocs,
					   local_syms, local_sections);

  /* This is a final link.  */

  ret_val = TRUE;

  symtab_hdr = &elf_symtab_hdr (input_bfd);

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    srelgot = bfd_get_linker_section (dynobj, ".rela.got");
  else
    srelgot = NULL;

  if (input_section->flags & SEC_ALLOC)
    {
      const char *section_name;
      section_name = (bfd_elf_string_from_elf_section
		      (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		       _bfd_elf_single_rel_hdr (input_section)->sh_name));
      BFD_ASSERT(section_name != NULL);
      srel = bfd_get_linker_section (dynobj, section_name);
    }
  else
    srel = NULL;

  /* Find the gp value for this input bfd.  */
  gotobj = alpha_elf_tdata (input_bfd)->gotobj;
  if (gotobj)
    {
      sgot = alpha_elf_tdata (gotobj)->got;
      gp = _bfd_get_gp_value (gotobj);
      if (gp == 0)
	{
	  gp = (sgot->output_section->vma
		+ sgot->output_offset
		+ 0x8000);
	  _bfd_set_gp_value (gotobj, gp);
	}
    }
  else
    {
      sgot = NULL;
      gp = 0;
    }

  local_got_entries = alpha_elf_tdata(input_bfd)->local_got_entries;

  if (elf_hash_table (info)->tls_sec != NULL)
    {
      dtp_base = alpha_get_dtprel_base (info);
      tp_base = alpha_get_tprel_base (info);
    }
  else
    dtp_base = tp_base = 0;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;
      bfd_reloc_status_type r;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym = NULL;
      asection *sec = NULL;
      bfd_vma value;
      bfd_vma addend;
      bfd_boolean dynamic_symbol_p;
      bfd_boolean unresolved_reloc = FALSE;
      bfd_boolean undef_weak_ref = FALSE;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
	}

      howto = elf64_alpha_howto_table + r_type;
      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	 reloc to the STN_UNDEF (0) symbol so that they all match.  */
      if (r_type == R_ALPHA_TLSLDM)
	r_symndx = STN_UNDEF;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  asection *msec;
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  msec = sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);

	  /* If this is a tp-relative relocation against sym STN_UNDEF (0),
	     this is hackery from relax_section.  Force the value to
	     be the tls module base.  */
	  if (r_symndx == STN_UNDEF
	      && (r_type == R_ALPHA_TLSLDM
		  || r_type == R_ALPHA_GOTTPREL
		  || r_type == R_ALPHA_TPREL64
		  || r_type == R_ALPHA_TPRELHI
		  || r_type == R_ALPHA_TPRELLO
		  || r_type == R_ALPHA_TPREL16))
	    value = dtp_base;

	  if (local_got_entries)
	    gotent = local_got_entries[r_symndx];
	  else
	    gotent = NULL;

	  /* Need to adjust local GOT entries' addends for SEC_MERGE
	     unless it has been done already.  */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && sec->sec_info_type == SEC_INFO_TYPE_MERGE
	      && gotent
	      && !gotent->reloc_xlated)
	    {
	      struct alpha_elf_got_entry *ent;

	      for (ent = gotent; ent; ent = ent->next)
		{
		  ent->reloc_xlated = 1;
		  if (ent->use_count == 0)
		    continue;
		  msec = sec;
		  ent->addend =
		    _bfd_merged_section_offset (output_bfd, &msec,
						elf_section_data (sec)->
						  sec_info,
						sym->st_value + ent->addend);
		  ent->addend -= sym->st_value;
		  ent->addend += msec->output_section->vma
				 + msec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset;
		}
	    }

	  dynamic_symbol_p = FALSE;
	}
      else
	{
	  bfd_boolean warned;
	  struct elf_link_hash_entry *hh;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sec, value,
				   unresolved_reloc, warned);

	  if (warned)
	    continue;

	  if (value == 0
	      && ! unresolved_reloc
	      && hh->root.type == bfd_link_hash_undefweak)
	    undef_weak_ref = TRUE;

	  h = (struct alpha_elf_link_hash_entry *) hh;
          dynamic_symbol_p = alpha_elf_dynamic_symbol_p (&h->root, info);
	  gotent = h->got_entries;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      addend = rel->r_addend;
      value += addend;

      /* Search for the proper got entry.  */
      for (; gotent ; gotent = gotent->next)
	if (gotent->gotobj == gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == addend)
	  break;

      switch (r_type)
	{
	case R_ALPHA_GPDISP:
	  {
	    bfd_byte *p_ldah, *p_lda;

	    BFD_ASSERT(gp != 0);

	    value = (input_section->output_section->vma
		     + input_section->output_offset
		     + rel->r_offset);

	    p_ldah = contents + rel->r_offset;
	    p_lda = p_ldah + rel->r_addend;

	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - value,
					     p_ldah, p_lda);
	  }
	  break;

	case R_ALPHA_LITERAL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 RELATIVE reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p && !undef_weak_ref)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, value);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_GPREL32:
	case R_ALPHA_GPREL16:
	case R_ALPHA_GPRELLOW:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: gp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(gp != 0);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_GPRELHIGH:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: gp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(gp != 0);
	  value -= gp;
	  value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_HINT:
	  /* A call to a dynamic symbol is definitely out of range of
	     the 16-bit displacement.  Don't bother writing anything.  */
	  if (dynamic_symbol_p)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;

	case R_ALPHA_BRADDR:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: pc-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;

	case R_ALPHA_BRSGP:
	  {
	    int other;
	    const char *name;

	    /* The regular PC-relative stuff measures from the start of
	       the instruction rather than the end.  */
	    value -= 4;

	    /* The source and destination gp must be the same.  Note that
	       the source will always have an assigned gp, since we forced
	       one in check_relocs, but that the destination may not, as
	       it might not have had any relocations at all.  Also take
	       care not to crash if H is an undefined symbol.  */
	    if (h != NULL && sec != NULL
		&& alpha_elf_tdata (sec->owner)->gotobj
		&& gotobj != alpha_elf_tdata (sec->owner)->gotobj)
	      {
		(*_bfd_error_handler)
		  (_("%B: change in gp: BRSGP %s"),
		   input_bfd, h->root.root.root.string);
		ret_val = FALSE;
	      }

	    /* The symbol should be marked either NOPV or STD_GPLOAD.  */
	    if (h != NULL)
	      other = h->root.other;
	    else
	      other = sym->st_other;
	    switch (other & STO_ALPHA_STD_GPLOAD)
	      {
	      case STO_ALPHA_NOPV:
	        break;
	      case STO_ALPHA_STD_GPLOAD:
		value += 8;
		break;
	      default:
		if (h != NULL)
		  name = h->root.root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      name = _("<unknown>");
		    else if (name[0] == 0)
		      name = bfd_section_name (input_bfd, sec);
		  }
		(*_bfd_error_handler)
		  (_("%B: !samegp reloc against symbol without .prologue: %s"),
		   input_bfd, name);
		ret_val = FALSE;
		break;
	      }

	    goto default_reloc;
	  }

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	case R_ALPHA_DTPREL64:
	case R_ALPHA_TPREL64:
	  {
	    long dynindx, dyntype = r_type;
	    bfd_vma dynaddend;

	    /* Careful here to remember RELATIVE relocations for global
	       variables for symbolic shared objects.  */

	    if (dynamic_symbol_p)
	      {
		BFD_ASSERT(h->root.dynindx != -1);
		dynindx = h->root.dynindx;
		dynaddend = addend;
		addend = 0, value = 0;
	      }
	    else if (r_type == R_ALPHA_DTPREL64)
	      {
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		value -= dtp_base;
		goto default_reloc;
	      }
	    else if (r_type == R_ALPHA_TPREL64)
	      {
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		if (!info->shared || info->pie)
		  {
		    value -= tp_base;
		    goto default_reloc;
		  }
		dynindx = 0;
		dynaddend = value - dtp_base;
	      }
	    else if (info->shared
		     && r_symndx != STN_UNDEF
		     && (input_section->flags & SEC_ALLOC)
		     && !undef_weak_ref
		     && !(unresolved_reloc
			  && (_bfd_elf_section_offset (output_bfd, info,
						       input_section,
						       rel->r_offset)
			      == (bfd_vma) -1)))
	      {
		if (r_type == R_ALPHA_REFLONG)
		  {
		    (*_bfd_error_handler)
		      (_("%B: unhandled dynamic relocation against %s"),
		       input_bfd,
		       h->root.root.root.string);
		    ret_val = FALSE;
		  }
		dynindx = 0;
		dyntype = R_ALPHA_RELATIVE;
		dynaddend = value;
	      }
	    else
	      goto default_reloc;

	    if (input_section->flags & SEC_ALLOC)
	      elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				       srel, rel->r_offset, dynindx,
				       dyntype, dynaddend);
	  }
	  goto default_reloc;

	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: pc-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  else if ((info->shared || info->pie) && undef_weak_ref)
            {
              (*_bfd_error_handler)
                (_("%B: pc-relative relocation against undefined weak symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }


	  /* ??? .eh_frame references to discarded sections will be smashed
	     to relocations against SHN_UNDEF.  The .eh_frame format allows
	     NULL to be encoded as 0 in any format, so this works here.  */
	  if (r_symndx == STN_UNDEF
	      || (unresolved_reloc
		  && _bfd_elf_section_offset (output_bfd, info,
					      input_section,
					      rel->r_offset) == (bfd_vma) -1))
	    howto = (elf64_alpha_howto_table
		     + (r_type - R_ALPHA_SREL32 + R_ALPHA_REFLONG));
	  goto default_reloc;

	case R_ALPHA_TLSLDM:
	  /* Ignore the symbol for the relocation.  The result is always
	     the current module.  */
	  dynamic_symbol_p = 0;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      /* Note that the module index for the main program is 1.  */
	      bfd_put_64 (output_bfd, !info->shared && !dynamic_symbol_p,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 DTPMOD64 reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_DTPMOD64, 0);

	      if (dynamic_symbol_p || r_type == R_ALPHA_TLSLDM)
		value = 0;
	      else
		{
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	          value -= dtp_base;
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset + 8);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_DTPRELHI:
	case R_ALPHA_DTPRELLO:
	case R_ALPHA_DTPREL16:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: dtp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	  value -= dtp_base;
	  if (r_type == R_ALPHA_DTPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_TPRELHI:
	case R_ALPHA_TPRELLO:
	case R_ALPHA_TPREL16:
	  if (info->shared && !info->pie)
	    {
	      (*_bfd_error_handler)
		(_("%B: TLS local exec code cannot be linked into shared objects"),
		input_bfd);
              ret_val = FALSE;
	    }
	  else if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%B: tp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	  value -= tp_base;
	  if (r_type == R_ALPHA_TPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      if (dynamic_symbol_p)
		value = 0;
	      else
		{
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		  if (r_type == R_ALPHA_GOTDTPREL)
		    value -= dtp_base;
		  else if (!info->shared)
		    value -= tp_base;
		  else
		    {
		      elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					       gotent->got_offset, 0,
					       R_ALPHA_TPREL64,
					       value - dtp_base);
		      value = 0;
		    }
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	default:
	default_reloc:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset, value, 0);
	  break;
	}

      switch (r)
	{
	case bfd_reloc_ok:
	  break;

	case bfd_reloc_overflow:
	  {
	    const char *name;

	    /* Don't warn if the overflow is due to pc relative reloc
	       against discarded section.  Section optimization code should
	       handle it.  */

	    if (r_symndx < symtab_hdr->sh_info
		&& sec != NULL && howto->pc_relative
		&& discarded_section (sec))
	      break;

	    if (h != NULL)
	      name = NULL;
	    else
	      {
		name = (bfd_elf_string_from_elf_section
			(input_bfd, symtab_hdr->sh_link, sym->st_name));
		if (name == NULL)
		  return FALSE;
		if (*name == '\0')
		  name = bfd_section_name (input_bfd, sec);
	      }
	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root.root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd, input_section,
		    rel->r_offset)))
	      ret_val = FALSE;
	  }
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();
	}
    }

  return ret_val;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf64_alpha_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
				   struct elf_link_hash_entry *h,
				   Elf_Internal_Sym *sym)
{
  struct alpha_elf_link_hash_entry *ah = (struct alpha_elf_link_hash_entry *)h;
  bfd *dynobj = elf_hash_table(info)->dynobj;

  if (h->needs_plt)
    {
      /* Fill in the .plt entry for this symbol.  */
      asection *splt, *sgot, *srel;
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      bfd_vma got_addr, plt_addr;
      bfd_vma plt_index;
      struct alpha_elf_got_entry *gotent;

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (splt != NULL);
      srel = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (srel != NULL);

      for (gotent = ah->got_entries; gotent ; gotent = gotent->next)
	if (gotent->reloc_type == R_ALPHA_LITERAL
	    && gotent->use_count > 0)
	  {
	    unsigned int insn;
	    int disp;

	    sgot = alpha_elf_tdata (gotent->gotobj)->got;
	    BFD_ASSERT (sgot != NULL);

	    BFD_ASSERT (gotent->got_offset != -1);
	    BFD_ASSERT (gotent->plt_offset != -1);

	    got_addr = (sgot->output_section->vma
			+ sgot->output_offset
			+ gotent->got_offset);
	    plt_addr = (splt->output_section->vma
			+ splt->output_offset
			+ gotent->plt_offset);

	    plt_index = (gotent->plt_offset-PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;

	    /* Fill in the entry in the procedure linkage table.  */
	    if (elf64_alpha_use_secureplt)
	      {
		disp = (PLT_HEADER_SIZE - 4) - (gotent->plt_offset + 4);
		insn = INSN_AD (INSN_BR, 31, disp);
		bfd_put_32 (output_bfd, insn,
			    splt->contents + gotent->plt_offset);

		plt_index = ((gotent->plt_offset - NEW_PLT_HEADER_SIZE)
			     / NEW_PLT_ENTRY_SIZE);
	      }
	    else
	      {
		disp = -(gotent->plt_offset + 4);
		insn = INSN_AD (INSN_BR, 28, disp);
		bfd_put_32 (output_bfd, insn,
			    splt->contents + gotent->plt_offset);
		bfd_put_32 (output_bfd, INSN_UNOP,
			    splt->contents + gotent->plt_offset + 4);
		bfd_put_32 (output_bfd, INSN_UNOP,
			    splt->contents + gotent->plt_offset + 8);

		plt_index = ((gotent->plt_offset - OLD_PLT_HEADER_SIZE)
			     / OLD_PLT_ENTRY_SIZE);
	      }

	    /* Fill in the entry in the .rela.plt section.  */
	    outrel.r_offset = got_addr;
	    outrel.r_info = ELF64_R_INFO(h->dynindx, R_ALPHA_JMP_SLOT);
	    outrel.r_addend = 0;

	    loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
	    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	    /* Fill in the entry in the .got.  */
	    bfd_put_64 (output_bfd, plt_addr,
			sgot->contents + gotent->got_offset);
	  }
    }
  else if (alpha_elf_dynamic_symbol_p (h, info))
    {
      /* Fill in the dynamic relocations for this symbol's .got entries.  */
      asection *srel;
      struct alpha_elf_got_entry *gotent;

      srel = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);

      for (gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
	   gotent != NULL;
	   gotent = gotent->next)
	{
	  asection *sgot;
	  long r_type;

	  if (gotent->use_count == 0)
	    continue;

	  sgot = alpha_elf_tdata (gotent->gotobj)->got;

	  r_type = gotent->reloc_type;
	  switch (r_type)
	    {
	    case R_ALPHA_LITERAL:
	      r_type = R_ALPHA_GLOB_DAT;
	      break;
	    case R_ALPHA_TLSGD:
	      r_type = R_ALPHA_DTPMOD64;
	      break;
	    case R_ALPHA_GOTDTPREL:
	      r_type = R_ALPHA_DTPREL64;
	      break;
	    case R_ALPHA_GOTTPREL:
	      r_type = R_ALPHA_TPREL64;
	      break;
	    case R_ALPHA_TLSLDM:
	    default:
	      abort ();
	    }

	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
				   gotent->got_offset, h->dynindx,
				   r_type, gotent->addend);

	  if (gotent->reloc_type == R_ALPHA_TLSGD)
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
				     gotent->got_offset + 8, h->dynindx,
				     R_ALPHA_DTPREL64, gotent->addend);
	}
    }

  /* Mark some specially defined symbols as absolute.  */
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot
      || h == elf_hash_table (info)->hplt)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf64_alpha_finish_dynamic_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt, *sgotplt, *srelaplt;
      Elf64_External_Dyn *dyncon, *dynconend;
      bfd_vma plt_vma, gotplt_vma;

      splt = bfd_get_linker_section (dynobj, ".plt");
      srelaplt = bfd_get_linker_section (output_bfd, ".rela.plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      plt_vma = splt->output_section->vma + splt->output_offset;

      gotplt_vma = 0;
      if (elf64_alpha_use_secureplt)
	{
	  sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
	  BFD_ASSERT (sgotplt != NULL);
	  if (sgotplt->size > 0)
	    gotplt_vma = sgotplt->output_section->vma + sgotplt->output_offset;
	}

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    case DT_PLTGOT:
	      dyn.d_un.d_ptr
		= elf64_alpha_use_secureplt ? gotplt_vma : plt_vma;
	      break;
	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = srelaplt ? srelaplt->size : 0;
	      break;
	    case DT_JMPREL:
	      dyn.d_un.d_ptr = srelaplt ? srelaplt->vma : 0;
	      break;

	    case DT_RELASZ:
	      /* My interpretation of the TIS v1.1 ELF document indicates
		 that RELASZ should not include JMPREL.  This is not what
		 the rest of the BFD does.  It is, however, what the
		 glibc ld.so wants.  Do this fixup here until we found
		 out who is right.  */
	      if (srelaplt)
		dyn.d_un.d_val -= srelaplt->size;
	      break;
	    }

	  bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	}

      /* Initialize the plt header.  */
      if (splt->size > 0)
	{
	  unsigned int insn;
	  int ofs;

	  if (elf64_alpha_use_secureplt)
	    {
	      ofs = gotplt_vma - (plt_vma + PLT_HEADER_SIZE);

	      insn = INSN_ABC (INSN_SUBQ, 27, 28, 25);
	      bfd_put_32 (output_bfd, insn, splt->contents);

	      insn = INSN_ABO (INSN_LDAH, 28, 28, (ofs + 0x8000) >> 16);
	      bfd_put_32 (output_bfd, insn, splt->contents + 4);

	      insn = INSN_ABC (INSN_S4SUBQ, 25, 25, 25);
	      bfd_put_32 (output_bfd, insn, splt->contents + 8);

	      insn = INSN_ABO (INSN_LDA, 28, 28, ofs);
	      bfd_put_32 (output_bfd, insn, splt->contents + 12);

	      insn = INSN_ABO (INSN_LDQ, 27, 28, 0);
	      bfd_put_32 (output_bfd, insn, splt->contents + 16);

	      insn = INSN_ABC (INSN_ADDQ, 25, 25, 25);
	      bfd_put_32 (output_bfd, insn, splt->contents + 20);

	      insn = INSN_ABO (INSN_LDQ, 28, 28, 8);
	      bfd_put_32 (output_bfd, insn, splt->contents + 24);

	      insn = INSN_AB (INSN_JMP, 31, 27);
	      bfd_put_32 (output_bfd, insn, splt->contents + 28);

	      insn = INSN_AD (INSN_BR, 28, -PLT_HEADER_SIZE);
	      bfd_put_32 (output_bfd, insn, splt->contents + 32);
	    }
	  else
	    {
	      insn = INSN_AD (INSN_BR, 27, 0);	/* br $27, .+4 */
	      bfd_put_32 (output_bfd, insn, splt->contents);

	      insn = INSN_ABO (INSN_LDQ, 27, 27, 12);
	      bfd_put_32 (output_bfd, insn, splt->contents + 4);

	      insn = INSN_UNOP;
	      bfd_put_32 (output_bfd, insn, splt->contents + 8);

	      insn = INSN_AB (INSN_JMP, 27, 27);
	      bfd_put_32 (output_bfd, insn, splt->contents + 12);

	      /* The next two words will be filled in by ld.so.  */
	      bfd_put_64 (output_bfd, 0, splt->contents + 16);
	      bfd_put_64 (output_bfd, 0, splt->contents + 24);
	    }

	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 0;
	}
    }

  return TRUE;
}

/* We need to use a special link routine to handle the .mdebug section.
   We need to merge all instances of these sections together, not write
   them all out sequentially.  */

static bfd_boolean
elf64_alpha_final_link (bfd *abfd, struct bfd_link_info *info)
{
  asection *o;
  struct bfd_link_order *p;
  asection *mdebug_sec;
  struct ecoff_debug_info debug;
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  void * mdebug_handle = NULL;
  struct alpha_elf_link_hash_table * htab;

  htab = alpha_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Go through the sections and collect the mdebug information.  */
  mdebug_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == NULL)
	    return FALSE;

	  if (1)
	    {
	      asection *s;
	      EXTR esym;
	      bfd_vma last = 0;
	      unsigned int i;
	      static const char * const name[] =
		{
		  ".text", ".init", ".fini", ".data",
		  ".rodata", ".sdata", ".sbss", ".bss"
		};
	      static const int sc[] = { scText, scInit, scFini, scData,
					  scRData, scSData, scSBss, scBss };

	      esym.jmptbl = 0;
	      esym.cobol_main = 0;
	      esym.weakext = 0;
	      esym.reserved = 0;
	      esym.ifd = ifdNil;
	      esym.asym.iss = issNil;
	      esym.asym.st = stLocal;
	      esym.asym.reserved = 0;
	      esym.asym.index = indexNil;
	      for (i = 0; i < 8; i++)
		{
		  esym.asym.sc = sc[i];
		  s = bfd_get_section_by_name (abfd, name[i]);
		  if (s != NULL)
		    {
		      esym.asym.value = s->vma;
		      last = s->vma + s->size;
		    }
		  else
		    esym.asym.value = last;

		  if (! bfd_ecoff_debug_one_external (abfd, &debug, swap,
						      name[i], &esym))
		    return FALSE;
		}
	    }

	  for (p = o->map_head.link_order;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (! is_alpha_elf (input_bfd))
		/* I don't know what a non ALPHA ELF bfd would be
		   doing with a .mdebug section, but I don't really
		   want to deal with it.  */
		continue;

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (!elf64_alpha_read_ecoff_info (input_bfd, input_section,
						&input_debug))
		return FALSE;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return FALSE;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = (char *) input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct alpha_elf_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = alpha_elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = FALSE;
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf64_alpha_output_extsym,
				  &einfo);
	  if (einfo.failed)
	    return FALSE;

	  /* Set the size of the .mdebug section.  */
	  o->size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->map_head.link_order = (struct bfd_link_order *) NULL;

	  mdebug_sec = o;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (! bfd_elf_final_link (abfd, info))
    return FALSE;

  /* Now write out the computed sections.  */

  /* The .got subsections...  */
  {
    bfd *i, *dynobj = elf_hash_table(info)->dynobj;
    for (i = htab->got_list;
	 i != NULL;
	 i = alpha_elf_tdata(i)->got_link_next)
      {
	asection *sgot;

	/* elf_bfd_final_link already did everything in dynobj.  */
	if (i == dynobj)
	  continue;

	sgot = alpha_elf_tdata(i)->got;
	if (! bfd_set_section_contents (abfd, sgot->output_section,
					sgot->contents,
					(file_ptr) sgot->output_offset,
					sgot->size))
	  return FALSE;
      }
  }

  if (mdebug_sec != (asection *) NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return FALSE;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }

  return TRUE;
}

static enum elf_reloc_type_class
elf64_alpha_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			      const asection *rel_sec ATTRIBUTE_UNUSED,
			      const Elf_Internal_Rela *rela)
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_ALPHA_RELATIVE:
      return reloc_class_relative;
    case R_ALPHA_JMP_SLOT:
      return reloc_class_plt;
    case R_ALPHA_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static const struct bfd_elf_special_section elf64_alpha_special_sections[] =
{
  { STRING_COMMA_LEN (".sbss"),  -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { STRING_COMMA_LEN (".sdata"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,                     0,  0, 0,            0 }
};

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  Copied
   from elf32-mips.c.  */
static const struct ecoff_debug_swap
elf64_alpha_ecoff_debug_swap =
{
  /* Symbol table magic number.  */
  magicSym2,
  /* Alignment of debugging information.  E.g., 4.  */
  8,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  elf64_alpha_read_ecoff_info
};

/* Use a non-standard hash bucket size of 8.  */

static const struct elf_size_info alpha_elf_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,
  1,
  64, 3,
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_checksum_contents,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
};

#define TARGET_LITTLE_SYM	bfd_elf64_alpha_vec
#define TARGET_LITTLE_NAME	"elf64-alpha"
#define ELF_ARCH		bfd_arch_alpha
#define ELF_TARGET_ID		ALPHA_ELF_DATA
#define ELF_MACHINE_CODE	EM_ALPHA
#define ELF_MAXPAGESIZE	0x10000
#define ELF_COMMONPAGESIZE	0x2000

#define bfd_elf64_bfd_link_hash_table_create \
  elf64_alpha_bfd_link_hash_table_create

#define bfd_elf64_bfd_reloc_type_lookup \
  elf64_alpha_bfd_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup \
  elf64_alpha_bfd_reloc_name_lookup
#define elf_info_to_howto \
  elf64_alpha_info_to_howto

#define bfd_elf64_mkobject \
  elf64_alpha_mkobject
#define elf_backend_object_p \
  elf64_alpha_object_p

#define elf_backend_section_from_shdr \
  elf64_alpha_section_from_shdr
#define elf_backend_section_flags \
  elf64_alpha_section_flags
#define elf_backend_fake_sections \
  elf64_alpha_fake_sections

#define bfd_elf64_bfd_is_local_label_name \
  elf64_alpha_is_local_label_name
#define bfd_elf64_find_nearest_line \
  elf64_alpha_find_nearest_line
#define bfd_elf64_bfd_relax_section \
  elf64_alpha_relax_section

#define elf_backend_add_symbol_hook \
  elf64_alpha_add_symbol_hook
#define elf_backend_relocs_compatible \
  _bfd_elf_relocs_compatible
#define elf_backend_check_relocs \
  elf64_alpha_check_relocs
#define elf_backend_create_dynamic_sections \
  elf64_alpha_create_dynamic_sections
#define elf_backend_adjust_dynamic_symbol \
  elf64_alpha_adjust_dynamic_symbol
#define elf_backend_merge_symbol_attribute \
  elf64_alpha_merge_symbol_attribute
#define elf_backend_copy_indirect_symbol \
  elf64_alpha_copy_indirect_symbol
#define elf_backend_always_size_sections \
  elf64_alpha_always_size_sections
#define elf_backend_size_dynamic_sections \
  elf64_alpha_size_dynamic_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_relocate_section \
  elf64_alpha_relocate_section
#define elf_backend_finish_dynamic_symbol \
  elf64_alpha_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
  elf64_alpha_finish_dynamic_sections
#define bfd_elf64_bfd_final_link \
  elf64_alpha_final_link
#define elf_backend_reloc_type_class \
  elf64_alpha_reloc_type_class

#define elf_backend_can_gc_sections	1
#define elf_backend_gc_mark_hook	elf64_alpha_gc_mark_hook
#define elf_backend_gc_sweep_hook	elf64_alpha_gc_sweep_hook

#define elf_backend_ecoff_debug_swap \
  &elf64_alpha_ecoff_debug_swap

#define elf_backend_size_info \
  alpha_elf_size_info

#define elf_backend_special_sections \
  elf64_alpha_special_sections

/* A few constants that determine how the .plt section is set up.  */
#define elf_backend_want_got_plt 0
#define elf_backend_plt_readonly 0
#define elf_backend_want_plt_sym 1
#define elf_backend_got_header_size 0

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"
#undef	ELF_OSABI
#define	ELF_OSABI		ELFOSABI_FREEBSD

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void
elf64_alpha_fbsd_post_process_headers (bfd * abfd,
	struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = get_elf_backend_data (abfd)->elf_osabi;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#undef  elf64_bed
#define elf64_bed elf64_alpha_fbsd_bed

#include "elf64-target.h"
@


1.192
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012
d3593 3
a3595 1
  switch (!dynamic && !info->link_info->shared)
@


1.192.2.1
log
@bfd/
	* elf64-alpha.c (elf64_alpha_relax_tls_get_addr): Cast switch
	expression to int to silence over-eager compiler warnings.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d3593 1
a3593 3
  /* Some compilers warn about a Boolean-looking expression being
     used in a switch.  The explicit cast silences them.  */
  switch ((int) (!dynamic && !info->link_info->shared))
@


1.191
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d1815 3
@


1.190
log
@	* elf-bfd.h (struct elf_obj_tdata): Move find_line_info, local_stubs,
	local_call_stubs, elf_data_symbol, elf_text_symbol, elf_data_section,
	and elf_text_section to..
	* elfxx-mips.c (struct mips_elf_obj_tdata): ..here.  Update all refs.
	* elf64-alpha.c (struct mips_elf_find_line): Rename to..
	(struct alpha_elf_find_line): ..this.
	(struct alpha_elf_obj_tdata): Add find_line_info, update refs.
@
text
@d5318 3
a5320 1
elf64_alpha_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.189
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d302 9
d340 4
a1445 11
/* Alpha ELF follows MIPS ELF in using a special find_nearest_line
   routine in order to handle the ECOFF debugging information.  We
   still call this mips_elf_find_line because of the slot
   find_line_info in elf_obj_tdata is declared that way.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

d1465 1
a1465 1
      struct mips_elf_find_line *fi;
d1476 1
a1476 1
      fi = elf_tdata (abfd)->find_line_info;
d1483 1
a1483 1
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);
d1485 1
a1485 1
	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
d1514 1
a1514 1
	  elf_tdata (abfd)->find_line_info = fi;
@


1.188
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d228 1
a228 1
/* Should we do dynamic things to this symbol?  This differs from the 
d4144 1
a4144 1
  
d4893 1
a4893 1
	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
d4898 1
a4898 1
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
@


1.187
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d4905 1
a4905 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.186
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d1455 1
a1455 1
				     line_ptr, 0,
@


1.185
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d214 1
a214 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, PTR)) (func),	\
d360 1
a360 1
		       PTR data ATTRIBUTE_UNUSED, asection *sec,
d373 1
a373 1
		       PTR data ATTRIBUTE_UNUSED, asection *sec,
d425 1
a425 1
			  asymbol *sym ATTRIBUTE_UNUSED, PTR data,
d1380 4
a1383 4
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
d1388 3
a1390 3
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
d1510 1
a1510 1
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);
d1552 1
a1552 1
elf64_alpha_output_extsym (struct alpha_elf_link_hash_entry *h, PTR data)
d2395 1
a2395 1
					 PTR arg ATTRIBUTE_UNUSED)
d2547 2
a2548 1
elf64_alpha_size_plt_section_1 (struct alpha_elf_link_hash_entry *h, PTR data)
d3174 1
a3174 1
		         (info->abfd, info->tsec, (PTR) NULL,
d3759 1
a3759 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d5107 1
a5107 1
	  if (mdebug_handle == (PTR) NULL)
d5211 1
a5211 1
		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
d5258 1
a5258 1
				  (PTR) &einfo);
@


1.184
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d2106 1
a2106 1
      s = bfd_get_section_by_name(dynobj, ".plt");
d2592 1
a2592 1
  splt = bfd_get_section_by_name (dynobj, ".plt");
d2602 1
a2602 1
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
d2618 1
a2618 1
      sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
d2777 1
a2777 1
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
d2827 1
a2827 1
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
d2863 1
a2863 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d4158 1
a4158 1
    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d4169 1
a4169 1
      srel = bfd_get_section_by_name (dynobj, section_name);
d4785 1
a4785 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
d4787 1
a4787 1
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
d4857 1
a4857 1
      srel = bfd_get_section_by_name (dynobj, ".rela.got");
d4922 1
a4922 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d4930 2
a4931 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      srelaplt = bfd_get_section_by_name (output_bfd, ".rela.plt");
d4939 1
a4939 1
	  sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
@


1.183
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4113 2
a4114 2
					 rel, relend,
					 elf64_alpha_howto_table + r_type,
d4322 1
a4322 1
					 rel, relend, howto, contents);
@


1.182
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d3 2
a4 1
   2006, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.
d4111 1
a4111 1
      if (sec != NULL && elf_discarded_section (sec))
d4269 1
a4269 1
	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
d4320 1
a4320 1
      if (sec != NULL && elf_discarded_section (sec))
d4731 1
a4731 1
		&& elf_discarded_section (sec))
@


1.181
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@d4216 1
a4297 1
	  bfd_boolean unresolved_reloc;
d4530 6
a4535 1
		     && !undef_weak_ref)
d4581 5
a4585 1
	  if (r_symndx == STN_UNDEF)
@


1.180
log
@        PR ld/12928
        * elf64-alpha.c (elf64_alpha_relax_tls_get_addr): Recover the
        tlsgd insn before swapping adjacent insns.
@
text
@d1451 2
a1452 1
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
@


1.180.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4109 1
a4109 1
      if (sec != NULL && discarded_section (sec))
d4266 1
a4266 1
	      && sec->sec_info_type == SEC_INFO_TYPE_MERGE
d4318 1
a4318 1
      if (sec != NULL && discarded_section (sec))
d4720 1
a4720 1
		&& discarded_section (sec))
@


1.179
log
@        * elf64-alpha.c (elf64_alpha_check_relocs): No dynamic reloc for
        TPREL in a PIE image.
        (alpha_dynamic_entries_for_reloc): Likewise.
        (elf64_alpha_relocate_section): Allow TPREL in PIE images.
        (elf64_alpha_relax_got_load): Likewise.
@
text
@d3511 7
a3584 7
  /* Beware of the compiler hoisting part of the sequence out a loop
     and adjusting the destination register for the TLSGD insn.  If this
     happens, there will be a move into $16 before the JSR insn, so only
     transformations of the first insn pair should use this register.  */
  tlsgd_reg = bfd_get_32 (info->abfd, pos[0]);
  tlsgd_reg = (tlsgd_reg >> 21) & 31;

@


1.178
log
@	* elf64-alpha.c (elf64_alpha_copy_indirect_symbol): Rename from
	elf64_alpha_merge_ind_symbols; adjust for the generic interface.
	(elf64_alpha_always_size_sections): Don't call
	elf64_alpha_merge_ind_symbols.
	(elf_backend_copy_indirect_symbol): New.
@
text
@d1885 6
a1890 1
	  if (info->shared || maybe_dynamic)
a1891 2
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
d2657 1
a2657 1
alpha_dynamic_entries_for_reloc (int r_type, int dynamic, int shared)
d2667 1
d2669 1
a2669 1
      return dynamic || shared;
d2676 1
d2678 1
a2678 1
      return dynamic || shared;
d2726 1
a2726 1
						 info->shared);
d2769 2
a2770 2
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);
d2820 1
a2820 1
			    (gotent->reloc_type, 0, info->shared));
d3052 2
a3053 1
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
d4518 1
a4518 1
		if (!info->shared)
d4639 1
a4639 1
	  if (info->shared)
@


1.177
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2151 9
a2159 5
static bfd_boolean
elf64_alpha_merge_ind_symbols (struct alpha_elf_link_hash_entry *hi,
			       PTR dummy ATTRIBUTE_UNUSED)
{
  struct alpha_elf_link_hash_entry *hs;
d2161 2
a2162 6
  if (hi->root.root.type != bfd_link_hash_indirect)
    return TRUE;
  hs = hi;
  do {
    hs = (struct alpha_elf_link_hash_entry *)hs->root.root.u.i.link;
  } while (hs->root.root.type == bfd_link_hash_indirect);
d2165 1
d2167 6
a2172 1
  hs->flags |= hi->flags;
a2225 2

  return TRUE;
a2631 4
  /* First, take care of the indirect symbols created by versioning.  */
  alpha_elf_link_hash_traverse (htab, elf64_alpha_merge_ind_symbols,
				NULL);

d5446 2
@


1.176
log
@        * elf64-alpha.c (elf64_alpha_size_dynamic_sections): Do not
        exclude empty .got sections.
@
text
@a1555 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

a2389 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

a2691 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

a2744 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

@


1.175
log
@        * elf64-alpha.c (elf64_alpha_gc_mark_hook): New.
        (elf64_alpha_gc_sweep_hook): New.
        (elf_backend_gc_mark_hook, elf_backend_gc_sweep_hook): New.
        (elf_backend_can_gc_sections): New.
@
text
@d2930 2
a2931 1
	  s->flags |= SEC_EXCLUDE;
@


1.174
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
d1991 87
d5474 4
@


1.173
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d4028 4
a4031 10
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  */
	  _bfd_clear_contents (elf64_alpha_howto_table + r_type,
			       input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
d4237 2
a4238 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.172
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d4089 1
a4089 1
		       elf_section_data(input_section)->rel_hdr.sh_name));
@


1.171
log
@Use bfd_elf_generic_reloc for alpha-elf.
@
text
@d1869 2
a1870 2
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
d3494 1
a3494 1
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
d3727 2
a3728 2
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
d4157 1
a4157 1
	 reloc to the 0 symbol so that they all match.  */
d4159 1
a4159 1
	r_symndx = 0;
d4169 1
a4169 1
	  /* If this is a tp-relative relocation against sym 0,
d4172 1
a4172 1
	  if (r_symndx == 0
d4458 1
a4458 1
		     && r_symndx != 0
d4506 1
a4506 1
	  if (r_symndx == 0)
@


1.170
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d497 1
a497 1
	 0,			/* special_function */
d512 1
a512 1
	 0,			/* special_function */
d529 1
a529 1
	 0,			/* special_function */
d544 1
a544 1
	 0,			/* special_function */
d610 1
a610 1
	 0,			/* special_function */
d625 1
a625 1
	 0,			/* special_function */
d640 1
a640 1
	 0,			/* special_function */
d655 1
a655 1
	 0,			/* special_function */
d670 1
a670 1
	 0,			/* special_function */
d692 1
a692 1
	 0,			/* special_function */
d707 1
a707 1
	 0,			/* special_function */
d722 1
a722 1
	 0,			/* special_function */
d808 1
a808 1
	 0,			/* special_function */
d823 1
a823 1
	 0,			/* special_function */
d838 1
a838 1
	 0,			/* special_function */
d853 1
a853 1
	 0,			/* special_function */
d869 1
a869 1
	 0,			/* special_function */
d884 1
a884 1
	 0,			/* special_function */
d899 1
a899 1
	 0,			/* special_function */
d914 1
a914 1
	 0,			/* special_function */
d929 1
a929 1
	 0,			/* special_function */
d945 1
a945 1
	 0,			/* special_function */
d960 1
a960 1
	 0,			/* special_function */
d975 1
a975 1
	 0,			/* special_function */
d990 1
a990 1
	 0,			/* special_function */
d1005 1
a1005 1
	 0,			/* special_function */
@


1.169
log
@        PR ld/11891
        * elf64-alpha.c (elf64_alpha_relax_tls_get_addr): Disallow relaxing
        to tlshi/lo until pos0 and pos1 are adjacent.  Use the destination
        register from the tldgd insn.
@
text
@d5337 1
@


1.168
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d3385 1
a3385 1
  unsigned int insn;
d3387 1
a3387 1
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
a3427 1
  pos1_unusable = FALSE;
a3437 2
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
d3495 8
d3516 1
a3516 1
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
d3527 1
a3527 1
		 && !pos1_unusable)
d3529 1
a3529 1
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
d3531 1
a3531 1
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
d3546 1
a3546 1
      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
@


1.167
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009  Free Software Foundation, Inc.
d219 2
a220 1
  ((struct alpha_elf_link_hash_table *) ((p)->hash))
d291 2
a292 1
				      sizeof (struct alpha_elf_link_hash_entry)))
d338 1
a338 1
   && elf_object_id (bfd) == ALPHA_ELF_TDATA)
d344 1
a344 1
				  ALPHA_ELF_TDATA);
d2327 7
a2333 1
  bfd *i, *got_list = alpha_elf_hash_table(info)->got_list;
d2341 1
a2341 1
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
d2379 1
d2381 4
a2384 1
  got_list = alpha_elf_hash_table (info)->got_list;
d2424 1
a2424 1
      alpha_elf_hash_table (info)->got_list = got_list;
d2495 5
d2508 1
a2508 1
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
d2538 1
d2543 4
d2548 1
a2548 2
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_merge_ind_symbols,
d2555 1
a2555 1
  i = alpha_elf_hash_table (info)->got_list;
d2711 5
d2721 1
a2721 1
  for (i = alpha_elf_hash_table(info)->got_list;
d2754 1
a2754 1
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
d2767 5
d2791 1
a2791 1
      alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
d3631 5
d3649 1
a3649 1
  if (alpha_elf_hash_table(link_info)->relax_trip != link_info->relax_trip)
d3651 1
a3651 1
      alpha_elf_hash_table(link_info)->relax_trip = link_info->relax_trip;
d4972 6
a4977 1
  PTR mdebug_handle = NULL;
d5132 1
a5132 2
		  h = alpha_elf_link_hash_lookup (alpha_elf_hash_table (info),
						  name, FALSE, FALSE, TRUE);
d5196 1
a5196 1
    for (i = alpha_elf_hash_table(info)->got_list;
@


1.166
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2008 Free Software Foundation, Inc.
d106 51
d179 1
a179 31
  struct alpha_elf_got_entry
  {
    struct alpha_elf_got_entry *next;

    /* Which .got subsection?  */
    bfd *gotobj;

    /* The addend in effect for this entry.  */
    bfd_vma addend;

    /* The .got offset for this entry.  */
    int got_offset;

    /* The .plt offset for this entry.  */
    int plt_offset;

    /* How many references to this entry?  */
    int use_count;

    /* The relocation type of this entry.  */
    unsigned char reloc_type;

    /* How a LITERAL is used.  */
    unsigned char flags;

    /* Have we initialized the dynamic relocation for this entry?  */
    unsigned char reloc_done;

    /* Have we adjusted this entry for SEC_MERGE?  */
    unsigned char reloc_xlated;
  } *got_entries;
d183 1
a183 16
  struct alpha_elf_reloc_entry
  {
    struct alpha_elf_reloc_entry *next;

    /* Which .reloc section? */
    asection *srel;

    /* What kind of relocation? */
    unsigned int rtype;

    /* Is this against read-only section? */
    unsigned int reltext : 1;

    /* How many did we find?  */
    unsigned long count;
  } *reloc_entries;
d467 1
d469 1
a469 1
  HOWTO(N, 0, 0, 0, 0, 0, 0, elf64_alpha_reloc_bad, 0, 0, 0, 0, 0)
d5072 1
a5072 1
	      eraw_src = input_debug.external_ext;
@


1.165
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@a1750 1
  const char *rel_sec_name;
a1774 1
  rel_sec_name = NULL;
a1923 13
	  if (rel_sec_name == NULL)
	    {
	      rel_sec_name = (bfd_elf_string_from_elf_section
			      (abfd, elf_elfheader(abfd)->e_shstrndx,
			       elf_section_data(sec)->rel_hdr.sh_name));
	      if (rel_sec_name == NULL)
		return FALSE;

	      BFD_ASSERT (CONST_STRNEQ (rel_sec_name, ".rela")
			  && strcmp (bfd_get_section_name (abfd, sec),
				     rel_sec_name+5) == 0);
	    }

d1926 1
a1926 2
	     the linker.  If not used, we'll kill it in
	     size_dynamic_sections.  */
d1929 3
a1931 1
	      sreloc = bfd_get_section_by_name (dynobj, rel_sec_name);
d1933 1
a1933 14
		{
		  flagword flags;

		  flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
			   | SEC_LINKER_CREATED | SEC_READONLY);
		  if (sec->flags & SEC_ALLOC)
		    flags |= SEC_ALLOC | SEC_LOAD;
		  sreloc = bfd_make_section_with_flags (dynobj,
							rel_sec_name,
							flags);
		  if (sreloc == NULL
		      || !bfd_set_section_alignment (dynobj, sreloc, 3))
		    return FALSE;
		}
@


1.164
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d3107 1
a3107 1
  if (info->link_info->hash->creator != info->tsec->owner->xvec
@


1.163
log
@	PR ld/4424
	* config.bfd (targ_selvecs): Add bfd_elf64_alpha_vec for
	alpha/FreeBSD.  Add bfd_elf64_sparc_vec for sparc64/FreeBSD.
	Add bfd_elf32_i386_vec and bfd_efi_app_ia32_vec for i386/FreeBSD.
	(targ64_selvecs): Set for i386/FreeBSD.
	* elf-bfd.h (elf_backend_data): Add relocs_compatible.
	(_bfd_elf_default_relocs_compatible): Declare.
	(_bfd_elf_relocs_compatible): Declare.
	* elfxx-target.h (elf_backend_relocs_compatible): Define.
	(elfNN_bed): Init new relocs_compatible field.
	* elflink.c (_bfd_elf_default_relocs_compatible): New function.
	(_bfd_elf_relocs_compatible): New function.
	(elf_link_add_object_symbols): Call bed->relocs_compatible.
	* elf32-i386.c (elf_backend_relocs_compatible): Define.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
d327 5
d335 2
a336 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d1236 3
d1265 3
d1769 3
a1771 1
  dynobj = elf_hash_table(info)->dynobj;
d1773 1
a1773 1
    elf_hash_table(info)->dynobj = dynobj = abfd;
d1777 2
a1778 2
  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
  sym_hashes = alpha_elf_sym_hashes(abfd);
d2400 6
a2405 1
	  bfd *this_got = alpha_elf_tdata (i)->gotobj;
d2436 3
d3630 2
d3648 1
a3648 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d3955 1
a3955 1
  symtab_hdr_sh_info = elf_tdata (input_bfd)->symtab_hdr.sh_info;
d4043 2
d4055 1
a4055 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d5065 5
a5069 9
	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
		{
		  /* I don't know what a non ALPHA ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}
@


1.162
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@d5332 2
@


1.161
log
@Switch sources over to use the GPL version 3
@
text
@d5280 1
@


1.160
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.159
log
@bfd/
        * elf64-alpha.c (struct alpha_elf_link_hash_table): Add relax_trip.
        (elf64_alpha_size_got_sections): Remove unused something_changed local.
        (elf64_alpha_size_plt_section): Return void.
        (elf64_alpha_size_rela_got_section): Likewise.
        (elf64_alpha_relax_section): Only regenerate got+plt if the
        relax_trip counter has changed.
include/
        * bfdlink.h (struct bfd_link_info): Add relax_trip.
ld/
        * ldlang.c (relax_sections): Initialize and increment
        link_info.relax_trip.
@
text
@d25 1
a26 1
#include "sysdep.h"
@


1.158
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d187 4
a2381 1
  int something_changed = 0;
a2418 3

      /* Force got offsets to be recalculated.  */
      something_changed = 1;
a2431 2
	  
	  something_changed = 1;
d2442 1
a2442 2
  if (1 || something_changed)
    elf64_alpha_calc_got_offsets (info);
d2477 2
a2478 2
/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */
d2480 1
a2480 1
static bfd_boolean
d2490 1
a2490 1
    return TRUE;
d2499 1
a2506 2
  else
    entries = 0;
a2516 2

  return TRUE;
d2687 1
a2687 1
static bfd_boolean
d2726 1
a2726 1
      return TRUE;
a2732 2

  return TRUE;
d3604 1
a3604 1
  /* We are not currently changing any sizes, so only one pass.  */
d3613 16
a3837 7
  if (!elf64_alpha_size_plt_section (link_info))
    return FALSE;
  if (!elf64_alpha_size_got_sections (link_info))
    return FALSE;
  if (!elf64_alpha_size_rela_got_section (link_info))
    return FALSE;

@


1.157
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d1058 17
d5302 2
@


1.156
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d5357 2
d5373 1
a5373 1
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
@


1.155
log
@	* elf64-alpha.c (elf64_alpha_merge_symbol_attribute): New function.
	(elf_backend_merge_symbol_attribute): Define.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d3915 1
d3919 1
d3929 1
a3929 1
      r_type = ELF64_R_TYPE(rel->r_info);
a3939 2
      r_symndx = ELF64_R_SYM(rel->r_info);

d3945 1
d3949 30
a3978 5
	  if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
	    {
	      sec = local_sections[r_symndx];
	      rel->r_addend += sec->output_offset + sym->st_value;
	    }
d3980 3
d4182 11
a4251 12
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

@


1.154
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2038 13
d5287 2
@


1.153
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d5278 2
@


1.152
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d1904 1
a1904 1
	      BFD_ASSERT (strncmp (rel_sec_name, ".rela", 5) == 0
d2764 1
a2764 1
      if (strncmp (name, ".rela", 5) == 0)
d2776 1
a2776 1
      else if (strncmp (name, ".got", 4) != 0
d5151 3
a5153 3
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sdata", 6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,     0,  0, 0,            0 }
@


1.151
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@a323 2
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d325 7
a331 2
    return FALSE;
  return TRUE;
@


1.150
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d5234 1
@


1.149
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d276 3
a278 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf64_alpha_link_hash_newfunc))
@


1.148
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d4720 2
a4721 2
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
@


1.147
log
@	* elf-bfd.h (_bfd_elf_define_linkage_sym): Declare.
	* elflink.c (_bfd_elf_define_linkage_sym): New function, extracted
	from..
	(_bfd_elf_create_got_section): ..here.
	(_bfd_elf_link_create_dynamic_sections): Call it for _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): ..and _PROCEDURE_LINKAGE_TABLE_.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Use
	_bfd_elf_define_linkage_sym.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
@
text
@d1247 4
a1250 2
  if (!_bfd_elf_define_linkage_sym (abfd, info, s,
				    "_PROCEDURE_LINKAGE_TABLE_"))
@


1.146
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@a1234 1
  struct bfd_link_hash_entry *bh;
d1247 2
a1248 11
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;

  if (info->shared && ! bfd_elf_link_record_dynamic_symbol (info, h))
d1285 4
a1288 5
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL,
	 alpha_elf_tdata(abfd)->got, (bfd_vma) 0, (const char *) NULL,
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
a1289 9
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  elf_hash_table (info)->hgot = h;
@


1.145
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a2769 1
      bfd_boolean strip;
a2777 10
      /* If we don't need this section, strip it from the output file.
	 This is to handle .rela.bss and .rela.plt.  We must create it
	 in create_dynamic_sections, because it must be created before
	 the linker maps input sections to output sections.  The
	 linker does that before adjust_dynamic_symbol is called, and
	 it is that function which decides whether anything needs to
	 go into these sections.  */

      strip = FALSE;

d2780 1
a2780 3
	  strip = (s->size == 0);

	  if (!strip)
d2782 1
a2782 1
	      if (strcmp(name, ".rela.plt") == 0)
d2790 3
a2792 1
      else if (strcmp (name, ".plt") != 0)
d2798 12
a2809 3
      if (strip)
	s->flags |= SEC_EXCLUDE;
      else
d2813 1
a2813 1
	  if (s->contents == NULL && s->size != 0)
@


1.144
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a5171 18
static const struct bfd_elf_special_section *
elf64_alpha_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf64_alpha_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d5310 2
a5311 2
#define elf_backend_get_sec_type_attr \
  elf64_alpha_get_sec_type_attr
@


1.143
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d5165 1
a5165 1
static struct bfd_elf_special_section const elf64_alpha_special_sections[] =
d5175 1
a5175 1
  const struct bfd_elf_special_section const *ssect;
@


1.142
log
@	* elf64-alpha.c (elf64_alpha_create_got_section): Always create
	a new .got section.
	(elf64_alpha_create_dynamic_sections): Always make new sections
	by using bfd_make_section_anyway_with_flags.  Check that .got not
	already created.
	(elf64_alpha_check_relocs): Delete "got_created".  Use tdata->gotobj
	instead.
@
text
@d5165 1
a5165 2
static struct bfd_elf_special_section const
  alpha_special_sections_s[]=
d5167 1
a5168 1
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
d5172 2
a5173 2
static struct bfd_elf_special_section const *
  elf64_alpha_special_sections[27] =
d5175 14
a5188 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  alpha_special_sections_s,	/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d5328 2
a5329 2
#define elf_backend_special_sections \
  elf64_alpha_special_sections
@


1.141
log
@        * elf64-alpha.c (ALPHA_ELF_LINK_HASH_LU_JSRDIRECT): New.
        (ALPHA_ELF_LINK_HASH_TLS_IE): Renumber to 0x80.
        (ALPHA_ELF_LINK_HASH_LU_PLT): Rename from ALPHA_ELF_LINK_HASH_LU_FUNC.
        (elf64_alpha_want_plt): Update to match.
        (elf64_alpha_check_relocs): Collect JSRDIRECT in gotent_flags.
        (elf64_alpha_relax_with_lituse): Likewise.  Handle JSRDIRECT.
@
text
@d1207 1
d1210 3
a1212 12
  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
    }

  s = bfd_make_section_with_flags (abfd, ".got", (SEC_ALLOC | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED));
d1219 5
d1233 1
d1239 4
a1242 7
  s = bfd_make_section_with_flags (abfd, ".plt",
				   (SEC_ALLOC | SEC_LOAD | SEC_CODE
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | (elf64_alpha_use_secureplt
				       ? SEC_READONLY : 0)));
d1261 3
a1263 6
  s = bfd_make_section_with_flags (abfd, ".rela.plt",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
d1269 2
a1270 2
      s = bfd_make_section_with_flags (abfd, ".got.plt",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d1278 5
a1282 2
  if (!elf64_alpha_create_got_section (abfd, info))
    return FALSE;
d1284 3
a1286 6
  s = bfd_make_section_with_flags (abfd, ".rela.got",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
a1740 1
  bfd_boolean got_created;
a1762 1
  got_created = FALSE;
d1874 1
a1874 1
	  if (!got_created)
a1877 8

	      /* Make sure the object's gotobj is set to itself so
		 that we default to every object with its own .got.
		 We'll merge .gots later once we've collected each
		 object's info.  */
	      alpha_elf_tdata(abfd)->gotobj = abfd;

	      got_created = 1;
@


1.140
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Use dtp_base for
        the zero index relocs produced by elf64_alpha_relax_tls_get_addr.
@
text
@d115 9
a123 8
#define ALPHA_ELF_LINK_HASH_LU_ADDR	0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	0x20
#define ALPHA_ELF_LINK_HASH_LU_FUNC	0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	0x40
d1733 2
a1734 2
	  && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC) != 0
	  && (ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC) == 0);
d1830 1
a1830 1
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
d3141 1
a3141 1
      if (urel->r_addend <= 3)
d3236 1
@


1.139
log
@        * configure.in (--enable-secureplt): New.
        * elf64-alpha.c (INSN_LDA, INSN_LDAH, INSN_LDQ, INSN_BR): New.
        (INSN_SUBQ, INSN_S4SUBQ, INSN_JMP): New.
        (INSN_A, INSN_AB, INSN_ABC, INSN_ABO, INSN_AD): New.
        (elf64_alpha_use_secureplt): New.
        (OLD_PLT_HEADER_SIZE, OLD_PLT_ENTRY_SIZE): New.
        (NEW_PLT_HEADER_SIZE, NEW_PLT_ENTRY_SIZE): New.
        (PLT_HEADER_SIZE, PLT_ENTRY_SIZE): Conditionalize on secureplt.
        (ALPHA_ELF_LINK_HASH_PLT_LOC): Remove.
        (struct alpha_elf_link_hash_entry): Add plt_offset.
        (PLT_HEADER_WORD1, PLT_HEADER_WORD2, PLT_HEADER_WORD3): Remove.
        (PLT_HEADER_WORD4, PLT_ENTRY_WORD1, PLT_ENTRY_WORD2): Remove.
        (PLT_ENTRY_WORD3): Remove.
        (elf64_alpha_create_dynamic_sections): If secureplt, set SEC_READONLY
        on .plt and create .got.plt.
        (elf64_alpha_output_extsym): Remove .plt frobbing for symbol values.
        (get_got_entry): Initialize plt_offset.
        (elf64_alpha_want_plt): New.
        (elf64_alpha_check_relocs): Use it.
        (elf64_alpha_adjust_dynamic_symbol): Likewise.  Don't allocate
        plt entries here.
        (elf64_alpha_calc_got_offsets_for_symbol): Don't report internal
        error as user error.
        (elf64_alpha_size_plt_section_1): Allocate one plt entry per
        got subsection.
        (elf64_alpha_size_plt_section): Size .got.plt section.
        (elf64_alpha_size_rela_got_1): Don't allocate relocations if
        plt entries used.
        (elf64_alpha_size_dynamic_sections): Call elf64_alpha_size_plt_section.
        Add PLTRO DYNAMIC entry.
        (elf64_alpha_finish_dynamic_symbol): Generate secureplt format.
        (elf64_alpha_finish_dynamic_sections): Likewise.
@
text
@d4101 1
a4101 1
	     be the tls base.  */
d4109 1
a4109 1
	    value = tp_base;
@


1.138
log
@        * elf64-alpha.c (struct alpha_elf_link_hash_entry): Remove
        plt_old_section, plt_old_value.
        (elf64_alpha_adjust_dynamic_symbol): Don't set it.
        (elf64_alpha_size_plt_section_1): Don't use it.
@
text
@d51 53
a122 1
#define ALPHA_ELF_LINK_HASH_PLT_LOC	0x80
d138 3
a1078 16
/* PLT/GOT Stuff */
#define PLT_HEADER_SIZE 32
#define PLT_HEADER_WORD1	(bfd_vma) 0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	(bfd_vma) 0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	(bfd_vma) 0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	(bfd_vma) 0x6b7b0000	/* jmp  $27,($27)   */

#define PLT_ENTRY_SIZE 12
#define PLT_ENTRY_WORD1		0xc3800000	/* br   $28, plt0   */
#define PLT_ENTRY_WORD2		0
#define PLT_ENTRY_WORD3		0

#define MAX_GOT_SIZE		(64*1024)

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so"

d1241 1
a1241 1
				   (SEC_ALLOC | SEC_LOAD
d1245 3
a1247 3
				    | SEC_CODE));
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 3))
d1262 1
a1262 2
  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d1271 1
a1271 2
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 3))
d1274 8
a1635 18
  else if (h->root.needs_plt)
    {
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = bfd_get_section_by_name (einfo->abfd, ".plt");
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
	{
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
	  else
	    h->esym.asym.value = 0;
	}
    }
d1706 1
d1726 10
d1915 7
a1921 6
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.needs_plt = 1;
		  else
		    h->root.needs_plt = 0;
	        }
d2028 5
a2032 13
     about whether this symbol should get a .plt entry.  */

  if (alpha_elf_dynamic_symbol_p (h, info)
      && ((h->type == STT_FUNC
	   && !(ah->flags & ALPHA_ELF_LINK_HASH_LU_ADDR))
	  || (h->type == STT_NOTYPE
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
      /* Don't prevent otherwise valid programs from linking by attempting
	 to create a new .got entry somewhere.  A Correct Solution would be
	 to add a new .got section to a new object file and let it be merged
	 somewhere later.  But for now don't bother.  */
      && ah->got_entries)
d2034 1
a2034 1
      h->needs_plt = 1;
d2040 3
a2042 11
      /* The first bit of the .plt is reserved.  */
      if (s->size == 0)
	s->size = PLT_HEADER_SIZE;

      h->plt.offset = s->size;
      s->size += PLT_ENTRY_SIZE;

      /* We also need a JMP_SLOT entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf64_External_Rela);
d2047 1
a2047 1
    h->needs_plt = 0;
a2309 1
  bfd_boolean result = TRUE;
a2321 7
	if (td == NULL)
	  {
	    _bfd_error_handler (_("Symbol %s has no GOT subsection for offset 0x%x"),
				h->root.root.root.string, gotent->got_offset);
	    result = FALSE;
	    continue;
	  }
d2327 1
a2327 1
  return result;
d2456 1
d2462 1
a2462 1
  /* There must still be a LITERAL got entry for the function.  */
d2466 7
a2472 1
      break;
d2474 3
a2476 14
  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
    {
      if (splt->size == 0)
	splt->size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->size;
      splt->size += PLT_ENTRY_SIZE;
    }
  else
    {
      h->root.needs_plt = 0;
      h->root.plt.offset = -1;
    }
d2487 1
a2487 1
  asection *splt, *spltrel;
d2492 1
a2492 1
  splt = bfd_get_section_by_name(dynobj, ".plt");
d2504 6
a2509 1
    entries = (splt->size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d2514 9
d2659 5
a2680 5
  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

d2776 1
d2860 4
a2894 11
#define OP_LDA		0x08
#define OP_LDAH		0x09
#define INSN_JSR	0x68004000
#define INSN_JSR_MASK	0xfc00c000
#define OP_LDQ		0x29
#define OP_BR		0x30
#define OP_BSR		0x34
#define INSN_UNOP	0x2ffe0000
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e

d4621 1
d4624 1
a4624 1
  if (h->plt.offset != MINUS_ONE)
a4635 5
      /* The first .got entry will be updated by the .plt with the
	 address of the target function.  */
      gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
      BFD_ASSERT (gotent && gotent->addend == 0);

a4639 2
      sgot = alpha_elf_tdata (gotent->gotobj)->got;
      BFD_ASSERT (sgot != NULL);
d4641 6
a4646 6
      got_addr = (sgot->output_section->vma
		  + sgot->output_offset
		  + gotent->got_offset);
      plt_addr = (splt->output_section->vma
		  + splt->output_offset
		  + h->plt.offset);
d4648 2
a4649 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d4651 2
a4652 3
      /* Fill in the entry in the procedure linkage table.  */
      {
	bfd_vma insn1, insn2, insn3;
d4654 6
a4659 8
	insn1 = PLT_ENTRY_WORD1 | ((-(h->plt.offset + 4) >> 2) & 0x1fffff);
	insn2 = PLT_ENTRY_WORD2;
	insn3 = PLT_ENTRY_WORD3;

	bfd_put_32 (output_bfd, insn1, splt->contents + h->plt.offset);
	bfd_put_32 (output_bfd, insn2, splt->contents + h->plt.offset + 4);
	bfd_put_32 (output_bfd, insn3, splt->contents + h->plt.offset + 8);
      }
d4661 1
a4661 4
      /* Fill in the entry in the .rela.plt section.  */
      outrel.r_offset = got_addr;
      outrel.r_info = ELF64_R_INFO(h->dynindx, R_ALPHA_JMP_SLOT);
      outrel.r_addend = 0;
d4663 7
a4669 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4671 13
a4683 6
      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in the
	     .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
d4685 3
a4687 2
      /* Fill in the entries in the .got.  */
      bfd_put_64 (output_bfd, plt_addr, sgot->contents + gotent->got_offset);
d4689 12
a4700 25
      /* Subsequent .got entries will continue to bounce through the .plt.  */
      if (gotent->next)
	{
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (! info->shared || srel != NULL);

	  gotent = gotent->next;
	  do
	    {
	      sgot = alpha_elf_tdata(gotent->gotobj)->got;
	      BFD_ASSERT(sgot != NULL);
	      BFD_ASSERT(gotent->addend == 0);

	      bfd_put_64 (output_bfd, plt_addr,
		          sgot->contents + gotent->got_offset);

	      if (info->shared)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, plt_addr);

	      gotent = gotent->next;
	    }
          while (gotent != NULL);
	}
d4777 1
a4777 1
      asection *splt;
d4779 1
d4782 1
d4785 11
a4800 2
	  const char *name;
	  asection *s;
d4807 3
a4809 2
	      name = ".plt";
	      goto get_vma;
d4811 2
a4812 2
	      name = ".rela.plt";
	      goto get_size;
d4814 2
a4815 2
	      name = ".rela.plt";
	      goto get_vma;
d4823 2
a4824 13
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s)
		dyn.d_un.d_val -= s->size;
	      break;

	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      dyn.d_un.d_ptr = (s ? s->vma : 0);
	      break;

	    get_size:
	      s = bfd_get_section_by_name (output_bfd, name);
	      dyn.d_un.d_val = s->size;
d4831 1
a4831 1
      /* Initialize the PLT0 entry.  */
d4834 52
a4885 8
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD1, splt->contents);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD2, splt->contents + 4);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD3, splt->contents + 8);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD4, splt->contents + 12);

	  /* The next two words will be filled in by ld.so */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 16);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 24);
@


1.137
log
@        * elf64-alpha.c: Update all function definitions to ISO C.  Remove
        all function prototypes; rearrange functions into def-use order.
@
text
@a71 4
  /* Used to undo the localization of a plt symbol.  */
  asection *plt_old_section;
  bfd_vma plt_old_value;

a2015 14
      /* If this symbol is not defined in a regular file, and we are not
	 generating a shared library, then set the symbol to the location
	 in the .plt.  This is required to make function pointers compare
	 equal between the normal executable and the shared library.  */
      if (! info->shared
	  && h->root.type != bfd_link_hash_defweak)
	{
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
	  h->root.u.def.section = s;
	  h->root.u.def.value = h->plt.offset;
	}

a2464 8

      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
@


1.136
log
@        * elf64-alpha.c (elf64_alpha_merge_gots): Fix gotent iteration
        in the presence of deleting elements.
        (elf64_alpha_size_got_sections): Zero dead got section size.
@
text
@a49 108
static bfd_boolean alpha_elf_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
static struct bfd_hash_entry * elf64_alpha_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table * elf64_alpha_bfd_link_hash_table_create
  PARAMS ((bfd *));

static bfd_reloc_status_type elf64_alpha_reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_reloc_bad
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_do_reloc_gpdisp
  PARAMS ((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
static bfd_reloc_status_type elf64_alpha_reloc_gpdisp
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static reloc_howto_type * elf64_alpha_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf64_alpha_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));

static bfd_boolean elf64_alpha_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_object_p
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_section_flags
  PARAMS ((flagword *, const Elf_Internal_Shdr *));
static bfd_boolean elf64_alpha_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static bfd_boolean elf64_alpha_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf64_alpha_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
static bfd_boolean elf64_alpha_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean elf64_alpha_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));

#if defined(__STDC__) || defined(ALMOST_STDC)
struct alpha_elf_link_hash_entry;
#endif

static bfd_boolean elf64_alpha_output_extsym
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));

static bfd_boolean elf64_alpha_can_merge_gots
  PARAMS ((bfd *, bfd *));
static void elf64_alpha_merge_gots
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf64_alpha_calc_got_offsets_for_symbol
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static void elf64_alpha_calc_got_offsets
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_got_sections
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section_1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static bfd_boolean elf64_alpha_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static int alpha_dynamic_entries_for_reloc
  PARAMS ((int, int, int));
static bfd_boolean elf64_alpha_calc_dynrel_sizes
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_rela_got_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_rela_got_1
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static struct alpha_elf_got_entry *get_got_entry
  PARAMS ((bfd *, struct alpha_elf_link_hash_entry *, unsigned long,
	   unsigned long, bfd_vma));
static bfd_boolean elf64_alpha_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
	  const Elf_Internal_Rela *));
static bfd_boolean elf64_alpha_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf64_alpha_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void elf64_alpha_emit_dynrel
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *,
	   bfd_vma, long, long, bfd_vma));
static bfd_boolean elf64_alpha_relocate_section_r
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf64_alpha_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_merge_ind_symbols
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static Elf_Internal_Rela * elf64_alpha_find_reloc_at_ofs
  PARAMS ((Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_vma, int));
static enum elf_reloc_type_class elf64_alpha_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d149 1
a149 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d168 2
a169 3
alpha_elf_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
d177 3
a179 4
elf64_alpha_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d215 1
a215 2
elf64_alpha_bfd_link_hash_table_create (abfd)
     bfd *abfd;
d269 1
a269 2
elf64_alpha_mkobject (abfd)
     bfd *abfd;
d279 1
a279 2
elf64_alpha_object_p (abfd)
     bfd *abfd;
d285 111
a942 127
/* A relocation function which doesn't do anything.  */

static bfd_reloc_status_type
elf64_alpha_reloc_nil (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_ok;
}

/* A relocation function used for an unsupported reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_bad (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_notsupported;
}

/* Do the work of the GPDISP relocation.  */

static bfd_reloc_status_type
elf64_alpha_do_reloc_gpdisp (abfd, gpdisp, p_ldah, p_lda)
     bfd *abfd;
     bfd_vma gpdisp;
     bfd_byte *p_ldah;
     bfd_byte *p_lda;
{
  bfd_reloc_status_type ret = bfd_reloc_ok;
  bfd_vma addend;
  unsigned long i_ldah, i_lda;

  i_ldah = bfd_get_32 (abfd, p_ldah);
  i_lda = bfd_get_32 (abfd, p_lda);

  /* Complain if the instructions are not correct.  */
  if (((i_ldah >> 26) & 0x3f) != 0x09
      || ((i_lda >> 26) & 0x3f) != 0x08)
    ret = bfd_reloc_dangerous;

  /* Extract the user-supplied offset, mirroring the sign extensions
     that the instructions perform.  */
  addend = ((i_ldah & 0xffff) << 16) | (i_lda & 0xffff);
  addend = (addend ^ 0x80008000) - 0x80008000;

  gpdisp += addend;

  if ((bfd_signed_vma) gpdisp < -(bfd_signed_vma) 0x80000000
      || (bfd_signed_vma) gpdisp >= (bfd_signed_vma) 0x7fff8000)
    ret = bfd_reloc_overflow;

  /* compensate for the sign extension again.  */
  i_ldah = ((i_ldah & 0xffff0000)
	    | (((gpdisp >> 16) + ((gpdisp >> 15) & 1)) & 0xffff));
  i_lda = (i_lda & 0xffff0000) | (gpdisp & 0xffff);

  bfd_put_32 (abfd, (bfd_vma) i_ldah, p_ldah);
  bfd_put_32 (abfd, (bfd_vma) i_lda, p_lda);

  return ret;
}

/* The special function for the GPDISP reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_gpdisp (abfd, reloc_entry, sym, data, input_section,
			  output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
{
  bfd_reloc_status_type ret;
  bfd_vma gp, relocation;
  bfd_vma high_address;
  bfd_byte *p_ldah, *p_lda;

  /* Don't do anything if we're not doing a final link.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  high_address = bfd_get_section_limit (abfd, input_section);
  if (reloc_entry->address > high_address
      || reloc_entry->address + reloc_entry->addend > high_address)
    return bfd_reloc_outofrange;

  /* The gp used in the portion of the output object to which this
     input object belongs is cached on the input bfd.  */
  gp = _bfd_get_gp_value (abfd);

  relocation = (input_section->output_section->vma
		+ input_section->output_offset
		+ reloc_entry->address);

  p_ldah = (bfd_byte *) data + reloc_entry->address;
  p_lda = p_ldah + reloc_entry->addend;

  ret = elf64_alpha_do_reloc_gpdisp (abfd, gp - relocation, p_ldah, p_lda);

  /* Complain if the instructions are not correct.  */
  if (ret == bfd_reloc_dangerous)
    *err_msg = _("GPDISP relocation did not find ldah and lda instructions");

  return ret;
}

d988 2
a989 3
elf64_alpha_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1005 2
a1006 4
elf64_alpha_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1008 1
a1008 3
  unsigned r_type;

  r_type = ELF64_R_TYPE(dst->r_info);
d1028 6
a1033 1
/* These functions do relaxation for Alpha ELF.
d1035 4
a1038 5
   Currently I'm only handling what I can do with existing compiler
   and assembler support, which means no instructions are removed,
   though some may be nopped.  At this time GCC does not emit enough
   information to do all of the relaxing that is possible.  It will
   take some not small amount of work for that to happen.
d1040 1
a1040 4
   There are a couple of interesting papers that I once read on this
   subject, that I cannot find references to at the moment, that
   related to Alpha in particular.  They are by David Wall, then of
   DEC WRL.  */
d1042 7
a1048 10
#define OP_LDA		0x08
#define OP_LDAH		0x09
#define INSN_JSR	0x68004000
#define INSN_JSR_MASK	0xfc00c000
#define OP_LDQ		0x29
#define OP_BR		0x30
#define OP_BSR		0x34
#define INSN_UNOP	0x2ffe0000
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e
d1050 5
a1054 1
struct alpha_relax_info
d1056 16
a1071 16
  bfd *abfd;
  asection *sec;
  bfd_byte *contents;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *relocs, *relend;
  struct bfd_link_info *link_info;
  bfd_vma gp;
  bfd *gotobj;
  asection *tsec;
  struct alpha_elf_link_hash_entry *h;
  struct alpha_elf_got_entry **first_gotent;
  struct alpha_elf_got_entry *gotent;
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
  unsigned char other;
};
d1073 3
a1075 17
static bfd_boolean elf64_alpha_relax_with_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel));
static bfd_vma elf64_alpha_relax_opt_call
  PARAMS((struct alpha_relax_info *info, bfd_vma symval));
static bfd_boolean elf64_alpha_relax_got_load
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, unsigned long));
static bfd_boolean elf64_alpha_relax_gprelhilo
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_tls_get_addr
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_section
  PARAMS((bfd *abfd, asection *sec, struct bfd_link_info *link_info,
	  bfd_boolean *again));
d1077 1
a1077 7
static Elf_Internal_Rela *
elf64_alpha_find_reloc_at_ofs (rel, relend, offset, type)
     Elf_Internal_Rela *rel, *relend;
     bfd_vma offset;
     int type;
{
  while (rel < relend)
d1079 4
a1082 4
      if (rel->r_offset == offset
	  && ELF64_R_TYPE (rel->r_info) == (unsigned int) type)
	return rel;
      ++rel;
d1084 2
a1085 1
  return NULL;
d1088 2
d1091 1
a1091 4
elf64_alpha_relax_with_lituse (info, symval, irel)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
d1093 8
a1100 8
  Elf_Internal_Rela *urel, *irelend = info->relend;
  int flags, count, i;
  bfd_signed_vma disp;
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
  unsigned int lit_insn;
d1102 4
a1105 9
  lit_insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);
  if (lit_insn >> 26 != OP_LDQ)
    {
      ((*_bfd_error_handler)
       ("%B: %A+0x%lx: warning: LITERAL relocation against unexpected insn",
	info->abfd, info->sec,
	(unsigned long) irel->r_offset));
      return TRUE;
    }
d1107 1
a1107 3
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;
d1109 1
a1109 2
  /* Summarize how this particular LITERAL is used.  */
  for (urel = irel+1, flags = count = 0; urel < irelend; ++urel, ++count)
d1111 7
a1117 4
      if (ELF64_R_TYPE (urel->r_info) != R_ALPHA_LITUSE)
	break;
      if (urel->r_addend <= 3)
	flags |= 1 << urel->r_addend;
d1119 9
d1129 2
a1130 2
  /* A little preparation for the loop...  */
  disp = symval - info->gp;
d1132 10
a1141 1
  for (urel = irel+1, i = 0; i < count; ++i, ++urel)
d1143 2
a1144 3
      unsigned int insn;
      int insn_disp;
      bfd_signed_vma xdisp;
d1146 1
a1146 1
      insn = bfd_get_32 (info->abfd, info->contents + urel->r_offset);
d1148 1
a1148 1
      switch (urel->r_addend)
d1150 14
a1163 6
	case LITUSE_ALPHA_ADDR:
	default:
	  /* This type is really just a placeholder to note that all
	     uses cannot be optimized, but to still allow some.  */
	  all_optimized = FALSE;
	  break;
d1165 1
a1165 2
	case LITUSE_ALPHA_BASE:
	  /* We can always optimize 16-bit displacements.  */
d1167 5
a1171 4
	  /* Extract the displacement from the instruction, sign-extending
	     it if necessary, then test whether it is within 16 or 32 bits
	     displacement from GP.  */
	  insn_disp = ((insn & 0xffff) ^ 0x8000) - 0x8000;
d1173 7
a1179 4
	  xdisp = disp + insn_disp;
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);
d1181 7
a1187 9
	  if (fits16)
	    {
	      /* Take the op code and dest from this insn, take the base
		 register from the literal insn.  Leave the offset alone.  */
	      insn = (insn & 0xffe0ffff) | (lit_insn & 0x001f0000);
	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPREL16);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;
d1189 1
a1189 4
	      bfd_put_32 (info->abfd, (bfd_vma) insn,
			  info->contents + urel->r_offset);
	      info->changed_contents = TRUE;
	    }
d1191 2
a1192 4
	  /* If all mem+byte, we can optimize 32-bit mem displacements.  */
	  else if (fits32 && !(flags & ~6))
	    {
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb.  */
d1194 1
a1194 7
	      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELHIGH);
	      lit_insn = (OP_LDAH << 26) | (lit_insn & 0x03ff0000);
	      bfd_put_32 (info->abfd, (bfd_vma) lit_insn,
			  info->contents + irel->r_offset);
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;
d1196 6
a1201 8
	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELLOW);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;
	    }
	  else
	    all_optimized = FALSE;
	  break;
d1203 1
a1203 2
	case LITUSE_ALPHA_BYTOFF:
	  /* We can always optimize byte instructions.  */
d1205 9
a1213 2
	  /* FIXME: sanity check the insn for byte op.  Check that the
	     literal dest reg is indeed Rb in the byte insn.  */
d1215 11
a1225 2
	  insn &= ~ (unsigned) 0x001ff000;
	  insn |= ((symval & 7) << 13) | 0x1000;
d1227 3
a1229 3
	  urel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  urel->r_addend = 0;
	  info->changed_relocs = TRUE;
d1231 9
a1239 4
	  bfd_put_32 (info->abfd, (bfd_vma) insn,
		      info->contents + urel->r_offset);
	  info->changed_contents = TRUE;
	  break;
d1241 2
a1242 6
	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
	  {
	    bfd_vma optdest, org;
	    bfd_signed_vma odisp;
d1244 57
a1300 8
	    /* For undefined weak symbols, we're mostly interested in getting
	       rid of the got entry whenever possible, so optimize this to a
	       use of the zero register.  */
	    if (info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	      {
		insn |= 31 << 16;
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);
d1302 2
a1303 3
		info->changed_contents = TRUE;
		break;
	      }
d1305 15
a1319 6
	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
	    odisp = (optdest ? optdest : symval) - org;
d1321 13
a1333 3
	    if (odisp >= -0x400000 && odisp < 0x400000)
	      {
		Elf_Internal_Rela *xrel;
d1335 1
a1335 5
		/* Preserve branch prediction call stack when possible.  */
		if ((insn & INSN_JSR_MASK) == INSN_JSR)
		  insn = (OP_BSR << 26) | (insn & 0x03e00000);
		else
		  insn = (OP_BR << 26) | (insn & 0x03e00000);
d1337 1
a1337 3
		urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					     R_ALPHA_BRADDR);
		urel->r_addend = irel->r_addend;
d1339 27
a1365 4
		if (optdest)
		  urel->r_addend += optdest - symval;
		else
		  all_optimized = FALSE;
d1367 1
a1367 2
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);
d1369 5
a1373 6
		/* Kill any HINT reloc that might exist for this insn.  */
		xrel = (elf64_alpha_find_reloc_at_ofs
			(info->relocs, info->relend, urel->r_offset,
			 R_ALPHA_HINT));
		if (xrel)
		  xrel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
d1375 4
a1378 5
		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
	      }
	    else
	      all_optimized = FALSE;
d1380 5
a1384 14
	    /* Even if the target is not in range for a direct branch,
	       if we share a GP, we can eliminate the gp reload.  */
	    if (optdest)
	      {
		Elf_Internal_Rela *gpdisp
		  = (elf64_alpha_find_reloc_at_ofs
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
		if (gpdisp)
		  {
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
		    bfd_byte *p_lda = p_ldah + gpdisp->r_addend;
		    unsigned int ldah = bfd_get_32 (info->abfd, p_ldah);
		    unsigned int lda = bfd_get_32 (info->abfd, p_lda);
d1386 7
a1392 9
		    /* Verify that the instruction is "ldah $29,0($26)".
		       Consider a function that ends in a noreturn call,
		       and that the next function begins with an ldgp,
		       and that by accident there is no padding between.
		       In that case the insn would use $27 as the base.  */
		    if (ldah == 0x27ba0000 && lda == 0x23bd0000)
		      {
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_ldah);
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_lda);
d1394 5
a1398 10
			gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
		      }
		  }
	      }
	  }
	  break;
	}
    }
d1400 2
a1401 3
  /* If all cases were optimized, we can reduce the use count on this
     got entry by one, possibly eliminating it.  */
  if (all_optimized)
d1403 14
a1416 1
      if (--info->gotent->use_count == 0)
d1418 43
a1460 4
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
d1463 3
a1465 5
      /* If the literal instruction is no longer needed (it may have been
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
	 so just nop it out.  */
      if (!lit_reused)
d1467 2
a1468 6
	  irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  info->changed_relocs = TRUE;

	  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP,
		      info->contents + irel->r_offset);
	  info->changed_contents = TRUE;
d1471 1
a1471 1
      return TRUE;
d1473 6
a1478 2
  else
    return elf64_alpha_relax_got_load (info, symval, irel, R_ALPHA_LITERAL);
d1480 2
d1483 1
a1483 4
static bfd_vma
elf64_alpha_relax_opt_call (info, symval)
     struct alpha_relax_info *info;
     bfd_vma symval;
d1485 6
a1490 3
  /* If the function has the same gp, and we can identify that the
     function does not use its function pointer, we can eliminate the
     address load.  */
d1492 6
a1497 4
  /* If the symbol is marked NOPV, we are being told the function never
     needs its procedure value.  */
  if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_NOPV)
    return symval;
d1499 2
a1500 4
  /* If the symbol is marked STD_GP, we are being told the function does
     a normal ldgp in the first two words.  */
  else if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_STD_GPLOAD)
    ;
d1502 14
a1515 2
  /* Otherwise, we may be able to identify a GP load in the first two
     words, which we can then skip.  */
d1517 6
d1524 7
a1530 2
      Elf_Internal_Rela *tsec_relocs, *tsec_relend, *tsec_free, *gpdisp;
      bfd_vma ofs;
d1532 3
a1534 7
      /* Load the relocations from the section that the target symbol is in.  */
      if (info->sec == info->tsec)
	{
	  tsec_relocs = info->relocs;
	  tsec_relend = info->relend;
	  tsec_free = NULL;
	}
d1537 33
a1569 8
	  tsec_relocs = (_bfd_elf_link_read_relocs
		         (info->abfd, info->tsec, (PTR) NULL,
			 (Elf_Internal_Rela *) NULL,
			 info->link_info->keep_memory));
	  if (tsec_relocs == NULL)
	    return 0;
	  tsec_relend = tsec_relocs + info->tsec->reloc_count;
	  tsec_free = (info->link_info->keep_memory ? NULL : tsec_relocs);
d1572 3
a1574 3
      /* Recover the symbol's offset within the section.  */
      ofs = (symval - info->tsec->output_section->vma
	     - info->tsec->output_offset);
d1576 9
a1584 3
      /* Look for a GPDISP reloc.  */
      gpdisp = (elf64_alpha_find_reloc_at_ofs
		(tsec_relocs, tsec_relend, ofs, R_ALPHA_GPDISP));
d1586 17
a1602 1
      if (!gpdisp || gpdisp->r_addend != 4)
d1604 7
a1610 3
	  if (tsec_free)
	    free (tsec_free);
	  return 0;
a1611 2
      if (tsec_free)
        free (tsec_free);
d1614 7
a1620 5
  /* We've now determined that we can skip an initial gp load.  Verify
     that the call and the target use the same gp.   */
  if (info->link_info->hash->creator != info->tsec->owner->xvec
      || info->gotobj != alpha_elf_tdata (info->tsec->owner)->gotobj)
    return 0;
d1622 1
a1622 1
  return symval + 8;
d1624 2
d1627 4
a1630 6
static bfd_boolean
elf64_alpha_relax_got_load (info, symval, irel, r_type)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     unsigned long r_type;
d1632 2
a1633 2
  unsigned int insn;
  bfd_signed_vma disp;
d1635 3
a1637 4
  /* Get the instruction.  */
  insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);

  if (insn >> 26 != OP_LDQ)
d1639 1
a1639 7
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
      ((*_bfd_error_handler)
       ("%B: %A+0x%lx: warning: %s relocation against unexpected insn",
	info->abfd, info->sec,
	(unsigned long) irel->r_offset, howto->name));
      return TRUE;
    }
d1641 1
a1641 3
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;
d1643 2
a1644 11
  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
    return TRUE;

  if (r_type == R_ALPHA_LITERAL)
    {
      /* Look for nice constant addresses.  This includes the not-uncommon
	 special case of 0 for undefweak symbols.  */
      if ((info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	  || (!info->link_info->shared
	      && (symval >= (bfd_vma)-0x8000 || symval < 0x8000)))
d1646 2
a1647 15
	  disp = 0;
	  insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
	  insn |= (symval & 0xffff);
	  r_type = R_ALPHA_NONE;
	}
      else
	{
	  disp = symval - info->gp;
	  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
	  r_type = R_ALPHA_GPREL16;
	}
    }
  else
    {
      bfd_vma dtp_base, tp_base;
d1649 3
a1651 4
      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
d1653 4
a1656 1
      insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
d1658 1
a1658 11
      switch (r_type)
	{
	case R_ALPHA_GOTDTPREL:
	  r_type = R_ALPHA_DTPREL16;
	  break;
	case R_ALPHA_GOTTPREL:
	  r_type = R_ALPHA_TPREL16;
	  break;
	default:
	  BFD_ASSERT (0);
	  return FALSE;
d1660 2
d1664 5
a1668 2
  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;
d1670 1
a1670 6
  bfd_put_32 (info->abfd, (bfd_vma) insn, info->contents + irel->r_offset);
  info->changed_contents = TRUE;

  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
d1672 2
a1673 5
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }
d1675 4
a1678 3
  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
  info->changed_relocs = TRUE;
d1680 7
a1686 3
  /* ??? Search forward through this basic block looking for insns
     that use the target register.  Stop after an insn modifying the
     register is seen, or after a branch or call.
d1688 2
a1689 3
     Any such memory load insn may be substituted by a load directly
     off the GP.  This allows the memory load insn to be issued before
     the calculated GP register would otherwise be ready.
d1691 7
a1697 1
     Any such jsr insn can be replaced by a bsr if it is in range.
d1699 2
a1700 2
     This would mean that we'd have to _add_ relocations, the pain of
     which gives one pause.  */
d1702 1
a1702 2
  return TRUE;
}
d1705 2
a1706 5
elf64_alpha_relax_gprelhilo (info, symval, irel, hi)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean hi;
d1708 30
a1737 3
  unsigned int insn;
  bfd_signed_vma disp;
  bfd_byte *pos = info->contents + irel->r_offset;
d1739 8
a1746 1
  /* ??? This assumes that the compiler doesn't render
d1748 6
a1753 5
	array[i]
     as
	ldah	t, array(gp)	!gprelhigh
	s8addl	i, t, t
	ldq	r, array(t)	!gprellow
d1755 6
a1760 1
     which would indeed be the most efficient way to implement this.  */
d1762 3
a1764 1
  return TRUE;
d1766 2
a1767 3
  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;
d1769 11
a1779 3
  if (hi)
    {
      /* Nop out the high instruction.  */
d1781 4
a1784 2
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos);
      info->changed_contents = TRUE;
d1786 4
a1789 7
      irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      irel->r_addend = 0;
      info->changed_relocs = TRUE;
    }
  else
    {
      /* Adjust the low instruction to reference GP directly.  */
d1791 7
a1797 9
      insn = bfd_get_32 (info->abfd, pos);
      insn = (insn & 0xffe00000) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos);
      info->changed_contents = TRUE;

      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				   R_ALPHA_GPREL16);
      info->changed_relocs = TRUE;
    }
d1799 4
a1802 2
  return TRUE;
}
d1804 8
a1811 12
static bfd_boolean
elf64_alpha_relax_tls_get_addr (info, symval, irel, is_gd)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean is_gd;
{
  bfd_byte *pos[5];
  unsigned int insn;
  Elf_Internal_Rela *gpdisp, *hint;
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
  unsigned long new_symndx;
d1813 5
a1817 1
  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);
d1819 7
a1825 4
  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;
d1827 4
a1830 5
  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;
d1832 6
a1837 3
  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return TRUE;
d1839 7
a1845 8
  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return TRUE;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return TRUE;
d1847 6
a1852 6
  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return TRUE;
d1854 5
a1858 6
  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;
  pos1_unusable = FALSE;
d1860 3
a1862 13
  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
    return TRUE;
d1864 3
a1866 6
  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;
d1868 3
a1870 3
    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];
d1872 7
a1878 3
    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;
d1880 9
a1888 7
    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);
d1890 9
a1898 6
    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }
d1900 4
a1903 1
  /* Change
d1905 10
a1914 17
	lda	$16,x($gp)		!tlsgd!1
	ldq	$27,__tls_get_addr($gp)	!literal!1
	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)		!gpdisp!2
	lda	$29,0($29)		!gpdisp!2
     to
	ldq	$16,x($gp)		!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)		!tprel
	unop
     or
	ldah	$16,x($gp)		!tprelhi
	lda	$16,x($16)		!tprello
d1916 12
a1927 14
     as appropriate.  */

  use_gottprel = FALSE;
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
  switch (!dynamic && !info->link_info->shared)
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
	disp = symval - tp_base;
d1929 7
a1935 5
	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);
d1937 1
a1937 13
	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && !pos1_unusable)
	  {
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);
d1939 3
a1941 8
	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */
d1943 6
a1948 2
    default:
      use_gottprel = TRUE;
d1950 4
a1953 3
      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);
d1955 15
a1969 4
      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
d1972 8
a1979 1
  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);
d1981 7
a1987 2
  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);
d1989 2
a1990 1
  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);
d1992 2
a1993 2
  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
d1995 13
a2007 4
  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
d2009 3
a2011 2
  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;
d2013 3
a2015 8
  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }
d2017 2
a2018 5
  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;
d2020 6
a2025 9
      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
d2027 6
a2032 8
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return FALSE;
d2034 4
a2037 2
	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;
d2039 4
a2042 6
	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }
d2044 10
a2053 3
	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
d2056 5
d2064 4
d2069 2
a2070 5
elf64_alpha_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d2072 1
a2072 6
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isymbuf = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;
d2074 1
a2074 7
  /* We are not currently changing any sizes, so only one pass.  */
  *again = FALSE;

  if (link_info->relocatable
      || ((sec->flags & (SEC_CODE | SEC_RELOC | SEC_ALLOC))
	  != (SEC_CODE | SEC_RELOC | SEC_ALLOC))
      || sec->reloc_count == 0)
d2076 4
d2081 1
a2081 2
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
d2083 1
a2083 6
  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    return FALSE;
d2085 2
a2086 7
  memset(&info, 0, sizeof (info));
  info.abfd = abfd;
  info.sec = sec;
  info.link_info = link_info;
  info.symtab_hdr = symtab_hdr;
  info.relocs = internal_relocs;
  info.relend = irelend = internal_relocs + sec->reloc_count;
d2088 2
a2089 14
  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
  info.gotobj = alpha_elf_tdata (abfd)->gotobj;
  if (info.gotobj)
    {
      asection *sgot = alpha_elf_tdata (info.gotobj)->got;
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
    }

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
d2092 18
a2109 2
      if (!bfd_malloc_and_get_section (abfd, sec, &info.contents))
	goto error_return;
d2111 3
d2115 3
a2117 1
  for (irel = internal_relocs; irel < irelend; irel++)
d2119 1
a2119 4
      bfd_vma symval;
      struct alpha_elf_got_entry *gotent;
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);
d2121 2
a2122 2
      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
d2124 13
a2136 7
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	  break;
d2138 2
a2139 5
	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  break;
d2141 1
a2141 3
	default:
	  continue;
	}
d2143 5
a2147 5
      /* Get the value of the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
d2149 3
a2151 11
	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }
d2153 3
a2155 1
	  isym = isymbuf + r_symndx;
d2157 8
a2164 19
	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.link_info);
	    }
	  else
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }
d2166 2
a2167 11
	  info.h = NULL;
	  info.other = isym->st_other;
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
	}
      else
d2169 1
a2169 1
	  unsigned long indx;
d2172 1
a2172 4
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = alpha_elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

d2174 1
a2174 1
		 || h->root.root.type == bfd_link_hash_warning)
d2177 1
a2177 7
	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefined)
	    continue;

	  /* If the symbol isn't defined in the current module,
	     again we can't do anything.  */
	  if (h->root.root.type == bfd_link_hash_undefweak)
d2179 4
a2182 17
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else if (!h->root.def_regular)
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }
d2184 5
a2188 4
	  info.h = h;
	  info.other = h->root.other;
	  info.first_gotent = &h->got_entries;
	}
d2190 4
a2193 29
      /* Search for the got entry to be used by this relocation.  */
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
      info.gotent = gotent;

      symval += info.tsec->output_section->vma + info.tsec->output_offset;
      symval += irel->r_addend;

      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);

	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
a2194 42
	  break;

	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  if (!elf64_alpha_relax_gprelhilo (&info, symval, irel,
					    r_type == R_ALPHA_GPRELHIGH))
	    goto error_return;
	  break;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
	    goto error_return;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
	    goto error_return;
	  break;
	}
    }

  if (!elf64_alpha_size_plt_section (link_info))
    return FALSE;
  if (!elf64_alpha_size_got_sections (link_info))
    return FALSE;
  if (!elf64_alpha_size_rela_got_section (link_info))
    return FALSE;

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d2198 17
a2214 11
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    {
      if (!info.changed_contents && !link_info->keep_memory)
	free (info.contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = info.contents;
	}
    }
d2216 1
a2216 1
  if (elf_section_data (sec)->relocs != internal_relocs)
d2218 4
a2221 5
      if (!info.changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }
d2223 12
a2234 1
  *again = info.changed_contents || info.changed_relocs;
d2236 3
a2238 1
  return TRUE;
d2240 5
a2244 19
 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    free (info.contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* PLT/GOT Stuff */
#define PLT_HEADER_SIZE 32
#define PLT_HEADER_WORD1	(bfd_vma) 0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	(bfd_vma) 0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	(bfd_vma) 0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	(bfd_vma) 0x6b7b0000	/* jmp  $27,($27)   */
d2246 4
a2249 4
#define PLT_ENTRY_SIZE 12
#define PLT_ENTRY_WORD1		0xc3800000	/* br   $28, plt0   */
#define PLT_ENTRY_WORD2		0
#define PLT_ENTRY_WORD3		0
d2251 11
a2261 1
#define MAX_GOT_SIZE		(64*1024)
d2263 13
a2275 7
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so"

/* Handle an Alpha specific section when reading an object file.  This
   is called when bfd_section_from_shdr finds a section with an unknown
   type.
   FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure
   how to.  */
d2277 5
a2281 7
static bfd_boolean
elf64_alpha_section_from_shdr (bfd *abfd,
			       Elf_Internal_Shdr *hdr,
			       const char *name,
			       int shindex)
{
  asection *newsect;
d2283 1
a2283 13
  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_ALPHA_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return FALSE;
      break;
    default:
      return FALSE;
d2285 1
d2287 3
a2289 3
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;
  newsect = hdr->bfd_section;
d2291 3
a2293 7
  if (hdr->sh_type == SHT_ALPHA_DEBUG)
    {
      if (! bfd_set_section_flags (abfd, newsect,
				   (bfd_get_section_flags (abfd, newsect)
				    | SEC_DEBUGGING)))
	return FALSE;
    }
d2295 2
a2296 1
  return TRUE;
d2299 1
a2299 1
/* Convert Alpha specific section flags to bfd internal section flags.  */
d2302 2
a2303 3
elf64_alpha_section_flags (flags, hdr)
     flagword *flags;
     const Elf_Internal_Shdr *hdr;
d2305 2
a2306 2
  if (hdr->sh_flags & SHF_ALPHA_GPREL)
    *flags |= SEC_SMALL_DATA;
d2308 2
a2309 2
  return TRUE;
}
d2311 5
a2315 2
/* Set the correct type for an Alpha ELF section.  We do this by the
   section name, which is a hack, but ought to work.  */
d2317 12
a2328 7
static bfd_boolean
elf64_alpha_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *sec;
{
  register const char *name;
d2330 1
a2330 20
  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_ALPHA_DEBUG;
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if ((abfd->flags & DYNAMIC) != 0 )
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if ((sec->flags & SEC_SMALL_DATA)
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_ALPHA_GPREL;

  return TRUE;
d2333 2
a2334 12
/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */

static bfd_boolean
elf64_alpha_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d2336 1
a2336 6
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && sym->st_size <= elf_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */
d2338 4
a2341 1
      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");
d2343 4
a2346 9
      if (scomm == NULL)
	{
	  scomm = bfd_make_section_with_flags (abfd, ".scommon",
					       (SEC_ALLOC
						| SEC_IS_COMMON
						| SEC_LINKER_CREATED));
	  if (scomm == NULL)
	    return FALSE;
	}
d2348 5
a2352 3
      *secp = scomm;
      *valp = sym->st_size;
    }
d2354 4
a2357 2
  return TRUE;
}
d2359 3
a2361 1
/* Create the .got section.  */
d2363 8
a2370 6
static bfd_boolean
elf64_alpha_create_got_section(abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  asection *s;
d2372 1
a2372 6
  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
a2373 12

  s = bfd_make_section_with_flags (abfd, ".got", (SEC_ALLOC | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  alpha_elf_tdata (abfd)->got = s;

  return TRUE;
d2376 1
a2376 1
/* Create all the dynamic sections.  */
d2379 1
a2379 3
elf64_alpha_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2381 2
a2382 3
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
d2384 1
a2384 1
  /* We need to create .plt, .rela.plt, .got, and .rela.got sections.  */
d2386 9
a2394 9
  s = bfd_make_section_with_flags (abfd, ".plt",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_CODE));
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
d2396 2
a2397 11
  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
     .plt section.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;
d2399 8
a2406 3
  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;
d2408 6
a2413 9
  s = bfd_make_section_with_flags (abfd, ".rela.plt",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
d2415 3
a2417 2
  /* We may or may not have created a .got section for this object, but
     we definitely havn't done the rest of the work.  */
d2419 1
a2419 2
  if (!elf64_alpha_create_got_section (abfd, info))
    return FALSE;
d2421 3
a2423 9
  s = bfd_make_section_with_flags (abfd, ".rela.got",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
d2425 7
a2431 13
  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the
     dynobj's .got section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL,
	 alpha_elf_tdata(abfd)->got, (bfd_vma) 0, (const char *) NULL,
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;
d2433 12
a2444 3
  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;
d2446 4
a2449 1
  elf_hash_table (info)->hgot = h;
a2452 3

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */
d2455 1
a2455 4
elf64_alpha_read_ecoff_info (abfd, section, debug)
     bfd *abfd;
     asection *section;
     struct ecoff_debug_info *debug;
d2457 2
a2458 3
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr = NULL;
d2460 3
a2462 2
  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));
d2464 5
a2468 3
  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;
d2470 8
a2477 21
  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = (type) bfd_malloc (amt);				\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
	goto error_return;						\
d2479 4
d2484 8
a2491 47
  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
#undef READ

  debug->fdr = NULL;

  return TRUE;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return FALSE;
}

/* Alpha ELF local labels start with '$'.  */
d2493 1
a2493 6
static bfd_boolean
elf64_alpha_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return name[0] == '$';
d2496 2
a2497 10
/* Alpha ELF follows MIPS ELF in using a special find_nearest_line
   routine in order to handle the ECOFF debugging information.  We
   still call this mips_elf_find_line because of the slot
   find_line_info in elf_obj_tdata is declared that way.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};
d2500 1
a2500 9
elf64_alpha_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			       functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d2502 3
a2504 1
  asection *msec;
d2506 3
a2508 4
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
d2511 1
a2511 7
  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct mips_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
d2513 2
a2514 6
      /* If we are called during a link, alpha_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;
d2516 7
a2522 8
      fi = elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);
d2524 2
a2525 6
	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
d2527 5
a2531 5
	  if (!elf64_alpha_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
d2533 2
a2534 15
	  /* Swap in the FDR information.  */
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);
d2536 4
a2539 1
	  elf_tdata (abfd)->find_line_info = fi;
d2541 2
a2542 7
	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}
d2544 6
a2549 3
      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
d2551 3
a2553 2
	  msec->flags = origflags;
	  return TRUE;
d2555 6
d2562 15
a2576 2
      msec->flags = origflags;
    }
d2578 5
a2582 1
  /* Fall back on the generic ELF find_nearest_line routine.  */
d2584 5
a2588 3
  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
a2589 2

/* Structure used to pass information to alpha_elf_output_extsym.  */
d2591 1
a2591 8
struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  bfd_boolean failed;
};
d2594 2
a2595 3
elf64_alpha_output_extsym (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
d2597 3
a2599 3
  struct extsym_info *einfo = (struct extsym_info *) data;
  bfd_boolean strip;
  asection *sec, *output_section;
d2604 14
a2617 69
  if (h->root.indx == -2)
    strip = FALSE;
  else if ((h->root.def_dynamic
	    || h->root.ref_dynamic
	    || h->root.root.type == bfd_link_hash_new)
	   && !h->root.def_regular
	   && !h->root.ref_regular)
    strip = TRUE;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
  else
    strip = FALSE;

  if (strip)
    return TRUE;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}
d2619 4
a2622 3
      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }
d2624 5
a2628 9
  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;
d2630 1
a2630 10
      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else if (h->root.needs_plt)
d2632 3
a2634 6
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = bfd_get_section_by_name (einfo->abfd, ".plt");
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
d2636 4
a2639 7
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
	  else
	    h->esym.asym.value = 0;
a2642 8
  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = TRUE;
      return FALSE;
    }

a2644 2

/* Search for and possibly create a got entry.  */
d2646 6
a2651 6
static struct alpha_elf_got_entry *
get_got_entry (abfd, h, r_type, r_symndx, r_addend)
     bfd *abfd;
     struct alpha_elf_link_hash_entry *h;
     unsigned long r_type, r_symndx;
     bfd_vma r_addend;
d2653 1
d2655 1
a2655 1
  struct alpha_elf_got_entry **slot;
d2657 2
a2658 5
  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */
d2660 4
a2663 1
      struct alpha_elf_got_entry **local_got_entries;
d2665 5
a2669 5
      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;
d2671 5
a2675 3
	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);
d2677 4
a2680 4
	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;
d2682 1
a2682 13
	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
d2684 4
a2687 23
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
a2688 2
  else
    gotent->use_count += 1;
d2690 1
a2690 1
  return gotent;
d2693 1
a2693 1
/* Handle dynamic relocations when doing an Alpha ELF link.  */
d2696 1
a2696 5
elf64_alpha_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2698 6
a2703 8
  bfd *dynobj;
  asection *sreloc;
  const char *rel_sec_name;
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  bfd_boolean got_created;
  bfd_size_type amt;
d2705 5
a2709 2
  if (info->relocatable)
    return TRUE;
d2711 4
a2714 8
  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;
d2716 3
a2718 3
  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj == NULL)
    elf_hash_table(info)->dynobj = dynobj = abfd;
d2720 8
a2727 5
  sreloc = NULL;
  rel_sec_name = NULL;
  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
  sym_hashes = alpha_elf_sym_hashes(abfd);
  got_created = FALSE;
d2729 3
a2731 2
  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; ++rel)
d2733 4
a2736 5
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };
d2738 3
a2740 6
      unsigned long r_symndx, r_type;
      struct alpha_elf_link_hash_entry *h;
      unsigned int gotent_flags;
      bfd_boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;
d2742 2
a2743 6
      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d2745 1
a2745 3
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d2747 7
a2753 2
	  h->root.ref_regular = 1;
	}
d2755 2
a2756 10
      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = FALSE;
      if (h && ((info->shared
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !h->root.def_regular
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = TRUE;
d2758 4
a2761 6
      need = 0;
      gotent_flags = 0;
      r_type = ELF64_R_TYPE (rel->r_info);
      addend = rel->r_addend;

      switch (r_type)
d2763 5
a2767 2
	case R_ALPHA_LITERAL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
d2769 6
a2774 7
	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;
d2776 3
a2778 4
	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;
d2780 8
a2787 8
	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL16:
	case R_ALPHA_GPREL32:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_BRSGP:
	  need = NEED_GOT;
	  break;
d2789 2
a2790 5
	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;
d2792 3
a2794 7
	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */
d2796 7
a2802 4
	case R_ALPHA_TLSGD:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;
d2804 1
a2804 6
	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
d2806 3
a2808 7
	case R_ALPHA_TPREL64:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
	}
d2810 1
a2810 3
      if (need & NEED_GOT)
	{
	  if (!got_created)
d2812 2
a2813 2
	      if (!elf64_alpha_create_got_section (abfd, info))
		return FALSE;
d2815 3
a2817 7
	      /* Make sure the object's gotobj is set to itself so
		 that we default to every object with its own .got.
		 We'll merge .gots later once we've collected each
		 object's info.  */
	      alpha_elf_tdata(abfd)->gotobj = abfd;

	      got_created = 1;
d2820 5
d2826 3
a2828 1
      if (need & NEED_GOT_ENTRY)
d2830 3
a2832 4
	  struct alpha_elf_got_entry *gotent;

	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
d2834 2
d2837 9
a2845 7
	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;
d2847 4
a2850 8
		  /* Make a guess as to whether a .plt entry is needed.  */
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.needs_plt = 1;
		  else
		    h->root.needs_plt = 0;
	        }
	    }
d2853 1
a2853 1
      if (need & NEED_DYNREL)
d2855 6
a2860 7
	  if (rel_sec_name == NULL)
	    {
	      rel_sec_name = (bfd_elf_string_from_elf_section
			      (abfd, elf_elfheader(abfd)->e_shstrndx,
			       elf_section_data(sec)->rel_hdr.sh_name));
	      if (rel_sec_name == NULL)
		return FALSE;
d2862 4
a2865 54
	      BFD_ASSERT (strncmp (rel_sec_name, ".rela", 5) == 0
			  && strcmp (bfd_get_section_name (abfd, sec),
				     rel_sec_name+5) == 0);
	    }

	  /* We need to create the section here now whether we eventually
	     use it or not so that it gets mapped to an output section by
	     the linker.  If not used, we'll kill it in
	     size_dynamic_sections.  */
	  if (sreloc == NULL)
	    {
	      sreloc = bfd_get_section_by_name (dynobj, rel_sec_name);
	      if (sreloc == NULL)
		{
		  flagword flags;

		  flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
			   | SEC_LINKER_CREATED | SEC_READONLY);
		  if (sec->flags & SEC_ALLOC)
		    flags |= SEC_ALLOC | SEC_LOAD;
		  sreloc = bfd_make_section_with_flags (dynobj,
							rel_sec_name,
							flags);
		  if (sreloc == NULL
		      || !bfd_set_section_alignment (dynobj, sreloc, 3))
		    return FALSE;
		}
	    }

	  if (h)
	    {
	      /* Since we havn't seen all of the input symbols yet, we
		 don't know whether we'll actually need a dynamic relocation
		 entry for this reloc.  So make a record of it.  Once we
		 find out if this thing needs dynamic relocation we'll
		 expand the relocation sections by the appropriate amount.  */

	      struct alpha_elf_reloc_entry *rent;

	      for (rent = h->reloc_entries; rent; rent = rent->next)
		if (rent->rtype == r_type && rent->srel == sreloc)
		  break;

	      if (!rent)
		{
		  amt = sizeof (struct alpha_elf_reloc_entry);
		  rent = (struct alpha_elf_reloc_entry *) bfd_alloc (abfd, amt);
		  if (!rent)
		    return FALSE;

		  rent->srel = sreloc;
		  rent->rtype = r_type;
		  rent->count = 1;
		  rent->reltext = (sec->flags & SEC_READONLY) != 0;
d2867 4
a2870 14
		  rent->next = h->reloc_entries;
		  h->reloc_entries = rent;
		}
	      else
		rent->count++;
	    }
	  else if (info->shared)
	    {
	      /* If this is a shared library, and the section is to be
		 loaded into memory, we need a RELATIVE reloc.  */
	      sreloc->size += sizeof (Elf64_External_Rela);
	      if (sec->flags & SEC_READONLY)
		info->flags |= DF_TEXTREL;
	    }
d2873 1
d2877 43
d2921 14
a2934 5
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */
d2937 2
a2938 3
elf64_alpha_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d2940 2
a2941 3
  bfd *dynobj;
  asection *s;
  struct alpha_elf_link_hash_entry *ah;
d2943 2
a2944 2
  dynobj = elf_hash_table(info)->dynobj;
  ah = (struct alpha_elf_link_hash_entry *)h;
d2946 1
a2946 14
  /* Now that we've seen all of the input symbols, finalize our decision
     about whether this symbol should get a .plt entry.  */

  if (alpha_elf_dynamic_symbol_p (h, info)
      && ((h->type == STT_FUNC
	   && !(ah->flags & ALPHA_ELF_LINK_HASH_LU_ADDR))
	  || (h->type == STT_NOTYPE
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
      /* Don't prevent otherwise valid programs from linking by attempting
	 to create a new .got entry somewhere.  A Correct Solution would be
	 to add a new .got section to a new object file and let it be merged
	 somewhere later.  But for now don't bother.  */
      && ah->got_entries)
d2948 7
a2954 1
      h->needs_plt = 1;
d2956 3
a2958 3
      s = bfd_get_section_by_name(dynobj, ".plt");
      if (!s && !elf64_alpha_create_dynamic_sections (dynobj, info))
	return FALSE;
d2960 3
a2962 3
      /* The first bit of the .plt is reserved.  */
      if (s->size == 0)
	s->size = PLT_HEADER_SIZE;
d2964 14
a2977 9
      h->plt.offset = s->size;
      s->size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are not
	 generating a shared library, then set the symbol to the location
	 in the .plt.  This is required to make function pointers compare
	 equal between the normal executable and the shared library.  */
      if (! info->shared
	  && h->root.type != bfd_link_hash_defweak)
d2979 3
a2981 5
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
	  h->root.u.def.section = s;
	  h->root.u.def.value = h->plt.offset;
a2982 7

      /* We also need a JMP_SLOT entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf64_External_Rela);

      return TRUE;
a2984 6
    h->needs_plt = 0;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
d2986 1
a2986 6
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }
d2988 4
a2991 4
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  The Alpha, since it uses .got entries for all
     symbols even in regular objects, does not need the hackery of a
     .dynbss section and COPY dynamic relocations.  */
d2993 1
a2993 2
  return TRUE;
}
d2995 13
a3007 3
/* Symbol versioning can create new symbols, and make our old symbols
   indirect to the new ones.  Consolidate the got and reloc information
   in these situations.  */
d3009 1
a3009 8
static bfd_boolean
elf64_alpha_merge_ind_symbols (hi, dummy)
     struct alpha_elf_link_hash_entry *hi;
     PTR dummy ATTRIBUTE_UNUSED;
{
  struct alpha_elf_link_hash_entry *hs;

  if (hi->root.root.type != bfd_link_hash_indirect)
a3010 4
  hs = hi;
  do {
    hs = (struct alpha_elf_link_hash_entry *)hs->root.root.u.i.link;
  } while (hs->root.root.type == bfd_link_hash_indirect);
d3012 2
a3013 1
  /* Merge the flags.  Whee.  */
d3015 9
a3023 1
  hs->flags |= hi->flags;
d3025 3
a3027 2
  /* Merge the .got entries.  Cannibalize the old symbol's list in
     doing so, since we don't need it anymore.  */
d3029 3
a3031 24
  if (hs->got_entries == NULL)
    hs->got_entries = hi->got_entries;
  else
    {
      struct alpha_elf_got_entry *gi, *gs, *gin, *gsh;

      gsh = hs->got_entries;
      for (gi = hi->got_entries; gi ; gi = gin)
	{
	  gin = gi->next;
	  for (gs = gsh; gs ; gs = gs->next)
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
	  gi->next = hs->got_entries;
	  hs->got_entries = gi;
	got_found:;
	}
    }
  hi->got_entries = NULL;
d3033 3
a3035 1
  /* And similar for the reloc entries.  */
d3037 1
a3037 5
  if (hs->reloc_entries == NULL)
    hs->reloc_entries = hi->reloc_entries;
  else
    {
      struct alpha_elf_reloc_entry *ri, *rs, *rin, *rsh;
d3039 2
a3040 16
      rsh = hs->reloc_entries;
      for (ri = hi->reloc_entries; ri ; ri = rin)
	{
	  rin = ri->next;
	  for (rs = rsh; rs ; rs = rs->next)
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
	      {
		rs->count += ri->count;
		goto found_reloc;
	      }
	  ri->next = hs->reloc_entries;
	  hs->reloc_entries = ri;
	found_reloc:;
	}
    }
  hi->reloc_entries = NULL;
d3045 2
a3046 5
/* Is it possible to merge two object file's .got tables?  */

static bfd_boolean
elf64_alpha_can_merge_gots (a, b)
     bfd *a, *b;
d3048 3
a3050 2
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;
d3052 4
a3055 3
  /* Trivial quick fallout test.  */
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
    return TRUE;
d3057 4
a3060 3
  /* By their nature, local .got entries cannot be merged.  */
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
    return FALSE;
d3062 3
a3064 4
  /* Failing the common trivial comparison, we must effectively
     perform the merge.  Not actually performing the merge means that
     we don't have to store undo information in case we fail.  */
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
d3066 2
a3067 3
      struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes (bsub);
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (bsub)->symtab_hdr;
      int i, n;
d3069 8
a3076 2
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
d3078 9
a3086 2
	  struct alpha_elf_got_entry *ae, *be;
	  struct alpha_elf_link_hash_entry *h;
d3088 3
a3090 4
	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d3092 3
a3094 6
	  for (be = h->got_entries; be ; be = be->next)
	    {
	      if (be->use_count == 0)
	        continue;
	      if (be->gotobj != b)
	        continue;
d3096 5
a3100 11
	      for (ae = h->got_entries; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  goto global_found;

	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
	        return FALSE;
	    global_found:;
	    }
d3102 2
d3106 7
a3112 1
  return TRUE;
d3115 26
a3140 1
/* Actually merge two .got tables.  */
d3142 8
a3149 6
static void
elf64_alpha_merge_gots (a, b)
     bfd *a, *b;
{
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;
d3151 2
a3152 6
  /* Remember local expansion.  */
  {
    int e = alpha_elf_tdata (b)->local_got_size;
    total += e;
    alpha_elf_tdata (a)->local_got_size += e;
  }
d3154 1
a3154 1
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
d3156 5
a3160 4
      struct alpha_elf_got_entry **local_got_entries;
      struct alpha_elf_link_hash_entry **hashes;
      Elf_Internal_Shdr *symtab_hdr;
      int i, n;
d3162 8
a3169 12
      /* Let the local .got entries know they are part of a new subsegment.  */
      local_got_entries = alpha_elf_tdata (bsub)->local_got_entries;
      if (local_got_entries)
        {
	  n = elf_tdata (bsub)->symtab_hdr.sh_info;
	  for (i = 0; i < n; ++i)
	    {
	      struct alpha_elf_got_entry *ent;
	      for (ent = local_got_entries[i]; ent; ent = ent->next)
	        ent->gotobj = a;
	    }
        }
d3171 2
a3172 3
      /* Merge the global .got entries.  */
      hashes = alpha_elf_sym_hashes (bsub);
      symtab_hdr = &elf_tdata (bsub)->symtab_hdr;
d3174 4
a3177 5
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
        {
	  struct alpha_elf_got_entry *ae, *be, **pbe, **start;
	  struct alpha_elf_link_hash_entry *h;
d3179 4
a3182 4
	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d3184 1
a3184 2
	  pbe = start = &h->got_entries;
	  while ((be = *pbe) != NULL)
d3186 7
a3192 22
	      if (be->use_count == 0)
	        {
		  *pbe = be->next;
		  memset (be, 0xa5, sizeof (*be));
		  goto kill;
	        }
	      if (be->gotobj != b)
	        goto next;

	      for (ae = *start; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  {
		    ae->flags |= be->flags;
		    ae->use_count += be->use_count;
		    *pbe = be->next;
		    memset (be, 0xa5, sizeof (*be));
		    goto kill;
		  }
	      be->gotobj = a;
	      total += alpha_got_entry_size (be->reloc_type);
d3194 3
a3196 3
	    next:;
	      pbe = &be->next;
	    kill:;
a3197 1
        }
d3199 4
a3202 3
      alpha_elf_tdata (bsub)->gotobj = a;
    }
  alpha_elf_tdata (a)->total_got_size = total;
d3204 7
a3210 3
  /* Merge the two in_got chains.  */
  {
    bfd *next;
d3212 8
a3219 3
    bsub = a;
    while ((next = alpha_elf_tdata (bsub)->in_got_link_next) != NULL)
      bsub = next;
d3221 2
a3222 3
    alpha_elf_tdata (bsub)->in_got_link_next = b;
  }
}
d3224 2
a3225 1
/* Calculate the offsets for the got entries.  */
d3227 2
a3228 7
static bfd_boolean
elf64_alpha_calc_got_offsets_for_symbol (h, arg)
     struct alpha_elf_link_hash_entry *h;
     PTR arg ATTRIBUTE_UNUSED;
{
  bfd_boolean result = TRUE;
  struct alpha_elf_got_entry *gotent;
d3230 3
a3232 2
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;
d3234 4
a3237 5
  for (gotent = h->got_entries; gotent; gotent = gotent->next)
    if (gotent->use_count > 0)
      {
	struct alpha_elf_obj_tdata *td;
	bfd_size_type *plge;
d3239 3
a3241 2
	td = alpha_elf_tdata (gotent->gotobj);
	if (td == NULL)
d3243 11
a3253 9
	    _bfd_error_handler (_("Symbol %s has no GOT subsection for offset 0x%x"),
				h->root.root.root.string, gotent->got_offset);
	    result = FALSE;
	    continue;
	  }
	plge = &td->got->size;
	gotent->got_offset = *plge;
	*plge += alpha_got_entry_size (gotent->reloc_type);
      }
d3255 3
a3257 2
  return result;
}
d3259 6
a3264 5
static void
elf64_alpha_calc_got_offsets (info)
     struct bfd_link_info *info;
{
  bfd *i, *got_list = alpha_elf_hash_table(info)->got_list;
d3266 3
a3268 4
  /* First, zero out the .got sizes, as we may be recalculating the
     .got after optimizing it.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    alpha_elf_tdata(i)->got->size = 0;
d3270 5
a3274 4
  /* Next, fill in the offsets for all the global entries.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_calc_got_offsets_for_symbol,
				NULL);
d3276 3
a3278 5
  /* Finally, fill in the offsets for the local entries.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->size;
      bfd *j;
d3280 4
a3283 4
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;
d3285 2
a3286 3
	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;
d3288 6
a3293 8
	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k]; gotent; gotent = gotent->next)
	      if (gotent->use_count > 0)
	        {
		  gotent->got_offset = got_offset;
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
	        }
	}
d3295 5
a3299 3
      alpha_elf_tdata(i)->got->size = got_offset;
    }
}
d3301 14
a3314 1
/* Constructs the gots.  */
d3316 9
a3324 6
static bfd_boolean
elf64_alpha_size_got_sections (info)
     struct bfd_link_info *info;
{
  bfd *i, *got_list, *cur_got_obj = NULL;
  int something_changed = 0;
d3326 10
a3335 1
  got_list = alpha_elf_hash_table (info)->got_list;
d3337 3
a3339 3
  /* On the first time through, pretend we have an existing got list
     consisting of all of the input files.  */
  if (got_list == NULL)
d3341 1
a3341 1
      for (i = info->input_bfds; i ; i = i->link_next)
d3343 4
a3346 21
	  bfd *this_got = alpha_elf_tdata (i)->gotobj;
	  if (this_got == NULL)
	    continue;

	  /* We are assuming no merging has yet occurred.  */
	  BFD_ASSERT (this_got == i);

          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
	    {
	      /* Yikes! A single object file has too many entries.  */
	      (*_bfd_error_handler)
	        (_("%B: .got subsegment exceeds 64K (size %d)"),
	         i, alpha_elf_tdata (this_got)->total_got_size);
	      return FALSE;
	    }

	  if (got_list == NULL)
	    got_list = this_got;
	  else
	    alpha_elf_tdata(cur_got_obj)->got_link_next = this_got;
	  cur_got_obj = this_got;
d3349 5
a3353 15
      /* Strange degenerate case of no got references.  */
      if (got_list == NULL)
	return TRUE;

      alpha_elf_hash_table (info)->got_list = got_list;

      /* Force got offsets to be recalculated.  */
      something_changed = 1;
    }

  cur_got_obj = got_list;
  i = alpha_elf_tdata(cur_got_obj)->got_link_next;
  while (i != NULL)
    {
      if (elf64_alpha_can_merge_gots (cur_got_obj, i))
d3355 2
a3356 1
	  elf64_alpha_merge_gots (cur_got_obj, i);
d3358 3
a3360 10
	  alpha_elf_tdata(i)->got->size = 0;
	  i = alpha_elf_tdata(i)->got_link_next;
	  alpha_elf_tdata(cur_got_obj)->got_link_next = i;
	  
	  something_changed = 1;
	}
      else
	{
	  cur_got_obj = i;
	  i = alpha_elf_tdata(i)->got_link_next;
d3362 2
d3365 2
a3366 7

  /* Once the gots have been merged, fill in the got offsets for
     everything therein.  */
  if (1 || something_changed)
    elf64_alpha_calc_got_offsets (info);

  return TRUE;
a3368 3
/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */

d3370 2
a3371 2
elf64_alpha_size_plt_section (info)
     struct bfd_link_info *info;
d3373 5
a3377 3
  asection *splt, *spltrel;
  unsigned long entries;
  bfd *dynobj;
d3379 1
a3379 4
  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_section_by_name(dynobj, ".plt");
  if (splt == NULL)
    return TRUE;
d3381 4
a3384 1
  splt->size = 0;
d3386 5
a3390 2
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_plt_section_1, splt);
d3392 3
a3394 7
  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
  if (splt->size)
    entries = (splt->size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
  else
    entries = 0;
  spltrel->size = entries * sizeof (Elf64_External_Rela);
d3396 8
a3403 2
  return TRUE;
}
d3405 5
a3409 10
static bfd_boolean
elf64_alpha_size_plt_section_1 (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;

  /* If we didn't need an entry before, we still don't.  */
  if (!h->root.needs_plt)
d3412 6
a3417 5
  /* There must still be a LITERAL got entry for the function.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      break;
d3419 4
a3422 3
  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
d3424 3
a3426 4
      if (splt->size == 0)
	splt->size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->size;
      splt->size += PLT_ENTRY_SIZE;
d3428 15
a3442 4
  else
    {
      h->root.needs_plt = 0;
      h->root.plt.offset = -1;
d3444 3
a3446 8
      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
    }
d3448 7
a3454 2
  return TRUE;
}
d3456 6
a3461 6
static bfd_boolean
elf64_alpha_always_size_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *i;
d3463 1
a3463 2
  if (info->relocatable)
    return TRUE;
d3465 17
a3481 4
  /* First, take care of the indirect symbols created by versioning.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_merge_ind_symbols,
				NULL);
d3483 1
a3483 2
  if (!elf64_alpha_size_got_sections (info))
    return FALSE;
d3485 3
a3487 3
  /* Allocate space for all of the .got subsections.  */
  i = alpha_elf_hash_table (info)->got_list;
  for ( ; i ; i = alpha_elf_tdata(i)->got_link_next)
d3489 4
a3492 8
      asection *s = alpha_elf_tdata(i)->got;
      if (s->size > 0)
	{
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->size);
	  if (s->contents == NULL)
	    return FALSE;
	}
    }
d3494 3
a3496 2
  return TRUE;
}
d3498 5
a3502 1
/* The number of dynamic relocations required by a static relocation.  */
d3504 13
a3516 16
static int
alpha_dynamic_entries_for_reloc (r_type, dynamic, shared)
     int r_type, dynamic, shared;
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
    case R_ALPHA_GOTTPREL:
      return dynamic || shared;
    case R_ALPHA_GOTDTPREL:
      return dynamic;
d3518 8
a3525 5
    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
    case R_ALPHA_TPREL64:
      return dynamic || shared;
a3526 2
    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
d3528 10
a3537 1
      return 0;
a3538 1
}
d3540 4
a3543 1
/* Work out the sizes of the dynamic relocation entries.  */
d3545 1
a3545 8
static bfd_boolean
elf64_alpha_calc_dynrel_sizes (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  bfd_boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;
d3547 2
a3548 2
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;
d3550 4
a3553 14
  /* If the symbol was defined as a common symbol in a regular object
     file, and there was no definition in any dynamic object, then the
     linker will have allocated space for the symbol in a common
     section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been
     set.  This is done for dynamic symbols in
     elf_adjust_dynamic_symbol but this is not done for non-dynamic
     symbols, somehow.  */
  if (!h->root.def_regular
      && h->root.ref_regular
      && !h->root.def_dynamic
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak)
      && !(h->root.root.u.def.section->owner->flags & DYNAMIC))
    h->root.def_regular = 1;
d3555 2
a3556 4
  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d3558 8
a3565 5
  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;
d3567 3
a3569 1
  for (relent = h->reloc_entries; relent; relent = relent->next)
d3571 11
a3581 3
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared);
      if (entries)
d3583 21
a3603 4
	  relent->srel->size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
a3609 2
/* Set the sizes of the dynamic relocation sections.  */

d3611 2
a3612 2
elf64_alpha_size_rela_got_section (info)
     struct bfd_link_info *info;
d3614 9
a3622 3
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;
d3624 5
a3628 2
  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */
d3630 2
a3631 5
  entries = 0;
  for (i = alpha_elf_hash_table(info)->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;
d3633 6
a3638 4
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;
d3640 7
a3646 3
	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;
d3648 9
a3656 7
	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared));
	}
d3659 4
a3662 3
  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!srel)
d3664 2
a3665 2
      BFD_ASSERT (entries == 0);
      return TRUE;
a3666 1
  srel->size = sizeof (Elf64_External_Rela) * entries;
d3668 6
a3673 3
  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_rela_got_1, info);
d3675 10
a3684 2
  return TRUE;
}
d3686 5
a3690 2
/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */
d3692 3
a3694 8
static bfd_boolean
elf64_alpha_size_rela_got_1 (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  bfd_boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;
d3696 5
a3700 2
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;
d3702 11
a3712 29
  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);

  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf64_External_Rela) * entries;
    }
d3714 1
a3714 2
  return TRUE;
}
d3716 19
a3734 1
/* Set the sizes of the dynamic sections.  */
d3736 11
a3746 16
static bfd_boolean
elf64_alpha_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  bfd_boolean relplt;

  dynobj = elf_hash_table(info)->dynobj;
  BFD_ASSERT(dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
d3748 2
a3749 5
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
d3751 3
a3753 6
      /* Now that we've seen all of the input files, we can decide which
	 symbols need dynamic relocation entries and which don't.  We've
	 collected information in check_relocs that we can now apply to
	 size the dynamic relocation sections.  */
      alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				    elf64_alpha_calc_dynrel_sizes, info);
d3755 3
a3757 3
      elf64_alpha_size_rela_got_section (info);
    }
  /* else we're not dynamic and by definition we don't need such things.  */
d3759 3
a3761 8
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relplt = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip;
d3763 21
a3783 2
      if (!(s->flags & SEC_LINKER_CREATED))
	continue;
d3785 4
a3788 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d3790 7
a3796 7
      /* If we don't need this section, strip it from the output file.
	 This is to handle .rela.bss and .rela.plt.  We must create it
	 in create_dynamic_sections, because it must be created before
	 the linker maps input sections to output sections.  The
	 linker does that before adjust_dynamic_symbol is called, and
	 it is that function which decides whether anything needs to
	 go into these sections.  */
d3798 2
a3799 1
      strip = FALSE;
d3801 1
a3801 1
      if (strncmp (name, ".rela", 5) == 0)
d3803 2
a3804 1
	  strip = (s->size == 0);
d3806 10
a3815 1
	  if (!strip)
d3817 11
a3827 2
	      if (strcmp(name, ".rela.plt") == 0)
		relplt = TRUE;
d3829 7
a3835 9
	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strcmp (name, ".plt") != 0)
	{
	  /* It's not one of our dynamic sections, so don't allocate space.  */
	  continue;
d3837 8
d3846 5
a3850 2
      if (strip)
	s->flags |= SEC_EXCLUDE;
d3853 2
a3854 4
	  /* Allocate memory for the section contents.  */
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL && s->size != 0)
	    return FALSE;
d3858 2
a3859 1
  if (elf_hash_table (info)->dynamic_sections_created)
d3861 3
a3863 9
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf64_alpha_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
d3865 2
a3866 2
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
d3868 1
d3870 7
a3876 8
      if (relplt)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}
d3878 1
a3878 4
      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	return FALSE;
d3880 1
a3880 7
      if (info->flags & DF_TEXTREL)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry
d3882 11
a3892 1
  return TRUE;
d3894 1
a3894 1

d3899 3
a3901 6
elf64_alpha_emit_dynrel (abfd, info, sec, srel, offset, dynindx, rtype, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec, *srel;
     bfd_vma offset, addend;
     long dynindx, rtype;
d3930 7
a3936 10
elf64_alpha_relocate_section_r (output_bfd, info, input_bfd, input_section,
			        contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d3988 5
a3992 10
elf64_alpha_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d4624 3
a4626 5
elf64_alpha_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d4784 2
a4785 3
elf64_alpha_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d4872 1
a4872 3
elf64_alpha_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d5139 1
a5139 2
elf64_alpha_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
a5353 3
static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

d5355 2
a5356 3
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
@


1.135
log
@        * elf64-alpha.c (elf64_alpha_relax_section): Ignore non-allocated
        sections.
        (elf64_alpha_check_relocs): Likewise.
        (elf64_alpha_relocate_section): Don't emit dynamic relocations to
        non-allocated sections.
@
text
@d3526 2
a3527 2
	  start = &h->got_entries;
	  for (pbe = start, be = *start; be ; pbe = &be->next, be = be->next)
d3532 2
a3533 1
		  continue;
d3536 1
a3536 1
	        continue;
d3546 2
a3547 1
		    goto global_found;
d3552 3
a3554 1
	    global_found:;
d3710 2
d3714 1
@


1.134
log
@        * elf64-alpha.c (elf64_alpha_relax_with_lituse): Relax jsr to
        undefweak to use zero register.  Call elf64_alpha_relax_got_load
        if not all uses removed.
        (elf64_alpha_relax_got_load): Relax undefweak to lda zero.
        (elf64_alpha_relax_section): Handle undefweak symbols.
        (elf64_alpha_calc_dynrel_sizes): Don't add relocs for undefweak.
        (elf64_alpha_size_rela_got_1): Likewise.
        (elf64_alpha_relocate_section): Likewise.
@
text
@d1996 2
a1997 1
      || (sec->flags & (SEC_CODE | SEC_RELOC)) != (SEC_CODE | SEC_RELOC)
d2992 9
d3086 1
a3086 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
d3224 1
a3224 2
		  rent->reltext = ((sec->flags & (SEC_READONLY | SEC_ALLOC))
				   == (SEC_READONLY | SEC_ALLOC));
d3237 1
a3237 2
	      if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		  == (SEC_READONLY | SEC_ALLOC))
a4275 1
  const char *section_name;
d4295 11
a4305 5
  section_name = (bfd_elf_string_from_elf_section
		  (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		   elf_section_data(input_section)->rel_hdr.sh_name));
  BFD_ASSERT(section_name != NULL);
  srel = bfd_get_section_by_name (dynobj, section_name);
d4689 4
a4692 3
	    elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				     srel, rel->r_offset, dynindx,
				     dyntype, dynaddend);
@


1.133
log
@        * elf64-alpha.c (elf64_alpha_relax_section): Only operate
        on SEC_CODE sections.
@
text
@d1303 1
a1303 3
	  insn_disp = insn & 0x0000ffff;
	  if (insn_disp & 0x8000)
	    insn_disp |= ~0xffff;  /* Negative: sign-extend.  */
d1372 13
d1488 2
d1491 2
a1492 2

  return TRUE;
d1599 19
a1617 1
    disp = symval - info->gp;
d1626 15
a1645 6
  /* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading
     a constant, so force the base register to be $31.  */
  if (r_type == R_ALPHA_LITERAL)
    insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  else
    insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
a1659 16
  switch (r_type)
    {
    case R_ALPHA_LITERAL:
      r_type = R_ALPHA_GPREL16;
      break;
    case R_ALPHA_GOTDTPREL:
      r_type = R_ALPHA_DTPREL16;
      break;
    case R_ALPHA_GOTTPREL:
      r_type = R_ALPHA_TPREL16;
      break;
    default:
      BFD_ASSERT (0);
      return FALSE;
    }

d2130 1
a2130 2
	  if (h->root.root.type == bfd_link_hash_undefweak
	      || h->root.root.type == bfd_link_hash_undefined)
d2133 8
a2140 3
	  /* If the symbol isn't defined in the current module, again
	     we can't do anything.  */
	  if (!h->root.def_regular)
d3891 1
d3893 5
a3897 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d3986 1
d3988 5
a3992 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d4486 1
a4486 1
	      if (info->shared && !dynamic_symbol_p)
d4658 2
a4659 1
		     && (input_section->flags & SEC_ALLOC))
d4692 8
@


1.132
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d1972 1
a1972 1
      || (sec->flags & SEC_RELOC) == 0
@


1.131
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d5373 2
a5374 1
static struct bfd_elf_special_section const elf64_alpha_special_sections[]=
d5381 32
@


1.130
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2374 5
a2378 5
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
d2406 4
a2409 1
  s = bfd_make_section (abfd, ".got");
a2410 4
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED))
d2432 6
a2437 1
  s = bfd_make_section (abfd, ".plt");
a2438 5
      || ! bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					    | SEC_HAS_CONTENTS
					    | SEC_IN_MEMORY
					    | SEC_LINKER_CREATED
					    | SEC_CODE))
d2458 6
a2463 1
  s = bfd_make_section (abfd, ".rela.plt");
a2464 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
d2474 6
a2479 1
  s = bfd_make_section(abfd, ".rela.got");
a2480 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
a3148 1
		  sreloc = bfd_make_section (dynobj, rel_sec_name);
d3153 3
a3156 1
		      || !bfd_set_section_flags (dynobj, sreloc, flags)
@


1.129
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.128
log
@Update the FSF address in the copyright/GPL notice
@
text
@d4061 1
a4061 1
	_bfd_strip_section_from_output (info, s);
d5187 1
a5187 1
	  for (p = o->link_order_head;
d5308 1
a5308 1
	  o->link_order_head = (struct bfd_link_order *) NULL;
@


1.127
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.126
log
@include/
	* bfdlink.h (bfd_link_repair_undef_list): Declare.
bfd/
	* elf64-ppc.c (ppc64_elf_check_directives): Move undefs list fixup..
	* linker.c (bfd_link_repair_undef_list): ..to new function, but don't
	remove anything but new and undefweak.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Override any
	existing _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): Formatting.
	(bfd_elf_record_link_assignment): Call bfd_link_repair_undef_list.
	(_bfd_elf_merge_symbol): Don't handle as-needed syms here.
	(struct elf_smash_data): New.
	(elf_smash_syms): New function.
	(elf_link_add_object_symbols): Call elf_smash_syms.  Don't add
	unneeded dynamic objects to loaded list.
	(elf_link_output_extsym): Don't handle as-needed here.  Strip
	bfd_link_hash_new symbols.
	* elf32-cris.c (elf_cris_discard_excess_program_dynamics): Don't
	delref when dynindx is already -1.
	* elf64-alpha.c (elf64_alpha_output_extsym): Strip bfd_link_hash_new
	symbols.
	* elfxx-mips.c (mips_elf_output_extsym): Likewise.
ld/
	* ld.texinfo: Clarify --as-needed operation.
@
text
@a74 2
static bfd_boolean elf64_alpha_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d2261 2
a2262 1
   is called when elfcode.h finds a section with an unknown type.
d2267 4
a2270 4
elf64_alpha_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d2289 1
a2289 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.126.2.1
log
@        * elf64-alpha.c (elf64_alpha_relax_with_lituse): Relax jsr to
        undefweak to use zero register.  Call elf64_alpha_relax_got_load
        if not all uses removed.
        (elf64_alpha_relax_got_load): Relax undefweak to lda zero.
        (elf64_alpha_relax_section): Handle undefweak symbols.
        (elf64_alpha_calc_dynrel_sizes): Don't add relocs for undefweak.
        (elf64_alpha_size_rela_got_1): Likewise.
        (elf64_alpha_relocate_section): Likewise.

        * elf64-alpha.c (elf64_alpha_relax_section): Only operate
        on SEC_CODE sections.
@
text
@d1305 3
a1307 1
	  insn_disp = ((insn & 0xffff) ^ 0x8000) - 0x8000;
a1375 13
	    /* For undefined weak symbols, we're mostly interested in getting
	       rid of the got entry whenever possible, so optimize this to a
	       use of the zero register.  */
	    if (info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	      {
		insn |= 31 << 16;
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);

		info->changed_contents = TRUE;
		break;
	      }

d1479 1
d1481 1
a1481 4
      return TRUE;
    }
  else
    return elf64_alpha_relax_got_load (info, symval, irel, R_ALPHA_LITERAL);
d1588 1
a1588 19
    {
      /* Look for nice constant addresses.  This includes the not-uncommon
	 special case of 0 for undefweak symbols.  */
      if ((info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	  || (!info->link_info->shared
	      && (symval >= (bfd_vma)-0x8000 || symval < 0x8000)))
	{
	  disp = 0;
	  insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
	  insn |= (symval & 0xffff);
	  r_type = R_ALPHA_NONE;
	}
      else
	{
	  disp = symval - info->gp;
	  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
	  r_type = R_ALPHA_GPREL16;
	}
    }
a1596 15

      insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);

      switch (r_type)
	{
	case R_ALPHA_GOTDTPREL:
	  r_type = R_ALPHA_DTPREL16;
	  break;
	case R_ALPHA_GOTTPREL:
	  r_type = R_ALPHA_TPREL16;
	  break;
	default:
	  BFD_ASSERT (0);
	  return FALSE;
	}
d1602 6
d1622 16
d1974 1
a1974 1
      || (sec->flags & (SEC_CODE | SEC_RELOC)) != (SEC_CODE | SEC_RELOC)
d2108 2
a2109 1
	  if (h->root.root.type == bfd_link_hash_undefined)
d2112 3
a2114 8
	  /* If the symbol isn't defined in the current module,
	     again we can't do anything.  */
	  if (h->root.root.type == bfd_link_hash_undefweak)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else if (!h->root.def_regular)
d3864 1
a3866 6
  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

d3954 1
a3956 6
  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

d4449 1
a4449 1
	      if (info->shared && !dynamic_symbol_p && !undef_weak_ref)
d4621 1
a4621 2
		     && (input_section->flags & SEC_ALLOC)
		     && !undef_weak_ref)
a4653 8
	  else if ((info->shared || info->pie) && undef_weak_ref)
            {
              (*_bfd_error_handler)
                (_("%B: pc-relative relocation against undefined weak symbol %s"),
                 input_bfd, h->root.root.root.string);
              ret_val = FALSE;
            }

@


1.126.2.2
log
@        * elf64-alpha.c (elf64_alpha_relax_section): Ignore non-allocated
        sections.
        (elf64_alpha_check_relocs): Likewise.
        (elf64_alpha_relocate_section): Don't emit dynamic relocations to
        non-allocated sections.
@
text
@d1998 1
a1998 2
      || ((sec->flags & (SEC_CODE | SEC_RELOC | SEC_ALLOC))
	  != (SEC_CODE | SEC_RELOC | SEC_ALLOC))
a2992 9
  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d3078 1
a3078 1
	  if (info->shared || maybe_dynamic)
d3215 2
a3216 1
		  rent->reltext = (sec->flags & SEC_READONLY) != 0;
d3229 2
a3230 1
	      if (sec->flags & SEC_READONLY)
d4269 1
d4289 5
a4293 11
  if (input_section->flags & SEC_ALLOC)
    {
      const char *section_name;
      section_name = (bfd_elf_string_from_elf_section
		      (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		       elf_section_data(input_section)->rel_hdr.sh_name));
      BFD_ASSERT(section_name != NULL);
      srel = bfd_get_section_by_name (dynobj, section_name);
    }
  else
    srel = NULL;
d4677 3
a4679 4
	    if (input_section->flags & SEC_ALLOC)
	      elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				       srel, rel->r_offset, dynindx,
				       dyntype, dynaddend);
@


1.125
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d2744 3
a2746 1
  else if ((h->root.def_dynamic || h->root.ref_dynamic)
@


1.124
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d4805 1
a4805 1
	      name = h->root.root.root.string;
d4816 3
a4818 2
		   (info, name, howto->name, (bfd_vma) 0,
		    input_bfd, input_section, rel->r_offset)))
@


1.123
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d3282 1
a3282 1
  if (h->weakdef != NULL)
d3284 4
a3287 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.122
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d2114 1
a2114 1
	  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2453 1
a2453 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2497 1
a2497 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2744 3
a2746 4
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d2833 1
a2833 1
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d3000 1
a3000 1
	  h->root.elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
d3010 1
a3010 1
		|| ! (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d3116 1
a3116 1
		    h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d3118 1
a3118 1
		    h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3242 1
a3242 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d3277 1
a3277 1
    h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3729 1
a3729 1
  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT))
d3749 1
a3749 1
      h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3851 3
a3853 5
  if (((h->root.elf_link_hash_flags
       & (ELF_LINK_HASH_DEF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_DEF_DYNAMIC))
       == ELF_LINK_HASH_REF_REGULAR)
d3857 1
a3857 1
    h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d4897 1
a4897 1
      if (!(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
@


1.121
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d1260 2
a1261 2
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
	bfd_archive_filename (info->abfd), info->sec->name,
d1573 2
a1574 2
       ("%s: %s+0x%lx: warning: %s relocation against unexpected insn",
	bfd_archive_filename (info->abfd), info->sec->name,
d3641 2
a3642 3
	        (_("%s: .got subsegment exceeds 64K (size %d)"),
	         bfd_archive_filename (i),
	         alpha_elf_tdata (this_got)->total_got_size);
d4182 2
a4183 2
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d4308 2
a4309 2
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d4480 2
a4481 2
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
d4492 2
a4493 2
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
d4518 2
a4519 2
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
d4546 2
a4547 2
		  (_("%s: change in gp: BRSGP %s"),
		   bfd_archive_filename (input_bfd), h->root.root.root.string);
d4576 2
a4577 2
		  (_("%s: !samegp reloc against symbol without .prologue: %s"),
		   bfd_archive_filename (input_bfd), name);
d4627 2
a4628 2
		      (_("%s: unhandled dynamic relocation against %s"),
		       bfd_archive_filename (input_bfd),
d4651 2
a4652 2
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
d4710 2
a4711 2
                (_("%s: dtp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
d4726 2
a4727 2
		(_("%s: TLS local exec code cannot be linked into shared objects"),
		bfd_archive_filename (input_bfd));
d4733 2
a4734 2
                (_("%s: tp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
@


1.120
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1039 1
a1039 1
  bfd_size_type sz;
d1049 3
a1051 3
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz
      || reloc_entry->address + reloc_entry->addend > sz)
@


1.119
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d1039 1
d1049 3
a1051 2
  if (reloc_entry->address > input_section->_cooked_size ||
      reloc_entry->address + reloc_entry->addend > input_section->_cooked_size)
a1977 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d2012 1
a2012 6
      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (info.contents == NULL)
	goto error_return;

      if (! bfd_get_section_contents (abfd, sec, info.contents,
				      (file_ptr) 0, sec->_raw_size))
d3199 1
a3199 1
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
d3250 2
a3251 2
      if (s->_raw_size == 0)
	s->_raw_size = PLT_HEADER_SIZE;
d3253 2
a3254 2
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;
d3273 1
a3273 1
      s->_raw_size += sizeof (Elf64_External_Rela);
d3561 1
a3561 1
	plge = &td->got->_raw_size;
d3578 1
a3578 1
    alpha_elf_tdata(i)->got->_raw_size = 0;
d3588 1
a3588 1
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->_raw_size;
d3609 1
a3609 2
      alpha_elf_tdata(i)->got->_raw_size = got_offset;
      alpha_elf_tdata(i)->got->_cooked_size = got_offset;
d3706 1
a3706 1
  splt->_raw_size = 0;
a3710 2
  splt->_cooked_size = splt->_raw_size;

d3713 2
a3714 2
  if (splt->_raw_size)
    entries = (splt->_raw_size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d3717 1
a3717 2
  spltrel->_raw_size = entries * sizeof (Elf64_External_Rela);
  spltrel->_cooked_size = spltrel->_raw_size;
d3744 4
a3747 4
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->_raw_size;
      splt->_raw_size += PLT_ENTRY_SIZE;
d3789 1
a3789 1
      if (s->_raw_size > 0)
d3791 1
a3791 1
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->_raw_size);
d3875 1
a3875 1
	  relent->srel->_raw_size +=
d3929 1
a3929 1
  srel->_raw_size = sizeof (Elf64_External_Rela) * entries;
a3934 2
  srel->_cooked_size = srel->_raw_size;

d3975 1
a3975 1
      srel->_raw_size += sizeof (Elf64_External_Rela) * entries;
d4002 1
a4002 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d4045 1
a4045 1
	  strip = (s->_raw_size == 0);
d4068 2
a4069 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
d4143 1
a4143 2
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
d5020 1
a5020 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d5049 1
a5049 4
		{
		  dyn.d_un.d_val -=
		    (s->_cooked_size ? s->_cooked_size : s->_raw_size);
		}
d5059 1
a5059 2
	      dyn.d_un.d_val =
		(s->_cooked_size ? s->_cooked_size : s->_raw_size);
d5067 1
a5067 1
      if (splt->_raw_size > 0)
d5178 1
a5178 1
		      last = s->vma + s->_raw_size;
d5223 1
a5223 1
	      BFD_ASSERT (p->size == input_section->_raw_size);
d5306 1
a5306 1
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);
d5339 1
a5339 1
					sgot->_raw_size))
@


1.118
log
@	* elf64-alpha.c (elf64_alpha_read_ecoff_info): Don't assign
	structure field removed in 2004-04-24 patch.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): Warning fix.

	* elf-bfd.h (struct elf_backend_data <elf_backend_section_flags>):
	Constify hdr arg.
	* elf32-arm.h (elf32_arm_section_flags): Likewise.
	* elf64-alpha.c (elf64_alpha_section_flags): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_flags): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set the bfd_section
	field before calling elf_backend_section_flags.
@
text
@d4384 1
a4384 2
						sym->st_value + ent->addend,
						(bfd_vma) 0);
@


1.117
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d78 1
a78 1
  PARAMS ((flagword *, Elf_Internal_Shdr *));
d2318 1
a2318 1
     Elf_Internal_Shdr *hdr;
a2574 1
  debug->adjust = NULL;
@


1.116
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2465 1
a2465 1
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d2509 1
a2509 1
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d5338 1
a5338 1
  if (! bfd_elf64_bfd_final_link (abfd, info))
@


1.115
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d126 1
a126 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d2366 1
a2366 1
     const Elf_Internal_Sym *sym;
@


1.114
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d4097 1
a4097 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.113
log
@Catch GOT offsets for a symbol which have no associated GOT subsection.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d4402 6
a4407 6
	  
	  RELOC_FOR_GLOBAL_SYMBOL (hh,
				   (struct elf_link_hash_entry *) alpha_elf_sym_hashes (input_bfd),
				   r_symndx, symtab_hdr, value,
				   sec, unresolved_reloc, info,
				   warned);
@


1.113.4.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d126 1
a126 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d2366 1
a2366 1
     Elf_Internal_Sym *sym;
d2465 1
a2465 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2509 1
a2509 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d4097 1
a4097 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4402 6
a4407 6
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sec, value,
				   unresolved_reloc, warned);
d5338 1
a5338 1
  if (! bfd_elf_final_link (abfd, info))
@


1.113.6.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d126 1
a126 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d2366 1
a2366 1
     Elf_Internal_Sym *sym;
d4097 1
a4097 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4402 6
a4407 6
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sec, value,
				   unresolved_reloc, warned);
@


1.113.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2465 1
a2465 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2509 1
a2509 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d5338 1
a5338 1
  if (! bfd_elf_final_link (abfd, info))
@


1.113.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d78 1
a78 1
  PARAMS ((flagword *, const Elf_Internal_Shdr *));
a1038 1
  bfd_vma high_address;
d1048 2
a1049 3
  high_address = bfd_get_section_limit (abfd, input_section);
  if (reloc_entry->address > high_address
      || reloc_entry->address + reloc_entry->addend > high_address)
d1258 2
a1259 2
       ("%B: %A+0x%lx: warning: LITERAL relocation against unexpected insn",
	info->abfd, info->sec,
d1571 2
a1572 2
       ("%B: %A+0x%lx: warning: %s relocation against unexpected insn",
	info->abfd, info->sec,
d1976 5
d2015 6
a2020 1
      if (!bfd_malloc_and_get_section (abfd, sec, &info.contents))
d2318 1
a2318 1
     const Elf_Internal_Shdr *hdr;
d2575 1
d3208 1
a3208 1
	      sreloc->size += sizeof (Elf64_External_Rela);
d3259 2
a3260 2
      if (s->size == 0)
	s->size = PLT_HEADER_SIZE;
d3262 2
a3263 2
      h->plt.offset = s->size;
      s->size += PLT_ENTRY_SIZE;
d3282 1
a3282 1
      s->size += sizeof (Elf64_External_Rela);
d3570 1
a3570 1
	plge = &td->got->size;
d3587 1
a3587 1
    alpha_elf_tdata(i)->got->size = 0;
d3597 1
a3597 1
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->size;
d3618 2
a3619 1
      alpha_elf_tdata(i)->got->size = got_offset;
d3651 3
a3653 2
	        (_("%B: .got subsegment exceeds 64K (size %d)"),
	         i, alpha_elf_tdata (this_got)->total_got_size);
d3716 1
a3716 1
  splt->size = 0;
d3721 2
d3725 2
a3726 2
  if (splt->size)
    entries = (splt->size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d3729 2
a3730 1
  spltrel->size = entries * sizeof (Elf64_External_Rela);
d3757 4
a3760 4
      if (splt->size == 0)
	splt->size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->size;
      splt->size += PLT_ENTRY_SIZE;
d3802 1
a3802 1
      if (s->size > 0)
d3804 1
a3804 1
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->size);
d3888 1
a3888 1
	  relent->srel->size +=
d3942 1
a3942 1
  srel->size = sizeof (Elf64_External_Rela) * entries;
d3948 2
d3990 1
a3990 1
      srel->size += sizeof (Elf64_External_Rela) * entries;
d4017 1
a4017 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d4060 1
a4060 1
	  strip = (s->size == 0);
d4083 2
a4084 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL && s->size != 0)
d4158 2
a4159 1
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count <= srel->size);
d4199 2
a4200 2
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
d4325 2
a4326 2
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
d4385 2
a4386 1
						sym->st_value + ent->addend);
d4498 2
a4499 2
                (_("%B: gp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d4510 2
a4511 2
                (_("%B: gp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d4536 2
a4537 2
                (_("%B: pc-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d4564 2
a4565 2
		  (_("%B: change in gp: BRSGP %s"),
		   input_bfd, h->root.root.root.string);
d4594 2
a4595 2
		  (_("%B: !samegp reloc against symbol without .prologue: %s"),
		   input_bfd, name);
d4645 2
a4646 2
		      (_("%B: unhandled dynamic relocation against %s"),
		       input_bfd,
d4669 2
a4670 2
                (_("%B: pc-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d4728 2
a4729 2
                (_("%B: dtp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d4744 2
a4745 2
		(_("%B: TLS local exec code cannot be linked into shared objects"),
		input_bfd);
d4751 2
a4752 2
                (_("%B: tp-relative relocation against dynamic symbol %s"),
                 input_bfd, h->root.root.root.string);
d5037 1
a5037 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d5066 4
a5069 1
		dyn.d_un.d_val -= s->size;
d5079 2
a5080 1
	      dyn.d_un.d_val = s->size;
d5088 1
a5088 1
      if (splt->size > 0)
d5199 1
a5199 1
		      last = s->vma + s->size;
d5244 1
a5244 1
	      BFD_ASSERT (p->size == input_section->size);
d5327 1
a5327 1
	  o->size = bfd_ecoff_debug_size (abfd, &debug, swap);
d5360 1
a5360 1
					sgot->size))
@


1.113.6.4
log
@Merge from mainline.
@
text
@d2114 1
a2114 1
	  if (!h->root.def_regular)
d2453 1
a2453 1
  h->def_regular = 1;
d2497 1
a2497 1
  h->def_regular = 1;
d2744 4
a2747 3
  else if ((h->root.def_dynamic || h->root.ref_dynamic)
	   && !h->root.def_regular
	   && !h->root.ref_regular)
d2834 1
a2834 1
  else if (h->root.needs_plt)
d3001 1
a3001 1
	  h->root.ref_regular = 1;
d3011 1
a3011 1
		|| !h->root.def_regular
d3117 1
a3117 1
		    h->root.needs_plt = 1;
d3119 1
a3119 1
		    h->root.needs_plt = 0;
d3243 1
a3243 1
      h->needs_plt = 1;
d3278 1
a3278 1
    h->needs_plt = 0;
d3283 1
a3283 1
  if (h->u.weakdef != NULL)
d3285 4
a3288 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d3730 1
a3730 1
  if (!h->root.needs_plt)
d3750 1
a3750 1
      h->root.needs_plt = 0;
d3852 5
a3856 3
  if (!h->root.def_regular
      && h->root.ref_regular
      && !h->root.def_dynamic
d3860 1
a3860 1
    h->root.def_regular = 1;
d4900 1
a4900 1
      if (!h->def_regular)
@


1.112
log
@	* elf32-i386.c (elf_i386_object_p): Delete.
	(elf_backend_object_p): Don't define.
	* elf32-s390.c (elf_s390_object_p): No need to alloc tdata here.
	* elf32-sh.c (sh_elf_object_p): Likewise.
	* elf32-sparc.c (elf32_sparc_object_p): Likewise.
	* elf64-alpha.c (elf64_alpha_object_p): Likewise.
	* elf64-s390.c (elf_s390_object_p): Likewise.
	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Likewise.
@
text
@d3550 1
d3559 2
a3560 2
	bfd_size_type *plge
	  = &alpha_elf_tdata (gotent->gotobj)->got->_raw_size;
d3562 9
d3575 1
a3575 1
  return TRUE;
@


1.111
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@a395 9
  /* Allocate our special target data.  */
  struct alpha_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;

@


1.110
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d3643 1
a3643 1
	  /* We are assuming no merging has yet ocurred.  */
@


1.109
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d4341 1
d4344 2
a4345 1
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
a4372 1
	      asection *msec;
@


1.108
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d1161 2
a1162 2
#define alpha_get_dtprel_base(tlss) \
  ((tlss)->start)
d1166 4
a1169 2
#define alpha_get_tprel_base(tlss) \
  ((tlss)->start - align_power ((bfd_vma) 16, (tlss)->align))
a1202 1
  struct elf_link_tls_segment *tls_segment;
a1227 2
static struct elf_link_tls_segment *elf64_alpha_relax_find_tls_segment
  PARAMS((struct alpha_relax_info *, struct elf_link_tls_segment *));
d1600 3
a1602 3
      BFD_ASSERT (info->tls_segment != NULL);
      dtp_base = alpha_get_dtprel_base (info->tls_segment);
      tp_base = alpha_get_tprel_base (info->tls_segment);
d1847 2
a1848 2
	BFD_ASSERT (info->tls_segment != NULL);
	tp_base = alpha_get_tprel_base (info->tls_segment);
a1962 47
static struct elf_link_tls_segment *
elf64_alpha_relax_find_tls_segment (info, seg)
     struct alpha_relax_info *info;
     struct elf_link_tls_segment *seg;
{
  bfd *output_bfd = info->sec->output_section->owner;
  asection *o;
  unsigned int align;
  bfd_vma base, end;

  for (o = output_bfd->sections; o ; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
        && (o->flags & SEC_LOAD) != 0)
      break;
  if (!o)
    return NULL;

  base = o->vma;
  align = 0;

  do
    {
      bfd_vma size;

      if (bfd_get_section_alignment (output_bfd, o) > align)
	align = bfd_get_section_alignment (output_bfd, o);

      size = o->_raw_size;
      if (size == 0 && (o->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *lo;
	  for (lo = o->link_order_head; lo ; lo = lo->next)
	    if (size < lo->offset + lo->size)
	      size = lo->offset + lo->size;
	}
      end = o->vma + size;
      o = o->next;
    }
  while (o && (o->flags & SEC_THREAD_LOCAL));

  seg->start = base;
  seg->size = end - base;
  seg->align = align;

  return seg;
}

a1975 1
  struct elf_link_tls_segment tls_segment;
a2032 5
  /* Compute the TLS segment information.  The version normally found in
     elf_hash_table (link_info)->tls_segment isn't built until final_link.
     ??? Probably should look into extracting this into a common function.  */
  info.tls_segment = elf64_alpha_relax_find_tls_segment (&info, &tls_segment);

d2086 1
a2086 1
	      symval = alpha_get_tprel_base (info.tls_segment);
a4242 1
  struct elf_link_tls_segment *tls_segment;
d4296 1
a4296 2
  tls_segment = elf_hash_table (info)->tls_segment;
  if (tls_segment)
d4298 2
a4299 2
      dtp_base = alpha_get_dtprel_base (tls_segment);
      tp_base = alpha_get_tprel_base (tls_segment);
d4621 1
a4621 1
		BFD_ASSERT(tls_segment != NULL);
d4627 1
a4627 1
		BFD_ASSERT(tls_segment != NULL);
d4707 1
a4707 1
		  BFD_ASSERT(tls_segment != NULL);
d4730 1
a4730 1
	  BFD_ASSERT(tls_segment != NULL);
d4753 1
a4753 1
	  BFD_ASSERT(tls_segment != NULL);
d4774 1
a4774 1
		  BFD_ASSERT(tls_segment != NULL);
@


1.107
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@a5602 1
#define elf_backend_plt_header_size PLT_HEADER_SIZE
@


1.106
log
@	* elf64-alpha.c (elf64_alpha_create_got_section): Initialize
	->got if the section already exists.
@
text
@d5452 3
a5454 6
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.105
log
@Better handking for unresolved symbols
@
text
@d2470 7
a2476 2
  if (bfd_get_section_by_name (abfd, ".got"))
    return TRUE;
@


1.104
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d3077 1
a3077 1
		 && (!info->symbolic || info->allow_shlib_undefined))
d4448 9
a4456 1
	  h = alpha_elf_sym_hashes (input_bfd)[r_symndx - symtab_hdr->sh_info];
d4458 2
a4459 9
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  value = 0;
	  if (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.root.u.def.section;
d4461 3
a4463 14
	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */

	      if (sec->output_section != NULL)
		value = (h->root.root.u.def.value
			 + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.root.type == bfd_link_hash_undefweak)
a4464 14
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (info->executable || info->no_undefined
		      || ELF_ST_VISIBILITY (h->root.other)))))
		return FALSE;
	      continue;
	    }
d4466 1
@


1.103
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d4484 1
a4484 1
		     (!info->shared || info->no_undefined
@


1.102
log
@        * elflink.c (_bfd_elf_dynamic_symbol_p): New.
        * elf-bfd.h (_bfd_elf_dynamic_symbol_p): Declare it.
        (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use it.
        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Likewise.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
        * elf64-hppa.c (elf64_hppa_dynamic_symbol_p): Likewise.
        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Likewise.
        Update all callers to provide the relocation being resolved.
@
text
@d5468 10
d5615 3
@


1.101
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d50 1
a50 1
static int alpha_elf_dynamic_symbol_p
d272 4
a275 1
/* Should we do dynamic things to this symbol?  */
d277 1
a277 1
static int
d282 1
a282 36
  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return TRUE;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_DEFAULT:
      break;
    case STV_HIDDEN:
    case STV_INTERNAL:
      return FALSE;
    case STV_PROTECTED:
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
        return FALSE;
      break;
    }

  if ((info->shared && !info->symbolic)
      || ((h->elf_link_hash_flags
	   & (ELF_LINK_HASH_DEF_DYNAMIC
	      | ELF_LINK_HASH_DEF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR))
	  == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))
    return TRUE;

  return FALSE;
@


1.100
log
@Correct spelling of "relocatable".
@
text
@d4507 1
a4507 1
	  else if (info->shared
@


1.99
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d2061 1
a2061 1
  if (link_info->relocateable
d2468 1
a2468 1
      && !info->relocateable
d3060 1
a3060 1
  if (info->relocateable)
d3866 1
a3866 1
  if (info->relocateable)
d4333 1
a4333 1
  if (info->relocateable)
@


1.98
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d4093 1
a4093 1
      if (!info->shared)
d4179 1
a4179 1
      if (!info->shared)
@


1.97
log
@        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Return false for an
        executable when a symbol is defined both regular and dynamic.
@
text
@d1559 1
a1559 1
	  tsec_relocs = (_bfd_elf64_link_read_relocs
d2075 1
a2075 1
  internal_relocs = (_bfd_elf64_link_read_relocs
d5559 1
a5559 1
  64, 8,
@


1.96
log
@        * elf64-alpha.c (elf64_alpha_relocate_section) <R_ALPHA_GPREL32>:
        Ignore relocations against r_symndx == 0.
@
text
@d308 3
a310 1
	   & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))
@


1.96.2.1
log
@Merge from mainline.
@
text
@d308 1
a308 3
	   & (ELF_LINK_HASH_DEF_DYNAMIC
	      | ELF_LINK_HASH_DEF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR))
@


1.96.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1559 1
a1559 1
	  tsec_relocs = (_bfd_elf_link_read_relocs
d2075 1
a2075 1
  internal_relocs = (_bfd_elf_link_read_relocs
d5559 1
a5559 1
  64, 3,
@


1.95
log
@2003-04-09  H.J. Lu <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_relocate_section): Don't return
	FALSE for undefined symbols.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
@
text
@d4582 13
a4595 1
	case R_ALPHA_GPREL32:
@


1.94
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@a4516 1
	      ret_val = FALSE;
@


1.94.12.1
log
@Merge with mainline.
@
text
@d4517 1
d4583 1
a4584 13
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

	case R_ALPHA_GPREL16:
@


1.93
log
@	* elf64-alpha.c (elf64_alpha_relax_section): Don't crash if
	local_got_entries is NULL.
@
text
@a4505 1
		   && (!info->symbolic || info->allow_shlib_undefined)
d5178 1
a5178 1
      /* Initialize the PLT0 entry */
@


1.92
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d2187 7
a2193 1
	  info.first_gotent = &local_got_entries[r_symndx];
@


1.91
log
@        * elf64-alpha.c (ALPHA_ELF_LINK_HASH_PLT_LOC): New.
        (struct alpha_elf_link_hash_entry): Add plt_old_section, plt_old_value.
        (elf64_alpha_adjust_dynamic_symbol): Set them.
        (elf64_alpha_size_plt_section_1): Reset them when plt entry removed.
        (elf64_alpha_relax_tls_get_addr): Handle LDM relocs.  Frob the
        symbol index when relaxing LDM to TPREL.
        (elf64_alpha_relax_section): Likewise.  Allow relaxation of GD
        relocs, even if the target isn't locally defined.
        (elf64_alpha_check_relocs): Frob LDM reloc symndx to zero.
        (elf64_alpha_relocate_section): Likewise.  Force TP-relative
        relocs vs symndx 0 to the tp base.
@
text
@d4441 1
a4441 2
	      && (elf_section_data (sec)->sec_info_type
		  == ELF_INFO_TYPE_MERGE)
@


1.90
log
@        * elf64-alpha.c (alpha_dynamic_entries_for_reloc): GOTTPREL and
        TPREL also get a reloc if shared.  Remove SREL support.
        (elf64_alpha_emit_dynrel): New.
        (elf64_alpha_relocate_section): Use it.  Resolve dynamic TPREL
        and GOTTPREL relocs to local symbols against the tp base.
        (elf64_alpha_finish_dynamic_symbol): Use elf64_alpha_emit_dynrel.

        * elf64-alpha.c (elf64_alpha_relax_got_load): Decrement got
        use count before clobbering r_type.
        (elf64_alpha_relax_tls_get_addr): Don't use pos[1] if insn
        ordering would mean dataflow inspection is necessary.
@
text
@d180 5
d1761 1
a1764 7
  /* ??? For LD relaxation, we need a symbol referencing the beginning
     of the TLS segment.  */
  /* ??? The STN_UNDEF symbol (dynindex 0) works fine for this.  Adjust
     the code below to expect that.  */
  if (!is_gd)
    return TRUE;

d1870 1
d1889 1
a1889 2
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPREL16);
d1903 1
a1903 2
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELHI);
d1905 1
a1905 2
	    irel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELLO);
d1919 1
a1919 2
      irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				     R_ALPHA_GOTTPREL);
d2122 1
d2133 2
d2136 3
d2140 1
d2146 1
a2146 1
      if (ELF64_R_SYM (irel->r_info) < symtab_hdr->sh_info)
d2163 9
a2171 7
	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;
	  else if (isym->st_shndx == SHN_ABS)
	    info.tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    info.tsec = bfd_com_section_ptr;
d2173 11
a2183 1
	    info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d2187 1
a2187 2
	  info.first_gotent = &local_got_entries[ELF64_R_SYM(irel->r_info)];
	  symval = isym->st_value;
d2194 1
a2194 1
	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
d2210 13
a2222 1
	    continue;
a2224 1
	  info.tsec = h->root.root.u.def.section;
a2226 1
	  symval = h->root.root.u.def.value;
d3144 8
a3152 1
	case R_ALPHA_TLSLDM:
d3354 3
d3838 8
d4409 5
d4419 12
@


1.89
log
@Treat elfNN_bed like other macros defined in elfxx-target.h and #undef it
before #define'ing it.
@
text
@d138 3
d1644 11
a1673 10
  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

d1755 1
a1755 1
  bfd_boolean dynamic, use_gottprel;
d1761 2
d1802 1
d1804 4
a1807 2
  /* Only positions 0 and 1 are allowed to be out of order.  */
  if (pos[1] < pos[0])
d1813 3
a1815 1
  if (pos[1] >= pos[2] || pos[2] >= pos[3] || pos[3] >= pos[4])
d1895 2
a1896 1
		 && disp < (bfd_signed_vma) 0x7fff8000)
d3857 1
a3859 1
    case R_ALPHA_GOTTPREL:
d3865 1
a3866 3
    case R_ALPHA_SREL64:
    case R_ALPHA_TPREL64:
      return dynamic;
d4160 32
d4509 3
a4511 19
		{
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;

		  BFD_ASSERT(srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		  outrel.r_addend = value;

		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}
d4636 2
a4637 2
	    Elf_Internal_Rela outrel;
	    bfd_byte *loc;
d4645 2
a4646 2
		outrel.r_info = ELF64_R_INFO (h->root.dynindx, r_type);
		outrel.r_addend = addend;
d4658 7
a4664 2
		value -= dtp_base;
		goto default_reloc;
d4678 3
a4680 2
		outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		outrel.r_addend = value;
d4685 3
a4687 16
	    BFD_ASSERT(srel != NULL);

	    outrel.r_offset =
	      _bfd_elf_section_offset (output_bfd, info, input_section,
				       rel->r_offset);
	    if ((outrel.r_offset | 1) != (bfd_vma) -1)
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
	    else
	      memset (&outrel, 0, sizeof outrel);

	    loc = srel->contents;
	    loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	    BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
			<= srel->_cooked_size);
d4729 3
a4731 20
		{
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;

		  BFD_ASSERT(srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  /* ??? Proper dynindx here.  */
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_DTPMOD64);
		  outrel.r_addend = 0;

		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}
d4805 12
a4816 1
		  value -= (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
d4973 3
a4975 13
		{
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		  outrel.r_addend = plt_addr;

		  loc = srel->contents;
		  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
			      <= srel->_cooked_size);
		}
a4985 2
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
d4996 1
a4996 1
	  int r_type;
a5001 3
	  outrel.r_offset = (sgot->output_section->vma
			     + sgot->output_offset
			     + gotent->got_offset);
d5023 3
a5025 6
	  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
	  outrel.r_addend = gotent->addend;

	  loc = srel->contents;
	  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d5028 3
a5030 11
	    {
	      outrel.r_offset += 8;
	      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_DTPREL64);

	      loc = srel->contents;
	      loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	    }

	  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
		      <= srel->_cooked_size);
@


1.88
log
@	* elf.c (elf_sort_sections): Don't reorder .tbss.
	(assign_file_positions_for_segments): Only adjust off/voff
	for increased alignment in PT_LOAD or PT_NOTE segment,
	but adjust p_filesz for .tbss too.  in PT_LOAD consider
	.tbss to have zero memory size.
	(copy_private_bfd_data) [SECTION_SIZE]: Define.
	[IS_CONTAINED_BY_VMA, IS_CONTAINED_BY_LMA]: Use it.
	[INCLUDE_SECTION_IN_SEGMENT]: Only put SHF_TLS sections
	into PT_TLS segment.  Never put SHF_TLS sections in
	segments other than PT_TLS or PT_LOAD.

	* elf64-alpha.c (elf64_alpha_finish_dynamic_sections): Clear .plt
	sh_entsize.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 1
a51 1
  PARAMS((struct elf_link_hash_entry *, struct bfd_link_info *));
d53 1
a53 1
  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d55 1
a55 1
  PARAMS((bfd *));
d58 1
a58 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 1
a60 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d62 1
a62 1
  PARAMS((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
d64 1
a64 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d67 1
a67 1
  PARAMS((bfd *, bfd_reloc_code_real_type));
d69 1
a69 1
  PARAMS((bfd *, arelent *, Elf_Internal_Rela *));
d72 1
a72 1
  PARAMS((bfd *));
d74 1
a74 1
  PARAMS((bfd *));
d76 1
a76 1
  PARAMS((bfd *, Elf_Internal_Shdr *, const char *));
d78 1
a78 1
  PARAMS((flagword *, Elf_Internal_Shdr *));
d80 1
a80 1
  PARAMS((bfd *, Elf_Internal_Shdr *, asection *));
d82 1
a82 1
  PARAMS((bfd *, struct bfd_link_info *));
d84 1
a84 1
  PARAMS((bfd *, struct bfd_link_info *));
d87 1
a87 1
  PARAMS((bfd *, asection *, struct ecoff_debug_info *));
d89 1
a89 1
  PARAMS((bfd *, const char *));
d91 2
a92 2
  PARAMS((bfd *, asection *, asymbol **, bfd_vma, const char **,
	  const char **, unsigned int *));
d99 1
a99 1
  PARAMS((struct alpha_elf_link_hash_entry *, PTR));
d102 1
a102 1
  PARAMS((bfd *, bfd *));
d104 1
a104 1
  PARAMS((bfd *, bfd *));
d132 1
a132 1
  PARAMS((bfd *, struct bfd_link_info *, asection *sec,
d135 1
a135 1
  PARAMS((struct bfd_link_info *, struct elf_link_hash_entry *));
d137 1
a137 1
  PARAMS((bfd *, struct bfd_link_info *));
d139 2
a140 2
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d142 1
a142 1
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
d145 2
a146 2
  PARAMS((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	  Elf_Internal_Sym *));
d148 1
a148 1
  PARAMS((bfd *, struct bfd_link_info *));
d150 1
a150 1
  PARAMS((bfd *, struct bfd_link_info *));
d152 1
a152 1
  PARAMS((struct alpha_elf_link_hash_entry *, PTR));
d183 1
a183 1
    /* which .got subsection?  */
d186 1
a186 1
    /* the addend in effect for this entry.  */
d189 1
a189 1
    /* the .got offset for this entry.  */
d208 1
a208 1
  /* used to count non-got, non-plt relocations for delayed sizing
d214 1
a214 1
    /* which .reloc section? */
d217 1
a217 1
    /* what kind of relocation? */
d220 1
a220 1
    /* is this against read-only section? */
d223 1
a223 1
    /* how many did we find?  */
d5619 1
@


1.87
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d5140 1
a5140 2
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize =
	    PLT_HEADER_SIZE;
@


1.86
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d71 1
a71 1
static boolean elf64_alpha_mkobject
d73 1
a73 1
static boolean elf64_alpha_object_p
d75 1
a75 1
static boolean elf64_alpha_section_from_shdr
d77 1
a77 1
static boolean elf64_alpha_section_flags
d79 1
a79 1
static boolean elf64_alpha_fake_sections
d81 1
a81 1
static boolean elf64_alpha_create_got_section
d83 1
a83 1
static boolean elf64_alpha_create_dynamic_sections
d86 1
a86 1
static boolean elf64_alpha_read_ecoff_info
d88 1
a88 1
static boolean elf64_alpha_is_local_label_name
d90 1
a90 1
static boolean elf64_alpha_find_nearest_line
d98 1
a98 1
static boolean elf64_alpha_output_extsym
d101 1
a101 1
static boolean elf64_alpha_can_merge_gots
d105 1
a105 1
static boolean elf64_alpha_calc_got_offsets_for_symbol
d107 1
a107 2
static void elf64_alpha_calc_got_offsets PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_got_sections
d109 1
a109 1
static boolean elf64_alpha_size_plt_section
d111 3
a113 1
static boolean elf64_alpha_size_plt_section_1
d115 1
a115 1
static boolean elf64_alpha_always_size_sections
d119 1
a119 1
static boolean elf64_alpha_calc_dynrel_sizes
d121 1
a121 1
static boolean elf64_alpha_size_rela_got_section
d123 1
a123 1
static boolean elf64_alpha_size_rela_got_1
d125 1
a125 1
static boolean elf64_alpha_add_symbol_hook
d131 1
a131 1
static boolean elf64_alpha_check_relocs
d134 1
a134 1
static boolean elf64_alpha_adjust_dynamic_symbol
d136 1
a136 1
static boolean elf64_alpha_size_dynamic_sections
d138 1
a138 1
static boolean elf64_alpha_relocate_section_r
d141 1
a141 1
static boolean elf64_alpha_relocate_section
d144 1
a144 1
static boolean elf64_alpha_finish_dynamic_symbol
d147 1
a147 1
static boolean elf64_alpha_finish_dynamic_sections
d149 1
a149 1
static boolean elf64_alpha_final_link
d151 1
a151 1
static boolean elf64_alpha_merge_ind_symbols
d251 1
a251 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d272 1
a272 1
    return false;
d279 1
a279 1
    return false;
d283 1
a283 1
    return true;
d291 1
a291 1
      return false;
d294 1
a294 1
        return false;
d302 1
a302 1
    return true;
d304 1
a304 1
  return false;
d403 1
a403 1
static boolean
d410 2
a411 2
    return false;
  return true;
d414 1
a414 1
static boolean
d423 1
a423 1
    return false;
d444 1
a444 1
	 true,			/* pc_relative */
d449 1
a449 1
	 false,			/* partial_inplace */
d452 1
a452 1
	 true),			/* pcrel_offset */
d459 1
a459 1
	 false,			/* pc_relative */
d464 1
a464 1
	 false,			/* partial_inplace */
d467 1
a467 1
	 false),		/* pcrel_offset */
d474 1
a474 1
	 false,			/* pc_relative */
d479 1
a479 1
	 false,			/* partial_inplace */
d482 1
a482 1
	 false),		/* pcrel_offset */
d491 1
a491 1
	 false,			/* pc_relative */
d496 1
a496 1
	 false,			/* partial_inplace */
d499 1
a499 1
	 false),		/* pcrel_offset */
d506 1
a506 1
	 false,			/* pc_relative */
d511 1
a511 1
	 false,			/* partial_inplace */
d514 1
a514 1
	 false),		/* pcrel_offset */
d527 1
a527 1
	 false,			/* pc_relative */
d532 1
a532 1
	 false,			/* partial_inplace */
d535 1
a535 1
	 false),		/* pcrel_offset */
d557 1
a557 1
	 false,			/* pc_relative */
d562 1
a562 1
	 false,			/* partial_inplace */
d565 1
a565 1
	 true),			/* pcrel_offset */
d572 1
a572 1
	 true,			/* pc_relative */
d577 1
a577 1
	 false,			/* partial_inplace */
d580 1
a580 1
	 true),			/* pcrel_offset */
d587 1
a587 1
	 true,			/* pc_relative */
d592 1
a592 1
	 false,			/* partial_inplace */
d595 1
a595 1
	 true),			/* pcrel_offset */
d602 1
a602 1
	 true,			/* pc_relative */
d607 1
a607 1
	 false,			/* partial_inplace */
d610 1
a610 1
	 true),			/* pcrel_offset */
d617 1
a617 1
	 true,			/* pc_relative */
d622 1
a622 1
	 false,			/* partial_inplace */
d625 1
a625 1
	 true),			/* pcrel_offset */
d632 1
a632 1
	 true,			/* pc_relative */
d637 1
a637 1
	 false,			/* partial_inplace */
d640 1
a640 1
	 true),			/* pcrel_offset */
d654 1
a654 1
	 false,			/* pc_relative */
d659 1
a659 1
	 false,			/* partial_inplace */
d662 1
a662 1
	 false),		/* pcrel_offset */
d669 1
a669 1
	 false,			/* pc_relative */
d674 1
a674 1
	 false,			/* partial_inplace */
d677 1
a677 1
	 false),		/* pcrel_offset */
d684 1
a684 1
	 false,			/* pc_relative */
d689 1
a689 1
	 false,			/* partial_inplace */
d692 1
a692 1
	 false),		/* pcrel_offset */
d710 1
a710 1
	 false,
d715 1
a715 1
	 false,
d718 1
a718 1
	 true),
d725 1
a725 1
	 false,
d730 1
a730 1
	 false,
d733 1
a733 1
	 true),
d740 1
a740 1
	 false,
d745 1
a745 1
	 false,
d748 1
a748 1
	 true),
d755 1
a755 1
	 false,
d760 1
a760 1
	 false,
d763 1
a763 1
	 true),
d770 1
a770 1
	 true,			/* pc_relative */
d775 1
a775 1
	 false,			/* partial_inplace */
d778 1
a778 1
	 true),			/* pcrel_offset */
d785 1
a785 1
	 false,			/* pc_relative */
d790 1
a790 1
	 false,			/* partial_inplace */
d793 1
a793 1
	 false),		/* pcrel_offset */
d800 1
a800 1
	 false,			/* pc_relative */
d805 1
a805 1
	 false,			/* partial_inplace */
d808 1
a808 1
	 false),		/* pcrel_offset */
d815 1
a815 1
	 false,			/* pc_relative */
d820 1
a820 1
	 false,			/* partial_inplace */
d823 1
a823 1
	 false),		/* pcrel_offset */
d831 1
a831 1
	 false,			/* pc_relative */
d836 1
a836 1
	 false,			/* partial_inplace */
d839 1
a839 1
	 false),		/* pcrel_offset */
d846 1
a846 1
	 false,			/* pc_relative */
d851 1
a851 1
	 false,			/* partial_inplace */
d854 1
a854 1
	 false),		/* pcrel_offset */
d861 1
a861 1
	 false,			/* pc_relative */
d866 1
a866 1
	 false,			/* partial_inplace */
d869 1
a869 1
	 false),		/* pcrel_offset */
d876 1
a876 1
	 false,			/* pc_relative */
d881 1
a881 1
	 false,			/* partial_inplace */
d884 1
a884 1
	 false),		/* pcrel_offset */
d891 1
a891 1
	 false,			/* pc_relative */
d896 1
a896 1
	 false,			/* partial_inplace */
d899 1
a899 1
	 false),		/* pcrel_offset */
d907 1
a907 1
	 false,			/* pc_relative */
d912 1
a912 1
	 false,			/* partial_inplace */
d915 1
a915 1
	 false),		/* pcrel_offset */
d922 1
a922 1
	 false,			/* pc_relative */
d927 1
a927 1
	 false,			/* partial_inplace */
d930 1
a930 1
	 false),		/* pcrel_offset */
d937 1
a937 1
	 false,			/* pc_relative */
d942 1
a942 1
	 false,			/* partial_inplace */
d945 1
a945 1
	 false),		/* pcrel_offset */
d952 1
a952 1
	 false,			/* pc_relative */
d957 1
a957 1
	 false,			/* partial_inplace */
d960 1
a960 1
	 false),		/* pcrel_offset */
d967 1
a967 1
	 false,			/* pc_relative */
d972 1
a972 1
	 false,			/* partial_inplace */
d975 1
a975 1
	 false),		/* pcrel_offset */
d1230 2
a1231 2
  boolean changed_contents;
  boolean changed_relocs;
d1235 1
a1235 1
static boolean elf64_alpha_relax_with_lituse
d1240 1
a1240 1
static boolean elf64_alpha_relax_got_load
d1243 1
a1243 1
static boolean elf64_alpha_relax_gprelhilo
d1245 2
a1246 2
          Elf_Internal_Rela *irel, boolean));
static boolean elf64_alpha_relax_tls_get_addr
d1248 1
a1248 1
          Elf_Internal_Rela *irel, boolean));
d1251 1
a1251 1
static boolean elf64_alpha_relax_section
d1253 1
a1253 1
	  boolean *again));
d1271 1
a1271 1
static boolean
d1280 4
a1283 4
  boolean fits16;
  boolean fits32;
  boolean lit_reused = false;
  boolean all_optimized = true;
d1293 1
a1293 1
      return true;
d1298 1
a1298 1
    return true;
d1326 1
a1326 1
	  all_optimized = false;
d1352 1
a1352 1
	      info->changed_relocs = true;
d1356 1
a1356 1
	      info->changed_contents = true;
d1369 2
a1370 2
	      lit_reused = true;
	      info->changed_contents = true;
d1375 1
a1375 1
	      info->changed_relocs = true;
d1378 1
a1378 1
	    all_optimized = false;
d1392 1
a1392 1
	  info->changed_relocs = true;
d1396 1
a1396 1
	  info->changed_contents = true;
d1430 1
a1430 1
		  all_optimized = false;
d1442 2
a1443 2
		info->changed_contents = true;
		info->changed_relocs = true;
d1446 1
a1446 1
	      all_optimized = false;
d1474 2
a1475 2
			info->changed_contents = true;
			info->changed_relocs = true;
d1503 1
a1503 1
	  info->changed_relocs = true;
d1507 1
a1507 1
	  info->changed_contents = true;
d1511 1
a1511 1
  return true;
d1586 1
a1586 1
static boolean
d1606 1
a1606 1
      return true;
d1611 1
a1611 1
    return true;
d1615 1
a1615 1
    return true;
d1630 1
a1630 1
    return true;
d1639 1
a1639 1
  info->changed_contents = true;
d1654 1
a1654 1
      return false;
d1658 1
a1658 1
  info->changed_relocs = true;
d1683 1
a1683 1
  return true;
d1686 1
a1686 1
static boolean
d1691 1
a1691 1
     boolean hi;
d1707 1
a1707 1
  return true;
d1711 1
a1711 1
    return true;
d1718 1
a1718 1
      info->changed_contents = true;
d1722 1
a1722 1
      info->changed_relocs = true;
d1731 1
a1731 1
      info->changed_contents = true;
d1735 1
a1735 1
      info->changed_relocs = true;
d1738 1
a1738 1
  return true;
d1741 1
a1741 1
static boolean
d1746 1
a1746 1
     boolean is_gd;
d1751 1
a1751 1
  boolean dynamic, use_gottprel;
d1758 1
a1758 1
    return true;
d1773 1
a1773 1
    return true;
d1778 1
a1778 1
    return true;
d1782 1
a1782 1
    return true;
d1789 1
a1789 1
    return true;
d1805 1
a1805 1
    return true;
d1859 1
a1859 1
  use_gottprel = false;
d1903 1
a1903 1
      use_gottprel = true;
d1931 2
a1932 2
  info->changed_contents = true;
  info->changed_relocs = true;
d1966 1
a1966 1
		return false;
d1983 1
a1983 1
  return true;
d2033 1
a2033 1
static boolean
d2038 1
a2038 1
     boolean *again;
d2049 1
a2049 1
  *again = false;
d2054 1
a2054 1
    return true;
d2069 1
a2069 1
    return false;
d2250 1
a2250 1
    return false;
d2252 1
a2252 1
    return false;
d2254 1
a2254 1
    return false;
d2290 1
a2290 1
  return true;
d2302 1
a2302 1
  return false;
d2326 1
a2326 1
static boolean
d2343 1
a2343 1
	return false;
d2346 1
a2346 1
      return false;
d2350 1
a2350 1
    return false;
d2358 1
a2358 1
	return false;
d2361 1
a2361 1
  return true;
d2366 1
a2366 1
static boolean
d2374 1
a2374 1
  return true;
d2380 1
a2380 1
static boolean
d2407 1
a2407 1
  return true;
d2413 1
a2413 1
static boolean
d2439 1
a2439 1
	    return false;
d2446 1
a2446 1
  return true;
d2451 1
a2451 1
static boolean
d2459 1
a2459 1
    return true;
d2468 1
a2468 1
    return false;
d2472 1
a2472 1
  return true;
d2477 1
a2477 1
static boolean
d2496 1
a2496 1
    return false;
d2503 1
a2503 1
	  (bfd_vma) 0, (const char *) NULL, false,
d2505 1
a2505 1
    return false;
d2512 1
a2512 1
    return false;
d2522 1
a2522 1
    return false;
d2528 1
a2528 1
    return false;
d2538 1
a2538 1
    return false;
d2548 2
a2549 2
	 false, get_elf_backend_data (abfd)->collect, &bh)))
    return false;
d2556 1
a2556 1
    return false;
d2560 1
a2560 1
  return true;
d2566 1
a2566 1
static boolean
d2623 1
a2623 1
  return true;
d2650 1
a2650 1
  return false;
d2655 1
a2655 1
static boolean
d2674 1
a2674 1
static boolean
d2691 1
a2691 1
    return true;
d2721 1
a2721 1
	      return false;
d2727 1
a2727 1
	      return false;
d2736 1
a2736 1
	      return false;
d2761 1
a2761 1
	  return true;
d2782 1
a2782 1
  boolean failed;
d2785 1
a2785 1
static boolean
d2791 1
a2791 1
  boolean strip;
d2798 1
a2798 1
    strip = false;
d2803 1
a2803 1
    strip = true;
d2808 2
a2809 2
				   false, false) == NULL))
    strip = true;
d2811 1
a2811 1
    strip = false;
d2814 1
a2814 1
    return true;
d2912 2
a2913 2
      einfo->failed = true;
      return false;
d2916 1
a2916 1
  return true;
d3000 1
a3000 1
static boolean
d3013 1
a3013 1
  boolean got_created;
d3017 1
a3017 1
    return true;
d3027 1
a3027 1
  got_created = false;
d3041 1
a3041 1
      boolean maybe_dynamic;
d3063 1
a3063 1
      maybe_dynamic = false;
d3068 1
a3068 1
        maybe_dynamic = true;
d3134 1
a3134 1
		return false;
d3152 1
a3152 1
	    return false;
d3180 1
a3180 1
		return false;
d3206 1
a3206 1
		    return false;
d3229 1
a3229 1
		    return false;
d3255 1
a3255 1
  return true;
d3264 1
a3264 1
static boolean
d3295 1
a3295 1
	return false;
d3320 1
a3320 1
      return true;
d3334 1
a3334 1
      return true;
d3342 1
a3342 1
  return true;
d3349 1
a3349 1
static boolean
d3357 1
a3357 1
    return true;
d3420 1
a3420 1
  return true;
d3425 1
a3425 1
static boolean
d3434 1
a3434 1
    return true;
d3438 1
a3438 1
    return false;
d3475 1
a3475 1
	        return false;
d3481 1
a3481 1
  return true;
d3581 1
a3581 1
static boolean
d3601 1
a3601 1
  return true;
d3651 1
a3651 1
static boolean
d3680 1
a3680 1
	      return false;
d3692 1
a3692 1
	return true;
d3723 1
a3723 1
  return true;
d3729 1
a3729 1
static boolean
d3740 1
a3740 1
    return true;
d3758 1
a3758 1
  return true;
d3761 1
a3761 1
static boolean
d3771 1
a3771 1
    return true;
d3794 1
a3794 1
  return true;
d3797 1
a3797 1
static boolean
d3805 1
a3805 1
    return true;
d3813 1
a3813 1
    return false;
d3824 1
a3824 1
	    return false;
d3828 1
a3828 1
  return true;
d3867 1
a3867 1
static boolean
d3872 1
a3872 1
  boolean dynamic;
d3915 1
a3915 1
  return true;
d3920 1
a3920 1
static boolean
d3960 1
a3960 1
      return true;
d3970 1
a3970 1
  return true;
d3976 1
a3976 1
static boolean
d3981 1
a3981 1
  boolean dynamic;
d4013 1
a4013 1
  return true;
d4018 1
a4018 1
static boolean
d4025 1
a4025 1
  boolean relplt;
d4055 1
a4055 1
  relplt = false;
d4059 1
a4059 1
      boolean strip;
d4076 1
a4076 1
      strip = false;
d4085 1
a4085 1
		relplt = true;
d4105 1
a4105 1
	    return false;
d4122 1
a4122 1
	    return false;
d4131 1
a4131 1
	    return false;
d4137 1
a4137 1
	return false;
d4142 1
a4142 1
	    return false;
d4147 1
a4147 1
  return true;
d4156 1
a4156 1
static boolean
d4171 1
a4171 1
  boolean ret_val = true;
d4190 1
a4190 1
	  ret_val = false;
d4217 1
a4217 1
static boolean
d4237 1
a4237 1
  boolean ret_val;
d4248 1
a4248 1
  ret_val = true;
d4307 2
a4308 2
      boolean dynamic_symbol_p;
      boolean undef_weak_ref = false;
d4318 1
a4318 1
	  ret_val = false;
d4368 1
a4368 1
	  dynamic_symbol_p = false;
d4398 1
a4398 1
	    undef_weak_ref = true;
d4411 2
a4412 2
		return false;
	      ret_val = false;
d4502 1
a4502 1
              ret_val = false;
d4514 1
a4514 1
              ret_val = false;
d4540 1
a4540 1
              ret_val = false;
d4568 1
a4568 1
		ret_val = false;
d4598 1
a4598 1
		ret_val = false;
d4645 1
a4645 1
		    ret_val = false;
d4680 1
a4680 1
              ret_val = false;
d4756 1
a4756 1
              ret_val = false;
d4772 1
a4772 1
              ret_val = false;
d4779 1
a4779 1
              ret_val = false;
d4847 1
a4847 1
		  return false;
d4854 1
a4854 1
	      ret_val = false;
d4870 1
a4870 1
static boolean
d5053 1
a5053 1
  return true;
d5058 1
a5058 1
static boolean
d5145 1
a5145 1
  return true;
d5152 1
a5152 1
static boolean
d5209 1
a5209 1
	    return false;
d5248 1
a5248 1
		    return false;
d5293 1
a5293 1
		return false;
d5298 1
a5298 1
		return false;
d5324 1
a5324 1
						  name, false, false, true);
d5361 1
a5361 1
	  einfo.failed = false;
d5366 1
a5366 1
	    return false;
d5381 1
a5381 1
    return false;
d5403 1
a5403 1
	  return false;
d5413 1
a5413 1
	return false;
d5418 1
a5418 1
  return true;
@


1.85
log
@	* elf64-alpha.c (elf64_alpha_check_relocs): Only put maybe_dynamic
	relocs into shared lib non-allocated reloc sections.
@
text
@d69 1
a69 1
  PARAMS((bfd *, arelent *, Elf64_Internal_Rela *));
d76 1
a76 1
  PARAMS((bfd *, Elf64_Internal_Shdr *, const char *));
d78 1
a78 1
  PARAMS((flagword *, Elf64_Internal_Shdr *));
d80 1
a80 1
  PARAMS((bfd *, Elf64_Internal_Shdr *, asection *));
d1168 1
a1168 1
     Elf64_Internal_Rela *dst;
d2328 1
a2328 1
     Elf64_Internal_Shdr *hdr;
d2368 1
a2368 1
     Elf64_Internal_Shdr *hdr;
d2382 1
a2382 1
     Elf64_Internal_Shdr *hdr;
d4468 1
d4478 3
a4480 4
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
d4610 1
d4663 3
a4665 4
	    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				       ((Elf64_External_Rela *)
					srel->contents)
				       + srel->reloc_count++);
d4711 1
d4722 3
a4724 4
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
d4883 1
d4929 2
a4930 3
      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				 ((Elf64_External_Rela *)srel->contents
				  + plt_index));
d4966 3
a4968 4
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srel->contents)
					     + srel->reloc_count++);
d4983 1
d5027 3
a5029 3
	  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				     ((Elf64_External_Rela *)srel->contents
				      + srel->reloc_count++));
d5036 3
a5038 3
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				         ((Elf64_External_Rela *)srel->contents
				          + srel->reloc_count++));
d5507 4
a5510 4
  NULL,
  NULL,
  NULL,
  NULL
@


1.84
log
@        * Makefile.am (BFD64_BACKENDS): Remove elf64-alpha-fbsd.
        (BFD64_BACKENDS_CFILES): Likewise.
        * configure.in (bfd_elf64_alpha_freebsd_vec): Use elf64-alpha.
        * elf64-alpha-fbsd.c: Remove file, move code ...
        * elf64-alpha.c: ... here.
        * Makefile.in, configure: Rebuild.
@
text
@d3103 1
a3103 1
	  if (info->shared || maybe_dynamic)
@


1.83
log
@        * elf64-alpha.c (elf64_alpha_relocate_section) [BRSGP]: Increment
        VALUE, not ADDEND.
@
text
@a5512 1
#ifndef ELF_ARCH
a5517 1
#endif /* ELF_ARCH */
d5581 39
@


1.82
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d4580 1
a4580 1
		addend += 8;
@


1.81
log
@2002-09-22  H.J. Lu <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.
@
text
@d2483 1
d2499 1
a2499 1
  h = NULL;
d2503 1
a2503 2
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
d2505 1
d2543 1
a2543 1
  h = NULL;
d2547 1
a2547 2
	 false, get_elf_backend_data (abfd)->collect,
	 (struct bfd_link_hash_entry **) &h)))
d2549 1
@


1.81.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a2482 1
  struct bfd_link_hash_entry *bh;
d2498 1
a2498 1
  bh = NULL;
d2502 2
a2503 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a2504 1
  h = (struct elf_link_hash_entry *) bh;
d2542 1
a2542 1
  bh = NULL;
d2546 2
a2547 1
	 false, get_elf_backend_data (abfd)->collect, &bh)))
a2548 1
  h = (struct elf_link_hash_entry *) bh;
d3102 1
a3102 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
d4579 1
a4579 1
		value += 8;
d5512 1
d5518 1
a5581 39

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static void
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#define elf64_bed elf64_alpha_fbsd_bed
@


1.81.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d50 2
a51 2
static bfd_boolean alpha_elf_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d53 1
a53 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d55 1
a55 1
  PARAMS ((bfd *));
d58 1
a58 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 1
a60 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d62 1
a62 1
  PARAMS ((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
d64 1
a64 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d67 1
a67 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d69 1
a69 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d71 22
a92 22
static bfd_boolean elf64_alpha_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_object_p
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elf64_alpha_section_flags
  PARAMS ((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elf64_alpha_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static bfd_boolean elf64_alpha_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf64_alpha_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
static bfd_boolean elf64_alpha_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean elf64_alpha_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d98 2
a99 2
static bfd_boolean elf64_alpha_output_extsym
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
d101 2
a102 2
static bfd_boolean elf64_alpha_can_merge_gots
  PARAMS ((bfd *, bfd *));
d104 2
a105 2
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf64_alpha_calc_got_offsets_for_symbol
d107 2
a108 3
static void elf64_alpha_calc_got_offsets
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_got_sections
d110 1
a110 1
static bfd_boolean elf64_alpha_size_plt_section
d112 1
a112 1
static bfd_boolean elf64_alpha_size_plt_section_1
d114 1
a114 1
static bfd_boolean elf64_alpha_always_size_sections
d118 1
a118 1
static bfd_boolean elf64_alpha_calc_dynrel_sizes
d120 1
a120 1
static bfd_boolean elf64_alpha_size_rela_got_section
d122 1
a122 1
static bfd_boolean elf64_alpha_size_rela_got_1
d124 1
a124 1
static bfd_boolean elf64_alpha_add_symbol_hook
d130 2
a131 2
static bfd_boolean elf64_alpha_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
d133 9
a141 12
static bfd_boolean elf64_alpha_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf64_alpha_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void elf64_alpha_emit_dynrel
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *,
	   bfd_vma, long, long, bfd_vma));
static bfd_boolean elf64_alpha_relocate_section_r
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
d143 9
a151 9
static bfd_boolean elf64_alpha_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf64_alpha_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_merge_ind_symbols
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
a175 5
#define ALPHA_ELF_LINK_HASH_PLT_LOC	0x80

  /* Used to undo the localization of a plt symbol.  */
  asection *plt_old_section;
  bfd_vma plt_old_value;
d182 1
a182 1
    /* Which .got subsection?  */
d185 1
a185 1
    /* The addend in effect for this entry.  */
d188 1
a188 1
    /* The .got offset for this entry.  */
d207 1
a207 1
  /* Used to count non-got, non-plt relocations for delayed sizing
d213 1
a213 1
    /* Which .reloc section? */
d216 1
a216 1
    /* What kind of relocation? */
d219 1
a219 1
    /* Is this against read-only section? */
d222 1
a222 1
    /* How many did we find?  */
d250 1
a250 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d263 1
a263 4
/* Should we do dynamic things to this symbol?  This differs from the 
   generic version in that we never need to consider function pointer
   equality wrt PLT entries -- we don't create a PLT entry if a symbol's
   address is ever taken.  */
d265 1
a265 1
static inline bfd_boolean
d270 34
a303 1
  return _bfd_elf_dynamic_symbol_p (h, info, 0);
d402 1
a402 1
static bfd_boolean
d409 2
a410 2
    return FALSE;
  return TRUE;
d413 1
a413 1
static bfd_boolean
d417 9
d443 1
a443 1
	 TRUE,			/* pc_relative */
d448 1
a448 1
	 FALSE,			/* partial_inplace */
d451 1
a451 1
	 TRUE),			/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),		/* pcrel_offset */
d473 1
a473 1
	 FALSE,			/* pc_relative */
d478 1
a478 1
	 FALSE,			/* partial_inplace */
d481 1
a481 1
	 FALSE),		/* pcrel_offset */
d490 1
a490 1
	 FALSE,			/* pc_relative */
d495 1
a495 1
	 FALSE,			/* partial_inplace */
d498 1
a498 1
	 FALSE),		/* pcrel_offset */
d505 1
a505 1
	 FALSE,			/* pc_relative */
d510 1
a510 1
	 FALSE,			/* partial_inplace */
d513 1
a513 1
	 FALSE),		/* pcrel_offset */
d526 1
a526 1
	 FALSE,			/* pc_relative */
d531 1
a531 1
	 FALSE,			/* partial_inplace */
d534 1
a534 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 FALSE,			/* partial_inplace */
d564 1
a564 1
	 TRUE),			/* pcrel_offset */
d571 1
a571 1
	 TRUE,			/* pc_relative */
d576 1
a576 1
	 FALSE,			/* partial_inplace */
d579 1
a579 1
	 TRUE),			/* pcrel_offset */
d586 1
a586 1
	 TRUE,			/* pc_relative */
d591 1
a591 1
	 FALSE,			/* partial_inplace */
d594 1
a594 1
	 TRUE),			/* pcrel_offset */
d601 1
a601 1
	 TRUE,			/* pc_relative */
d606 1
a606 1
	 FALSE,			/* partial_inplace */
d609 1
a609 1
	 TRUE),			/* pcrel_offset */
d616 1
a616 1
	 TRUE,			/* pc_relative */
d621 1
a621 1
	 FALSE,			/* partial_inplace */
d624 1
a624 1
	 TRUE),			/* pcrel_offset */
d631 1
a631 1
	 TRUE,			/* pc_relative */
d636 1
a636 1
	 FALSE,			/* partial_inplace */
d639 1
a639 1
	 TRUE),			/* pcrel_offset */
d653 1
a653 1
	 FALSE,			/* pc_relative */
d658 1
a658 1
	 FALSE,			/* partial_inplace */
d661 1
a661 1
	 FALSE),		/* pcrel_offset */
d668 1
a668 1
	 FALSE,			/* pc_relative */
d673 1
a673 1
	 FALSE,			/* partial_inplace */
d676 1
a676 1
	 FALSE),		/* pcrel_offset */
d683 1
a683 1
	 FALSE,			/* pc_relative */
d688 1
a688 1
	 FALSE,			/* partial_inplace */
d691 1
a691 1
	 FALSE),		/* pcrel_offset */
d709 1
a709 1
	 FALSE,
d714 1
a714 1
	 FALSE,
d717 1
a717 1
	 TRUE),
d724 1
a724 1
	 FALSE,
d729 1
a729 1
	 FALSE,
d732 1
a732 1
	 TRUE),
d739 1
a739 1
	 FALSE,
d744 1
a744 1
	 FALSE,
d747 1
a747 1
	 TRUE),
d754 1
a754 1
	 FALSE,
d759 1
a759 1
	 FALSE,
d762 1
a762 1
	 TRUE),
d769 1
a769 1
	 TRUE,			/* pc_relative */
d774 1
a774 1
	 FALSE,			/* partial_inplace */
d777 1
a777 1
	 TRUE),			/* pcrel_offset */
d784 1
a784 1
	 FALSE,			/* pc_relative */
d789 1
a789 1
	 FALSE,			/* partial_inplace */
d792 1
a792 1
	 FALSE),		/* pcrel_offset */
d799 1
a799 1
	 FALSE,			/* pc_relative */
d804 1
a804 1
	 FALSE,			/* partial_inplace */
d807 1
a807 1
	 FALSE),		/* pcrel_offset */
d814 1
a814 1
	 FALSE,			/* pc_relative */
d819 1
a819 1
	 FALSE,			/* partial_inplace */
d822 1
a822 1
	 FALSE),		/* pcrel_offset */
d830 1
a830 1
	 FALSE,			/* pc_relative */
d835 1
a835 1
	 FALSE,			/* partial_inplace */
d838 1
a838 1
	 FALSE),		/* pcrel_offset */
d845 1
a845 1
	 FALSE,			/* pc_relative */
d850 1
a850 1
	 FALSE,			/* partial_inplace */
d853 1
a853 1
	 FALSE),		/* pcrel_offset */
d860 1
a860 1
	 FALSE,			/* pc_relative */
d865 1
a865 1
	 FALSE,			/* partial_inplace */
d868 1
a868 1
	 FALSE),		/* pcrel_offset */
d875 1
a875 1
	 FALSE,			/* pc_relative */
d880 1
a880 1
	 FALSE,			/* partial_inplace */
d883 1
a883 1
	 FALSE),		/* pcrel_offset */
d890 1
a890 1
	 FALSE,			/* pc_relative */
d895 1
a895 1
	 FALSE,			/* partial_inplace */
d898 1
a898 1
	 FALSE),		/* pcrel_offset */
d906 1
a906 1
	 FALSE,			/* pc_relative */
d911 1
a911 1
	 FALSE,			/* partial_inplace */
d914 1
a914 1
	 FALSE),		/* pcrel_offset */
d921 1
a921 1
	 FALSE,			/* pc_relative */
d926 1
a926 1
	 FALSE,			/* partial_inplace */
d929 1
a929 1
	 FALSE),		/* pcrel_offset */
d936 1
a936 1
	 FALSE,			/* pc_relative */
d941 1
a941 1
	 FALSE,			/* partial_inplace */
d944 1
a944 1
	 FALSE),		/* pcrel_offset */
d951 1
a951 1
	 FALSE,			/* pc_relative */
d956 1
a956 1
	 FALSE,			/* partial_inplace */
d959 1
a959 1
	 FALSE),		/* pcrel_offset */
d966 1
a966 1
	 FALSE,			/* pc_relative */
d971 1
a971 1
	 FALSE,			/* partial_inplace */
d974 1
a974 1
	 FALSE),		/* pcrel_offset */
d1168 1
a1168 1
     Elf_Internal_Rela *dst;
d1182 2
a1183 2
#define alpha_get_dtprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma)
d1187 2
a1188 4
#define alpha_get_tprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma					\
   - align_power ((bfd_vma) 16,						\
		  elf_hash_table (info)->tls_sec->alignment_power))
d1222 1
d1229 2
a1230 2
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
d1234 1
a1234 1
static bfd_boolean elf64_alpha_relax_with_lituse
d1239 1
a1239 1
static bfd_boolean elf64_alpha_relax_got_load
d1242 1
a1242 1
static bfd_boolean elf64_alpha_relax_gprelhilo
d1244 2
a1245 2
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_tls_get_addr
d1247 4
a1250 2
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_section
d1252 1
a1252 1
	  bfd_boolean *again));
d1270 1
a1270 1
static bfd_boolean
d1279 4
a1282 4
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
d1292 1
a1292 1
      return TRUE;
d1297 1
a1297 1
    return TRUE;
d1325 1
a1325 1
	  all_optimized = FALSE;
d1351 1
a1351 1
	      info->changed_relocs = TRUE;
d1355 1
a1355 1
	      info->changed_contents = TRUE;
d1368 2
a1369 2
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;
d1374 1
a1374 1
	      info->changed_relocs = TRUE;
d1377 1
a1377 1
	    all_optimized = FALSE;
d1391 1
a1391 1
	  info->changed_relocs = TRUE;
d1395 1
a1395 1
	  info->changed_contents = TRUE;
d1429 1
a1429 1
		  all_optimized = FALSE;
d1441 2
a1442 2
		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
d1445 1
a1445 1
	      all_optimized = FALSE;
d1473 2
a1474 2
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
d1502 1
a1502 1
	  info->changed_relocs = TRUE;
d1506 1
a1506 1
	  info->changed_contents = TRUE;
d1510 1
a1510 1
  return TRUE;
d1548 1
a1548 1
	  tsec_relocs = (_bfd_elf_link_read_relocs
d1585 1
a1585 1
static bfd_boolean
d1605 1
a1605 1
      return TRUE;
d1610 1
a1610 1
    return TRUE;
d1614 1
a1614 1
    return TRUE;
d1622 3
a1624 3
      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
d1629 1
a1629 1
    return TRUE;
d1638 1
a1638 11
  info->changed_contents = TRUE;

  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }
a1639 1
  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
d1653 1
a1653 1
      return FALSE;
d1657 11
a1667 1
  info->changed_relocs = TRUE;
d1682 1
a1682 1
  return TRUE;
d1685 1
a1685 1
static bfd_boolean
d1690 1
a1690 1
     bfd_boolean hi;
d1706 1
a1706 1
  return TRUE;
d1710 1
a1710 1
    return TRUE;
d1717 1
a1717 1
      info->changed_contents = TRUE;
d1721 1
a1721 1
      info->changed_relocs = TRUE;
d1730 1
a1730 1
      info->changed_contents = TRUE;
d1734 1
a1734 1
      info->changed_relocs = TRUE;
d1737 1
a1737 1
  return TRUE;
d1740 1
a1740 1
static bfd_boolean
d1745 1
a1745 1
     bfd_boolean is_gd;
d1750 1
a1750 2
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
  unsigned long new_symndx;
d1754 5
d1772 1
a1772 1
    return TRUE;
d1777 1
a1777 1
    return TRUE;
d1781 1
a1781 1
    return TRUE;
d1788 1
a1788 1
    return TRUE;
a1794 1
  pos1_unusable = FALSE;
d1796 2
a1797 4
  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
d1803 2
a1804 4
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
    return TRUE;
d1858 1
a1858 2
  use_gottprel = FALSE;
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
d1866 2
a1867 2
	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
d1877 2
a1878 1
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
d1883 1
a1883 2
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && !pos1_unusable)
d1891 2
a1892 1
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
d1894 2
a1895 1
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
d1902 1
a1902 1
      use_gottprel = TRUE;
d1909 2
a1910 1
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
d1930 2
a1931 2
  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;
d1965 1
a1965 1
		return FALSE;
d1982 1
a1982 1
  return TRUE;
d1985 48
a2032 1
static bfd_boolean
d2037 1
a2037 1
     bfd_boolean *again;
d2045 1
d2048 1
a2048 1
  *again = FALSE;
d2050 1
a2050 1
  if (link_info->relocatable
d2053 1
a2053 1
    return TRUE;
d2064 1
a2064 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2068 1
a2068 1
    return FALSE;
d2103 5
a2112 1
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);
a2122 2
	  break;

a2123 3
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
a2124 1

d2130 1
a2130 1
      if (r_symndx < symtab_hdr->sh_info)
d2147 7
a2153 9
	  isym = isymbuf + r_symndx;

	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.link_info);
	    }
d2155 1
a2155 11
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }
d2159 2
a2160 7
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
d2167 1
a2167 1
	  indx = r_symndx - symtab_hdr->sh_info;
d2183 1
a2183 13
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }
d2186 1
d2189 1
d2249 1
a2249 1
    return FALSE;
d2251 1
a2251 1
    return FALSE;
d2253 1
a2253 1
    return FALSE;
d2289 1
a2289 1
  return TRUE;
d2301 1
a2301 1
  return FALSE;
d2325 1
a2325 1
static bfd_boolean
d2328 1
a2328 1
     Elf_Internal_Shdr *hdr;
d2342 1
a2342 1
	return FALSE;
d2345 1
a2345 1
      return FALSE;
d2349 1
a2349 1
    return FALSE;
d2357 1
a2357 1
	return FALSE;
d2360 1
a2360 1
  return TRUE;
d2365 1
a2365 1
static bfd_boolean
d2368 1
a2368 1
     Elf_Internal_Shdr *hdr;
d2373 1
a2373 1
  return TRUE;
d2379 1
a2379 1
static bfd_boolean
d2382 1
a2382 1
     Elf_Internal_Shdr *hdr;
d2406 1
a2406 1
  return TRUE;
d2412 1
a2412 1
static bfd_boolean
d2423 1
a2423 1
      && !info->relocatable
d2438 1
a2438 1
	    return FALSE;
d2445 1
a2445 1
  return TRUE;
d2450 1
a2450 1
static bfd_boolean
d2457 2
a2458 7
  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
    }
d2467 1
a2467 1
    return FALSE;
d2471 1
a2471 1
  return TRUE;
d2476 1
a2476 1
static bfd_boolean
d2495 1
a2495 1
    return FALSE;
d2502 1
a2502 1
	  (bfd_vma) 0, (const char *) NULL, FALSE,
d2504 1
a2504 1
    return FALSE;
d2511 1
a2511 1
    return FALSE;
d2521 1
a2521 1
    return FALSE;
d2527 1
a2527 1
    return FALSE;
d2537 1
a2537 1
    return FALSE;
d2547 2
a2548 2
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
d2555 1
a2555 1
    return FALSE;
d2559 1
a2559 1
  return TRUE;
d2565 1
a2565 1
static bfd_boolean
d2622 1
a2622 1
  return TRUE;
d2649 1
a2649 1
  return FALSE;
d2654 1
a2654 1
static bfd_boolean
d2673 1
a2673 1
static bfd_boolean
d2690 1
a2690 1
    return TRUE;
d2720 1
a2720 1
	      return FALSE;
d2726 1
a2726 1
	      return FALSE;
d2735 1
a2735 1
	      return FALSE;
d2760 1
a2760 1
	  return TRUE;
d2781 1
a2781 1
  bfd_boolean failed;
d2784 1
a2784 1
static bfd_boolean
d2790 1
a2790 1
  bfd_boolean strip;
d2797 1
a2797 1
    strip = FALSE;
d2802 1
a2802 1
    strip = TRUE;
d2807 2
a2808 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d2810 1
a2810 1
    strip = FALSE;
d2813 1
a2813 1
    return TRUE;
d2911 2
a2912 2
      einfo->failed = TRUE;
      return FALSE;
d2915 1
a2915 1
  return TRUE;
d2999 1
a2999 1
static bfd_boolean
d3012 1
a3012 1
  bfd_boolean got_created;
d3015 2
a3016 2
  if (info->relocatable)
    return TRUE;
d3026 1
a3026 1
  got_created = FALSE;
d3040 1
a3040 1
      bfd_boolean maybe_dynamic;
d3062 1
a3062 1
      maybe_dynamic = FALSE;
d3064 1
a3064 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
d3067 1
a3067 1
        maybe_dynamic = TRUE;
d3107 1
a3108 8
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
d3133 1
a3133 1
		return FALSE;
d3151 1
a3151 1
	    return FALSE;
d3179 1
a3179 1
		return FALSE;
d3205 1
a3205 1
		    return FALSE;
d3228 1
a3228 1
		    return FALSE;
d3254 1
a3254 1
  return TRUE;
d3263 1
a3263 1
static bfd_boolean
d3294 1
a3294 1
	return FALSE;
a3309 3
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
d3319 1
a3319 1
      return TRUE;
d3333 1
a3333 1
      return TRUE;
d3341 1
a3341 1
  return TRUE;
d3348 1
a3348 1
static bfd_boolean
d3356 1
a3356 1
    return TRUE;
d3419 1
a3419 1
  return TRUE;
d3424 1
a3424 1
static bfd_boolean
d3433 1
a3433 1
    return TRUE;
d3437 1
a3437 1
    return FALSE;
d3474 1
a3474 1
	        return FALSE;
d3480 1
a3480 1
  return TRUE;
d3580 1
a3580 1
static bfd_boolean
d3600 1
a3600 1
  return TRUE;
d3650 1
a3650 1
static bfd_boolean
d3669 1
a3669 1
	  /* We are assuming no merging has yet occurred.  */
d3679 1
a3679 1
	      return FALSE;
d3691 1
a3691 1
	return TRUE;
d3722 1
a3722 1
  return TRUE;
d3728 1
a3728 1
static bfd_boolean
d3739 1
a3739 1
    return TRUE;
d3757 1
a3757 1
  return TRUE;
d3760 1
a3760 1
static bfd_boolean
d3770 1
a3770 1
    return TRUE;
a3790 8

      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
d3793 1
a3793 1
  return TRUE;
d3796 1
a3796 1
static bfd_boolean
d3803 2
a3804 2
  if (info->relocatable)
    return TRUE;
d3812 1
a3812 1
    return FALSE;
d3823 1
a3823 1
	    return FALSE;
d3827 1
a3827 1
  return TRUE;
a3843 1
    case R_ALPHA_GOTTPREL:
d3846 1
d3852 2
d3855 1
a3855 1
      return dynamic || shared;
d3866 1
a3866 1
static bfd_boolean
d3871 1
a3871 1
  bfd_boolean dynamic;
d3914 1
a3914 1
  return TRUE;
d3919 1
a3919 1
static bfd_boolean
d3959 1
a3959 1
      return TRUE;
d3969 1
a3969 1
  return TRUE;
d3975 1
a3975 1
static bfd_boolean
d3980 1
a3980 1
  bfd_boolean dynamic;
d4012 1
a4012 1
  return TRUE;
d4017 1
a4017 1
static bfd_boolean
d4024 1
a4024 1
  bfd_boolean relplt;
d4032 1
a4032 1
      if (info->executable)
d4054 1
a4054 1
  relplt = FALSE;
d4058 1
a4058 1
      bfd_boolean strip;
d4075 1
a4075 1
      strip = FALSE;
d4084 1
a4084 1
		relplt = TRUE;
d4104 1
a4104 1
	    return FALSE;
d4118 1
a4118 1
      if (info->executable)
d4121 1
a4121 1
	    return FALSE;
d4130 1
a4130 1
	    return FALSE;
d4136 1
a4136 1
	return FALSE;
d4141 1
a4141 1
	    return FALSE;
d4146 1
a4146 33
  return TRUE;
}

/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)
   into the next available slot in SREL.  */

static void
elf64_alpha_emit_dynrel (abfd, info, sec, srel, offset, dynindx, rtype, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec, *srel;
     bfd_vma offset, addend;
     long dynindx, rtype;
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (srel != NULL);

  outrel.r_info = ELF64_R_INFO (dynindx, rtype);
  outrel.r_addend = addend;

  offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if ((offset | 1) != (bfd_vma) -1)
    outrel.r_offset = sec->output_section->vma + sec->output_offset + offset;
  else
    memset (&outrel, 0, sizeof (outrel));

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
d4155 1
a4155 1
static bfd_boolean
d4170 1
a4170 1
  bfd_boolean ret_val = TRUE;
d4189 1
a4189 1
	  ret_val = FALSE;
d4216 1
a4216 1
static bfd_boolean
d4231 1
d4236 1
a4236 1
  bfd_boolean ret_val;
d4240 1
a4240 1
  if (info->relocatable)
d4247 1
a4247 1
  ret_val = TRUE;
d4285 2
a4286 1
  if (elf_hash_table (info)->tls_sec != NULL)
d4288 2
a4289 2
      dtp_base = alpha_get_dtprel_base (info);
      tp_base = alpha_get_tprel_base (info);
d4306 2
a4307 2
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref = FALSE;
d4317 1
a4317 1
	  ret_val = FALSE;
a4323 5
      /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	 reloc to the 0 symbol so that they all match.  */
      if (r_type == R_ALPHA_TLSLDM)
	r_symndx = 0;

a4325 1
	  asection *msec;
d4328 1
a4328 14
	  msec = sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);

	  /* If this is a tp-relative relocation against sym 0,
	     this is hackery from relax_section.  Force the value to
	     be the tls base.  */
	  if (r_symndx == 0
	      && (r_type == R_ALPHA_TLSLDM
		  || r_type == R_ALPHA_GOTTPREL
		  || r_type == R_ALPHA_TPREL64
		  || r_type == R_ALPHA_TPRELHI
		  || r_type == R_ALPHA_TPRELLO
		  || r_type == R_ALPHA_TPREL16))
	    value = tp_base;
d4339 2
a4340 1
	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
d4345 1
d4367 1
a4367 1
	  dynamic_symbol_p = FALSE;
d4371 1
a4371 9
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry *hh;
	  
	  RELOC_FOR_GLOBAL_SYMBOL (hh,
				   (struct elf_link_hash_entry *) alpha_elf_sym_hashes (input_bfd),
				   r_symndx, symtab_hdr, value,
				   sec, unresolved_reloc, info,
				   warned);
d4373 3
a4375 2
	  if (warned)
	    continue;
d4377 37
a4413 4
	  if (value == 0
	      && ! unresolved_reloc
	      && hh->root.type == bfd_link_hash_undefweak)
	    undef_weak_ref = TRUE;
a4414 1
	  h = (struct alpha_elf_link_hash_entry *) hh;
d4466 19
a4484 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, value);
d4493 1
a4494 13
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

	case R_ALPHA_GPREL16:
d4501 1
a4501 1
              ret_val = FALSE;
d4513 1
a4513 1
              ret_val = FALSE;
d4539 1
a4539 1
              ret_val = FALSE;
d4567 1
a4567 1
		ret_val = FALSE;
d4597 1
a4597 1
		ret_val = FALSE;
d4609 1
a4609 2
	    long dynindx, dyntype = r_type;
	    bfd_vma dynaddend;
d4617 2
a4618 2
		dynindx = h->root.dynindx;
		dynaddend = addend;
d4623 1
a4623 1
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4629 3
a4631 8
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		if (!info->shared)
		  {
		    value -= tp_base;
		    goto default_reloc;
		  }
		dynindx = 0;
		dynaddend = value - dtp_base;
d4643 1
a4643 1
		    ret_val = FALSE;
d4645 2
a4646 3
		dynindx = 0;
		dyntype = R_ALPHA_RELATIVE;
		dynaddend = value;
d4651 17
a4667 3
	    elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				     srel, rel->r_offset, dynindx,
				     dyntype, dynaddend);
d4679 1
a4679 1
              ret_val = FALSE;
d4709 20
a4728 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_DTPMOD64, 0);
d4734 1
a4734 1
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4755 1
a4755 1
              ret_val = FALSE;
d4757 1
a4757 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4771 1
a4771 1
              ret_val = FALSE;
d4778 1
a4778 1
              ret_val = FALSE;
d4780 1
a4780 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4801 2
a4802 13
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		  if (r_type == R_ALPHA_GOTDTPREL)
		    value -= dtp_base;
		  else if (!info->shared)
		    value -= tp_base;
		  else
		    {
		      elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					       gotent->got_offset, 0,
					       R_ALPHA_TPREL64,
					       value - dtp_base);
		      value = 0;
		    }
d4846 1
a4846 1
		  return FALSE;
d4853 1
a4853 1
	      ret_val = FALSE;
d4869 1
a4869 1
static bfd_boolean
a4882 1
      bfd_byte *loc;
d4928 3
a4930 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4959 14
a4972 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, plt_addr);
d4983 1
d4994 1
a4994 1
	  long r_type;
d5000 3
d5024 6
a5029 3
	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				   gotent->got_offset, h->dynindx,
				   r_type, gotent->addend);
d5032 11
a5042 3
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				     gotent->got_offset + 8, h->dynindx,
				     R_ALPHA_DTPREL64, gotent->addend);
d5052 1
a5052 1
  return TRUE;
d5057 1
a5057 1
static bfd_boolean
d5127 1
a5127 1
      /* Initialize the PLT0 entry.  */
d5139 2
a5140 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 0;
d5144 1
a5144 1
  return TRUE;
d5151 1
a5151 1
static bfd_boolean
d5208 1
a5208 1
	    return FALSE;
d5247 1
a5247 1
		    return FALSE;
d5292 1
a5292 1
		return FALSE;
d5297 1
a5297 1
		return FALSE;
d5323 1
a5323 1
						  name, FALSE, FALSE, TRUE);
d5360 1
a5360 1
	  einfo.failed = FALSE;
d5365 1
a5365 1
	    return FALSE;
d5380 1
a5380 1
    return FALSE;
d5402 1
a5402 1
	  return FALSE;
d5412 1
a5412 1
	return FALSE;
d5417 1
a5417 1
  return TRUE;
a5436 7
static struct bfd_elf_special_section const elf64_alpha_special_sections[]=
{
  { ".sdata", 6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,     0,  0, 0,            0 }
};

d5496 1
a5496 1
  64, 3,
d5507 4
a5510 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
a5574 3
#define elf_backend_special_sections \
  elf64_alpha_special_sections

d5580 1
a5618 1
#undef  elf64_bed
@


1.80
log
@	* elf64-alpha.c (alpha_elf_size_info): Make static.
@
text
@d3406 1
a3406 1
	    if (ri->rtype == rs->rtype)
@


1.80.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d3406 1
a3406 1
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
@


1.80.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a2482 1
  struct bfd_link_hash_entry *bh;
d2498 1
a2498 1
  bh = NULL;
d2502 2
a2503 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a2504 1
  h = (struct elf_link_hash_entry *) bh;
d2542 1
a2542 1
  bh = NULL;
d2546 2
a2547 1
	 false, get_elf_backend_data (abfd)->collect, &bh)))
a2548 1
  h = (struct elf_link_hash_entry *) bh;
@


1.80.2.3
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d3103 1
a3103 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
d4580 1
a4580 1
		value += 8;
d5513 1
d5519 1
a5582 39

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static void
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#define elf64_bed elf64_alpha_fbsd_bed
@


1.80.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d69 1
a69 1
  PARAMS((bfd *, arelent *, Elf_Internal_Rela *));
d71 1
a71 1
static bfd_boolean elf64_alpha_mkobject
d73 1
a73 1
static bfd_boolean elf64_alpha_object_p
d75 7
a81 7
static bfd_boolean elf64_alpha_section_from_shdr
  PARAMS((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elf64_alpha_section_flags
  PARAMS((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elf64_alpha_fake_sections
  PARAMS((bfd *, Elf_Internal_Shdr *, asection *));
static bfd_boolean elf64_alpha_create_got_section
d83 1
a83 1
static bfd_boolean elf64_alpha_create_dynamic_sections
d86 1
a86 1
static bfd_boolean elf64_alpha_read_ecoff_info
d88 1
a88 1
static bfd_boolean elf64_alpha_is_local_label_name
d90 1
a90 1
static bfd_boolean elf64_alpha_find_nearest_line
d98 1
a98 1
static bfd_boolean elf64_alpha_output_extsym
d101 1
a101 1
static bfd_boolean elf64_alpha_can_merge_gots
d105 1
a105 1
static bfd_boolean elf64_alpha_calc_got_offsets_for_symbol
d107 2
a108 1
static void elf64_alpha_calc_got_offsets
d110 1
a110 1
static bfd_boolean elf64_alpha_size_got_sections
d112 1
a112 3
static bfd_boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section_1
d114 1
a114 1
static bfd_boolean elf64_alpha_always_size_sections
d118 1
a118 1
static bfd_boolean elf64_alpha_calc_dynrel_sizes
d120 1
a120 1
static bfd_boolean elf64_alpha_size_rela_got_section
d122 1
a122 1
static bfd_boolean elf64_alpha_size_rela_got_1
d124 1
a124 1
static bfd_boolean elf64_alpha_add_symbol_hook
d130 1
a130 1
static bfd_boolean elf64_alpha_check_relocs
d133 1
a133 1
static bfd_boolean elf64_alpha_adjust_dynamic_symbol
d135 1
a135 1
static bfd_boolean elf64_alpha_size_dynamic_sections
d137 1
a137 1
static bfd_boolean elf64_alpha_relocate_section_r
d140 1
a140 1
static bfd_boolean elf64_alpha_relocate_section
d143 1
a143 1
static bfd_boolean elf64_alpha_finish_dynamic_symbol
d146 1
a146 1
static bfd_boolean elf64_alpha_finish_dynamic_sections
d148 1
a148 1
static bfd_boolean elf64_alpha_final_link
d150 1
a150 1
static bfd_boolean elf64_alpha_merge_ind_symbols
d250 1
a250 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d271 1
a271 1
    return FALSE;
d278 1
a278 1
    return FALSE;
d282 1
a282 1
    return TRUE;
d290 1
a290 1
      return FALSE;
d293 1
a293 1
        return FALSE;
d301 1
a301 1
    return TRUE;
d303 1
a303 1
  return FALSE;
d402 1
a402 1
static bfd_boolean
d409 2
a410 2
    return FALSE;
  return TRUE;
d413 1
a413 1
static bfd_boolean
d422 1
a422 1
    return FALSE;
d443 1
a443 1
	 TRUE,			/* pc_relative */
d448 1
a448 1
	 FALSE,			/* partial_inplace */
d451 1
a451 1
	 TRUE),			/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),		/* pcrel_offset */
d473 1
a473 1
	 FALSE,			/* pc_relative */
d478 1
a478 1
	 FALSE,			/* partial_inplace */
d481 1
a481 1
	 FALSE),		/* pcrel_offset */
d490 1
a490 1
	 FALSE,			/* pc_relative */
d495 1
a495 1
	 FALSE,			/* partial_inplace */
d498 1
a498 1
	 FALSE),		/* pcrel_offset */
d505 1
a505 1
	 FALSE,			/* pc_relative */
d510 1
a510 1
	 FALSE,			/* partial_inplace */
d513 1
a513 1
	 FALSE),		/* pcrel_offset */
d526 1
a526 1
	 FALSE,			/* pc_relative */
d531 1
a531 1
	 FALSE,			/* partial_inplace */
d534 1
a534 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 FALSE,			/* partial_inplace */
d564 1
a564 1
	 TRUE),			/* pcrel_offset */
d571 1
a571 1
	 TRUE,			/* pc_relative */
d576 1
a576 1
	 FALSE,			/* partial_inplace */
d579 1
a579 1
	 TRUE),			/* pcrel_offset */
d586 1
a586 1
	 TRUE,			/* pc_relative */
d591 1
a591 1
	 FALSE,			/* partial_inplace */
d594 1
a594 1
	 TRUE),			/* pcrel_offset */
d601 1
a601 1
	 TRUE,			/* pc_relative */
d606 1
a606 1
	 FALSE,			/* partial_inplace */
d609 1
a609 1
	 TRUE),			/* pcrel_offset */
d616 1
a616 1
	 TRUE,			/* pc_relative */
d621 1
a621 1
	 FALSE,			/* partial_inplace */
d624 1
a624 1
	 TRUE),			/* pcrel_offset */
d631 1
a631 1
	 TRUE,			/* pc_relative */
d636 1
a636 1
	 FALSE,			/* partial_inplace */
d639 1
a639 1
	 TRUE),			/* pcrel_offset */
d653 1
a653 1
	 FALSE,			/* pc_relative */
d658 1
a658 1
	 FALSE,			/* partial_inplace */
d661 1
a661 1
	 FALSE),		/* pcrel_offset */
d668 1
a668 1
	 FALSE,			/* pc_relative */
d673 1
a673 1
	 FALSE,			/* partial_inplace */
d676 1
a676 1
	 FALSE),		/* pcrel_offset */
d683 1
a683 1
	 FALSE,			/* pc_relative */
d688 1
a688 1
	 FALSE,			/* partial_inplace */
d691 1
a691 1
	 FALSE),		/* pcrel_offset */
d709 1
a709 1
	 FALSE,
d714 1
a714 1
	 FALSE,
d717 1
a717 1
	 TRUE),
d724 1
a724 1
	 FALSE,
d729 1
a729 1
	 FALSE,
d732 1
a732 1
	 TRUE),
d739 1
a739 1
	 FALSE,
d744 1
a744 1
	 FALSE,
d747 1
a747 1
	 TRUE),
d754 1
a754 1
	 FALSE,
d759 1
a759 1
	 FALSE,
d762 1
a762 1
	 TRUE),
d769 1
a769 1
	 TRUE,			/* pc_relative */
d774 1
a774 1
	 FALSE,			/* partial_inplace */
d777 1
a777 1
	 TRUE),			/* pcrel_offset */
d784 1
a784 1
	 FALSE,			/* pc_relative */
d789 1
a789 1
	 FALSE,			/* partial_inplace */
d792 1
a792 1
	 FALSE),		/* pcrel_offset */
d799 1
a799 1
	 FALSE,			/* pc_relative */
d804 1
a804 1
	 FALSE,			/* partial_inplace */
d807 1
a807 1
	 FALSE),		/* pcrel_offset */
d814 1
a814 1
	 FALSE,			/* pc_relative */
d819 1
a819 1
	 FALSE,			/* partial_inplace */
d822 1
a822 1
	 FALSE),		/* pcrel_offset */
d830 1
a830 1
	 FALSE,			/* pc_relative */
d835 1
a835 1
	 FALSE,			/* partial_inplace */
d838 1
a838 1
	 FALSE),		/* pcrel_offset */
d845 1
a845 1
	 FALSE,			/* pc_relative */
d850 1
a850 1
	 FALSE,			/* partial_inplace */
d853 1
a853 1
	 FALSE),		/* pcrel_offset */
d860 1
a860 1
	 FALSE,			/* pc_relative */
d865 1
a865 1
	 FALSE,			/* partial_inplace */
d868 1
a868 1
	 FALSE),		/* pcrel_offset */
d875 1
a875 1
	 FALSE,			/* pc_relative */
d880 1
a880 1
	 FALSE,			/* partial_inplace */
d883 1
a883 1
	 FALSE),		/* pcrel_offset */
d890 1
a890 1
	 FALSE,			/* pc_relative */
d895 1
a895 1
	 FALSE,			/* partial_inplace */
d898 1
a898 1
	 FALSE),		/* pcrel_offset */
d906 1
a906 1
	 FALSE,			/* pc_relative */
d911 1
a911 1
	 FALSE,			/* partial_inplace */
d914 1
a914 1
	 FALSE),		/* pcrel_offset */
d921 1
a921 1
	 FALSE,			/* pc_relative */
d926 1
a926 1
	 FALSE,			/* partial_inplace */
d929 1
a929 1
	 FALSE),		/* pcrel_offset */
d936 1
a936 1
	 FALSE,			/* pc_relative */
d941 1
a941 1
	 FALSE,			/* partial_inplace */
d944 1
a944 1
	 FALSE),		/* pcrel_offset */
d951 1
a951 1
	 FALSE,			/* pc_relative */
d956 1
a956 1
	 FALSE,			/* partial_inplace */
d959 1
a959 1
	 FALSE),		/* pcrel_offset */
d966 1
a966 1
	 FALSE,			/* pc_relative */
d971 1
a971 1
	 FALSE,			/* partial_inplace */
d974 1
a974 1
	 FALSE),		/* pcrel_offset */
d1168 1
a1168 1
     Elf_Internal_Rela *dst;
d1229 2
a1230 2
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
d1234 1
a1234 1
static bfd_boolean elf64_alpha_relax_with_lituse
d1239 1
a1239 1
static bfd_boolean elf64_alpha_relax_got_load
d1242 1
a1242 1
static bfd_boolean elf64_alpha_relax_gprelhilo
d1244 2
a1245 2
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_tls_get_addr
d1247 1
a1247 1
          Elf_Internal_Rela *irel, bfd_boolean));
d1250 1
a1250 1
static bfd_boolean elf64_alpha_relax_section
d1252 1
a1252 1
	  bfd_boolean *again));
d1270 1
a1270 1
static bfd_boolean
d1279 4
a1282 4
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
d1292 1
a1292 1
      return TRUE;
d1297 1
a1297 1
    return TRUE;
d1325 1
a1325 1
	  all_optimized = FALSE;
d1351 1
a1351 1
	      info->changed_relocs = TRUE;
d1355 1
a1355 1
	      info->changed_contents = TRUE;
d1368 2
a1369 2
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;
d1374 1
a1374 1
	      info->changed_relocs = TRUE;
d1377 1
a1377 1
	    all_optimized = FALSE;
d1391 1
a1391 1
	  info->changed_relocs = TRUE;
d1395 1
a1395 1
	  info->changed_contents = TRUE;
d1429 1
a1429 1
		  all_optimized = FALSE;
d1441 2
a1442 2
		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
d1445 1
a1445 1
	      all_optimized = FALSE;
d1473 2
a1474 2
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
d1502 1
a1502 1
	  info->changed_relocs = TRUE;
d1506 1
a1506 1
	  info->changed_contents = TRUE;
d1510 1
a1510 1
  return TRUE;
d1585 1
a1585 1
static bfd_boolean
d1605 1
a1605 1
      return TRUE;
d1610 1
a1610 1
    return TRUE;
d1614 1
a1614 1
    return TRUE;
d1629 1
a1629 1
    return TRUE;
d1638 1
a1638 1
  info->changed_contents = TRUE;
d1653 1
a1653 1
      return FALSE;
d1657 1
a1657 1
  info->changed_relocs = TRUE;
d1682 1
a1682 1
  return TRUE;
d1685 1
a1685 1
static bfd_boolean
d1690 1
a1690 1
     bfd_boolean hi;
d1706 1
a1706 1
  return TRUE;
d1710 1
a1710 1
    return TRUE;
d1717 1
a1717 1
      info->changed_contents = TRUE;
d1721 1
a1721 1
      info->changed_relocs = TRUE;
d1730 1
a1730 1
      info->changed_contents = TRUE;
d1734 1
a1734 1
      info->changed_relocs = TRUE;
d1737 1
a1737 1
  return TRUE;
d1740 1
a1740 1
static bfd_boolean
d1745 1
a1745 1
     bfd_boolean is_gd;
d1750 1
a1750 1
  bfd_boolean dynamic, use_gottprel;
d1757 1
a1757 1
    return TRUE;
d1772 1
a1772 1
    return TRUE;
d1777 1
a1777 1
    return TRUE;
d1781 1
a1781 1
    return TRUE;
d1788 1
a1788 1
    return TRUE;
d1804 1
a1804 1
    return TRUE;
d1858 1
a1858 1
  use_gottprel = FALSE;
d1902 1
a1902 1
      use_gottprel = TRUE;
d1930 2
a1931 2
  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;
d1965 1
a1965 1
		return FALSE;
d1982 1
a1982 1
  return TRUE;
d2032 1
a2032 1
static bfd_boolean
d2037 1
a2037 1
     bfd_boolean *again;
d2048 1
a2048 1
  *again = FALSE;
d2053 1
a2053 1
    return TRUE;
d2068 1
a2068 1
    return FALSE;
d2249 1
a2249 1
    return FALSE;
d2251 1
a2251 1
    return FALSE;
d2253 1
a2253 1
    return FALSE;
d2289 1
a2289 1
  return TRUE;
d2301 1
a2301 1
  return FALSE;
d2325 1
a2325 1
static bfd_boolean
d2328 1
a2328 1
     Elf_Internal_Shdr *hdr;
d2342 1
a2342 1
	return FALSE;
d2345 1
a2345 1
      return FALSE;
d2349 1
a2349 1
    return FALSE;
d2357 1
a2357 1
	return FALSE;
d2360 1
a2360 1
  return TRUE;
d2365 1
a2365 1
static bfd_boolean
d2368 1
a2368 1
     Elf_Internal_Shdr *hdr;
d2373 1
a2373 1
  return TRUE;
d2379 1
a2379 1
static bfd_boolean
d2382 1
a2382 1
     Elf_Internal_Shdr *hdr;
d2406 1
a2406 1
  return TRUE;
d2412 1
a2412 1
static bfd_boolean
d2438 1
a2438 1
	    return FALSE;
d2445 1
a2445 1
  return TRUE;
d2450 1
a2450 1
static bfd_boolean
d2458 1
a2458 1
    return TRUE;
d2467 1
a2467 1
    return FALSE;
d2471 1
a2471 1
  return TRUE;
d2476 1
a2476 1
static bfd_boolean
d2495 1
a2495 1
    return FALSE;
d2502 1
a2502 1
	  (bfd_vma) 0, (const char *) NULL, FALSE,
d2504 1
a2504 1
    return FALSE;
d2511 1
a2511 1
    return FALSE;
d2521 1
a2521 1
    return FALSE;
d2527 1
a2527 1
    return FALSE;
d2537 1
a2537 1
    return FALSE;
d2547 2
a2548 2
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
d2555 1
a2555 1
    return FALSE;
d2559 1
a2559 1
  return TRUE;
d2565 1
a2565 1
static bfd_boolean
d2622 1
a2622 1
  return TRUE;
d2649 1
a2649 1
  return FALSE;
d2654 1
a2654 1
static bfd_boolean
d2673 1
a2673 1
static bfd_boolean
d2690 1
a2690 1
    return TRUE;
d2720 1
a2720 1
	      return FALSE;
d2726 1
a2726 1
	      return FALSE;
d2735 1
a2735 1
	      return FALSE;
d2760 1
a2760 1
	  return TRUE;
d2781 1
a2781 1
  bfd_boolean failed;
d2784 1
a2784 1
static bfd_boolean
d2790 1
a2790 1
  bfd_boolean strip;
d2797 1
a2797 1
    strip = FALSE;
d2802 1
a2802 1
    strip = TRUE;
d2807 2
a2808 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d2810 1
a2810 1
    strip = FALSE;
d2813 1
a2813 1
    return TRUE;
d2911 2
a2912 2
      einfo->failed = TRUE;
      return FALSE;
d2915 1
a2915 1
  return TRUE;
d2999 1
a2999 1
static bfd_boolean
d3012 1
a3012 1
  bfd_boolean got_created;
d3016 1
a3016 1
    return TRUE;
d3026 1
a3026 1
  got_created = FALSE;
d3040 1
a3040 1
      bfd_boolean maybe_dynamic;
d3062 1
a3062 1
      maybe_dynamic = FALSE;
d3067 1
a3067 1
        maybe_dynamic = TRUE;
d3133 1
a3133 1
		return FALSE;
d3151 1
a3151 1
	    return FALSE;
d3179 1
a3179 1
		return FALSE;
d3205 1
a3205 1
		    return FALSE;
d3228 1
a3228 1
		    return FALSE;
d3254 1
a3254 1
  return TRUE;
d3263 1
a3263 1
static bfd_boolean
d3294 1
a3294 1
	return FALSE;
d3319 1
a3319 1
      return TRUE;
d3333 1
a3333 1
      return TRUE;
d3341 1
a3341 1
  return TRUE;
d3348 1
a3348 1
static bfd_boolean
d3356 1
a3356 1
    return TRUE;
d3419 1
a3419 1
  return TRUE;
d3424 1
a3424 1
static bfd_boolean
d3433 1
a3433 1
    return TRUE;
d3437 1
a3437 1
    return FALSE;
d3474 1
a3474 1
	        return FALSE;
d3480 1
a3480 1
  return TRUE;
d3580 1
a3580 1
static bfd_boolean
d3600 1
a3600 1
  return TRUE;
d3650 1
a3650 1
static bfd_boolean
d3679 1
a3679 1
	      return FALSE;
d3691 1
a3691 1
	return TRUE;
d3722 1
a3722 1
  return TRUE;
d3728 1
a3728 1
static bfd_boolean
d3739 1
a3739 1
    return TRUE;
d3757 1
a3757 1
  return TRUE;
d3760 1
a3760 1
static bfd_boolean
d3770 1
a3770 1
    return TRUE;
d3793 1
a3793 1
  return TRUE;
d3796 1
a3796 1
static bfd_boolean
d3804 1
a3804 1
    return TRUE;
d3812 1
a3812 1
    return FALSE;
d3823 1
a3823 1
	    return FALSE;
d3827 1
a3827 1
  return TRUE;
d3866 1
a3866 1
static bfd_boolean
d3871 1
a3871 1
  bfd_boolean dynamic;
d3914 1
a3914 1
  return TRUE;
d3919 1
a3919 1
static bfd_boolean
d3959 1
a3959 1
      return TRUE;
d3969 1
a3969 1
  return TRUE;
d3975 1
a3975 1
static bfd_boolean
d3980 1
a3980 1
  bfd_boolean dynamic;
d4012 1
a4012 1
  return TRUE;
d4017 1
a4017 1
static bfd_boolean
d4024 1
a4024 1
  bfd_boolean relplt;
d4054 1
a4054 1
  relplt = FALSE;
d4058 1
a4058 1
      bfd_boolean strip;
d4075 1
a4075 1
      strip = FALSE;
d4084 1
a4084 1
		relplt = TRUE;
d4104 1
a4104 1
	    return FALSE;
d4121 1
a4121 1
	    return FALSE;
d4130 1
a4130 1
	    return FALSE;
d4136 1
a4136 1
	return FALSE;
d4141 1
a4141 1
	    return FALSE;
d4146 1
a4146 1
  return TRUE;
d4155 1
a4155 1
static bfd_boolean
d4170 1
a4170 1
  bfd_boolean ret_val = TRUE;
d4189 1
a4189 1
	  ret_val = FALSE;
d4216 1
a4216 1
static bfd_boolean
d4236 1
a4236 1
  bfd_boolean ret_val;
d4247 1
a4247 1
  ret_val = TRUE;
d4306 2
a4307 2
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref = FALSE;
d4317 1
a4317 1
	  ret_val = FALSE;
d4367 1
a4367 1
	  dynamic_symbol_p = FALSE;
d4397 1
a4397 1
	    undef_weak_ref = TRUE;
d4410 2
a4411 2
		return FALSE;
	      ret_val = FALSE;
a4467 1
		  bfd_byte *loc;
d4477 4
a4480 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4501 1
a4501 1
              ret_val = FALSE;
d4513 1
a4513 1
              ret_val = FALSE;
d4539 1
a4539 1
              ret_val = FALSE;
d4567 1
a4567 1
		ret_val = FALSE;
d4597 1
a4597 1
		ret_val = FALSE;
a4609 1
	    bfd_byte *loc;
d4643 1
a4643 1
		    ret_val = FALSE;
d4662 4
a4665 3
	    loc = srel->contents;
	    loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4679 1
a4679 1
              ret_val = FALSE;
a4710 1
		  bfd_byte *loc;
d4721 4
a4724 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4755 1
a4755 1
              ret_val = FALSE;
d4771 1
a4771 1
              ret_val = FALSE;
d4778 1
a4778 1
              ret_val = FALSE;
d4846 1
a4846 1
		  return FALSE;
d4853 1
a4853 1
	      ret_val = FALSE;
d4869 1
a4869 1
static bfd_boolean
a4882 1
      bfd_byte *loc;
d4928 3
a4930 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d4966 4
a4969 3
		  loc = srel->contents;
		  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a4983 1
      bfd_byte *loc;
d5027 3
a5029 3
	  loc = srel->contents;
	  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d5036 3
a5038 3
	      loc = srel->contents;
	      loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d5052 1
a5052 1
  return TRUE;
d5057 1
a5057 1
static bfd_boolean
d5144 1
a5144 1
  return TRUE;
d5151 1
a5151 1
static bfd_boolean
d5208 1
a5208 1
	    return FALSE;
d5247 1
a5247 1
		    return FALSE;
d5292 1
a5292 1
		return FALSE;
d5297 1
a5297 1
		return FALSE;
d5323 1
a5323 1
						  name, FALSE, FALSE, TRUE);
d5360 1
a5360 1
	  einfo.failed = FALSE;
d5365 1
a5365 1
	    return FALSE;
d5380 1
a5380 1
    return FALSE;
d5402 1
a5402 1
	  return FALSE;
d5412 1
a5412 1
	return FALSE;
d5417 1
a5417 1
  return TRUE;
d5507 4
a5510 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
@


1.80.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 1
a51 1
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d53 1
a53 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d55 1
a55 1
  PARAMS ((bfd *));
d58 1
a58 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 1
a60 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d62 1
a62 1
  PARAMS ((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
d64 1
a64 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d67 1
a67 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d69 1
a69 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d72 1
a72 1
  PARAMS ((bfd *));
d74 1
a74 1
  PARAMS ((bfd *));
d76 1
a76 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d78 1
a78 1
  PARAMS ((flagword *, Elf_Internal_Shdr *));
d80 1
a80 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d82 1
a82 1
  PARAMS ((bfd *, struct bfd_link_info *));
d84 1
a84 1
  PARAMS ((bfd *, struct bfd_link_info *));
d87 1
a87 1
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
d89 1
a89 1
  PARAMS ((bfd *, const char *));
d91 2
a92 2
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d99 1
a99 1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
d102 1
a102 1
  PARAMS ((bfd *, bfd *));
d104 1
a104 1
  PARAMS ((bfd *, bfd *));
d132 1
a132 1
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
d135 1
a135 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d137 1
a137 4
  PARAMS ((bfd *, struct bfd_link_info *));
static void elf64_alpha_emit_dynrel
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *,
	   bfd_vma, long, long, bfd_vma));
d139 2
a140 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d142 1
a142 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
d145 2
a146 2
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
d148 1
a148 1
  PARAMS ((bfd *, struct bfd_link_info *));
d150 1
a150 1
  PARAMS ((bfd *, struct bfd_link_info *));
d152 1
a152 1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
a176 5
#define ALPHA_ELF_LINK_HASH_PLT_LOC	0x80

  /* Used to undo the localization of a plt symbol.  */
  asection *plt_old_section;
  bfd_vma plt_old_value;
d183 1
a183 1
    /* Which .got subsection?  */
d186 1
a186 1
    /* The addend in effect for this entry.  */
d189 1
a189 1
    /* The .got offset for this entry.  */
d208 1
a208 1
  /* Used to count non-got, non-plt relocations for delayed sizing
d214 1
a214 1
    /* Which .reloc section? */
d217 1
a217 1
    /* What kind of relocation? */
d220 1
a220 1
    /* Is this against read-only section? */
d223 1
a223 1
    /* How many did we find?  */
a1640 11
  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
d1660 10
d1751 1
a1751 2
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
  unsigned long new_symndx;
d1755 5
a1795 1
  pos1_unusable = FALSE;
d1797 2
a1798 4
  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
d1804 1
a1804 3
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
a1859 1
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
d1878 2
a1879 1
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
d1884 1
a1884 2
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && !pos1_unusable)
d1892 2
a1893 1
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
d1895 2
a1896 1
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
d1910 2
a1911 1
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
a2113 1
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);
a2123 2
	  break;

a2124 3
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
a2125 1

d2131 1
a2131 1
      if (r_symndx < symtab_hdr->sh_info)
d2148 7
a2154 9
	  isym = isymbuf + r_symndx;

	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.tls_segment);
	    }
d2156 1
a2156 11
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }
d2160 2
a2161 7
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
d2168 1
a2168 1
	  indx = r_symndx - symtab_hdr->sh_info;
d2184 1
a2184 13
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }
d2187 1
d2190 1
d3108 1
a3109 8
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
a3310 3
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
a3791 8

      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
a3844 1
    case R_ALPHA_GOTTPREL:
d3847 1
d3853 2
d3856 1
a3856 1
      return dynamic || shared;
a4149 32
/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)
   into the next available slot in SREL.  */

static void
elf64_alpha_emit_dynrel (abfd, info, sec, srel, offset, dynindx, rtype, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec, *srel;
     bfd_vma offset, addend;
     long dynindx, rtype;
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (srel != NULL);

  outrel.r_info = ELF64_R_INFO (dynindx, rtype);
  outrel.r_addend = addend;

  offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if ((offset | 1) != (bfd_vma) -1)
    outrel.r_offset = sec->output_section->vma + sec->output_offset + offset;
  else
    memset (&outrel, 0, sizeof (outrel));

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
}

a4324 5
      /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	 reloc to the 0 symbol so that they all match.  */
      if (r_type == R_ALPHA_TLSLDM)
	r_symndx = 0;

a4330 12
	  /* If this is a tp-relative relocation against sym 0,
	     this is hackery from relax_section.  Force the value to
	     be the tls base.  */
	  if (r_symndx == 0
	      && (r_type == R_ALPHA_TLSLDM
		  || r_type == R_ALPHA_GOTTPREL
		  || r_type == R_ALPHA_TPREL64
		  || r_type == R_ALPHA_TPRELHI
		  || r_type == R_ALPHA_TPRELLO
		  || r_type == R_ALPHA_TPREL16))
	    value = tp_base;

d4340 2
a4341 1
	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
d4467 19
a4485 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, value);
d4610 2
a4611 2
	    long dynindx, dyntype = r_type;
	    bfd_vma dynaddend;
d4619 2
a4620 2
		dynindx = h->root.dynindx;
		dynaddend = addend;
d4632 2
a4633 7
		if (!info->shared)
		  {
		    value -= tp_base;
		    goto default_reloc;
		  }
		dynindx = 0;
		dynaddend = value - dtp_base;
d4647 2
a4648 3
		dynindx = 0;
		dyntype = R_ALPHA_RELATIVE;
		dynaddend = value;
d4653 16
a4668 3
	    elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				     srel, rel->r_offset, dynindx,
				     dyntype, dynaddend);
d4710 20
a4729 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_DTPMOD64, 0);
d4803 1
a4803 12
		  if (r_type == R_ALPHA_GOTDTPREL)
		    value -= dtp_base;
		  else if (!info->shared)
		    value -= tp_base;
		  else
		    {
		      elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					       gotent->got_offset, 0,
					       R_ALPHA_TPREL64,
					       value - dtp_base);
		      value = 0;
		    }
d4960 13
a4972 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, plt_addr);
d4983 2
d4995 1
a4995 1
	  long r_type;
d5001 3
d5025 6
a5030 3
	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				   gotent->got_offset, h->dynindx,
				   r_type, gotent->addend);
d5033 11
a5043 3
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				     gotent->got_offset + 8, h->dynindx,
				     R_ALPHA_DTPREL64, gotent->addend);
d5140 2
a5141 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 0;
a5619 1
#undef  elf64_bed
@


1.80.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d4506 1
d5179 1
a5179 1
      /* Initialize the PLT0 entry.  */
@


1.80.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d4517 1
d4583 1
a4584 13
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

	case R_ALPHA_GPREL16:
@


1.80.2.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d308 1
a308 3
	   & (ELF_LINK_HASH_DEF_DYNAMIC
	      | ELF_LINK_HASH_DEF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR))
@


1.80.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1559 1
a1559 1
	  tsec_relocs = (_bfd_elf_link_read_relocs
d2075 1
a2075 1
  internal_relocs = (_bfd_elf_link_read_relocs
d5559 1
a5559 1
  64, 3,
@


1.80.2.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2061 1
a2061 1
  if (link_info->relocatable
d2468 1
a2468 1
      && !info->relocatable
d3060 1
a3060 1
  if (info->relocatable)
d3866 1
a3866 1
  if (info->relocatable)
d4093 1
a4093 1
      if (info->executable)
d4179 1
a4179 1
      if (info->executable)
d4333 1
a4333 1
  if (info->relocatable)
@


1.80.2.11
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d50 1
a50 1
static bfd_boolean alpha_elf_dynamic_symbol_p
d272 1
a272 4
/* Should we do dynamic things to this symbol?  This differs from the 
   generic version in that we never need to consider function pointer
   equality wrt PLT entries -- we don't create a PLT entry if a symbol's
   address is ever taken.  */
d274 1
a274 1
static inline bfd_boolean
d279 36
a314 1
  return _bfd_elf_dynamic_symbol_p (h, info, 0);
d4507 1
a4507 1
	  else if (!info->executable
a5499 10
static struct bfd_elf_special_section const elf64_alpha_special_sections[]=
{
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a5636 3

#define elf_backend_special_sections \
  elf64_alpha_special_sections
@


1.80.2.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d3077 1
a3077 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
d4448 1
a4448 9
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry *hh;
	  
	  RELOC_FOR_GLOBAL_SYMBOL (hh,
				   (struct elf_link_hash_entry *) alpha_elf_sym_hashes (input_bfd),
				   r_symndx, symtab_hdr, value,
				   sec, unresolved_reloc, info,
				   warned);
d4450 9
a4458 2
	  if (warned)
	    continue;
d4460 14
a4473 3
	  if (value == 0
	      && ! unresolved_reloc
	      && hh->root.type == bfd_link_hash_undefweak)
d4475 14
a4489 1
	  h = (struct alpha_elf_link_hash_entry *) hh;
@


1.80.2.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1161 2
a1162 2
#define alpha_get_dtprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma)
d1166 2
a1167 4
#define alpha_get_tprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma					\
   - align_power ((bfd_vma) 16,						\
		  elf_hash_table (info)->tls_sec->alignment_power))
d1201 1
d1227 2
d1601 3
a1603 3
      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
d1848 2
a1849 2
	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
d1964 47
d2024 1
d2082 5
d2140 1
a2140 1
	      symval = alpha_get_tprel_base (info.link_info);
d2470 2
a2471 7
  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
    }
d4292 1
d4346 2
a4347 1
  if (elf_hash_table (info)->tls_sec != NULL)
d4349 2
a4350 2
      dtp_base = alpha_get_dtprel_base (info);
      tp_base = alpha_get_tprel_base (info);
a4391 1
	  asection *msec;
d4394 1
a4394 2
	  msec = sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
d4422 1
d4672 1
a4672 1
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4678 1
a4678 1
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4758 1
a4758 1
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4781 1
a4781 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4804 1
a4804 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4825 1
a4825 1
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d5447 6
a5452 3
  { ".sdata", 6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,     0,  0, 0,            0 }
d5601 1
@


1.80.2.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d396 9
d3643 1
a3643 1
	  /* We are assuming no merging has yet occurred.  */
@


1.79
log
@2002-09-16  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.

	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".

	* emulparams/elf_i386_fbsd.sh: Set OUTPUT_FORMAT to
	elf32-i386-freebsd.
	* emulparams/elf64alpha_fbsd.sh: Set OUTPUT_FORMAT to
	elf64-alpha-freebsd.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20020715021113.GJ30362@@bubble.sa.bigpond.net.au>
@
text
@d5483 1
a5483 1
const struct elf_size_info alpha_elf_size_info =
@


1.78
log
@* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Only insert
DT_PLTGOT into the dynamic section if there is a PLT.
@
text
@d5512 1
d5518 1
@


1.77
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a4122 3
      if (!add_dynamic_entry (DT_PLTGOT, 0))
	return false;

d4125 2
a4126 1
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
@


1.77.2.1
log
@* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Only insert
DT_PLTGOT into the dynamic section if there is a PLT.
@
text
@d4123 3
d4128 1
a4128 2
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
@


1.77.2.2
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d3406 1
a3406 1
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
d5483 1
a5483 1
static const struct elf_size_info alpha_elf_size_info =
a5511 1
#ifndef ELF_ARCH
a5516 1
#endif /* ELF_ARCH */
@


1.77.2.3
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a2482 1
  struct bfd_link_hash_entry *bh;
d2498 1
a2498 1
  bh = NULL;
d2502 2
a2503 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a2504 1
  h = (struct elf_link_hash_entry *) bh;
d2542 1
a2542 1
  bh = NULL;
d2546 2
a2547 1
	 false, get_elf_backend_data (abfd)->collect, &bh)))
a2548 1
  h = (struct elf_link_hash_entry *) bh;
@


1.77.2.4
log
@        * elf64-alpha.c (elf64_alpha_relocate_section) [BRSGP]: Increment
        VALUE, not ADDEND.
@
text
@d4580 1
a4580 1
		value += 8;
@


1.77.2.5
log
@Merge from mainline.
@
text
@d3103 1
a3103 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
@


1.76
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@a2039 1
  Elf_Internal_Shdr *shndx_hdr;
a2040 1
  Elf_Internal_Rela *free_relocs = NULL;
d2042 1
a2042 4
  bfd_byte *free_contents = NULL;
  Elf64_External_Sym *extsyms;
  Elf64_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
d2068 1
a2068 3
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a2096 1
      free_contents = info.contents;
a2102 28
  /* Read this BFD's symbols.  */
  if (symtab_hdr->contents != NULL)
    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
  else
    {
      bfd_size_type amt = symtab_hdr->sh_info * sizeof (Elf64_External_Sym);
      extsyms = (Elf64_External_Sym *) bfd_malloc (amt);
      if (extsyms == NULL)
	goto error_return;
      free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
	goto error_return;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;
      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	goto error_return;
    }

a2110 1
      Elf_Internal_Sym isym;
d2133 1
a2133 2
	  Elf64_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
d2135 14
a2148 5
	  esym = extsyms + ELF64_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF64_R_SYM (irel->r_info) : 0);
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
	  if (isym.st_shndx == SHN_UNDEF)
d2150 1
a2150 1
	  else if (isym.st_shndx == SHN_ABS)
d2152 1
a2152 1
	  else if (isym.st_shndx == SHN_COMMON)
d2155 1
a2155 1
	    info.tsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d2158 1
a2158 1
	  info.other = isym.st_other;
d2160 1
a2160 1
	  symval = isym.st_value;
d2255 2
a2256 8
  if (info.changed_relocs)
    elf_section_data (sec)->relocs = internal_relocs;
  else if (free_relocs != NULL)
    free (free_relocs);

  if (info.changed_contents)
    elf_section_data (sec)->this_hdr.contents = info.contents;
  else if (free_contents != NULL)
d2258 14
a2271 2
      if (! link_info->keep_memory)
	free (free_contents);
d2279 1
a2279 4
  if (shndx_buf != NULL)
    free (shndx_buf);

  if (free_extsyms != NULL)
d2281 2
a2282 2
      if (! link_info->keep_memory)
	free (free_extsyms);
d2284 1
a2284 4
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) extsyms;
	}
d2292 9
a2300 8
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
@


1.75
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d2609 2
a2610 3
  if (bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				swap->external_hdr_size)
      == false)
@


1.74
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d2977 1
a2977 1
	    = (struct alpha_elf_got_entry **) bfd_alloc (abfd, size);
a2980 1
	  memset (local_got_entries, 0, (size_t) size);
@


1.73
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2175 2
a2176 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
@


1.72
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d2175 2
a2176 1
	  bfd_elf64_swap_symbol_in (abfd, esym, shndx, &isym);
d5532 1
@


1.71
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d76 1
a76 1
  PARAMS((bfd *, Elf64_Internal_Shdr *, char *));
d2356 1
a2356 1
     char *name;
@


1.70
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Don't dereference
        null when there are no got entries for a symbol.
        (elf64_alpha_relax_find_tls_segment): Rearrange to avoid
        uninitialized variable warning.
@
text
@d1457 1
a1457 1
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset; 
d1639 1
a1639 1
  
d2085 1
a2085 1
  /* Find the GP for this object.  Do not store the result back via 
d3753 1
a3753 1
/* Called from relax_section to rebuild the PLT in light of 
d3957 1
a3957 1
	 
d4588 1
a4588 1
	       it might not have had any relocations at all.  Also take 
@


1.69
log
@        * elf64-alpha.c (elf64_alpha_relax_with_lituse): Don't test for
        undefined symbols here.
        (elf64_alpha_relax_section): Do it here.  Also test for not
        defined in the current module.
        (elf64_alpha_relocate_section_r): Split out of ...
        (elf64_alpha_relocate_section): ... here.  Don't dereference
        NULL when looking up local got entries.
@
text
@d1991 1
a1991 1
  asection *first_tls_sec = NULL, *o;
d1998 2
a1999 5
      {
        first_tls_sec = o;
        break;
      }
  if (!first_tls_sec)
d2002 1
a2002 1
  base = first_tls_sec->vma;
d2005 1
a2005 1
  for (o = first_tls_sec; o && (o->flags & SEC_THREAD_LOCAL); o = o->next)
d2021 1
d2023 1
d4368 5
a4372 4
	       && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	       && (elf_section_data (sec)->sec_info_type
		   == ELF_INFO_TYPE_MERGE)
	       && !gotent->reloc_xlated)
@


1.68
log
@        * elf64-alpha.c (elf64_alpha_relax_with_lituse): Reject undefined
        symbols from JSR relaxation.
        (elf64_alpha_size_plt_section_1): New.
        (elf64_alpha_calc_dynrel_sizes): Split out .rela.got bits ...
        (elf64_alpha_size_rela_got_1): ... here.
        (elf64_alpha_size_dynamic_sections): Split out .rela.got bits ...
        (elf64_alpha_size_rela_got_section): ... here.
        (elf64_alpha_size_plt_section): New.
        (elf64_alpha_relax_section): Call them.
        (elf64_alpha_size_got_sections): Remove output_bfd arg.
        (elf64_alpha_finish_dynamic_symbol): Check gotent use_count.
@
text
@d137 3
a1404 9
	    /* If this symbol is undefined, we can't relax it to a branch.  */
	    if (info->h
		&& (info->h->root.root.type == bfd_link_hash_undefweak
		    || info->h->root.root.type == bfd_link_hash_undefined))
	      {
		all_optimized = false;
		break;
	      }

d2178 1
a2178 1
	    info.tsec = bfd_und_section_ptr;
d2204 10
d4180 65
d4259 1
a4259 1
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d4262 25
a4286 5
  struct elf_link_tls_segment *tls_segment = NULL;
  asection *sgot = NULL, *srel = NULL, *srelgot = NULL;
  bfd *dynobj = NULL, *gotobj = NULL;
  bfd_vma gp = 0, tp_base = 0, dtp_base = 0;
  boolean ret_val = true;
d4288 21
a4308 1
  if (!info->relocateable)
d4310 3
a4312 1
      const char *name;
d4314 1
a4314 24
      dynobj = elf_hash_table (info)->dynobj;
      if (dynobj)
        srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

      name = (bfd_elf_string_from_elf_section
	      (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
	       elf_section_data(input_section)->rel_hdr.sh_name));
      BFD_ASSERT(name != NULL);
      srel = bfd_get_section_by_name (dynobj, name);

      /* Find the gp value for this input bfd.  */
      gotobj = alpha_elf_tdata (input_bfd)->gotobj;
      if (gotobj)
	{
	  sgot = alpha_elf_tdata (gotobj)->got;
	  gp = _bfd_get_gp_value (gotobj);
	  if (gp == 0)
	    {
	      gp = (sgot->output_section->vma
		    + sgot->output_offset
		    + 0x8000);
	      _bfd_set_gp_value (gotobj, gp);
	    }
        }
d4316 5
a4320 6
      tls_segment = elf_hash_table (info)->tls_segment;
      if (tls_segment)
        {
          dtp_base = alpha_get_dtprel_base (tls_segment);
          tp_base = alpha_get_tprel_base (tls_segment);
        }
d4322 2
a4324 1
  rel = relocs;
d4326 1
a4326 1
  for (; rel < relend; rel++)
d4328 1
a4328 1
      struct alpha_elf_link_hash_entry *h;
d4333 2
a4334 2
      Elf_Internal_Sym *sym;
      asection *sec;
d4338 1
a4338 1
      boolean undef_weak_ref;
a4354 32
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */

	  /* The symbol associated with GPDISP and LITUSE is
	     immaterial.  Only the addend is significant.  */
	  if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	    continue;

	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */

      h = NULL;
      sym = NULL;
      sec = NULL;
      undef_weak_ref = false;

d4361 4
a4364 1
	  gotent = alpha_elf_tdata(input_bfd)->local_got_entries[r_symndx];
@


1.67
log
@	include/elf/
        * alpha.h (LITUSE_ALPHA_ADDR, LITUSE_ALPHA_BASE, LITUSE_ALPHA_BYTOFF,
        LITUSE_ALPHA_JSR, LITUSE_ALPHA_TLSGD, LITUSE_ALPHA_TLSLDM): New.

	gas/
        * config/tc-alpha.c: Move LITUSE constants to "elf/alpha.h".
        Rename them LITUSE_ALPHA_*.

	bfd/
        * elf64-alpha.c (alpha_get_dtprel_base, alpha_get_tprel_base): New.
        (elf64_alpha_relocate_section): Use them.  Reject LE TLS relocs
        in shared libraries.  Fix DTPRELHI and TPRELHI value.
        (INSN_ADDQ, INSN_RDUNIQ): New.
        (struct alpha_relax_info): Add symtab_hdr, tls_segment, first_gotent.
        (elf64_alpha_relax_with_lituse): Return boolean.  Remove irelend
        argument.  Reject dynamic symbols.  Use LITUSE symbolic constants.
        (elf64_alpha_relax_got_load): Rename from relax_without_lituse.
        Handle GOTDTPREL and GOTTPREL relocations.
        (elf64_alpha_relax_gprelhilo): New.
        (elf64_alpha_relax_tls_get_addr): New.
        (elf64_alpha_relax_find_tls_segment): New.
        (elf64_alpha_relax_section): Handle TLS relocations.
        (ALPHA_ELF_LINK_HASH_TLS_IE): New.
        (elf64_alpha_check_relocs): Set it.
@
text
@d109 5
a113 1
  PARAMS ((bfd *, struct bfd_link_info *));
d120 4
d1399 1
a1399 5
	    /* If not zero, place to jump without needing pv.  */
	    bfd_vma optdest = elf64_alpha_relax_opt_call (info, symval);
	    bfd_vma org = (info->sec->output_section->vma
			   + info->sec->output_offset
			   + urel->r_offset + 4);
d1402 14
d1417 1
d2273 5
a2277 1
  if (!elf64_alpha_size_got_sections (abfd, link_info))
d3676 1
a3676 2
elf64_alpha_size_got_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
d3750 71
d3823 1
a3823 1
     bfd *output_bfd;
d3836 1
a3836 1
  if (!elf64_alpha_size_got_sections (output_bfd, info))
d3898 1
a3898 2
  struct alpha_elf_got_entry *gotent;
  int entries;
d3918 1
a3918 3
    {
      h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }
d3939 79
d4020 3
a4022 2
    entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						dynamic, info->shared);
a4055 3
      int entries;
      bfd *i;

d4070 1
a4070 16
				    elf64_alpha_calc_dynrel_sizes,
				    info);

      /* Shared libraries often require RELATIVE relocs, and some relocs
	 require attention for the main application as well.  */
	 
      entries = 0;
      for (i = alpha_elf_hash_table(info)->got_list;
	   i ; i = alpha_elf_tdata(i)->got_link_next)
	{
	  bfd *j;

	  for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	    {
	      struct alpha_elf_got_entry **local_got_entries, *gotent;
	      int k, n;
d4072 1
a4072 19
	      local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	      if (!local_got_entries)
		continue;

	      for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
		for (gotent = local_got_entries[k];
		     gotent ; gotent = gotent->next)
		  if (gotent->use_count > 0)
		    entries += (alpha_dynamic_entries_for_reloc
				(gotent->reloc_type, 0, info->shared));
	    }
	}

      if (entries > 0)
	{
	  s = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size += sizeof (Elf64_External_Rela) * entries;
	}
d4964 1
a4964 1
	  asection *sgot = alpha_elf_tdata (gotent->gotobj)->got;
d4967 4
@


1.66
log
@        * elf64-alpha.c (elf64_alpha_relax_section): Don't store computed gp.
@
text
@d156 1
a156 1
  /* Contexts (LITUSE) in which a literal was referenced.  */
d164 1
d1169 9
d1200 2
d1208 1
d1211 1
a1211 2
  boolean changed_contents;
  boolean changed_relocs;
d1216 1
d1218 2
d1223 1
a1223 5
static Elf_Internal_Rela * elf64_alpha_relax_with_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, Elf_Internal_Rela *irelend));

static boolean elf64_alpha_relax_without_lituse
a1225 1

d1228 11
a1238 1

d1259 2
a1260 2
static Elf_Internal_Rela *
elf64_alpha_relax_with_lituse (info, symval, irel, irelend)
d1263 1
a1263 1
     Elf_Internal_Rela *irel, *irelend;
d1265 1
a1265 1
  Elf_Internal_Rela *urel;
d1281 1
a1281 1
      return irel;
d1284 4
d1310 2
a1311 1
	default: /* 0 = ADDRESS FORMAT */
d1317 1
a1317 1
	case 1: /* MEM FORMAT */
d1324 2
a1325 2
	  if (insn_disp & 0x00008000)
	    insn_disp |= 0xffff0000;  /* Negative: sign-extend.  */
d1328 3
a1330 2
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x00008000 && xdisp < 0x00008000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000 && xdisp < 0x7fff8000);
d1369 1
a1369 1
	case 2: /* BYTE OFFSET FORMAT */
d1387 3
a1389 1
	case 3: /* CALL FORMAT */
d1440 2
a1441 1
		     (irel, irelend, urel->r_offset + 4, R_ALPHA_GPDISP));
d1476 2
a1477 2
	  int sz = alpha_got_entry_size (info->gotent->reloc_type);
	  alpha_elf_tdata (info->gotent->gotobj)->total_got_size -= sz;
d1479 1
a1479 1
	    alpha_elf_tdata (info->gotent->gotobj)->local_got_size -= sz;
d1497 1
a1497 1
  return irel + count;
d1573 1
a1573 1
elf64_alpha_relax_without_lituse (info, symval, irel)
d1577 1
d1587 1
d1589 1
a1589 1
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
d1591 1
a1591 1
	(unsigned long) irel->r_offset));
d1595 19
a1613 3
  /* So we aren't told much.  Do what we can with the address load and
     fake the rest.  All of the optimizations here require that the
     offset from the GP fit in 16 bits.  */
a1614 1
  disp = symval - info->gp;
d1618 6
a1623 4
  /* On the LITERAL instruction itself, consider exchanging
     `ldq R,X(gp)' for `lda R,Y(gp)'.  */

  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
d1626 16
d1643 1
a1643 1
  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), R_ALPHA_GPREL16);
d1650 2
a1651 2
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotent->gotobj)->total_got_size -= sz;
d1653 1
a1653 1
	alpha_elf_tdata (info->gotent->gotobj)->local_got_size -= sz;
d1673 348
d2033 1
a2033 1
  Elf64_External_Sym *extsyms = NULL;
d2038 1
d2069 1
d2084 48
d2137 1
d2139 2
a2140 5
      if (ELF64_R_TYPE (irel->r_info) != (int) R_ALPHA_LITERAL)
	continue;

      /* Get the section contents.  */
      if (info.contents == NULL)
d2142 10
a2151 47
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    info.contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (info.contents == NULL)
		goto error_return;
	      free_contents = info.contents;

	      if (! bfd_get_section_contents (abfd, sec, info.contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  bfd_size_type amt;

	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf64_External_Sym);
	      extsyms = (Elf64_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	    }

	  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
	  if (shndx_hdr->sh_size != 0)
	    {
	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	    }
d2175 1
a2175 1
	  gotent = local_got_entries[ELF64_R_SYM(irel->r_info)];
a2190 6
	  /* We can't do anthing with undefined or dynamic symbols.  */
	  if (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak
	      || alpha_elf_dynamic_symbol_p (&h->root, link_info))
	    continue;

d2194 1
a2194 1
	  gotent = h->got_entries;
d2199 5
a2203 2
      while (gotent->gotobj != info.gotobj || gotent->addend != irel->r_addend)
	gotent = gotent->next;
d2209 4
a2212 1
      BFD_ASSERT(info.gotent != NULL);
d2214 15
a2228 3
      /* If there exist LITUSE relocations immediately following, this
	 opens up all sorts of interesting optimizations, because we
	 now know every location that this address load is used.  */
d2230 11
a2240 4
      if (irel+1 < irelend && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	{
	  irel = elf64_alpha_relax_with_lituse (&info, symval, irel, irelend);
	  if (irel == NULL)
d2242 7
a2248 4
	}
      else
	{
	  if (!elf64_alpha_relax_without_lituse (&info, symval, irel))
d2250 1
d2258 1
a2258 3
    {
      elf_section_data (sec)->relocs = internal_relocs;
    }
d2260 1
a2260 3
    {
      free (free_relocs);
    }
d2263 1
a2263 3
    {
      elf_section_data (sec)->this_hdr.contents = info.contents;
    }
d3117 1
d4097 2
a4098 6
          /* This is PT_TLS segment p_vaddr.  */
          dtp_base = tls_segment->start;

          /* Main program TLS (whose template starts at PT_TLS p_vaddr)
	     is assigned offset round(16, PT_TLS p_align).  */
          tp_base = dtp_base - align_power (16, tls_segment->align);
d4596 2
d4603 8
a4610 1
	  if (dynamic_symbol_p)
d4619 2
@


1.65
log
@        * elf64-alpha.c: Remove dead code.
@
text
@d1659 2
a1660 1
  /* Find the GP for this object.  */
d1665 3
a1667 8
      info.gp = _bfd_get_gp_value (info.gotobj);
      if (info.gp == 0)
	{
	  info.gp = (sgot->output_section->vma
		     + sgot->output_offset
		     + 0x8000);
	  _bfd_set_gp_value (info.gotobj, info.gp);
	}
@


1.64
log
@        * elf64-alpha.c (elf64_alpha_check_relocs): Fix typo on maybe_dynamic
        check; don't suppress dynamic relocs for non-allocated sections.
@
text
@a2481 11

/* FIXME:  Create a runtime procedure table from the .mdebug section.

static boolean
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
*/
@


1.63
log
@include/elf/
        * alpha.h (R_ALPHA_TLSGD, R_ALPHA_TLSLDM, R_ALPHA_DTPMOD64,
        R_ALPHA_GOTDTPREL, R_ALPHA_DTPREL64, R_ALPHA_DTPRELHI,
        R_ALPHA_DTPRELLO, R_ALPHA_DTPREL16, R_ALPHA_GOTTPREL, R_ALPHA_TPREL64,
        R_ALPHA_TPRELHI, R_ALPHA_TPRELLO, R_ALPHA_TPREL16): New.

bfd/
        * elf64-alpha.c (ALPHA_ELF_LINK_HASH_LU_TLSGD,
        ALPHA_ELF_LINK_HASH_LU_TLSLDM, ALPHA_ELF_LINK_HASH_LU_FUNC): New.
        (ALPHA_ELF_GOT_ENTRY_RELOCS_DONE): Remove.
        (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Remove.
        (struct alpha_elf_got_entry): Add reloc_type, reloc_done, reloc_xlated.
        (struct alpha_elf_obj_tdata): Rename total_got_entries and
        n_local_got_entries to total_got_size and local_got_size.
        (elf64_alpha_howto, elf64_alpha_reloc_map): Update for TLS relocs.
        (alpha_got_entry_size): New.
        (elf64_alpha_relax_with_lituse): Use it.
        (elf64_alpha_relax_without_lituse): Likewise.
        (MAX_GOT_SIZE): Rename from MAX_GOT_ENTRIES.
        (get_got_entry): New.
        (elf64_alpha_check_relocs): Handle TLS relocs.  Reorganize.
        (elf64_alpha_adjust_dynamic_symbol): Test LU_FUNC as a mask.
        (elf64_alpha_merge_ind_symbols): Check gotent->reloc_type.
        (elf64_alpha_can_merge_gots, elf64_alpha_merge_gots): Likewise.
        (elf64_alpha_calc_got_offsets_for_symbol): Use alpha_got_entry_size.
        (elf64_alpha_calc_got_offsets): Likewise.
        (alpha_dynamic_entries_for_reloc): New.
        (elf64_alpha_calc_dynrel_sizes): Use it.
        (elf64_alpha_size_dynamic_sections): Likewise.
        (elf64_alpha_relocate_section): Handle TLS relocations.
        * reloc.c: Add Alpha TLS relocations.
        * bfd-in2.h, libbfd.h: Rebuild.

gas/
        * expr.h (operatorT): Add O_md17..O_md32.
        * config/tc-alpha.c (O_lituse_tlsgd, O_lituse_tlsldm, O_tlsgd,
        O_tlsldm, O_gotdtprel, O_dtprelhi, O_dtprello, O_dtprel, O_gottprel,
        O_tprelhi, O_tprello, O_tprel): New.
        (USER_RELOC_P, alpha_reloc_op_tag, debug_exp): Include them.
        (DUMMY_RELOC_LITUSE_TLSGD, DUMMY_RELOC_LITUSE_TLSLDM): New.
        (LITUSE_TLSGD, LITUSE_TLSLDM): New.
        (struct alpha_reloc_tag): Add master, saw_tlsgd, saw_tlsld,
        saw_lu_tlsgd, saw_lu_tlsldm.  Make multi_section_p a bit field.
        (md_apply_fix3): Handle TLS relocations.
        (alpha_force_relocation, alpha_fix_adjustable): Likewise.
        (alpha_adjust_symtab_relocs): Sort LITERAL relocs after the
        associated TLS reloc.  Check lituse_tls relocs match up.
        (emit_insn): Handle TLS relocations.
        (ldX_op): Remove.

gas/testsuite/
        * gas/alpha/elf-tls-1.s, gas/alpha/elf-tls-1.d: New.
        * gas/alpha/elf-tls-2.s, gas/alpha/elf-tls-1.l: New.
        * gas/alpha/elf-tls-3.s, gas/alpha/elf-tls-1.l: New.
        * gas/alpha/alpha.exp: Run them.
@
text
@d2643 1
a2643 1
		|| h->root.type == bfd_link_hash_defweak))
d2818 1
a2818 1
	  else if (info->shared && (sec->flags & SEC_ALLOC))
d2823 2
a2824 1
	      if (sec->flags & SEC_READONLY)
@


1.62
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Force relative relocs
        vs SHN_UNDEF to zero.
@
text
@d112 2
d119 3
d157 7
a163 4
#define ALPHA_ELF_LINK_HASH_LU_ADDR 0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM  0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE 0x04
#define ALPHA_ELF_LINK_HASH_LU_FUNC 0x08
d179 5
a183 1
    int flags;
d185 2
a186 3
    /* Additional flags.  */
#define ALPHA_ELF_GOT_ENTRY_RELOCS_DONE 0x10
#define ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED 0x20
d188 5
a192 1
    int use_count;
d379 2
a380 2
  /* For every got, this is it's total number of *entries*.  */
  int total_got_entries;
d382 1
a382 1
  /* For every got, this is the sum of the number of *entries* required
d384 1
a384 1
  int n_local_got_entries;
d766 197
d1117 13
d1164 4
d1445 7
a1451 4
      info->gotent->use_count -= 1;
      alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
      if (!info->h)
	alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;
d1454 2
a1455 2
	 reused.  We can eliminate it.
	 ??? For now, I don't want to deal with compacting the section,
d1584 7
a1590 4
  info->gotent->use_count -= 1;
  alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
  if (!info->h)
    alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;
d1881 1
a1881 1
#define MAX_GOT_ENTRIES		(64*1024 / 8)
d2494 80
a2587 1
  struct alpha_elf_got_entry **local_got_entries;
d2589 1
a2589 1
  int got_created;
d2603 1
a2603 2
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
  got_created = 0;
d2608 6
d2616 4
d2634 14
d2649 1
d2654 1
a2654 3
	  {
	    struct alpha_elf_got_entry *gotent;
	    int flags = 0;
d2656 12
a2667 110
	    if (h)
	      {
		/* Search for and possibly create a got entry.  */
		for (gotent = h->got_entries; gotent ; gotent = gotent->next)
		  if (gotent->gotobj == abfd &&
		      gotent->addend == rel->r_addend)
		    break;

		if (!gotent)
		  {
		    amt = sizeof (struct alpha_elf_got_entry);
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd, amt));
		    if (!gotent)
		      return false;

		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;
		    gotent->use_count = 1;

		    gotent->next = h->got_entries;
		    h->got_entries = gotent;

		    alpha_elf_tdata (abfd)->total_got_entries++;
		  }
		else
		  gotent->use_count += 1;
	      }
	    else
	      {
		/* This is a local .got entry -- record for merge.  */
		if (!local_got_entries)
		  {
		    bfd_size_type size;
		    size = symtab_hdr->sh_info;
		    size *= sizeof (struct alpha_elf_got_entry *);

		    local_got_entries = ((struct alpha_elf_got_entry **)
					 bfd_alloc (abfd, size));
		    if (!local_got_entries)
		      return false;

		    memset (local_got_entries, 0, (size_t) size);
		    alpha_elf_tdata (abfd)->local_got_entries =
		      local_got_entries;
		  }

		for (gotent = local_got_entries[ELF64_R_SYM(rel->r_info)];
		     gotent != NULL && gotent->addend != rel->r_addend;
		     gotent = gotent->next)
		  continue;
		if (!gotent)
		  {
		    amt = sizeof (struct alpha_elf_got_entry);
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd, amt));
		    if (!gotent)
		      return false;

		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;
		    gotent->use_count = 1;

		    gotent->next = local_got_entries[ELF64_R_SYM(rel->r_info)];
		    local_got_entries[ELF64_R_SYM(rel->r_info)] = gotent;

		    alpha_elf_tdata(abfd)->total_got_entries++;
		    alpha_elf_tdata(abfd)->n_local_got_entries++;
		  }
		else
		  gotent->use_count += 1;
	      }

	    /* Remember how this literal is used from its LITUSEs.
	       This will be important when it comes to decide if we can
	       create a .plt entry for a function symbol.  */
	    if (rel+1 < relend
		&& ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE)
	      {
		do
		  {
		    ++rel;
		    if (rel->r_addend >= 1 && rel->r_addend <= 3)
		      flags |= 1 << rel->r_addend;
		  }
		while (rel+1 < relend &&
		       ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE);
	      }
	    else
	      {
		/* No LITUSEs -- presumably the address is not being
		   loaded for nothing.  */
		flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	      }

	    gotent->flags |= flags;
	    if (h)
	      {
		/* Make a guess as to whether a .plt entry will be needed.  */
		if ((h->flags |= flags) == ALPHA_ELF_LINK_HASH_LU_FUNC)
		  h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		else
		  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	      }
	  }
	  /* FALLTHRU */
d2675 31
a2705 3
	  /* We don't actually use the .got here, but the sections must
	     be created before the linker maps input sections to output
	     sections.  */
d2719 17
a2735 1
	  break;
d2737 9
a2745 6
	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (h == NULL)
	    break;
	  /* FALLTHRU */
d2747 2
a2748 2
	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
a2825 1
	  break;
d2857 2
a2858 1
	      && ah->flags == ALPHA_ELF_LINK_HASH_LU_FUNC))
d2955 7
a2961 2
	    if (gi->gotobj == gs->gotobj && gi->addend == gs->addend)
	      goto got_found;
d3003 1
a3003 1
  int total = alpha_elf_tdata (a)->total_got_entries;
d3007 1
a3007 1
  if (total + alpha_elf_tdata (b)->total_got_entries <= MAX_GOT_ENTRIES)
d3011 1
a3011 1
  if ((total += alpha_elf_tdata (b)->n_local_got_entries) > MAX_GOT_ENTRIES)
d3042 3
a3044 1
	        if (ae->gotobj == a && ae->addend == be->addend)
d3047 2
a3048 1
	      if (++total > MAX_GOT_ENTRIES)
d3064 1
a3064 1
  int total = alpha_elf_tdata (a)->total_got_entries;
d3069 1
a3069 1
    int e = alpha_elf_tdata (b)->n_local_got_entries;
d3071 1
a3071 1
    alpha_elf_tdata (a)->n_local_got_entries += e;
d3121 3
a3123 1
	        if (ae->gotobj == a && ae->addend == be->addend)
d3131 1
a3131 1
	      total += 1;
d3139 1
a3139 1
  alpha_elf_tdata (a)->total_got_entries = total;
d3172 1
a3172 1
	*plge += 8;
d3214 1
a3214 1
		  got_offset += 8;
d3248 1
a3248 1
          if (alpha_elf_tdata (this_got)->total_got_entries > MAX_GOT_ENTRIES)
d3254 1
a3254 1
	         alpha_elf_tdata (this_got)->total_got_entries * 8);
d3335 34
d3376 5
d3407 3
a3409 1
  if (alpha_elf_dynamic_symbol_p (&h->root, info) || info->shared)
d3411 10
a3420 5
      struct alpha_elf_reloc_entry *relent;
      bfd *dynobj;
      struct alpha_elf_got_entry *gotent;
      bfd_size_type count;
      asection *srel;
d3422 4
a3425 9
      for (relent = h->reloc_entries; relent; relent = relent->next)
	if (relent->rtype == R_ALPHA_REFLONG
	    || relent->rtype == R_ALPHA_REFQUAD)
	  {
	    relent->srel->_raw_size +=
	      sizeof (Elf64_External_Rela) * relent->count;
	    if (relent->reltext)
	      info->flags |= DT_TEXTREL;
	  }
d3427 4
a3430 2
      dynobj = elf_hash_table(info)->dynobj;
      count = 0;
d3432 6
a3437 14
      for (gotent = h->got_entries; gotent ; gotent = gotent->next)
	count++;

      /* If we are using a .plt entry, subtract one, as the first
	 reference uses a .rela.plt entry instead.  */
      if (h->root.plt.offset != MINUS_ONE)
	count--;

      if (count > 0)
	{
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);
	  srel->_raw_size += sizeof (Elf64_External_Rela) * count;
	}
d3459 3
d3479 8
a3486 7
      /* When building shared libraries, each local .got entry needs a
	 RELATIVE reloc.  */
      if (info->shared)
	{
	  bfd *i;
	  asection *srel;
	  bfd_size_type count;
d3488 4
a3491 2
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);
d3493 12
a3504 4
	  for (i = alpha_elf_hash_table(info)->got_list, count = 0;
	       i != NULL;
	       i = alpha_elf_tdata(i)->got_link_next)
	    count += alpha_elf_tdata(i)->n_local_got_entries;
d3506 5
a3510 1
	  srel->_raw_size += count * sizeof (Elf64_External_Rela);
d3629 1
a3629 1
  Elf_Internal_Shdr *symtab_hdr;
d3632 4
a3635 3
  asection *sec, *sgot, *srel, *srelgot;
  bfd *dynobj, *gotobj;
  bfd_vma gp;
d3638 39
a3676 23
  srelgot = srel = NULL;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    {
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
    }

  /* Find the gp value for this input bfd.  */
  sgot = NULL;
  gp = 0;
  gotobj = alpha_elf_tdata (input_bfd)->gotobj;
  if (gotobj)
    {
      sgot = alpha_elf_tdata (gotobj)->got;
      gp = _bfd_get_gp_value (gotobj);
      if (gp == 0)
	{
	  gp = (sgot->output_section->vma
		+ sgot->output_offset
		+ 0x8000);
	  _bfd_set_gp_value (gotobj, gp);
	}
d3683 3
a3685 1
      int r_type;
a3687 1
      struct alpha_elf_link_hash_entry *h;
d3689 2
a3690 1
      bfd_vma relocation;
d3692 3
a3694 1
      bfd_reloc_status_type r;
d3697 1
a3697 1
      if (r_type < 0 || r_type >= (int) R_ALPHA_max)
d3699 3
d3703 2
a3704 1
	  return false;
d3706 1
a3707 1

d3740 1
d3746 36
a3781 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d3791 1
d3797 12
a3808 8
	      if (sec->output_section == NULL)
		relocation = 0;
	      else
		{
		  relocation = (h->root.root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		}
d3811 1
a3811 1
	    relocation = 0;
d3816 1
a3816 1
	    relocation = 0;
d3824 3
a3826 2
		ret_val = false;
	      relocation = 0;
d3828 3
d3832 1
d3834 8
d3851 3
a3853 3
	    relocation = (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->r_offset);
d3855 1
a3855 1
	    p_ldah = contents + rel->r_offset - input_section->vma;
d3858 1
a3858 1
	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - relocation,
d3864 4
a3867 3
	  {
	    struct alpha_elf_got_entry *gotent;
	    boolean dynamic_symbol;
d3869 3
a3871 2
	    BFD_ASSERT(sgot != NULL);
	    BFD_ASSERT(gp != 0);
d3873 2
a3874 21
	    if (h != NULL)
	      {
		gotent = h->got_entries;
		dynamic_symbol = alpha_elf_dynamic_symbol_p (&h->root, info);
	      }
	    else
	      {
		gotent = (alpha_elf_tdata(input_bfd)->
			  local_got_entries[r_symndx]);
		dynamic_symbol = false;

		/* Need to adjust local GOT entries' addends for SEC_MERGE
		   unless it has been done already.  */
		if ((sec->flags & SEC_MERGE)
		    && ELF_ST_TYPE (sym->st_info) == STT_SECTION
		    && (elf_section_data (sec)->sec_info_type
			== ELF_INFO_TYPE_MERGE)
		    && (gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED) == 0)
		  {
		    struct alpha_elf_got_entry *ent;
		    asection *msec;
d3876 6
a3881 21
		    for (ent = gotent; ent; ent = ent->next)
		      {
			ent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED;
			if (ent->use_count == 0)
			  continue;
			msec = sec;
			ent->addend =
			  _bfd_merged_section_offset (output_bfd, &msec,
						      elf_section_data (sec)->
						      sec_info,
						      sym->st_value
						      + ent->addend,
						      (bfd_vma) 0);
			ent->addend -= sym->st_value;
			ent->addend += msec->output_section->vma
				       + msec->output_offset
				       - sec->output_section->vma
				       - sec->output_offset;
		      }
		  }
	      }
d3883 1
a3883 1
	    BFD_ASSERT(gotent != NULL);
d3885 5
a3889 2
	    while (gotent->gotobj != gotobj || gotent->addend != addend)
	      gotent = gotent->next;
d3891 9
a3899 14
	    BFD_ASSERT(gotent->use_count >= 1);

	    /* Initialize the .got entry's value.  */
	    if (!(gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_DONE))
	      {
		bfd_put_64 (output_bfd, relocation + addend,
			    sgot->contents + gotent->got_offset);

		/* If the symbol has been forced local, output a
		   RELATIVE reloc, otherwise it will be handled in
		   finish_dynamic_symbol.  */
		if (info->shared && !dynamic_symbol)
		  {
		    Elf_Internal_Rela outrel;
d3901 4
a3904 28
		    BFD_ASSERT(srelgot != NULL);

		    outrel.r_offset = (sgot->output_section->vma
				       + sgot->output_offset
				       + gotent->got_offset);
		    outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		    outrel.r_addend = relocation + addend;

		    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					       ((Elf64_External_Rela *)
					        srelgot->contents)
					       + srelgot->reloc_count++);
		    BFD_ASSERT (sizeof (Elf64_External_Rela)
				* srelgot->reloc_count
				<= srelgot->_cooked_size);
		  }

		gotent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_DONE;
	      }

	    /* Figure the gprel relocation.  */
	    addend = 0;
	    relocation = (sgot->output_section->vma
			  + sgot->output_offset
			  + gotent->got_offset);
	    relocation -= gp;
	  }
	  /* overflow handled by _bfd_final_link_relocate */
d3910 1
a3910 1
	  if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
d3918 1
a3918 1
	  relocation -= gp;
d3922 1
a3922 1
	  if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
d3930 2
a3931 5
	  relocation -= gp;
	  relocation += addend;
	  addend = 0;
	  relocation = (((bfd_signed_vma) relocation >> 16)
			+ ((relocation >> 15) & 1));
d3937 1
a3937 1
	  if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
d3942 4
a3945 1
	  /* FALLTHRU */
d3948 7
d3957 1
a3957 1
	  addend -= 4;
d3967 1
a3967 1
	    addend -= 4;
d4020 2
d4028 1
a4028 1
	    if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
d4031 1
a4031 1
		outrel.r_info = ELF64_R_INFO(h->root.dynindx, r_type);
d4033 13
a4045 1
		addend = 0, relocation = 0;
d4051 10
a4060 2
		outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		outrel.r_addend = relocation + addend;
d4065 1
a4065 12
	    if (!srel)
	      {
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
			 elf_section_data(input_section)->rel_hdr.sh_name));
		BFD_ASSERT(name != NULL);

		srel = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT(srel != NULL);
	      }
d4085 1
d4088 8
d4104 113
d4220 1
a4220 2
					contents, rel->r_offset, relocation,
					addend);
a4391 1
      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_GLOB_DAT);
d4397 2
d4402 22
d4429 11
@


1.62.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d76 1
a76 1
  PARAMS((bfd *, Elf64_Internal_Shdr *, const char *));
d109 1
a109 5
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_plt_section_1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
a111 2
static int alpha_dynamic_entries_for_reloc
  PARAMS ((int, int, int));
a113 4
static boolean elf64_alpha_size_rela_got_section
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_rela_got_1
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
a116 3
static struct alpha_elf_got_entry *get_got_entry
  PARAMS ((bfd *, struct alpha_elf_link_hash_entry *, unsigned long,
	   unsigned long, bfd_vma));
a123 3
static boolean elf64_alpha_relocate_section_r
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d151 5
a155 9
  /* Contexts in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR	0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	0x20
#define ALPHA_ELF_LINK_HASH_LU_FUNC	0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	0x40
d171 1
a171 5
    /* How many references to this entry?  */
    int use_count;

    /* The relocation type of this entry.  */
    unsigned char reloc_type;
d173 3
a175 2
    /* How a LITERAL is used.  */
    unsigned char flags;
d177 1
a177 5
    /* Have we initialized the dynamic relocation for this entry?  */
    unsigned char reloc_done;

    /* Have we adjusted this entry for SEC_MERGE?  */
    unsigned char reloc_xlated;
d364 2
a365 2
  /* For every got, this is it's total number of words.  */
  int total_got_size;
d367 1
a367 1
  /* For every got, this is the sum of the number of words required
d369 1
a369 1
  int local_got_size;
a750 197

  /* Creates a tls_index for the symbol in the got.  */
  HOWTO (R_ALPHA_TLSGD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSGD",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a tls_index for the (current) module in the got.  */
  HOWTO (R_ALPHA_TLSLDM,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSLDM",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a DTP module entry.  */
  HOWTO (R_ALPHA_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPMOD64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from DTP to the target.  */
  HOWTO (R_ALPHA_GOTDTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTDTPREL",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELHI",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELLO",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 16-bit displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL16",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from TP to the target.  */
  HOWTO (R_ALPHA_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTTPREL",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELHI",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELLO",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 16-bit displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL16",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a904 13
  {BFD_RELOC_ALPHA_TLSGD,		R_ALPHA_TLSGD},
  {BFD_RELOC_ALPHA_TLSLDM,		R_ALPHA_TLSLDM},
  {BFD_RELOC_ALPHA_DTPMOD64,		R_ALPHA_DTPMOD64},
  {BFD_RELOC_ALPHA_GOTDTPREL16,		R_ALPHA_GOTDTPREL},
  {BFD_RELOC_ALPHA_DTPREL64,		R_ALPHA_DTPREL64},
  {BFD_RELOC_ALPHA_DTPREL_HI16,		R_ALPHA_DTPRELHI},
  {BFD_RELOC_ALPHA_DTPREL_LO16,		R_ALPHA_DTPRELLO},
  {BFD_RELOC_ALPHA_DTPREL16,		R_ALPHA_DTPREL16},
  {BFD_RELOC_ALPHA_GOTTPREL16,		R_ALPHA_GOTTPREL},
  {BFD_RELOC_ALPHA_TPREL64,		R_ALPHA_TPREL64},
  {BFD_RELOC_ALPHA_TPREL_HI16,		R_ALPHA_TPRELHI},
  {BFD_RELOC_ALPHA_TPREL_LO16,		R_ALPHA_TPRELLO},
  {BFD_RELOC_ALPHA_TPREL16,		R_ALPHA_TPREL16},
a938 13

/* These two relocations create a two-word entry in the got.  */
#define alpha_got_entry_size(r_type) \
  (r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)

/* This is PT_TLS segment p_vaddr.  */
#define alpha_get_dtprel_base(tlss) \
  ((tlss)->start)

/* Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */
#define alpha_get_tprel_base(tlss) \
  ((tlss)->start - align_power ((bfd_vma) 16, (tlss)->align))
a960 2
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e
a966 1
  Elf_Internal_Shdr *symtab_hdr;
d969 2
a970 1
  struct elf_link_tls_segment *tls_segment;
a974 1
  struct alpha_elf_got_entry **first_gotent;
a975 2
  boolean changed_contents;
  boolean changed_relocs;
d979 5
a983 1
static boolean elf64_alpha_relax_with_lituse
d986 1
d989 1
a989 11
static boolean elf64_alpha_relax_got_load
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, unsigned long));
static boolean elf64_alpha_relax_gprelhilo
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, boolean));
static boolean elf64_alpha_relax_tls_get_addr
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, boolean));
static struct elf_link_tls_segment *elf64_alpha_relax_find_tls_segment
  PARAMS((struct alpha_relax_info *, struct elf_link_tls_segment *));
d1010 2
a1011 2
static boolean
elf64_alpha_relax_with_lituse (info, symval, irel)
d1014 1
a1014 1
     Elf_Internal_Rela *irel;
d1016 1
a1016 1
  Elf_Internal_Rela *urel, *irelend = info->relend;
d1032 1
a1032 1
      return true;
a1034 4
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return true;

d1057 1
a1057 2
	case LITUSE_ALPHA_ADDR:
	default:
d1063 1
a1063 1
	case LITUSE_ALPHA_BASE:
d1070 2
a1071 2
	  if (insn_disp & 0x8000)
	    insn_disp |= ~0xffff;  /* Negative: sign-extend.  */
d1074 2
a1075 3
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);
d1114 1
a1114 1
	case LITUSE_ALPHA_BYTOFF:
d1132 1
a1132 3
	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
d1134 5
a1138 1
	    bfd_vma optdest, org;
a1140 5
	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
a1141 1

d1183 1
a1183 2
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
d1186 1
a1186 1
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
d1216 4
a1219 7
      if (--info->gotent->use_count == 0)
	{
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
	}
d1222 2
a1223 2
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
d1236 1
a1236 1
  return true;
d1312 1
a1312 1
elf64_alpha_relax_got_load (info, symval, irel, r_type)
a1315 1
     unsigned long r_type;
a1324 1
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
d1326 1
a1326 1
       ("%s: %s+0x%lx: warning: %s relocation against unexpected insn",
d1328 1
a1328 1
	(unsigned long) irel->r_offset, howto->name));
d1332 3
a1334 3
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return true;
d1336 2
a1337 2
  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
d1340 2
a1341 14
  if (r_type == R_ALPHA_LITERAL)
    disp = symval - info->gp;
  else
    {
      bfd_vma dtp_base, tp_base;

      BFD_ASSERT (info->tls_segment != NULL);
      dtp_base = alpha_get_dtprel_base (info->tls_segment);
      tp_base = alpha_get_tprel_base (info->tls_segment);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
    }

  if (disp < -0x8000 || disp >= 0x8000)
    return true;
d1343 1
a1343 6
  /* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading
     a constant, so force the base register to be $31.  */
  if (r_type == R_ALPHA_LITERAL)
    insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  else
    insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
d1347 1
a1347 17
  switch (r_type)
    {
    case R_ALPHA_LITERAL:
      r_type = R_ALPHA_GPREL16;
      break;
    case R_ALPHA_GOTDTPREL:
      r_type = R_ALPHA_DTPREL16;
      break;
    case R_ALPHA_GOTTPREL:
      r_type = R_ALPHA_TPREL16;
      break;
    default:
      BFD_ASSERT (0);
      return false;
    }

  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
d1352 4
a1355 7
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }
d1374 5
a1378 5
elf64_alpha_relax_gprelhilo (info, symval, irel, hi)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     boolean hi;
d1380 11
a1390 3
  unsigned int insn;
  bfd_signed_vma disp;
  bfd_byte *pos = info->contents + irel->r_offset;
d1392 2
a1393 1
  /* ??? This assumes that the compiler doesn't render
d1395 3
a1397 12
	array[i]
     as
	ldah	t, array(gp)	!gprelhigh
	s8addl	i, t, t
	ldq	r, array(t)	!gprellow

     which would indeed be the most efficient way to implement this.  */

  return true;

  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
d1400 4
a1403 3
  if (hi)
    {
      /* Nop out the high instruction.  */
d1405 2
a1406 2
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos);
      info->changed_contents = true;
d1408 2
a1409 351
      irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      irel->r_addend = 0;
      info->changed_relocs = true;
    }
  else
    {
      /* Adjust the low instruction to reference GP directly.  */

      insn = bfd_get_32 (info->abfd, pos);
      insn = (insn & 0xffe00000) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos);
      info->changed_contents = true;

      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				   R_ALPHA_GPREL16);
      info->changed_relocs = true;
    }

  return true;
}

static boolean
elf64_alpha_relax_tls_get_addr (info, symval, irel, is_gd)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     boolean is_gd;
{
  bfd_byte *pos[5];
  unsigned int insn;
  Elf_Internal_Rela *gpdisp, *hint;
  boolean dynamic, use_gottprel;

  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);

  /* ??? For LD relaxation, we need a symbol referencing the beginning
     of the TLS segment.  */
  if (!is_gd)
    return true;

  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;

  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;

  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return true;

  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return true;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return true;

  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return true;

  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;

  /* Only positions 0 and 1 are allowed to be out of order.  */
  if (pos[1] < pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  if (pos[1] >= pos[2] || pos[2] >= pos[3] || pos[3] >= pos[4])
    return true;

  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;

    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];

    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;

    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);

    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }

  /* Change

	lda	$16,x($gp)		!tlsgd!1
	ldq	$27,__tls_get_addr($gp)	!literal!1
	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)		!gpdisp!2
	lda	$29,0($29)		!gpdisp!2
     to
	ldq	$16,x($gp)		!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)		!tprel
	unop
     or
	ldah	$16,x($gp)		!tprelhi
	lda	$16,x($16)		!tprello

     as appropriate.  */

  use_gottprel = false;
  switch (!dynamic && !info->link_info->shared)
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (info->tls_segment != NULL);
	tp_base = alpha_get_tprel_base (info->tls_segment);
	disp = symval - tp_base;

	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000)
	  {
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */

    default:
      use_gottprel = true;

      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				     R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
    }

  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);

  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);

  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);

  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  info->changed_contents = true;
  info->changed_relocs = true;

  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;

      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
	{
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return false;

	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;

	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }

	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
    }

  return true;
}

static struct elf_link_tls_segment *
elf64_alpha_relax_find_tls_segment (info, seg)
     struct alpha_relax_info *info;
     struct elf_link_tls_segment *seg;
{
  bfd *output_bfd = info->sec->output_section->owner;
  asection *o;
  unsigned int align;
  bfd_vma base, end;

  for (o = output_bfd->sections; o ; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
        && (o->flags & SEC_LOAD) != 0)
      break;
  if (!o)
    return NULL;

  base = o->vma;
  align = 0;

  do
    {
      bfd_vma size;

      if (bfd_get_section_alignment (output_bfd, o) > align)
	align = bfd_get_section_alignment (output_bfd, o);

      size = o->_raw_size;
      if (size == 0 && (o->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *lo;
	  for (lo = o->link_order_head; lo ; lo = lo->next)
	    if (size < lo->offset + lo->size)
	      size = lo->offset + lo->size;
	}
      end = o->vma + size;
      o = o->next;
    }
  while (o && (o->flags & SEC_THREAD_LOCAL));

  seg->start = base;
  seg->size = end - base;
  seg->align = align;

  return seg;
}

static boolean
elf64_alpha_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *free_contents = NULL;
  Elf64_External_Sym *extsyms;
  Elf64_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;
  struct elf_link_tls_segment tls_segment;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = false;

  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return true;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf64_link_read_relocs
a1420 1
  info.symtab_hdr = symtab_hdr;
d1424 1
a1424 2
  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
d1429 8
a1436 3
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
d1439 1
a1439 4
  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
  else
d1441 8
a1448 1
      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
d1450 9
a1458 2
	goto error_return;
      free_contents = info.contents;
d1460 5
a1464 4
      if (! bfd_get_section_contents (abfd, sec, info.contents,
				      (file_ptr) 0, sec->_raw_size))
	goto error_return;
    }
d1466 1
a1466 7
  /* Read this BFD's symbols.  */
  if (symtab_hdr->contents != NULL)
    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
  else
    {
      bfd_size_type amt = symtab_hdr->sh_info * sizeof (Elf64_External_Sym);
      extsyms = (Elf64_External_Sym *) bfd_malloc (amt);
d1468 2
a1469 24
	goto error_return;
      free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
	goto error_return;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;
      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	goto error_return;
    }

  /* Compute the TLS segment information.  The version normally found in
     elf_hash_table (link_info)->tls_segment isn't built until final_link.
     ??? Probably should look into extracting this into a common function.  */
  info.tls_segment = elf64_alpha_relax_find_tls_segment (&info, &tls_segment);
d1471 14
a1484 6
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      Elf_Internal_Sym isym;
      struct alpha_elf_got_entry *gotent;
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
d1486 12
a1497 13
      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  break;
	default:
	  continue;
d1509 1
a1509 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d1511 1
a1511 1
	    continue;
d1521 1
a1521 1
	  info.first_gotent = &local_got_entries[ELF64_R_SYM(irel->r_info)];
d1537 4
a1540 8
	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefweak
	      || h->root.root.type == bfd_link_hash_undefined)
	    continue;

	  /* If the symbol isn't defined in the current module, again
	     we can't do anything.  */
	  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1546 1
a1546 1
	  info.first_gotent = &h->got_entries;
d1551 2
a1552 5
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
d1558 1
a1558 4
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);
d1560 3
a1562 15
	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
	    }
	  break;
d1564 4
a1567 4
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  if (!elf64_alpha_relax_gprelhilo (&info, symval, irel,
					    r_type == R_ALPHA_GPRELHIGH))
d1569 4
a1572 14
	  break;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
	    goto error_return;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
a1573 1
	  break;
d1577 1
a1577 5
  if (!elf64_alpha_size_plt_section (link_info))
    return false;
  if (!elf64_alpha_size_got_sections (link_info))
    return false;
  if (!elf64_alpha_size_rela_got_section (link_info))
d1581 3
a1583 1
    elf_section_data (sec)->relocs = internal_relocs;
d1585 3
a1587 1
    free (free_relocs);
d1590 3
a1592 1
    elf_section_data (sec)->this_hdr.contents = info.contents;
d1646 1
a1646 1
#define MAX_GOT_SIZE		(64*1024)
d1659 1
a1659 1
     const char *name;
d2247 11
d2259 1
a2259 1
/* Search for and possibly create a got entry.  */
d2261 2
a2262 2
static struct alpha_elf_got_entry *
get_got_entry (abfd, h, r_type, r_symndx, r_addend)
d2264 3
a2266 3
     struct alpha_elf_link_hash_entry *h;
     unsigned long r_type, r_symndx;
     bfd_vma r_addend;
d2268 9
a2276 2
  struct alpha_elf_got_entry *gotent;
  struct alpha_elf_got_entry **slot;
d2278 2
a2279 5
  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */
d2281 3
a2283 1
      struct alpha_elf_got_entry **local_got_entries;
d2285 1
a2285 85
      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);

	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;

	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
    {
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
    }
  else
    gotent->use_count += 1;

  return gotent;
}

/* Handle dynamic relocations when doing an Alpha ELF link.  */

static boolean
elf64_alpha_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  bfd *dynobj;
  asection *sreloc;
  const char *rel_sec_name;
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  boolean got_created;
  bfd_size_type amt;

  if (info->relocateable)
    return true;

  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj == NULL)
    elf_hash_table(info)->dynobj = dynobj = abfd;

  sreloc = NULL;
d2289 2
a2290 1
  got_created = false;
a2294 6
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };

a2296 4
      unsigned int gotent_flags;
      boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;
a2310 14

      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = false;
      if (h && ((info->shared
		 && (!info->symbolic || info->allow_shlib_undefined))
		|| ! (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = true;

      need = 0;
      gotent_flags = 0;
a2311 1
      addend = rel->r_addend;
d2316 70
a2385 1
	  need = NEED_GOT | NEED_GOT_ENTRY;
d2387 43
a2429 12
	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;

	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;
d2437 3
a2439 32
	  need = NEED_GOT;
	  break;

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;

	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_ALPHA_TPREL64:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
	}

      if (need & NEED_GOT)
	{
d2453 1
a2453 1
	}
d2455 6
a2460 3
      if (need & NEED_GOT_ENTRY)
	{
	  struct alpha_elf_got_entry *gotent;
d2462 2
a2463 24
	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
	    return false;

	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;

		  /* Make a guess as to whether a .plt entry is needed.  */
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  else
		    h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	        }
	    }
	}

      if (need & NEED_DYNREL)
	{
d2533 1
a2533 1
	  else if (info->shared)
d2538 1
a2538 2
	      if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		  == (SEC_READONLY | SEC_ALLOC))
d2541 1
d2573 1
a2573 2
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
d2670 2
a2671 7
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
d2713 1
a2713 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2717 1
a2717 1
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
d2721 1
a2721 1
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
d2752 1
a2752 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2755 1
a2755 2
	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
d2771 1
a2771 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2776 1
a2776 1
    int e = alpha_elf_tdata (b)->local_got_size;
d2778 1
a2778 1
    alpha_elf_tdata (a)->local_got_size += e;
d2828 1
a2828 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2836 1
a2836 1
	      total += alpha_got_entry_size (be->reloc_type);
d2844 1
a2844 1
  alpha_elf_tdata (a)->total_got_size = total;
d2877 1
a2877 1
	*plge += alpha_got_entry_size (gotent->reloc_type);
d2919 1
a2919 1
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
d2931 2
a2932 1
elf64_alpha_size_got_sections (info)
d2953 1
a2953 1
          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
d2959 1
a2959 1
	         alpha_elf_tdata (this_got)->total_got_size);
a3005 71
/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */

static boolean
elf64_alpha_size_plt_section (info)
     struct bfd_link_info *info;
{
  asection *splt, *spltrel;
  unsigned long entries;
  bfd *dynobj;

  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_section_by_name(dynobj, ".plt");
  if (splt == NULL)
    return true;

  splt->_raw_size = 0;

  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_plt_section_1, splt);

  splt->_cooked_size = splt->_raw_size;

  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
  if (splt->_raw_size)
    entries = (splt->_raw_size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
  else
    entries = 0;
  spltrel->_raw_size = entries * sizeof (Elf64_External_Rela);
  spltrel->_cooked_size = spltrel->_raw_size;

  return true;
}

static boolean
elf64_alpha_size_plt_section_1 (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;

  /* If we didn't need an entry before, we still don't.  */
  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT))
    return true;

  /* There must still be a LITERAL got entry for the function.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      break;

  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
    {
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->_raw_size;
      splt->_raw_size += PLT_ENTRY_SIZE;
    }
  else
    {
      h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->root.plt.offset = -1;
    }

  return true;
}

d3008 1
a3008 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d3021 1
a3021 1
  if (!elf64_alpha_size_got_sections (info))
a3039 34
/* The number of dynamic relocations required by a static relocation.  */

static int
alpha_dynamic_entries_for_reloc (r_type, dynamic, shared)
     int r_type, dynamic, shared;
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
      return dynamic || shared;
    case R_ALPHA_GOTDTPREL:
    case R_ALPHA_GOTTPREL:
      return dynamic;

    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
      return dynamic || shared;
    case R_ALPHA_SREL64:
    case R_ALPHA_TPREL64:
      return dynamic;

    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
    default:
      return 0;
    }
}

a3046 4
  boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;

d3065 3
a3067 1
    h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3073 7
a3079 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d3081 9
a3089 12
  for (relent = h->reloc_entries; relent; relent = relent->next)
    {
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared);
      if (entries)
	{
	  relent->srel->_raw_size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
	}
    }
d3091 2
a3092 2
  return true;
}
d3094 2
a3095 1
/* Set the sizes of the dynamic relocation sections.  */
d3097 4
a3100 16
static boolean
elf64_alpha_size_rela_got_section (info)
     struct bfd_link_info *info;
{
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;

  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */

  entries = 0;
  for (i = alpha_elf_hash_table(info)->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;
d3102 1
a3102 1
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
d3104 3
a3106 13
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared));
a3109 58
  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!srel)
    {
      BFD_ASSERT (entries == 0);
      return true;
    }
  srel->_raw_size = sizeof (Elf64_External_Rela) * entries;

  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_rela_got_1, info);

  srel->_cooked_size = srel->_raw_size;

  return true;
}

/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */

static boolean
elf64_alpha_size_rela_got_1 (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */

  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);

  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela) * entries;
    }

d3143 13
a3155 1
				    elf64_alpha_calc_dynrel_sizes, info);
d3157 7
a3163 1
      elf64_alpha_size_rela_got_section (info);
a3266 65
/* Relocate an Alpha ELF section for a relocatable link.

   We don't have to change anything unless the reloc is against a section
   symbol, in which case we have to adjust according to where the section
   symbol winds up in the output section.  */

static boolean
elf64_alpha_relocate_section_r (output_bfd, info, input_bfd, input_section,
			        contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  unsigned long symtab_hdr_sh_info;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  boolean ret_val = true;

  symtab_hdr_sh_info = elf_tdata (input_bfd)->symtab_hdr.sh_info;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = false;
	  continue;
	}

      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol associated with GPDISP and LITUSE is
	 immaterial.  Only the addend is significant.  */
      if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	continue;

      if (r_symndx < symtab_hdr_sh_info)
	{
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
	    {
	      sec = local_sections[r_symndx];
	      rel->r_addend += sec->output_offset + sym->st_value;
	    }
	}
    }

  return ret_val;
}

d3284 1
a3284 2
  struct elf_link_tls_segment *tls_segment;
  asection *sgot, *srel, *srelgot;
d3286 2
a3287 14
  bfd_vma gp, tp_base, dtp_base;
  struct alpha_elf_got_entry **local_got_entries;
  boolean ret_val;
  const char *section_name;

  /* Handle relocatable links with a smaller loop.  */
  if (info->relocateable)
    return elf64_alpha_relocate_section_r (output_bfd, info, input_bfd,
					   input_section, contents, relocs,
					   local_syms, local_sections);

  /* This is a final link.  */

  ret_val = true;
d3289 1
a3290 1

d3293 3
a3295 9
    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  else
    srelgot = NULL;

  section_name = (bfd_elf_string_from_elf_section
		  (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		   elf_section_data(input_section)->rel_hdr.sh_name));
  BFD_ASSERT(section_name != NULL);
  srel = bfd_get_section_by_name (dynobj, section_name);
d3298 2
a3312 16
  else
    {
      sgot = NULL;
      gp = 0;
    }

  local_got_entries = alpha_elf_tdata(input_bfd)->local_got_entries;

  tls_segment = elf_hash_table (info)->tls_segment;
  if (tls_segment)
    {
      dtp_base = alpha_get_dtprel_base (tls_segment);
      tp_base = alpha_get_tprel_base (tls_segment);
    }
  else
    dtp_base = tp_base = 0;
d3314 1
d3316 1
a3316 1
  for (rel = relocs; rel < relend; rel++)
d3318 1
a3318 3
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;
      bfd_reloc_status_type r;
d3321 3
a3323 3
      Elf_Internal_Sym *sym = NULL;
      asection *sec = NULL;
      bfd_vma value;
d3325 1
a3325 3
      boolean dynamic_symbol_p;
      boolean undef_weak_ref = false;
      unsigned long r_type;
d3328 1
a3328 1
      if (r_type >= R_ALPHA_max)
a3329 3
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d3331 1
a3331 2
	  ret_val = false;
	  continue;
d3333 1
a3334 1
      howto = elf64_alpha_howto_table + r_type;
d3337 1
a3337 1
      if (r_symndx < symtab_hdr->sh_info)
d3339 9
a3347 3
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d3349 1
a3349 13
	  if (local_got_entries)
	    gotent = local_got_entries[r_symndx];
	  else
	    gotent = NULL;

	  /* Need to adjust local GOT entries' addends for SEC_MERGE
	     unless it has been done already.  */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && (elf_section_data (sec)->sec_info_type
		  == ELF_INFO_TYPE_MERGE)
	      && gotent
	      && !gotent->reloc_xlated)
d3351 2
a3352 4
	      struct alpha_elf_got_entry *ent;
	      asection *msec;

	      for (ent = gotent; ent; ent = ent->next)
d3354 2
a3355 15
		  ent->reloc_xlated = 1;
		  if (ent->use_count == 0)
		    continue;
		  msec = sec;
		  ent->addend =
		    _bfd_merged_section_offset (output_bfd, &msec,
						elf_section_data (sec)->
						  sec_info,
						sym->st_value + ent->addend,
						(bfd_vma) 0);
		  ent->addend -= sym->st_value;
		  ent->addend += msec->output_section->vma
				 + msec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset;
d3359 14
a3372 1
	  dynamic_symbol_p = false;
a3381 1
	  value = 0;
d3387 8
a3394 12
	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */

	      if (sec->output_section != NULL)
		value = (h->root.root.u.def.value
			 + sec->output_section->vma
			      + sec->output_offset);
d3397 1
a3397 1
	    undef_weak_ref = true;
d3402 1
a3402 1
	    ;
d3410 2
a3411 3
		return false;
	      ret_val = false;
	      continue;
a3412 3

          dynamic_symbol_p = alpha_elf_dynamic_symbol_p (&h->root, info);
	  gotent = h->got_entries;
a3413 1

a3414 8
      value += addend;

      /* Search for the proper got entry.  */
      for (; gotent ; gotent = gotent->next)
	if (gotent->gotobj == gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == addend)
	  break;
d3424 3
a3426 3
	    value = (input_section->output_section->vma
		     + input_section->output_offset
		     + rel->r_offset);
d3428 1
a3428 1
	    p_ldah = contents + rel->r_offset;
d3431 1
a3431 1
	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - value,
d3437 55
a3491 4
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);
d3493 1
a3493 3
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;
d3495 5
a3499 2
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
d3501 6
a3506 6
	      /* If the symbol has been forced local, output a
		 RELATIVE reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		{
		  Elf_Internal_Rela outrel;
d3508 1
a3508 1
		  BFD_ASSERT(srelgot != NULL);
d3510 14
a3523 5
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		  outrel.r_addend = value;
d3525 2
a3526 9
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}
	    }
d3528 8
a3535 4
	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
d3541 1
a3541 1
	  if (dynamic_symbol_p)
d3549 1
a3549 1
	  value -= gp;
d3553 1
a3553 1
	  if (dynamic_symbol_p)
d3561 5
a3565 2
	  value -= gp;
	  value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
d3571 1
a3571 1
	  if (dynamic_symbol_p)
d3576 1
a3576 4
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;
a3578 7
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
d3581 1
a3581 1
	  value -= 4;
d3591 1
a3591 1
	    value -= 4;
d3596 1
a3596 1
	       it might not have had any relocations at all.  Also take
a3643 2
	case R_ALPHA_DTPREL64:
	case R_ALPHA_TPREL64:
d3650 1
a3650 1
	    if (dynamic_symbol_p)
d3653 1
a3653 1
		outrel.r_info = ELF64_R_INFO (h->root.dynindx, r_type);
d3655 1
a3655 13
		addend = 0, value = 0;
	      }
	    else if (r_type == R_ALPHA_DTPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		value -= dtp_base;
		goto default_reloc;
	      }
	    else if (r_type == R_ALPHA_TPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		value -= dtp_base;
		goto default_reloc;
d3661 2
a3662 10
		if (r_type == R_ALPHA_REFLONG)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unhandled dynamic relocation against %s"),
		       bfd_archive_filename (input_bfd),
		       h->root.root.root.string);
		    ret_val = false;
		  }
		outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		outrel.r_addend = value;
d3667 12
a3678 1
	    BFD_ASSERT(srel != NULL);
a3697 1
	case R_ALPHA_SREL16:
a3699 8
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }

a3707 124
	case R_ALPHA_TLSLDM:
	  /* Ignore the symbol for the relocation.  The result is always
	     the current module.  */
	  dynamic_symbol_p = 0;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      /* Note that the module index for the main program is 1.  */
	      bfd_put_64 (output_bfd, !info->shared && !dynamic_symbol_p,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 DTPMOD64 reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		{
		  Elf_Internal_Rela outrel;

		  BFD_ASSERT(srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  /* ??? Proper dynindx here.  */
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_DTPMOD64);
		  outrel.r_addend = 0;

		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}

	      if (dynamic_symbol_p || r_type == R_ALPHA_TLSLDM)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
	          value -= dtp_base;
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset + 8);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_DTPRELHI:
	case R_ALPHA_DTPRELLO:
	case R_ALPHA_DTPREL16:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: dtp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= dtp_base;
	  if (r_type == R_ALPHA_DTPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_TPRELHI:
	case R_ALPHA_TPRELLO:
	case R_ALPHA_TPREL16:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: TLS local exec code cannot be linked into shared objects"),
		bfd_archive_filename (input_bfd));
              ret_val = false;
	    }
	  else if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: tp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= tp_base;
	  if (r_type == R_ALPHA_TPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      if (dynamic_symbol_p)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
		  value -= (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

d3711 2
a3712 1
					contents, rel->r_offset, value, 0);
d3884 1
d3889 1
a3889 7
	  asection *sgot;
	  int r_type;

	  if (gotent->use_count == 0)
	    continue;

	  sgot = alpha_elf_tdata (gotent->gotobj)->got;
a3892 22

	  r_type = gotent->reloc_type;
	  switch (r_type)
	    {
	    case R_ALPHA_LITERAL:
	      r_type = R_ALPHA_GLOB_DAT;
	      break;
	    case R_ALPHA_TLSGD:
	      r_type = R_ALPHA_DTPMOD64;
	      break;
	    case R_ALPHA_GOTDTPREL:
	      r_type = R_ALPHA_DTPREL64;
	      break;
	    case R_ALPHA_GOTTPREL:
	      r_type = R_ALPHA_TPREL64;
	      break;
	    case R_ALPHA_TLSLDM:
	    default:
	      abort ();
	    }

	  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
a3897 11

	  if (gotent->reloc_type == R_ALPHA_TLSGD)
	    {
	      outrel.r_offset += 8;
	      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_DTPREL64);

	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				         ((Elf64_External_Rela *)srel->contents
				          + srel->reloc_count++));
	    }

a4357 1
  bfd_elf64_swap_symbol_in,
@


1.62.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2040 1
d2042 1
d2044 4
a2047 1
  Elf_Internal_Sym *isymbuf = NULL;
d2073 3
a2075 1
    return false;
d2104 1
d2111 28
d2147 1
d2170 2
a2171 1
	  Elf_Internal_Sym *isym;
d2173 5
a2177 14
	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
d2179 1
a2179 1
	  else if (isym->st_shndx == SHN_ABS)
d2181 1
a2181 1
	  else if (isym->st_shndx == SHN_COMMON)
d2184 1
a2184 1
	    info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d2187 1
a2187 1
	  info.other = isym->st_other;
d2189 1
a2189 1
	  symval = isym->st_value;
d2284 8
a2291 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d2293 2
a2294 2
      if (!link_info->keep_memory)
	free (isymbuf);
d2297 2
a2298 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d2302 4
a2305 2
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
d2307 2
a2308 2
      if (!info.changed_contents && !link_info->keep_memory)
	free (info.contents);
d2311 2
a2312 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = info.contents;
a2315 8
  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!info.changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

d2321 8
a2328 9
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    free (info.contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d2609 3
a2611 2
  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
d4152 3
d4157 1
a4157 2
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
@


1.62.6.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d3406 1
a3406 1
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
d5483 1
a5483 1
static const struct elf_size_info alpha_elf_size_info =
a5511 1
#ifndef ELF_ARCH
a5516 1
#endif /* ELF_ARCH */
@


1.62.6.4
log
@merge from mainline
@
text
@a2482 1
  struct bfd_link_hash_entry *bh;
d2498 1
a2498 1
  bh = NULL;
d2502 2
a2503 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a2504 1
  h = (struct elf_link_hash_entry *) bh;
d2542 1
a2542 1
  bh = NULL;
d2546 2
a2547 1
	 false, get_elf_backend_data (abfd)->collect, &bh)))
a2548 1
  h = (struct elf_link_hash_entry *) bh;
d3102 1
a3102 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
d4579 1
a4579 1
		value += 8;
d5512 1
d5518 1
a5581 39

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static void
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#define elf64_bed elf64_alpha_fbsd_bed
@


1.62.4.1
log
@merge from trunk
@
text
@d76 1
a76 1
  PARAMS((bfd *, Elf64_Internal_Shdr *, const char *));
d109 1
a109 5
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_plt_section_1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
a111 2
static int alpha_dynamic_entries_for_reloc
  PARAMS ((int, int, int));
a113 4
static boolean elf64_alpha_size_rela_got_section
  PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_rela_got_1
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
a116 3
static struct alpha_elf_got_entry *get_got_entry
  PARAMS ((bfd *, struct alpha_elf_link_hash_entry *, unsigned long,
	   unsigned long, bfd_vma));
a123 3
static boolean elf64_alpha_relocate_section_r
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d151 5
a155 9
  /* Contexts in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR	0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	0x20
#define ALPHA_ELF_LINK_HASH_LU_FUNC	0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	0x40
d171 1
a171 5
    /* How many references to this entry?  */
    int use_count;

    /* The relocation type of this entry.  */
    unsigned char reloc_type;
d173 3
a175 2
    /* How a LITERAL is used.  */
    unsigned char flags;
d177 1
a177 5
    /* Have we initialized the dynamic relocation for this entry?  */
    unsigned char reloc_done;

    /* Have we adjusted this entry for SEC_MERGE?  */
    unsigned char reloc_xlated;
d364 2
a365 2
  /* For every got, this is it's total number of words.  */
  int total_got_size;
d367 1
a367 1
  /* For every got, this is the sum of the number of words required
d369 1
a369 1
  int local_got_size;
a750 197

  /* Creates a tls_index for the symbol in the got.  */
  HOWTO (R_ALPHA_TLSGD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSGD",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a tls_index for the (current) module in the got.  */
  HOWTO (R_ALPHA_TLSLDM,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSLDM",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a DTP module entry.  */
  HOWTO (R_ALPHA_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPMOD64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from DTP to the target.  */
  HOWTO (R_ALPHA_GOTDTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTDTPREL",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELHI",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELLO",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 16-bit displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL16",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from TP to the target.  */
  HOWTO (R_ALPHA_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTTPREL",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL64",		/* name */
	 false,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELHI",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELLO",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 16-bit displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL16",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a904 13
  {BFD_RELOC_ALPHA_TLSGD,		R_ALPHA_TLSGD},
  {BFD_RELOC_ALPHA_TLSLDM,		R_ALPHA_TLSLDM},
  {BFD_RELOC_ALPHA_DTPMOD64,		R_ALPHA_DTPMOD64},
  {BFD_RELOC_ALPHA_GOTDTPREL16,		R_ALPHA_GOTDTPREL},
  {BFD_RELOC_ALPHA_DTPREL64,		R_ALPHA_DTPREL64},
  {BFD_RELOC_ALPHA_DTPREL_HI16,		R_ALPHA_DTPRELHI},
  {BFD_RELOC_ALPHA_DTPREL_LO16,		R_ALPHA_DTPRELLO},
  {BFD_RELOC_ALPHA_DTPREL16,		R_ALPHA_DTPREL16},
  {BFD_RELOC_ALPHA_GOTTPREL16,		R_ALPHA_GOTTPREL},
  {BFD_RELOC_ALPHA_TPREL64,		R_ALPHA_TPREL64},
  {BFD_RELOC_ALPHA_TPREL_HI16,		R_ALPHA_TPRELHI},
  {BFD_RELOC_ALPHA_TPREL_LO16,		R_ALPHA_TPRELLO},
  {BFD_RELOC_ALPHA_TPREL16,		R_ALPHA_TPREL16},
a938 13

/* These two relocations create a two-word entry in the got.  */
#define alpha_got_entry_size(r_type) \
  (r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)

/* This is PT_TLS segment p_vaddr.  */
#define alpha_get_dtprel_base(tlss) \
  ((tlss)->start)

/* Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */
#define alpha_get_tprel_base(tlss) \
  ((tlss)->start - align_power ((bfd_vma) 16, (tlss)->align))
a960 2
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e
a966 1
  Elf_Internal_Shdr *symtab_hdr;
d969 2
a970 1
  struct elf_link_tls_segment *tls_segment;
a974 1
  struct alpha_elf_got_entry **first_gotent;
a975 2
  boolean changed_contents;
  boolean changed_relocs;
d979 5
a983 1
static boolean elf64_alpha_relax_with_lituse
d986 1
d989 1
a989 11
static boolean elf64_alpha_relax_got_load
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, unsigned long));
static boolean elf64_alpha_relax_gprelhilo
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, boolean));
static boolean elf64_alpha_relax_tls_get_addr
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, boolean));
static struct elf_link_tls_segment *elf64_alpha_relax_find_tls_segment
  PARAMS((struct alpha_relax_info *, struct elf_link_tls_segment *));
d1010 2
a1011 2
static boolean
elf64_alpha_relax_with_lituse (info, symval, irel)
d1014 1
a1014 1
     Elf_Internal_Rela *irel;
d1016 1
a1016 1
  Elf_Internal_Rela *urel, *irelend = info->relend;
d1032 1
a1032 1
      return true;
a1034 4
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return true;

d1057 1
a1057 2
	case LITUSE_ALPHA_ADDR:
	default:
d1063 1
a1063 1
	case LITUSE_ALPHA_BASE:
d1070 2
a1071 2
	  if (insn_disp & 0x8000)
	    insn_disp |= ~0xffff;  /* Negative: sign-extend.  */
d1074 2
a1075 3
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);
d1114 1
a1114 1
	case LITUSE_ALPHA_BYTOFF:
d1132 1
a1132 3
	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
d1134 5
a1138 1
	    bfd_vma optdest, org;
a1140 5
	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
a1141 1

d1183 1
a1183 2
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
d1186 1
a1186 1
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
d1216 4
a1219 7
      if (--info->gotent->use_count == 0)
	{
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
	}
d1222 2
a1223 2
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
d1236 1
a1236 1
  return true;
d1312 1
a1312 1
elf64_alpha_relax_got_load (info, symval, irel, r_type)
a1315 1
     unsigned long r_type;
a1324 1
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
d1326 1
a1326 1
       ("%s: %s+0x%lx: warning: %s relocation against unexpected insn",
d1328 1
a1328 1
	(unsigned long) irel->r_offset, howto->name));
d1332 3
a1334 3
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return true;
d1336 2
a1337 2
  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
d1340 2
a1341 14
  if (r_type == R_ALPHA_LITERAL)
    disp = symval - info->gp;
  else
    {
      bfd_vma dtp_base, tp_base;

      BFD_ASSERT (info->tls_segment != NULL);
      dtp_base = alpha_get_dtprel_base (info->tls_segment);
      tp_base = alpha_get_tprel_base (info->tls_segment);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
    }

  if (disp < -0x8000 || disp >= 0x8000)
    return true;
d1343 1
a1343 6
  /* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading
     a constant, so force the base register to be $31.  */
  if (r_type == R_ALPHA_LITERAL)
    insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  else
    insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
d1347 1
a1347 17
  switch (r_type)
    {
    case R_ALPHA_LITERAL:
      r_type = R_ALPHA_GPREL16;
      break;
    case R_ALPHA_GOTDTPREL:
      r_type = R_ALPHA_DTPREL16;
      break;
    case R_ALPHA_GOTTPREL:
      r_type = R_ALPHA_TPREL16;
      break;
    default:
      BFD_ASSERT (0);
      return false;
    }

  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
d1352 4
a1355 7
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }
d1374 5
a1378 5
elf64_alpha_relax_gprelhilo (info, symval, irel, hi)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     boolean hi;
d1380 11
a1390 3
  unsigned int insn;
  bfd_signed_vma disp;
  bfd_byte *pos = info->contents + irel->r_offset;
d1392 2
a1393 1
  /* ??? This assumes that the compiler doesn't render
d1395 3
a1397 12
	array[i]
     as
	ldah	t, array(gp)	!gprelhigh
	s8addl	i, t, t
	ldq	r, array(t)	!gprellow

     which would indeed be the most efficient way to implement this.  */

  return true;

  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
d1400 4
a1403 3
  if (hi)
    {
      /* Nop out the high instruction.  */
d1405 2
a1406 2
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos);
      info->changed_contents = true;
d1408 2
a1409 351
      irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      irel->r_addend = 0;
      info->changed_relocs = true;
    }
  else
    {
      /* Adjust the low instruction to reference GP directly.  */

      insn = bfd_get_32 (info->abfd, pos);
      insn = (insn & 0xffe00000) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos);
      info->changed_contents = true;

      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				   R_ALPHA_GPREL16);
      info->changed_relocs = true;
    }

  return true;
}

static boolean
elf64_alpha_relax_tls_get_addr (info, symval, irel, is_gd)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     boolean is_gd;
{
  bfd_byte *pos[5];
  unsigned int insn;
  Elf_Internal_Rela *gpdisp, *hint;
  boolean dynamic, use_gottprel;

  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);

  /* ??? For LD relaxation, we need a symbol referencing the beginning
     of the TLS segment.  */
  if (!is_gd)
    return true;

  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;

  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;

  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return true;

  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return true;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return true;

  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return true;

  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;

  /* Only positions 0 and 1 are allowed to be out of order.  */
  if (pos[1] < pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  if (pos[1] >= pos[2] || pos[2] >= pos[3] || pos[3] >= pos[4])
    return true;

  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;

    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];

    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;

    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);

    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }

  /* Change

	lda	$16,x($gp)		!tlsgd!1
	ldq	$27,__tls_get_addr($gp)	!literal!1
	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)		!gpdisp!2
	lda	$29,0($29)		!gpdisp!2
     to
	ldq	$16,x($gp)		!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)		!tprel
	unop
     or
	ldah	$16,x($gp)		!tprelhi
	lda	$16,x($16)		!tprello

     as appropriate.  */

  use_gottprel = false;
  switch (!dynamic && !info->link_info->shared)
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (info->tls_segment != NULL);
	tp_base = alpha_get_tprel_base (info->tls_segment);
	disp = symval - tp_base;

	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000)
	  {
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */

    default:
      use_gottprel = true;

      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				     R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
    }

  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);

  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);

  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);

  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  info->changed_contents = true;
  info->changed_relocs = true;

  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;

      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
	{
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return false;

	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;

	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }

	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
    }

  return true;
}

static struct elf_link_tls_segment *
elf64_alpha_relax_find_tls_segment (info, seg)
     struct alpha_relax_info *info;
     struct elf_link_tls_segment *seg;
{
  bfd *output_bfd = info->sec->output_section->owner;
  asection *o;
  unsigned int align;
  bfd_vma base, end;

  for (o = output_bfd->sections; o ; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
        && (o->flags & SEC_LOAD) != 0)
      break;
  if (!o)
    return NULL;

  base = o->vma;
  align = 0;

  do
    {
      bfd_vma size;

      if (bfd_get_section_alignment (output_bfd, o) > align)
	align = bfd_get_section_alignment (output_bfd, o);

      size = o->_raw_size;
      if (size == 0 && (o->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *lo;
	  for (lo = o->link_order_head; lo ; lo = lo->next)
	    if (size < lo->offset + lo->size)
	      size = lo->offset + lo->size;
	}
      end = o->vma + size;
      o = o->next;
    }
  while (o && (o->flags & SEC_THREAD_LOCAL));

  seg->start = base;
  seg->size = end - base;
  seg->align = align;

  return seg;
}

static boolean
elf64_alpha_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *free_contents = NULL;
  Elf64_External_Sym *extsyms;
  Elf64_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;
  struct elf_link_tls_segment tls_segment;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = false;

  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return true;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf64_link_read_relocs
a1420 1
  info.symtab_hdr = symtab_hdr;
d1424 1
a1424 2
  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
d1429 8
a1436 3
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
d1439 1
a1439 4
  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
  else
d1441 8
a1448 1
      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
d1450 9
a1458 2
	goto error_return;
      free_contents = info.contents;
d1460 5
a1464 4
      if (! bfd_get_section_contents (abfd, sec, info.contents,
				      (file_ptr) 0, sec->_raw_size))
	goto error_return;
    }
d1466 1
a1466 7
  /* Read this BFD's symbols.  */
  if (symtab_hdr->contents != NULL)
    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
  else
    {
      bfd_size_type amt = symtab_hdr->sh_info * sizeof (Elf64_External_Sym);
      extsyms = (Elf64_External_Sym *) bfd_malloc (amt);
d1468 2
a1469 24
	goto error_return;
      free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
	goto error_return;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;
      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	goto error_return;
    }

  /* Compute the TLS segment information.  The version normally found in
     elf_hash_table (link_info)->tls_segment isn't built until final_link.
     ??? Probably should look into extracting this into a common function.  */
  info.tls_segment = elf64_alpha_relax_find_tls_segment (&info, &tls_segment);
d1471 14
a1484 6
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      Elf_Internal_Sym isym;
      struct alpha_elf_got_entry *gotent;
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
d1486 12
a1497 13
      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  break;
	default:
	  continue;
d1509 1
a1509 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d1511 1
a1511 1
	    continue;
d1521 1
a1521 1
	  info.first_gotent = &local_got_entries[ELF64_R_SYM(irel->r_info)];
d1537 4
a1540 8
	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefweak
	      || h->root.root.type == bfd_link_hash_undefined)
	    continue;

	  /* If the symbol isn't defined in the current module, again
	     we can't do anything.  */
	  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1546 1
a1546 1
	  info.first_gotent = &h->got_entries;
d1551 2
a1552 5
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
d1558 1
a1558 4
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);
d1560 3
a1562 15
	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
	    }
	  break;
d1564 4
a1567 4
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  if (!elf64_alpha_relax_gprelhilo (&info, symval, irel,
					    r_type == R_ALPHA_GPRELHIGH))
d1569 4
a1572 14
	  break;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
	    goto error_return;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
a1573 1
	  break;
d1577 1
a1577 5
  if (!elf64_alpha_size_plt_section (link_info))
    return false;
  if (!elf64_alpha_size_got_sections (link_info))
    return false;
  if (!elf64_alpha_size_rela_got_section (link_info))
d1581 3
a1583 1
    elf_section_data (sec)->relocs = internal_relocs;
d1585 3
a1587 1
    free (free_relocs);
d1590 3
a1592 1
    elf_section_data (sec)->this_hdr.contents = info.contents;
d1646 1
a1646 1
#define MAX_GOT_SIZE		(64*1024)
d1659 1
a1659 1
     const char *name;
d2247 11
d2259 1
a2259 1
/* Search for and possibly create a got entry.  */
d2261 2
a2262 2
static struct alpha_elf_got_entry *
get_got_entry (abfd, h, r_type, r_symndx, r_addend)
d2264 3
a2266 3
     struct alpha_elf_link_hash_entry *h;
     unsigned long r_type, r_symndx;
     bfd_vma r_addend;
d2268 9
a2276 2
  struct alpha_elf_got_entry *gotent;
  struct alpha_elf_got_entry **slot;
d2278 2
a2279 5
  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */
d2281 3
a2283 1
      struct alpha_elf_got_entry **local_got_entries;
d2285 1
a2285 85
      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);

	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;

	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
    {
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
    }
  else
    gotent->use_count += 1;

  return gotent;
}

/* Handle dynamic relocations when doing an Alpha ELF link.  */

static boolean
elf64_alpha_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  bfd *dynobj;
  asection *sreloc;
  const char *rel_sec_name;
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  boolean got_created;
  bfd_size_type amt;

  if (info->relocateable)
    return true;

  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj == NULL)
    elf_hash_table(info)->dynobj = dynobj = abfd;

  sreloc = NULL;
d2289 2
a2290 1
  got_created = false;
a2294 6
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };

a2296 4
      unsigned int gotent_flags;
      boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;
a2310 14

      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = false;
      if (h && ((info->shared
		 && (!info->symbolic || info->allow_shlib_undefined))
		|| ! (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = true;

      need = 0;
      gotent_flags = 0;
a2311 1
      addend = rel->r_addend;
d2316 70
a2385 1
	  need = NEED_GOT | NEED_GOT_ENTRY;
d2387 43
a2429 12
	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;

	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;
d2437 3
a2439 32
	  need = NEED_GOT;
	  break;

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;

	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_ALPHA_TPREL64:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
	}

      if (need & NEED_GOT)
	{
d2453 1
a2453 1
	}
d2455 6
a2460 3
      if (need & NEED_GOT_ENTRY)
	{
	  struct alpha_elf_got_entry *gotent;
d2462 2
a2463 24
	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
	    return false;

	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;

		  /* Make a guess as to whether a .plt entry is needed.  */
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  else
		    h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	        }
	    }
	}

      if (need & NEED_DYNREL)
	{
d2533 1
a2533 1
	  else if (info->shared)
d2538 1
a2538 2
	      if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		  == (SEC_READONLY | SEC_ALLOC))
d2541 1
d2573 1
a2573 2
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
d2670 2
a2671 7
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
d2713 1
a2713 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2717 1
a2717 1
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
d2721 1
a2721 1
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
d2752 1
a2752 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2755 1
a2755 2
	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
d2771 1
a2771 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2776 1
a2776 1
    int e = alpha_elf_tdata (b)->local_got_size;
d2778 1
a2778 1
    alpha_elf_tdata (a)->local_got_size += e;
d2828 1
a2828 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2836 1
a2836 1
	      total += alpha_got_entry_size (be->reloc_type);
d2844 1
a2844 1
  alpha_elf_tdata (a)->total_got_size = total;
d2877 1
a2877 1
	*plge += alpha_got_entry_size (gotent->reloc_type);
d2919 1
a2919 1
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
d2931 2
a2932 1
elf64_alpha_size_got_sections (info)
d2953 1
a2953 1
          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
d2959 1
a2959 1
	         alpha_elf_tdata (this_got)->total_got_size);
a3005 71
/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */

static boolean
elf64_alpha_size_plt_section (info)
     struct bfd_link_info *info;
{
  asection *splt, *spltrel;
  unsigned long entries;
  bfd *dynobj;

  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_section_by_name(dynobj, ".plt");
  if (splt == NULL)
    return true;

  splt->_raw_size = 0;

  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_plt_section_1, splt);

  splt->_cooked_size = splt->_raw_size;

  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
  if (splt->_raw_size)
    entries = (splt->_raw_size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
  else
    entries = 0;
  spltrel->_raw_size = entries * sizeof (Elf64_External_Rela);
  spltrel->_cooked_size = spltrel->_raw_size;

  return true;
}

static boolean
elf64_alpha_size_plt_section_1 (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;

  /* If we didn't need an entry before, we still don't.  */
  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT))
    return true;

  /* There must still be a LITERAL got entry for the function.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      break;

  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
    {
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->_raw_size;
      splt->_raw_size += PLT_ENTRY_SIZE;
    }
  else
    {
      h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->root.plt.offset = -1;
    }

  return true;
}

d3008 1
a3008 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d3021 1
a3021 1
  if (!elf64_alpha_size_got_sections (info))
a3039 34
/* The number of dynamic relocations required by a static relocation.  */

static int
alpha_dynamic_entries_for_reloc (r_type, dynamic, shared)
     int r_type, dynamic, shared;
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
      return dynamic || shared;
    case R_ALPHA_GOTDTPREL:
    case R_ALPHA_GOTTPREL:
      return dynamic;

    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
      return dynamic || shared;
    case R_ALPHA_SREL64:
    case R_ALPHA_TPREL64:
      return dynamic;

    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
    default:
      return 0;
    }
}

a3046 4
  boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;

d3065 3
a3067 1
    h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3073 7
a3079 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d3081 9
a3089 12
  for (relent = h->reloc_entries; relent; relent = relent->next)
    {
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared);
      if (entries)
	{
	  relent->srel->_raw_size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
	}
    }
d3091 2
a3092 2
  return true;
}
d3094 2
a3095 1
/* Set the sizes of the dynamic relocation sections.  */
d3097 4
a3100 16
static boolean
elf64_alpha_size_rela_got_section (info)
     struct bfd_link_info *info;
{
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;

  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */

  entries = 0;
  for (i = alpha_elf_hash_table(info)->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;
d3102 1
a3102 1
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
d3104 3
a3106 13
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared));
a3109 58
  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!srel)
    {
      BFD_ASSERT (entries == 0);
      return true;
    }
  srel->_raw_size = sizeof (Elf64_External_Rela) * entries;

  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_rela_got_1, info);

  srel->_cooked_size = srel->_raw_size;

  return true;
}

/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */

static boolean
elf64_alpha_size_rela_got_1 (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */

  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);

  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela) * entries;
    }

d3143 13
a3155 1
				    elf64_alpha_calc_dynrel_sizes, info);
d3157 7
a3163 1
      elf64_alpha_size_rela_got_section (info);
a3266 65
/* Relocate an Alpha ELF section for a relocatable link.

   We don't have to change anything unless the reloc is against a section
   symbol, in which case we have to adjust according to where the section
   symbol winds up in the output section.  */

static boolean
elf64_alpha_relocate_section_r (output_bfd, info, input_bfd, input_section,
			        contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  unsigned long symtab_hdr_sh_info;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  boolean ret_val = true;

  symtab_hdr_sh_info = elf_tdata (input_bfd)->symtab_hdr.sh_info;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = false;
	  continue;
	}

      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol associated with GPDISP and LITUSE is
	 immaterial.  Only the addend is significant.  */
      if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	continue;

      if (r_symndx < symtab_hdr_sh_info)
	{
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
	    {
	      sec = local_sections[r_symndx];
	      rel->r_addend += sec->output_offset + sym->st_value;
	    }
	}
    }

  return ret_val;
}

d3284 1
a3284 2
  struct elf_link_tls_segment *tls_segment;
  asection *sgot, *srel, *srelgot;
d3286 2
a3287 14
  bfd_vma gp, tp_base, dtp_base;
  struct alpha_elf_got_entry **local_got_entries;
  boolean ret_val;
  const char *section_name;

  /* Handle relocatable links with a smaller loop.  */
  if (info->relocateable)
    return elf64_alpha_relocate_section_r (output_bfd, info, input_bfd,
					   input_section, contents, relocs,
					   local_syms, local_sections);

  /* This is a final link.  */

  ret_val = true;
d3289 1
a3290 1

d3293 3
a3295 9
    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  else
    srelgot = NULL;

  section_name = (bfd_elf_string_from_elf_section
		  (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		   elf_section_data(input_section)->rel_hdr.sh_name));
  BFD_ASSERT(section_name != NULL);
  srel = bfd_get_section_by_name (dynobj, section_name);
d3298 2
a3312 16
  else
    {
      sgot = NULL;
      gp = 0;
    }

  local_got_entries = alpha_elf_tdata(input_bfd)->local_got_entries;

  tls_segment = elf_hash_table (info)->tls_segment;
  if (tls_segment)
    {
      dtp_base = alpha_get_dtprel_base (tls_segment);
      tp_base = alpha_get_tprel_base (tls_segment);
    }
  else
    dtp_base = tp_base = 0;
d3314 1
d3316 1
a3316 1
  for (rel = relocs; rel < relend; rel++)
d3318 1
a3318 3
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;
      bfd_reloc_status_type r;
d3321 3
a3323 3
      Elf_Internal_Sym *sym = NULL;
      asection *sec = NULL;
      bfd_vma value;
d3325 1
a3325 3
      boolean dynamic_symbol_p;
      boolean undef_weak_ref = false;
      unsigned long r_type;
d3328 1
a3328 1
      if (r_type >= R_ALPHA_max)
a3329 3
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d3331 1
a3331 2
	  ret_val = false;
	  continue;
d3333 1
a3334 1
      howto = elf64_alpha_howto_table + r_type;
d3337 1
a3337 1
      if (r_symndx < symtab_hdr->sh_info)
d3339 9
a3347 3
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d3349 1
a3349 13
	  if (local_got_entries)
	    gotent = local_got_entries[r_symndx];
	  else
	    gotent = NULL;

	  /* Need to adjust local GOT entries' addends for SEC_MERGE
	     unless it has been done already.  */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && (elf_section_data (sec)->sec_info_type
		  == ELF_INFO_TYPE_MERGE)
	      && gotent
	      && !gotent->reloc_xlated)
d3351 2
a3352 4
	      struct alpha_elf_got_entry *ent;
	      asection *msec;

	      for (ent = gotent; ent; ent = ent->next)
d3354 2
a3355 15
		  ent->reloc_xlated = 1;
		  if (ent->use_count == 0)
		    continue;
		  msec = sec;
		  ent->addend =
		    _bfd_merged_section_offset (output_bfd, &msec,
						elf_section_data (sec)->
						  sec_info,
						sym->st_value + ent->addend,
						(bfd_vma) 0);
		  ent->addend -= sym->st_value;
		  ent->addend += msec->output_section->vma
				 + msec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset;
d3359 14
a3372 1
	  dynamic_symbol_p = false;
a3381 1
	  value = 0;
d3387 8
a3394 12
	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */

	      if (sec->output_section != NULL)
		value = (h->root.root.u.def.value
			 + sec->output_section->vma
			      + sec->output_offset);
d3397 1
a3397 1
	    undef_weak_ref = true;
d3402 1
a3402 1
	    ;
d3410 2
a3411 3
		return false;
	      ret_val = false;
	      continue;
a3412 3

          dynamic_symbol_p = alpha_elf_dynamic_symbol_p (&h->root, info);
	  gotent = h->got_entries;
a3413 1

a3414 8
      value += addend;

      /* Search for the proper got entry.  */
      for (; gotent ; gotent = gotent->next)
	if (gotent->gotobj == gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == addend)
	  break;
d3424 3
a3426 3
	    value = (input_section->output_section->vma
		     + input_section->output_offset
		     + rel->r_offset);
d3428 1
a3428 1
	    p_ldah = contents + rel->r_offset;
d3431 1
a3431 1
	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - value,
d3437 55
a3491 4
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);
d3493 1
a3493 3
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;
d3495 5
a3499 2
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
d3501 6
a3506 6
	      /* If the symbol has been forced local, output a
		 RELATIVE reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		{
		  Elf_Internal_Rela outrel;
d3508 1
a3508 1
		  BFD_ASSERT(srelgot != NULL);
d3510 14
a3523 5
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		  outrel.r_addend = value;
d3525 2
a3526 9
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}
	    }
d3528 8
a3535 4
	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
d3541 1
a3541 1
	  if (dynamic_symbol_p)
d3549 1
a3549 1
	  value -= gp;
d3553 1
a3553 1
	  if (dynamic_symbol_p)
d3561 5
a3565 2
	  value -= gp;
	  value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
d3571 1
a3571 1
	  if (dynamic_symbol_p)
d3576 1
a3576 4
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;
a3578 7
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
d3581 1
a3581 1
	  value -= 4;
d3591 1
a3591 1
	    value -= 4;
d3596 1
a3596 1
	       it might not have had any relocations at all.  Also take
a3643 2
	case R_ALPHA_DTPREL64:
	case R_ALPHA_TPREL64:
d3650 1
a3650 1
	    if (dynamic_symbol_p)
d3653 1
a3653 1
		outrel.r_info = ELF64_R_INFO (h->root.dynindx, r_type);
d3655 1
a3655 13
		addend = 0, value = 0;
	      }
	    else if (r_type == R_ALPHA_DTPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		value -= dtp_base;
		goto default_reloc;
	      }
	    else if (r_type == R_ALPHA_TPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		value -= dtp_base;
		goto default_reloc;
d3661 2
a3662 10
		if (r_type == R_ALPHA_REFLONG)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unhandled dynamic relocation against %s"),
		       bfd_archive_filename (input_bfd),
		       h->root.root.root.string);
		    ret_val = false;
		  }
		outrel.r_info = ELF64_R_INFO (0, R_ALPHA_RELATIVE);
		outrel.r_addend = value;
d3667 12
a3678 1
	    BFD_ASSERT(srel != NULL);
a3697 1
	case R_ALPHA_SREL16:
a3699 8
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }

a3707 124
	case R_ALPHA_TLSLDM:
	  /* Ignore the symbol for the relocation.  The result is always
	     the current module.  */
	  dynamic_symbol_p = 0;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      /* Note that the module index for the main program is 1.  */
	      bfd_put_64 (output_bfd, !info->shared && !dynamic_symbol_p,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 DTPMOD64 reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		{
		  Elf_Internal_Rela outrel;

		  BFD_ASSERT(srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  /* ??? Proper dynindx here.  */
		  outrel.r_info = ELF64_R_INFO (0, R_ALPHA_DTPMOD64);
		  outrel.r_addend = 0;

		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srelgot->contents)
					     + srelgot->reloc_count++);
		  BFD_ASSERT (sizeof (Elf64_External_Rela)
			      * srelgot->reloc_count
			      <= srelgot->_cooked_size);
		}

	      if (dynamic_symbol_p || r_type == R_ALPHA_TLSLDM)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
	          value -= dtp_base;
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset + 8);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_DTPRELHI:
	case R_ALPHA_DTPRELLO:
	case R_ALPHA_DTPREL16:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: dtp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= dtp_base;
	  if (r_type == R_ALPHA_DTPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_TPRELHI:
	case R_ALPHA_TPRELLO:
	case R_ALPHA_TPREL16:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: TLS local exec code cannot be linked into shared objects"),
		bfd_archive_filename (input_bfd));
              ret_val = false;
	    }
	  else if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: tp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = false;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= tp_base;
	  if (r_type == R_ALPHA_TPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      if (dynamic_symbol_p)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
		  value -= (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

d3711 2
a3712 1
					contents, rel->r_offset, value, 0);
d3884 1
d3889 1
a3889 7
	  asection *sgot;
	  int r_type;

	  if (gotent->use_count == 0)
	    continue;

	  sgot = alpha_elf_tdata (gotent->gotobj)->got;
a3892 22

	  r_type = gotent->reloc_type;
	  switch (r_type)
	    {
	    case R_ALPHA_LITERAL:
	      r_type = R_ALPHA_GLOB_DAT;
	      break;
	    case R_ALPHA_TLSGD:
	      r_type = R_ALPHA_DTPMOD64;
	      break;
	    case R_ALPHA_GOTDTPREL:
	      r_type = R_ALPHA_DTPREL64;
	      break;
	    case R_ALPHA_GOTTPREL:
	      r_type = R_ALPHA_TPREL64;
	      break;
	    case R_ALPHA_TLSLDM:
	    default:
	      abort ();
	    }

	  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
a3897 11

	  if (gotent->reloc_type == R_ALPHA_TLSGD)
	    {
	      outrel.r_offset += 8;
	      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_DTPREL64);

	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				         ((Elf64_External_Rela *)srel->contents
				          + srel->reloc_count++));
	    }

a4357 1
  bfd_elf64_swap_symbol_in,
@


1.61
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d3698 10
@


1.60
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d327 1
a327 1
  ret = (struct alpha_elf_link_hash_table *) bfd_zalloc (abfd, amt);
d334 1
a334 1
      bfd_release (abfd, ret);
@


1.59
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2123 3
d2129 3
a2131 3
           || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
          && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
          && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d2134 4
a2137 4
          || (einfo->info->strip == strip_some
              && bfd_hash_lookup (einfo->info->keep_hash,
                                  h->root.root.root.string,
                                  false, false) == NULL))
d2156 2
a2157 2
         && h->root.root.type != bfd_link_hash_defweak)
       h->esym.asym.sc = scAbs;
d2159 5
a2163 2
       {
         const char *name;
d2165 7
a2171 2
         sec = h->root.root.u.def.section;
         output_section = sec->output_section;
d2173 21
a2193 29
         /* When making a shared library and symbol h is the one from
            the another shared library, OUTPUT_SECTION may be null.  */
         if (output_section == NULL)
           h->esym.asym.sc = scUndefined;
         else
           {
             name = bfd_section_name (output_section->owner, output_section);

             if (strcmp (name, ".text") == 0)
               h->esym.asym.sc = scText;
             else if (strcmp (name, ".data") == 0)
               h->esym.asym.sc = scData;
             else if (strcmp (name, ".sdata") == 0)
               h->esym.asym.sc = scSData;
             else if (strcmp (name, ".rodata") == 0
                      || strcmp (name, ".rdata") == 0)
               h->esym.asym.sc = scRData;
             else if (strcmp (name, ".bss") == 0)
               h->esym.asym.sc = scBss;
             else if (strcmp (name, ".sbss") == 0)
               h->esym.asym.sc = scSBss;
             else if (strcmp (name, ".init") == 0)
               h->esym.asym.sc = scInit;
             else if (strcmp (name, ".fini") == 0)
               h->esym.asym.sc = scFini;
             else
               h->esym.asym.sc = scAbs;
           }
       }
d2205 1
a2205 1
       h->esym.asym.sc = scBss;
d2207 1
a2207 1
       h->esym.asym.sc = scSBss;
d2212 3
a2214 3
       h->esym.asym.value = (h->root.root.u.def.value
                             + sec->output_offset
                             + output_section->vma);
d2216 1
a2216 1
       h->esym.asym.value = 0;
d2238 2
a2239 2
                                     h->root.root.root.string,
                                     &h->esym))
d2867 3
d3047 3
@


1.58
log
@        * elf64-alpha.c (elf64_alpha_relocate_section) [BRSGP]: A target
        section with no got matches any got.  Simplify error generaion.
@
text
@d3674 1
a3674 1
	    if (outrel.r_offset != (bfd_vma) -1)
@


1.57
log
@	Support arbitrary length fill patterns.
	* linker.c (bfd_new_link_order): Zero all fields with bfd_zalloc.
	(_bfd_default_link_order): Remove bfd_fill_link_order code.
	Call default_data_link_order.
	(default_fill_link_order): Delete.
	(default_data_link_order): New function.
	* elf32-mips.c (_bfd_mips_elf_final_link): Replace occurrences
	of bfd_fill_link_order with bfd_data_link_order.
	* elf64-alpha.c (elf64_alpha_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
@
text
@d3584 7
a3590 2
	    /* The source and destination gp must be the same.  */
	    if (h != NULL
a3592 11
		if (h != NULL)
		  name = h->root.root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      name = _("<unknown>");
		    else if (name[0] == 0)
		      name = bfd_section_name (input_bfd, sec);
		  }
d3595 1
a3595 1
		   bfd_archive_filename (input_bfd), name);
@


1.56
log
@        * elf64-alpha.c (elf64_alpha_howto): Add R_ALPHA_BRSGP.
        (elf64_alpha_reloc_map, elf64_alpha_check_relocs): Likewise.
        (elf64_alpha_relocate_section): Likewise.
        * reloc.c (BFD_RELOC_ALPHA_BRSGP): New.
        * bfd-in2.h, libbfd.h: Rebuild.
@
text
@d4108 1
a4108 1
		  if (p->type == bfd_fill_link_order)
@


1.56.2.1
log
@        * elf64-alpha.c (elf64_alpha_relocate_section) [BRSGP]: A target
        section with no got matches any got.  Simplify error generaion.
@
text
@d3584 2
a3585 7
	    /* The source and destination gp must be the same.  Note that
	       the source will always have an assigned gp, since we forced
	       one in check_relocs, but that the destination may not, as
	       it might not have had any relocations at all.  Also take 
	       care not to crash if H is an undefined symbol.  */
	    if (h != NULL && sec != NULL
		&& alpha_elf_tdata (sec->owner)->gotobj
d3588 11
d3601 1
a3601 1
		   bfd_archive_filename (input_bfd), h->root.root.root.string);
@


1.56.2.2
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3674 1
a3674 1
	    if ((outrel.r_offset | 1) != (bfd_vma) -1)
@


1.56.2.3
log
@Merge from mainline.
@
text
@a2122 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

d2126 3
a2128 3
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d2131 4
a2134 4
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   false, false) == NULL))
d2153 2
a2154 2
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
d2156 2
a2157 5
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;
d2159 2
a2160 7
	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);
d2162 29
a2190 21
	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}
d2202 1
a2202 1
	h->esym.asym.sc = scBss;
d2204 1
a2204 1
	h->esym.asym.sc = scSBss;
d2209 3
a2211 3
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
d2213 1
a2213 1
	h->esym.asym.value = 0;
d2235 2
a2236 2
				      h->root.root.root.string,
				      &h->esym))
a2863 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

a3040 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

@


1.56.2.4
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Force relative relocs
        vs SHN_UNDEF to zero.
@
text
@a3697 10
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  /* ??? .eh_frame references to discarded sections will be smashed
	     to relocations against SHN_UNDEF.  The .eh_frame format allows
	     NULL to be encoded as 0 in any format, so this works here.  */
	  if (r_symndx == 0)
	    howto = (elf64_alpha_howto_table
		     + (r_type - R_ALPHA_SREL32 + R_ALPHA_REFLONG));
	  goto default_reloc;

@


1.56.2.5
log
@* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Only insert
DT_PLTGOT into the dynamic section if there is a PLT.
@
text
@d3240 3
d3245 1
a3245 2
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
@


1.55
log
@        * elf64-alpha.c (elf64_alpha_check_relocs): Don't set reltext
        for non-allocated sections.
@
text
@d735 16
a750 1
	 true)
d904 1
d2433 1
d3574 64
@


1.54
log
@        * elf64-alpha.c (elf64_alpha_adjust_dynamic_symbol): Don't suppress
        plt entries for undefweak symbols.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d2504 2
a2505 1
		  rent->reltext = (sec->flags & SEC_READONLY) != 0;
@


1.53
log
@        * elf64-alpha.c (INSN_UNOP): Encode with RB as $sp.
@
text
@d2548 1
a2548 2
  if (h->root.type != bfd_link_hash_undefweak
      && alpha_elf_dynamic_symbol_p (h, info)
@


1.52
log
@	* elf-bfd.h (elf_discarded_section): Define.
	* elflink.h (elf_link_input_bfd): Use it.
	(elf_reloc_symbol_deleted_p): Likewise.

	* elf64-alpha.c (elf64_alpha_relocate_section): Don't warn about
	overflows for pc relative relocs against discarded sections.
@
text
@d944 1
a944 1
#define INSN_UNOP	0x2fe00000
@


1.51
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d3631 9
@


1.50
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d1365 1
d1372 1
d1453 2
d1459 3
a1461 1
	      extsyms = (Elf64_External_Sym *) bfd_malloc (symtab_hdr->sh_size);
d1466 14
a1479 2
		  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
d1488 6
a1493 3
	  bfd_elf64_swap_symbol_in (abfd,
				    extsyms + ELF64_R_SYM (irel->r_info),
				    &isym);
a1495 2
	  else if (isym.st_shndx > 0 && isym.st_shndx < SHN_LORESERVE)
	    info.tsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d1501 1
a1501 1
	    continue;	/* who knows.  */
d1588 3
d1611 2
@


1.49
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d3409 2
a3410 1
		    && elf_section_data (sec)->merge_info
d3425 1
a3425 1
						      merge_info,
@


1.48
log
@	* elf64-alpha.c (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Defined.
	(elf64_alpha_relocate_section): Translate local_got_entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.
	* elfxx-ia64.c (struct elfNN_ia64_local_hash_entry): Add
	sec_merge_done.
	(get_local_sym_hash): New, extracted from get_dyn_sym_info.
	(get_dyn_sym_info): Use it.
	(elfNN_ia64_relocate_section): Translate local dyn entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.

        * write.c (adjust_reloc_syms): Mark SEC_MERGE symbols as used
        in reloc if it has non-zero addend.
        * config/tc-alpha.c (tc_gen_reloc): Reinstall SEC_MERGE check.
        * config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@a3536 1
	    boolean skip;
d3571 4
a3574 19
	    skip = false;

	    if (elf_section_data (input_section)->stab_info == NULL)
	      outrel.r_offset = rel->r_offset;
	    else
	      {
		bfd_vma off;

		off = (_bfd_stab_section_offset
		       (output_bfd, &elf_hash_table (info)->stab_info,
			input_section,
			&elf_section_data (input_section)->stab_info,
			rel->r_offset));
		if (off == (bfd_vma) -1)
		  skip = true;
		outrel.r_offset = off;
	      }

	    if (! skip)
@


1.47
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d173 1
a173 1
    /* An additional flag.  */
d175 1
d3404 31
@


1.46
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d3321 1
a3321 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.45
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d3519 3
a3521 1
	    else if (info->shared && (input_section->flags & SEC_ALLOC))
@


1.44
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d1575 1
a1575 1
	  symtab_hdr->contents = extsyms;
@


1.43
log
@Fix compile time warnings
@
text
@d139 1
a139 1
  PARAMS ((int));
d4134 2
a4135 2
elf64_alpha_reloc_type_class (type)
     int type;
d4137 1
a4137 1
  switch (type)
@


1.42
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d1023 1
a1023 1
      if (urel->r_addend >= 0 && urel->r_addend <= 3)
@


1.41
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1013 2
a1014 2
	bfd_get_filename (info->abfd), info->sec->name,
	(unsigned long)irel->r_offset));
d1310 1
a1310 1
	bfd_get_filename (info->abfd), info->sec->name,
d2910 1
a2910 1
	         bfd_get_filename (i),
d3464 1
a3464 1
                 bfd_get_filename (input_bfd), h->root.root.root.string);
d3476 1
a3476 1
                 bfd_get_filename (input_bfd), h->root.root.root.string);
@


1.40
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3349 2
a3350 1
	  else if (info->shared && !info->symbolic
@


1.39
log
@        * elf64-alpha.c (elf64_alpha_section_flags): New.
        (elf64_alpha_fake_sections): Map SEC_SMALL_DATA to SHF_ALPHA_GPREL.
@
text
@d166 1
a166 1
    bfd_signed_vma addend;
d324 1
d326 1
a326 2
  ret = ((struct alpha_elf_link_hash_table *)
	 bfd_zalloc (abfd, sizeof (struct alpha_elf_link_hash_table)));
d378 2
a379 1
  abfd->tdata.any = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
d391 2
a392 1
  new_tdata = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
d808 2
a809 2
  bfd_put_32 (abfd, i_ldah, p_ldah);
  bfd_put_32 (abfd, i_lda, p_lda);
d1070 2
a1071 1
	      bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
d1083 1
a1083 1
	      bfd_put_32 (info->abfd, lit_insn,
d1103 2
a1104 1
	  insn = (insn & ~0x001ff000) | ((symval & 7) << 13) | 0x1000;
d1110 2
a1111 1
	  bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
d1144 2
a1145 1
		bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
d1181 2
a1182 2
			bfd_put_32 (info->abfd, INSN_UNOP, p_ldah);
			bfd_put_32 (info->abfd, INSN_UNOP, p_lda);
d1213 2
a1214 1
	  bfd_put_32 (info->abfd, INSN_UNOP, info->contents + irel->r_offset);
d1327 1
a1327 1
  bfd_put_32 (info->abfd, insn, info->contents + irel->r_offset);
d1454 1
a1454 2
	      extsyms = ((Elf64_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
d1459 1
a1459 1
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d1595 4
a1598 4
#define PLT_HEADER_WORD1	0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	0x6b7b0000	/* jmp  $27,($27)   */
d1866 1
a1866 1
  ext_hdr = (char *) bfd_malloc ((size_t) swap->external_hdr_size);
d1885 2
a1886 1
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
d1890 1
a1890 2
	  || (bfd_read (debug->ptr, size, symhdr->count,		\
			abfd) != size * symhdr->count))			\
d2003 1
d2005 1
a2005 2
	  fi = ((struct mips_elf_find_line *)
		bfd_zalloc (abfd, sizeof (struct mips_elf_find_line)));
d2019 2
a2020 4
	  fi->d.fdr = ((struct fdr *)
		       bfd_alloc (abfd,
				  (fi->d.symbolic_header.ifdMax *
				   sizeof (struct fdr))));
d2232 1
d2286 1
d2288 1
a2288 2
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
d2311 3
a2313 3
		    size_t size;
		    size = (symtab_hdr->sh_info
			    * sizeof (struct alpha_elf_got_entry *));
d2320 1
a2320 1
		    memset (local_got_entries, 0, size);
d2331 1
d2333 1
a2333 2
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
d2441 2
d2444 4
d2449 1
a2449 9
		      || !bfd_set_section_flags (dynobj, sreloc,
						 (((sec->flags
						    & SEC_ALLOC)
						   ? (SEC_ALLOC
						      | SEC_LOAD) : 0)
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
d2471 2
a2472 3
		  rent = ((struct alpha_elf_reloc_entry *)
			  bfd_alloc (abfd,
				     sizeof (struct alpha_elf_reloc_entry)));
d3167 1
a3167 1
	  s->contents = (bfd_byte *) bfd_zalloc(dynobj, s->_raw_size);
d3180 3
d3185 1
a3185 1
	  if (!bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d3189 1
a3189 1
      if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0))
d3194 3
a3196 3
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d3200 3
a3202 4
      if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (Elf64_External_Rela)))
d3207 1
a3207 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d3211 1
d3273 1
a3273 1
      bfd_signed_vma addend;
d3416 1
a3416 1
		bfd_put_64 (output_bfd, relocation+addend,
d3432 1
a3432 1
		    outrel.r_addend = relocation+addend;
d3662 1
a3662 1
	unsigned insn1, insn2, insn3;
d3848 2
a3849 2
	  bfd_put_64 (output_bfd, 0, splt->contents + 16);
	  bfd_put_64 (output_bfd, 0, splt->contents + 24);
d4111 2
a4112 1
					sgot->contents, sgot->output_offset,
@


1.38
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Do not
        apply HINT relocations against dynamic symbols.
@
text
@d77 2
d1646 13
d1682 2
a1683 1
  else if (strcmp (name, ".sdata") == 0
d4239 2
@


1.37
log
@        * elf64-alpha.c: Delete all unused ERIC_neverdef and rth_notdef code.
@
text
@d3465 10
a3475 1
	case R_ALPHA_HINT:
@


1.36
log
@        * elf64-alpha.c (elf64_alpha_relax_with_lituse): Nop out gpdisp
        following a call to a near function.
@
text
@a1624 7
#ifdef ERIC_neverdef
    case SHT_ALPHA_REGINFO:
      if (strcmp (name, ".reginfo") != 0
	  || hdr->sh_size != sizeof (Elf64_External_RegInfo))
	return false;
      break;
#endif
a1640 17
#ifdef ERIC_neverdef
  /* For a .reginfo section, set the gp value in the tdata information
     from the contents of this section.  We need the gp value while
     processing relocs, so we just get it now.  */
  if (hdr->sh_type == SHT_ALPHA_REGINFO)
    {
      Elf64_External_RegInfo ext;
      Elf64_RegInfo s;

      if (! bfd_get_section_contents (abfd, newsect, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
      bfd_alpha_elf64_swap_reginfo_in (abfd, &ext, &s);
      elf_gp (abfd) = s.ri_gp_value;
    }
#endif

a1666 24
#ifdef ERIC_neverdef
  else if (strcmp (name, ".reginfo") == 0)
    {
      hdr->sh_type = SHT_ALPHA_REGINFO;
      /* In a shared object on Irix 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if ((abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = sizeof (Elf64_External_RegInfo);
      else
	hdr->sh_entsize = 1;

      /* Force the section size to the correct value, even if the
	 linker thinks it is larger.  The link routine below will only
	 write out this much data for .reginfo.  */
      hdr->sh_size = sec->_raw_size = sizeof (Elf64_External_RegInfo);
    }
  else if (strcmp (name, ".hash") == 0
	   || strcmp (name, ".dynamic") == 0
	   || strcmp (name, ".dynstr") == 0)
    {
      hdr->sh_entsize = 0;
      hdr->sh_info = SIZEOF_ALPHA_DYNSYM_SECNAMES;
    }
#endif
a2170 3
#if 0 /* FIXME?  */
      h->esym.ifd = 0;
#endif
a3316 24
#if rth_notdef
	      if ((r_type == R_ALPHA_LITERAL
		   && elf_hash_table(info)->dynamic_sections_created
		   && (!info->shared
		       || !info->symbolic
		       || !(h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR)))
		  || (info->shared
		      && (!info->symbolic
			  || !(h->root.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR))
		      && (input_section->flags & SEC_ALLOC)
		      && (r_type == R_ALPHA_REFLONG
			  || r_type == R_ALPHA_REFQUAD
			  || r_type == R_ALPHA_LITERAL)))
		{
		  /* In these cases, we don't need the relocation value.
		     We check specially because in some obscure cases
		     sec->output_section will be NULL.  */
		  relocation = 0;
		}
#else
	      /* FIXME: Are not these obscure cases simply bugs?  Let's
		 get something working and come back to this.  */
a3318 1
#endif /* rth_notdef */
d3829 3
a3831 3
/* We need to use a special link routine to handle the .reginfo and
   the .mdebug sections.  We need to merge all instances of these
   sections together, not write them all out sequentially.  */
d3840 1
a3840 1
  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
d3847 1
a3847 12
#if 0
	      if (++ngots == 2)
		{
		  (*info->callbacks->warning)
		    (info, _("using multiple gp values"), (char *) NULL,
		     output_bfd, (asection *) NULL, (bfd_vma) 0);
		}
#endif

  /* Go through the sections and collect the .reginfo and .mdebug
     information.  */
  reginfo_sec = NULL;
a3848 2
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
a3850 66
#ifdef ERIC_neverdef
      if (strcmp (o->name, ".reginfo") == 0)
	{
	  memset (&reginfo, 0, sizeof reginfo);

	  /* We have found the .reginfo section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      Elf64_External_RegInfo ext;
	      Elf64_RegInfo sub;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* The linker emulation code has probably clobbered the
                 size to be zero bytes.  */
	      if (input_section->_raw_size == 0)
		input_section->_raw_size = sizeof (Elf64_External_RegInfo);

	      if (! bfd_get_section_contents (input_bfd, input_section,
					      (PTR) &ext,
					      (file_ptr) 0,
					      sizeof ext))
		return false;

	      bfd_alpha_elf64_swap_reginfo_in (input_bfd, &ext, &sub);

	      reginfo.ri_gprmask |= sub.ri_gprmask;
	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];

	      /* ri_gp_value is set by the function
		 alpha_elf_section_processing when the section is
		 finally written out.  */

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* Force the section size to the value we want.  */
	  o->_raw_size = sizeof (Elf64_External_RegInfo);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  reginfo_sec = o;
	}
#endif

a4036 25
#ifdef ERIC_neverdef
	  if (info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY);

		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 12))
		    return false;
		}

	      if (! alpha_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec, &debug))
		return false;
	    }
#endif

a4057 223

#ifdef ERIC_neverdef
      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
	{
	  const char *subname;
	  unsigned int c;
	  Elf64_gptab *tab;
	  Elf64_External_gptab *ext_tab;
	  unsigned int i;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocateable)
	    {
	      asection **secpp;

	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_fill_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &=~ SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->link_order_head = (struct bfd_link_order *) NULL;

	      /* Really remove the section.  */
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      *secpp = (*secpp)->next;
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_get_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  tab = (Elf64_gptab *) bfd_malloc (c * sizeof (Elf64_gptab));
	  if (tab == NULL)
	    return false;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = bfd_section_size (input_bfd, input_section);
	      last = 0;
	      for (gpentry = sizeof (Elf64_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf64_External_gptab))
		{
		  Elf64_External_gptab ext_gptab;
		  Elf64_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  gpentry, sizeof (Elf64_External_gptab))))
		    {
		      free (tab);
		      return false;
		    }

		  bfd_alpha_elf64_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = false;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = true;
		    }

		  if (! exact)
		    {
		      Elf64_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      new_tab = ((Elf64_gptab *)
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf64_gptab)));
		      if (new_tab == NULL)
			{
			  free (tab);
			  return false;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  ext_tab = ((Elf64_External_gptab *)
		     bfd_alloc (abfd, c * sizeof (Elf64_External_gptab)));
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return false;
	    }

	  for (i = 0; i < c; i++)
	    bfd_alpha_elf64_swap_gptab_out (abfd, tab + i, ext_tab + i);
	  free (tab);

	  o->_raw_size = c * sizeof (Elf64_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;
	}
#endif

a4086 12
#ifdef ERIC_neverdef
  if (reginfo_sec != (asection *) NULL)
    {
      Elf64_External_RegInfo ext;

      bfd_alpha_elf64_swap_reginfo_out (abfd, &reginfo, &ext);
      if (! bfd_set_section_contents (abfd, reginfo_sec, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
    }
#endif

a4095 18
    }

  if (gptab_data_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
	return false;
    }

  if (gptab_bss_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
	return false;
@


1.35
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Soft fail
        relocation errors.  Fail gp-relative relocations against
        dynamic symbols.
@
text
@d1152 13
a1164 5
	    /* ??? If target gp == current gp we can eliminate the gp reload.
	       This does depend on every place a gp could be reloaded will
	       be, which currently happens for all code produced by gcc, but
	       not necessarily by hand-coded assembly, or if sibling calls
	       are enabled in gcc.
d1166 16
a1181 2
	       Perhaps conditionalize this on a flag being set in the target
	       object file's header, and have gcc set it?  */
@


1.34
log
@        * elf64-alpha.c (SKIP_HOWTO): New.
        (elf64_alpha_howto_table): Use it to remove dead ECOFF relocs.
        Fix sizes of 16-bit mem format relocs.
        (elf64_alpha_reloc_map): Update to match.
        (elf64_alpha_relax_with_lituse): Use GPREL16 as appropriate.
        (elf64_alpha_relax_without_lituse): Likewise.
        (elf64_alpha_check_relocs): Handle GPREL16.
        (elf64_alpha_relocate_section): Likewise.
        * reloc.c (BFD_RELOC_ALPHA_USER_*): Remove.
        (BFD_RELOC_ALPHA_GPREL_HI16, BFD_RELOC_ALPHA_GPREL_LO16): New.
        * bfd-in2.h, libbfd.h: Rebuild.
@
text
@d3244 1
d3393 1
a3393 1
		return false;
d3492 7
d3504 7
d3627 1
a3627 1
	      return false;
d3637 1
a3637 1
  return true;
@


1.33
log
@	* elf64-alpha.c (elf64_alpha_relocate_section): Duplicate memory
	value into R_ALPHA_RELATIVE's addend.
	(elf64_alpha_finish_dynamic_symbol): Likewise.
@
text
@d402 3
d471 1
a471 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d492 1
a492 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d552 1
a552 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d609 6
a614 83
  /* Push a value on the reloc evaluation stack.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PUSH,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PUSH",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* Store the value from the stack at the given address.  Store it in
     a bitfield of size r_size starting at bit position r_offset.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_STORE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_STORE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Subtract the reloc address from the value on the top of the
     relocation stack.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PSUB,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PSUB",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* Shift the value on the top of the relocation stack right by the
     given value.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PRSHIFT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PRSHIFT",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* Change the value of GP used by +r_addend until the next GPVALUE or the
     end of the input bfd.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_GPVALUE,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "GPVALUE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d619 1
a619 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d624 1
a624 1
	 elf64_alpha_reloc_bad, /* special_function */
d634 1
a634 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d639 1
a639 1
	 elf64_alpha_reloc_bad, /* special_function */
d647 1
a647 2
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_16,
d649 1
a649 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d655 1
a655 1
	 "IMMED_GP_16",		/* name */
d661 5
a665 68
  /* The high bits of a 32-bit displacement from the GP to the target; the
     low bits are supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_GP_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement to the starting address of the
     current section (the relocation target is ignored); the low bits are
     supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_SCN_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_SCN_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement from the previous br, bsr, jsr
     or jmp insn (as tagged by a BRADDR or HINT reloc) to the target; the
     low bits are supplied by subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_BR_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_BR_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of a displacement calculated in a previous HI32 reloc.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_LO32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_LO32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d868 16
a883 24
  {BFD_RELOC_NONE,		R_ALPHA_NONE},
  {BFD_RELOC_32,		R_ALPHA_REFLONG},
  {BFD_RELOC_64,		R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,		R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,		R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_ELF_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,	R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,	R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,	R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,		R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,		R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,		R_ALPHA_SREL64},

/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to process
   the explicit !<reloc>!sequence relocations, and are mapped into the normal
   relocations at the end of processing.  */
  {BFD_RELOC_ALPHA_USER_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_USER_LITUSE_BASE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_JSR,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_ALPHA_USER_GPRELHIGH,	R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_USER_GPRELLOW,	R_ALPHA_GPRELLOW},
d1062 1
a1062 1
					   R_ALPHA_GPRELLOW);
d1299 1
a1299 1
  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), R_ALPHA_GPRELLOW);
d2396 1
a3417 7
	case R_ALPHA_OP_PUSH:
	case R_ALPHA_OP_STORE:
	case R_ALPHA_OP_PSUB:
	case R_ALPHA_OP_PRSHIFT:
	  /* We hate these silly beasts.  */
	  abort ();

d3488 1
@


1.32
log
@
	* oasys.c: Add missing prototypes.

	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Add unused
	attribute for parameter.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.

	* versados.c (get_4): Make static.
	(get_10): Make static.
	Add missing prototypes.
	(process_esd): Fix call to versados_new_symbol.
@
text
@d3616 1
a3616 1
		    outrel.r_addend = 0;
d3681 1
a3681 1
		outrel.r_addend = 0;
d3874 1
a3874 1
		  outrel.r_addend = 0;
@


1.31
log
@	* elflink.h (elf_link_sort_cmp1): Sort RELATIVE relocs first, not
	last.
	(elf_link_sort_relocs): Adjust accordingly.

	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Add reltext flag.
	(elf64_alpha_check_relocs): Set it if section this reloc is against
	is read-only.  Set DF_TEXTREL if a RELATIVE reloc is needed against
	read-only section.
	(elf64_alpha_calc_dynrel_sizes): Set DF_TEXTREL flag if relocation
	is is against read-only section.
	(elf64_alpha_size_dynamic_sections): Use DF_TEXTREL flag, don't
	check section names.
	(elf64_alpha_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d3222 1
a3222 1
     bfd *output_bfd;
@


1.30
log
@	* bfd.c (bfd_get_gp_size): Return an unsigned int.
	(bfd_set_gp_size): Make param unsigned.
	* bfd-in2.h: Regenerate.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Use elf_gp_size rather
	than calling bfd_get_gp_size.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
@
text
@d136 2
d187 4
a190 1
    unsigned long rtype;
d2635 1
d2648 2
d3192 2
a3226 1
  boolean reltext;
a3274 1
  reltext = false;
a3303 13
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

d3359 1
a3359 1
      if (reltext)
a3362 1
	  info->flags |= DF_TEXTREL;
d4647 17
d4791 2
@


1.29
log
@Oops missed from last commit
@
text
@d1858 1
a1858 1
      && sym->st_size <= (unsigned int) bfd_get_gp_size (abfd))
@


1.28
log
@2001-07-11  H.J. Lu  <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_check_relocs): Set the ALLOC|LOAD
	flags when creating the reloc section if the ALLOC flag in the
	source section is set.
@
text
@d162 1
a162 1
    bfd_vma addend;
d1122 2
a1123 1
      if (rel->r_offset == offset && ELF64_R_TYPE (rel->r_info) == type)
a1618 1
	  info.gotent = gotent;
d1858 1
a1858 1
      && sym->st_size <= bfd_get_gp_size (abfd))
d2966 1
a2966 1
     PTR arg;
d3032 1
a3032 1
     bfd *output_bfd;
d3035 1
a3035 1
  bfd *i, *got_list, *cur_got_obj;
d3431 1
a3431 1
      bfd_vma addend;
d4171 1
a4171 1
	      bfd_vma last;
@


1.27
log
@2001-07-11  H.J. Lu  <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_check_relocs): Only use the same
	ALLOC|LOAD flags as the source section for debugging sections
	when creating the reloc section.
@
text
@d2593 3
a2595 6
						    & SEC_DEBUGGING)
						   ? (sec->flags
						      & (SEC_ALLOC
							 | SEC_LOAD))
						   : (SEC_ALLOC
						      | SEC_LOAD))
@


1.26
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@d2592 7
a2598 2
						 ((sec->flags & (SEC_ALLOC
								 | SEC_LOAD))
@


1.25
log
@        * elf64-alpha.c (SREL16, SREL32, SREL64): Set pcrel_offset true.
@
text
@d2834 1
a2834 1
      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
d2906 1
a2906 1
      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
@


1.24
log
@	* elf64-gen.c (elf_generic_info_to_howto): Add unused attribute.
	(elf_generic_info_to_howto_rel): Likewise.
	* coff-alpha.c (reloc_nil): Likewise.
	(alpha_ecoff_bad_format_hook): Likewise.
	(alpha_adjust_reloc_out): Likewise.
	(alpha_bfd_reloc_type_lookup): Likewise.
	(alpha_convert_external_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_nil): Likewise.
	(elf64_alpha_reloc_bad): Likewise.
	(elf64_alpha_reloc_gpdisp): Likewise.
	(elf64_alpha_bfd_reloc_type_lookup): Likewise.
	(elf64_alpha_info_to_howto): Likewise.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_is_local_label_name): Likewise.
	(elf64_alpha_merge_ind_symbols): Likewise.
	* elf64-mips.c (mips_elf64_reloc_type_lookup): Likewise.
	(mips_elf64_get_reloc_upper_bound): Likewise.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Likewise.
	(nlm_alpha_get_public_offset): Likewise.
@
text
@d569 1
a569 1
	 false),		/* pcrel_offset */
d584 1
a584 1
	 false),		/* pcrel_offset */
d599 1
a599 1
	 false),		/* pcrel_offset */
@


1.23
log
@Update copyright notices
@
text
@d870 1
a870 1
     bfd *abfd;
d872 2
a873 2
     asymbol *sym;
     PTR data;
d876 1
a876 1
     char **error_message;
d887 1
a887 1
     bfd *abfd;
d889 2
a890 2
     asymbol *sym;
     PTR data;
d893 1
a893 1
     char **error_message;
d950 1
a950 1
     asymbol *sym;
d1031 1
a1031 1
     bfd *abfd;
d1049 1
a1049 1
     bfd *abfd;
d1851 2
a1852 2
     const char **namep;
     flagword *flagsp;
d1887 1
a1887 1
     struct bfd_link_info *info;
d2090 1
a2090 1
     bfd *abfd;
d2742 1
a2742 1
     PTR dummy;
d4730 2
a4731 2
#define ELF_MACHINE_CODE 	EM_ALPHA
#define ELF_MAXPAGESIZE 	0x10000
@


1.22
log
@        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Respect weakness
        before visibility.  Locally defined protected symbols are not
        dynamic.
@
text
@d2 2
a3 1
   Copyright 1996, 97, 98, 1999 Free Software Foundation, Inc.
@


1.21
log
@2001-02-06  H.J. Lu  <hjl@@gnu.org>

	* elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Only hidden and
	internal symbols are not dynamic.
	* elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
@
text
@d243 5
d250 3
a253 1
    case STV_HIDDEN:
d255 4
a259 4

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return true;
@


1.20
log
@        * elf64-alpha.c (elf64_alpha_find_nearest_line): Query dwarf2
        before mdebug.
@
text
@d243 6
a248 2
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
    return false;
@


1.19
log
@        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Return false
        for non-default visibility.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise, but
        delete ugly macro and replace with pretty function.
@
text
@d2108 6
@


1.19.2.1
log
@        * elf64-alpha.c (elf64_alpha_find_nearest_line): Query dwarf2
        before mdebug.
@
text
@a2107 6
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return true;

@


1.19.2.2
log
@        * elf64-alpha.c (SREL16, SREL32, SREL64): Set pcrel_offset true.
@
text
@d557 1
a557 1
	 true),			/* pcrel_offset */
d572 1
a572 1
	 true),			/* pcrel_offset */
d587 1
a587 1
	 true),			/* pcrel_offset */
@


1.19.2.3
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.19.2.4
log
@Merge from mainline.
@
text
@d244 2
a250 13
  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_DEFAULT:
      break;
    case STV_HIDDEN:
    case STV_INTERNAL:
      return false;
    case STV_PROTECTED:
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
        return false;
      break;
    }

d859 1
a859 1
     bfd *abfd ATTRIBUTE_UNUSED;
d861 2
a862 2
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d865 1
a865 1
     char **error_message ATTRIBUTE_UNUSED;
d876 1
a876 1
     bfd *abfd ATTRIBUTE_UNUSED;
d878 2
a879 2
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d882 1
a882 1
     char **error_message ATTRIBUTE_UNUSED;
d939 1
a939 1
     asymbol *sym ATTRIBUTE_UNUSED;
d1020 1
a1020 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1038 1
a1038 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1840 2
a1841 2
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
d1876 1
a1876 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d2079 1
a2079 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2731 1
a2731 1
     PTR dummy ATTRIBUTE_UNUSED;
d2823 1
a2823 1
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
d2895 1
a2895 1
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
d4719 2
a4720 2
#define ELF_MACHINE_CODE	EM_ALPHA
#define ELF_MAXPAGESIZE	0x10000
@


1.18
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d49 2
a50 1
static boolean elf64_alpha_mkobject PARAMS ((bfd *));
d70 2
d229 29
a257 8
#define alpha_elf_dynamic_symbol_p(h, info) 				\
  ((((info)->shared && !(info)->symbolic)				\
    || (((h)->elf_link_hash_flags					\
	 & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
        == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
    || (h)->root.type == bfd_link_hash_undefweak			\
    || (h)->root.type == bfd_link_hash_defweak)				\
   && (h)->dynindx != -1)
@


1.17
log
@Fix formatting.
@
text
@a131 1

@


1.16
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* elf64-alpha.c: Fix formatting.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
@
text
@d4744 1
a4744 3
/*
 * A few constants that determine how the .plt section is set up.
 */
@


1.15
log
@        * elf64-alpha.c (elf64_alpha_check_relocs): Create the reloc
        section with the same ALLOC|LOAD flags as the source section.
@
text
@d37 1
a37 1
/* Get the ECOFF swapping routines.  Needed for the debug information. */
d714 1
a714 1
     current section (the relocation target is ignored); the low bits are 
d765 1
a765 1
  /* Misc ELF relocations. */
d982 1
a982 1
   relocations at the end of processing. */
d1025 1
a1025 1
/* These functions do relaxation for Alpha ELF. 
d1065 1
a1065 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
d1069 1
a1069 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
d1128 1
a1128 1
  /* A little preparation for the loop... */
d1164 1
a1164 1
		 register from the literal insn.  Leave the offset alone. */
d1227 1
a1227 1
		/* Preserve branch prediction call stack when possible. */
d1232 1
a1232 1
		  
d1246 1
a1246 1
			(info->relocs, info->relend, urel->r_offset, 
d1261 1
a1261 1
	       are enabled in gcc. 
d1311 1
a1311 1
     a normal ldgp in the first two words.  */ 
d1317 1
a1317 1
  else 
d1322 1
a1322 1
      /* Load the relocations from the section that the target symbol is in. */
d1344 1
a1344 1
  
d1359 1
a1359 1
  /* We've now determined that we can skip an initial gp load.  Verify 
d1420 1
a1420 1
     the calculated GP register would otherwise be ready. 
d1472 1
a1472 1
  memset(&info, 0, sizeof(info));
d1555 2
a1556 2
	  else 
	    continue;	/* who knows. */
d1974 1
a1974 1
  memset (debug, 0, sizeof(*debug));
d2568 1
a2568 1
		 expand the relocation sections by the appropriate amount. */
d3140 1
a3140 1
	      sizeof(Elf64_External_Rela) * relent->count;
d3215 1
a3215 1
	  srel->_raw_size += count * sizeof(Elf64_External_Rela);
d3318 1
a3318 1
					    sizeof(Elf64_External_Rela)))
d3408 1
a3408 1
	  /* The symbol associated with GPDISP and LITUSE is 
d3531 1
a3531 1
	  abort();
d3585 1
a3585 1
		    BFD_ASSERT (sizeof(Elf64_External_Rela)
d3690 1
a3690 1
	    BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
d3843 1
a3843 1
		  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
d3876 1
a3876 1
	  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
a4293 1

d4613 1
a4613 1
   from elf32-mips.c. */
@


1.14
log
@	* elf64-alpha.c (elf64_alpha_relax_opt_call): Only check bits used
	by STO_ALPHA constants.

	* config/tc-alpha.c (s_alpha_prologue): Preserve visibility bits.
@
text
@d2551 2
a2552 1
						 (SEC_ALLOC|SEC_LOAD
@


1.13
log
@ld performs LITUSE relocations incorrectly if -relax is specified on the ld
command line and the displacement field of the load or store instruction is
non-zero.
@
text
@d1307 1
a1307 1
  if (info->other == STO_ALPHA_NOPV)
d1312 1
a1312 1
  else if (info->other == STO_ALPHA_STD_GPLOAD)
@


1.12
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@a1129 2
  fits16 = (disp >= -(bfd_signed_vma)0x8000 && disp < 0x8000);
  fits32 = (disp >= -(bfd_signed_vma)0x80000000 && disp < 0x7fff8000);
d1134 3
d1149 12
d1163 3
a1165 6
	      /* FIXME: sanity check the insn for mem format with
		 zero addend.  */

	      /* Take the op code and dest from this insn, take the base 
		 register from the literal insn.  Leave the offset alone.  */
	      insn = (insn & 0xffe00000) | (lit_insn & 0x001f0000);
d1178 1
a1178 2
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb, and
		 that mem_insn disp is zero.  */
@


1.11
log
@Fix hash section entry size to match ELF standard.  Override for alpha-linux.
	* elf64-alpha.c (alpha_elf_size_info): New.
	(elf_backend_size_info): Define to alpha_elf_size_info.
	* elfcode.h (elf_size_info): Change hash bucket size to 4.
@
text
@d3315 1
@


1.10
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_relocate_section): Check
	h->root.other not h->other.
@
text
@d4646 30
d4730 3
@


1.9
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d3480 1
a3480 1
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d3488 1
a3488 1
		      || ELF_ST_VISIBILITY (h->other)))))
@


1.8
log
@Don't emit relative relocations for non-loaded sections in shared objects.
Fix for DWARF-2 sections .debug_info and .debug_line.
@
text
@d3478 3
a3480 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d3487 2
a3488 1
		     (!info->shared || info->no_undefined))))
@


1.7
log
@2000-03-24  H.J. Lu  <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Add prototype.
	(elf64_alpha_find_reloc_at_ofs): Likewise.
@
text
@d2584 1
a2584 1
	  else if (info->shared)
d2586 2
a2587 1
	      /* If this is a shared library, we need a RELATIVE reloc.  */
d3627 1
a3627 1
	    else if (info->shared)
@


1.7.2.1
log
@Don't emit relative relocations for non-loaded sections in shared objects.
Fix for DWARF-2 sections .debug_info and .debug_line.
@
text
@d2584 1
a2584 1
	  else if (info->shared && (sec->flags & SEC_ALLOC))
d2586 1
a2586 2
	      /* If this is a shared library, and the section is to be
		 loaded into memory, we need a RELATIVE reloc.  */
d3626 1
a3626 1
	    else if (info->shared && (input_section->flags & SEC_ALLOC))
@


1.7.2.2
log
@Merge from mainline
@
text
@d3478 1
a3478 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d3485 1
a3485 2
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
@


1.7.2.3
log
@Merge changes from mainline to make elf64-alpha build again
@
text
@d3480 1
a3480 1
		   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
d3488 1
a3488 1
		      || ELF_ST_VISIBILITY (h->root.other)))))
@


1.6
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d128 4
@


1.5
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d3479 2
a3480 1
		     input_section, rel->r_offset)))
@


1.4
log
@Add new relocations for alpha explicit relocation support
@
text
@d3266 1
a3266 1
	_bfd_strip_section_from_output (s);
@


1.3
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d975 11
@


1.2
log
@        * elf64-alpha.c (elf64_alpha_relocate_section): Don't adjust
        GPDISP or LITUSE in a relocatable link.
@
text
@a117 2
static boolean elf64_alpha_adjust_dynindx
  PARAMS((struct elf_link_hash_entry *, PTR));
a3264 28
  /* If we are generating a shared library, we generate a section
     symbol for each output section.  These are local symbols, which
     means that they must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.  */
  if (info->shared)
    {
      long c[2], i;
      asection *p;

      c[0] = 0;
      c[1] = bfd_count_sections (output_bfd);

      elf_hash_table (info)->dynsymcount += c[1];
      elf_link_hash_traverse (elf_hash_table(info),
			      elf64_alpha_adjust_dynindx,
			      (PTR) c);

      for (i = 1, p = output_bfd->sections;
	   p != NULL;
	   p = p->next, i++)
	{
	  elf_section_data (p)->dynindx = i;
	  /* These symbols will have no names, so we don't need to
	     fiddle with dynstr_index.  */
	}
    }

a3304 16
/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
elf64_alpha_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  long *cp = (long *)cparg;

  if (h->dynindx >= cp[0])
    h->dynindx += cp[1];

  return true;
}

a3945 38
    }

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;

      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  BFD_ASSERT (indx > 0);
	  sym.st_shndx = indx;

	  bfd_elf64_swap_symbol_out (output_bfd, &sym,
				     (PTR) (((Elf64_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));
	}

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	bfd_count_sections (output_bfd) + 1;
@


1.1
log
@Initial revision
@
text
@d3426 6
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

