head	1.47;
access;
symbols
	sid-snapshot-20180601:1.47
	sid-snapshot-20180501:1.47
	sid-snapshot-20180401:1.47
	sid-snapshot-20180301:1.47
	sid-snapshot-20180201:1.47
	sid-snapshot-20180101:1.47
	sid-snapshot-20171201:1.47
	sid-snapshot-20171101:1.47
	sid-snapshot-20171001:1.47
	sid-snapshot-20170901:1.47
	sid-snapshot-20170801:1.47
	sid-snapshot-20170701:1.47
	sid-snapshot-20170601:1.47
	sid-snapshot-20170501:1.47
	sid-snapshot-20170401:1.47
	sid-snapshot-20170301:1.47
	sid-snapshot-20170201:1.47
	sid-snapshot-20170101:1.47
	sid-snapshot-20161201:1.47
	sid-snapshot-20161101:1.47
	sid-snapshot-20160901:1.47
	sid-snapshot-20160801:1.47
	sid-snapshot-20160701:1.47
	sid-snapshot-20160601:1.47
	sid-snapshot-20160501:1.47
	sid-snapshot-20160401:1.47
	sid-snapshot-20160301:1.47
	sid-snapshot-20160201:1.47
	sid-snapshot-20160101:1.47
	sid-snapshot-20151201:1.47
	sid-snapshot-20151101:1.47
	sid-snapshot-20151001:1.47
	sid-snapshot-20150901:1.47
	sid-snapshot-20150801:1.47
	sid-snapshot-20150701:1.47
	sid-snapshot-20150601:1.47
	sid-snapshot-20150501:1.47
	sid-snapshot-20150401:1.47
	sid-snapshot-20150301:1.47
	sid-snapshot-20150201:1.47
	sid-snapshot-20150101:1.47
	sid-snapshot-20141201:1.47
	sid-snapshot-20141101:1.47
	sid-snapshot-20141001:1.47
	sid-snapshot-20140901:1.47
	sid-snapshot-20140801:1.47
	sid-snapshot-20140701:1.47
	sid-snapshot-20140601:1.47
	sid-snapshot-20140501:1.47
	sid-snapshot-20140401:1.47
	sid-snapshot-20140301:1.47
	sid-snapshot-20140201:1.47
	sid-snapshot-20140101:1.47
	sid-snapshot-20131201:1.47
	sid-snapshot-20131101:1.47
	sid-snapshot-20131001:1.47
	binutils-2_24-branch:1.47.0.2
	binutils-2_24-branchpoint:1.47
	binutils-2_21_1:1.41
	sid-snapshot-20130901:1.47
	gdb_7_6_1-2013-08-30-release:1.45
	sid-snapshot-20130801:1.47
	sid-snapshot-20130701:1.47
	sid-snapshot-20130601:1.47
	sid-snapshot-20130501:1.47
	gdb_7_6-2013-04-26-release:1.45
	sid-snapshot-20130401:1.45
	binutils-2_23_2:1.43
	gdb_7_6-branch:1.45.0.2
	gdb_7_6-2013-03-12-branchpoint:1.45
	sid-snapshot-20130301:1.45
	sid-snapshot-20130201:1.45
	sid-snapshot-20130101:1.43
	sid-snapshot-20121201:1.43
	gdb_7_5_1-2012-11-29-release:1.43
	binutils-2_23_1:1.43
	sid-snapshot-20121101:1.43
	binutils-2_23:1.43
	sid-snapshot-20121001:1.43
	sid-snapshot-20120901:1.43
	gdb_7_5-2012-08-17-release:1.43
	sid-snapshot-20120801:1.43
	binutils-2_23-branch:1.43.0.10
	binutils-2_23-branchpoint:1.43
	gdb_7_5-branch:1.43.0.8
	gdb_7_5-2012-07-18-branchpoint:1.43
	sid-snapshot-20120701:1.43
	sid-snapshot-20120601:1.43
	sid-snapshot-20120501:1.43
	binutils-2_22_branch:1.43.0.6
	gdb_7_4_1-2012-04-26-release:1.43
	sid-snapshot-20120401:1.43
	sid-snapshot-20120301:1.43
	sid-snapshot-20120201:1.43
	gdb_7_4-2012-01-24-release:1.43
	sid-snapshot-20120101:1.43
	gdb_7_4-branch:1.43.0.4
	gdb_7_4-2011-12-13-branchpoint:1.43
	sid-snapshot-20111201:1.43
	binutils-2_22:1.43
	sid-snapshot-20111101:1.43
	sid-snapshot-20111001:1.43
	binutils-2_22-branch:1.43.0.2
	binutils-2_22-branchpoint:1.43
	gdb_7_3_1-2011-09-04-release:1.41
	sid-snapshot-20110901:1.43
	sid-snapshot-20110801:1.43
	gdb_7_3-2011-07-26-release:1.41
	sid-snapshot-20110701:1.42
	sid-snapshot-20110601:1.41
	sid-snapshot-20110501:1.41
	gdb_7_3-branch:1.41.0.6
	gdb_7_3-2011-04-01-branchpoint:1.41
	sid-snapshot-20110401:1.41
	sid-snapshot-20110301:1.41
	sid-snapshot-20110201:1.41
	sid-snapshot-20110101:1.41
	binutils-2_21:1.41
	sid-snapshot-20101201:1.41
	binutils-2_21-branch:1.41.0.4
	binutils-2_21-branchpoint:1.41
	sid-snapshot-20101101:1.41
	sid-snapshot-20101001:1.41
	binutils-2_20_1:1.39
	gdb_7_2-2010-09-02-release:1.41
	sid-snapshot-20100901:1.41
	sid-snapshot-20100801:1.41
	gdb_7_2-branch:1.41.0.2
	gdb_7_2-2010-07-07-branchpoint:1.41
	sid-snapshot-20100701:1.41
	sid-snapshot-20100601:1.40
	sid-snapshot-20100501:1.40
	sid-snapshot-20100401:1.40
	gdb_7_1-2010-03-18-release:1.40
	sid-snapshot-20100301:1.40
	gdb_7_1-branch:1.40.0.2
	gdb_7_1-2010-02-18-branchpoint:1.40
	sid-snapshot-20100201:1.40
	sid-snapshot-20100101:1.40
	gdb_7_0_1-2009-12-22-release:1.39
	sid-snapshot-20091201:1.40
	sid-snapshot-20091101:1.39
	binutils-2_20:1.39
	gdb_7_0-2009-10-06-release:1.39
	sid-snapshot-20091001:1.39
	gdb_7_0-branch:1.39.0.4
	gdb_7_0-2009-09-16-branchpoint:1.39
	arc-sim-20090309:1.37
	binutils-arc-20081103-branch:1.37.0.26
	binutils-arc-20081103-branchpoint:1.37
	binutils-2_20-branch:1.39.0.2
	binutils-2_20-branchpoint:1.39
	sid-snapshot-20090901:1.38
	sid-snapshot-20090801:1.38
	msnyder-checkpoint-072509-branch:1.38.0.4
	msnyder-checkpoint-072509-branchpoint:1.38
	sid-snapshot-20090701:1.38
	dje-cgen-play1-branch:1.38.0.2
	dje-cgen-play1-branchpoint:1.38
	sid-snapshot-20090601:1.38
	sid-snapshot-20090501:1.38
	sid-snapshot-20090401:1.37
	arc-20081103-branch:1.37.0.24
	arc-20081103-branchpoint:1.37
	arc-insight_6_8-branch:1.37.0.22
	arc-insight_6_8-branchpoint:1.37
	insight_6_8-branch:1.37.0.20
	insight_6_8-branchpoint:1.37
	sid-snapshot-20090301:1.37
	binutils-2_19_1:1.37
	sid-snapshot-20090201:1.37
	sid-snapshot-20090101:1.37
	reverse-20081226-branch:1.37.0.18
	reverse-20081226-branchpoint:1.37
	sid-snapshot-20081201:1.37
	multiprocess-20081120-branch:1.37.0.16
	multiprocess-20081120-branchpoint:1.37
	sid-snapshot-20081101:1.37
	binutils-2_19:1.37
	sid-snapshot-20081001:1.37
	reverse-20080930-branch:1.37.0.14
	reverse-20080930-branchpoint:1.37
	binutils-2_19-branch:1.37.0.12
	binutils-2_19-branchpoint:1.37
	sid-snapshot-20080901:1.37
	sid-snapshot-20080801:1.37
	reverse-20080717-branch:1.37.0.10
	reverse-20080717-branchpoint:1.37
	sid-snapshot-20080701:1.37
	msnyder-reverse-20080609-branch:1.37.0.8
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.34.0.2
	drow-reverse-20070409-branchpoint:1.34
	sid-snapshot-20080601:1.37
	sid-snapshot-20080501:1.37
	sid-snapshot-20080403:1.37
	sid-snapshot-20080401:1.37
	gdb_6_8-2008-03-27-release:1.37
	sid-snapshot-20080301:1.37
	gdb_6_8-branch:1.37.0.6
	gdb_6_8-2008-02-26-branchpoint:1.37
	sid-snapshot-20080201:1.37
	sid-snapshot-20080101:1.37
	sid-snapshot-20071201:1.37
	sid-snapshot-20071101:1.37
	gdb_6_7_1-2007-10-29-release:1.37
	gdb_6_7-2007-10-10-release:1.37
	sid-snapshot-20071001:1.37
	gdb_6_7-branch:1.37.0.4
	gdb_6_7-2007-09-07-branchpoint:1.37
	binutils-2_18:1.37
	binutils-2_18-branch:1.37.0.2
	binutils-2_18-branchpoint:1.37
	insight_6_6-20070208-release:1.32
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	gdb_6_6-2006-12-18-release:1.32
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.25
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	gdb_6_6-branch:1.32.0.2
	gdb_6_6-2006-11-15-branchpoint:1.32
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	insight_6_5-20061003-release:1.30
	gdb-csl-symbian-6_4_50_20060226-12:1.29
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	gdb-csl-sourcerygxx-3_4_4-25:1.29
	binutils-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.31
	gdb-csl-symbian-6_4_50_20060226-11:1.29
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	gdb-csl-sourcerygxx-4_1-17:1.29
	binutils-csl-sourcerygxx-4_1-17:1.29
	gdb-csl-20060226-branch-local-2:1.29
	gdb-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	gdb-csl-sourcerygxx-4_1-13:1.29
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	gdb-csl-sourcerygxx-4_1-12:1.29
	binutils-csl-sourcerygxx-4_1-12:1.29
	gdb-csl-sourcerygxx-3_4_4-21:1.29
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	gdb_6_5-20060621-release:1.30
	binutils-csl-wrs-linux-3_4_4-24:1.25
	binutils-csl-wrs-linux-3_4_4-23:1.25
	gdb-csl-sourcerygxx-4_1-9:1.29
	binutils-csl-sourcerygxx-4_1-9:1.29
	gdb-csl-sourcerygxx-4_1-8:1.29
	binutils-csl-sourcerygxx-4_1-8:1.29
	gdb-csl-sourcerygxx-4_1-7:1.29
	binutils-csl-sourcerygxx-4_1-7:1.29
	gdb-csl-arm-2006q1-6:1.29
	binutils-csl-arm-2006q1-6:1.29
	gdb-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.25
	gdb-csl-symbian-6_4_50_20060226-10:1.29
	gdb-csl-symbian-6_4_50_20060226-9:1.29
	gdb-csl-symbian-6_4_50_20060226-8:1.29
	gdb-csl-coldfire-4_1-11:1.29
	binutils-csl-coldfire-4_1-11:1.29
	gdb-csl-sourcerygxx-3_4_4-19:1.29
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	gdb-csl-coldfire-4_1-10:1.29
	gdb_6_5-branch:1.30.0.4
	gdb_6_5-2006-05-14-branchpoint:1.30
	binutils-csl-coldfire-4_1-10:1.29
	gdb-csl-sourcerygxx-4_1-5:1.29
	binutils-csl-sourcerygxx-4_1-5:1.29
	nickrob-async-20060513-branch:1.30.0.2
	nickrob-async-20060513-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-4:1.29
	binutils-csl-sourcerygxx-4_1-4:1.29
	msnyder-reverse-20060502-branch:1.29.0.24
	msnyder-reverse-20060502-branchpoint:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.25
	gdb-csl-morpho-4_1-4:1.29
	binutils-csl-morpho-4_1-4:1.29
	gdb-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.25
	readline_5_1-import-branch:1.29.0.22
	readline_5_1-import-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.29
	binutils-2_17-branch:1.29.0.20
	binutils-2_17-branchpoint:1.29
	gdb-csl-symbian-20060226-branch:1.29.0.18
	gdb-csl-symbian-20060226-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.29
	msnyder-reverse-20060331-branch:1.29.0.16
	msnyder-reverse-20060331-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.14
	binutils-csl-2_17-branchpoint:1.29
	gdb-csl-available-20060303-branch:1.29.0.12
	gdb-csl-available-20060303-branchpoint:1.29
	gdb-csl-20060226-branch:1.29.0.10
	gdb-csl-20060226-branchpoint:1.29
	gdb_6_4-20051202-release:1.29
	msnyder-fork-checkpoint-branch:1.29.0.8
	msnyder-fork-checkpoint-branchpoint:1.29
	gdb-csl-gxxpro-6_3-branch:1.29.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.29
	gdb_6_4-branch:1.29.0.4
	gdb_6_4-2005-11-01-branchpoint:1.29
	gdb-csl-arm-20051020-branch:1.29.0.2
	gdb-csl-arm-20051020-branchpoint:1.29
	binutils-csl-gxxpro-3_4-branch:1.25.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.25
	binutils-2_16_1:1.25
	msnyder-tracepoint-checkpoint-branch:1.28.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.28
	gdb-csl-arm-20050325-2005-q1b:1.25
	binutils-csl-arm-2005q1b:1.25
	binutils-2_16:1.25
	gdb-csl-arm-20050325-2005-q1a:1.25
	binutils-csl-arm-2005q1a:1.25
	csl-arm-20050325-branch:1.25.0.6
	csl-arm-20050325-branchpoint:1.25
	binutils-csl-arm-2005q1-branch:1.25.0.4
	binutils-csl-arm-2005q1-branchpoint:1.25
	binutils-2_16-branch:1.25.0.2
	binutils-2_16-branchpoint:1.25
	csl-arm-2004-q3d:1.24
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.2
	gdb_6_3-20041019-branchpoint:1.21
	csl-arm-2004-q3:1.20
	drow_intercu-merge-20040921:1.20
	drow_intercu-merge-20040915:1.20
	jimb-gdb_6_2-e500-branch:1.19.0.6
	jimb-gdb_6_2-e500-branchpoint:1.19
	gdb_6_2-20040730-release:1.19
	gdb_6_2-branch:1.19.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.19
	gdb_6_1_1-20040616-release:1.16
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.16
	gdb_6_1-2004-04-05-release:1.16
	drow_intercu-merge-20040402:1.16
	drow_intercu-merge-20040327:1.16
	ezannoni_pie-20040323-branch:1.16.0.14
	ezannoni_pie-20040323-branchpoint:1.16
	cagney_tramp-20040321-mergepoint:1.16
	cagney_tramp-20040309-branch:1.16.0.12
	cagney_tramp-20040309-branchpoint:1.16
	gdb_6_1-branch:1.16.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.16
	drow_intercu-20040221-branch:1.16.0.8
	drow_intercu-20040221-branchpoint:1.16
	binutils-2_15-branch:1.16.0.6
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-merge-20040208:1.16
	carlton_dictionary-20040126-merge:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	drow-cplus-merge-20040113:1.16
	csl-arm-2003-q4:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.14.0.38
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.36
	cagney_x86i386-20030821-branch:1.14.0.34
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.32
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.14
	cagney_convert-20030606-branch:1.14.0.28
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.26
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.22
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	binutils-2_14-branch:1.14.0.18
	binutils-2_14-branchpoint:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.16
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.14
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.12
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.10
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.8
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.6
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.4
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.2
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030202-branch:1.13.0.4
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.2
	cagney-unwind-20030108-branchpoint:1.13
	binutils-2_13_2_1:1.12
	binutils-2_13_2:1.12
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	binutils-2_13_1:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.14
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.12
	carlton_dictionary-20020920-branchpoint:1.12
	sid-20020905-branchpoint:1.12
	sid-20020905-branch:1.12.0.10
	gdb_5_3-branch:1.12.0.8
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.6
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.4
	readline_4_3-import-branchpoint:1.12
	binutils-2_13:1.12
	gdb_5_2_1-2002-07-23-release:1.5
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.2
	kseitz_interps-20020528-branch:1.8.0.2
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.7.0.4
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.4.2.2
	jimb-macro-020506-branch:1.7.0.2
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.5
	binutils-2_12:1.4.2.1
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.3
	binutils_latest_snapshot:1.47;
locks; strict;
comment	@ * @;


1.47
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.14.14.53.01;	author hp;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.26.02.08.01;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.11.15.03.06;	author clm;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.06.01.26.03;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.23.14.41.30;	author pbrook;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.26.11.13.59;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.15.08.33.53;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.20.02.09.56;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.17.13.29.55;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.23.17.44.55;	author fnf;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.04.15.53.35;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.04.07.19.32;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.24.22.50.43;	author hp;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.24.21.40.36;	author hp;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.24.14.09.16;	author hp;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.08.14.54.01;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.17.16.40.00;	author bwilson;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches
	1.16.8.1;
next	1.15;

1.15
date	2003.10.16.04.11.07;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.29.21.45.09;	author hp;	state Exp;
branches
	1.12.12.1
	1.12.14.1;
next	1.11;

1.11
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.08.07.27.52;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.05.03.43.11;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.00.18.57;	author amodra;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.03.14.09.41.54;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.17.21.18.33;	author hp;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.01.08.18.56;	author hp;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.01.06.07.30.35;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.19.01.22.45;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.30.15.20.02;	author nickc;	state Exp;
branches;
next	;

1.16.8.1
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	;

1.12.12.1
date	2002.12.23.19.37.55;	author carlton;	state Exp;
branches;
next	1.12.12.2;

1.12.12.2
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.12.12.3;

1.12.12.3
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	;

1.12.14.1
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.20.01.31.01;	author kseitz;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.4.2.1
date	2002.02.17.22.55.35;	author hp;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.03.28.06.20.03;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.47
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@/* BFD back-end for mmo objects (MMIX-specific object-format).
   Copyright 2001-2013 Free Software Foundation, Inc.
   Written by Hans-Peter Nilsson (hp@@bitrange.com).
   Infrastructure and other bits originally copied from srec.c and
   binary.c.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/*
SECTION
	mmo backend

	The mmo object format is used exclusively together with Professor
	Donald E.@@: Knuth's educational 64-bit processor MMIX.  The simulator
	@@command{mmix} which is available at
	@@url{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz}
	understands this format.  That package also includes a combined
	assembler and linker called @@command{mmixal}.  The mmo format has
	no advantages feature-wise compared to e.g. ELF.  It is a simple
	non-relocatable object format with no support for archives or
	debugging information, except for symbol value information and
	line numbers (which is not yet implemented in BFD).  See
	@@url{http://www-cs-faculty.stanford.edu/~knuth/mmix.html} for more
	information about MMIX.  The ELF format is used for intermediate
	object files in the BFD implementation.

@@c We want to xref the symbol table node.  A feature in "chew"
@@c requires that "commands" do not contain spaces in the
@@c arguments.  Hence the hyphen in "Symbol-table".
@@menu
@@* File layout::
@@* Symbol-table::
@@* mmo section mapping::
@@end menu

INODE
File layout, Symbol-table, mmo, mmo
SUBSECTION
	File layout

	The mmo file contents is not partitioned into named sections as
	with e.g.@@: ELF.  Memory areas is formed by specifying the
	location of the data that follows.  Only the memory area
	@@samp{0x0000@@dots{}00} to @@samp{0x01ff@@dots{}ff} is executable, so
	it is used for code (and constants) and the area
	@@samp{0x2000@@dots{}00} to @@samp{0x20ff@@dots{}ff} is used for
	writable data.  @@xref{mmo section mapping}.

	There is provision for specifying ``special data'' of 65536
	different types.  We use type 80 (decimal), arbitrarily chosen the
	same as the ELF <<e_machine>> number for MMIX, filling it with
	section information normally found in ELF objects. @@xref{mmo
	section mapping}.

	Contents is entered as 32-bit words, xor:ed over previous
	contents, always zero-initialized.  A word that starts with the
	byte @@samp{0x98} forms a command called a @@samp{lopcode}, where
	the next byte distinguished between the thirteen lopcodes.  The
	two remaining bytes, called the @@samp{Y} and @@samp{Z} fields, or
	the @@samp{YZ} field (a 16-bit big-endian number), are used for
	various purposes different for each lopcode.  As documented in
	@@url{http://www-cs-faculty.stanford.edu/~knuth/mmixal-intro.ps.gz},
	the lopcodes are:

	@@table @@code
	@@item lop_quote
	0x98000001.  The next word is contents, regardless of whether it
	starts with 0x98 or not.

	@@item lop_loc
	0x9801YYZZ, where @@samp{Z} is 1 or 2.  This is a location
	directive, setting the location for the next data to the next
	32-bit word (for @@math{Z = 1}) or 64-bit word (for @@math{Z = 2}),
	plus @@math{Y * 2^56}.  Normally @@samp{Y} is 0 for the text segment
	and 2 for the data segment.

	@@item lop_skip
	0x9802YYZZ.  Increase the current location by @@samp{YZ} bytes.

	@@item lop_fixo
	0x9803YYZZ, where @@samp{Z} is 1 or 2.  Store the current location
	as 64 bits into the location pointed to by the next 32-bit
	(@@math{Z = 1}) or 64-bit (@@math{Z = 2}) word, plus @@math{Y *
	2^56}.

	@@item lop_fixr
	0x9804YYZZ.  @@samp{YZ} is stored into the current location plus
	@@math{2 - 4 * YZ}.

	@@item lop_fixrx
	0x980500ZZ.  @@samp{Z} is 16 or 24.  A value @@samp{L} derived from
	the following 32-bit word are used in a manner similar to
	@@samp{YZ} in lop_fixr: it is xor:ed into the current location
	minus @@math{4 * L}.  The first byte of the word is 0 or 1.  If it
	is 1, then @@math{L = (@@var{lowest 24 bits of word}) - 2^Z}, if 0,
 	then @@math{L = (@@var{lowest 24 bits of word})}.

	@@item lop_file
	0x9806YYZZ.  @@samp{Y} is the file number, @@samp{Z} is count of
	32-bit words.  Set the file number to @@samp{Y} and the line
	counter to 0.  The next @@math{Z * 4} bytes contain the file name,
	padded with zeros if the count is not a multiple of four.  The
	same @@samp{Y} may occur multiple times, but @@samp{Z} must be 0 for
	all but the first occurrence.

	@@item lop_line
	0x9807YYZZ.  @@samp{YZ} is the line number.  Together with
	lop_file, it forms the source location for the next 32-bit word.
	Note that for each non-lopcode 32-bit word, line numbers are
	assumed incremented by one.

	@@item lop_spec
	0x9808YYZZ.  @@samp{YZ} is the type number.  Data until the next
	lopcode other than lop_quote forms special data of type @@samp{YZ}.
	@@xref{mmo section mapping}.

	Other types than 80, (or type 80 with a content that does not
	parse) is stored in sections named <<.MMIX.spec_data.@@var{n}>>
	where @@var{n} is the @@samp{YZ}-type.  The flags for such a
	sections say not to allocate or load the data.  The vma is 0.
	Contents of multiple occurrences of special data @@var{n} is
	concatenated to the data of the previous lop_spec @@var{n}s.  The
	location in data or code at which the lop_spec occurred is lost.

	@@item lop_pre
	0x980901ZZ.  The first lopcode in a file.  The @@samp{Z} field forms the
	length of header information in 32-bit words, where the first word
	tells the time in seconds since @@samp{00:00:00 GMT Jan 1 1970}.

	@@item lop_post
	0x980a00ZZ.  @@math{Z > 32}.  This lopcode follows after all
	content-generating lopcodes in a program.  The @@samp{Z} field
	denotes the value of @@samp{rG} at the beginning of the program.
	The following @@math{256 - Z} big-endian 64-bit words are loaded
	into global registers @@samp{$G} @@dots{} @@samp{$255}.

	@@item lop_stab
	0x980b0000.  The next-to-last lopcode in a program.  Must follow
	immediately after the lop_post lopcode and its data.  After this
	lopcode follows all symbols in a compressed format
	(@@pxref{Symbol-table}).

	@@item lop_end
	0x980cYYZZ.  The last lopcode in a program.  It must follow the
	lop_stab lopcode and its data.  The @@samp{YZ} field contains the
	number of 32-bit words of symbol table information after the
	preceding lop_stab lopcode.
	@@end table

	Note that the lopcode "fixups"; <<lop_fixr>>, <<lop_fixrx>> and
	<<lop_fixo>> are not generated by BFD, but are handled.  They are
	generated by <<mmixal>>.

EXAMPLE
	This trivial one-label, one-instruction file:

| :Main TRAP 1,2,3

	can be represented this way in mmo:

| 0x98090101 - lop_pre, one 32-bit word with timestamp.
| <timestamp>
| 0x98010002 - lop_loc, text segment, using a 64-bit address.
|              Note that mmixal does not emit this for the file above.
| 0x00000000 - Address, high 32 bits.
| 0x00000000 - Address, low 32 bits.
| 0x98060002 - lop_file, 2 32-bit words for file-name.
| 0x74657374 - "test"
| 0x2e730000 - ".s\0\0"
| 0x98070001 - lop_line, line 1.
| 0x00010203 - TRAP 1,2,3
| 0x980a00ff - lop_post, setting $255 to 0.
| 0x00000000
| 0x00000000
| 0x980b0000 - lop_stab for ":Main" = 0, serial 1.
| 0x203a4040   @@xref{Symbol-table}.
| 0x10404020
| 0x4d206120
| 0x69016e00
| 0x81000000
| 0x980c0005 - lop_end; symbol table contained five 32-bit words.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "libiberty.h"
#include "elf/mmix.h"
#include "opcode/mmix.h"

#define LOP 0x98
#define LOP_QUOTE 0
#define LOP_LOC 1
#define LOP_SKIP 2
#define LOP_FIXO 3
#define LOP_FIXR 4
#define LOP_FIXRX 5
#define LOP_FILE 6
#define LOP_LINE 7
#define LOP_SPEC 8
#define LOP_PRE 9
#define LOP_POST 10
#define LOP_STAB 11
#define LOP_END 12

#define LOP_QUOTE_NEXT ((LOP << 24) | (LOP_QUOTE << 16) | 1)
#define SPEC_DATA_SECTION 80
#define LOP_SPEC_SECTION \
 ((LOP << 24) | (LOP_SPEC << 16) | SPEC_DATA_SECTION)

/* Must be a power of two.  If you change this to be >= 64k, you need a
   new test-case; the ld test b-loc64k.d touches chunk-size problem areas.  */
#define MMO_SEC_CONTENTS_CHUNK_SIZE (1 << 15)

/* An arbitrary number for the maximum length section name size.  */
#define MAX_SECTION_NAME_SIZE (1024 * 1024)

/* A quite arbitrary number for the maximum length section size.  */
#define MAX_ARTIFICIAL_SECTION_SIZE (1024 * 1024 * 1024)

#define MMO3_WCHAR 0x80
#define MMO3_LEFT 0x40
#define MMO3_MIDDLE 0x20
#define MMO3_RIGHT 0x10
#define MMO3_TYPEBITS 0xf
#define MMO3_REGQUAL_BITS 0xf
#define MMO3_UNDEF 2
#define MMO3_DATA 8
#define MMO3_SYMBITS 0x2f

/* Put these everywhere in new code.  */
#define FATAL_DEBUG						\
 _bfd_abort (__FILE__, __LINE__,				\
	     "Internal: Non-debugged code (test-case missing)")

#define BAD_CASE(x)				\
 _bfd_abort (__FILE__, __LINE__,		\
	     "bad case for " #x)

enum mmo_sym_type { mmo_reg_sym, mmo_undef_sym, mmo_data_sym, mmo_abs_sym};

/* When scanning the mmo file, a linked list of mmo_symbol
   structures is built to represent the symbol table (if there is
   one).  */

struct mmo_symbol
  {
    struct mmo_symbol *next;
    char *name;
    bfd_vma value;
    enum mmo_sym_type sym_type;
    unsigned int serno;
  };

struct mmo_data_list_struct
  {
    struct mmo_data_list_struct *next;
    bfd_vma where;
    bfd_size_type size;
    bfd_size_type allocated_size;
    bfd_byte data[1];
  };

typedef struct mmo_data_list_struct mmo_data_list_type;

struct mmo_symbol_trie
  {
    struct mmo_symbol_trie *left;
    struct mmo_symbol_trie *right;
    struct mmo_symbol_trie *middle;

    bfd_byte symchar;

    /* A zero name means there's nothing here.  */
    struct mmo_symbol sym;
  };

/* The mmo tdata information.  */

struct mmo_data_struct
  {
    struct mmo_symbol *symbols;
    struct mmo_symbol *symtail;
    asymbol *csymbols;

    /* File representation of time (NULL) when this file was created.  */
    bfd_byte created[4];

    /* When we're reading bytes recursively, check this occasionally.
       Also holds write errors.  */
    bfd_boolean have_error;

    /* Max symbol length that may appear in the lop_stab table.  Note that
       this table might just hold a subset of symbols for not-really large
       programs, as it can only be 65536 * 4 bytes large.  */
    int max_symbol_length;

    /* Here's the symbol we build in lop_stab.  */
    char *lop_stab_symbol;

    /* Index into lop_stab_symbol for the next character when parsing the
       symbol information.  */
    int symbol_position;

    /* When creating arbitrary sections, we need to count section numbers.  */
    int sec_no;

    /* When writing or reading byte-wise, we need to count the bytes
       within a 32-bit word.  */
    int byte_no;

    /* We also need a buffer to hold the bytes we count reading or writing.  */
    bfd_byte buf[4];
  };

typedef struct mmo_data_struct tdata_type;

struct mmo_section_data_struct
  {
    mmo_data_list_type *head;
    mmo_data_list_type *tail;
  };

#define mmo_section_data(sec) \
  ((struct mmo_section_data_struct *) (sec)->used_by_bfd)

/* These structures are used in bfd_map_over_sections constructs.  */

/* Used when writing out sections; all but the register contents section
   which is stored in reg_section.  */
struct mmo_write_sec_info
  {
    asection *reg_section;
    bfd_boolean retval;
  };

/* Used when trying to find a section corresponding to addr.  */
struct mmo_find_sec_info
  {
    asection *sec;
    bfd_vma addr;
  };

static bfd_boolean mmo_bfd_copy_private_bfd_data (bfd *, bfd *);
static void mmo_write_section_unless_reg_contents (bfd *, asection *, void *);
static void mmo_find_sec_w_addr (bfd *, asection *, void *);
static void mmo_find_sec_w_addr_grow (bfd *, asection *, void *);
static asection *mmo_make_section (bfd *, const char *);
static void mmo_get_symbol_info (bfd *, asymbol *, symbol_info *);
static void mmo_print_symbol (bfd *, void *, asymbol *,
			      bfd_print_symbol_type);
static void mmo_init (void);
static bfd_boolean mmo_mkobject (bfd *);
static bfd_boolean mmo_scan (bfd *);
static asection *mmo_decide_section (bfd *, bfd_vma);
static asection *mmo_get_generic_spec_data_section (bfd *, int);
static asection *mmo_get_spec_section (bfd *, int);
static INLINE bfd_byte *mmo_get_loc (asection *, bfd_vma, int);
static void mmo_xore_64 (asection *, bfd_vma vma, bfd_vma value);
static void mmo_xore_32 (asection *, bfd_vma vma, unsigned int);
static void mmo_xore_16 (asection *, bfd_vma vma, unsigned int);
static const bfd_target *mmo_object_p (bfd *);
static void mmo_map_set_sizes (bfd *, asection *, void *);
static bfd_boolean mmo_get_symbols (bfd *);
static bfd_boolean mmo_create_symbol (bfd *, const char *, bfd_vma,
				      enum mmo_sym_type, unsigned int);
static bfd_boolean mmo_get_section_contents (bfd *, asection *, void *,
					     file_ptr, bfd_size_type);
static long mmo_get_symtab_upper_bound (bfd *);
static long mmo_canonicalize_symtab (bfd *, asymbol **);
static void mmo_get_symbol_info (bfd *, asymbol *, symbol_info *);
static void mmo_print_symbol (bfd *, void *, asymbol *,
			      bfd_print_symbol_type);
static bfd_boolean mmo_set_section_contents (bfd *, sec_ptr, const void *,
					     file_ptr, bfd_size_type);
static int mmo_sizeof_headers (bfd *, struct bfd_link_info *);
static bfd_boolean mmo_internal_write_header (bfd *);
static bfd_boolean mmo_internal_write_post (bfd *, int, asection *);
static bfd_boolean mmo_internal_add_3_sym (bfd *, struct mmo_symbol_trie *,
					   const struct mmo_symbol *);
static unsigned int mmo_internal_3_length (bfd *, struct mmo_symbol_trie *);
static void mmo_internal_3_dump (bfd *, struct mmo_symbol_trie *);
static void mmo_beb128_out (bfd *, int, int);
static bfd_boolean mmo_internal_write_section (bfd *, asection *);
static void mmo_write_tetra (bfd *, unsigned int);
static void mmo_write_tetra_raw (bfd *, unsigned int);
static void mmo_write_octa (bfd *, bfd_vma);
static void mmo_write_octa_raw (bfd *, bfd_vma);
static bfd_boolean mmo_write_chunk (bfd *, const bfd_byte *, unsigned int);
static bfd_boolean mmo_flush_chunk (bfd *);
static bfd_boolean mmo_write_loc_chunk (bfd *, bfd_vma, const bfd_byte *,
					unsigned int, bfd_vma *);
static bfd_boolean mmo_write_chunk_list (bfd *, mmo_data_list_type *);
static bfd_boolean mmo_write_loc_chunk_list (bfd *, mmo_data_list_type *);
static bfd_boolean mmo_write_symbols_and_terminator (bfd *);
static flagword mmo_sec_flags_from_bfd_flags (flagword);
static flagword bfd_sec_flags_from_mmo_flags (flagword);
static bfd_byte mmo_get_byte (bfd *);
static void mmo_write_byte (bfd *, bfd_byte);
static bfd_boolean mmo_new_section_hook (bfd *, asection *);
static int mmo_sort_mmo_symbols (const void *, const void *);
static bfd_boolean mmo_write_object_contents (bfd *);
static bfd_boolean mmo_write_section_description (bfd *, asection *);
static bfd_boolean mmo_has_leading_or_trailing_zero_tetra_p (bfd *,
							     asection *);

/* Global "const" variables initialized once.  Must not depend on
   particular input or caller; put such things into the bfd or elsewhere.
   Look ma, no static per-invocation data!  */

static
char valid_mmo_symbol_character_set[/* A-Z a-z (we assume consecutive
				       codes; sorry EBCDIC:ers!).  */
				    + 'Z' - 'A' + 1 + 'z' - 'a' + 1
				    /* Digits.  */
				    + 10
				    /* ':' and '_'.  */
				    + 1 + 1
				    /* Codes higher than 126.  */
				    + 256 - 126
				    /* Ending zero.  */
				    + 1];


/* Get section SECNAME or create one if it doesn't exist.  When creating
   one, new memory for the name is allocated.  */

static asection *
mmo_make_section (bfd *abfd, const char *secname)
{
  asection *sec = bfd_get_section_by_name (abfd, secname);

  if (sec == NULL)
    {
      char *newsecname = strdup (secname);

      if (newsecname == NULL)
	{
	  (*_bfd_error_handler)
	    (_("%s: No core to allocate section name %s\n"),
	     bfd_get_filename (abfd), secname);
	  bfd_set_error (bfd_error_system_call);
	  return NULL;
	}
      sec = bfd_make_section (abfd, newsecname);
    }

  return sec;
}

/* Nothing to do, but keep as a placeholder if we need it.
   Note that state that might differ between bfd:s must not be initialized
   here, nor must it be static.  Add it to tdata information instead.  */

static void
mmo_init (void)
{
  static bfd_boolean inited = FALSE;
  int i = 0;
  int j = 0;
  static const char letters[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789:_";

  if (inited)
    return;
  inited = TRUE;

  /* Fill in the set of valid symbol characters.  */
  strcpy (valid_mmo_symbol_character_set, letters);
  i = strlen (letters);

  for (j = 126; j < 256; j++)
    valid_mmo_symbol_character_set[i++] = j;
}

/* Check whether an existing file is an mmo file.  */

static const bfd_target *
mmo_object_p (bfd *abfd)
{
  struct stat statbuf;
  bfd_byte b[4];

  mmo_init ();

  if (bfd_stat (abfd, &statbuf) < 0
      || bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (b, 4, abfd) != 4)
    goto bad_final;

  /* All mmo files are a multiple of four bytes long.
     Only recognize version one.  */
  if ((statbuf.st_size % 4) != 0
      || b[0] != LOP || b[1] != LOP_PRE || b[2] != 1)
    goto bad_format;

  /* Get the last 32-bit word.  */
  if (bfd_seek (abfd, (file_ptr) statbuf.st_size - 4, SEEK_SET) != 0
      || bfd_bread (b, 4, abfd) != 4)
    goto bad_final;

  /* Check if the file ends in a lop_end lopcode. */
  if (b[0] != LOP || b[1] != LOP_END || ! mmo_mkobject (abfd))
    goto bad_format;

  /* Compute an upper bound on the max symbol length.  Not really
     important as all of the symbol information can only be 256k.  */
  abfd->tdata.mmo_data->max_symbol_length = (b[2] * 256 + b[3]) * 4;
  abfd->tdata.mmo_data->lop_stab_symbol
    = bfd_malloc (abfd->tdata.mmo_data->max_symbol_length + 1);

  if (abfd->tdata.mmo_data->lop_stab_symbol == NULL)
    {
      (*_bfd_error_handler)
	(_("%s: No core to allocate a symbol %d bytes long\n"),
	 bfd_get_filename (abfd), abfd->tdata.mmo_data->max_symbol_length);
      goto bad_final;
    }

  /* Read in everything.  */
  if (! mmo_scan (abfd))
    goto bad_format_free;

  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

  /* You'll have to tweak this if you want to use this format for other
     arches (not recommended due to its small-size limitations).  Look at
     the ELF format for how to make it target-generic.  */
  if (! bfd_default_set_arch_mach (abfd, bfd_arch_mmix, 0))
    goto bad_format_free;

  return abfd->xvec;

 bad_format_free:
  free (abfd->tdata.mmo_data->lop_stab_symbol);
 bad_format:
  bfd_set_error (bfd_error_wrong_format);
 bad_final:
  return NULL;
}

/* Set up the mmo tdata information.  */

static bfd_boolean
mmo_mkobject (bfd *abfd)
{
  mmo_init ();

  if (abfd->tdata.mmo_data == NULL)
    {
      time_t created;

      /* All fields are zero-initialized, so we don't have to explicitly
	 initialize most.  */
      tdata_type *tdata = (tdata_type *) bfd_zmalloc (sizeof (tdata_type));
      if (tdata == NULL)
	return FALSE;

      created = time (NULL);
      bfd_put_32 (abfd, created, tdata->created);

      abfd->tdata.mmo_data = tdata;
    }

  return TRUE;
}

static bfd_boolean
mmo_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_mmo_flavour
      || bfd_get_flavour (obfd) != bfd_target_mmo_flavour)
    return TRUE;

  /* Copy the time the copied-from file was created.  If people want the
     time the file was last *modified*, they have that in the normal file
     information.  */
  memcpy (obfd->tdata.mmo_data->created, ibfd->tdata.mmo_data->created,
	  sizeof (obfd->tdata.mmo_data->created));
  return TRUE;
}

/* Helper functions for mmo_decide_section, used through
   bfd_map_over_sections.  */

static void
mmo_find_sec_w_addr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *p)
{
  struct mmo_find_sec_info *infop = (struct mmo_find_sec_info *) p;
  bfd_vma vma = bfd_get_section_vma (abfd, sec);

  /* Ignore sections that aren't loaded.  */
  if ((bfd_get_section_flags (abfd, sec) & (SEC_LOAD | SEC_ALLOC))
      !=  (SEC_LOAD | SEC_ALLOC))
    return;

  if (infop->addr >= vma && infop->addr < vma + sec->size)
    infop->sec = sec;
}

static void
mmo_find_sec_w_addr_grow (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *p)
{
  struct mmo_find_sec_info *infop = (struct mmo_find_sec_info *) p;
  bfd_vma vma = bfd_get_section_vma (abfd, sec);

  /* Ignore sections that aren't loaded.  */
  if ((bfd_get_section_flags (abfd, sec) & (SEC_LOAD | SEC_ALLOC))
      !=  (SEC_LOAD | SEC_ALLOC))
    return;

  if (infop->addr >= vma && infop->addr < vma + MAX_ARTIFICIAL_SECTION_SIZE)
    infop->sec = sec;
}

/* Find a section that corresponds to a VMA.  Automatically create .text
   or .data and set current section to it, depending on what vma.  If we
   can't deduce a section, make one up as ".MMIX.sec.N", where N is an
   increasing number.  */

static asection *
mmo_decide_section (bfd *abfd, bfd_vma vma)
{
  asection *sec = NULL;
  char sec_name[sizeof (".MMIX.sec.") + 20];
  struct mmo_find_sec_info info;

  info.addr = vma;
  info.sec = NULL;

  /* First see if there's a section that would match exactly.  */
  bfd_map_over_sections (abfd, mmo_find_sec_w_addr, &info);

  if (info.sec != NULL)
    return info.sec;

  /* If there's no such section, try and expand one of the existing ones,
     up to a limit.  Make sure we have .text and .data before we try that;
     create them corresponding to expected addresses and set flags to make
     them match the "loaded and with contents" expectation.  */
  if ((vma >> 56) == 0)
    {
      sec = bfd_make_section_old_way (abfd, MMO_TEXT_SECTION_NAME);

      if (sec == NULL)
	return NULL;

      if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))
	return NULL;

      if (! bfd_set_section_flags (abfd, sec,
				   bfd_get_section_flags (abfd, sec)
				   | SEC_CODE | SEC_LOAD | SEC_ALLOC))
	return NULL;
    }
  else if ((vma >> 56) == 0x20)
    {
      sec = bfd_make_section_old_way (abfd, MMO_DATA_SECTION_NAME);

      if (sec == NULL)
	return NULL;

      if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))
	return NULL;

      if (! bfd_set_section_flags (abfd, sec,
				   bfd_get_section_flags (abfd, sec)
				   | SEC_LOAD | SEC_ALLOC))
	return NULL;
    }

  bfd_map_over_sections (abfd, mmo_find_sec_w_addr_grow, &info);

  if (info.sec != NULL)
    return info.sec;

  /* If there's still no suitable section, make a new one.  */
  sprintf (sec_name, ".MMIX.sec.%d", abfd->tdata.mmo_data->sec_no++);
  sec = mmo_make_section (abfd, sec_name);

  if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))
    return NULL;

  if (! bfd_set_section_flags (abfd, sec,
			       bfd_get_section_flags (abfd, sec)
			       | SEC_LOAD | SEC_ALLOC))
    return NULL;
  return sec;
}

/* Xor in a 64-bit value VALUE at VMA.  */

static INLINE void
mmo_xore_64 (asection *sec, bfd_vma vma, bfd_vma value)
{
  bfd_byte *loc = mmo_get_loc (sec, vma, 8);
  bfd_vma prev = bfd_get_64 (sec->owner, loc);

  value ^= prev;
  bfd_put_64 (sec->owner, value, loc);
}

/* Xor in a 32-bit value VALUE at VMA.  */

static INLINE void
mmo_xore_32 (asection *sec, bfd_vma vma, unsigned int value)
{
  bfd_byte *loc = mmo_get_loc (sec, vma, 4);
  unsigned int prev = bfd_get_32 (sec->owner, loc);

  value ^= prev;
  bfd_put_32 (sec->owner, value, loc);
}

/* Xor in a 16-bit value VALUE at VMA.  */

static INLINE void
mmo_xore_16 (asection *sec, bfd_vma vma, unsigned int value)
{
  bfd_byte *loc = mmo_get_loc (sec, vma, 2);
  unsigned int prev = bfd_get_16 (sec->owner, loc);

  value ^= prev;
  bfd_put_16 (sec->owner, value, loc);
}

/* Write a 32-bit word to output file, no lop_quote generated.  */

static INLINE void
mmo_write_tetra_raw (bfd *abfd, unsigned int value)
{
  bfd_byte buf[4];

  bfd_put_32 (abfd, value, buf);

  if (bfd_bwrite (buf, 4, abfd) != 4)
    abfd->tdata.mmo_data->have_error = TRUE;
}

/* Write a 32-bit word to output file; lop_quote if necessary.  */

static INLINE void
mmo_write_tetra (bfd *abfd, unsigned int value)
{
  if (((value >> 24) & 0xff) == LOP)
    mmo_write_tetra_raw (abfd, LOP_QUOTE_NEXT);

  mmo_write_tetra_raw (abfd, value);
}

/* Write a 64-bit word to output file, perhaps with lop_quoting.  */

static INLINE void
mmo_write_octa (bfd *abfd, bfd_vma value)
{
  mmo_write_tetra (abfd, (unsigned int) (value >> 32));
  mmo_write_tetra (abfd, (unsigned int) value);
}

/* Write a 64-bit word to output file, without lop_quoting.  */

static INLINE void
mmo_write_octa_raw (bfd *abfd, bfd_vma value)
{
  mmo_write_tetra_raw (abfd, (unsigned int) (value >> 32));
  mmo_write_tetra_raw (abfd, (unsigned int) value);
}

/* Write quoted contents.  Intended to be called multiple times in
   sequence, followed by a call to mmo_flush_chunk.  */

static INLINE bfd_boolean
mmo_write_chunk (bfd *abfd, const bfd_byte *loc, unsigned int len)
{
  bfd_boolean retval = TRUE;
  struct mmo_data_struct *mmop = abfd->tdata.mmo_data;

  /* Fill up a tetra from bytes remaining from a previous chunk.  */
  if (mmop->byte_no != 0)
    {
      while (mmop->byte_no < 4 && len != 0)
	{
	  mmop->buf[mmop->byte_no++] = *loc++;
	  len--;
	}

      if (mmop->byte_no == 4)
	{
	  mmo_write_tetra (abfd, bfd_get_32 (abfd, mmop->buf));
	  mmop->byte_no = 0;
	}
    }

  while (len >= 4)
    {
      if (loc[0] == LOP)
	mmo_write_tetra_raw (abfd, LOP_QUOTE_NEXT);

      retval = (retval
		&& ! mmop->have_error
		&& 4 == bfd_bwrite (loc, 4, abfd));

      loc += 4;
      len -= 4;
    }

  if (len)
    {
      memcpy (mmop->buf, loc, len);
      mmop->byte_no = len;
    }

  if (! retval)
    mmop->have_error = TRUE;
  return retval;
}

/* Flush remaining bytes, from a previous mmo_write_chunk, zero-padded to
   4 bytes.  */

static INLINE bfd_boolean
mmo_flush_chunk (bfd *abfd)
{
  if (abfd->tdata.mmo_data->byte_no != 0)
    {
      memset (abfd->tdata.mmo_data->buf + abfd->tdata.mmo_data->byte_no,
	      0, 4 - abfd->tdata.mmo_data->byte_no);
      mmo_write_tetra (abfd,
		       bfd_get_32 (abfd, abfd->tdata.mmo_data->buf));
      abfd->tdata.mmo_data->byte_no = 0;
    }

  return ! abfd->tdata.mmo_data->have_error;
}

/* Same, but from a list.  */

static INLINE bfd_boolean
mmo_write_chunk_list (bfd *abfd, mmo_data_list_type *datap)
{
  for (; datap != NULL; datap = datap->next)
    if (! mmo_write_chunk (abfd, datap->data, datap->size))
      return FALSE;

  return mmo_flush_chunk (abfd);
}

/* Write a lop_loc and some contents.  A caller needs to call
   mmo_flush_chunk after calling this function.  The location is only
   output if different than *LAST_VMAP, which is updated after this call.  */

static bfd_boolean
mmo_write_loc_chunk (bfd *abfd, bfd_vma vma, const bfd_byte *loc,
		     unsigned int len, bfd_vma *last_vmap)
{
  /* Find an initial and trailing section of zero tetras; we don't need to
     write out zeros.  FIXME: When we do this, we should emit section size
     and address specifiers, else objcopy can't always perform an identity
     translation.  Only do this if we *don't* have left-over data from a
     previous write or the vma of this chunk is *not* the next address,
     because then data isn't tetrabyte-aligned and we're concatenating to
     that left-over data.  */

  if (abfd->tdata.mmo_data->byte_no == 0 || vma != *last_vmap)
    {
      while (len >= 4 && bfd_get_32 (abfd, loc) == 0)
	{
	  vma += 4;
	  len -= 4;
	  loc += 4;
	}

      while (len >= 4 && bfd_get_32 (abfd, loc + len - 4) == 0)
	len -= 4;
    }

  /* Only write out the location if it's different than the one the caller
     (supposedly) previously handled, accounting for omitted leading zeros.  */
  if (vma != *last_vmap)
    {
      /* We might be in the middle of a sequence.  */
      mmo_flush_chunk (abfd);

      /* We always write the location as 64 bits; no use saving bytes
         here.  */
      mmo_write_tetra_raw (abfd, (LOP << 24) | (LOP_LOC << 16) | 2);
      mmo_write_octa_raw (abfd, vma);
    }

  /* Update to reflect end of this chunk, with trailing zeros omitted.  */
  *last_vmap = vma + len;

  return (! abfd->tdata.mmo_data->have_error
	  && mmo_write_chunk (abfd, loc, len));
}

/* Same, but from a list.  */

static INLINE bfd_boolean
mmo_write_loc_chunk_list (bfd *abfd, mmo_data_list_type *datap)
{
  /* Get an address different than the address of the first chunk.  */
  bfd_vma last_vma = datap ? datap->where - 1 : 0;

  for (; datap != NULL; datap = datap->next)
    if (! mmo_write_loc_chunk (abfd, datap->where, datap->data, datap->size,
			       &last_vma))
      return FALSE;

  return mmo_flush_chunk (abfd);
}

/* Make a .MMIX.spec_data.N section.  */

static asection *
mmo_get_generic_spec_data_section (bfd *abfd, int spec_data_number)
{
  asection *sec;
  char secname[sizeof (MMIX_OTHER_SPEC_SECTION_PREFIX) + 20]
    = MMIX_OTHER_SPEC_SECTION_PREFIX;

  sprintf (secname + strlen (MMIX_OTHER_SPEC_SECTION_PREFIX),
	   "%d", spec_data_number);

  sec = mmo_make_section (abfd, secname);

  return sec;
}

/* Make a special section for SPEC_DATA_NUMBER.  If it is the one we use
   ourselves, parse some of its data to get at the section name.  */

static asection *
mmo_get_spec_section (bfd *abfd, int spec_data_number)
{
  char *secname;
  asection *sec;
  bfd_byte buf[4];
  unsigned int secname_length;
  unsigned int i;
  bfd_vma section_length;
  bfd_vma section_vma;
  mmo_data_list_type *loc;
  flagword flags;
  long orig_pos;

  /* If this isn't the "special" special data, then make a placeholder
     section.  */
  if (spec_data_number != SPEC_DATA_SECTION)
    return mmo_get_generic_spec_data_section (abfd, spec_data_number);

  /* Seek back to this position if there was a format error.  */
  orig_pos = bfd_tell (abfd);

  /* Read the length (in 32-bit words).  */
  if (bfd_bread (buf, 4, abfd) != 4)
    goto format_error;

  if (buf[0] == LOP)
    {
      if (buf[1] != LOP_QUOTE)
	goto format_error;

      if (bfd_bread (buf, 4, abfd) != 4)
	goto format_error;
    }

  /* We don't care to keep the name length accurate.  It's
     zero-terminated.  */
  secname_length = bfd_get_32 (abfd, buf) * 4;

  /* Check section name length for sanity.  */
  if (secname_length > MAX_SECTION_NAME_SIZE)
    goto format_error;

  /* This should be free'd regardless if a section is created.  */
  secname = bfd_malloc (secname_length + 1);
  secname[secname_length] = 0;

  for (i = 0; i < secname_length / 4; i++)
    {
      if (bfd_bread (secname + i * 4, 4, abfd) != 4)
	goto format_error_free;

      if (secname[i * 4] == (char) LOP)
	{
	  /* A bit of overkill, but we handle char 0x98 in a section name,
	     and recognize misparsing.  */
	  if (secname[i * 4 + 1] != LOP_QUOTE
	      || bfd_bread (secname + i * 4, 4, abfd) != 4)
	    /* Whoops.  We thought this was a name, and now we found a
	       non-lop_quote lopcode before we parsed the whole length of
	       the name.  Signal end-of-file in the same manner.  */
	      goto format_error_free;
	}
    }

  /* Get the section flags.  */
  if (bfd_bread (buf, 4, abfd) != 4
      || (buf[0] == LOP
	  && (buf[1] != LOP_QUOTE || bfd_bread (buf, 4, abfd) != 4)))
    goto format_error_free;

  flags = bfd_get_32 (abfd, buf);

  /* Get the section length.  */
  if (bfd_bread (buf, 4, abfd) != 4
      || (buf[0] == LOP
	  && (buf[1] != LOP_QUOTE || bfd_bread (buf, 4, abfd) != 4)))
    goto format_error_free;

  section_length = (bfd_vma) bfd_get_32 (abfd, buf) << 32;

  /* That's the first, high-part.  Now get the low part.  */

  if (bfd_bread (buf, 4, abfd) != 4
      || (buf[0] == LOP
	  && (buf[1] != LOP_QUOTE || bfd_bread (buf, 4, abfd) != 4)))
    goto format_error_free;

  section_length |= (bfd_vma) bfd_get_32 (abfd, buf);

  /* Check the section length for sanity.  */
  if (section_length > MAX_ARTIFICIAL_SECTION_SIZE)
    goto format_error_free;

  /* Get the section VMA.  */
  if (bfd_bread (buf, 4, abfd) != 4
      || (buf[0] == LOP
	  && (buf[1] != LOP_QUOTE || bfd_bread (buf, 4, abfd) != 4)))
    goto format_error_free;

  section_vma = (bfd_vma) bfd_get_32 (abfd, buf) << 32;

  /* That's the first, high-part.  Now get the low part.  */
  if (bfd_bread (buf, 4, abfd) != 4
      || (buf[0] == LOP
	  && (buf[1] != LOP_QUOTE || bfd_bread (buf, 4, abfd) != 4)))
    goto format_error_free;

  section_vma |= (bfd_vma) bfd_get_32 (abfd, buf);

  sec = mmo_make_section (abfd, secname);
  free (secname);
  if (sec == NULL)
    goto format_error;

  /* We allocate a buffer here for the advertised size, with head room for
     tetrabyte alignment.  */
  loc = bfd_zmalloc (section_length + 3
		     + sizeof (struct mmo_data_list_struct));
  if (loc == NULL)
    goto format_error;

  /* Use a TETRA-rounded size for the allocated buffer; we set the
     "visible" section size below.  */
  loc->size = (section_length + 3) & ~3;

  /* Add in the section flags we found to those bfd entered during this
     process and set the contents.  */
  if (! bfd_set_section_flags (abfd, sec,
			       bfd_sec_flags_from_mmo_flags (flags)
			       | bfd_get_section_flags (abfd, sec)
			       | (section_length != 0 ? SEC_HAS_CONTENTS : 0))
      || ! bfd_set_section_size (abfd, sec, sec->size + section_length)
      /* Set VMA only for the first occurrence.  */
      || (! sec->user_set_vma
	  && ! bfd_set_section_vma  (abfd, sec, section_vma)))
    {
      /* If we get an error for any of the calls above, signal more than
	 just a format error for the spec section.  */
      return NULL;
    }

  loc->next = NULL;
  if (mmo_section_data (sec)->tail != NULL)
    mmo_section_data (sec)->tail->next = loc;
  else
    mmo_section_data (sec)->head = loc;
  mmo_section_data (sec)->tail = loc;
  loc->where = section_vma;

  return sec;

 format_error_free:
  free (secname);
 format_error:
  if (bfd_seek (abfd, orig_pos, SEEK_SET) != 0)
    return NULL;

  return mmo_get_generic_spec_data_section (abfd, spec_data_number);
}

/* Read a byte, but read from file in multiples of 32-bit words.  */

static bfd_byte
mmo_get_byte (bfd *abfd)
{
  bfd_byte retval;

  if (abfd->tdata.mmo_data->byte_no == 0)
    {
      if (! abfd->tdata.mmo_data->have_error
	  && bfd_bread (abfd->tdata.mmo_data->buf, 4, abfd) != 4)
	{
	  abfd->tdata.mmo_data->have_error = TRUE;

	  /* A value somewhat safe against tripping on some inconsistency
	     when mopping up after this error.  */
	  return 128;
	}
    }

  retval = abfd->tdata.mmo_data->buf[abfd->tdata.mmo_data->byte_no];
  abfd->tdata.mmo_data->byte_no = (abfd->tdata.mmo_data->byte_no + 1) % 4;

  return retval;
}

/* Write a byte, in multiples of 32-bit words.  */

static void
mmo_write_byte (bfd *abfd, bfd_byte value)
{
  abfd->tdata.mmo_data->buf[(abfd->tdata.mmo_data->byte_no++ % 4)] = value;
  if ((abfd->tdata.mmo_data->byte_no % 4) == 0)
    {
      if (! abfd->tdata.mmo_data->have_error
	  && bfd_bwrite (abfd->tdata.mmo_data->buf, 4, abfd) != 4)
	abfd->tdata.mmo_data->have_error = TRUE;
    }
}

/* Create a symbol.  */

static bfd_boolean
mmo_create_symbol (bfd *abfd, const char *symname, bfd_vma addr, enum
		   mmo_sym_type sym_type, unsigned int serno)
{
  struct mmo_symbol *n;

  n = (struct mmo_symbol *) bfd_alloc (abfd, sizeof (struct mmo_symbol));
  if (n == NULL)
    return FALSE;

  n->name = bfd_alloc (abfd, strlen (symname) + 1);
  if (n->name == NULL)
    return FALSE;

  strcpy (n->name, symname);

  n->value = addr;
  n->sym_type = sym_type;
  n->serno = serno;

  if (abfd->tdata.mmo_data->symbols == NULL)
    abfd->tdata.mmo_data->symbols = n;
  else
    abfd->tdata.mmo_data->symtail->next = n;
  abfd->tdata.mmo_data->symtail = n;
  n->next = NULL;

  ++abfd->symcount;

  /* Check that :Main equals the last octa of the .MMIX.reg_contents
     section, as it's the one place we're sure to pass when reading a mmo
     object.  For written objects, we do it while setting the symbol
     table.  */
  if (strcmp (symname, MMIX_START_SYMBOL_NAME) == 0
      && bfd_get_start_address (abfd) != addr)
    {
      (*_bfd_error_handler)
	(_("%s: invalid mmo file: initialization value for $255 is not `Main'\n"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}

/* Read in symbols.  */

static bfd_boolean
mmo_get_symbols (bfd *abfd)
{
/*
INODE
Symbol-table, mmo section mapping, File layout, mmo
SUBSECTION
	Symbol table format

	From mmixal.w (or really, the generated mmixal.tex) in
	@@url{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz}):
	``Symbols are stored and retrieved by means of a @@samp{ternary
	search trie}, following ideas of Bentley and Sedgewick. (See
	ACM--SIAM Symp.@@: on Discrete Algorithms @@samp{8} (1997), 360--369;
	R.@@:Sedgewick, @@samp{Algorithms in C} (Reading, Mass.@@:
	Addison--Wesley, 1998), @@samp{15.4}.)  Each trie node stores a
	character, and there are branches to subtries for the cases where
	a given character is less than, equal to, or greater than the
	character in the trie.  There also is a pointer to a symbol table
	entry if a symbol ends at the current node.''

	So it's a tree encoded as a stream of bytes.  The stream of bytes
	acts on a single virtual global symbol, adding and removing
	characters and signalling complete symbol points.  Here, we read
	the stream and create symbols at the completion points.

	First, there's a control byte <<m>>.  If any of the listed bits
	in <<m>> is nonzero, we execute what stands at the right, in
	the listed order:

| (MMO3_LEFT)
| 0x40 - Traverse left trie.
|        (Read a new command byte and recurse.)
|
| (MMO3_SYMBITS)
| 0x2f - Read the next byte as a character and store it in the
|        current character position; increment character position.
|        Test the bits of <<m>>:
|
|        (MMO3_WCHAR)
|        0x80 - The character is 16-bit (so read another byte,
|               merge into current character.
|
|        (MMO3_TYPEBITS)
|        0xf  - We have a complete symbol; parse the type, value
|               and serial number and do what should be done
|               with a symbol.  The type and length information
|               is in j = (m & 0xf).
|
|               (MMO3_REGQUAL_BITS)
|	        j == 0xf: A register variable.  The following
|                         byte tells which register.
|               j <= 8:   An absolute symbol.  Read j bytes as the
|                         big-endian number the symbol equals.
|                         A j = 2 with two zero bytes denotes an
|                         unknown symbol.
|               j > 8:    As with j <= 8, but add (0x20 << 56)
|                         to the value in the following j - 8
|                         bytes.
|
|               Then comes the serial number, as a variant of
|               uleb128, but better named ubeb128:
|               Read bytes and shift the previous value left 7
|               (multiply by 128).  Add in the new byte, repeat
|               until a byte has bit 7 set.  The serial number
|               is the computed value minus 128.
|
|        (MMO3_MIDDLE)
|        0x20 - Traverse middle trie.  (Read a new command byte
|               and recurse.)  Decrement character position.
|
| (MMO3_RIGHT)
| 0x10 - Traverse right trie.  (Read a new command byte and
|        recurse.)

	Let's look again at the <<lop_stab>> for the trivial file
	(@@pxref{File layout}).

| 0x980b0000 - lop_stab for ":Main" = 0, serial 1.
| 0x203a4040
| 0x10404020
| 0x4d206120
| 0x69016e00
| 0x81000000

	This forms the trivial trie (note that the path between ``:'' and
	``M'' is redundant):

| 203a	   ":"
| 40       /
| 40      /
| 10      \
| 40      /
| 40     /
| 204d  "M"
| 2061  "a"
| 2069  "i"
| 016e  "n" is the last character in a full symbol, and
|       with a value represented in one byte.
| 00    The value is 0.
| 81    The serial number is 1.  */

  bfd_byte m = mmo_get_byte (abfd);

  /* Check first if we have a bad hair day.  */
  if (abfd->tdata.mmo_data->have_error)
    return FALSE;

  if (m & MMO3_LEFT)
    /* Traverse left trie. */
    mmo_get_symbols (abfd);

  if (m & MMO3_SYMBITS)
    {
      bfd_byte c = mmo_get_byte (abfd);
      bfd_byte j = m & MMO3_TYPEBITS;
      bfd_vma addr = 0;
      enum mmo_sym_type sym_type;
      unsigned int serno = 0;
      bfd_byte k;

      if (m & MMO3_WCHAR)
	{
	  bfd_byte c2 = mmo_get_byte (abfd);

	  /* A two-byte character.  We can't grok this, but neither can
	     mmotype, for other cases than the second byte being zero.  */

	  if (c != 0)
	    {
	      abfd->tdata.mmo_data->lop_stab_symbol
		[abfd->tdata.mmo_data->symbol_position] = 0;

	      (*_bfd_error_handler)
		(_("%s: unsupported wide character sequence"
		   " 0x%02X 0x%02X after symbol name starting with `%s'\n"),
		 bfd_get_filename (abfd), c, c2,
		 abfd->tdata.mmo_data->lop_stab_symbol);
	      bfd_set_error (bfd_error_bad_value);
	      abfd->tdata.mmo_data->have_error = TRUE;
	      return FALSE;
	    }
	  else
	    c = c2;
	}

      abfd->tdata.mmo_data->lop_stab_symbol[abfd->tdata.mmo_data->symbol_position++] = c;
      abfd->tdata.mmo_data->lop_stab_symbol[abfd->tdata.mmo_data->symbol_position] = 0;

      if (j & MMO3_REGQUAL_BITS)
	{
	  if (j == MMO3_REGQUAL_BITS)
	    {
	      sym_type = mmo_reg_sym;
	      addr = mmo_get_byte (abfd);
	    }
	  else if (j <= 8)
	    {
	      unsigned int i;

	      for (i = 0; i < j; i++)
		addr = (addr << 8) + mmo_get_byte (abfd);

	      if (addr == 0 && j == MMO3_UNDEF)
		sym_type = mmo_undef_sym;
	      else
		sym_type = mmo_abs_sym;
	    }
	  else
	    {
	      unsigned int i;

	      for (i = MMO3_DATA; i < j; i++)
		addr = (addr << 8) + mmo_get_byte (abfd);

	      addr += (bfd_vma) 0x20 << 56;
	      sym_type = mmo_data_sym;
	    }

	  /* Get the serial number.  */
	  do
	    {
	      k = mmo_get_byte (abfd);
	      serno = (serno << 7) + k;
	    }
	  while (k < 128);
	  serno -= 128;

	  /* Got it.  Now enter it.  Skip a leading ":".  */
	  if (! abfd->tdata.mmo_data->have_error
	      && ! mmo_create_symbol (abfd,
				      abfd->tdata.mmo_data->lop_stab_symbol
				      + 1,
				      addr, sym_type, serno))
	    abfd->tdata.mmo_data->have_error = TRUE;
	}

      if (m & MMO3_MIDDLE)
	/* Traverse middle trie. */
	mmo_get_symbols (abfd);

      abfd->tdata.mmo_data->symbol_position--;
    }

  if (m & MMO3_RIGHT)
    /* Traverse right trie.  */
    mmo_get_symbols (abfd);

  return ! abfd->tdata.mmo_data->have_error;
}

/* Get the location of memory area [VMA..VMA + SIZE - 1], which we think
   is in section SEC.  Adjust and reallocate zero-initialized contents.
   If there's new contents, allocate to the next multiple of
   MMO_SEC_CONTENTS_CHUNK_SIZE.  */

static INLINE bfd_byte *
mmo_get_loc (asection *sec, bfd_vma vma, int size)
{
  bfd_size_type allocated_size;
  struct mmo_section_data_struct *sdatap = mmo_section_data (sec);
  struct mmo_data_list_struct *datap = sdatap->head;
  struct mmo_data_list_struct *entry;

  /* First search the list to see if we have the requested chunk in one
     piece, or perhaps if we have a suitable chunk with room to fit.  */
  for (; datap != NULL; datap = datap->next)
    {
      if (datap->where <= vma
	  && datap->where + datap->size >= vma + size)
	return datap->data + vma - datap->where;
      else if (datap->where <= vma
	       && datap->where + datap->allocated_size >= vma + size
	       /* Only munch on the "allocated size" if it does not
		  overlap the next chunk.  */
	       && (datap->next == NULL || datap->next->where >= vma + size))
	{
	  /* There was room allocated, but the size wasn't set to include
	     it.  Do that now.  */
	  datap->size += (vma + size) - (datap->where + datap->size);

	  /* Update the section size.  This happens only if we update the
	     32-bit-aligned chunk size.  Callers that have
	     non-32-bit-aligned sections should do all allocation and
	     size-setting by themselves or at least set the section size
	     after the last allocating call to this function.  */
	  if (vma + size > sec->vma + sec->size)
	    sec->size += (vma + size) - (sec->vma + sec->size);

	  return datap->data + vma - datap->where;
	}
    }

  /* Not found; allocate a new block.  First check in case we get a
     request for a size split up over several blocks; we'll have to return
     NULL for those cases, requesting the caller to split up the request.
     Requests with an address aligned on MMO_SEC_CONTENTS_CHUNK_SIZE bytes and
     for no more than MMO_SEC_CONTENTS_CHUNK_SIZE will always get resolved.  */

  for (datap = sdatap->head; datap != NULL; datap = datap->next)
    if ((datap->where <= vma && datap->where + datap->size > vma)
	|| (datap->where < vma + size
	    && datap->where + datap->size >= vma + size))
      return NULL;

  allocated_size
    = (size + MMO_SEC_CONTENTS_CHUNK_SIZE - 1) & ~(MMO_SEC_CONTENTS_CHUNK_SIZE - 1);
  entry = (mmo_data_list_type *)
    bfd_zalloc (sec->owner, sizeof (mmo_data_list_type) + allocated_size);
  if (entry == NULL)
    return NULL;
  entry->where = vma;
  entry->size = size;
  entry->allocated_size = allocated_size;

  datap = sdatap->head;

  /* Sort the records by address.  Optimize for the common case of adding
     a record to the end of the list.  */
  if (sdatap->tail != NULL && entry->where >= sdatap->tail->where)
    {
      sdatap->tail->next = entry;
      entry->next = NULL;
      sdatap->tail = entry;
    }
  else
    {
      mmo_data_list_type **look;
      for (look = &sdatap->head;
	   *look != NULL && (*look)->where < entry->where;
	   look = &(*look)->next)
	;
      entry->next = *look;
      *look = entry;
      if (entry->next == NULL)
	{
	  sdatap->tail = entry;

	  /* We get here for the first time (at other times too) for this
	     section.  Say we have contents.  */
	  if (! bfd_set_section_flags (sec->owner, sec,
				       bfd_get_section_flags (sec->owner, sec)
				       | SEC_HAS_CONTENTS))
	    return NULL;
	}
    }

  /* Update the section size.  This happens only when we add contents and
     re-size as we go.  The section size will then be aligned to 32 bits.  */
  if (vma + size > sec->vma + sec->size)
    sec->size += (vma + size) - (sec->vma + sec->size);
  return entry->data;
}

/* Set sizes once we've read in all sections.  */

static void
mmo_map_set_sizes (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
		   void *ignored ATTRIBUTE_UNUSED)
{
  sec->lma = sec->vma;
}

/* Read the mmo file and turn it into sections.  */

static bfd_boolean
mmo_scan (bfd *abfd)
{
  unsigned int i;
  unsigned int lineno = 1;
  bfd_boolean error = FALSE;
  bfd_vma vma = 0;
  asection *sec = bfd_make_section_old_way (abfd, MMO_TEXT_SECTION_NAME);
  asection *non_spec_sec = NULL;
  bfd_vma non_spec_vma = 0;
  bfd_size_type nbytes_read = 0;
  /* Buffer with room to read a 64-bit value.  */
  bfd_byte buf[8];
  long stab_loc = -1;
  char *file_names[256];

  abfd->symcount = 0;
  memset (file_names, 0, sizeof (file_names));

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto error_return;

  while ((nbytes_read = bfd_bread (buf, 4, abfd)) == 4)
    {
      if (buf[0] == LOP)
	{
	  unsigned int y = bfd_get_8 (abfd, buf + 2);
	  unsigned int z = bfd_get_8 (abfd, buf + 3);

	  /* Change back to the original section for lopcodes other
	     than LOP_QUOTE that comes after a LOP_SPEC.  */
	  if ((buf[1] != LOP_QUOTE || y != 0 || z != 1)
	      && non_spec_sec != NULL)
	    {
	      sec = non_spec_sec;
	      vma = non_spec_vma;
	      non_spec_sec = NULL;
	    }

	  switch (buf[1])
	    {
	    default:
	      (*_bfd_error_handler)
		(_("%s: invalid mmo file: unsupported lopcode `%d'\n"),
		 bfd_get_filename (abfd), buf[1]);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;

	    case LOP_QUOTE:
	      /* Quote the next 32-bit word.  */
	      if (y != 0 || z != 1)
		{
		  (*_bfd_error_handler)
		    (_("%s: invalid mmo file: expected YZ = 1 got YZ = %d for lop_quote\n"),
		     bfd_get_filename (abfd), y*256+z);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      if (bfd_bread (buf, 4, abfd) != 4)
		goto error_return;

	      mmo_xore_32 (sec, vma, bfd_get_32 (abfd, buf));
	      vma += 4;
	      vma &= ~3;
	      lineno++;
	      break;

	    case LOP_LOC:
	      /* Set vma (and section).  */
	      vma = (bfd_vma) y << 56;
	      if (z == 1)
		{
		  /* Get a 32-bit value.  */
		  if (bfd_bread (buf, 4, abfd) != 4)
		    goto error_return;

		  vma += bfd_get_32 (abfd, buf);
		}
	      else if (z == 2)
		{
		  /* Get a 64-bit value.  */
		  if (bfd_bread (buf, 8, abfd) != 8)
		    goto error_return;

		  vma += bfd_get_64 (abfd, buf);
		}
	      else
		{
		  (*_bfd_error_handler)
		    (_("%s: invalid mmo file: expected z = 1 or z = 2, got z = %d for lop_loc\n"),
		     bfd_get_filename (abfd), z);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      sec = mmo_decide_section (abfd, vma);
	      if (sec == NULL)
		goto error_return;
	      break;

	    case LOP_SKIP:
	      /* Move forward within the same section.  */
	      vma += y * 256 + z;

	      sec = mmo_decide_section (abfd, vma);
	      if (sec == NULL)
		goto error_return;
	      break;

	    case LOP_FIXO:
	      /* A fixup: Store the current vma somewhere.  Position using
		 same format as LOP_LOC.  */
	      {
		bfd_vma p = (bfd_vma) y << 56;
		asection *fixosec;

		if (z == 1)
		  {
		    /* Get a 32-bit value.  */
		    if (bfd_bread (buf, 4, abfd) != 4)
		      goto error_return;

		    p += bfd_get_32 (abfd, buf);
		  }
		else if (z == 2)
		  {
		    /* Get a 64-bit value.  */
		    if (bfd_bread (buf, 8, abfd) != 8)
		      goto error_return;

		    p += bfd_get_64 (abfd, buf);
		  }
		else
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: expected z = 1 or z = 2, got z = %d for lop_fixo\n"),
		       bfd_get_filename (abfd), z);
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		/* The section where we store this address might be a
		   different one than the current section.  */
		fixosec = mmo_decide_section (abfd, p);
		if (fixosec == NULL)
		  goto error_return;
		mmo_xore_64 (fixosec, p, vma);
	      }
	    break;

	    case LOP_FIXR:
	      /* A fixup: Store YZ of this lopcode into YZ at vma - 4 * yz.  */
	      {
		unsigned int yz = (y * 256 + z);
		bfd_vma p = vma + 2 - 4 * yz;
		asection *fixrsec = mmo_decide_section (abfd, p);
		if (fixrsec == NULL)
		  goto error_return;
		mmo_xore_16 (fixrsec, p, yz);
	      }
	    break;

	    case LOP_FIXRX:
	      /* A fixup, similar to lop_fixr, but taking larger numbers
		 and can change branches into the opposite direction
		 (gasp!).  */
	      {
		bfd_vma delta;
		bfd_vma p;
		asection *fixrsec;

		if (y != 0)
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: expected y = 0, got y = %d for lop_fixrx\n"),
		       bfd_get_filename (abfd), y);
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		if (z != 16 && z != 24)
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: expected z = 16 or z = 24, got z = %d for lop_fixrx\n"),
		       bfd_get_filename (abfd), z);
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		/* Get the next 32-bit value.  */
		if (bfd_bread (buf, 4, abfd) != 4)
		  goto error_return;

		delta = bfd_get_32 (abfd, buf);

		/* Do an, ehm, involved calculation for the location of
		   the fixup.  See mmixal documentation for a verbose
		   explanation.  We follow it verbosely here for the
		   readers delight.  */
		if (buf[0] == 0)
		  p = vma - 4 * delta;
		else if (buf[0] == 1)
		  p = vma - 4 * ((delta & 0xffffff) - (1 << z));
		else
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: leading byte of operand word must be 0 or 1, got %d for lop_fixrx\n"),
		       bfd_get_filename (abfd), buf[0]);
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		fixrsec = mmo_decide_section (abfd, vma);
		if (fixrsec == NULL)
		  goto error_return;
		mmo_xore_32 (fixrsec, p, delta);
	      }
	    break;

	    case LOP_FILE:
	      /* Set current file and perhaps the file name.  Reset line
		 number.  */
	      if (z != 0)
		{
		  char *fname = bfd_malloc (z * 4 + 1);

		  if (fname == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%s: cannot allocate file name for file number %d, %d bytes\n"),
			 bfd_get_filename (abfd), y, z * 4 + 1);
		      bfd_set_error (bfd_error_system_call);
		      goto error_return;
		    }

		  fname[z * 4] = 0;

		  for (i = 0; i < z; i++)
		    {
		      if (bfd_bread (fname + i * 4, 4, abfd) != 4)
			{
			  free (fname);
			  goto error_return;
			}
		    }

		  if (file_names[y] != NULL)
		    {
		      (*_bfd_error_handler)
			(_("%s: invalid mmo file: file number %d `%s',"
			   " was already entered as `%s'\n"),
			 bfd_get_filename (abfd), y, fname, file_names[y]);
		      bfd_set_error (bfd_error_bad_value);
		      goto error_return;
		    }

		  file_names[y] = fname;
		}

	      if (file_names[y] == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: invalid mmo file: file name for number %d"
		       " was not specified before use\n"),
		     bfd_get_filename (abfd), y);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      lineno = 0;
	      break;

	    case LOP_LINE:
	      /* Set line number.  */
	      lineno = y * 256 + z;
	      /* FIXME: Create a sequence of mmo-specific line number
		 entries for each section, then translate into canonical
		 format.  */
	      break;

	    case LOP_SPEC:
	      /* Special data follows until the next non-lop_quote
		 lopcode.  */
	      non_spec_sec = sec;
	      non_spec_vma = vma;
	      sec = mmo_get_spec_section (abfd, y * 256 + z);
	      if (sec == NULL)
		goto error_return;

	      vma = sec->vma;
	      break;

	    case LOP_PRE:
	      {
		/* We ignore header information, except we read in the
		   creation time from the first 32-bit word with the time
		   in seconds since era.  */
		if (z >= 1
		    && bfd_bread (abfd->tdata.mmo_data->created, 4,
				 abfd) != 4)
		  goto error_return;

		for (i = 1; i < z; i++)
		  if (bfd_bread (buf, 4, abfd) != 4)
		    goto error_return;
	      }
	      break;

	    case LOP_POST:
	      /* This tells of the contents of registers $Z..$255 at
		 startup.  We make a section out of it, with VMA = Z * 8,
		 but only if Z != 255 or the contents is non-zero.  */
	      {
		asection *rsec;
		bfd_byte *loc;
		bfd_vma first_octa;
		bfd_vma startaddr_octa;

		/* Read first octaword outside loop to simplify logic when
		   excluding the Z == 255, octa == 0 case.  */
		if (bfd_bread (buf, 8, abfd) != 8)
		  goto error_return;

		first_octa = bfd_get_64 (abfd, buf);

		/* Don't emit contents for the trivial case which is
		   always present; $255 pointing to Main.  */
		if (z != 255)
		  {
		    rsec
		      = bfd_make_section_old_way (abfd,
						  MMIX_REG_CONTENTS_SECTION_NAME);
		    rsec->flags |= SEC_LINKER_CREATED;
		    rsec->vma = z * 8;
		    loc = mmo_get_loc (rsec, z * 8, (255 - z) * 8);
		    bfd_put_64 (abfd, first_octa, loc);

		    for (i = z + 1; i < 255; i++)
		      {
			if (bfd_bread (loc + (i - z) * 8, 8, abfd) != 8)
			  goto error_return;
		      }

		    /* Read out the last octabyte, and use it to set the
		       start address.  */
		    if (bfd_bread (buf, 8, abfd) != 8)
		      goto error_return;

		    startaddr_octa = bfd_get_64 (abfd, buf);
		  }
		else
		  startaddr_octa = first_octa;

		if (! bfd_set_start_address (abfd, startaddr_octa))
		  {
		    /* Currently this can't fail, but this should handle
		       future failures.  */
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }
	      }
	      break;

	    case LOP_STAB:
	      /* We read in the symbols now, not later.  */
	      if (y != 0 || z != 0)
		{
		  (*_bfd_error_handler)
		    (_("%s: invalid mmo file: fields y and z of lop_stab"
		       " non-zero, y: %d, z: %d\n"),
		     bfd_get_filename (abfd), y, z);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      /* Save the location, so we can check that YZ in the LOP_END
		 is correct.  */
	      stab_loc = bfd_tell (abfd);

	      /* It's not said that an MMO can be without symbols (though
		 mmixal will refuse to assemble files without Main), but
		 it seems it would still be a valid mmo-file, so allow it.
		 We detect the absence of a symbol area in that the upper
		 limit is computed (from the lop_end YZ field) as 0.
		 Don't call mmo_get_symbols; it can only detect the end of
		 a valid symbol trie, not the absence of one.  */
	      if (abfd->tdata.mmo_data->max_symbol_length != 0
		  && ! mmo_get_symbols (abfd))
		goto error_return;
	      break;

	    case LOP_END:
	      {
		/* This must be the last 32-bit word in an mmo file.
		   Let's find out.  */
		struct stat statbuf;
		file_ptr curpos = bfd_tell (abfd);

		if (bfd_stat (abfd, &statbuf) < 0)
		  goto error_return;

		if (statbuf.st_size != curpos)
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: lop_end not last item in"
			 " file\n"),
		       bfd_get_filename (abfd));
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		/* Check that the YZ field is right.  Subtract the size of
		   this LOP_END in the calculation; YZ does not include
		   it.  */
		if ((long) (y * 256 + z) * 4 != (curpos - stab_loc) - 4)
		  {
		    (*_bfd_error_handler)
		      (_("%s: invalid mmo file: YZ of lop_end (%ld)"
			 " not equal to the number of tetras to the preceding"
			 " lop_stab (%ld)\n"),
		       bfd_get_filename (abfd), (long) (y * 256 + z),
		       (curpos - stab_loc - 4)/4);
		    bfd_set_error (bfd_error_bad_value);
		    goto error_return;
		  }

		bfd_map_over_sections (abfd, mmo_map_set_sizes, NULL);
		goto done;
	      }
	    }
	}
      else
	{
	  /* This wasn't a lopcode, so store it in the current section.  */
	  mmo_xore_32 (sec, vma & ~3, bfd_get_32 (abfd, buf));
	  vma += 4;
	  vma &= ~3;
	  lineno++;
	}
    }

  /* We know this file is a multiple of four bytes (checked in
     mmo_object_p), so if we got something other than 0, this was a bad
     file (although it's more likely we'll get 0 in that case too).
     If we got end-of-file, then there was no lop_stab, so the file has
     invalid format.  */

  if (nbytes_read != 0)
    bfd_set_error (bfd_error_system_call);
  else
    bfd_set_error (bfd_error_bad_value);

 error_return:
  error = TRUE;
 done:
  /* Mark the .text and .data section with their normal attribute if they
     contain anything.  This is not redundant wrt. mmo_decide_section,
     since that code might never execute, and conversely the alloc+code
     section flags must be set then.  */
  sec = bfd_get_section_by_name (abfd, MMO_TEXT_SECTION_NAME);
  if (sec != NULL
      && (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)
      && ! bfd_set_section_flags (abfd, sec,
				  bfd_get_section_flags (abfd, sec)
				  | SEC_ALLOC | SEC_LOAD | SEC_CODE))
    error = TRUE;

  sec = bfd_get_section_by_name (abfd, MMO_DATA_SECTION_NAME);
  if (sec != NULL
      && (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)
      && ! bfd_set_section_flags (abfd, sec,
				  bfd_get_section_flags (abfd, sec)
				  | SEC_ALLOC | SEC_LOAD))
    error = TRUE;

  /* Free whatever resources we took.  */
  for (i = 0; i < sizeof (file_names) / sizeof (file_names[0]); i++)
    if (file_names[i])
      free (file_names[i]);
  return ! error;
}

/* A hook to set up object file dependent section information.  For mmo,
   we point out the shape of allocated section contents.  */

static bfd_boolean
mmo_new_section_hook (bfd *abfd, asection *newsect)
{
  if (!newsect->used_by_bfd)
    {
      /* We zero-fill all fields and assume NULL is represented by an all
	 zero-bit pattern.  */
      newsect->used_by_bfd
	= bfd_zalloc (abfd, sizeof (struct mmo_section_data_struct));
      if (!newsect->used_by_bfd)
	return FALSE;
    }

  /* Always align to at least 32-bit words.  */
  newsect->alignment_power = 2;
  return _bfd_generic_new_section_hook (abfd, newsect);
}

/* We already have section contents loaded for sections that have
   contents.  */

static bfd_boolean
mmo_get_section_contents (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *sec,
			  void * location,
			  file_ptr offset,
			  bfd_size_type bytes_to_do)
{
  /* Iterate over diminishing chunk sizes, copying contents, like
     mmo_set_section_contents.  */
  while (bytes_to_do)
    {
      /* A minor song-and-dance to make sure we're not bitten by the
	 distant possibility of the cast from bfd_vma to int making the
	 chunk zero-sized.  */
      int chunk_size
	= (int) bytes_to_do != 0 ? bytes_to_do : MMO_SEC_CONTENTS_CHUNK_SIZE;
      bfd_byte *loc;

      do
	loc = mmo_get_loc (sec, sec->vma + offset, chunk_size);
      while (loc == NULL && (chunk_size /= 2) != 0);

      if (chunk_size == 0)
	return FALSE;

      memcpy (location, loc, chunk_size);

      location += chunk_size;
      bytes_to_do -= chunk_size;
      offset += chunk_size;
    }
  return TRUE;
}

/* Return the amount of memory needed to read the symbol table.  */

static long
mmo_get_symtab_upper_bound (bfd *abfd)
{
  return (abfd->symcount + 1) * sizeof (asymbol *);
}

/* Sort mmo symbols by serial number.  */

static int
mmo_sort_mmo_symbols (const void *arg1, const void *arg2)
{
  const struct mmo_symbol *sym1 = *(const struct mmo_symbol **) arg1;
  const struct mmo_symbol *sym2 = *(const struct mmo_symbol **) arg2;

  /* Sort by serial number first.  */
  if (sym1->serno < sym2->serno)
    return -1;
  else if (sym1->serno > sym2->serno)
    return 1;

  /* Then sort by address of the table entries.  */
  return ((const char *) arg1 - (const char *) arg2);
}

/* Translate the symbol table.  */

static long
mmo_canonicalize_symtab (bfd *abfd, asymbol **alocation)
{
  unsigned int symcount = bfd_get_symcount (abfd);
  asymbol *csymbols;
  unsigned int i;

  csymbols = abfd->tdata.mmo_data->csymbols;
  if (csymbols == NULL && symcount != 0)
    {
      asymbol *c;
      struct mmo_symbol *s;
      struct mmo_symbol **msp;

      /* First we store the symbols into the table we'll return, then we
	 qsort it on the serial number, with secondary on the address of
	 the symbol, to preserve order if there would be non-unique serial
	 numbers.  */
      for (s = abfd->tdata.mmo_data->symbols,
	     msp = (struct mmo_symbol **) alocation;
	   s != NULL;
	   s = s->next, ++msp)
	*msp = s;

      *msp = NULL;

      qsort (alocation, symcount, sizeof (struct mmo_symbol *),
	     mmo_sort_mmo_symbols);

      csymbols = (asymbol *) bfd_alloc (abfd, symcount * sizeof (asymbol));
      if (csymbols == NULL)
	return -1;
      abfd->tdata.mmo_data->csymbols = csymbols;

      for (msp = (struct mmo_symbol **) alocation, c = csymbols;
	   *msp != NULL;
	   msp++, ++c)
	{
	  s = *msp;
	  c->the_bfd = abfd;
	  c->name = s->name;
	  c->value = s->value;
	  c->flags = BSF_GLOBAL;

	  if (s->sym_type == mmo_data_sym)
	    {
	      c->section
		= bfd_get_section_by_name (abfd, MMO_DATA_SECTION_NAME);

	      if (c->section == NULL)
		c->section = bfd_abs_section_ptr;
	      else
		c->value -= c->section->vma;
	    }
	  else if (s->sym_type == mmo_undef_sym)
	    c->section = bfd_und_section_ptr;
	  else if (s->sym_type == mmo_reg_sym)
	    {
	      c->section
		= bfd_make_section_old_way (abfd, MMIX_REG_SECTION_NAME);
	      c->section->flags |= SEC_LINKER_CREATED;
	    }
	  else
	    {
	      asection *textsec
		= bfd_get_section_by_name (abfd, MMO_TEXT_SECTION_NAME);
	      asection *datasec;

	      if (textsec != NULL
		  && c->value >= textsec->vma
		  && c->value <= textsec->vma + textsec->size)
		{
		  c->section = textsec;
		  c->value -= c->section->vma;
		}
	      /* In mmo, symbol types depend on the VMA.  Therefore, if
		 the data section isn't within the usual bounds, its
		 symbols are marked as absolute.  Correct that.  This
		 means we can't have absolute symbols with values matching
		 data section addresses, but we also can't have with
		 absolute symbols with values matching text section
		 addresses.  For such needs, use the ELF format.  */
	      else if ((datasec
			= bfd_get_section_by_name (abfd,
						   MMO_DATA_SECTION_NAME))
		       != NULL
		       && c->value >= datasec->vma
		       && c->value <= datasec->vma + datasec->size)
		{
		  c->section = datasec;
		  c->value -= c->section->vma;
		}
	      else
		c->section = bfd_abs_section_ptr;
	    }

	  c->udata.p = NULL;
	}
    }

  /* Last, overwrite the incoming table with the right-type entries.  */
  for (i = 0; i < symcount; i++)
    *alocation++ = csymbols++;
  *alocation = NULL;

  return symcount;
}

/* Get information about a symbol.  */

static void
mmo_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol, symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

static void
mmo_print_symbol (bfd *abfd, void *afile, asymbol *symbol,
		  bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    default:
      bfd_print_symbol_vandf (abfd, file, symbol);

      fprintf (file, " %-5s %s",
	       symbol->section->name,
	       symbol->name);
    }
}

/* We can't map a file directly into executable code, so the
   size of header information is irrelevant.  */

static int
mmo_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,
		    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Write the (section-neutral) file preamble.  */

static bfd_boolean
mmo_internal_write_header (bfd *abfd)
{
  const char lop_pre_bfd[] = { LOP, LOP_PRE, 1, 1};

  if (bfd_bwrite (lop_pre_bfd, 4, abfd) != 4)
    return FALSE;

  /* Copy creation time of original file.  */
  if (bfd_bwrite (abfd->tdata.mmo_data->created, 4, abfd) != 4)
    return FALSE;

  return TRUE;
}

/* Write the LOP_POST record, with global register initializations.
   Z is the Z field of the LOP_POST, corresponding to 255 - number of
   registers at DATA.  The Z = 255 field is filled in with the
   start-address.  */

static bfd_boolean
mmo_internal_write_post (bfd *abfd, int z, asection *sec)
{
  int i;
  bfd_byte buf[8];
  mmo_write_tetra_raw (abfd, (LOP << 24) | (LOP_POST << 16) | z);

  for (i = z; i < 255; i++)
    {
      bfd_byte *data = mmo_get_loc (sec, i * 8, 8);

      if (bfd_bwrite (data, 8, abfd) != 8)
	return FALSE;
    }

  /* For Z == $255, we always emit the start location; supposedly Main,
     but we have it handy at bfd_get_start_address.  If we're called with
     Z == 255, don't assume DATA is valid.  */
  bfd_put_64 (abfd, bfd_get_start_address (abfd), buf);

  return ! abfd->tdata.mmo_data->have_error && bfd_bwrite (buf, 8, abfd) == 8;
}

/* Translate to and from BFD flags.  This is to make sure that we don't
   get bitten by BFD flag number changes.  */

static flagword
mmo_sec_flags_from_bfd_flags (flagword flags)
{
  flagword oflags = 0;

  if (flags & SEC_ALLOC)
    oflags |= MMO_SEC_ALLOC;
  if (flags & SEC_LOAD)
    oflags |= MMO_SEC_LOAD;
  if (flags & SEC_RELOC)
    oflags |= MMO_SEC_RELOC;
  if (flags & SEC_READONLY)
    oflags |= MMO_SEC_READONLY;
  if (flags & SEC_CODE)
    oflags |= MMO_SEC_CODE;
  if (flags & SEC_DATA)
    oflags |= MMO_SEC_DATA;
  if (flags & SEC_NEVER_LOAD)
    oflags |= MMO_SEC_NEVER_LOAD;
  if (flags & SEC_IS_COMMON)
    oflags |= MMO_SEC_IS_COMMON;
  if (flags & SEC_DEBUGGING)
    oflags |= MMO_SEC_DEBUGGING;

  return oflags;
}

static flagword
bfd_sec_flags_from_mmo_flags (flagword flags)
{
  flagword oflags = 0;

  if (flags & MMO_SEC_ALLOC)
    oflags |= SEC_ALLOC;
  if (flags & MMO_SEC_LOAD)
    oflags |= SEC_LOAD;
  if (flags & MMO_SEC_RELOC)
    oflags |= SEC_RELOC;
  if (flags & MMO_SEC_READONLY)
    oflags |= SEC_READONLY;
  if (flags & MMO_SEC_CODE)
    oflags |= SEC_CODE;
  if (flags & MMO_SEC_DATA)
    oflags |= SEC_DATA;
  if (flags & MMO_SEC_NEVER_LOAD)
    oflags |= SEC_NEVER_LOAD;
  if (flags & MMO_SEC_IS_COMMON)
    oflags |= SEC_IS_COMMON;
  if (flags & MMO_SEC_DEBUGGING)
    oflags |= SEC_DEBUGGING;

  return oflags;
}

/* Return TRUE iff the leading or trailing tetrabyte in SEC is defined and
   is 0.  */

static bfd_boolean
mmo_has_leading_or_trailing_zero_tetra_p (bfd *abfd, asection *sec)
{
  bfd_vma secaddr = bfd_get_section_vma (abfd, sec);

  if (sec->size < 4)
    return FALSE;

  if (bfd_get_32 (abfd, mmo_get_loc (sec, secaddr, 4)) == 0
      && bfd_get_32 (abfd,
		     mmo_get_loc (sec, secaddr + sec->size - 4, 4)) == 0)
    return TRUE;

  return FALSE;
}

/* Write a section.  */

static bfd_boolean
mmo_internal_write_section (bfd *abfd, asection *sec)
{
  /* We do it differently depending on what section this is:

   ".text": Output, prepended by information about the first source file
   (not yet implemented.)

   ".data": Output.

   (".MMIX.reg_contents": Not handled here.)

   Anything else: Output inside a lop_spec 80, in the format described
   above.  */

  if (strcmp (sec->name, MMO_TEXT_SECTION_NAME) == 0)
    {
      bfd_vma secaddr = bfd_get_section_vma (abfd, sec);

      /* Because leading and trailing zeros are omitted in output, we need to
	 specify the section boundaries so they're correct when the file
	 is read in again.  That's also the case if this section is
	 specified as not within its usual boundaries or alignments.  */
      if (sec->size != 0
	  && (secaddr + sec->size >= (bfd_vma) 1 << 56
	      || (secaddr & 3) != 0
	      || (sec->size & 3) != 0
	      || mmo_has_leading_or_trailing_zero_tetra_p (abfd, sec)))
	{
	  if (!mmo_write_section_description (abfd, sec))
	    return FALSE;
	}

      /* FIXME: Output source file name and line number.  */
      return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
    }
  else if (strcmp (sec->name, MMO_DATA_SECTION_NAME) == 0)
    {
      bfd_vma secaddr = bfd_get_section_vma (abfd, sec);

      /* Same goes as for MMO_TEXT_SECTION_NAME above.  */
      if (sec->size != 0
	  && (secaddr < (bfd_vma) 0x20 << 56
	      || secaddr + sec->size >= (bfd_vma) 0x21 << 56
	      || (secaddr & 3) != 0
	      || (sec->size & 3) != 0
	      || mmo_has_leading_or_trailing_zero_tetra_p (abfd, sec)))
	{
	  if (!mmo_write_section_description (abfd, sec))
	    return FALSE;
	}

      return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
    }
  else if (strcmp (sec->name, MMIX_REG_CONTENTS_SECTION_NAME) == 0)
    /* Not handled here.  */
    {
      /* This would normally be an abort call since this can't happen, but
         we don't do that.  */
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
  else if (CONST_STRNEQ (sec->name, MMIX_OTHER_SPEC_SECTION_PREFIX))
    {
      int n = atoi (sec->name + strlen (MMIX_OTHER_SPEC_SECTION_PREFIX));

      mmo_write_tetra_raw (abfd, (LOP << 24) | (LOP_SPEC << 16) | n);
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
    }
  /* Ignore sections that are just allocated or empty; we write out
     _contents_ here.  */
  else if ((bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS) != 0
	   && sec->size != 0)
    {
      if (!mmo_write_section_description (abfd, sec))
	return FALSE;

      /* Writing a LOP_LOC ends the LOP_SPEC data, and makes data actually
	 loaded.  */
      if (bfd_get_section_flags (abfd, sec) & SEC_LOAD)
	return (! abfd->tdata.mmo_data->have_error
		&& mmo_write_loc_chunk_list (abfd,
					 mmo_section_data (sec)->head));
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
    }

  /* Some section without contents.  */
  return TRUE;
}

/* Write the description of a section, extended-mmo-style.  */

static bfd_boolean
mmo_write_section_description (bfd *abfd, asection *sec)
{
  /* Keep the following document-comment formatted the way it is.  */
/*
INODE
mmo section mapping, , Symbol-table, mmo
SUBSECTION
	mmo section mapping

	The implementation in BFD uses special data type 80 (decimal) to
	encapsulate and describe named sections, containing e.g.@@: debug
	information.  If needed, any datum in the encapsulation will be
	quoted using lop_quote.  First comes a 32-bit word holding the
	number of 32-bit words containing the zero-terminated zero-padded
	segment name.  After the name there's a 32-bit word holding flags
	describing the section type.  Then comes a 64-bit big-endian word
	with the section length (in bytes), then another with the section
	start address.  Depending on the type of section, the contents
	might follow, zero-padded to 32-bit boundary.  For a loadable
	section (such as data or code), the contents might follow at some
	later point, not necessarily immediately, as a lop_loc with the
	same start address as in the section description, followed by the
	contents.  This in effect forms a descriptor that must be emitted
	before the actual contents.  Sections described this way must not
	overlap.

	For areas that don't have such descriptors, synthetic sections are
	formed by BFD.  Consecutive contents in the two memory areas
	@@samp{0x0000@@dots{}00} to @@samp{0x01ff@@dots{}ff} and
	@@samp{0x2000@@dots{}00} to @@samp{0x20ff@@dots{}ff} are entered in
	sections named <<.text>> and <<.data>> respectively.  If an area
	is not otherwise described, but would together with a neighboring
	lower area be less than @@samp{0x40000000} bytes long, it is joined
	with the lower area and the gap is zero-filled.  For other cases,
	a new section is formed, named <<.MMIX.sec.@@var{n}>>.  Here,
	@@var{n} is a number, a running count through the mmo file,
	starting at 0.

EXAMPLE
	A loadable section specified as:

| .section secname,"ax"
| TETRA 1,2,3,4,-1,-2009
| BYTE 80

	and linked to address @@samp{0x4}, is represented by the sequence:

| 0x98080050 - lop_spec 80
| 0x00000002 - two 32-bit words for the section name
| 0x7365636e - "secn"
| 0x616d6500 - "ame\0"
| 0x00000033 - flags CODE, READONLY, LOAD, ALLOC
| 0x00000000 - high 32 bits of section length
| 0x0000001c - section length is 28 bytes; 6 * 4 + 1 + alignment to 32 bits
| 0x00000000 - high 32 bits of section address
| 0x00000004 - section address is 4
| 0x98010002 - 64 bits with address of following data
| 0x00000000 - high 32 bits of address
| 0x00000004 - low 32 bits: data starts at address 4
| 0x00000001 - 1
| 0x00000002 - 2
| 0x00000003 - 3
| 0x00000004 - 4
| 0xffffffff - -1
| 0xfffff827 - -2009
| 0x50000000 - 80 as a byte, padded with zeros.

	Note that the lop_spec wrapping does not include the section
	contents.  Compare this to a non-loaded section specified as:

| .section thirdsec
| TETRA 200001,100002
| BYTE 38,40

	This, when linked to address @@samp{0x200000000000001c}, is
	represented by:

| 0x98080050 - lop_spec 80
| 0x00000002 - two 32-bit words for the section name
| 0x7365636e - "thir"
| 0x616d6500 - "dsec"
| 0x00000010 - flag READONLY
| 0x00000000 - high 32 bits of section length
| 0x0000000c - section length is 12 bytes; 2 * 4 + 2 + alignment to 32 bits
| 0x20000000 - high 32 bits of address
| 0x0000001c - low 32 bits of address 0x200000000000001c
| 0x00030d41 - 200001
| 0x000186a2 - 100002
| 0x26280000 - 38, 40 as bytes, padded with zeros

	For the latter example, the section contents must not be
	loaded in memory, and is therefore specified as part of the
	special data.  The address is usually unimportant but might
	provide information for e.g.@@: the DWARF 2 debugging format.  */

  mmo_write_tetra_raw (abfd, LOP_SPEC_SECTION);
  mmo_write_tetra (abfd, (strlen (sec->name) + 3) / 4);
  mmo_write_chunk (abfd, (bfd_byte *) sec->name, strlen (sec->name));
  mmo_flush_chunk (abfd);
  /* FIXME: We can get debug sections (.debug_line & Co.) with a section
     flag still having SEC_RELOC set.  Investigate.  This might be true
     for all alien sections; perhaps mmo.em should clear that flag.  Might
     be related to weak references.  */
  mmo_write_tetra (abfd,
		   mmo_sec_flags_from_bfd_flags
		   (bfd_get_section_flags (abfd, sec)));
  mmo_write_octa (abfd, sec->size);
  mmo_write_octa (abfd, bfd_get_section_vma (abfd, sec));
  return TRUE;
}

/* We save up all data before output.  */

static bfd_boolean
mmo_set_section_contents (bfd *abfd ATTRIBUTE_UNUSED, sec_ptr sec,
			  const void *location, file_ptr offset,
			  bfd_size_type bytes_to_do)
{
  /* Iterate over diminishing chunk sizes, copying contents.  */
  while (bytes_to_do)
    {
      /* A minor song-and-dance to make sure we're not bitten by the
	 distant possibility of the cast from bfd_vma to int making the
	 chunk zero-sized.  */
      int chunk_size
	= (int) bytes_to_do != 0 ? bytes_to_do : MMO_SEC_CONTENTS_CHUNK_SIZE;
      bfd_byte *loc;

      do
	loc = mmo_get_loc (sec, sec->vma + offset, chunk_size);
      while (loc == NULL && (chunk_size /= 2) != 0);

      if (chunk_size == 0)
	return FALSE;

      memcpy (loc, location, chunk_size);

      location += chunk_size;
      bytes_to_do -= chunk_size;
      offset += chunk_size;
    }
  return TRUE;
}

/* Add a symbol to a trie-tree.  */

static bfd_boolean
mmo_internal_add_3_sym (bfd *abfd, struct mmo_symbol_trie *rootp,
			const struct mmo_symbol *symp)
{
  const char *name = symp->name;
  struct mmo_symbol_trie *trie = rootp;
  struct mmo_symbol_trie **triep = NULL;

  while (*name && trie != NULL)
    {
      if (*name < trie->symchar)
	{
	  triep = &trie->left;
	  trie = trie->left;
	}
      else if (*name > trie->symchar)
	{
	  triep = &trie->right;
	  trie = trie->right;
	}
      else if (*name == trie->symchar)
	{
	  triep = &trie->middle;
	  name++;

	  /* Make sure "trie" points to where we should fill in the
	     current symbol whenever we've iterated through "name".  We
	     would lose the right position if we encounter "foobar" then
	     "foo".  */
	  if (*name)
	    trie = trie->middle;
	}
    }

  while (*name != 0)
    {
      /* Create middle branches for the rest of the characters.  */
      trie = bfd_zalloc (abfd, sizeof (struct mmo_symbol_trie));
      *triep = trie;
      trie->symchar = *name++;
      triep = &trie->middle;
    }

  /* We discover a duplicate symbol rather late in the process, but still;
     we discover it and bail out.  */
  if (trie->sym.name != NULL)
    {
      (*_bfd_error_handler)
	(_("%s: invalid symbol table: duplicate symbol `%s'\n"),
	 bfd_get_filename (abfd), trie->sym.name);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  memcpy (&trie->sym, symp, sizeof *symp);
  return TRUE;
}

/* Find out the length of the serialized version of a trie in bytes.  */

static unsigned int
mmo_internal_3_length (bfd *abfd, struct mmo_symbol_trie *trie)
{
  /* First, one for the control byte.  */
  unsigned int length = 1;

  if (trie == NULL)
    return 0;

  /* Add in the recursion to the left.  */
  length += mmo_internal_3_length (abfd, trie->left);

  /* Add in the middle trie and the character.  */
  length += 1 + mmo_internal_3_length (abfd, trie->middle);

  /* Add in the recursion to the right.  */
  length += mmo_internal_3_length (abfd, trie->right);

  /* Add in bytes for the symbol (if this is an endnode). */
  if (trie->sym.name != NULL)
    {
      unsigned int serno = trie->sym.serno;

      /* First what it takes to encode the value. */
      if (trie->sym.sym_type == mmo_reg_sym)
	length++;
      else if (trie->sym.sym_type == mmo_undef_sym)
	length += 2;
      else
	{
	  bfd_vma value = trie->sym.value;

	  /* Coded in one to eight following bytes.  */
	  if (trie->sym.sym_type == mmo_data_sym)
	    value -= (bfd_vma) 0x20 << 56;

	  do
	    {
	      value >>= 8;
	      length++;
	    }
	  while (value != 0);
	}

      /* Find out what it takes to encode the serial number.  */
      do
	{
	  serno >>= 7;
	  length++;
	}
      while (serno != 0);
    }

  return length;
}

/* Helper function for outputting the serial number of a symbol, output as
   a variant of leb128 (see dwarf2 documentation) which could be called
   beb128.  Using a helper function and recursion simplifies debugging.  */

static void
mmo_beb128_out (bfd *abfd, int serno, int marker)
{
  if (serno & ~0x7f)
    mmo_beb128_out (abfd, serno >> 7, 0);
  mmo_write_byte (abfd, marker | (serno & 0x7f));
}

/* Serialize a trie.  */

static void
mmo_internal_3_dump (bfd *abfd, struct mmo_symbol_trie *trie)
{
  bfd_byte control = 0;

  if (trie == NULL)
    return;

  if (trie->left)
    control |= MMO3_LEFT;

  if (trie->middle)
    control |= MMO3_MIDDLE;

  if (trie->right)
    control |= MMO3_RIGHT;

  if (trie->sym.name != NULL)
    {
      /* Encode the symbol type and length of value bytes.  */
      if (trie->sym.sym_type == mmo_reg_sym)
	control |= MMO3_REGQUAL_BITS;
      else if (trie->sym.sym_type == mmo_undef_sym)
	control |= MMO3_UNDEF;
      else
	{
	  bfd_vma value = trie->sym.value;

	  /* Coded in 1..8 following bytes.  */
	  if (trie->sym.sym_type == mmo_data_sym)
	    {
	      control |= MMO3_DATA;
	      value -= (bfd_vma) 0x20 << 56;
	    }

	  do
	    {
	      value >>= 8;
	      control++;
	    }
	  while (value != 0);
	}
    }

  /* The control byte is output before recursing.  */
  mmo_write_byte (abfd, control);

  mmo_internal_3_dump (abfd, trie->left);

  if (control & MMO3_SYMBITS)
    {
      mmo_write_byte (abfd, trie->symchar);

      if (trie->sym.name != NULL)
	{
	  if (trie->sym.sym_type == mmo_reg_sym)
	    mmo_write_byte (abfd, trie->sym.value);
	  else if (trie->sym.sym_type == mmo_undef_sym)
	    {
	      mmo_write_byte (abfd, 0);
	      mmo_write_byte (abfd, 0);
	    }
	  else
	    {
	      bfd_vma value = trie->sym.value;

	      bfd_byte byte_n = control & 15;

	      /* Coded in 1..8 following bytes.  Note that the value is
		 shifted out big-endian.  */
	      if (trie->sym.sym_type == mmo_data_sym)
		{
		  value -= (bfd_vma) 0x20 << 56;
		  byte_n -= 8;
		}

	      do
		{
		  mmo_write_byte (abfd, (value >> ((byte_n - 1) * 8)) & 0xff);
		  byte_n--;
		}
	      while (byte_n != 0);
	    }

	  mmo_beb128_out (abfd, trie->sym.serno, 128);
	}
      mmo_internal_3_dump (abfd, trie->middle);
    }
  mmo_internal_3_dump (abfd, trie->right);
}

/* Write symbols in mmo format.  Also write the lop_end terminator.  */

static bfd_boolean
mmo_write_symbols_and_terminator (bfd *abfd)
{
  int count = bfd_get_symcount (abfd);
  asymbol **table;
  asymbol **orig_table = bfd_get_outsymbols (abfd);
  int serno;
  struct mmo_symbol_trie root;
  int trie_len;
  int i;
  bfd_byte buf[4];

  /* Create a symbol for "Main".  */
  asymbol *fakemain = bfd_make_empty_symbol (abfd);

  fakemain->flags = BSF_GLOBAL;
  fakemain->value = bfd_get_start_address (abfd);
  fakemain->name = MMIX_START_SYMBOL_NAME;
  fakemain->section = bfd_abs_section_ptr;

  memset (&root, 0, sizeof (root));

  /* Make all symbols take a left turn.  */
  root.symchar = 0xff;

  /* There must always be a ":Main", so we'll add one if there are no
     symbols.  Make sure we have room for it.  */
  table = bfd_alloc (abfd, (count + 1) * sizeof (asymbol *));
  if (table == NULL)
    return FALSE;

  memcpy (table, orig_table, count * sizeof (asymbol *));

  /* Move :Main (if there is one) to the first position.  This is
     necessary to get the same layout of the trie-tree when linking as
     when objcopying the result as in the objcopy.exp test "simple objcopy
     of executable".  It also automatically takes care of assigning serial
     number 1 to :Main (as is mandatory).  */
  for (i = 0; i < count; i++)
    if (table[i] != NULL
	&& strcmp (table[i]->name, MMIX_START_SYMBOL_NAME) == 0
	&& (table[i]->flags & (BSF_DEBUGGING|BSF_GLOBAL)) == BSF_GLOBAL)
      {
	asymbol *mainsym = table[i];
	memcpy (table + 1, orig_table, i * sizeof (asymbol *));
	table[0] = mainsym;

	/* Check that the value assigned to :Main is the same as the entry
	   address.  The default linker script asserts this.  This is as
	   good a place as any to check this consistency. */
	if ((mainsym->value
	     + mainsym->section->output_section->vma
	     + mainsym->section->output_offset)
	    != bfd_get_start_address (abfd))
	  {
	    /* Arbitrary buffer to hold the printable representation of a
	       vma.  */
	    char vmas_main[40];
	    char vmas_start[40];
	    bfd_vma vma_start = bfd_get_start_address (abfd);

	    sprintf_vma (vmas_main, mainsym->value);
	    sprintf_vma (vmas_start, vma_start);

	    (*_bfd_error_handler)
	      (_("%s: Bad symbol definition: `Main' set to %s rather"
		 " than the start address %s\n"),
	       bfd_get_filename (abfd), vmas_main, vmas_start);
	    bfd_set_error (bfd_error_bad_value);
	    return FALSE;
	  }
	break;
      }
  if (i == count && count != 0)
    {
      /* When there are symbols, there must be a :Main.  There was no
	 :Main, so we need to add it manually.  */
      memcpy (table + 1, orig_table, count * sizeof (asymbol *));
      table[0] = fakemain;
      count++;
    }

  for (i = 0, serno = 1; i < count && table[i] != NULL; i++)
    {
      asymbol *s = table[i];

      /* It's not enough to consult bfd_is_local_label, since it does not
	 mean "local" in the sense of linkable-and-observable-after-link.
	 Let's just check the BSF_GLOBAL flag.

	 Also, don't export symbols with characters not in the allowed set.  */
      if ((s->flags & (BSF_DEBUGGING|BSF_GLOBAL)) == BSF_GLOBAL
	  && strspn (s->name,
		     valid_mmo_symbol_character_set) == strlen (s->name))
	{
	  struct mmo_symbol sym;
	  memset (&sym, 0, sizeof (sym));

	  /* Need to strip const here; strdup:ing would leak and the
	     existing string must be safe to reuse.  */
	  sym.name = (char *) s->name;
	  sym.value =
	    s->value
	    + s->section->output_section->vma
	    + s->section->output_offset;

	  if (bfd_is_und_section (s->section))
	    sym.sym_type = mmo_undef_sym;
	  else if (strcmp (s->section->name, MMO_DATA_SECTION_NAME) == 0
		   /* The encoding of data symbols require that the "rest"
		      of the value fits in 6 bytes, so the upper two bytes
		      must be 0x2000.  All other symbols get to be the
		      absolute type.  */
		   && (sym.value >> 48) == 0x2000)
	    sym.sym_type = mmo_data_sym;
	  else if (strcmp (s->section->name, MMIX_REG_SECTION_NAME) == 0)
	    sym.sym_type = mmo_reg_sym;
	  else if (strcmp (s->section->name,
			   MMIX_REG_CONTENTS_SECTION_NAME) == 0)
	    {
	      sym.sym_type = mmo_reg_sym;
	      sym.value /= 8;
	    }
	  else
	    sym.sym_type = mmo_abs_sym;

	  /* FIXME: We assume the order of the received symbols is an
	     ordered mapping of the serial numbers.  This is not
	     necessarily true if we e.g. objcopy a mmo file to another and
	     there are gaps in the numbering.  Not sure if this can
	     happen.  Not sure what to do.  */
	  sym.serno = serno++;

	  if (! mmo_internal_add_3_sym (abfd, &root, &sym))
	    return FALSE;
	}
    }

  /* Change the root node to be a ":"-prefix.  */
  root.symchar = ':';
  root.middle = root.left;
  root.right = NULL;
  root.left = NULL;

  /* We have to find out if we can fit the whole symbol table in the mmo
     symtab.  It would be bad to assume we can always fit it in 262144
     bytes.  If we can't, just leave the Main symbol.  */
  trie_len = (mmo_internal_3_length (abfd, &root) + 3)/4;

  if (trie_len > 0xffff)
    {
      /* Test this code by using a lower limit in the test above and check
	 that the single "Main" symbol is emitted and handled properly.
	 There's no specific test-case.  */
      struct mmo_symbol sym;

      (*_bfd_error_handler)
	(_("%s: warning: symbol table too large for mmo, larger than 65535"
	   " 32-bit words: %d.  Only `Main' will be emitted.\n"),
	 bfd_get_filename (abfd), trie_len);

      memset (&sym, 0, sizeof (sym));
      sym.sym_type = mmo_abs_sym;
      sym.name = MMIX_START_SYMBOL_NAME;
      sym.serno = 1;
      sym.value = bfd_get_start_address (abfd);

      /* Then patch up a symbol table to be just the ":Main" symbol.  */
      memset (&root, 0, sizeof (root));
      root.left = root.middle;
      root.symchar = 0xff;
      root.middle = NULL;
      root.right = NULL;

      if (! mmo_internal_add_3_sym (abfd, &root, &sym))
	return FALSE;

      root.symchar = ':';
      root.middle = root.left;
      root.right = NULL;
      root.left = NULL;

      trie_len = (mmo_internal_3_length (abfd, &root) + 3)/4;
    }

  /* Reset the written-bytes counter.  */
  abfd->tdata.mmo_data->byte_no = 0;

  /* Put out the lop_stab mark.  */
  bfd_put_32 (abfd, (LOP << 24) | (LOP_STAB << 16), buf);
  if (bfd_bwrite (buf, 4, abfd) != 4)
    return FALSE;

  /* Dump out symbols.  */
  mmo_internal_3_dump (abfd, &root);

  if (trie_len != (abfd->tdata.mmo_data->byte_no + 3)/4)
    {
      /* I haven't seen this trig.  It seems no use claiming this case
	 isn't debugged and abort if we get here.  Instead emit a
	 diagnostic and fail "normally".  */
      (*_bfd_error_handler)
	(_("%s: internal error, symbol table changed size from %d to %d"
	   " words\n"),
	 bfd_get_filename (abfd), trie_len,
	 (abfd->tdata.mmo_data->byte_no + 3)/4);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* Dump out remaining bytes in the buffer and handle I/O errors by
     propagating errors.  */
  if ((abfd->tdata.mmo_data->byte_no % 4) != 0
      || abfd->tdata.mmo_data->have_error)
    {
      memset (abfd->tdata.mmo_data->buf + (abfd->tdata.mmo_data->byte_no % 4),
	      0, 4 - (abfd->tdata.mmo_data->byte_no % 4));

      if (abfd->tdata.mmo_data->have_error
	  || bfd_bwrite (abfd->tdata.mmo_data->buf, 4, abfd) != 4)
	return FALSE;
    }

  bfd_put_32 (abfd, (LOP << 24) | (LOP_END << 16) | trie_len, buf);
  return bfd_bwrite (buf, 4, abfd) == 4;
}

/* Write section unless it is the register contents section.  For that, we
   instead store the section in the supplied pointer.  This function is
   used through bfd_map_over_sections.  */

static void
mmo_write_section_unless_reg_contents (bfd *abfd, asection *sec, void *p)
{
  struct mmo_write_sec_info *infop = (struct mmo_write_sec_info *) p;

  if (! infop->retval)
    return;

  if (strcmp (sec->name, MMIX_REG_CONTENTS_SECTION_NAME) == 0)
    {
      infop->reg_section = sec;
      return;
    }

  /* Exclude the convenience register section.  */
  if (strcmp (sec->name, MMIX_REG_SECTION_NAME) == 0)
    {
      if (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)
	{
	  /* Make sure it hasn't got contents.  It seems impossible to
	     make it carry contents, so we don't have a test-case for
	     this.  */
	  (*_bfd_error_handler)
	    (_("%s: internal error, internal register section %s had"
	       " contents\n"),
	     bfd_get_filename (abfd), sec->name);
	  bfd_set_error (bfd_error_bad_value);
	  infop->retval = FALSE;
	  return;
	}

      return;
    }

  infop->retval = mmo_internal_write_section (abfd, sec);
}

/* Do the actual output of a file.  Assumes mmo_set_section_contents is
   already called. */

static bfd_boolean
mmo_write_object_contents (bfd *abfd)
{
  struct mmo_write_sec_info wsecinfo;

  /* First, there are a few words of preamble.  */
  if (! mmo_internal_write_header (abfd))
    return FALSE;

  wsecinfo.reg_section = NULL;
  wsecinfo.retval = TRUE;

  bfd_map_over_sections (abfd, mmo_write_section_unless_reg_contents,
			 &wsecinfo);

  if (! wsecinfo.retval)
    return FALSE;

  if (wsecinfo.reg_section != NULL)
    {
      asection *sec = wsecinfo.reg_section;
      unsigned int z = (unsigned int) (sec->vma / 8);

      /* Registers 0..31 must not be global.  Do sanity check on the "vma"
	 of the register contents section and check that it corresponds to
	 the length of the section.  */
      if (z < 32 || z >= 255 || (sec->vma & 7) != 0
	  || sec->vma != 256 * 8 - sec->size - 8)
	{
	  bfd_set_error (bfd_error_bad_value);

	  if (sec->size == 0)
	    /* There must always be at least one such register.  */
	    (*_bfd_error_handler)
	      (_("%s: no initialized registers; section length 0\n"),
	       bfd_get_filename (abfd));
	  else if (sec->vma > (256 - 32) * 8)
	    /* Provide better error message for the case of too many
	       global registers.  */
	    (*_bfd_error_handler)
	      (_("%s: too many initialized registers; section length %ld\n"),
	       bfd_get_filename (abfd),
	       (long) sec->size);
	  else
	    (*_bfd_error_handler)
	      (_("%s: invalid start address for initialized registers of"
		 " length %ld: 0x%lx%08lx\n"),
	       bfd_get_filename (abfd),
	       (long) sec->size,
	       (unsigned long) (sec->vma >> 32), (unsigned long) (sec->vma));

	  return FALSE;
	}

      if (! mmo_internal_write_post (abfd, z, sec))
	return FALSE;
    }
  else
    if (! mmo_internal_write_post (abfd, 255, NULL))
      return FALSE;

  return mmo_write_symbols_and_terminator (abfd);
}

/* If there's anything in particular in a mmo bfd that we want to free,
   make this a real function.  Only do this if you see major memory
   thrashing; zealous free:ing will cause unwanted behavior, especially if
   you "free" memory allocated with "bfd_alloc", or even "bfd_release" a
   block allocated with "bfd_alloc"; they're really allocated from an
   obstack, and we don't know what was allocated there since this
   particular allocation.  */

#define	mmo_close_and_cleanup _bfd_generic_close_and_cleanup
#define mmo_bfd_free_cached_info _bfd_generic_bfd_free_cached_info

/* Perhaps we need to adjust this one; mmo labels (originally) without a
   leading ':' might more appropriately be called local.  */
#define mmo_bfd_is_local_label_name bfd_generic_is_local_label_name
#define mmo_bfd_is_target_special_symbol  \
  ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)

/* Is this one really used or defined by anyone?  */
#define mmo_get_lineno _bfd_nosymbols_get_lineno

/* FIXME: We can do better on this one, if we have a dwarf2 .debug_line
   section or if MMO line numbers are implemented.  */
#define mmo_find_nearest_line _bfd_nosymbols_find_nearest_line
#define mmo_find_inliner_info _bfd_nosymbols_find_inliner_info
#define mmo_make_empty_symbol _bfd_generic_make_empty_symbol
#define mmo_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define mmo_read_minisymbols _bfd_generic_read_minisymbols
#define mmo_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define mmo_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window
#define mmo_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define mmo_bfd_gc_sections bfd_generic_gc_sections
#define mmo_bfd_lookup_section_flags bfd_generic_lookup_section_flags
#define mmo_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define mmo_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define mmo_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define mmo_bfd_link_just_syms _bfd_generic_link_just_syms
#define mmo_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define mmo_bfd_final_link _bfd_generic_final_link
#define mmo_bfd_link_split_section _bfd_generic_link_split_section

/* Strictly speaking, only MMIX uses this restricted format, but let's not
   stop anybody from shooting themselves in the foot.  */
#define mmo_set_arch_mach bfd_default_set_arch_mach
#define mmo_bfd_relax_section bfd_generic_relax_section
#define mmo_bfd_merge_sections bfd_generic_merge_sections
#define mmo_bfd_is_group_section bfd_generic_is_group_section
#define mmo_bfd_discard_group bfd_generic_discard_group
#define mmo_section_already_linked \
  _bfd_generic_section_already_linked
#define mmo_bfd_define_common_symbol bfd_generic_define_common_symbol

/* We want to copy time of creation, otherwise we'd use
   BFD_JUMP_TABLE_COPY (_bfd_generic).  */
#define mmo_bfd_merge_private_bfd_data _bfd_generic_bfd_merge_private_bfd_data
#define mmo_bfd_copy_private_section_data _bfd_generic_bfd_copy_private_section_data
#define mmo_bfd_copy_private_symbol_data _bfd_generic_bfd_copy_private_symbol_data
#define mmo_bfd_copy_private_header_data _bfd_generic_bfd_copy_private_header_data
#define mmo_bfd_set_private_flags _bfd_generic_bfd_set_private_flags
#define mmo_bfd_print_private_bfd_data _bfd_generic_bfd_print_private_bfd_data

const bfd_target bfd_mmo_vec =
{
  "mmo",			/* name */
  bfd_target_mmo_flavour,
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */

  /* FIXME: Might need adjustments.  */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  /* FIXME: Might need adjustments.  */
  (SEC_CODE | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
   | SEC_READONLY | SEC_EXCLUDE | SEC_DEBUGGING | SEC_IN_MEMORY),
				/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {
    _bfd_dummy_target,
    mmo_object_p,		/* bfd_check_format */
    _bfd_dummy_target,
    _bfd_dummy_target,
  },
  {
    bfd_false,
    mmo_mkobject,
    bfd_false,
    bfd_false,
  },
  {				/* bfd_write_contents */
    bfd_false,
    mmo_write_object_contents,
    bfd_false,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (mmo),
  BFD_JUMP_TABLE_COPY (mmo),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
  BFD_JUMP_TABLE_SYMBOLS (mmo),
  BFD_JUMP_TABLE_RELOCS (_bfd_norelocs),
  BFD_JUMP_TABLE_WRITE (mmo),
  BFD_JUMP_TABLE_LINK (mmo),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  NULL
};
@


1.46
log
@	* mmo.c (mmo_write_chunk): Break out abfd->tdata.mmo_data to new
	local variable mmop.
@
text
@d2 1
a2 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
   Free Software Foundation, Inc.
d664 3
a666 2
      if (! sec->user_set_vma)
	bfd_set_section_vma (abfd, sec, vma);
d679 3
a681 2
      if (! sec->user_set_vma)
	bfd_set_section_vma (abfd, sec, vma);
d696 3
a698 2
  if (! sec->user_set_vma)
    bfd_set_section_vma (abfd, sec, vma);
@


1.45
log
@	* bfd.c (struct bfd_preserve, bfd_preserve_save, bfd_preserve_restore,
	bfd_preserve_finish): Move to..
	* format.c: ..here, splitting out..
	(bfd_reinit): ..this.  New function.
	(bfd_check_format_matches): Use bfd_preserve_save/restore to
	keep bfd state for a match.
	* elfcode.h (elf_object_p): Don't use bfd_preserve_save/restore.
	* elfcore.h (elf_core_file_p): Likewise.
	* mach-o.c (bfd_mach_o_header_p): Likewise.
	* pef.c (bfd_pef_object_p, bfd_pef_xlib_object_p): Likewise.
	* xsym.c (bfd_sym_object_p): Likewise.
	* mmo.c (mmo_scan): Clear abfd->symcount.
	* opncls.c (_bfd_new_bfd): Use a smaller section hash table.
	* section.c (bfd_section_list_clear): Clear section_htab.count.
	* bfd-in2.h: Regenerate.
@
text
@d790 1
d793 1
a793 1
  if (abfd->tdata.mmo_data->byte_no != 0)
d795 1
a795 1
      while (abfd->tdata.mmo_data->byte_no < 4 && len != 0)
d797 1
a797 1
	  abfd->tdata.mmo_data->buf[abfd->tdata.mmo_data->byte_no++] = *loc++;
d801 1
a801 1
      if (abfd->tdata.mmo_data->byte_no == 4)
d803 2
a804 3
	  mmo_write_tetra (abfd,
			   bfd_get_32 (abfd, abfd->tdata.mmo_data->buf));
	  abfd->tdata.mmo_data->byte_no = 0;
d814 1
a814 1
		&& ! abfd->tdata.mmo_data->have_error
d823 2
a824 2
      memcpy (abfd->tdata.mmo_data->buf, loc, len);
      abfd->tdata.mmo_data->byte_no = len;
d828 1
a828 1
    abfd->tdata.mmo_data->have_error = TRUE;
@


1.44
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d1539 1
@


1.43
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d366 1
a366 1
static void mmo_print_symbol (bfd *, void *, asymbol *, 
@


1.42
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3193 1
@


1.41
log
@fix set but unused variable warnings
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d3241 1
@


1.40
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
a1532 1
  char *current_filename = NULL;
a1790 1
	      current_filename = file_names[y];
a2827 1
  asymbol *maintable[2];
a2842 2
  maintable[0] = fakemain;
  maintable[1] = NULL;
@


1.39
log
@update copyright dates
@
text
@d3202 2
@


1.38
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.37
log
@	* srec.c (srec_canonicalize_symtab): Don't alloc when symcount
	is zero.  Correct return value on error.
	* mmo.c (mmo_canonicalize_symtab): Likewise.
	* binary.c (binary_canonicalize_symtab) Correct return on error.
@
text
@d3214 1
@


1.36
log
@Switch sources over to use the GPL version 3
@
text
@d2100 1
a2100 1
  if (csymbols == NULL)
d2122 2
a2123 2
      if (csymbols == NULL && symcount != 0)
	return FALSE;
@


1.35
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8 16
a23 1
This file is part of BFD, the Binary File Descriptor library.
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.34
log
@	* libbfd-in.h (_bfd_norelocs_get_reloc_upper_bound): Don't define,
	declare.
	(_bfd_norelocs_canonicalize_reloc): Likewise.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_norelocs_get_reloc_upper_bound): New function.
	(_bfd_norelocs_canonicalize_reloc): Likewise.
	* binary.c (binary_bfd_reloc_type_lookup): Don't define.
	(binary_get_reloc_upper_bound, binary_canonicalize_reloc): Likewise.
	(binary_vec): Use _bfd_norelocs in BFD_JUMP_TABLE_RELOCS.
	* ihex.c: Similarly.
	* mach-o-target.c: Similarly.
	* mach-o.c: Similarly.
	* mmo.c: Similarly.
	* pef.c: Similarly.
	* ppcboot.c: Similarly.
	* srec.c: Similarly.
	* xsym.c: Similarly.
@
text
@d198 1
a199 1
#include "sysdep.h"
@


1.33
log
@	* bfd-in.h (struct stat): Don't typedef.
	* bfdio.c (bfd_get_size): Return a file_ptr.
	* cisco-core.c (cisco_core_file_validate): Use bfd_size_type for nread.
	* mmo.c (mmo_scan): Use file_ptr for curpos.
	* trad-core.c (trad_unix_core): Don't cast statbuf.st_size to
	unsigned long.
	* bfd-in2.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006
a390 1
static long mmo_get_reloc_upper_bound (bfd *, asection *);
a416 1
static long mmo_canonicalize_reloc (bfd *, sec_ptr, arelent **, asymbol **);
a3161 22
/* Return the size of a NULL pointer, so we support linking in an mmo
   object.  */

static long
mmo_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *sec ATTRIBUTE_UNUSED)
{
  return sizeof (void *);
}

/* Similarly canonicalize relocs to empty, filling in the terminating NULL
   pointer.  */

long
mmo_canonicalize_reloc (bfd *abfd ATTRIBUTE_UNUSED,
			sec_ptr section ATTRIBUTE_UNUSED, arelent **relptr,
			asymbol **symbols ATTRIBUTE_UNUSED)
{
  *relptr = NULL;
  return 0;
}

a3212 12
/* objcopy will be upset if we return -1 from bfd_get_reloc_upper_bound by
   using BFD_JUMP_TABLE_RELOCS (_bfd_norelocs) rather than 0.  FIXME: Most
   likely a bug in the _bfd_norelocs definition.

   On the other hand, we smuggle in an mmo object (because setting up ELF
   is too cumbersome) when linking (from other formats, presumably ELF) to
   represent the g255 entry.  We need to link that object, so need to say
   it has no relocs.  Upper bound for the size of the relocation table is
   the size of a NULL pointer, and we support "canonicalization" for that
   pointer.  */
#define mmo_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

d3272 1
a3272 3
  /* We have to provide a valid method for getting relocs, returning zero,
     so we can't say BFD_JUMP_TABLE_RELOCS (_bfd_norelocs).  */
  BFD_JUMP_TABLE_RELOCS (mmo),
@


1.32
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1920 1
a1920 1
		long curpos = bfd_tell (abfd);
@


1.31
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d2424 1
a2424 2
  else if (strncmp (sec->name, MMIX_OTHER_SPEC_SECTION_PREFIX,
		    strlen (MMIX_OTHER_SPEC_SECTION_PREFIX)) == 0)
d2427 1
@


1.30
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d390 1
a390 1
static int mmo_sizeof_headers (bfd *, bfd_boolean);
d2234 1
a2234 1
		    bfd_boolean exec ATTRIBUTE_UNUSED)
@


1.29
log
@	* elf64-mmix.c (mmix_elf_add_symbol_hook): Mark reg section
	SEC_LINKER_CREATED.
	(mmix_elf_final_link): Check that section hasn't already been
	removed before removing.
	* mmo.c (mmo_scan): Mark reg contents section SEC_LINKER_CREATED.
	(mmo_canonicalize_symtab): Likewise for reg section.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005
d2010 1
a2010 1
mmo_new_section_hook (bfd *abfd ATTRIBUTE_UNUSED, asection *newsect)
a2011 5
  /* We zero-fill all fields and assume NULL is represented by an all
     zero-bit pattern.  */
  newsect->used_by_bfd =
    bfd_zalloc (abfd, sizeof (struct mmo_section_data_struct));

d2013 8
a2020 1
    return FALSE;
d2024 1
a2024 1
  return TRUE;
@


1.28
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d1856 1
d2150 1
@


1.27
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3205 1
@


1.26
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.25
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.24
log
@	* mmo.c: Adjust to ISO C.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004
d427 1
a427 1
static unsigned
d950 1
a950 1
  bfd_byte *secname;
d999 1
a999 1
      if (secname[i * 4] == LOP)
d2550 1
a2550 1
  mmo_write_chunk (abfd, sec->name, strlen (sec->name));
@


1.23
log
@	* mmo.c (mmo_write_section_description): New function broken out
	of mmo_internal_write_section.
	(mmo_internal_write_section): For each of .text and .data, call
	mmo_write_section_description before outputting contents if it has
	nontrivially deducible vma or contents.
	(mmo_has_leading_or_trailing_zero_tetra_p): New function.
	(mmo_canonicalize_symtab): Adjust absolute symbols to .data
	symbols if found within the .data address range.
@
text
@d263 1
a263 1
    const char *name;
d358 64
a421 113
static bfd_boolean mmo_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static void mmo_write_section_unless_reg_contents
 PARAMS ((bfd *, asection *, PTR));
static void mmo_find_sec_w_addr
  PARAMS ((bfd *, asection *, PTR));
static void mmo_find_sec_w_addr_grow
  PARAMS ((bfd *, asection *, PTR));
static asection *mmo_make_section
  PARAMS ((bfd *, const char *));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void mmo_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void mmo_init
  PARAMS ((void));
static bfd_boolean mmo_mkobject
  PARAMS ((bfd *));
static bfd_boolean mmo_scan
  PARAMS ((bfd *));
static asection *mmo_decide_section
  PARAMS ((bfd *, bfd_vma));
static asection *mmo_get_generic_spec_data_section
  PARAMS ((bfd *, int));
static asection *mmo_get_spec_section
  PARAMS ((bfd *, int));
static INLINE bfd_byte *mmo_get_loc
  PARAMS ((asection *, bfd_vma, int));
static void mmo_xore_64
  PARAMS ((asection *, bfd_vma vma, bfd_vma value));
static void mmo_xore_32
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static void mmo_xore_16
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static const bfd_target *mmo_object_p
  PARAMS ((bfd *));
static void mmo_map_set_sizes
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean mmo_get_symbols
  PARAMS ((bfd *));
static bfd_boolean mmo_create_symbol
  PARAMS ((bfd *, const char *, bfd_vma, enum mmo_sym_type, unsigned int));
static bfd_boolean mmo_get_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
static long mmo_get_symtab_upper_bound
  PARAMS ((bfd *));
static long mmo_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void mmo_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean mmo_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static int mmo_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static long mmo_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));

static bfd_boolean mmo_internal_write_header
  PARAMS ((bfd *));
static bfd_boolean mmo_internal_write_post
  PARAMS ((bfd *, int, asection *));
static bfd_boolean mmo_internal_add_3_sym
  PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
static unsigned int mmo_internal_3_length
  PARAMS ((bfd *, struct mmo_symbol_trie *));
static void mmo_internal_3_dump
  PARAMS ((bfd *, struct mmo_symbol_trie *));
static void mmo_beb128_out
  PARAMS ((bfd *, int, int));
static bfd_boolean mmo_internal_write_section
  PARAMS ((bfd *, asection *));
static void mmo_write_tetra
  PARAMS ((bfd *, unsigned int));
static void mmo_write_tetra_raw
  PARAMS ((bfd *, unsigned int));
static void mmo_write_octa
  PARAMS ((bfd *, bfd_vma));
static void mmo_write_octa_raw
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean mmo_write_chunk
  PARAMS ((bfd *, const bfd_byte *, unsigned int));
static bfd_boolean mmo_flush_chunk
  PARAMS ((bfd *));
static bfd_boolean mmo_write_loc_chunk
  PARAMS ((bfd *, bfd_vma, const bfd_byte *, unsigned int, bfd_vma *));
static bfd_boolean mmo_write_chunk_list
  PARAMS ((bfd *, mmo_data_list_type *));
static bfd_boolean mmo_write_loc_chunk_list
  PARAMS ((bfd *, mmo_data_list_type *));
static bfd_boolean mmo_write_symbols_and_terminator
  PARAMS ((bfd *));
static flagword mmo_sec_flags_from_bfd_flags
  PARAMS ((flagword));
static flagword bfd_sec_flags_from_mmo_flags
  PARAMS ((flagword));
static bfd_byte mmo_get_byte
  PARAMS ((bfd *));
static void mmo_write_byte
  PARAMS ((bfd *, bfd_byte));
static bfd_boolean mmo_new_section_hook
  PARAMS ((bfd *, asection *));
static int mmo_sort_mmo_symbols
  PARAMS ((const PTR, const PTR));
static bfd_boolean mmo_write_object_contents
  PARAMS ((bfd *));
static long mmo_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static bfd_boolean mmo_write_section_description
  PARAMS ((bfd *, asection *));
static bfd_boolean mmo_has_leading_or_trailing_zero_tetra_p
  PARAMS ((bfd *, asection *));
d445 1
a445 3
mmo_make_section (abfd, secname)
     bfd *abfd;
     const char *secname;
d472 1
a472 1
mmo_init ()
d495 1
a495 2
mmo_object_p (abfd)
     bfd *abfd;
d562 1
a562 2
mmo_mkobject (abfd)
     bfd *abfd;
d586 1
a586 3
mmo_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d604 1
a604 4
mmo_find_sec_w_addr (abfd, sec, p)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR p;
d619 1
a619 4
mmo_find_sec_w_addr_grow (abfd, sec, p)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR p;
d639 1
a639 3
mmo_decide_section (abfd, vma)
     bfd *abfd;
     bfd_vma vma;
d708 1
a708 4
mmo_xore_64 (sec, vma, value)
     asection *sec;
     bfd_vma vma;
     bfd_vma value;
d720 1
a720 4
mmo_xore_32 (sec, vma, value)
     asection *sec;
     bfd_vma vma;
     unsigned int value;
d732 1
a732 4
mmo_xore_16 (sec, vma, value)
     asection *sec;
     bfd_vma vma;
     unsigned int value;
d744 1
a744 3
mmo_write_tetra_raw (abfd, value)
     bfd *abfd;
     unsigned int value;
d750 1
a750 1
  if (bfd_bwrite ((PTR) buf, 4, abfd) != 4)
d757 1
a757 3
mmo_write_tetra (abfd, value)
     bfd *abfd;
     unsigned int value;
d768 1
a768 3
mmo_write_octa (abfd, value)
     bfd *abfd;
     bfd_vma value;
d777 1
a777 3
mmo_write_octa_raw (abfd, value)
     bfd *abfd;
     bfd_vma value;
d787 1
a787 4
mmo_write_chunk (abfd, loc, len)
     bfd *abfd;
     const bfd_byte *loc;
     unsigned int len;
d815 1
a815 1
		&& 4 == bfd_bwrite ((PTR) loc, 4, abfd));
d836 1
a836 2
mmo_flush_chunk (abfd)
     bfd *abfd;
d853 1
a853 3
mmo_write_chunk_list (abfd, datap)
     bfd *abfd;
     mmo_data_list_type *datap;
d867 2
a868 6
mmo_write_loc_chunk (abfd, vma, loc, len, last_vmap)
     bfd *abfd;
     bfd_vma vma;
     const bfd_byte *loc;
     unsigned int len;
     bfd_vma *last_vmap;
d914 1
a914 3
mmo_write_loc_chunk_list (abfd, datap)
     bfd *abfd;
     mmo_data_list_type *datap;
d930 1
a930 3
mmo_get_generic_spec_data_section (abfd, spec_data_number)
     bfd *abfd;
     int spec_data_number;
d948 1
a948 3
mmo_get_spec_section (abfd, spec_data_number)
     bfd *abfd;
     int spec_data_number;
d1111 1
a1111 2
mmo_get_byte (abfd)
     bfd *abfd;
d1137 1
a1137 3
mmo_write_byte (abfd, value)
     bfd *abfd;
     bfd_byte value;
d1151 2
a1152 6
mmo_create_symbol (abfd, symname, addr, sym_type, serno)
     bfd *abfd;
     const char *symname;
     bfd_vma addr;
     enum mmo_sym_type sym_type;
     unsigned int serno;
d1164 1
a1164 1
  strcpy ((PTR) n->name, symname);
d1199 1
a1199 2
mmo_get_symbols (abfd)
     bfd *abfd;
d1332 2
a1333 2
		(_("%s: unsupported wide character sequence\
 0x%02X 0x%02X after symbol name starting with `%s'\n"),
d1415 1
a1415 4
mmo_get_loc (sec, vma, size)
     asection *sec;
     bfd_vma vma;
     int size;
d1515 2
a1516 4
mmo_map_set_sizes (abfd, sec, ignored)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR ignored ATTRIBUTE_UNUSED;
d1524 1
a1524 2
mmo_scan (abfd)
     bfd *abfd;
d1772 2
a1773 2
			(_("%s: invalid mmo file: file number %d `%s',\
 was already entered as `%s'\n"),
d1785 2
a1786 2
		    (_("%s: invalid mmo file: file name for number %d\
 was not specified before use\n"),
d1891 2
a1892 2
		    (_("%s: invalid mmo file: fields y and z of lop_stab\
 non-zero, y: %d, z: %d\n"),
d1927 2
a1928 2
		      (_("%s: invalid mmo file: lop_end not last item in\
 file\n"),
d1940 3
a1942 2
		      (_("%s: invalid mmo file: YZ of lop_end (%ld)\
 not equal to the number of tetras to the preceding lop_stab (%ld)\n"),
d2009 1
a2009 3
mmo_new_section_hook (abfd, newsect)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *newsect;
d2014 1
a2014 1
    (PTR) bfd_zalloc (abfd, sizeof (struct mmo_section_data_struct));
d2028 5
a2032 6
mmo_get_section_contents (abfd, sec, location, offset, bytes_to_do)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     PTR location ATTRIBUTE_UNUSED;
     file_ptr offset ATTRIBUTE_UNUSED;
     bfd_size_type bytes_to_do ATTRIBUTE_UNUSED;
d2064 1
a2064 2
mmo_get_symtab_upper_bound (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d2072 1
a2072 3
mmo_sort_mmo_symbols (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d2090 1
a2090 3
mmo_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d2199 2
a2200 4
mmo_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d2206 2
a2207 5
mmo_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
d2217 1
a2217 1
      bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d2229 2
a2230 3
mmo_sizeof_headers (abfd, exec)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean exec ATTRIBUTE_UNUSED;
d2238 1
a2238 2
mmo_internal_write_header (abfd)
     bfd *abfd;
d2258 1
a2258 4
mmo_internal_write_post (abfd, z, sec)
     bfd *abfd;
     int z;
     asection *sec;
d2284 1
a2284 2
mmo_sec_flags_from_bfd_flags (flags)
     flagword flags;
d2311 1
a2311 2
bfd_sec_flags_from_mmo_flags (flags)
     flagword flags;
d2341 1
a2341 3
mmo_has_leading_or_trailing_zero_tetra_p (abfd, sec)
     bfd *abfd;
     asection *sec;
d2359 1
a2359 3
mmo_internal_write_section (abfd, sec)
     bfd *abfd;
     asection *sec;
d2453 1
a2453 3
mmo_write_section_description (abfd, sec)
     bfd *abfd;
     asection *sec;
d2567 3
a2569 6
mmo_set_section_contents (abfd, sec, location, offset, bytes_to_do)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr sec;
     const PTR location;
     file_ptr offset;
     bfd_size_type bytes_to_do;
d2600 2
a2601 4
mmo_internal_add_3_sym (abfd, rootp, symp)
     bfd *abfd;
     struct mmo_symbol_trie *rootp;
     const struct mmo_symbol *symp;
d2660 1
a2660 3
mmo_internal_3_length (abfd, trie)
     bfd *abfd;
     struct mmo_symbol_trie *trie;
d2720 1
a2720 4
mmo_beb128_out (abfd, serno, marker)
     bfd *abfd;
     int serno;
     int marker;
d2730 1
a2730 3
mmo_internal_3_dump (abfd, trie)
     bfd *abfd;
     struct mmo_symbol_trie *trie;
d2823 1
a2823 2
mmo_write_symbols_and_terminator (abfd)
     bfd *abfd;
d2890 2
a2891 2
	      (_("%s: Bad symbol definition: `Main' set to %s rather\
 than the start address %s\n"),
d2923 3
a2925 1
	  sym.name = s->name;
d2982 2
a2983 2
	(_("%s: warning: symbol table too large for mmo, larger than 65535\
 32-bit words: %d.  Only `Main' will be emitted.\n"),
d3027 2
a3028 2
	(_("%s: internal error, symbol table changed size from %d to %d\
 words\n"),
d3057 1
a3057 4
mmo_write_section_unless_reg_contents (abfd, sec, p)
     bfd *abfd;
     asection *sec;
     PTR p;
d3079 2
a3080 2
	    (_("%s: internal error, internal register section %s had\
 contents\n"),
d3097 1
a3097 2
mmo_write_object_contents (abfd)
     bfd *abfd;
d3109 1
a3109 1
			 (PTR) &wsecinfo);
d3141 2
a3142 2
	      (_("%s: invalid start address for initialized registers of\
 length %ld: 0x%lx%08lx\n"),
d3164 2
a3165 3
mmo_get_reloc_upper_bound (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
d3167 1
a3167 1
  return sizeof (PTR);
d3174 3
a3176 5
mmo_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr section ATTRIBUTE_UNUSED;
     arelent **relptr;
     asymbol **symbols ATTRIBUTE_UNUSED;
@


1.22
log
@	* mmo.c (File Layout): Correct place of misplaced blurb about
	special data.
@
text
@d467 4
d2271 1
d2280 17
d2466 21
d2507 20
a2526 2
    /* FIXME: Output source file name and line number.  */
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2528 17
a2544 1
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2566 25
a2590 1
      /* Keep the document-comment formatted the way it is.  */
d2683 13
a2695 23
      mmo_write_tetra_raw (abfd, LOP_SPEC_SECTION);
      mmo_write_tetra (abfd, (strlen (sec->name) + 3) / 4);
      mmo_write_chunk (abfd, sec->name, strlen (sec->name));
      mmo_flush_chunk (abfd);
      /* FIXME: We can get debug sections (.debug_line & Co.) with a
	 section flag still having SEC_RELOC set.  Investigate.  This
	 might be true for all alien sections; perhaps mmo.em should clear
	 that flag.  Might be related to weak references.  */
      mmo_write_tetra (abfd,
		       mmo_sec_flags_from_bfd_flags
		       (bfd_get_section_flags (abfd, sec)));
      mmo_write_octa (abfd, sec->size);
      mmo_write_octa (abfd, bfd_get_section_vma (abfd, sec));

      /* Writing a LOP_LOC ends the LOP_SPEC data, and makes data actually
	 loaded.  */
      if (bfd_get_section_flags (abfd, sec) & SEC_LOAD)
	return (! abfd->tdata.mmo_data->have_error
		&& mmo_write_loc_chunk_list (abfd,
					     mmo_section_data (sec)->head));
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
    }
@


1.21
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d64 6
a79 6
	There is provision for specifying ``special data'' of 65536
	different types.  We use type 80 (decimal), arbitrarily chosen the
	same as the ELF <<e_machine>> number for MMIX, filling it with
	section information normally found in ELF objects. @@xref{mmo
	section mapping}.

@


1.20
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d3258 2
@


1.19
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d3289 2
@


1.18
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d668 1
a668 1
  if (infop->addr >= vma && infop->addr < vma + sec->_raw_size)
d1171 1
a1171 2
      || ! bfd_set_section_size (abfd, sec,
				 sec->_cooked_size + section_length)
d1547 2
a1548 2
	  if (vma + size > sec->vma + sec->_raw_size)
	    sec->_raw_size += (vma + size) - (sec->vma + sec->_raw_size);
d1610 2
a1611 2
  if (vma + size > sec->vma + sec->_raw_size)
    sec->_raw_size += (vma + size) - (sec->vma + sec->_raw_size);
a1622 1
  sec->_cooked_size = sec->_raw_size;
d2270 1
a2270 1
		  && c->value <= textsec->vma + textsec->_cooked_size)
d2487 1
a2487 1
	   && sec->_raw_size != 0)
d2593 1
a2593 1
      mmo_write_octa (abfd, sec->_raw_size);
d3182 1
a3182 1
	  || sec->vma != 256 * 8 - sec->_raw_size - 8)
d3186 1
a3186 1
	  if (sec->_raw_size == 0)
d3197 1
a3197 1
	       (long) sec->_raw_size);
d3203 1
a3203 1
	       (long) sec->_raw_size,
@


1.17
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d3309 1
@


1.16
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003
d3289 1
@


1.16.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004
d668 1
a668 1
  if (infop->addr >= vma && infop->addr < vma + sec->size)
d1171 2
a1172 1
      || ! bfd_set_section_size (abfd, sec, sec->size + section_length)
d1548 2
a1549 2
	  if (vma + size > sec->vma + sec->size)
	    sec->size += (vma + size) - (sec->vma + sec->size);
d1611 2
a1612 2
  if (vma + size > sec->vma + sec->size)
    sec->size += (vma + size) - (sec->vma + sec->size);
d1624 1
d2272 1
a2272 1
		  && c->value <= textsec->vma + textsec->size)
d2489 1
a2489 1
	   && sec->size != 0)
d2595 1
a2595 1
      mmo_write_octa (abfd, sec->size);
d3184 1
a3184 1
	  || sec->vma != 256 * 8 - sec->size - 8)
d3188 1
a3188 1
	  if (sec->size == 0)
d3199 1
a3199 1
	       (long) sec->size);
d3205 1
a3205 1
	       (long) sec->size,
a3288 1
#define mmo_bfd_is_group_section bfd_generic_is_group_section
a3289 2
#define mmo_section_already_linked \
  _bfd_generic_section_already_linked
a3307 1
#define mmo_bfd_copy_private_header_data _bfd_generic_bfd_copy_private_header_data
@


1.15
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d411 1
a411 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d2616 1
a2616 1
     PTR location;
@


1.14
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d404 1
a404 1
static long mmo_get_symtab
d2203 1
a2203 1
mmo_get_symtab (abfd, alocation)
@


1.13
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2001, 2002
d338 3
d1183 2
a1184 3
  if (((struct mmo_section_data_struct *) (sec->used_by_bfd))->tail != NULL)
    ((struct mmo_section_data_struct *) (sec->used_by_bfd))->tail->next
      = loc;
d1186 2
a1187 2
    ((struct mmo_section_data_struct *) (sec->used_by_bfd))->head = loc;
  ((struct mmo_section_data_struct *) (sec->used_by_bfd))->tail = loc;
d1522 1
a1522 2
  struct mmo_section_data_struct *sdatap
    = (struct mmo_section_data_struct *) sec->used_by_bfd;
d2467 1
a2467 4
    return
      mmo_write_loc_chunk_list (abfd,
				((struct mmo_section_data_struct *)
				 (sec->used_by_bfd))->head);
d2469 1
a2469 4
    return
      mmo_write_loc_chunk_list (abfd,
				((struct mmo_section_data_struct *)
				 (sec->used_by_bfd))->head);
d2484 1
a2484 3
	      && mmo_write_chunk_list (abfd,
				       ((struct mmo_section_data_struct *)
					(sec->used_by_bfd))->head));
d2601 5
a2605 10
	  return
	    ! abfd->tdata.mmo_data->have_error
	    && mmo_write_loc_chunk_list (abfd,
					 ((struct mmo_section_data_struct *)
					  (sec->used_by_bfd))->head);
      return
	! abfd->tdata.mmo_data->have_error
	&& mmo_write_chunk_list (abfd,
				 ((struct mmo_section_data_struct *)
				  (sec->used_by_bfd))->head);
@


1.12
log
@	* mmo.c (mmo_write_loc_chunk): Don't eliminate leading and
	trailing zero-sequences when there's previous left-over data.
@
text
@d305 1
a305 1
    boolean have_error;
d345 1
a345 1
    boolean retval;
d355 2
a356 1
static boolean mmo_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d359 8
a366 4
static void mmo_find_sec_w_addr PARAMS ((bfd *, asection *, PTR));
static void mmo_find_sec_w_addr_grow PARAMS ((bfd *, asection *, PTR));
static asection *mmo_make_section PARAMS ((bfd *, const char *));
static void mmo_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
d368 30
a397 17
 PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void mmo_init PARAMS ((void));
static boolean mmo_mkobject PARAMS ((bfd *));
static boolean mmo_scan PARAMS ((bfd *));
static asection *mmo_decide_section PARAMS ((bfd *, bfd_vma));
static asection *mmo_get_generic_spec_data_section PARAMS ((bfd *, int));
static asection *mmo_get_spec_section PARAMS ((bfd *, int));
static INLINE bfd_byte *mmo_get_loc PARAMS ((asection *, bfd_vma, int));
static void mmo_xore_64 PARAMS ((asection *, bfd_vma vma, bfd_vma value));
static void mmo_xore_32 PARAMS ((asection *, bfd_vma vma, unsigned int));
static void mmo_xore_16 PARAMS ((asection *, bfd_vma vma, unsigned int));
static const bfd_target *mmo_object_p PARAMS ((bfd *));
static void mmo_map_set_sizes PARAMS ((bfd *, asection *, PTR));
static boolean mmo_get_symbols PARAMS ((bfd *));
static boolean mmo_create_symbol PARAMS ((bfd *, const char *, bfd_vma,
					  enum mmo_sym_type, unsigned int));
static boolean mmo_get_section_contents
d399 9
a407 6
static long mmo_get_symtab_upper_bound PARAMS ((bfd *));
static long mmo_get_symtab PARAMS ((bfd *, asymbol **));
static void mmo_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
static void mmo_print_symbol PARAMS ((bfd *, PTR, asymbol *,
				      bfd_print_symbol_type));
static boolean mmo_set_section_contents
d409 4
a412 2
static int mmo_sizeof_headers PARAMS ((bfd *, boolean));
static long mmo_get_reloc_upper_bound PARAMS ((bfd *, asection *));
d414 6
a419 4
static boolean mmo_internal_write_header PARAMS ((bfd *));
static boolean mmo_internal_write_post PARAMS ((bfd *, int, asection *));
static boolean mmo_internal_add_3_sym
 PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
d421 1
a421 1
 PARAMS ((bfd *, struct mmo_symbol_trie *));
d423 4
a426 3
 PARAMS ((bfd *, struct mmo_symbol_trie *));
static void mmo_beb128_out PARAMS ((bfd *, int, int));
static boolean mmo_internal_write_section
d428 9
a436 5
static void mmo_write_tetra PARAMS ((bfd *, unsigned int));
static void mmo_write_tetra_raw PARAMS ((bfd *, unsigned int));
static void mmo_write_octa PARAMS ((bfd *, bfd_vma));
static void mmo_write_octa_raw PARAMS ((bfd *, bfd_vma));
static boolean mmo_write_chunk
d438 3
a440 2
static boolean mmo_flush_chunk PARAMS ((bfd *));
static boolean mmo_write_loc_chunk
d442 1
a442 2
static boolean mmo_write_chunk_list PARAMS ((bfd *, mmo_data_list_type *));
static boolean mmo_write_loc_chunk_list
d444 18
a461 8
static boolean mmo_write_symbols_and_terminator PARAMS ((bfd *));
static flagword mmo_sec_flags_from_bfd_flags PARAMS ((flagword));
static flagword bfd_sec_flags_from_mmo_flags PARAMS ((flagword));
static bfd_byte mmo_get_byte PARAMS ((bfd *));
static void mmo_write_byte PARAMS ((bfd *, bfd_byte));
static boolean mmo_new_section_hook PARAMS ((bfd *, asection *));
static int mmo_sort_mmo_symbols PARAMS ((const PTR, const PTR));
static boolean mmo_write_object_contents PARAMS ((bfd *));
d518 1
a518 1
  static boolean inited = false;
d526 1
a526 1
  inited = true;
d606 1
a606 1
static boolean
d620 1
a620 1
	return false;
d628 1
a628 1
  return true;
d631 1
a631 1
static boolean
d638 1
a638 1
    return true;
d645 1
a645 1
  return true;
d818 1
a818 1
    abfd->tdata.mmo_data->have_error = true;
d859 1
a859 1
static INLINE boolean
d865 1
a865 1
  boolean retval = true;
d904 1
a904 1
    abfd->tdata.mmo_data->have_error = true;
d911 1
a911 1
static INLINE boolean
d929 1
a929 1
static INLINE boolean
d936 1
a936 1
      return false;
d945 1
a945 1
static boolean
d996 1
a996 1
static INLINE boolean
d1007 1
a1007 1
      return false;
d1212 1
a1212 1
	  abfd->tdata.mmo_data->have_error = true;
d1238 1
a1238 1
	abfd->tdata.mmo_data->have_error = true;
d1244 1
a1244 1
static boolean
d1256 1
a1256 1
    return false;
d1260 1
a1260 1
    return false;
d1288 1
a1288 1
      return false;
d1291 1
a1291 1
  return true;
d1296 1
a1296 1
static boolean
d1403 1
a1403 1
    return false;
d1436 2
a1437 2
	      abfd->tdata.mmo_data->have_error = true;
	      return false;
d1491 1
a1491 1
	    abfd->tdata.mmo_data->have_error = true;
d1629 1
a1629 1
static boolean
d1635 1
a1635 1
  boolean error = false;
d2082 1
a2082 1
  error = true;
d2094 1
a2094 1
    error = true;
d2102 1
a2102 1
    error = true;
d2114 1
a2114 1
static boolean
d2125 1
a2125 1
    return false;
d2129 1
a2129 1
  return true;
d2135 1
a2135 1
static boolean
d2159 1
a2159 1
	return false;
d2167 1
a2167 1
  return true;
d2234 1
a2234 1
	return false;
d2332 1
a2332 1
     boolean exec ATTRIBUTE_UNUSED;
d2339 1
a2339 1
static boolean
d2346 1
a2346 1
    return false;
d2350 1
a2350 1
    return false;
d2352 1
a2352 1
  return true;
d2360 1
a2360 1
static boolean
d2375 1
a2375 1
	return false;
d2447 1
a2447 1
static boolean
d2481 1
a2481 1
      return false;
d2608 1
a2608 1
	  return 
d2619 1
a2619 1
  return true;
d2624 1
a2624 1
static boolean
d2647 1
a2647 1
	return false;
d2655 1
a2655 1
  return true;
d2660 1
a2660 1
static boolean
d2713 1
a2713 1
      return false;
d2717 1
a2717 1
  return true;
d2892 1
a2892 1
static boolean
d2925 1
a2925 1
    return false;
d2965 1
a2965 1
	    return false;
d3028 1
a3028 1
	    return false;
d3069 1
a3069 1
	return false;
d3085 1
a3085 1
    return false;
d3101 1
a3101 1
      return false;
d3114 1
a3114 1
	return false;
d3155 1
a3155 1
	  infop->retval = false;
d3168 1
a3168 1
static boolean
d3176 1
a3176 1
    return false;
d3179 1
a3179 1
  wsecinfo.retval = true;
d3185 1
a3185 1
    return false;
d3220 1
a3220 1
	  return false;
d3224 1
a3224 1
	return false;
d3228 1
a3228 1
      return false;
@


1.12.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003
d305 1
a305 1
    bfd_boolean have_error;
a337 3
#define mmo_section_data(sec) \
  ((struct mmo_section_data_struct *) (sec)->used_by_bfd)

d345 1
a345 1
    bfd_boolean retval;
d355 1
a355 2
static bfd_boolean mmo_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d358 4
a361 8
static void mmo_find_sec_w_addr
  PARAMS ((bfd *, asection *, PTR));
static void mmo_find_sec_w_addr_grow
  PARAMS ((bfd *, asection *, PTR));
static asection *mmo_make_section
  PARAMS ((bfd *, const char *));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d363 17
a379 30
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void mmo_init
  PARAMS ((void));
static bfd_boolean mmo_mkobject
  PARAMS ((bfd *));
static bfd_boolean mmo_scan
  PARAMS ((bfd *));
static asection *mmo_decide_section
  PARAMS ((bfd *, bfd_vma));
static asection *mmo_get_generic_spec_data_section
  PARAMS ((bfd *, int));
static asection *mmo_get_spec_section
  PARAMS ((bfd *, int));
static INLINE bfd_byte *mmo_get_loc
  PARAMS ((asection *, bfd_vma, int));
static void mmo_xore_64
  PARAMS ((asection *, bfd_vma vma, bfd_vma value));
static void mmo_xore_32
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static void mmo_xore_16
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static const bfd_target *mmo_object_p
  PARAMS ((bfd *));
static void mmo_map_set_sizes
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean mmo_get_symbols
  PARAMS ((bfd *));
static bfd_boolean mmo_create_symbol
  PARAMS ((bfd *, const char *, bfd_vma, enum mmo_sym_type, unsigned int));
static bfd_boolean mmo_get_section_contents
d381 14
a394 21
static long mmo_get_symtab_upper_bound
  PARAMS ((bfd *));
static long mmo_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void mmo_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean mmo_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static int mmo_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static long mmo_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));

static bfd_boolean mmo_internal_write_header
  PARAMS ((bfd *));
static bfd_boolean mmo_internal_write_post
  PARAMS ((bfd *, int, asection *));
static bfd_boolean mmo_internal_add_3_sym
  PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
d396 1
a396 1
  PARAMS ((bfd *, struct mmo_symbol_trie *));
d398 3
a400 4
  PARAMS ((bfd *, struct mmo_symbol_trie *));
static void mmo_beb128_out
  PARAMS ((bfd *, int, int));
static bfd_boolean mmo_internal_write_section
d402 5
a406 9
static void mmo_write_tetra
  PARAMS ((bfd *, unsigned int));
static void mmo_write_tetra_raw
  PARAMS ((bfd *, unsigned int));
static void mmo_write_octa
  PARAMS ((bfd *, bfd_vma));
static void mmo_write_octa_raw
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean mmo_write_chunk
d408 2
a409 3
static bfd_boolean mmo_flush_chunk
  PARAMS ((bfd *));
static bfd_boolean mmo_write_loc_chunk
d411 2
a412 1
static bfd_boolean mmo_write_chunk_list
d414 8
a421 18
static bfd_boolean mmo_write_loc_chunk_list
  PARAMS ((bfd *, mmo_data_list_type *));
static bfd_boolean mmo_write_symbols_and_terminator
  PARAMS ((bfd *));
static flagword mmo_sec_flags_from_bfd_flags
  PARAMS ((flagword));
static flagword bfd_sec_flags_from_mmo_flags
  PARAMS ((flagword));
static bfd_byte mmo_get_byte
  PARAMS ((bfd *));
static void mmo_write_byte
  PARAMS ((bfd *, bfd_byte));
static bfd_boolean mmo_new_section_hook
  PARAMS ((bfd *, asection *));
static int mmo_sort_mmo_symbols
  PARAMS ((const PTR, const PTR));
static bfd_boolean mmo_write_object_contents
  PARAMS ((bfd *));
d478 1
a478 1
  static bfd_boolean inited = FALSE;
d486 1
a486 1
  inited = TRUE;
d566 1
a566 1
static bfd_boolean
d580 1
a580 1
	return FALSE;
d588 1
a588 1
  return TRUE;
d591 1
a591 1
static bfd_boolean
d598 1
a598 1
    return TRUE;
d605 1
a605 1
  return TRUE;
d778 1
a778 1
    abfd->tdata.mmo_data->have_error = TRUE;
d819 1
a819 1
static INLINE bfd_boolean
d825 1
a825 1
  bfd_boolean retval = TRUE;
d864 1
a864 1
    abfd->tdata.mmo_data->have_error = TRUE;
d871 1
a871 1
static INLINE bfd_boolean
d889 1
a889 1
static INLINE bfd_boolean
d896 1
a896 1
      return FALSE;
d905 1
a905 1
static bfd_boolean
d956 1
a956 1
static INLINE bfd_boolean
d967 1
a967 1
      return FALSE;
d1140 3
a1142 2
  if (mmo_section_data (sec)->tail != NULL)
    mmo_section_data (sec)->tail->next = loc;
d1144 2
a1145 2
    mmo_section_data (sec)->head = loc;
  mmo_section_data (sec)->tail = loc;
d1172 1
a1172 1
	  abfd->tdata.mmo_data->have_error = TRUE;
d1198 1
a1198 1
	abfd->tdata.mmo_data->have_error = TRUE;
d1204 1
a1204 1
static bfd_boolean
d1216 1
a1216 1
    return FALSE;
d1220 1
a1220 1
    return FALSE;
d1248 1
a1248 1
      return FALSE;
d1251 1
a1251 1
  return TRUE;
d1256 1
a1256 1
static bfd_boolean
d1363 1
a1363 1
    return FALSE;
d1396 2
a1397 2
	      abfd->tdata.mmo_data->have_error = TRUE;
	      return FALSE;
d1451 1
a1451 1
	    abfd->tdata.mmo_data->have_error = TRUE;
d1480 2
a1481 1
  struct mmo_section_data_struct *sdatap = mmo_section_data (sec);
d1589 1
a1589 1
static bfd_boolean
d1595 1
a1595 1
  bfd_boolean error = FALSE;
d2042 1
a2042 1
  error = TRUE;
d2054 1
a2054 1
    error = TRUE;
d2062 1
a2062 1
    error = TRUE;
d2074 1
a2074 1
static bfd_boolean
d2085 1
a2085 1
    return FALSE;
d2089 1
a2089 1
  return TRUE;
d2095 1
a2095 1
static bfd_boolean
d2119 1
a2119 1
	return FALSE;
d2127 1
a2127 1
  return TRUE;
d2162 1
a2162 1
mmo_canonicalize_symtab (abfd, alocation)
d2194 1
a2194 1
	return FALSE;
d2292 1
a2292 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d2299 1
a2299 1
static bfd_boolean
d2306 1
a2306 1
    return FALSE;
d2310 1
a2310 1
    return FALSE;
d2312 1
a2312 1
  return TRUE;
d2320 1
a2320 1
static bfd_boolean
d2335 1
a2335 1
	return FALSE;
d2407 1
a2407 1
static bfd_boolean
d2426 4
a2429 1
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2431 4
a2434 1
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2441 1
a2441 1
      return FALSE;
d2449 3
a2451 1
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
d2568 10
a2577 5
	return (! abfd->tdata.mmo_data->have_error
		&& mmo_write_loc_chunk_list (abfd,
					     mmo_section_data (sec)->head));
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
d2579 1
a2579 1
  return TRUE;
d2584 1
a2584 1
static bfd_boolean
d2588 1
a2588 1
     const PTR location;
d2607 1
a2607 1
	return FALSE;
d2615 1
a2615 1
  return TRUE;
d2620 1
a2620 1
static bfd_boolean
d2673 1
a2673 1
      return FALSE;
d2677 1
a2677 1
  return TRUE;
d2852 1
a2852 1
static bfd_boolean
d2885 1
a2885 1
    return FALSE;
d2925 1
a2925 1
	    return FALSE;
d2988 1
a2988 1
	    return FALSE;
d3029 1
a3029 1
	return FALSE;
d3045 1
a3045 1
    return FALSE;
d3061 1
a3061 1
      return FALSE;
d3074 1
a3074 1
	return FALSE;
d3115 1
a3115 1
	  infop->retval = FALSE;
d3128 1
a3128 1
static bfd_boolean
d3136 1
a3136 1
    return FALSE;
d3139 1
a3139 1
  wsecinfo.retval = TRUE;
d3145 1
a3145 1
    return FALSE;
d3180 1
a3180 1
	  return FALSE;
d3184 1
a3184 1
	return FALSE;
d3188 1
a3188 1
      return FALSE;
@


1.12.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d305 1
a305 1
    bfd_boolean have_error;
d345 1
a345 1
    bfd_boolean retval;
d355 1
a355 2
static bfd_boolean mmo_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d358 4
a361 8
static void mmo_find_sec_w_addr
  PARAMS ((bfd *, asection *, PTR));
static void mmo_find_sec_w_addr_grow
  PARAMS ((bfd *, asection *, PTR));
static asection *mmo_make_section
  PARAMS ((bfd *, const char *));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d363 17
a379 30
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void mmo_init
  PARAMS ((void));
static bfd_boolean mmo_mkobject
  PARAMS ((bfd *));
static bfd_boolean mmo_scan
  PARAMS ((bfd *));
static asection *mmo_decide_section
  PARAMS ((bfd *, bfd_vma));
static asection *mmo_get_generic_spec_data_section
  PARAMS ((bfd *, int));
static asection *mmo_get_spec_section
  PARAMS ((bfd *, int));
static INLINE bfd_byte *mmo_get_loc
  PARAMS ((asection *, bfd_vma, int));
static void mmo_xore_64
  PARAMS ((asection *, bfd_vma vma, bfd_vma value));
static void mmo_xore_32
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static void mmo_xore_16
  PARAMS ((asection *, bfd_vma vma, unsigned int));
static const bfd_target *mmo_object_p
  PARAMS ((bfd *));
static void mmo_map_set_sizes
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean mmo_get_symbols
  PARAMS ((bfd *));
static bfd_boolean mmo_create_symbol
  PARAMS ((bfd *, const char *, bfd_vma, enum mmo_sym_type, unsigned int));
static bfd_boolean mmo_get_section_contents
d381 6
a386 9
static long mmo_get_symtab_upper_bound
  PARAMS ((bfd *));
static long mmo_get_symtab
  PARAMS ((bfd *, asymbol **));
static void mmo_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void mmo_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean mmo_set_section_contents
d388 2
a389 4
static int mmo_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static long mmo_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));
d391 4
a394 6
static bfd_boolean mmo_internal_write_header
  PARAMS ((bfd *));
static bfd_boolean mmo_internal_write_post
  PARAMS ((bfd *, int, asection *));
static bfd_boolean mmo_internal_add_3_sym
  PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
d396 1
a396 1
  PARAMS ((bfd *, struct mmo_symbol_trie *));
d398 3
a400 4
  PARAMS ((bfd *, struct mmo_symbol_trie *));
static void mmo_beb128_out
  PARAMS ((bfd *, int, int));
static bfd_boolean mmo_internal_write_section
d402 5
a406 9
static void mmo_write_tetra
  PARAMS ((bfd *, unsigned int));
static void mmo_write_tetra_raw
  PARAMS ((bfd *, unsigned int));
static void mmo_write_octa
  PARAMS ((bfd *, bfd_vma));
static void mmo_write_octa_raw
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean mmo_write_chunk
d408 2
a409 3
static bfd_boolean mmo_flush_chunk
  PARAMS ((bfd *));
static bfd_boolean mmo_write_loc_chunk
d411 2
a412 1
static bfd_boolean mmo_write_chunk_list
d414 8
a421 18
static bfd_boolean mmo_write_loc_chunk_list
  PARAMS ((bfd *, mmo_data_list_type *));
static bfd_boolean mmo_write_symbols_and_terminator
  PARAMS ((bfd *));
static flagword mmo_sec_flags_from_bfd_flags
  PARAMS ((flagword));
static flagword bfd_sec_flags_from_mmo_flags
  PARAMS ((flagword));
static bfd_byte mmo_get_byte
  PARAMS ((bfd *));
static void mmo_write_byte
  PARAMS ((bfd *, bfd_byte));
static bfd_boolean mmo_new_section_hook
  PARAMS ((bfd *, asection *));
static int mmo_sort_mmo_symbols
  PARAMS ((const PTR, const PTR));
static bfd_boolean mmo_write_object_contents
  PARAMS ((bfd *));
d478 1
a478 1
  static bfd_boolean inited = FALSE;
d486 1
a486 1
  inited = TRUE;
d566 1
a566 1
static bfd_boolean
d580 1
a580 1
	return FALSE;
d588 1
a588 1
  return TRUE;
d591 1
a591 1
static bfd_boolean
d598 1
a598 1
    return TRUE;
d605 1
a605 1
  return TRUE;
d778 1
a778 1
    abfd->tdata.mmo_data->have_error = TRUE;
d819 1
a819 1
static INLINE bfd_boolean
d825 1
a825 1
  bfd_boolean retval = TRUE;
d864 1
a864 1
    abfd->tdata.mmo_data->have_error = TRUE;
d871 1
a871 1
static INLINE bfd_boolean
d889 1
a889 1
static INLINE bfd_boolean
d896 1
a896 1
      return FALSE;
d905 1
a905 1
static bfd_boolean
d956 1
a956 1
static INLINE bfd_boolean
d967 1
a967 1
      return FALSE;
d1172 1
a1172 1
	  abfd->tdata.mmo_data->have_error = TRUE;
d1198 1
a1198 1
	abfd->tdata.mmo_data->have_error = TRUE;
d1204 1
a1204 1
static bfd_boolean
d1216 1
a1216 1
    return FALSE;
d1220 1
a1220 1
    return FALSE;
d1248 1
a1248 1
      return FALSE;
d1251 1
a1251 1
  return TRUE;
d1256 1
a1256 1
static bfd_boolean
d1363 1
a1363 1
    return FALSE;
d1396 2
a1397 2
	      abfd->tdata.mmo_data->have_error = TRUE;
	      return FALSE;
d1451 1
a1451 1
	    abfd->tdata.mmo_data->have_error = TRUE;
d1589 1
a1589 1
static bfd_boolean
d1595 1
a1595 1
  bfd_boolean error = FALSE;
d2042 1
a2042 1
  error = TRUE;
d2054 1
a2054 1
    error = TRUE;
d2062 1
a2062 1
    error = TRUE;
d2074 1
a2074 1
static bfd_boolean
d2085 1
a2085 1
    return FALSE;
d2089 1
a2089 1
  return TRUE;
d2095 1
a2095 1
static bfd_boolean
d2119 1
a2119 1
	return FALSE;
d2127 1
a2127 1
  return TRUE;
d2194 1
a2194 1
	return FALSE;
d2292 1
a2292 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d2299 1
a2299 1
static bfd_boolean
d2306 1
a2306 1
    return FALSE;
d2310 1
a2310 1
    return FALSE;
d2312 1
a2312 1
  return TRUE;
d2320 1
a2320 1
static bfd_boolean
d2335 1
a2335 1
	return FALSE;
d2407 1
a2407 1
static bfd_boolean
d2441 1
a2441 1
      return FALSE;
d2568 1
a2568 1
	  return
d2579 1
a2579 1
  return TRUE;
d2584 1
a2584 1
static bfd_boolean
d2607 1
a2607 1
	return FALSE;
d2615 1
a2615 1
  return TRUE;
d2620 1
a2620 1
static bfd_boolean
d2673 1
a2673 1
      return FALSE;
d2677 1
a2677 1
  return TRUE;
d2852 1
a2852 1
static bfd_boolean
d2885 1
a2885 1
    return FALSE;
d2925 1
a2925 1
	    return FALSE;
d2988 1
a2988 1
	    return FALSE;
d3029 1
a3029 1
	return FALSE;
d3045 1
a3045 1
    return FALSE;
d3061 1
a3061 1
      return FALSE;
d3074 1
a3074 1
	return FALSE;
d3115 1
a3115 1
	  infop->retval = FALSE;
d3128 1
a3128 1
static bfd_boolean
d3136 1
a3136 1
    return FALSE;
d3139 1
a3139 1
  wsecinfo.retval = TRUE;
d3145 1
a3145 1
    return FALSE;
d3180 1
a3180 1
	  return FALSE;
d3184 1
a3184 1
	return FALSE;
d3188 1
a3188 1
      return FALSE;
@


1.12.12.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003
a337 3
#define mmo_section_data(sec) \
  ((struct mmo_section_data_struct *) (sec)->used_by_bfd)

d1180 3
a1182 2
  if (mmo_section_data (sec)->tail != NULL)
    mmo_section_data (sec)->tail->next = loc;
d1184 2
a1185 2
    mmo_section_data (sec)->head = loc;
  mmo_section_data (sec)->tail = loc;
d1520 2
a1521 1
  struct mmo_section_data_struct *sdatap = mmo_section_data (sec);
d2466 4
a2469 1
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2471 4
a2474 1
    return mmo_write_loc_chunk_list (abfd, mmo_section_data (sec)->head);
d2489 3
a2491 1
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
d2608 10
a2617 5
	return (! abfd->tdata.mmo_data->have_error
		&& mmo_write_loc_chunk_list (abfd,
					     mmo_section_data (sec)->head));
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd, mmo_section_data (sec)->head));
@


1.12.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d404 1
a404 1
static long mmo_canonicalize_symtab
d411 1
a411 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d2203 1
a2203 1
mmo_canonicalize_symtab (abfd, alocation)
d2616 1
a2616 1
     const PTR location;
@


1.11
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d916 6
a921 2
     translation.  */
  while (len >= 4 && bfd_get_32 (abfd, loc) == 0)
d923 9
a931 3
      vma += 4;
      len -= 4;
      loc += 4;
a932 3

  while (len >= 4 && bfd_get_32 (abfd, loc + len - 4) == 0)
    len -= 4;
@


1.10
log
@	* armnetbsd.c: Replace CONST with const.
	* corefile.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf64-mips.c: Likewise.
	* mmo.c: Likewise.
	* ns32knetbsd.c: Likewise.
@
text
@d484 1
a484 1
  if (inited == true)
d849 3
a851 4
      retval
	= (retval == true
	   && abfd->tdata.mmo_data->have_error == false
	   && 4 == bfd_bwrite ((PTR) loc, 4, abfd));
d863 1
a863 1
  if (retval == false)
d884 1
a884 1
  return abfd->tdata.mmo_data->have_error == false;
d943 2
a944 3
  return
    abfd->tdata.mmo_data->have_error == false
    && mmo_write_chunk (abfd, loc, len);
d1162 1
a1162 1
      if (abfd->tdata.mmo_data->have_error == false
d1189 1
a1189 1
      if (abfd->tdata.mmo_data->have_error == false
d1355 1
a1355 1
  if (abfd->tdata.mmo_data->have_error == true)
d1439 1
a1439 1
	  if (abfd->tdata.mmo_data->have_error == false
d1458 1
a1458 1
  return abfd->tdata.mmo_data->have_error == false;
d2061 1
a2061 1
  return error ? false : true;
d2336 1
a2336 3
  return
    abfd->tdata.mmo_data->have_error == false
    && bfd_bwrite (buf, 8, abfd) == 8;
d2441 4
a2444 5
      return
	abfd->tdata.mmo_data->have_error == false
	&& mmo_write_chunk_list (abfd,
				 ((struct mmo_section_data_struct *)
				  (sec->used_by_bfd))->head);
d2561 2
a2562 2
	  return
	    abfd->tdata.mmo_data->have_error == false
d2567 1
a2567 1
	abfd->tdata.mmo_data->have_error == false
d3086 1
a3086 1
  if (infop->retval == false)
d3137 1
a3137 1
  if (wsecinfo.retval == false)
@


1.9
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d263 1
a263 1
    CONST char *name;
d360 1
a360 1
static asection *mmo_make_section PARAMS ((bfd *, CONST char *));
d374 1
a374 1
static CONST bfd_target *mmo_object_p PARAMS ((bfd *));
d377 1
a377 1
static boolean mmo_create_symbol PARAMS ((bfd *, CONST char *, bfd_vma,
d394 1
a394 1
 PARAMS ((bfd *, struct mmo_symbol_trie *, CONST struct mmo_symbol *));
d407 1
a407 1
  PARAMS ((bfd *, CONST bfd_byte *, unsigned int));
d410 1
a410 1
  PARAMS ((bfd *, bfd_vma, CONST bfd_byte *, unsigned int, bfd_vma *));
d420 1
a420 1
static int mmo_sort_mmo_symbols PARAMS ((CONST PTR, CONST PTR));
d449 1
a449 1
     CONST char *secname;
d498 1
a498 1
static CONST bfd_target *
d822 1
a822 1
     CONST bfd_byte *loc;
d910 1
a910 1
     CONST bfd_byte *loc;
d1202 1
a1202 1
     CONST char *symname;
d2138 2
a2139 2
     CONST PTR arg1;
     CONST PTR arg2;
d2141 2
a2142 2
  CONST struct mmo_symbol *sym1 = *(CONST struct mmo_symbol **) arg1;
  CONST struct mmo_symbol *sym2 = *(CONST struct mmo_symbol **) arg2;
d2151 1
a2151 1
  return ((CONST char *) arg1 - (CONST char *) arg2);
d2298 1
a2298 1
  CONST char lop_pre_bfd[] = { LOP, LOP_PRE, 1, 1};
d2622 1
a2622 1
     CONST struct mmo_symbol *symp;
d2624 1
a2624 1
  CONST char *name = symp->name;
d3281 1
a3281 1
CONST bfd_target bfd_mmo_vec =
@


1.8
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3259 1
@


1.8.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d263 1
a263 1
    const char *name;
d360 1
a360 1
static asection *mmo_make_section PARAMS ((bfd *, const char *));
d374 1
a374 1
static const bfd_target *mmo_object_p PARAMS ((bfd *));
d377 1
a377 1
static boolean mmo_create_symbol PARAMS ((bfd *, const char *, bfd_vma,
d394 1
a394 1
 PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
d407 1
a407 1
  PARAMS ((bfd *, const bfd_byte *, unsigned int));
d410 1
a410 1
  PARAMS ((bfd *, bfd_vma, const bfd_byte *, unsigned int, bfd_vma *));
d420 1
a420 1
static int mmo_sort_mmo_symbols PARAMS ((const PTR, const PTR));
d449 1
a449 1
     const char *secname;
d498 1
a498 1
static const bfd_target *
d822 1
a822 1
     const bfd_byte *loc;
d910 1
a910 1
     const bfd_byte *loc;
d1202 1
a1202 1
     const char *symname;
d2138 2
a2139 2
     const PTR arg1;
     const PTR arg2;
d2141 2
a2142 2
  const struct mmo_symbol *sym1 = *(const struct mmo_symbol **) arg1;
  const struct mmo_symbol *sym2 = *(const struct mmo_symbol **) arg2;
d2151 1
a2151 1
  return ((const char *) arg1 - (const char *) arg2);
d2298 1
a2298 1
  const char lop_pre_bfd[] = { LOP, LOP_PRE, 1, 1};
d2622 1
a2622 1
     const struct mmo_symbol *symp;
d2624 1
a2624 1
  const char *name = symp->name;
a3258 1
#define mmo_bfd_discard_group bfd_generic_discard_group
d3280 1
a3280 1
const bfd_target bfd_mmo_vec =
@


1.8.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d484 1
a484 1
  if (inited)
d849 4
a852 3
      retval = (retval
		&& ! abfd->tdata.mmo_data->have_error
		&& 4 == bfd_bwrite ((PTR) loc, 4, abfd));
d864 1
a864 1
  if (! retval)
d885 1
a885 1
  return ! abfd->tdata.mmo_data->have_error;
d917 2
a918 6
     translation.  Only do this if we *don't* have left-over data from a
     previous write or the vma of this chunk is *not* the next address,
     because then data isn't tetrabyte-aligned and we're concatenating to
     that left-over data.  */

  if (abfd->tdata.mmo_data->byte_no == 0 || vma != *last_vmap)
d920 4
a923 6
      while (len >= 4 && bfd_get_32 (abfd, loc) == 0)
	{
	  vma += 4;
	  len -= 4;
	  loc += 4;
	}
d925 2
a926 3
      while (len >= 4 && bfd_get_32 (abfd, loc + len - 4) == 0)
	len -= 4;
    }
d944 3
a946 2
  return (! abfd->tdata.mmo_data->have_error
	  && mmo_write_chunk (abfd, loc, len));
d1164 1
a1164 1
      if (! abfd->tdata.mmo_data->have_error
d1191 1
a1191 1
      if (! abfd->tdata.mmo_data->have_error
d1357 1
a1357 1
  if (abfd->tdata.mmo_data->have_error)
d1441 1
a1441 1
	  if (! abfd->tdata.mmo_data->have_error
d1460 1
a1460 1
  return ! abfd->tdata.mmo_data->have_error;
d2063 1
a2063 1
  return ! error;
d2338 3
a2340 1
  return ! abfd->tdata.mmo_data->have_error && bfd_bwrite (buf, 8, abfd) == 8;
d2445 5
a2449 4
      return (! abfd->tdata.mmo_data->have_error
	      && mmo_write_chunk_list (abfd,
				       ((struct mmo_section_data_struct *)
					(sec->used_by_bfd))->head));
d2566 2
a2567 2
	  return 
	    ! abfd->tdata.mmo_data->have_error
d2572 1
a2572 1
	! abfd->tdata.mmo_data->have_error
d3091 1
a3091 1
  if (! infop->retval)
d3142 1
a3142 1
  if (! wsecinfo.retval)
@


1.7
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d3250 1
@


1.7.4.1
log
@merge from trunk
@
text
@d263 1
a263 1
    const char *name;
d360 1
a360 1
static asection *mmo_make_section PARAMS ((bfd *, const char *));
d374 1
a374 1
static const bfd_target *mmo_object_p PARAMS ((bfd *));
d377 1
a377 1
static boolean mmo_create_symbol PARAMS ((bfd *, const char *, bfd_vma,
d394 1
a394 1
 PARAMS ((bfd *, struct mmo_symbol_trie *, const struct mmo_symbol *));
d407 1
a407 1
  PARAMS ((bfd *, const bfd_byte *, unsigned int));
d410 1
a410 1
  PARAMS ((bfd *, bfd_vma, const bfd_byte *, unsigned int, bfd_vma *));
d420 1
a420 1
static int mmo_sort_mmo_symbols PARAMS ((const PTR, const PTR));
d449 1
a449 1
     const char *secname;
d498 1
a498 1
static const bfd_target *
d822 1
a822 1
     const bfd_byte *loc;
d910 1
a910 1
     const bfd_byte *loc;
d1202 1
a1202 1
     const char *symname;
d2138 2
a2139 2
     const PTR arg1;
     const PTR arg2;
d2141 2
a2142 2
  const struct mmo_symbol *sym1 = *(const struct mmo_symbol **) arg1;
  const struct mmo_symbol *sym2 = *(const struct mmo_symbol **) arg2;
d2151 1
a2151 1
  return ((const char *) arg1 - (const char *) arg2);
d2298 1
a2298 1
  const char lop_pre_bfd[] = { LOP, LOP_PRE, 1, 1};
d2622 1
a2622 1
     const struct mmo_symbol *symp;
d2624 1
a2624 1
  const char *name = symp->name;
a3249 1
#define mmo_bfd_link_just_syms _bfd_generic_link_just_syms
a3257 1
#define mmo_bfd_discard_group bfd_generic_discard_group
d3279 1
a3279 1
const bfd_target bfd_mmo_vec =
@


1.6
log
@Fix compile time failure
@
text
@d3248 1
@


1.5
log
@	* mmo.c: Correct and improve comments.
	(mmo_write_chunk): Store trailing byte in bfd buffer; don't
	zero-pad.  Use input to fill up non-empty bfd buffer.
	(mmo_flush_chunk): New function.
	(mmo_write_loc_chunk): Add parameter last_vmap, all callers
	changed.  Don't emit location specifier if VMA is same as
	*LAST_VMAP after omitting leading zero contents.  Call
	mmo_flush_chunk before emitting location specifier.
	(mmo_write_loc_chunk_list): Call mmo_flush_chunk when finished
	with mmo_write_loc_chunk calls.
	(mmo_internal_write_section): Call mmo_flush_chunk after
	mmo_write_chunk.
	(mmo_write_symbols_and_terminator): Move :Main to first position
	in symbol array.  Add faked one if it does not exist if there are
	other symbols.  Don't add it if there are no symbols at all.  Move
	out test for value of :Main from symbol loop.  Rename table
	fakemain to maintable and variable mainsym to fakemain.
@
text
@d1526 1
a1526 1
    return false;
@


1.4
log
@	Perform on-demand global register allocation from
	R_MMIX_BASE_PLUS_OFFSET relocs.
	* elf64-mmix.c (struct bpo_reloc_section_info, struct
	bpo_reloc_request, struct bpo_greg_section_info): New.
	(mmix_elf_check_common_relocs, mmix_elf_gc_sweep_hook,
	bpo_reloc_request_sort_fn, mmix_elf_relax_section,
	_bfd_mmix_check_all_relocs,
	_bfd_mmix_prepare_linker_allocated_gregs,
	_bfd_mmix_finalize_linker_allocated_gregs): New functions.
	(elf_mmix_howto_table): Correct src_mask for most relocs.
	(mmix_elf_perform_relocation) <case R_MMIX_BASE_PLUS_OFFSET>: New
	case.
	(mmix_final_link_relocate) <case R_MMIX_BASE_PLUS_OFFSET>: New
	case.  Fix typo in comment.  New label do_mmix_reloc.
	(mmix_elf_check_relocs): Abuse bfd_link_info member base_file to
	store first object file with a base-plus-offset reloc.  Call
	mmix_elf_check_common_relocs for the part common with mmo.
	(mmix_elf_final_link): Write out linker-allocated register
	contents section.
	(elf_backend_gc_sweep_hook): Define.
	(bfd_elf64_bfd_relax_section): Define.

	* mmo.c: Don't include <ctype.h>
	(mmo_init): Correct init-once logic.
@
text
@d408 1
d410 1
a410 1
  PARAMS ((bfd *, bfd_vma, CONST bfd_byte *, unsigned int));
d816 2
a817 1
/* Write quoted contents, zero filled.  */
d826 17
a842 1
  bfd_byte buf[4] = {0, 0, 0, 0};
d860 11
a870 3
      memcpy (buf, loc, len);
      if (buf[0] == LOP)
	mmo_write_tetra_raw (abfd, LOP_QUOTE_NEXT);
d872 11
a882 4
      retval
	= (retval == true
	   && abfd->tdata.mmo_data->have_error == false
	   && 4 == bfd_bwrite ((PTR) buf, 4, abfd));
d885 1
a885 1
  return retval;
d899 1
a899 1
  return true;
d902 3
a904 1
/* Write a lop_loc and some contents.  */
d907 1
a907 1
mmo_write_loc_chunk (abfd, vma, loc, len)
d912 1
a913 3
  /* We always write the location as 64 bits; no use saving bytes here.  */
  mmo_write_tetra_raw (abfd, (LOP << 24) | (LOP_LOC << 16) | 2);

d916 1
a916 1
     and address specifiers, else objcopy can't perform a unity
d928 16
a943 1
  mmo_write_octa_raw (abfd, vma);
d956 3
d960 2
a961 1
    if (! mmo_write_loc_chunk (abfd, datap->where, datap->data, datap->size))
d964 1
a964 1
  return true;
d1480 2
d1497 5
a1501 1
	  /* Update the section size.  */
d1563 2
a1564 1
  /* Update the section size.  */
d2511 2
a2512 2
| 0x00000000 - high 64 bits of address
| 0x00000004 - data starts at address 4
d2538 2
a2539 2
| 0x20000000 - high 64 bits of address
| 0x0000001c - low 64 bits of address 0x200000000000001c
d2544 1
a2544 1
	For the latter example, the section contents must not to appear
d2552 1
d2848 1
a2848 2
/* Write symbols, either in mmo format or hidden in a lop_spec 80 section.
   Write the lop_end terminator also.  */
d2855 1
a2855 1
  asymbol *fakemain[2];
d2857 2
a2858 1
  int serno = 2;
d2865 1
a2865 1
  asymbol *mainsym = bfd_make_empty_symbol (abfd);
d2867 6
a2872 6
  mainsym->flags = BSF_GLOBAL;
  mainsym->value = bfd_get_start_address (abfd);
  mainsym->name = MMIX_START_SYMBOL_NAME;
  mainsym->section = bfd_abs_section_ptr;
  fakemain[0] = mainsym;
  fakemain[1] = NULL;
d2879 55
a2933 6
  /* There must always be a ":Main", so we'll add one
     if there are no symbols.  */
  if (count == 0)
    {
      table = fakemain;
      count = 1;
a2934 2
  else
    table = bfd_get_outsymbols (abfd);
d2936 1
a2936 1
  for (i = 0; i < count && table[i] != NULL; i++)
d2981 1
a2981 1
	     there are gaps in the numbering.  Note sure if this can
d2983 1
a2983 29
	  /* Make sure Main has serial number 1; others start at 2.  */
	  if (strcmp (s->name, MMIX_START_SYMBOL_NAME) == 0)
	    {
	      sym.serno = 1;

	      /* Check that the value assigned to :Main is the same as the
		 entry address.  The default linker script asserts this.
		 This is as good a place as any to check this consistency. */
	      if (sym.value != bfd_get_start_address (abfd))
		{
		  /* Arbitrary buffer to hold the printable representation
		     of a vma.  */
		  char vmas_main[40];
		  char vmas_start[40];
		  bfd_vma vma_start = bfd_get_start_address (abfd);

		  sprintf_vma (vmas_main, s->value);
		  sprintf_vma (vmas_start, vma_start);

		  (*_bfd_error_handler)
		    (_("%s: Bad symbol definition: `Main' set to %s rather\
 than the start address %s\n"),
		     bfd_get_filename (abfd), vmas_main, vmas_start);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}
	    }
	  else
	    sym.serno = serno++;
@


1.4.2.1
log
@	* mmo.c: Correct and improve comments.
	(mmo_write_chunk): Store trailing byte in bfd buffer; don't
	zero-pad.  Use input to fill up non-empty bfd buffer.
	(mmo_flush_chunk): New function.
	(mmo_write_loc_chunk): Add parameter last_vmap, all callers
	changed.  Don't emit location specifier if VMA is same as
	*LAST_VMAP after omitting leading zero contents.  Call
	mmo_flush_chunk before emitting location specifier.
	(mmo_write_loc_chunk_list): Call mmo_flush_chunk when finished
	with mmo_write_loc_chunk calls.
	(mmo_internal_write_section): Call mmo_flush_chunk after
	mmo_write_chunk.
	(mmo_write_symbols_and_terminator): Move :Main to first position
	in symbol array.  Add faked one if it does not exist if there are
	other symbols.  Don't add it if there are no symbols at all.  Move
	out test for value of :Main from symbol loop.  Rename table
	fakemain to maintable and variable mainsym to fakemain.
@
text
@a407 1
static boolean mmo_flush_chunk PARAMS ((bfd *));
d409 1
a409 1
  PARAMS ((bfd *, bfd_vma, CONST bfd_byte *, unsigned int, bfd_vma *));
d815 1
a815 2
/* Write quoted contents.  Intended to be called multiple times in
   sequence, followed by a call to mmo_flush_chunk.  */
d824 1
a824 17

  /* Fill up a tetra from bytes remaining from a previous chunk.  */
  if (abfd->tdata.mmo_data->byte_no != 0)
    {
      while (abfd->tdata.mmo_data->byte_no < 4 && len != 0)
	{
	  abfd->tdata.mmo_data->buf[abfd->tdata.mmo_data->byte_no++] = *loc++;
	  len--;
	}

      if (abfd->tdata.mmo_data->byte_no == 4)
	{
	  mmo_write_tetra (abfd,
			   bfd_get_32 (abfd, abfd->tdata.mmo_data->buf));
	  abfd->tdata.mmo_data->byte_no = 0;
	}
    }
d842 8
a849 2
      memcpy (abfd->tdata.mmo_data->buf, loc, len);
      abfd->tdata.mmo_data->byte_no = len;
a851 2
  if (retval == false)
    abfd->tdata.mmo_data->have_error = true;
a854 19
/* Flush remaining bytes, from a previous mmo_write_chunk, zero-padded to
   4 bytes.  */

static INLINE boolean
mmo_flush_chunk (abfd)
     bfd *abfd;
{
  if (abfd->tdata.mmo_data->byte_no != 0)
    {
      memset (abfd->tdata.mmo_data->buf + abfd->tdata.mmo_data->byte_no,
	      0, 4 - abfd->tdata.mmo_data->byte_no);
      mmo_write_tetra (abfd,
		       bfd_get_32 (abfd, abfd->tdata.mmo_data->buf));
      abfd->tdata.mmo_data->byte_no = 0;
    }

  return abfd->tdata.mmo_data->have_error == false;
}

d866 1
a866 1
  return mmo_flush_chunk (abfd);
d869 1
a869 3
/* Write a lop_loc and some contents.  A caller needs to call
   mmo_flush_chunk after calling this function.  The location is only
   output if different than *LAST_VMAP, which is updated after this call.  */
d872 1
a872 1
mmo_write_loc_chunk (abfd, vma, loc, len, last_vmap)
a876 1
     bfd_vma *last_vmap;
d878 3
d883 1
a883 1
     and address specifiers, else objcopy can't always perform an identity
d895 1
a895 16
  /* Only write out the location if it's different than the one the caller
     (supposedly) previously handled, accounting for omitted leading zeros.  */
  if (vma != *last_vmap)
    {
      /* We might be in the middle of a sequence.  */
      mmo_flush_chunk (abfd);

      /* We always write the location as 64 bits; no use saving bytes
         here.  */
      mmo_write_tetra_raw (abfd, (LOP << 24) | (LOP_LOC << 16) | 2);
      mmo_write_octa_raw (abfd, vma);
    }

  /* Update to reflect end of this chunk, with trailing zeros omitted.  */
  *last_vmap = vma + len;

a907 3
  /* Get an address different than the address of the first chunk.  */
  bfd_vma last_vma = datap ? datap->where - 1 : 0;

d909 1
a909 2
    if (! mmo_write_loc_chunk (abfd, datap->where, datap->data, datap->size,
			       &last_vma))
d912 1
a912 1
  return mmo_flush_chunk (abfd);
a1427 2
  /* First search the list to see if we have the requested chunk in one
     piece, or perhaps if we have a suitable chunk with room to fit.  */
d1443 1
a1443 5
	  /* Update the section size.  This happens only if we update the
	     32-bit-aligned chunk size.  Callers that have
	     non-32-bit-aligned sections should do all allocation and
	     size-setting by themselves or at least set the section size
	     after the last allocating call to this function.  */
d1505 1
a1505 2
  /* Update the section size.  This happens only when we add contents and
     re-size as we go.  The section size will then be aligned to 32 bits.  */
d2452 2
a2453 2
| 0x00000000 - high 32 bits of address
| 0x00000004 - low 32 bits: data starts at address 4
d2479 2
a2480 2
| 0x20000000 - high 32 bits of address
| 0x0000001c - low 32 bits of address 0x200000000000001c
d2485 1
a2485 1
	For the latter example, the section contents must not be
a2492 1
      mmo_flush_chunk (abfd);
d2788 2
a2789 1
/* Write symbols in mmo format.  Also write the lop_end terminator.  */
d2796 1
a2796 1
  asymbol *maintable[2];
d2798 1
a2798 2
  asymbol **orig_table = bfd_get_outsymbols (abfd);
  int serno;
d2805 1
a2805 1
  asymbol *fakemain = bfd_make_empty_symbol (abfd);
d2807 6
a2812 6
  fakemain->flags = BSF_GLOBAL;
  fakemain->value = bfd_get_start_address (abfd);
  fakemain->name = MMIX_START_SYMBOL_NAME;
  fakemain->section = bfd_abs_section_ptr;
  maintable[0] = fakemain;
  maintable[1] = NULL;
d2819 6
a2824 55
  /* There must always be a ":Main", so we'll add one if there are no
     symbols.  Make sure we have room for it.  */
  table = bfd_alloc (abfd, (count + 1) * sizeof (asymbol *));
  if (table == NULL)
    return false;

  memcpy (table, orig_table, count * sizeof (asymbol *));

  /* Move :Main (if there is one) to the first position.  This is
     necessary to get the same layout of the trie-tree when linking as
     when objcopying the result as in the objcopy.exp test "simple objcopy
     of executable".  It also automatically takes care of assigning serial
     number 1 to :Main (as is mandatory).  */
  for (i = 0; i < count; i++)
    if (table[i] != NULL
	&& strcmp (table[i]->name, MMIX_START_SYMBOL_NAME) == 0
	&& (table[i]->flags & (BSF_DEBUGGING|BSF_GLOBAL)) == BSF_GLOBAL)
      {
	asymbol *mainsym = table[i];
	memcpy (table + 1, orig_table, i * sizeof (asymbol *));
	table[0] = mainsym;

	/* Check that the value assigned to :Main is the same as the entry
	   address.  The default linker script asserts this.  This is as
	   good a place as any to check this consistency. */
	if ((mainsym->value
	     + mainsym->section->output_section->vma
	     + mainsym->section->output_offset)
	    != bfd_get_start_address (abfd))
	  {
	    /* Arbitrary buffer to hold the printable representation of a
	       vma.  */
	    char vmas_main[40];
	    char vmas_start[40];
	    bfd_vma vma_start = bfd_get_start_address (abfd);

	    sprintf_vma (vmas_main, mainsym->value);
	    sprintf_vma (vmas_start, vma_start);

	    (*_bfd_error_handler)
	      (_("%s: Bad symbol definition: `Main' set to %s rather\
 than the start address %s\n"),
	       bfd_get_filename (abfd), vmas_main, vmas_start);
	    bfd_set_error (bfd_error_bad_value);
	    return false;
	  }
	break;
      }
  if (i == count && count != 0)
    {
      /* When there are symbols, there must be a :Main.  There was no
	 :Main, so we need to add it manually.  */
      memcpy (table + 1, orig_table, count * sizeof (asymbol *));
      table[0] = fakemain;
      count++;
d2826 2
d2829 1
a2829 1
  for (i = 0, serno = 1; i < count && table[i] != NULL; i++)
d2874 1
a2874 1
	     there are gaps in the numbering.  Not sure if this can
d2876 29
a2904 1
	  sym.serno = serno++;
@


1.4.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d1526 1
a1526 1
    return NULL;
@


1.3
log
@	* syms.c (_bfd_generic_make_empty_symbol): New function.
	* libbfd-in.h (_bfd_nosymbols_make_empty_symbol): Define as
	_bfd_generic_make_empty_symbol.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* hppabsd-core.c (hppabsd_core_make_empty_symbol): Delete function.
	(hppabsd_core_get_symtab_upper_bound): Don't define.
	(hppabsd_core_get_symtab): Likewise.
	(hppabsd_core_print_symbol): Likewise.
	(hppabsd_core_get_symbol_info): Likewise.
	(hppabsd_core_bfd_is_local_label_name): Likewise.
	(hppabsd_core_get_lineno): Likewise.
	(hppabsd_core_find_nearest_line): Likewise.
	(hppabsd_core_bfd_make_debug_symbol): Likewise.
	(hppabsd_core_read_minisymbols): Likewise.
	(hppabsd_core_minisymbol_to_symbol): Likewise.
	(hppabsd_core_vec): Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).
	Formatting fixes.
	* hpux-core.c: Similarly.
	* irix-core.c: Similarly.
	* osf-core.c: Similarly.
	* sco5-core.c: Similarly.
	* binary.c (binary_make_empty_symbol): Remove function, define as
	_bfd_generic_make_empty_symbol.
	* ihex.c (ihex_make_empty_symbol): Likewise.
	* mmo.c (mmo_make_empty_symbol): Likewise.
	* ppcboot.c (ppcboot_make_empty_symbol): Likewise.
	* srec.c (srec_make_empty_symbol): Likewise.
	* versados.c (versados_make_empty_symbol): Likewise.
	* vms.c (_bfd_vms_make_empty_symbol): Remove.
	(vms_make_empty_symbol): Define as _bfd_generic_make_empty_symbol.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Call bfd_make_empty_symbol
	rather than _bfd_vms_make_empty_symbol.
	* vms-misc.c (new_symbol): Likewise.
@
text
@a203 1
#include <ctype.h>
d483 3
a485 4
  if (inited == false)
    {
      inited = true;
    }
@


1.2
log
@	* mmo.c: Adjust documentation tags to use texinfo 4 features.
@
text
@d2 1
a2 1
   Copyright 2001
a383 1
static asymbol *mmo_make_empty_symbol PARAMS ((bfd *));
a2189 13
/* Make an empty symbol.  */

static asymbol *
mmo_make_empty_symbol (abfd)
     bfd *abfd;
{
  asymbol *new = (asymbol *) bfd_zalloc (abfd, sizeof (asymbol));

  if (new)
    new->the_bfd = abfd;
  return new;
}

d3160 1
@


1.1
log
@Add MMIX support
@
text
@d30 2
a31 2
	@@emph{mmix} which is available at
	@@emph{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz}
d33 1
a33 1
	assembler and linker called @@emph{mmixal}.  The mmo format has
d38 1
a38 1
	@@emph{http://www-cs-faculty.stanford.edu/~knuth/mmix.html} for more
d71 1
a71 1
	@@emph{http://www-cs-faculty.stanford.edu/~knuth/mmixal-intro.ps.gz},
d1213 1
a1213 1
	@@emph{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz}):
@

