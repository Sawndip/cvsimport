head	1.33;
access;
symbols
	sid-snapshot-20180601:1.33
	sid-snapshot-20180501:1.33
	sid-snapshot-20180401:1.33
	sid-snapshot-20180301:1.33
	sid-snapshot-20180201:1.33
	sid-snapshot-20180101:1.33
	sid-snapshot-20171201:1.33
	sid-snapshot-20171101:1.33
	sid-snapshot-20171001:1.33
	sid-snapshot-20170901:1.33
	sid-snapshot-20170801:1.33
	sid-snapshot-20170701:1.33
	sid-snapshot-20170601:1.33
	sid-snapshot-20170501:1.33
	sid-snapshot-20170401:1.33
	sid-snapshot-20170301:1.33
	sid-snapshot-20170201:1.33
	sid-snapshot-20170101:1.33
	sid-snapshot-20161201:1.33
	sid-snapshot-20161101:1.33
	sid-snapshot-20160901:1.33
	sid-snapshot-20160801:1.33
	sid-snapshot-20160701:1.33
	sid-snapshot-20160601:1.33
	sid-snapshot-20160501:1.33
	sid-snapshot-20160401:1.33
	sid-snapshot-20160301:1.33
	sid-snapshot-20160201:1.33
	sid-snapshot-20160101:1.33
	sid-snapshot-20151201:1.33
	sid-snapshot-20151101:1.33
	sid-snapshot-20151001:1.33
	sid-snapshot-20150901:1.33
	sid-snapshot-20150801:1.33
	sid-snapshot-20150701:1.33
	sid-snapshot-20150601:1.33
	sid-snapshot-20150501:1.33
	sid-snapshot-20150401:1.33
	sid-snapshot-20150301:1.33
	sid-snapshot-20150201:1.33
	sid-snapshot-20150101:1.33
	sid-snapshot-20141201:1.33
	sid-snapshot-20141101:1.33
	sid-snapshot-20141001:1.33
	sid-snapshot-20140901:1.33
	sid-snapshot-20140801:1.33
	sid-snapshot-20140701:1.33
	sid-snapshot-20140601:1.33
	sid-snapshot-20140501:1.33
	sid-snapshot-20140401:1.33
	sid-snapshot-20140301:1.33
	sid-snapshot-20140201:1.33
	sid-snapshot-20140101:1.33
	sid-snapshot-20131201:1.33
	sid-snapshot-20131101:1.33
	sid-snapshot-20131001:1.33
	binutils-2_24-branch:1.33.0.8
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.30
	sid-snapshot-20130901:1.33
	gdb_7_6_1-2013-08-30-release:1.33
	sid-snapshot-20130801:1.33
	sid-snapshot-20130701:1.33
	sid-snapshot-20130601:1.33
	sid-snapshot-20130501:1.33
	gdb_7_6-2013-04-26-release:1.33
	sid-snapshot-20130401:1.33
	binutils-2_23_2:1.33
	gdb_7_6-branch:1.33.0.6
	gdb_7_6-2013-03-12-branchpoint:1.33
	sid-snapshot-20130301:1.33
	sid-snapshot-20130201:1.33
	sid-snapshot-20130101:1.33
	sid-snapshot-20121201:1.33
	gdb_7_5_1-2012-11-29-release:1.33
	binutils-2_23_1:1.33
	sid-snapshot-20121101:1.33
	binutils-2_23:1.33
	sid-snapshot-20121001:1.33
	sid-snapshot-20120901:1.33
	gdb_7_5-2012-08-17-release:1.33
	sid-snapshot-20120801:1.33
	binutils-2_23-branch:1.33.0.4
	binutils-2_23-branchpoint:1.33
	gdb_7_5-branch:1.33.0.2
	gdb_7_5-2012-07-18-branchpoint:1.33
	sid-snapshot-20120701:1.32
	sid-snapshot-20120601:1.32
	sid-snapshot-20120501:1.31
	binutils-2_22_branch:1.30.0.10
	gdb_7_4_1-2012-04-26-release:1.30
	sid-snapshot-20120401:1.31
	sid-snapshot-20120301:1.31
	sid-snapshot-20120201:1.30
	gdb_7_4-2012-01-24-release:1.30
	sid-snapshot-20120101:1.30
	gdb_7_4-branch:1.30.0.8
	gdb_7_4-2011-12-13-branchpoint:1.30
	sid-snapshot-20111201:1.30
	binutils-2_22:1.30
	sid-snapshot-20111101:1.30
	sid-snapshot-20111001:1.30
	binutils-2_22-branch:1.30.0.6
	binutils-2_22-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.30
	sid-snapshot-20110901:1.30
	sid-snapshot-20110801:1.30
	gdb_7_3-2011-07-26-release:1.30
	sid-snapshot-20110701:1.30
	sid-snapshot-20110601:1.30
	sid-snapshot-20110501:1.30
	gdb_7_3-branch:1.30.0.4
	gdb_7_3-2011-04-01-branchpoint:1.30
	sid-snapshot-20110401:1.30
	sid-snapshot-20110301:1.30
	sid-snapshot-20110201:1.30
	sid-snapshot-20110101:1.30
	binutils-2_21:1.30
	sid-snapshot-20101201:1.30
	binutils-2_21-branch:1.30.0.2
	binutils-2_21-branchpoint:1.30
	sid-snapshot-20101101:1.30
	sid-snapshot-20101001:1.30
	binutils-2_20_1:1.29
	gdb_7_2-2010-09-02-release:1.29
	sid-snapshot-20100901:1.30
	sid-snapshot-20100801:1.29
	gdb_7_2-branch:1.29.0.38
	gdb_7_2-2010-07-07-branchpoint:1.29
	sid-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	gdb_7_1-2010-03-18-release:1.29
	sid-snapshot-20100301:1.29
	gdb_7_1-branch:1.29.0.36
	gdb_7_1-2010-02-18-branchpoint:1.29
	sid-snapshot-20100201:1.29
	sid-snapshot-20100101:1.29
	gdb_7_0_1-2009-12-22-release:1.29
	sid-snapshot-20091201:1.29
	sid-snapshot-20091101:1.29
	binutils-2_20:1.29
	gdb_7_0-2009-10-06-release:1.29
	sid-snapshot-20091001:1.29
	gdb_7_0-branch:1.29.0.34
	gdb_7_0-2009-09-16-branchpoint:1.29
	arc-sim-20090309:1.29
	binutils-arc-20081103-branch:1.29.0.32
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.29.0.30
	binutils-2_20-branchpoint:1.29
	sid-snapshot-20090901:1.29
	sid-snapshot-20090801:1.29
	msnyder-checkpoint-072509-branch:1.29.0.28
	msnyder-checkpoint-072509-branchpoint:1.29
	sid-snapshot-20090701:1.29
	dje-cgen-play1-branch:1.29.0.26
	dje-cgen-play1-branchpoint:1.29
	sid-snapshot-20090601:1.29
	sid-snapshot-20090501:1.29
	sid-snapshot-20090401:1.29
	arc-20081103-branch:1.29.0.24
	arc-20081103-branchpoint:1.29
	arc-insight_6_8-branch:1.29.0.22
	arc-insight_6_8-branchpoint:1.29
	insight_6_8-branch:1.29.0.20
	insight_6_8-branchpoint:1.29
	sid-snapshot-20090301:1.29
	binutils-2_19_1:1.29
	sid-snapshot-20090201:1.29
	sid-snapshot-20090101:1.29
	reverse-20081226-branch:1.29.0.18
	reverse-20081226-branchpoint:1.29
	sid-snapshot-20081201:1.29
	multiprocess-20081120-branch:1.29.0.16
	multiprocess-20081120-branchpoint:1.29
	sid-snapshot-20081101:1.29
	binutils-2_19:1.29
	sid-snapshot-20081001:1.29
	reverse-20080930-branch:1.29.0.14
	reverse-20080930-branchpoint:1.29
	binutils-2_19-branch:1.29.0.12
	binutils-2_19-branchpoint:1.29
	sid-snapshot-20080901:1.29
	sid-snapshot-20080801:1.29
	reverse-20080717-branch:1.29.0.10
	reverse-20080717-branchpoint:1.29
	sid-snapshot-20080701:1.29
	msnyder-reverse-20080609-branch:1.29.0.8
	msnyder-reverse-20080609-branchpoint:1.29
	drow-reverse-20070409-branch:1.27.0.2
	drow-reverse-20070409-branchpoint:1.27
	sid-snapshot-20080601:1.29
	sid-snapshot-20080501:1.29
	sid-snapshot-20080403:1.29
	sid-snapshot-20080401:1.29
	gdb_6_8-2008-03-27-release:1.29
	sid-snapshot-20080301:1.29
	gdb_6_8-branch:1.29.0.6
	gdb_6_8-2008-02-26-branchpoint:1.29
	sid-snapshot-20080201:1.29
	sid-snapshot-20080101:1.29
	sid-snapshot-20071201:1.29
	sid-snapshot-20071101:1.29
	gdb_6_7_1-2007-10-29-release:1.29
	gdb_6_7-2007-10-10-release:1.29
	sid-snapshot-20071001:1.29
	gdb_6_7-branch:1.29.0.4
	gdb_6_7-2007-09-07-branchpoint:1.29
	binutils-2_18:1.29
	binutils-2_18-branch:1.29.0.2
	binutils-2_18-branchpoint:1.29
	insight_6_6-20070208-release:1.26
	binutils-csl-coldfire-4_1-32:1.24
	binutils-csl-sourcerygxx-4_1-32:1.24
	gdb_6_6-2006-12-18-release:1.26
	binutils-csl-innovasic-fido-3_4_4-33:1.24
	binutils-csl-sourcerygxx-3_4_4-32:1.18
	binutils-csl-coldfire-4_1-30:1.24
	binutils-csl-sourcerygxx-4_1-30:1.24
	binutils-csl-coldfire-4_1-28:1.24
	binutils-csl-sourcerygxx-4_1-29:1.24
	binutils-csl-sourcerygxx-4_1-28:1.24
	gdb_6_6-branch:1.26.0.2
	gdb_6_6-2006-11-15-branchpoint:1.26
	binutils-csl-arm-2006q3-27:1.24
	binutils-csl-sourcerygxx-4_1-27:1.24
	binutils-csl-arm-2006q3-26:1.24
	binutils-csl-sourcerygxx-4_1-26:1.24
	binutils-csl-sourcerygxx-4_1-25:1.24
	binutils-csl-sourcerygxx-4_1-24:1.24
	binutils-csl-sourcerygxx-4_1-23:1.24
	insight_6_5-20061003-release:1.24
	gdb-csl-symbian-6_4_50_20060226-12:1.24
	binutils-csl-sourcerygxx-4_1-21:1.24
	binutils-csl-arm-2006q3-21:1.24
	binutils-csl-sourcerygxx-4_1-22:1.24
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.24
	binutils-csl-sourcerygxx-4_1-20:1.24
	binutils-csl-arm-2006q3-19:1.24
	binutils-csl-sourcerygxx-4_1-19:1.24
	binutils-csl-sourcerygxx-4_1-18:1.24
	binutils-csl-renesas-4_1-9:1.24
	gdb-csl-sourcerygxx-3_4_4-25:1.24
	binutils-csl-sourcerygxx-3_4_4-25:1.18
	nickrob-async-20060828-mergepoint:1.24
	gdb-csl-symbian-6_4_50_20060226-11:1.24
	binutils-csl-renesas-4_1-8:1.24
	binutils-csl-renesas-4_1-7:1.24
	binutils-csl-renesas-4_1-6:1.24
	gdb-csl-sourcerygxx-4_1-17:1.24
	binutils-csl-sourcerygxx-4_1-17:1.24
	gdb-csl-20060226-branch-local-2:1.24
	gdb-csl-sourcerygxx-4_1-14:1.24
	binutils-csl-sourcerygxx-4_1-14:1.24
	binutils-csl-sourcerygxx-4_1-15:1.24
	gdb-csl-sourcerygxx-4_1-13:1.24
	binutils-csl-sourcerygxx-4_1-13:1.24
	binutils-2_17:1.24
	gdb-csl-sourcerygxx-4_1-12:1.24
	binutils-csl-sourcerygxx-4_1-12:1.24
	gdb-csl-sourcerygxx-3_4_4-21:1.24
	binutils-csl-sourcerygxx-3_4_4-21:1.24
	gdb_6_5-20060621-release:1.24
	binutils-csl-wrs-linux-3_4_4-24:1.18
	binutils-csl-wrs-linux-3_4_4-23:1.18
	gdb-csl-sourcerygxx-4_1-9:1.24
	binutils-csl-sourcerygxx-4_1-9:1.24
	gdb-csl-sourcerygxx-4_1-8:1.24
	binutils-csl-sourcerygxx-4_1-8:1.24
	gdb-csl-sourcerygxx-4_1-7:1.24
	binutils-csl-sourcerygxx-4_1-7:1.24
	gdb-csl-arm-2006q1-6:1.24
	binutils-csl-arm-2006q1-6:1.24
	gdb-csl-sourcerygxx-4_1-6:1.24
	binutils-csl-sourcerygxx-4_1-6:1.24
	binutils-csl-wrs-linux-3_4_4-22:1.18
	gdb-csl-symbian-6_4_50_20060226-10:1.24
	gdb-csl-symbian-6_4_50_20060226-9:1.24
	gdb-csl-symbian-6_4_50_20060226-8:1.24
	gdb-csl-coldfire-4_1-11:1.24
	binutils-csl-coldfire-4_1-11:1.24
	gdb-csl-sourcerygxx-3_4_4-19:1.24
	binutils-csl-sourcerygxx-3_4_4-19:1.24
	gdb-csl-coldfire-4_1-10:1.24
	gdb_6_5-branch:1.24.0.28
	gdb_6_5-2006-05-14-branchpoint:1.24
	binutils-csl-coldfire-4_1-10:1.24
	gdb-csl-sourcerygxx-4_1-5:1.24
	binutils-csl-sourcerygxx-4_1-5:1.24
	nickrob-async-20060513-branch:1.24.0.26
	nickrob-async-20060513-branchpoint:1.24
	gdb-csl-sourcerygxx-4_1-4:1.24
	binutils-csl-sourcerygxx-4_1-4:1.24
	msnyder-reverse-20060502-branch:1.24.0.24
	msnyder-reverse-20060502-branchpoint:1.24
	binutils-csl-wrs-linux-3_4_4-21:1.18
	gdb-csl-morpho-4_1-4:1.24
	binutils-csl-morpho-4_1-4:1.24
	gdb-csl-sourcerygxx-3_4_4-17:1.24
	binutils-csl-sourcerygxx-3_4_4-17:1.24
	binutils-csl-wrs-linux-3_4_4-20:1.18
	readline_5_1-import-branch:1.24.0.22
	readline_5_1-import-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.24
	binutils-2_17-branch:1.24.0.20
	binutils-2_17-branchpoint:1.24
	gdb-csl-symbian-20060226-branch:1.24.0.18
	gdb-csl-symbian-20060226-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.24
	msnyder-reverse-20060331-branch:1.24.0.16
	msnyder-reverse-20060331-branchpoint:1.24
	binutils-csl-2_17-branch:1.24.0.14
	binutils-csl-2_17-branchpoint:1.24
	gdb-csl-available-20060303-branch:1.24.0.12
	gdb-csl-available-20060303-branchpoint:1.24
	gdb-csl-20060226-branch:1.24.0.10
	gdb-csl-20060226-branchpoint:1.24
	gdb_6_4-20051202-release:1.24
	msnyder-fork-checkpoint-branch:1.24.0.8
	msnyder-fork-checkpoint-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.24.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.24
	gdb_6_4-branch:1.24.0.4
	gdb_6_4-2005-11-01-branchpoint:1.24
	gdb-csl-arm-20051020-branch:1.24.0.2
	gdb-csl-arm-20051020-branchpoint:1.24
	binutils-csl-gxxpro-3_4-branch:1.18.0.14
	binutils-csl-gxxpro-3_4-branchpoint:1.18
	binutils-2_16_1:1.18
	msnyder-tracepoint-checkpoint-branch:1.21.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.21
	gdb-csl-arm-20050325-2005-q1b:1.18
	binutils-csl-arm-2005q1b:1.18
	binutils-2_16:1.18
	gdb-csl-arm-20050325-2005-q1a:1.18
	binutils-csl-arm-2005q1a:1.18
	csl-arm-20050325-branch:1.18.0.12
	csl-arm-20050325-branchpoint:1.18
	binutils-csl-arm-2005q1-branch:1.18.0.10
	binutils-csl-arm-2005q1-branchpoint:1.18
	binutils-2_16-branch:1.18.0.8
	binutils-2_16-branchpoint:1.18
	csl-arm-2004-q3d:1.18
	gdb_6_3-20041109-release:1.18
	gdb_6_3-branch:1.18.0.4
	gdb_6_3-20041019-branchpoint:1.18
	csl-arm-2004-q3:1.18
	drow_intercu-merge-20040921:1.18
	drow_intercu-merge-20040915:1.18
	jimb-gdb_6_2-e500-branch:1.18.0.6
	jimb-gdb_6_2-e500-branchpoint:1.18
	gdb_6_2-20040730-release:1.18
	gdb_6_2-branch:1.18.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.18
	gdb_6_1_1-20040616-release:1.17
	binutils-2_15:1.17
	binutils-2_15-branchpoint:1.17
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.17
	gdb_6_1-2004-04-05-release:1.17
	drow_intercu-merge-20040402:1.17
	drow_intercu-merge-20040327:1.17
	ezannoni_pie-20040323-branch:1.17.0.14
	ezannoni_pie-20040323-branchpoint:1.17
	cagney_tramp-20040321-mergepoint:1.17
	cagney_tramp-20040309-branch:1.17.0.12
	cagney_tramp-20040309-branchpoint:1.17
	gdb_6_1-branch:1.17.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.17
	drow_intercu-20040221-branch:1.17.0.8
	drow_intercu-20040221-branchpoint:1.17
	binutils-2_15-branch:1.17.0.6
	cagney_bfdfile-20040213-branch:1.17.0.4
	cagney_bfdfile-20040213-branchpoint:1.17
	drow-cplus-merge-20040208:1.17
	carlton_dictionary-20040126-merge:1.17
	cagney_bigcore-20040122-branch:1.17.0.2
	cagney_bigcore-20040122-branchpoint:1.17
	drow-cplus-merge-20040113:1.17
	csl-arm-2003-q4:1.17
	drow-cplus-merge-20031224:1.17
	drow-cplus-merge-20031220:1.17
	carlton_dictionary-20031215-merge:1.17
	drow-cplus-merge-20031214:1.17
	carlton-dictionary-20031111-merge:1.17
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.15.0.4
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.2
	cagney_x86i386-20030821-branch:1.14.0.18
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.16
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.14
	cagney_convert-20030606-branch:1.14.0.12
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.10
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.6
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	binutils-2_14-branch:1.14.0.2
	binutils-2_14-branchpoint:1.14
	kettenis_i386newframe-20030419-branch:1.13.0.20
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.18
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.16
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.14
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.12
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.10
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.8
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.6
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.13
	interps-20030202-branch:1.13.0.4
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.2
	cagney-unwind-20030108-branchpoint:1.13
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.9
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.12
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.10
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.18
	kseitz_interps-20020528-branch:1.3.0.16
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.14
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.12
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.10
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.8
	binutils-2_12-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2.2.1
	binutils-2_11_1:1.2.2.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.2
	insight-precleanup-2001-01-01:1.2
	binutils_latest_snapshot:1.33;
locks; strict;
comment	@ * @;


1.33
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2012.05.15.12.55.34;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2012.02.13.02.29.51;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.25.14.53.42;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.08.00.26.45;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.07.13.22.49;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.04.15.53.16;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.24.04.46.20;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.04.21.02.53;	author ciceron;	state Exp;
branches
	1.17.8.1;
next	1.16;

1.16
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.06.20.55.50;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.21.13.22.14;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.08.03.34.38;	author amodra;	state Exp;
branches
	1.13.20.1;
next	1.12;

1.12
date	2002.12.01.12.18.29;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.17.02.59.15;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.22.05.41.53;	author amodra;	state Exp;
branches
	1.8.10.1
	1.8.12.1;
next	1.7;

1.7
date	2002.08.19.06.38.43;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.13.21.15.47;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.13.20.56.59;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.13.20.43.01;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.08.21.03.59;	author nickc;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	2000.12.06.18.59.48;	author kazu;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	;

1.17.8.1
date	2004.09.16.17.00.24;	author drow;	state Exp;
branches;
next	;

1.13.20.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	;

1.8.10.1
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2002.12.23.19.37.42;	author carlton;	state Exp;
branches;
next	1.8.10.3;

1.8.10.3
date	2003.05.01.00.46.40;	author carlton;	state Exp;
branches;
next	1.8.10.4;

1.8.10.4
date	2003.09.17.21.27.51;	author carlton;	state Exp;
branches;
next	1.8.10.5;

1.8.10.5
date	2003.11.11.23.50.17;	author carlton;	state Exp;
branches;
next	;

1.8.12.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.2.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.33
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@/* Motorola 68HC12-specific support for 32-bit ELF
   Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2010, 2012
   Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@nerim.fr)
   (Heavily copied from the D10V port by Martin Hunt (hunt@@cygnus.com))

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf32-m68hc1x.h"
#include "elf/m68hc11.h"
#include "opcode/m68hc11.h"

/* Relocation functions.  */
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void m68hc11_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);

/* Trampoline generation.  */


/* Use REL instead of RELA to save space */
#define USE_REL	1

/* The 68HC12 microcontroler has a memory bank switching system
   with a 16Kb window in the 64Kb address space.  The extended memory
   is mapped in the 16Kb window (at 0x8000).  The page register controls
   which 16Kb bank is mapped.  The call/rtc instructions take care of
   bank switching in function calls/returns.

   For GNU Binutils to work, we consider there is a physical memory
   at 0..0x0ffff and a kind of virtual memory above that.  Symbols
   in virtual memory have their addresses treated in a special way
   when disassembling and when linking.

   For the linker to work properly, we must always relocate the virtual
   memory as if it is mapped at 0x8000.  When a 16-bit relocation is
   made in the virtual memory, we check that it does not cross the
   memory bank where it is used.  This would involve a page change
   which would be wrong.  The 24-bit relocation is for that and it
   treats the address as a physical address + page number.


					Banked
					Address Space
                                        |               |       Page n
					+---------------+ 0x1010000
                                        |               |
                                        | jsr _foo      |
                                        | ..            |       Page 3
                                        | _foo:         |
					+---------------+ 0x100C000
					|	        |
                                        | call _bar     |
					| ..	        |	Page 2
					| _bar:	        |
					+---------------+ 0x1008000
				/------>|	        |
				|	| call _foo     |	Page 1
				|	|       	|
				|	+---------------+ 0x1004000
      Physical			|	|	        |
      Address Space		|	|	        |	Page 0
				|	|	        |
    +-----------+ 0x00FFFF	|	+---------------+ 0x1000000
    |		|		|
    | call _foo	|		|
    |		|		|
    +-----------+ 0x00BFFF -+---/
    |		|           |
    |		|	    |
    |		| 16K	    |
    |		|	    |
    +-----------+ 0x008000 -+
    |		|
    |		|
    =		=
    |		|
    |		|
    +-----------+ 0000


   The 'call _foo' must be relocated with page 3 and 16-bit address
   mapped at 0x8000.

   The 3-bit and 16-bit PC rel relocation is only used by 68HC12.  */
static reloc_howto_type elf_m68hc11_howto_table[] = {
  /* This reloc does nothing.  */
  HOWTO (R_M68HC11_NONE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_NONE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation */
  HOWTO (R_M68HC11_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation (upper address) */
  HOWTO (R_M68HC11_HI8,		/* type */
	 8,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_HI8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation (upper address) */
  HOWTO (R_M68HC11_LO8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_LO8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit PC-rel relocation */
  HOWTO (R_M68HC11_PCREL_8,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_PCREL_8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* A 16 bit absolute relocation */
  HOWTO (R_M68HC11_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont /*bitfield */ ,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  This one is never used for the
     code relocation.  It's used by gas for -gstabs generation.  */
  HOWTO (R_M68HC11_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 3 bit absolute relocation */
  HOWTO (R_M68HC11_3B,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 3,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_4B",	/* name */
	 FALSE,			/* partial_inplace */
	 0x003,			/* src_mask */
	 0x003,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit PC-rel relocation */
  HOWTO (R_M68HC11_PCREL_16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_PCREL_16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M68HC11_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_M68HC11_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M68HC11_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_M68HC11_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 24 bit relocation */
  HOWTO (R_M68HC11_24,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_special_reloc,	/* special_function */
	 "R_M68HC12_24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit low relocation */
  HOWTO (R_M68HC11_LO16,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_special_reloc,/* special_function */
	 "R_M68HC12_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A page relocation */
  HOWTO (R_M68HC11_PAGE,        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_special_reloc,/* special_function */
	 "R_M68HC12_PAGE",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (14),

  /* A 16 bit absolute relocation.  */
  HOWTO (R_M68HC12_16B,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_16B",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 9 bit PC-rel relocation.  */
  HOWTO (R_M68HC12_PCREL_9,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize (result is >>1) */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_PCREL_9",	/* name */
	 TRUE,			/* partial_inplace */
	 0xfe00,		/* src_mask */
	 0x01ff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* A 10 bit PC-rel relocation.  */
  HOWTO (R_M68HC12_PCREL_10,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize (result is >>1) */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_PCREL_10",	/* name */
	 TRUE,			/* partial_inplace */
	 0xfc00,		/* src_mask */
	 0x03ff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* A 8 bit absolute relocation (upper address).  */
  HOWTO (R_M68HC12_HI8XG,		/* type */
	 8,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_HI8XG",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation (lower address).  */
  HOWTO (R_M68HC12_LO8XG,		/* type */
	 8,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC12_LO8XG",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Mark beginning of a jump instruction (any form).  */
  HOWTO (R_M68HC11_RL_JUMP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC12_RL_JUMP",	/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* Mark beginning of Gcc relaxation group instruction.  */
  HOWTO (R_M68HC11_RL_GROUP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC12_RL_GROUP",	/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),                 /* pcrel_offset */
};

/* Map BFD reloc types to M68HC11 ELF reloc types.  */

struct m68hc11_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct m68hc11_reloc_map m68hc11_reloc_map[] =
{
  {BFD_RELOC_NONE, R_M68HC11_NONE,},
  {BFD_RELOC_8, R_M68HC11_8},
  {BFD_RELOC_M68HC11_HI8, R_M68HC11_HI8},
  {BFD_RELOC_M68HC11_LO8, R_M68HC11_LO8},
  {BFD_RELOC_8_PCREL, R_M68HC11_PCREL_8},
  {BFD_RELOC_16_PCREL, R_M68HC11_PCREL_16},
  {BFD_RELOC_16, R_M68HC11_16},
  {BFD_RELOC_32, R_M68HC11_32},
  {BFD_RELOC_M68HC11_3B, R_M68HC11_3B},

  {BFD_RELOC_VTABLE_INHERIT, R_M68HC11_GNU_VTINHERIT},
  {BFD_RELOC_VTABLE_ENTRY, R_M68HC11_GNU_VTENTRY},

  {BFD_RELOC_M68HC11_LO16, R_M68HC11_LO16},
  {BFD_RELOC_M68HC11_PAGE, R_M68HC11_PAGE},
  {BFD_RELOC_M68HC11_24, R_M68HC11_24},

  {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
  {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},

  {BFD_RELOC_M68HC12_16B, R_M68HC12_16B},

  {BFD_RELOC_M68HC12_9_PCREL, R_M68HC12_PCREL_9},
  {BFD_RELOC_M68HC12_10_PCREL, R_M68HC12_PCREL_10},
  {BFD_RELOC_M68HC12_HI8XG, R_M68HC12_HI8XG},
  {BFD_RELOC_M68HC12_LO8XG, R_M68HC12_LO8XG},
};

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (m68hc11_reloc_map) / sizeof (struct m68hc11_reloc_map);
       i++)
    {
      if (m68hc11_reloc_map[i].bfd_reloc_val == code)
	return &elf_m68hc11_howto_table[m68hc11_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (elf_m68hc11_howto_table)
	    / sizeof (elf_m68hc11_howto_table[0]));
       i++)
    if (elf_m68hc11_howto_table[i].name != NULL
	&& strcasecmp (elf_m68hc11_howto_table[i].name, r_name) == 0)
      return &elf_m68hc11_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an M68HC11 ELF reloc.  */

static void
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_M68HC11_max);
  cache_ptr->howto = &elf_m68hc11_howto_table[r_type];
}


/* Far trampoline generation.  */

/* Build a 68HC12 trampoline stub.  */
static bfd_boolean
m68hc12_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->size;
  stub_sec->size += 7;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     ldy #%addr(symbol)
     call %page(symbol), __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* ldy #%page(sym) */
  bfd_put_8 (stub_bfd, 0xCD, loc);
  bfd_put_16 (stub_bfd, phys_addr, loc + 1);
  loc += 3;

  /* call %page(sym), __trampoline  */
  bfd_put_8 (stub_bfd, 0x4a, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 3);

  return TRUE;
}

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
m68hc12_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->size += 7;
  return TRUE;
}

/* Create a 68HC12 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc12_elf_bfd_link_hash_table_create (bfd *abfd)
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc12_elf_size_one_stub;
  ret->build_one_stub = m68hc12_elf_build_one_stub;

  return &ret->root.root;
}

static bfd_boolean
m68hc12_elf_set_mach_from_flags (bfd *abfd)
{
  flagword flags = elf_elfheader (abfd)->e_flags;

  switch (flags & EF_M68HC11_MACH_MASK)
    {
    case EF_M68HC12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812);
      break;
    case EF_M68HCS12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812s);
      break;
    case EF_M68HC11_GENERIC:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12,
                                 bfd_mach_m6812_default);
      break;
    default:
      return FALSE;
    }
  return TRUE;
}

/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC12.
   - The .vectors is the section that represents the interrupt
     vectors.  */
static const struct bfd_elf_special_section elf32_m68hc12_special_sections[] =
{
  { STRING_COMMA_LEN (".eeprom"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".page0"),    0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".softregs"), 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".vectors"),  0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,                       0,  0, 0,            0 }
};

#define ELF_ARCH		bfd_arch_m68hc12
#define ELF_TARGET_ID		M68HC11_ELF_DATA
#define ELF_MACHINE_CODE	EM_68HC12
#define ELF_MAXPAGESIZE		0x1000

#define TARGET_BIG_SYM          bfd_elf32_m68hc12_vec
#define TARGET_BIG_NAME		"elf32-m68hc12"

#define elf_info_to_howto	0
#define elf_info_to_howto_rel	m68hc11_info_to_howto_rel
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
#define elf_backend_object_p		m68hc12_elf_set_mach_from_flags
#define elf_backend_final_write_processing	0
#define elf_backend_can_gc_sections		1
#define elf_backend_special_sections elf32_m68hc12_special_sections
#define elf_backend_post_process_headers     elf32_m68hc11_post_process_headers
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook
#define elf_backend_merge_symbol_attribute elf32_m68hc11_merge_symbol_attribute

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc12_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_m68hc11_elf_print_private_bfd_data

#include "elf32-target.h"
@


1.32
log
@	* config/tc-m68hc11.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Tweak target flags to match other tools. (i.e. -m m68hc11).
	* doc/as.texinfo: Mention new options.
	* doc/c-m68hc11.texi: Document new options.
	* NEWS: Mention new support.

	* archures.c: Add bfd_arch_m9s12x and bfd_arch_m9s12xg.
	* config.bfd: Likewise.
	* cpu-m9s12x.c: New.
	* cpu-m9s12xg.c: New.
	* elf32-m68hc12.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Fix carry bug in IMM16 (IMM8 low/high) relocate.
	* Makefile.am (ALL_MACHINES): Add cpu-m9s12x and cpu-m9s12xg.
	(ALL_MACHINES_CFILES): Likewise.
	* reloc.c: Add S12X relocs.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* gas/m68hc11/insns9s12x.s: New
	* gas/m68hc11/insns9s12x.d: New
	* gas/m68hc11/hexprefix.s: New
	* gas/m68hc11/hexprefix.d: New
	* gas/m68hc11/9s12x-exg-sex-tfr.s: New
	* gas/m68hc11/9s12x-exg-sex-tfr.d: New
	* gas/m68hc11/insns9s12xg.s: New
	* gas/m68hc11/insns9s12xg.d: New
	* gas/m68hc11/9s12x-mov.s: New
	* gas/m68hc11/9s12x-mov.d: New
	* gas/m68hc11/m68hc11.exp: Updated
	* gas/m68hc11/*.d: Brought in line with changed objdump output.
	* gas/all/gas.exp: XFAIL all hc11/12 targets for redef2,3.
	* gas/elf/elf.exp: XFAIL all hc11/12 targets for redef.
	* gas/elf/dwarf2-1.d: Skip for hc11/12 targets.
	* gas/elf/dwarf2-2.d: Likewise.

	* ld-m68hc11/xgate-link.s: New.
	* ld-m68hc11/xgate-link.d: New.
	* ld-m68hc11/xgate-offset.s: New.
	* ld-m68hc11/xgate-offset.d: New.
	* ld-m68hc11/xgate1.s: New.
	* ld-m68hc11/xgate1.d: New.
	* ld-m68hc11/xgate2.s: New.
	* ld-m68hc11/m68hc11.exp: Updated.
	* ld-m68hc11/*.d: Brought in line with changed objdump output.
	* ld-gc/gc.exp: Update CFLAGS for m68hc11.
	* ld-plugin/plugin.exp: Likewise.
	* ld-srec/srec.exp: XFAIL for m68hc11 and m68hc12.

	* configure.in: Add S12X and XGATE co-processor support to m68hc11
	target.
	* disassemble.c: Likewise.
	* configure: Regenerate.
	* m68hc11-dis.c: Make objdump output more consistent, use hex
	instead of decimal and use 0x prefix for hex.
	* m68hc11-opc.c: Add S12X and XGATE opcodes.
	* dis-asm.h (print_insn_m9s12x): Prototype.
	(print_insn_m9s12xg): Prototype.

	* m68hc11.h (R_M68HC12_16B, R_M68HC12_PCREL_9, R_M68HC12_PCREL_10)
	R_M68HC12_HI8XG, R_M68HC12_LO8XG): New relocations.
	(E_M68HC11_XGATE_RAMOFFSET): Define.

	* m68hc11.h: Add XGate definitions.
	(struct m68hc11_opcode): Add xg_mask field.
@
text
@a39 6
static bfd_boolean m68hc12_elf_size_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static bfd_boolean m68hc12_elf_build_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static struct bfd_link_hash_table* m68hc12_elf_bfd_link_hash_table_create
  (bfd*);
a40 1
static bfd_boolean m68hc12_elf_set_mach_from_flags PARAMS ((bfd *));
@


1.31
log
@	* elf32-m68hc1x.c (elf32_m68hc11_merge_symbol_attribute): New function.
	* elf32-m68hc1x.h (elf32_m68hc11_merge_symbol_attribute): Declare.
	* elf32-m68hc11.c (elf_backend_merge_symbol_attribute): Define.
	* elf32-m68hc12.c (elf_backend_merge_symbol_attribute): Define.
@
text
@d327 75
a401 5
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
d442 2
a443 1
static const struct m68hc11_reloc_map m68hc11_reloc_map[] = {
d463 7
@


1.30
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007
d584 1
@


1.29
log
@Switch sources over to use the GPL version 3
@
text
@d567 1
@


1.28
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.27
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.26
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003, 2004, 2005, 2006
d410 17
@


1.25
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.
a556 2
#define elf_backend_gc_mark_hook     elf32_m68hc11_gc_mark_hook
#define elf_backend_gc_sweep_hook    elf32_m68hc11_gc_sweep_hook
@


1.24
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d540 5
a544 5
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
@


1.23
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a545 18

static const struct bfd_elf_special_section *
elf32_m68hc12_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf32_m68hc12_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}
d563 1
a563 1
#define elf_backend_get_sec_type_attr elf32_m68hc12_get_sec_type_attr
@


1.22
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d538 1
a538 1
static struct bfd_elf_special_section const elf32_m68hc12_special_sections[] =
d550 1
a550 1
  const struct bfd_elf_special_section const *ssect;
@


1.21
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d538 1
a538 2
static struct bfd_elf_special_section const
  m68hc12_special_sections_e[] =
d541 1
a541 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  m68hc12_special_sections_s[]=
{
d543 1
d547 2
a548 2
static struct bfd_elf_special_section const
  m68hc12_special_sections_p[]=
d550 1
a550 3
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,        0, 0, 0,            0 }
};
d552 9
a560 6
static struct bfd_elf_special_section const
  m68hc12_special_sections_v[]=
{
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
};
d562 2
a563 31
static struct bfd_elf_special_section const *
  elf32_m68hc12_special_sections[27] =
{
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  m68hc12_special_sections_e,	/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  m68hc12_special_sections_p,	/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  m68hc12_special_sections_s,	/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  m68hc12_special_sections_v,	/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d581 1
a581 1
#define elf_backend_special_sections elf32_m68hc12_special_sections
@


1.20
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d538 2
a539 1
static struct bfd_elf_special_section const elf32_m68hc12_special_sections[]=
d542 6
d549 6
d556 6
d565 32
@


1.19
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.18
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d20 1
a20 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.17
log
@	* elf32-m68hc1x.c: Update to ISO C90; replace PTR with void*.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
d446 2
a447 2
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 7;
d489 1
a489 1
  stub_entry->stub_sec->_raw_size += 7;
@


1.17.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d446 2
a447 2
  stub_entry->stub_offset = stub_sec->size;
  stub_sec->size += 7;
d489 1
a489 1
  stub_entry->stub_sec->size += 7;
@


1.16
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d33 1
a33 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d35 1
a35 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d39 1
a39 1
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
d41 1
a41 1
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
d43 1
a43 1
  PARAMS((bfd*));
d393 2
a394 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d412 2
a413 4
m68hc11_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d427 1
a427 3
m68hc12_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d481 2
a482 3
m68hc12_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d496 1
a496 2
m68hc12_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
d511 1
a511 2
m68hc12_elf_set_mach_from_flags (abfd)
     bfd *abfd;
@


1.15
log
@	* elf32-m68hc12.c (elf32_m68hc12_special_sections): New for hc11.
	(elf_backend_special_sections): Define.a

	PR savannah/4950:
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): The .vectors
	section is read-only.
@
text
@d548 5
a552 10
  { ".eeprom",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".softregs",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { ".page0",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".vectors",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.14
log
@	* elf32-m68hc1x.c: New file (from elf32-m68hc11.c and elf32-m68hc12.c)
	(m68hc11_elf_hash_table_create): New function.
	(elf32_m68hc11_link_hash_table_free): New function.
	(stub_hash_newfunc): New function.
	(m68hc11_add_stub): New function.
	(elf32_m68hc11_add_symbol_hook): New function.
	(elf32_m68hc11_setup_section_lists): New function.
	(elf32_m68hc11_next_input_section): New function.
	(elf32_m68hc11_size_stubs): New function.
	(elf32_m68hc11_build_stubs): New function.
	(m68hc11_get_relocation_value): New function.
	(elf32_m68hc11_relocate_section): Call the above to redirect
	some relocations to the trampoline code.
	(m68hc11_elf_export_one_stub): New function.
	(m68hc11_elf_set_symbol): New function.
	(elf32_m68hc11_build_stubs): Call it via bfd_hash_traverse.
	(m68hc11_elf_get_bank_parameters): Get parameters only when the info
	is not yet initialized.

	* elf32-m68hc1x.h: New file (from elf32-m68hc11.c and elf32-m68hc12.c)
	(elf32_m68hc11_stub_hash_entry): New struct.
	(m68hc11_page_info): Add trampoline handler address.
	(m68hc11_elf_link_hash_table): Add stubs generation members.
	(elf32_m68hc11_add_symbol_hook): Declare.
	(elf32_m68hc11_setup_section_lists): Declare.
	(elf32_m68hc11_size_stubs): Declare.
	(elf32_m68hc11_build_stubs): Declare.

	* elf32-m68hc11.c (m68hc11_elf_ignore_reloc): Move to elf32-m68hc1x.c.
	(elf32_m68hc11_gc_mark_hook, elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf32_m68hc11_check_relocs, elf32_m68hc11_relocate_section): Ditto.
	(_bfd_m68hc11_elf_set_private_flags): Ditto.
	(_bfd_m68hc11_elf_merge_private_bfd_data): Ditto.
	(_bfd_m68hc11_elf_print_private_bfd_data): Ditto.
	(bfd_elf32_bfd_link_hash_table_create): Define.
	(elf_backend_add_symbol_hook): Define.
	(m68hc11_elf_bfd_link_hash_table_create): New function.
	(m68hc11_elf_build_one_stub): New function.
	(m68hc11_elf_size_one_stub): New function.
	(m68hc11_elf_bfd_link_hash_table_create): Install the above.
	(bfd_elf32_bfd_link_hash_table_create): Define.

	* elf32-m68hc12.c (m68hc11_elf_ignore_reloc): Remove.
	(m68hc12_addr_is_banked): Remove, use m68hc11_addr_is_banked.
	(m68hc12_phys_addr): Ditto.
	(m68hc12_phys_page): Ditto.
	(m68hc12_elf_special_reloc): Move to elf32-m68hc1x.c.
	(elf32_m68hc11_gc_mark_hook): Likewise.
	(elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf32_m68hc11_check_relocs): Likewise.
	(elf32_m68hc11_relocate_section): Likewise.
	(_bfd_m68hc12_elf_set_private_flags): Likewise.
	(_bfd_m68hc12_elf_merge_private_bfd_data): Likewise.
	(_bfd_m68hc12_elf_print_private_bfd_data): Likewise.
	(m68hc12_elf_build_one_stub): New function.
	(m68hc12_elf_size_one_stub): New function.
	(m68hc12_elf_bfd_link_hash_table_create): New function, use the above.
	(elf_backend_add_symbol_hook): Define.
	(elf_m68hc11_howto_table): Use TRUE for pcrel relocs; fix masks.
@
text
@d541 19
d576 1
@


1.13
log
@	* bfd-in.h: Comment typo fix.  Formatting.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_openr_next_archived_file): Warning fix.
	* elf32-m68hc12.c (m68hc12_elf_set_mach_from_flags): Prototype.
	* elf64-mmix.c (mmix_dump_bpo_gregs): Warning fix.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d24 1
d27 1
d31 1
d37 7
a43 15
static bfd_reloc_status_type m68hc11_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type m68hc12_elf_special_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static int m68hc12_addr_is_banked PARAMS ((bfd_vma));
static bfd_vma m68hc12_phys_addr PARAMS ((bfd_vma));
static bfd_vma m68hc12_phys_page PARAMS ((bfd_vma));

/* GC mark and sweep.  */
static asection *elf32_m68hc11_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_m68hc11_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
a46 6
bfd_boolean _bfd_m68hc12_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
bfd_boolean _bfd_m68hc12_elf_set_private_flags PARAMS ((bfd *, flagword));
bfd_boolean _bfd_m68hc12_elf_print_private_bfd_data PARAMS ((bfd *, PTR));



d50 1
a50 6
/* The Motorola 68HC11 microcontroler only addresses 64Kb.
   We must handle 8 and 16-bit relocations.  The 32-bit relocation
   is defined but not used except by gas when -gstabs is used (which
   is wrong).

   The 68HC12 microcontroler has a memory bank switching system
d186 1
a186 1
	 FALSE),		/* pcrel_offset */
d196 1
a196 1
	 m68hc12_elf_special_reloc,	/* special_function */
d247 1
a247 1
	 FALSE),		/* pcrel_offset */
d282 1
a282 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d287 1
a287 1
	 m68hc12_elf_special_reloc,	/* special_function */
d290 2
a291 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d302 1
a302 1
	 m68hc12_elf_special_reloc,/* special_function */
d317 1
a317 1
	 m68hc12_elf_special_reloc,/* special_function */
a409 152
/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
m68hc11_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                          output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

static int
m68hc12_addr_is_banked (addr)
     bfd_vma addr;
{
   return (addr >= M68HC12_BANK_VIRT) ? 1 : 0;
}

/* Return the physical address seen by the processor, taking
   into account banked memory.  */
static bfd_vma
m68hc12_phys_addr (addr)
     bfd_vma addr;
{
  if (addr < M68HC12_BANK_VIRT)
    return addr;

  /* Map the address to the memory bank.  */
  addr -= M68HC12_BANK_VIRT;
  addr &= M68HC12_BANK_MASK;
  addr += M68HC12_BANK_BASE;
  return addr;
}

/* Return the page number corresponding to an address in banked memory.  */
static bfd_vma
m68hc12_phys_page (addr)
     bfd_vma addr;
{
  if (addr < M68HC12_BANK_VIRT)
    return 0;

  /* Map the address to the memory bank.  */
  addr -= M68HC12_BANK_VIRT;
  addr >>= M68HC12_BANK_SHIFT;
  addr &= M68HC12_BANK_PAGE_MASK;
  return addr;
}

static bfd_reloc_status_type
m68hc12_elf_special_reloc (abfd, reloc_entry, symbol, data, input_section,
                           output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto;
  bfd_vma relocation;
  bfd_vma phys_addr;
  bfd_vma phys_page;
  bfd_vma insn_page;
  bfd_vma insn_addr;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Compute relocation.  */
  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  relocation += bfd_get_16 (abfd, (bfd_byte*) data + reloc_entry->address);

  /* Do the memory bank mapping.  */
  phys_addr = m68hc12_phys_addr (relocation);
  phys_page = m68hc12_phys_page (relocation);

  howto = reloc_entry->howto;
  if (howto->complain_on_overflow != complain_overflow_dont
      && (phys_addr & (((bfd_vma) -1) << 16)))
     return bfd_reloc_overflow;

  switch (howto->type)
    {
    case R_M68HC11_16:
          /* Get virtual address of instruction having the relocation.  */
       insn_addr = input_section->output_section->vma
          + input_section->output_offset
          + reloc_entry->address;

      insn_page = m68hc12_phys_page (insn_addr);

      if (m68hc12_addr_is_banked (relocation)
          && m68hc12_addr_is_banked (insn_addr)
          && phys_page != insn_page)
         {
            *error_message = _("address is not in the same bank");
            return bfd_reloc_dangerous;
         }
      if (m68hc12_addr_is_banked (relocation)
          && !m68hc12_addr_is_banked (insn_addr))
         {
            *error_message = _("reference to a banked address in "
                               "the normal address space");
            return bfd_reloc_dangerous;
         }

    case R_M68HC11_LO16:
      bfd_put_16 (abfd, phys_addr, (bfd_byte*) data + reloc_entry->address);
      break;

    case R_M68HC11_24:
      bfd_put_16 (abfd, phys_addr, (bfd_byte*) data + reloc_entry->address);
      bfd_put_8 (abfd, phys_page, (bfd_byte*) data + reloc_entry->address + 2);
      break;

    case R_M68HC11_PAGE:
      bfd_put_8 (abfd, phys_page, (bfd_byte*) data + reloc_entry->address);
      break;

    default:
       abort ();
       break;
    }

  return bfd_reloc_ok;
}

d425 53
a477 29
static asection *
elf32_m68hc11_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d479 1
a479 1
  return NULL;
d482 3
d486 3
a488 5
elf32_m68hc11_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d490 6
a495 1
  /* We don't use got and plt entries for 68hc11/68hc12.  */
d499 17
a540 143
/* Set and control ELF flags in ELF header.  */

bfd_boolean
_bfd_m68hc12_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return m68hc12_elf_set_mach_from_flags (abfd);
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

bfd_boolean
_bfd_m68hc12_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean ok = TRUE;

  /* Check if we have the same endianess */
  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return FALSE;
	}

      return TRUE;
    }

  /* Check ABI compatibility.  */
  if ((new_flags & E_M68HC11_I32) != (old_flags & E_M68HC11_I32))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 16-bit integers (-mshort) "
           "and others for 32-bit integers"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
  if ((new_flags & E_M68HC11_F64) != (old_flags & E_M68HC11_F64))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 32-bit double (-fshort-double) "
           "and others for 64-bit double"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }

  /* Processor compatibility.  */
  if (!EF_M68HC11_CAN_MERGE_MACH (new_flags, old_flags))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for HCS12 with "
           "others compiled for HC12"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
  new_flags = ((new_flags & ~EF_M68HC11_MACH_MASK)
               | (EF_M68HC11_MERGE_MACH (new_flags, old_flags)));

  elf_elfheader (obfd)->e_flags = new_flags;

  /* Warn about any other mismatches */
  new_flags &= ~(EF_M68HC11_ABI | EF_M68HC11_MACH_MASK);
  old_flags &= ~(EF_M68HC11_ABI | EF_M68HC11_MACH_MASK);
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = FALSE;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}

bfd_boolean
_bfd_m68hc12_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_I32)
    fprintf (file, _("[abi=32-bit int,"));
  else
    fprintf (file, _("[abi=16-bit int,"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_F64)
    fprintf (file, _(" 64-bit double,"));
  else
    fprintf (file, _(" 32-bit double,"));

  if (elf_elfheader (abfd)->e_flags & EF_M68HCS12_MACH)
    fprintf (file, _(" cpu=HCS12]"));
  else
    fprintf (file, _(" cpu=HC12]"));
  fputc ('\n', file);

  return TRUE;
}

d552 2
d556 8
a563 3
/* Disabled as this backend uses the generic linker.  */
#define elf_backend_can_gc_sections		0

d565 2
a566 2
					_bfd_m68hc12_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc12_elf_set_private_flags
d568 1
a568 1
					_bfd_m68hc12_elf_print_private_bfd_data
@


1.13.20.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
a23 1
#include "bfdlink.h"
a25 1
#include "elf32-m68hc1x.h"
a28 1
/* Relocation functions.  */
d34 15
a48 7
/* Trampoline generation.  */
static bfd_boolean m68hc12_elf_size_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static bfd_boolean m68hc12_elf_build_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static struct bfd_link_hash_table* m68hc12_elf_bfd_link_hash_table_create
  PARAMS((bfd*));
d52 6
d61 6
a66 1
/* The 68HC12 microcontroler has a memory bank switching system
d202 1
a202 1
	 TRUE),                 /* pcrel_offset */
d212 1
a212 1
	 bfd_elf_generic_reloc,	/* special_function */
d263 1
a263 1
	 TRUE),                 /* pcrel_offset */
d298 1
a298 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d303 1
a303 1
	 m68hc11_elf_special_reloc,	/* special_function */
d306 2
a307 2
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
d318 1
a318 1
	 m68hc11_elf_special_reloc,/* special_function */
d333 1
a333 1
	 m68hc11_elf_special_reloc,/* special_function */
d426 152
d593 29
a621 2

/* Far trampoline generation.  */
d623 1
a623 52
/* Build a 68HC12 trampoline stub.  */
static bfd_boolean
m68hc12_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 7;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     ldy #%addr(symbol)
     call %page(symbol), __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* ldy #%page(sym) */
  bfd_put_8 (stub_bfd, 0xCD, loc);
  bfd_put_16 (stub_bfd, phys_addr, loc + 1);
  loc += 3;

  /* call %page(sym), __trampoline  */
  bfd_put_8 (stub_bfd, 0x4a, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 3);

  return TRUE;
a625 3
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

d627 5
a631 3
m68hc12_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d633 1
a633 6
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->_raw_size += 7;
a636 17
/* Create a 68HC12 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc12_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc12_elf_size_one_stub;
  ret->build_one_stub = m68hc12_elf_build_one_stub;

  return &ret->root.root;
}
d662 143
a815 2
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
d818 3
a820 8
#define elf_backend_can_gc_sections		1
#define elf_backend_post_process_headers     elf32_m68hc11_post_process_headers
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc12_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
d822 2
a823 2
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
d825 1
a825 1
					_bfd_m68hc11_elf_print_private_bfd_data
@


1.12
log
@	* bfd-in2.h (bfd_mach_m6812): Rebuild.
	* archures.c (bfd_mach_m6812_default, bfd_mach_m6812,
	bfd_mach_m6812s): Declare.

	* elf32-m68hc12.c (m68hc12_elf_set_mach_from_flags): New function.
	(_bfd_m68hc12_elf_set_private_flags): Call it.
	(_bfd_m68hc12_elf_print_private_bfd_data): Report processor version.
	(_bfd_m68hc12_elf_merge_private_bfd_data): Merge the flags and
	report microcontroller incompatibilities (HC12 vs HCS12).
	(elf_backend_object_p): Update.
@
text
@d50 2
d799 1
a799 1
    fprintf (file, _(" cpu=HC12]"));    
@


1.11
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d636 24
d672 1
a672 1
  return TRUE;
a695 1
  elf_elfheader (obfd)->e_flags |= new_flags & EF_M68HC11_ABI;
d733 14
a746 2
  new_flags &= ~EF_M68HC11_ABI;
  old_flags &= ~EF_M68HC11_ABI;
d749 2
d790 1
a790 1
    fprintf (file, _(" 64-bit double]"));
d792 1
a792 1
    fprintf (file, _(" 32-bit double]"));
d794 4
a802 2
/* Below is the only difference between elf32-m68hc12.c and elf32-m68hc11.c.
   The Motorola spec says to use a different Elf machine code.  */
d814 1
a814 1
#define elf_backend_object_p	0
@


1.10
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d46 1
a46 1
static boolean elf32_m68hc11_gc_sweep_hook
d50 3
a52 3
boolean _bfd_m68hc12_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
boolean _bfd_m68hc12_elf_set_private_flags PARAMS ((bfd *, flagword));
boolean _bfd_m68hc12_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d123 1
a123 1
   mapped at 0x8000.  
d132 1
a132 1
	 false,			/* pc_relative */
d137 1
a137 1
	 false,			/* partial_inplace */
d140 1
a140 1
	 false),		/* pcrel_offset */
d147 1
a147 1
	 false,			/* pc_relative */
d152 1
a152 1
	 false,			/* partial_inplace */
d155 1
a155 1
	 false),		/* pcrel_offset */
d162 1
a162 1
	 false,			/* pc_relative */
d167 1
a167 1
	 false,			/* partial_inplace */
d170 1
a170 1
	 false),		/* pcrel_offset */
d177 1
a177 1
	 false,			/* pc_relative */
d182 1
a182 1
	 false,			/* partial_inplace */
d185 1
a185 1
	 false),		/* pcrel_offset */
d192 1
a192 1
	 true,			/* pc_relative */
d197 1
a197 1
	 false,			/* partial_inplace */
d200 1
a200 1
	 false),		/* pcrel_offset */
d207 1
a207 1
	 false,			/* pc_relative */
d212 1
a212 1
	 false,			/* partial_inplace */
d215 1
a215 1
	 false),		/* pcrel_offset */
d223 1
a223 1
	 false,			/* pc_relative */
d228 1
a228 1
	 false,			/* partial_inplace */
d231 1
a231 1
	 false),		/* pcrel_offset */
d238 1
a238 1
	 false,			/* pc_relative */
d243 1
a243 1
	 false,			/* partial_inplace */
d246 1
a246 1
	 false),		/* pcrel_offset */
d253 1
a253 1
	 true,			/* pc_relative */
d258 1
a258 1
	 false,			/* partial_inplace */
d261 1
a261 1
	 false),		/* pcrel_offset */
d268 1
a268 1
	 false,			/* pc_relative */
d273 1
a273 1
	 false,			/* partial_inplace */
d276 1
a276 1
	 false),		/* pcrel_offset */
d283 1
a283 1
	 false,			/* pc_relative */
d288 1
a288 1
	 false,			/* partial_inplace */
d291 1
a291 1
	 false),		/* pcrel_offset */
d298 1
a298 1
	 false,			/* pc_relative */
d303 1
a303 1
	 false,			/* partial_inplace */
d306 2
a307 2
	 false),		/* pcrel_offset */
  
d313 1
a313 1
	 false,			/* pc_relative */
d318 1
a318 1
	 false,			/* partial_inplace */
d321 1
a321 1
	 false),		/* pcrel_offset */
d328 1
a328 1
	 false,			/* pc_relative */
d333 1
a333 1
	 false,			/* partial_inplace */
d336 1
a336 1
	 false),		/* pcrel_offset */
d344 1
a344 1
  
d350 1
a350 1
	 false,			/* pc_relative */
d355 1
a355 1
	 true,			/* partial_inplace */
d358 1
a358 1
	 true),                 /* pcrel_offset */
d365 1
a365 1
	 false,			/* pc_relative */
d370 1
a370 1
	 true,			/* partial_inplace */
d373 1
a373 1
	 true),                 /* pcrel_offset */
d498 1
a498 1
  
d554 1
a554 1
      
d572 1
a572 1
  
d624 1
a624 1
static boolean
d632 1
a632 1
  return true;
d638 1
a638 1
boolean
d647 2
a648 2
  elf_flags_init (abfd) = true;
  return true;
d654 1
a654 1
boolean
d661 1
a661 1
  boolean ok = true;
d664 2
a665 2
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;
d669 1
a669 1
    return true;
d677 1
a677 1
      elf_flags_init (obfd) = true;
d687 1
a687 1
	    return false;
d690 1
a690 1
      return true;
d700 1
a700 1
      ok = false;
d708 1
a708 1
      ok = false;
d720 1
a720 1
      ok = false;
d726 1
a726 1
      return false;
d729 1
a729 1
  return true;
d732 1
a732 1
boolean
d759 1
a759 1
  return true;
@


1.9
log
@	* elfxx-target.h (USE_REL): Don't define as 1.
	* elf32-arm.h (USE_REL): Provide a default define of 0.
	Use #if rather than #ifdef when testing USE_REL.
	* elf32-m32r.c: Likewise.

	* elf32-arc.c (USE_REL): Define as 1.
	* elf32-d10v.c (USE_REL): Likewise.
	* elf32-m32r.c (USE_REL): Likewise.
	* elf32-m68hc11.c (USE_REL): Likewise.
	* elf32-m68hc12.c (USE_REL): Likewise.
	* elf32-or32.c (USE_REL): Likewise.
	* elfarm-nabi.c (USE_REL): Likewise.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d582 1
a582 1
     Elf32_Internal_Rel *dst;
@


1.8
log
@	* elf32-m68hc11.c: Formatting fixes.
	(elf32_m68hc11_gc_mark_hook): Correct params.  Remove unnecessary test.
	* elf32-m68hc12.c: Formatting fixes.
	(elf32_m68hc11_gc_mark_hook): Correct params.  Remove unnecessary test.
@
text
@d57 1
a57 1
#define USE_REL
@


1.8.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d57 1
a57 1
#define USE_REL	1
@


1.8.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
a23 1
#include "bfdlink.h"
a25 1
#include "elf32-m68hc1x.h"
a28 1
/* Relocation functions.  */
d30 1
a30 1
  (bfd *, bfd_reloc_code_real_type);
d32 21
a52 1
  (bfd *, arelent *, Elf_Internal_Rela *);
a53 7
/* Trampoline generation.  */
static bfd_boolean m68hc12_elf_size_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static bfd_boolean m68hc12_elf_build_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static struct bfd_link_hash_table* m68hc12_elf_bfd_link_hash_table_create
  (bfd*);
a54 1
static bfd_boolean m68hc12_elf_set_mach_from_flags PARAMS ((bfd *));
d59 6
a64 1
/* The 68HC12 microcontroler has a memory bank switching system
d123 1
a123 1
   mapped at 0x8000.
d132 1
a132 1
	 FALSE,			/* pc_relative */
d137 1
a137 1
	 FALSE,			/* partial_inplace */
d140 1
a140 1
	 FALSE),		/* pcrel_offset */
d147 1
a147 1
	 FALSE,			/* pc_relative */
d152 1
a152 1
	 FALSE,			/* partial_inplace */
d155 1
a155 1
	 FALSE),		/* pcrel_offset */
d162 1
a162 1
	 FALSE,			/* pc_relative */
d167 1
a167 1
	 FALSE,			/* partial_inplace */
d170 1
a170 1
	 FALSE),		/* pcrel_offset */
d177 1
a177 1
	 FALSE,			/* pc_relative */
d182 1
a182 1
	 FALSE,			/* partial_inplace */
d185 1
a185 1
	 FALSE),		/* pcrel_offset */
d192 1
a192 1
	 TRUE,			/* pc_relative */
d197 1
a197 1
	 FALSE,			/* partial_inplace */
d200 1
a200 1
	 TRUE),                 /* pcrel_offset */
d207 1
a207 1
	 FALSE,			/* pc_relative */
d210 1
a210 1
	 bfd_elf_generic_reloc,	/* special_function */
d212 1
a212 1
	 FALSE,			/* partial_inplace */
d215 1
a215 1
	 FALSE),		/* pcrel_offset */
d223 1
a223 1
	 FALSE,			/* pc_relative */
d228 1
a228 1
	 FALSE,			/* partial_inplace */
d231 1
a231 1
	 FALSE),		/* pcrel_offset */
d238 1
a238 1
	 FALSE,			/* pc_relative */
d243 1
a243 1
	 FALSE,			/* partial_inplace */
d246 1
a246 1
	 FALSE),		/* pcrel_offset */
d253 1
a253 1
	 TRUE,			/* pc_relative */
d258 1
a258 1
	 FALSE,			/* partial_inplace */
d261 1
a261 1
	 TRUE),                 /* pcrel_offset */
d268 1
a268 1
	 FALSE,			/* pc_relative */
d273 1
a273 1
	 FALSE,			/* partial_inplace */
d276 1
a276 1
	 FALSE),		/* pcrel_offset */
d283 1
a283 1
	 FALSE,			/* pc_relative */
d288 1
a288 1
	 FALSE,			/* partial_inplace */
d291 1
a291 1
	 FALSE),		/* pcrel_offset */
d296 1
a296 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d298 1
a298 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 m68hc11_elf_special_reloc,	/* special_function */
d303 5
a307 5
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

d313 1
a313 1
	 FALSE,			/* pc_relative */
d316 1
a316 1
	 m68hc11_elf_special_reloc,/* special_function */
d318 1
a318 1
	 FALSE,			/* partial_inplace */
d321 1
a321 1
	 FALSE),		/* pcrel_offset */
d328 1
a328 1
	 FALSE,			/* pc_relative */
d331 1
a331 1
	 m68hc11_elf_special_reloc,/* special_function */
d333 1
a333 1
	 FALSE,			/* partial_inplace */
d336 1
a336 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1

d350 1
a350 1
	 FALSE,			/* pc_relative */
d355 1
a355 1
	 TRUE,			/* partial_inplace */
d358 1
a358 1
	 TRUE),                 /* pcrel_offset */
d365 1
a365 1
	 FALSE,			/* pc_relative */
d370 1
a370 1
	 TRUE,			/* partial_inplace */
d373 1
a373 1
	 TRUE),                 /* pcrel_offset */
d407 3
a409 2
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
d424 152
d579 4
a582 2
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
d591 32
a622 2

/* Far trampoline generation.  */
d624 6
a629 3
/* Build a 68HC12 trampoline stub.  */
static bfd_boolean
m68hc12_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d631 3
a633 7
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;
d635 2
a636 3
  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;
d638 7
a644 1
  htab = m68hc11_elf_hash_table (info);
d646 4
a649 1
  stub_sec = stub_entry->stub_sec;
d651 2
a652 4
  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 7;
  loc = stub_sec->contents + stub_entry->stub_offset;
d654 20
a673 1
  stub_bfd = stub_sec->owner;
d675 14
a688 1
  /* Create the trampoline call stub:
d690 2
a691 2
     ldy #%addr(symbol)
     call %page(symbol), __trampoline
d693 19
a711 6
  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);
d713 9
a721 4
  /* ldy #%page(sym) */
  bfd_put_8 (stub_bfd, 0xCD, loc);
  bfd_put_16 (stub_bfd, phys_addr, loc + 1);
  loc += 3;
d723 5
a727 4
  /* call %page(sym), __trampoline  */
  bfd_put_8 (stub_bfd, 0x4a, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 3);
d729 1
a729 1
  return TRUE;
d732 4
a735 6
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
m68hc12_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
d737 1
a737 1
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
d739 1
a739 2
  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
d741 2
a742 5
  stub_entry->stub_sec->_raw_size += 7;
  return TRUE;
}

/* Create a 68HC12 ELF linker hash table.  */
d744 2
a745 4
static struct bfd_link_hash_table *
m68hc12_elf_bfd_link_hash_table_create (bfd *abfd)
{
  struct m68hc11_elf_link_hash_table *ret;
d747 4
a750 3
  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;
d752 4
a755 2
  ret->size_one_stub = m68hc12_elf_size_one_stub;
  ret->build_one_stub = m68hc12_elf_build_one_stub;
d757 1
a757 7
  return &ret->root.root;
}

static bfd_boolean
m68hc12_elf_set_mach_from_flags (bfd *abfd)
{
  flagword flags = elf_elfheader (abfd)->e_flags;
d759 1
a759 16
  switch (flags & EF_M68HC11_MACH_MASK)
    {
    case EF_M68HC12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812);
      break;
    case EF_M68HCS12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812s);
      break;
    case EF_M68HC11_GENERIC:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12,
                                 bfd_mach_m6812_default);
      break;
    default:
      return FALSE;
    }
  return TRUE;
d762 2
a763 14
/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC12.
   - The .vectors is the section that represents the interrupt
     vectors.  */
static struct bfd_elf_special_section const elf32_m68hc12_special_sections[]=
{
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
};

d775 1
a775 3
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
#define elf_backend_object_p		m68hc12_elf_set_mach_from_flags
d777 3
a779 9
#define elf_backend_can_gc_sections		1
#define elf_backend_special_sections elf32_m68hc12_special_sections
#define elf_backend_post_process_headers     elf32_m68hc11_post_process_headers
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc12_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
d781 2
a782 2
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
d784 1
a784 1
					_bfd_m68hc11_elf_print_private_bfd_data
@


1.8.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d57 1
a57 1
#define USE_REL	1
@


1.8.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d46 1
a46 1
static bfd_boolean elf32_m68hc11_gc_sweep_hook
d50 3
a52 5
static bfd_boolean m68hc12_elf_set_mach_from_flags PARAMS ((bfd *));

bfd_boolean _bfd_m68hc12_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
bfd_boolean _bfd_m68hc12_elf_set_private_flags PARAMS ((bfd *, flagword));
bfd_boolean _bfd_m68hc12_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d123 1
a123 1
   mapped at 0x8000.
d132 1
a132 1
	 FALSE,			/* pc_relative */
d137 1
a137 1
	 FALSE,			/* partial_inplace */
d140 1
a140 1
	 FALSE),		/* pcrel_offset */
d147 1
a147 1
	 FALSE,			/* pc_relative */
d152 1
a152 1
	 FALSE,			/* partial_inplace */
d155 1
a155 1
	 FALSE),		/* pcrel_offset */
d162 1
a162 1
	 FALSE,			/* pc_relative */
d167 1
a167 1
	 FALSE,			/* partial_inplace */
d170 1
a170 1
	 FALSE),		/* pcrel_offset */
d177 1
a177 1
	 FALSE,			/* pc_relative */
d182 1
a182 1
	 FALSE,			/* partial_inplace */
d185 1
a185 1
	 FALSE),		/* pcrel_offset */
d192 1
a192 1
	 TRUE,			/* pc_relative */
d197 1
a197 1
	 FALSE,			/* partial_inplace */
d200 1
a200 1
	 FALSE),		/* pcrel_offset */
d207 1
a207 1
	 FALSE,			/* pc_relative */
d212 1
a212 1
	 FALSE,			/* partial_inplace */
d215 1
a215 1
	 FALSE),		/* pcrel_offset */
d223 1
a223 1
	 FALSE,			/* pc_relative */
d228 1
a228 1
	 FALSE,			/* partial_inplace */
d231 1
a231 1
	 FALSE),		/* pcrel_offset */
d238 1
a238 1
	 FALSE,			/* pc_relative */
d243 1
a243 1
	 FALSE,			/* partial_inplace */
d246 1
a246 1
	 FALSE),		/* pcrel_offset */
d253 1
a253 1
	 TRUE,			/* pc_relative */
d258 1
a258 1
	 FALSE,			/* partial_inplace */
d261 1
a261 1
	 FALSE),		/* pcrel_offset */
d268 1
a268 1
	 FALSE,			/* pc_relative */
d273 1
a273 1
	 FALSE,			/* partial_inplace */
d276 1
a276 1
	 FALSE),		/* pcrel_offset */
d283 1
a283 1
	 FALSE,			/* pc_relative */
d288 1
a288 1
	 FALSE,			/* partial_inplace */
d291 1
a291 1
	 FALSE),		/* pcrel_offset */
d298 1
a298 1
	 FALSE,			/* pc_relative */
d303 1
a303 1
	 FALSE,			/* partial_inplace */
d306 2
a307 2
	 FALSE),		/* pcrel_offset */

d313 1
a313 1
	 FALSE,			/* pc_relative */
d318 1
a318 1
	 FALSE,			/* partial_inplace */
d321 1
a321 1
	 FALSE),		/* pcrel_offset */
d328 1
a328 1
	 FALSE,			/* pc_relative */
d333 1
a333 1
	 FALSE,			/* partial_inplace */
d336 1
a336 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1

d350 1
a350 1
	 FALSE,			/* pc_relative */
d355 1
a355 1
	 TRUE,			/* partial_inplace */
d358 1
a358 1
	 TRUE),                 /* pcrel_offset */
d365 1
a365 1
	 FALSE,			/* pc_relative */
d370 1
a370 1
	 TRUE,			/* partial_inplace */
d373 1
a373 1
	 TRUE),                 /* pcrel_offset */
d498 1
a498 1

d554 1
a554 1

d572 1
a572 1

d582 1
a582 1
     Elf_Internal_Rela *dst;
d624 1
a624 1
static bfd_boolean
d632 1
a632 1
  return TRUE;
a635 24
static bfd_boolean
m68hc12_elf_set_mach_from_flags (abfd)
     bfd *abfd;
{
  flagword flags = elf_elfheader (abfd)->e_flags;

  switch (flags & EF_M68HC11_MACH_MASK)
    {
    case EF_M68HC12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812);
      break;
    case EF_M68HCS12_MACH:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12, bfd_mach_m6812s);
      break;
    case EF_M68HC11_GENERIC:
      bfd_default_set_arch_mach (abfd, bfd_arch_m68hc12,
                                 bfd_mach_m6812_default);
      break;
    default:
      return FALSE;
    }
  return TRUE;
}

d638 1
a638 1
bfd_boolean
d647 2
a648 2
  elf_flags_init (abfd) = TRUE;
  return m68hc12_elf_set_mach_from_flags (abfd);
d654 1
a654 1
bfd_boolean
d661 1
a661 1
  bfd_boolean ok = TRUE;
d664 2
a665 2
  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;
d669 1
a669 1
    return TRUE;
d672 1
d677 1
a677 1
      elf_flags_init (obfd) = TRUE;
d687 1
a687 1
	    return FALSE;
d690 1
a690 1
      return TRUE;
d700 1
a700 1
      ok = FALSE;
d708 1
a708 11
      ok = FALSE;
    }

  /* Processor compatibility.  */
  if (!EF_M68HC11_CAN_MERGE_MACH (new_flags, old_flags))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for HCS12 with "
           "others compiled for HC12"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
d710 2
a711 4
  new_flags = ((new_flags & ~EF_M68HC11_MACH_MASK)
               | (EF_M68HC11_MERGE_MACH (new_flags, old_flags)));

  elf_elfheader (obfd)->e_flags = new_flags;
a713 2
  new_flags &= ~(EF_M68HC11_ABI | EF_M68HC11_MACH_MASK);
  old_flags &= ~(EF_M68HC11_ABI | EF_M68HC11_MACH_MASK);
d720 1
a720 1
      ok = FALSE;
d726 1
a726 1
      return FALSE;
d729 1
a729 1
  return TRUE;
d732 1
a732 1
bfd_boolean
d753 1
a753 1
    fprintf (file, _(" 64-bit double,"));
d755 1
a755 1
    fprintf (file, _(" 32-bit double,"));
a756 4
  if (elf_elfheader (abfd)->e_flags & EF_M68HCS12_MACH)
    fprintf (file, _(" cpu=HCS12]"));
  else
    fprintf (file, _(" cpu=HC12]"));
d759 1
a759 1
  return TRUE;
d762 2
d775 1
a775 1
#define elf_backend_object_p		m68hc12_elf_set_mach_from_flags
@


1.8.10.3
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
a23 1
#include "bfdlink.h"
a25 1
#include "elf32-m68hc1x.h"
a28 1
/* Relocation functions.  */
d34 15
a48 7
/* Trampoline generation.  */
static bfd_boolean m68hc12_elf_size_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static bfd_boolean m68hc12_elf_build_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static struct bfd_link_hash_table* m68hc12_elf_bfd_link_hash_table_create
  PARAMS((bfd*));
d52 6
d61 6
a66 1
/* The 68HC12 microcontroler has a memory bank switching system
d202 1
a202 1
	 TRUE),                 /* pcrel_offset */
d212 1
a212 1
	 bfd_elf_generic_reloc,	/* special_function */
d263 1
a263 1
	 TRUE),                 /* pcrel_offset */
d298 1
a298 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d303 1
a303 1
	 m68hc11_elf_special_reloc,	/* special_function */
d306 2
a307 2
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
d318 1
a318 1
	 m68hc11_elf_special_reloc,/* special_function */
d333 1
a333 1
	 m68hc11_elf_special_reloc,/* special_function */
d426 152
d593 29
a621 2

/* Far trampoline generation.  */
d623 1
a623 52
/* Build a 68HC12 trampoline stub.  */
static bfd_boolean
m68hc12_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 7;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     ldy #%addr(symbol)
     call %page(symbol), __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* ldy #%page(sym) */
  bfd_put_8 (stub_bfd, 0xCD, loc);
  bfd_put_16 (stub_bfd, phys_addr, loc + 1);
  loc += 3;

  /* call %page(sym), __trampoline  */
  bfd_put_8 (stub_bfd, 0x4a, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 3);

  return TRUE;
a625 3
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

d627 5
a631 3
m68hc12_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d633 1
a633 6
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->_raw_size += 7;
a636 17
/* Create a 68HC12 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc12_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc12_elf_size_one_stub;
  ret->build_one_stub = m68hc12_elf_build_one_stub;

  return &ret->root.root;
}
d662 143
a815 2
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
d818 3
a820 8
#define elf_backend_can_gc_sections		1
#define elf_backend_post_process_headers     elf32_m68hc11_post_process_headers
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc12_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
d822 2
a823 2
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
d825 1
a825 1
					_bfd_m68hc11_elf_print_private_bfd_data
@


1.8.10.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a540 19
/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC12.
   - The .vectors is the section that represents the interrupt
     vectors.  */
static struct bfd_elf_special_section const elf32_m68hc12_special_sections[]=
{
  { ".eeprom",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".softregs",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { ".page0",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".vectors",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a556 1
#define elf_backend_special_sections elf32_m68hc12_special_sections
@


1.8.10.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d33 1
a33 1
  (bfd *, bfd_reloc_code_real_type);
d35 1
a35 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d39 1
a39 1
  (struct bfd_hash_entry *gen_entry, void *in_arg);
d41 1
a41 1
  (struct bfd_hash_entry *gen_entry, void *in_arg);
d43 1
a43 1
  (bfd*);
d393 3
a395 2
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
d413 4
a416 2
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
d430 3
a432 1
m68hc12_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d486 3
a488 2
m68hc12_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
d502 2
a503 1
m68hc12_elf_bfd_link_hash_table_create (bfd *abfd)
d518 2
a519 1
m68hc12_elf_set_mach_from_flags (bfd *abfd)
d548 10
a557 5
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
@


1.7
log
@	* elf32-m68hc12.c (elf_backend_can_gc_sections): False.
@
text
@d30 1
a30 1
PARAMS ((bfd * abfd, bfd_reloc_code_real_type code));
d32 1
a32 1
PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d35 1
a35 3
PARAMS ((bfd *abfd, arelent *reloc_entry,
         asymbol *symbol, PTR data, asection *input_section,
         bfd *output_bfd, char **error_message));
d44 2
a45 3
PARAMS ((bfd *abfd, struct bfd_link_info *info,
         Elf_Internal_Rela *rel, struct elf_link_hash_entry *h,
         Elf_Internal_Sym *sym));
d47 2
a48 2
PARAMS ((bfd *abfd, struct bfd_link_info *info,
         asection *sec, const Elf_Internal_Rela *relocs));
d50 3
a52 3
boolean _bfd_m68hc12_elf_merge_private_bfd_data PARAMS ((bfd*, bfd*));
boolean _bfd_m68hc12_elf_set_private_flags PARAMS ((bfd*, flagword));
boolean _bfd_m68hc12_elf_print_private_bfd_data PARAMS ((bfd*, PTR));
d592 2
a593 2
elf32_m68hc11_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d619 2
a620 9
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && !((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
	       && sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }
@


1.6
log
@	* elf32-m68hc11.c (elf32_m68hc11_gc_mark_hook): New for section GC.
	(elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf_backend_gc_mark_hook): Define for GC section support.
	(elf_backend_gc_sweep_hook): Likewise.
	(elf_backend_can_gc_sections): Likewise.

	* elf32-m68hc12.c: Likewise.
@
text
@d787 2
a788 1
#define elf_backend_can_gc_sections		1
@


1.5
log
@	* elf32-m68hc11.c (_bfd_m68hc11_elf_print_private_bfd_data): New.
	(_bfd_m68hc11_elf_merge_private_bfd_data): New function.
	(_bfd_m68hc11_elf_set_private_flags): New function.
	Use them to set/check/print ELF flags specific to 68HC11.

	* elf32-m68hc12.c (_bfd_m68hc12_elf_print_private_bfd_data): New.
	(_bfd_m68hc12_elf_merge_private_bfd_data): New function.
	(_bfd_m68hc12_elf_set_private_flags): New function.
	Use them to set/check/print ELF flags specific to 68HC12.
@
text
@d44 9
d594 51
d783 2
d787 1
@


1.4
log
@	* elf32-m68hc11.c (elf_m68hc11_howto_table): Add the new relocs;
	fix masks for PC-rel relocs.
	(m68hc11_elf_ignore_reloc): New function.

	* elf32-m68hc12.c (m68hc12_elf_special_reloc): New to handle specific
	68HC12 banked addressing relocs.
	(m68hc12_phys_addr): New to compute physical address of banked memory.
	(m68hc12_phys_page): Likewise for page.
	(m68hc12_addr_is_banked): New to see if address is in banked area.
	(elf_m68hc12_howto_table): Add new relocs and rename to xx12.
@
text
@d44 6
d585 127
d725 6
@


1.3
log
@Update copyright notices
@
text
@d2 2
a3 2
   Copyright 1999, 2000 Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@worldnet.fr)
d27 1
d34 10
d51 62
d122 1
a122 1
	 complain_overflow_bitfield,	/* complain_on_overflow */
d124 1
a124 1
	 "R_M68HC11_NONE",	/* name */
d139 1
a139 1
	 "R_M68HC11_8",		/* name */
d154 1
a154 1
	 "R_M68HC11_HI8",	/* name */
d169 1
a169 1
	 "R_M68HC11_LO8",	/* name */
d184 1
a184 1
	 "R_M68HC11_PCREL_8",	/* name */
d186 1
a186 1
	 0x0,			/* src_mask */
d198 2
a199 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_16",	/* name */
d215 1
a215 1
	 "R_M68HC11_32",	/* name */
d230 1
a230 1
	 "R_M68HC11_4B",	/* name */
d245 1
a245 1
	 "R_M68HC11_PCREL_16",	/* name */
d247 1
a247 1
	 0x0,			/* src_mask */
d280 82
a382 1
  /* The following relocs are defined but they probably don't work yet.  */
d385 7
d410 152
@


1.3.16.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@nerim.fr)
a26 1
#include "opcode/m68hc11.h"
d29 1
a29 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d31 1
a31 23
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));

static bfd_reloc_status_type m68hc11_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type m68hc12_elf_special_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static int m68hc12_addr_is_banked PARAMS ((bfd_vma));
static bfd_vma m68hc12_phys_addr PARAMS ((bfd_vma));
static bfd_vma m68hc12_phys_page PARAMS ((bfd_vma));

/* GC mark and sweep.  */
static asection *elf32_m68hc11_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static boolean elf32_m68hc11_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

boolean _bfd_m68hc12_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
boolean _bfd_m68hc12_elf_set_private_flags PARAMS ((bfd *, flagword));
boolean _bfd_m68hc12_elf_print_private_bfd_data PARAMS ((bfd *, PTR));


a39 62

   The 68HC12 microcontroler has a memory bank switching system
   with a 16Kb window in the 64Kb address space.  The extended memory
   is mapped in the 16Kb window (at 0x8000).  The page register controls
   which 16Kb bank is mapped.  The call/rtc instructions take care of
   bank switching in function calls/returns.

   For GNU Binutils to work, we consider there is a physical memory
   at 0..0x0ffff and a kind of virtual memory above that.  Symbols
   in virtual memory have their addresses treated in a special way
   when disassembling and when linking.

   For the linker to work properly, we must always relocate the virtual
   memory as if it is mapped at 0x8000.  When a 16-bit relocation is
   made in the virtual memory, we check that it does not cross the
   memory bank where it is used.  This would involve a page change
   which would be wrong.  The 24-bit relocation is for that and it
   treats the address as a physical address + page number.


					Banked
					Address Space
                                        |               |       Page n
					+---------------+ 0x1010000
                                        |               |
                                        | jsr _foo      |
                                        | ..            |       Page 3
                                        | _foo:         |
					+---------------+ 0x100C000
					|	        |
                                        | call _bar     |
					| ..	        |	Page 2
					| _bar:	        |
					+---------------+ 0x1008000
				/------>|	        |
				|	| call _foo     |	Page 1
				|	|       	|
				|	+---------------+ 0x1004000
      Physical			|	|	        |
      Address Space		|	|	        |	Page 0
				|	|	        |
    +-----------+ 0x00FFFF	|	+---------------+ 0x1000000
    |		|		|
    | call _foo	|		|
    |		|		|
    +-----------+ 0x00BFFF -+---/
    |		|           |
    |		|	    |
    |		| 16K	    |
    |		|	    |
    +-----------+ 0x008000 -+
    |		|
    |		|
    =		=
    |		|
    |		|
    +-----------+ 0000


   The 'call _foo' must be relocated with page 3 and 16-bit address
   mapped at 0x8000.  

d49 1
a49 1
	 complain_overflow_dont,/* complain_on_overflow */
d51 1
a51 1
	 "R_M68HC12_NONE",	/* name */
d66 1
a66 1
	 "R_M68HC12_8",		/* name */
d81 1
a81 1
	 "R_M68HC12_HI8",	/* name */
d96 1
a96 1
	 "R_M68HC12_LO8",	/* name */
d111 1
a111 1
	 "R_M68HC12_PCREL_8",	/* name */
d113 1
a113 1
	 0x00ff,		/* src_mask */
d125 2
a126 2
	 m68hc12_elf_special_reloc,	/* special_function */
	 "R_M68HC12_16",	/* name */
d142 1
a142 1
	 "R_M68HC12_32",	/* name */
d157 1
a157 1
	 "R_M68HC12_4B",	/* name */
d172 1
a172 1
	 "R_M68HC12_PCREL_16",	/* name */
d174 1
a174 1
	 0xffff,		/* src_mask */
a206 82

  /* A 24 bit relocation */
  HOWTO (R_M68HC11_24,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc12_elf_special_reloc,	/* special_function */
	 "R_M68HC12_24",	/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
  
  /* A 16-bit low relocation */
  HOWTO (R_M68HC11_LO16,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc12_elf_special_reloc,/* special_function */
	 "R_M68HC12_LO16",	/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A page relocation */
  HOWTO (R_M68HC11_PAGE,        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc12_elf_special_reloc,/* special_function */
	 "R_M68HC12_PAGE",	/* name */
	 false,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 false),		/* pcrel_offset */

  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  
  /* Mark beginning of a jump instruction (any form).  */
  HOWTO (R_M68HC11_RL_JUMP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC12_RL_JUMP",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),                 /* pcrel_offset */

  /* Mark beginning of Gcc relaxation group instruction.  */
  HOWTO (R_M68HC11_RL_GROUP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC12_RL_GROUP",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),                 /* pcrel_offset */
d228 1
a230 7

  {BFD_RELOC_M68HC11_LO16, R_M68HC11_LO16},
  {BFD_RELOC_M68HC11_PAGE, R_M68HC11_PAGE},
  {BFD_RELOC_M68HC11_24, R_M68HC11_24},

  {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
  {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
a250 152
/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
m68hc11_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                          output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

static int
m68hc12_addr_is_banked (addr)
     bfd_vma addr;
{
   return (addr >= M68HC12_BANK_VIRT) ? 1 : 0;
}

/* Return the physical address seen by the processor, taking
   into account banked memory.  */
static bfd_vma
m68hc12_phys_addr (addr)
     bfd_vma addr;
{
  if (addr < M68HC12_BANK_VIRT)
    return addr;

  /* Map the address to the memory bank.  */
  addr -= M68HC12_BANK_VIRT;
  addr &= M68HC12_BANK_MASK;
  addr += M68HC12_BANK_BASE;
  return addr;
}

/* Return the page number corresponding to an address in banked memory.  */
static bfd_vma
m68hc12_phys_page (addr)
     bfd_vma addr;
{
  if (addr < M68HC12_BANK_VIRT)
    return 0;

  /* Map the address to the memory bank.  */
  addr -= M68HC12_BANK_VIRT;
  addr >>= M68HC12_BANK_SHIFT;
  addr &= M68HC12_BANK_PAGE_MASK;
  return addr;
}

static bfd_reloc_status_type
m68hc12_elf_special_reloc (abfd, reloc_entry, symbol, data, input_section,
                           output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto;
  bfd_vma relocation;
  bfd_vma phys_addr;
  bfd_vma phys_page;
  bfd_vma insn_page;
  bfd_vma insn_addr;
  
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Compute relocation.  */
  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  relocation += bfd_get_16 (abfd, (bfd_byte*) data + reloc_entry->address);

  /* Do the memory bank mapping.  */
  phys_addr = m68hc12_phys_addr (relocation);
  phys_page = m68hc12_phys_page (relocation);

  howto = reloc_entry->howto;
  if (howto->complain_on_overflow != complain_overflow_dont
      && (phys_addr & (((bfd_vma) -1) << 16)))
     return bfd_reloc_overflow;

  switch (howto->type)
    {
    case R_M68HC11_16:
          /* Get virtual address of instruction having the relocation.  */
       insn_addr = input_section->output_section->vma
          + input_section->output_offset
          + reloc_entry->address;

      insn_page = m68hc12_phys_page (insn_addr);

      if (m68hc12_addr_is_banked (relocation)
          && m68hc12_addr_is_banked (insn_addr)
          && phys_page != insn_page)
         {
            *error_message = _("address is not in the same bank");
            return bfd_reloc_dangerous;
         }
      if (m68hc12_addr_is_banked (relocation)
          && !m68hc12_addr_is_banked (insn_addr))
         {
            *error_message = _("reference to a banked address in "
                               "the normal address space");
            return bfd_reloc_dangerous;
         }
      
    case R_M68HC11_LO16:
      bfd_put_16 (abfd, phys_addr, (bfd_byte*) data + reloc_entry->address);
      break;

    case R_M68HC11_24:
      bfd_put_16 (abfd, phys_addr, (bfd_byte*) data + reloc_entry->address);
      bfd_put_8 (abfd, phys_page, (bfd_byte*) data + reloc_entry->address + 2);
      break;

    case R_M68HC11_PAGE:
      bfd_put_8 (abfd, phys_page, (bfd_byte*) data + reloc_entry->address);
      break;

    default:
       abort ();
       break;
    }
  
  return bfd_reloc_ok;
}

a265 171
static asection *
elf32_m68hc11_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

static boolean
elf32_m68hc11_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  /* We don't use got and plt entries for 68hc11/68hc12.  */
  return true;
}


/* Set and control ELF flags in ELF header.  */

boolean
_bfd_m68hc12_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

boolean
_bfd_m68hc12_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  boolean ok = true;

  /* Check if we have the same endianess */
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_M68HC11_ABI;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return false;
	}

      return true;
    }

  /* Check ABI compatibility.  */
  if ((new_flags & E_M68HC11_I32) != (old_flags & E_M68HC11_I32))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 16-bit integers (-mshort) "
           "and others for 32-bit integers"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }
  if ((new_flags & E_M68HC11_F64) != (old_flags & E_M68HC11_F64))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 32-bit double (-fshort-double) "
           "and others for 64-bit double"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }
  new_flags &= ~EF_M68HC11_ABI;
  old_flags &= ~EF_M68HC11_ABI;

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = false;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
    }

  return true;
}

boolean
_bfd_m68hc12_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_I32)
    fprintf (file, _("[abi=32-bit int,"));
  else
    fprintf (file, _("[abi=16-bit int,"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_F64)
    fprintf (file, _(" 64-bit double]"));
  else
    fprintf (file, _(" 32-bit double]"));

  fputc ('\n', file);

  return true;
}

a276 2
#define elf_backend_gc_mark_hook     elf32_m68hc11_gc_mark_hook
#define elf_backend_gc_sweep_hook    elf32_m68hc11_gc_sweep_hook
a278 8
/* Disabled as this backend uses the generic linker.  */
#define elf_backend_can_gc_sections		0

#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_m68hc12_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc12_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_m68hc12_elf_print_private_bfd_data
@


1.3.16.2
log
@merge from mainline
@
text
@d57 1
a57 1
#define USE_REL	1
@


1.2
log
@2000-12-06  Kazu Hirata  <kazu@@hxi.com>

	* elf32-m32r.c: Fix formatting.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.2.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.1
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@a32 1

@

