head	1.19;
access;
symbols
	sid-snapshot-20180601:1.19
	sid-snapshot-20180501:1.19
	sid-snapshot-20180401:1.19
	sid-snapshot-20180301:1.19
	sid-snapshot-20180201:1.19
	sid-snapshot-20180101:1.19
	sid-snapshot-20171201:1.19
	sid-snapshot-20171101:1.19
	sid-snapshot-20171001:1.19
	sid-snapshot-20170901:1.19
	sid-snapshot-20170801:1.19
	sid-snapshot-20170701:1.19
	sid-snapshot-20170601:1.19
	sid-snapshot-20170501:1.19
	sid-snapshot-20170401:1.19
	sid-snapshot-20170301:1.19
	sid-snapshot-20170201:1.19
	sid-snapshot-20170101:1.19
	sid-snapshot-20161201:1.19
	sid-snapshot-20161101:1.19
	sid-snapshot-20160901:1.19
	sid-snapshot-20160801:1.19
	sid-snapshot-20160701:1.19
	sid-snapshot-20160601:1.19
	sid-snapshot-20160501:1.19
	sid-snapshot-20160401:1.19
	sid-snapshot-20160301:1.19
	sid-snapshot-20160201:1.19
	sid-snapshot-20160101:1.19
	sid-snapshot-20151201:1.19
	sid-snapshot-20151101:1.19
	sid-snapshot-20151001:1.19
	sid-snapshot-20150901:1.19
	sid-snapshot-20150801:1.19
	sid-snapshot-20150701:1.19
	sid-snapshot-20150601:1.19
	sid-snapshot-20150501:1.19
	sid-snapshot-20150401:1.19
	sid-snapshot-20150301:1.19
	sid-snapshot-20150201:1.19
	sid-snapshot-20150101:1.19
	sid-snapshot-20141201:1.19
	sid-snapshot-20141101:1.19
	sid-snapshot-20141001:1.19
	sid-snapshot-20140901:1.19
	sid-snapshot-20140801:1.19
	sid-snapshot-20140701:1.19
	sid-snapshot-20140601:1.19
	sid-snapshot-20140501:1.19
	sid-snapshot-20140401:1.19
	sid-snapshot-20140301:1.19
	sid-snapshot-20140201:1.19
	sid-snapshot-20140101:1.19
	sid-snapshot-20131201:1.19
	sid-snapshot-20131101:1.19
	sid-snapshot-20131001:1.19
	binutils-2_24-branch:1.19.0.4
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.16
	sid-snapshot-20130901:1.19
	gdb_7_6_1-2013-08-30-release:1.19
	sid-snapshot-20130801:1.19
	sid-snapshot-20130701:1.19
	sid-snapshot-20130601:1.19
	sid-snapshot-20130501:1.19
	gdb_7_6-2013-04-26-release:1.19
	sid-snapshot-20130401:1.19
	binutils-2_23_2:1.16.20.2
	gdb_7_6-branch:1.19.0.2
	gdb_7_6-2013-03-12-branchpoint:1.19
	sid-snapshot-20130301:1.19
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	gdb_7_5_1-2012-11-29-release:1.16
	binutils-2_23_1:1.16
	sid-snapshot-20121101:1.16
	binutils-2_23:1.16
	sid-snapshot-20121001:1.16
	sid-snapshot-20120901:1.16
	gdb_7_5-2012-08-17-release:1.16
	sid-snapshot-20120801:1.16
	binutils-2_23-branch:1.16.0.20
	binutils-2_23-branchpoint:1.16
	gdb_7_5-branch:1.16.0.18
	gdb_7_5-2012-07-18-branchpoint:1.16
	sid-snapshot-20120701:1.16
	sid-snapshot-20120601:1.16
	sid-snapshot-20120501:1.16
	binutils-2_22_branch:1.16.0.16
	gdb_7_4_1-2012-04-26-release:1.16
	sid-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	sid-snapshot-20120201:1.16
	gdb_7_4-2012-01-24-release:1.16
	sid-snapshot-20120101:1.16
	gdb_7_4-branch:1.16.0.14
	gdb_7_4-2011-12-13-branchpoint:1.16
	sid-snapshot-20111201:1.16
	binutils-2_22:1.16
	sid-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	binutils-2_22-branch:1.16.0.12
	binutils-2_22-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	sid-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	gdb_7_3-2011-07-26-release:1.16
	sid-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	gdb_7_3-branch:1.16.0.10
	gdb_7_3-2011-04-01-branchpoint:1.16
	sid-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	binutils-2_21:1.16
	sid-snapshot-20101201:1.16
	binutils-2_21-branch:1.16.0.8
	binutils-2_21-branchpoint:1.16
	sid-snapshot-20101101:1.16
	sid-snapshot-20101001:1.16
	binutils-2_20_1:1.15.26.1
	gdb_7_2-2010-09-02-release:1.16
	sid-snapshot-20100901:1.16
	sid-snapshot-20100801:1.16
	gdb_7_2-branch:1.16.0.6
	gdb_7_2-2010-07-07-branchpoint:1.16
	sid-snapshot-20100701:1.16
	sid-snapshot-20100601:1.16
	sid-snapshot-20100501:1.16
	sid-snapshot-20100401:1.16
	gdb_7_1-2010-03-18-release:1.16
	sid-snapshot-20100301:1.16
	gdb_7_1-branch:1.16.0.4
	gdb_7_1-2010-02-18-branchpoint:1.16
	sid-snapshot-20100201:1.16
	sid-snapshot-20100101:1.16
	gdb_7_0_1-2009-12-22-release:1.16
	sid-snapshot-20091201:1.16
	sid-snapshot-20091101:1.16
	binutils-2_20:1.15.26.1
	gdb_7_0-2009-10-06-release:1.16
	sid-snapshot-20091001:1.16
	gdb_7_0-branch:1.16.0.2
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.15
	binutils-arc-20081103-branch:1.15.0.28
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.15.0.26
	binutils-2_20-branchpoint:1.15
	sid-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	msnyder-checkpoint-072509-branch:1.15.0.24
	msnyder-checkpoint-072509-branchpoint:1.15
	sid-snapshot-20090701:1.15
	dje-cgen-play1-branch:1.15.0.22
	dje-cgen-play1-branchpoint:1.15
	sid-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	arc-20081103-branch:1.15.0.20
	arc-20081103-branchpoint:1.15
	arc-insight_6_8-branch:1.15.0.18
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.16
	insight_6_8-branchpoint:1.15
	sid-snapshot-20090301:1.15
	binutils-2_19_1:1.15
	sid-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	reverse-20081226-branch:1.15.0.14
	reverse-20081226-branchpoint:1.15
	sid-snapshot-20081201:1.15
	multiprocess-20081120-branch:1.15.0.12
	multiprocess-20081120-branchpoint:1.15
	sid-snapshot-20081101:1.15
	binutils-2_19:1.15
	sid-snapshot-20081001:1.15
	reverse-20080930-branch:1.15.0.10
	reverse-20080930-branchpoint:1.15
	binutils-2_19-branch:1.15.0.8
	binutils-2_19-branchpoint:1.15
	sid-snapshot-20080901:1.15
	sid-snapshot-20080801:1.15
	reverse-20080717-branch:1.15.0.6
	reverse-20080717-branchpoint:1.15
	sid-snapshot-20080701:1.15
	msnyder-reverse-20080609-branch:1.15.0.4
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.12.0.18
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.15
	sid-snapshot-20080501:1.15
	sid-snapshot-20080403:1.15
	sid-snapshot-20080401:1.15
	gdb_6_8-2008-03-27-release:1.15
	sid-snapshot-20080301:1.15
	gdb_6_8-branch:1.15.0.2
	gdb_6_8-2008-02-26-branchpoint:1.15
	sid-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	sid-snapshot-20071001:1.14
	gdb_6_7-branch:1.14.0.4
	gdb_6_7-2007-09-07-branchpoint:1.14
	binutils-2_18:1.14
	binutils-2_18-branch:1.14.0.2
	binutils-2_18-branchpoint:1.14
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.16
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.11
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.11
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.12.0.14
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.12
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.10
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.11
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.12.0.8
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	binutils-2_17-branch:1.12.0.6
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.11.0.16
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.12.0.4
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.2
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.11.0.14
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.12
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.10
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.6
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.4
	gdb-csl-arm-20051020-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.9.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.11.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.6
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.4
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.2
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.18
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.20
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.8
	binutils-2_15:1.8
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.14
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.12
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.8
	drow_intercu-20040221-branchpoint:1.8
	binutils-2_15-branch:1.8.0.6
	cagney_bfdfile-20040213-branch:1.8.0.4
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.2
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	csl-arm-2003-q4:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.7.0.6
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.4
	cagney_x86i386-20030821-branch:1.7.0.2
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.36
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.6
	binutils-2_14:1.6
	cagney_convert-20030606-branch:1.6.0.32
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.30
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.26
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	binutils-2_14-branch:1.6.0.22
	binutils-2_14-branchpoint:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	binutils-2_13_1:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.14
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.12
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.10
	gdb_5_3-branch:1.5.0.8
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.6
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.4
	readline_4_3-import-branchpoint:1.5
	binutils-2_13:1.5
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.2
	kseitz_interps-20020528-branch:1.3.0.10
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.8
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.6
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.4
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	binutils_latest_snapshot:1.19;
locks; strict;
comment	@ * @;


1.19
date	2013.02.18.10.40.19;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.11.14.09.58;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.11.13.55.02;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches
	1.16.20.1;
next	1.15;

1.15
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches
	1.15.26.1;
next	1.14;

1.14
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.04.15.53.11;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.29.22.59.37;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.07.07.25.34;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.10.18.33;	author nickc;	state Exp;
branches
	1.5.12.1
	1.5.14.1;
next	1.4;

1.4
date	2002.06.06.10.47.27;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.18.11.47.59;	author jakub;	state Exp;
branches
	1.3.8.1
	1.3.10.1;
next	1.2;

1.2
date	2001.11.11.22.18.01;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.07.16.50.36;	author jakub;	state Exp;
branches;
next	;

1.16.20.1
date	2013.01.21.13.48.35;	author amodra;	state Exp;
branches;
next	1.16.20.2;

1.16.20.2
date	2013.02.18.11.31.15;	author amodra;	state Exp;
branches;
next	;

1.15.26.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.5.12.1
date	2002.12.23.19.37.38;	author carlton;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2003.09.17.21.27.50;	author carlton;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2003.11.11.23.50.13;	author carlton;	state Exp;
branches;
next	;

1.5.14.1
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.3.10.1
date	2002.06.20.01.30.01;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.19
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): Declare.
	(_bfd_elf_strtab_resize): Declare.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): New function.
	(_bfd_elf_strtab_resize): Likewise.
	* elflink.c (elf_link_add_object_symbols): Use _bfd_elf_strtab_resize.
@
text
@/* ELF strtab with GC and suffix merging support.
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
   Written by Jakub Jelinek <jakub@@redhat.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "hashtab.h"
#include "libiberty.h"

/* An entry in the strtab hash table.  */

struct elf_strtab_hash_entry
{
  struct bfd_hash_entry root;
  /* Length of this entry.  This includes the zero terminator.  */
  int len;
  unsigned int refcount;
  union {
    /* Index within the merged section.  */
    bfd_size_type index;
    /* Entry this is a suffix of (if len < 0).  */
    struct elf_strtab_hash_entry *suffix;
  } u;
};

/* The strtab hash table.  */

struct elf_strtab_hash
{
  struct bfd_hash_table table;
  /* Next available index.  */
  bfd_size_type size;
  /* Number of array entries alloced.  */
  bfd_size_type alloced;
  /* Final strtab size.  */
  bfd_size_type sec_size;
  /* Array of pointers to strtab entries.  */
  struct elf_strtab_hash_entry **array;
};

/* Routine to create an entry in a section merge hashtab.  */

static struct bfd_hash_entry *
elf_strtab_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    entry = (struct bfd_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
  if (entry == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);

  if (entry)
    {
      /* Initialize the local fields.  */
      struct elf_strtab_hash_entry *ret;

      ret = (struct elf_strtab_hash_entry *) entry;
      ret->u.index = -1;
      ret->refcount = 0;
      ret->len = 0;
    }

  return entry;
}

/* Create a new hash table.  */

struct elf_strtab_hash *
_bfd_elf_strtab_init (void)
{
  struct elf_strtab_hash *table;
  bfd_size_type amt = sizeof (struct elf_strtab_hash);

  table = (struct elf_strtab_hash *) bfd_malloc (amt);
  if (table == NULL)
    return NULL;

  if (!bfd_hash_table_init (&table->table, elf_strtab_hash_newfunc,
			    sizeof (struct elf_strtab_hash_entry)))
    {
      free (table);
      return NULL;
    }

  table->sec_size = 0;
  table->size = 1;
  table->alloced = 64;
  amt = sizeof (struct elf_strtab_hasn_entry *);
  table->array = (struct elf_strtab_hash_entry **)
      bfd_malloc (table->alloced * amt);
  if (table->array == NULL)
    {
      free (table);
      return NULL;
    }

  table->array[0] = NULL;

  return table;
}

/* Free a strtab.  */

void
_bfd_elf_strtab_free (struct elf_strtab_hash *tab)
{
  bfd_hash_table_free (&tab->table);
  free (tab->array);
  free (tab);
}

/* Get the index of an entity in a hash table, adding it if it is not
   already present.  */

bfd_size_type
_bfd_elf_strtab_add (struct elf_strtab_hash *tab,
		     const char *str,
		     bfd_boolean copy)
{
  register struct elf_strtab_hash_entry *entry;

  /* We handle this specially, since we don't want to do refcounting
     on it.  */
  if (*str == '\0')
    return 0;

  BFD_ASSERT (tab->sec_size == 0);
  entry = (struct elf_strtab_hash_entry *)
	  bfd_hash_lookup (&tab->table, str, TRUE, copy);

  if (entry == NULL)
    return (bfd_size_type) -1;

  entry->refcount++;
  if (entry->len == 0)
    {
      entry->len = strlen (str) + 1;
      /* 2G strings lose.  */
      BFD_ASSERT (entry->len > 0);
      if (tab->size == tab->alloced)
	{
	  bfd_size_type amt = sizeof (struct elf_strtab_hash_entry *);
	  tab->alloced *= 2;
	  tab->array = (struct elf_strtab_hash_entry **)
              bfd_realloc_or_free (tab->array, tab->alloced * amt);
	  if (tab->array == NULL)
	    return (bfd_size_type) -1;
	}

      entry->u.index = tab->size++;
      tab->array[entry->u.index] = entry;
    }
  return entry->u.index;
}

void
_bfd_elf_strtab_addref (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  if (idx == 0 || idx == (bfd_size_type) -1)
    return;
  BFD_ASSERT (tab->sec_size == 0);
  BFD_ASSERT (idx < tab->size);
  ++tab->array[idx]->refcount;
}

void
_bfd_elf_strtab_delref (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  if (idx == 0 || idx == (bfd_size_type) -1)
    return;
  BFD_ASSERT (tab->sec_size == 0);
  BFD_ASSERT (idx < tab->size);
  BFD_ASSERT (tab->array[idx]->refcount > 0);
  --tab->array[idx]->refcount;
}

unsigned int
_bfd_elf_strtab_refcount (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  return tab->array[idx]->refcount;
}

void
_bfd_elf_strtab_clear_all_refs (struct elf_strtab_hash *tab)
{
  bfd_size_type idx;

  for (idx = 1; idx < tab->size; idx++)
    tab->array[idx]->refcount = 0;
}

/* Downsizes strtab.  Entries from IDX up to the current size are
   removed from the array.  */
void
_bfd_elf_strtab_restore_size (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  bfd_size_type curr_size = tab->size;

  BFD_ASSERT (tab->sec_size == 0);
  BFD_ASSERT (idx <= curr_size);
  tab->size = idx;
  for (; idx < curr_size; ++idx)
    {
      /* We don't remove entries from the hash table, just set their
	 REFCOUNT to zero.  Setting LEN zero will result in the size
	 growing if the entry is added again.  See _bfd_elf_strtab_add.  */
      tab->array[idx]->refcount = 0;
      tab->array[idx]->len = 0;
    }
}

bfd_size_type
_bfd_elf_strtab_size (struct elf_strtab_hash *tab)
{
  return tab->sec_size ? tab->sec_size : tab->size;
}

bfd_size_type
_bfd_elf_strtab_offset (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  struct elf_strtab_hash_entry *entry;

  if (idx == 0)
    return 0;
  BFD_ASSERT (idx < tab->size);
  BFD_ASSERT (tab->sec_size);
  entry = tab->array[idx];
  BFD_ASSERT (entry->refcount > 0);
  entry->refcount--;
  return tab->array[idx]->u.index;
}

bfd_boolean
_bfd_elf_strtab_emit (register bfd *abfd, struct elf_strtab_hash *tab)
{
  bfd_size_type off = 1, i;

  if (bfd_bwrite ("", 1, abfd) != 1)
    return FALSE;

  for (i = 1; i < tab->size; ++i)
    {
      register const char *str;
      register unsigned int len;

      BFD_ASSERT (tab->array[i]->refcount == 0);
      len = tab->array[i]->len;
      if ((int) len < 0)
	continue;

      str = tab->array[i]->root.string;
      if (bfd_bwrite (str, len, abfd) != len)
	return FALSE;

      off += len;
    }

  BFD_ASSERT (off == tab->sec_size);
  return TRUE;
}

/* Compare two elf_strtab_hash_entry structures.  Called via qsort.  */

static int
strrevcmp (const void *a, const void *b)
{
  struct elf_strtab_hash_entry *A = *(struct elf_strtab_hash_entry **) a;
  struct elf_strtab_hash_entry *B = *(struct elf_strtab_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = (const unsigned char *) A->root.string + lenA - 1;
  const unsigned char *t = (const unsigned char *) B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

static inline int
is_suffix (const struct elf_strtab_hash_entry *A,
	   const struct elf_strtab_hash_entry *B)
{
  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len - 1) == 0;
}

/* This function assigns final string table offsets for used strings,
   merging strings matching suffixes of longer strings if possible.  */

void
_bfd_elf_strtab_finalize (struct elf_strtab_hash *tab)
{
  struct elf_strtab_hash_entry **array, **a, *e;
  bfd_size_type size, amt;

  /* GCC 2.91.66 (egcs-1.1.2) on i386 miscompiles this function when i is
     a 64-bit bfd_size_type: a 64-bit target or --enable-64-bit-bfd.
     Besides, indexing with a long long wouldn't give anything but extra
     cycles.  */
  size_t i;

  /* Sort the strings by suffix and length.  */
  amt = tab->size * sizeof (struct elf_strtab_hash_entry *);
  array = (struct elf_strtab_hash_entry **) bfd_malloc (amt);
  if (array == NULL)
    goto alloc_failure;

  for (i = 1, a = array; i < tab->size; ++i)
    {
      e = tab->array[i];
      if (e->refcount)
	{
	  *a++ = e;
	  /* Adjust the length to not include the zero terminator.  */
	  e->len -= 1;
	}
      else
	e->len = 0;
    }

  size = a - array;
  if (size != 0)
    {
      qsort (array, size, sizeof (struct elf_strtab_hash_entry *), strrevcmp);

      /* Loop over the sorted array and merge suffixes.  Start from the
	 end because we want eg.

	 s1 -> "d"
	 s2 -> "bcd"
	 s3 -> "abcd"

	 to end up as

	 s3 -> "abcd"
	 s2 _____^
	 s1 _______^

	 ie. we don't want s1 pointing into the old s2.  */
      e = *--a;
      e->len += 1;
      while (--a >= array)
	{
	  struct elf_strtab_hash_entry *cmp = *a;

	  cmp->len += 1;
	  if (is_suffix (e, cmp))
	    {
	      cmp->u.suffix = e;
	      cmp->len = -cmp->len;
	    }
	  else
	    e = cmp;
	}
    }

alloc_failure:
  if (array)
    free (array);

  /* Assign positions to the strings we want to keep.  */
  size = 1;
  for (i = 1; i < tab->size; ++i)
    {
      e = tab->array[i];
      if (e->refcount && e->len > 0)
	{
	  e->u.index = size;
	  size += e->len;
	}
    }

  tab->sec_size = size;

  /* Adjust the rest.  */
  for (i = 1; i < tab->size; ++i)
    {
      e = tab->array[i];
      if (e->refcount && e->len < 0)
	e->u.index = e->u.suffix->u.index + (e->u.suffix->len + e->len);
    }
}
@


1.18
log
@	* elf-bfd.h (_bfd_elf_strtab_refcount): Declare.
	* elf-strtab.c (_bfd_elf_strtab_refcount): New function.
	* elflink.c (elf_add_dt_needed_tag): Use _bfd_elf_strtab_refcount.
@
text
@d211 1
a211 1
_bfd_elf_strtab_clear_refs (struct elf_strtab_hash *tab, bfd_size_type idx)
d213 24
a236 2
  while (idx < tab->size)
    tab->array[idx++]->refcount = 0;
@


1.17
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Declare.
	(_bfd_elf_strtab_clear_all_refs): Define.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): New function.
	(_bfd_elf_strtab_clear_all_refs): Delete.
	* elflink.c (elf_link_add_object_symbols): Clear out added
	strtab refs.  Correct handling of warning common symbols.
@
text
@d204 6
@


1.16
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d205 1
a205 1
_bfd_elf_strtab_clear_all_refs (struct elf_strtab_hash *tab)
d207 2
a208 4
  bfd_size_type idx;

  for (idx = 1; idx < tab->size; ++idx)
    tab->array[idx]->refcount = 0;
@


1.16.20.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d204 2
a205 2
unsigned int
_bfd_elf_strtab_refcount (struct elf_strtab_hash *tab, bfd_size_type idx)
d207 1
a207 2
  return tab->array[idx]->refcount;
}
d209 2
a210 5
void
_bfd_elf_strtab_clear_refs (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  while (idx < tab->size)
    tab->array[idx++]->refcount = 0;
@


1.16.20.2
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): Declare.
	(_bfd_elf_strtab_resize): Declare.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): New function.
	(_bfd_elf_strtab_resize): Likewise.
	* elflink.c (elf_link_add_object_symbols): Use _bfd_elf_strtab_resize.
@
text
@d211 1
a211 1
_bfd_elf_strtab_clear_all_refs (struct elf_strtab_hash *tab)
d213 2
a214 24
  bfd_size_type idx;

  for (idx = 1; idx < tab->size; idx++)
    tab->array[idx]->refcount = 0;
}

/* Downsizes strtab.  Entries from IDX up to the current size are
   removed from the array.  */
void
_bfd_elf_strtab_restore_size (struct elf_strtab_hash *tab, bfd_size_type idx)
{
  bfd_size_type curr_size = tab->size;

  BFD_ASSERT (tab->sec_size == 0);
  BFD_ASSERT (idx <= curr_size);
  tab->size = idx;
  for (; idx < curr_size; ++idx)
    {
      /* We don't remove entries from the hash table, just set their
	 REFCOUNT to zero.  Setting LEN zero will result in the size
	 growing if the entry is added again.  See _bfd_elf_strtab_add.  */
      tab->array[idx]->refcount = 0;
      tab->array[idx]->len = 0;
    }
@


1.15
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d71 2
a72 1
    entry = bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
d101 1
a101 1
  table = bfd_malloc (amt);
d116 2
a117 1
  table->array = bfd_malloc (table->alloced * amt);
d171 2
a172 1
	  tab->array = bfd_realloc_or_free (tab->array, tab->alloced * amt);
d317 1
a317 1
  array = bfd_malloc (amt);
@


1.15.26.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d71 1
a71 2
    entry = (struct bfd_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
d100 1
a100 1
  table = (struct elf_strtab_hash *) bfd_malloc (amt);
d115 1
a115 2
  table->array = (struct elf_strtab_hash_entry **)
      bfd_malloc (table->alloced * amt);
d169 1
a169 2
	  tab->array = (struct elf_strtab_hash_entry **)
              bfd_realloc_or_free (tab->array, tab->alloced * amt);
d314 1
a314 1
  array = (struct elf_strtab_hash_entry **) bfd_malloc (amt);
@


1.14
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2005, 2006, 2007
d169 1
a169 1
	  tab->array = bfd_realloc (tab->array, tab->alloced * amt);
@


1.13
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.12
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2003, 2005, 2006 Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@


1.11
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
d102 2
a103 1
  if (! bfd_hash_table_init (&table->table, elf_strtab_hash_newfunc))
@


1.10
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.9
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@	* merge.c (struct sec_merge_sec_info): Update comment.
	(struct sec_merge_hash_entry): Remove entsize.
	(sec_merge_hash_lookup): Only adjust alignment when creating.
	(sec_merge_emit): Remove register keyword.
	(cmplengthentry, last4_eq, last_eq): Delete.
	(strrevcmp, strrevcmp_align, is_suffix): New.
	(merge_strings): Use them to implement fast suffix merging.
	* elf-strtab.c (struct elf_strtab_hash_entry): Update comments.
	Make "len" signed.
	(_bfd_elf_strtab_add): Lose on >2G strings.
	(_bfd_elf_strtab_emit): Don't emit strings with len < 0.
	(cmplengthentry, last4_eq): Delete.
	(strrevcmp, is_suffix): New.
	(_bfd_elf_strtab_finalize): Rework to implement fast suffix merging.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d266 2
a267 2
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
@


1.7
log
@	* elf-bfd.h: Remove PARAMS macro.  Replace PTR with void *.
	(NAME): Use ## rather than CONCAT4 macro.
	* elfcode.h: Remove one remaining PARAMS macro.
	* elf-eh-frame.c: Convert to C90, remove unneeded casts and prototypes.
	* elf-strtab.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf32-hppa.h: Likewise.
	* elf32-hppa.c: Likewise.
	(elf32_hppa_add_symbol_hook): Delete.
	(elf_backend_add_symbol_hook): Don't define.
	* libhppa.h: Convert to C90.  Replace INLINE with inline.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d33 2
a34 2
  /* Length of this entry.  */
  unsigned int len;
d39 1
a39 1
    /* Entry this is a suffix of (if len is 0).  */
a40 1
    struct elf_strtab_hash_entry *next;
d160 2
d239 1
a239 1
      register size_t len;
d241 1
a241 1
      str = tab->array[i]->root.string;
d243 1
a243 2
      BFD_ASSERT (tab->array[i]->refcount == 0);
      if (len == 0)
d246 1
d257 1
a257 1
/* Compare two elf_strtab_hash_entry structures.  This is called via qsort.  */
d260 1
a260 1
cmplengthentry (const void *a, const void *b)
d264 5
d270 9
a278 6
  if (A->len < B->len)
    return 1;
  else if (A->len > B->len)
    return -1;

  return memcmp (A->root.string, B->root.string, A->len);
d281 3
a283 2
static int
last4_eq (const void *a, const void *b)
a284 8
  const struct elf_strtab_hash_entry *A = a;
  const struct elf_strtab_hash_entry *B = b;

  if (memcmp (A->root.string + A->len - 5, B->root.string + B->len - 5, 4)
      != 0)
    /* This was a hashtable collision.  */
    return 0;

d291 1
a291 1
		 B->root.string, B->len - 5) == 0;
d300 1
a300 2
  struct elf_strtab_hash_entry **array, **a, **end, *e;
  htab_t last4tab = NULL;
a301 1
  struct elf_strtab_hash_entry *last[256], **last_ptr[256];
d309 1
a309 2
  /* Now sort the strings by length, longest first.  */
  array = NULL;
a314 3
  memset (last, 0, sizeof (last));
  for (i = 0; i < 256; ++i)
    last_ptr[i] = &last[i];
d316 11
a326 4
    if (tab->array[i]->refcount)
      *a++ = tab->array[i];
    else
      tab->array[i]->len = 0;
d329 3
d333 2
a334 1
  qsort (array, size, sizeof (struct elf_strtab_hash_entry *), cmplengthentry);
d336 3
a338 3
  last4tab = htab_create_alloc (size * 4, NULL, last4_eq, NULL, calloc, free);
  if (last4tab == NULL)
    goto alloc_failure;
d340 1
a340 10
  /* Now insert the strings into hash tables (strings with last 4 characters
     and strings with last character equal), look for longer strings which
     we're suffix of.  */
  for (a = array, end = array + size; a < end; a++)
    {
      register hashval_t hash;
      unsigned int c;
      unsigned int j;
      const unsigned char *s;
      void **p;
d342 3
a344 17
      e = *a;
      if (e->len > 4)
	{
	  s = e->root.string + e->len - 1;
	  hash = 0;
	  for (j = 0; j < 4; j++)
	    {
	      c = *--s;
	      hash += c + (c << 17);
	      hash ^= hash >> 2;
	    }
	  p = htab_find_slot_with_hash (last4tab, e, hash, INSERT);
	  if (p == NULL)
	    goto alloc_failure;
	  if (*p)
	    {
	      struct elf_strtab_hash_entry *ent;
d346 4
a349 9
	      ent = *p;
	      e->u.suffix = ent;
	      e->len = 0;
	      continue;
	    }
	  else
	    *p = e;
	}
      else
d351 1
a351 1
	  struct elf_strtab_hash_entry *tem;
d353 2
a354 8
	  c = e->root.string[e->len - 2] & 0xff;

	  for (tem = last[c]; tem; tem = tem->u.next)
	    if (tem->len > e->len
		&& memcmp (tem->root.string + (tem->len - e->len),
			   e->root.string, e->len - 1) == 0)
	      break;
	  if (tem)
d356 2
a357 3
	      e->u.suffix = tem;
	      e->len = 0;
	      continue;
d359 2
a361 6

      c = e->root.string[e->len - 2] & 0xff;
      /* Put longest strings first.  */
      *last_ptr[c] = e;
      last_ptr[c] = &e->u.next;
      e->u.next = NULL;
a366 2
  if (last4tab)
    htab_delete (last4tab);
d368 1
a368 1
  /* Now assign positions to the strings we want to keep.  */
d373 1
a373 1
      if (e->refcount && e->len)
d382 1
a382 1
  /* And now adjust the rest.  */
d386 2
a387 3
      if (e->refcount && ! e->len)
	e->u.index = e->u.suffix->u.index
		     + (e->u.suffix->len - strlen (e->root.string) - 1);
@


1.6
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@a59 5
static struct bfd_hash_entry *elf_strtab_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static int cmplengthentry PARAMS ((const PTR, const PTR));
static int last4_eq PARAMS ((const PTR, const PTR));

d63 3
a65 4
elf_strtab_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
a66 2
  struct elf_strtab_hash_entry *ret = (struct elf_strtab_hash_entry *) entry;

d69 3
a71 4
  if (ret == (struct elf_strtab_hash_entry *) NULL)
    ret = ((struct elf_strtab_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry)));
  if (ret == (struct elf_strtab_hash_entry *) NULL)
d75 1
a75 2
  ret = ((struct elf_strtab_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
d77 1
a77 1
  if (ret)
d80 3
d88 1
a88 1
  return (struct bfd_hash_entry *)ret;
d94 1
a94 1
_bfd_elf_strtab_init ()
d99 1
a99 1
  table = (struct elf_strtab_hash *) bfd_malloc (amt);
d113 1
a113 2
  table->array = (struct elf_strtab_hash_entry **)
		 bfd_malloc (table->alloced * amt);
d128 1
a128 2
_bfd_elf_strtab_free (tab)
     struct elf_strtab_hash *tab;
d139 3
a141 4
_bfd_elf_strtab_add (tab, str, copy)
     struct elf_strtab_hash *tab;
     const char *str;
     bfd_boolean copy;
d165 1
a165 2
	  tab->array = (struct elf_strtab_hash_entry **)
		       bfd_realloc (tab->array, tab->alloced * amt);
d177 1
a177 3
_bfd_elf_strtab_addref (tab, idx)
     struct elf_strtab_hash *tab;
     bfd_size_type idx;
d187 1
a187 3
_bfd_elf_strtab_delref (tab, idx)
     struct elf_strtab_hash *tab;
     bfd_size_type idx;
d198 1
a198 2
_bfd_elf_strtab_clear_all_refs (tab)
     struct elf_strtab_hash *tab;
d207 1
a207 2
_bfd_elf_strtab_size (tab)
     struct elf_strtab_hash *tab;
d213 1
a213 3
_bfd_elf_strtab_offset (tab, idx)
     struct elf_strtab_hash *tab;
     bfd_size_type idx;
d228 1
a228 3
_bfd_elf_strtab_emit (abfd, tab)
     register bfd *abfd;
     struct elf_strtab_hash *tab;
d246 1
a246 1
      if (bfd_bwrite ((PTR) str, (bfd_size_type) len, abfd) != len)
d259 1
a259 3
cmplengthentry (a, b)
     const PTR a;
     const PTR b;
d261 2
a262 2
  struct elf_strtab_hash_entry * A = *(struct elf_strtab_hash_entry **) a;
  struct elf_strtab_hash_entry * B = *(struct elf_strtab_hash_entry **) b;
d273 1
a273 3
last4_eq (a, b)
     const PTR a;
     const PTR b;
d275 2
a276 2
  struct elf_strtab_hash_entry * A = (struct elf_strtab_hash_entry *) a;
  struct elf_strtab_hash_entry * B = (struct elf_strtab_hash_entry *) b;
d296 1
a296 2
_bfd_elf_strtab_finalize (tab)
     struct elf_strtab_hash *tab;
d312 1
a312 1
  array = (struct elf_strtab_hash_entry **) bfd_malloc (amt);
d342 1
a342 1
      PTR *p;
d362 1
a362 1
	      ent = (struct elf_strtab_hash_entry *) *p;
d368 1
a368 1
	    *p = (PTR) e;
@


1.5
log
@Use htab_create_alloc with calloc, not htab_alloc.
@
text
@d151 1
a151 1
     boolean copy;
d162 1
a162 1
	  bfd_hash_lookup (&tab->table, str, true, copy);
d246 1
a246 1
boolean
d254 1
a254 1
    return false;
d268 1
a268 1
	return false;
d274 1
a274 1
  return true;
@


1.5.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d33 2
a34 2
  /* Length of this entry.  This includes the zero terminator.  */
  int len;
d39 1
a39 1
    /* Entry this is a suffix of (if len < 0).  */
d41 1
d60 5
d68 4
a71 3
elf_strtab_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
d73 2
d77 4
a80 3
  if (entry == NULL)
    entry = bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
  if (entry == NULL)
d84 2
a85 1
  entry = bfd_hash_newfunc (entry, table, string);
d87 1
a87 1
  if (entry)
a89 3
      struct elf_strtab_hash_entry *ret;

      ret = (struct elf_strtab_hash_entry *) entry;
d95 1
a95 1
  return entry;
d101 1
a101 1
_bfd_elf_strtab_init (void)
d106 1
a106 1
  table = bfd_malloc (amt);
d120 2
a121 1
  table->array = bfd_malloc (table->alloced * amt);
d136 2
a137 1
_bfd_elf_strtab_free (struct elf_strtab_hash *tab)
d148 4
a151 3
_bfd_elf_strtab_add (struct elf_strtab_hash *tab,
		     const char *str,
		     bfd_boolean copy)
d162 1
a162 1
	  bfd_hash_lookup (&tab->table, str, TRUE, copy);
a170 2
      /* 2G strings lose.  */
      BFD_ASSERT (entry->len > 0);
d175 2
a176 1
	  tab->array = bfd_realloc (tab->array, tab->alloced * amt);
d188 3
a190 1
_bfd_elf_strtab_addref (struct elf_strtab_hash *tab, bfd_size_type idx)
d200 3
a202 1
_bfd_elf_strtab_delref (struct elf_strtab_hash *tab, bfd_size_type idx)
d213 2
a214 1
_bfd_elf_strtab_clear_all_refs (struct elf_strtab_hash *tab)
d223 2
a224 1
_bfd_elf_strtab_size (struct elf_strtab_hash *tab)
d230 3
a232 1
_bfd_elf_strtab_offset (struct elf_strtab_hash *tab, bfd_size_type idx)
d246 4
a249 2
bfd_boolean
_bfd_elf_strtab_emit (register bfd *abfd, struct elf_strtab_hash *tab)
d254 1
a254 1
    return FALSE;
d259 1
a259 1
      register unsigned int len;
d261 2
d264 1
a264 2
      len = tab->array[i]->len;
      if ((int) len < 0)
d267 2
a268 3
      str = tab->array[i]->root.string;
      if (bfd_bwrite (str, len, abfd) != len)
	return FALSE;
d274 1
a274 1
  return TRUE;
d277 1
a277 1
/* Compare two elf_strtab_hash_entry structures.  Called via qsort.  */
d280 11
a290 9
strrevcmp (const void *a, const void *b)
{
  struct elf_strtab_hash_entry *A = *(struct elf_strtab_hash_entry **) a;
  struct elf_strtab_hash_entry *B = *(struct elf_strtab_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;
d292 1
a292 9
  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
d295 13
a307 4
static inline int
is_suffix (const struct elf_strtab_hash_entry *A,
	   const struct elf_strtab_hash_entry *B)
{
d314 1
a314 1
		 B->root.string, B->len - 1) == 0;
d321 2
a322 1
_bfd_elf_strtab_finalize (struct elf_strtab_hash *tab)
d324 2
a325 1
  struct elf_strtab_hash_entry **array, **a, *e;
d327 1
d335 2
a336 1
  /* Sort the strings by suffix and length.  */
d338 1
a338 1
  array = bfd_malloc (amt);
d342 3
d346 4
a349 11
    {
      e = tab->array[i];
      if (e->refcount)
	{
	  *a++ = e;
	  /* Adjust the length to not include the zero terminator.  */
	  e->len -= 1;
	}
      else
	e->len = 0;
    }
a351 3
  if (size != 0)
    {
      qsort (array, size, sizeof (struct elf_strtab_hash_entry *), strrevcmp);
d353 1
a353 2
      /* Loop over the sorted array and merge suffixes.  Start from the
	 end because we want eg.
d355 3
a357 3
	 s1 -> "d"
	 s2 -> "bcd"
	 s3 -> "abcd"
d359 10
a368 1
	 to end up as
d370 17
a386 3
	 s3 -> "abcd"
	 s2 _____^
	 s1 _______^
d388 9
a396 4
	 ie. we don't want s1 pointing into the old s2.  */
      e = *--a;
      e->len += 1;
      while (--a >= array)
d398 3
a400 1
	  struct elf_strtab_hash_entry *cmp = *a;
d402 6
a407 2
	  cmp->len += 1;
	  if (is_suffix (e, cmp))
d409 3
a411 2
	      cmp->u.suffix = e;
	      cmp->len = -cmp->len;
a412 2
	  else
	    e = cmp;
d414 6
d425 2
d428 1
a428 1
  /* Assign positions to the strings we want to keep.  */
d433 1
a433 1
      if (e->refcount && e->len > 0)
d442 1
a442 1
  /* Adjust the rest.  */
d446 3
a448 2
      if (e->refcount && e->len < 0)
	e->u.index = e->u.suffix->u.index + (e->u.suffix->len + e->len);
@


1.5.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d151 1
a151 1
     bfd_boolean copy;
d162 1
a162 1
	  bfd_hash_lookup (&tab->table, str, TRUE, copy);
d246 1
a246 1
bfd_boolean
d254 1
a254 1
    return FALSE;
d268 1
a268 1
	return FALSE;
d274 1
a274 1
  return TRUE;
@


1.5.12.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d60 5
d68 4
a71 3
elf_strtab_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
d73 2
d77 4
a80 3
  if (entry == NULL)
    entry = bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
  if (entry == NULL)
d84 2
a85 1
  entry = bfd_hash_newfunc (entry, table, string);
d87 1
a87 1
  if (entry)
a89 3
      struct elf_strtab_hash_entry *ret;

      ret = (struct elf_strtab_hash_entry *) entry;
d95 1
a95 1
  return entry;
d101 1
a101 1
_bfd_elf_strtab_init (void)
d106 1
a106 1
  table = bfd_malloc (amt);
d120 2
a121 1
  table->array = bfd_malloc (table->alloced * amt);
d136 2
a137 1
_bfd_elf_strtab_free (struct elf_strtab_hash *tab)
d148 4
a151 3
_bfd_elf_strtab_add (struct elf_strtab_hash *tab,
		     const char *str,
		     bfd_boolean copy)
d175 2
a176 1
	  tab->array = bfd_realloc (tab->array, tab->alloced * amt);
d188 3
a190 1
_bfd_elf_strtab_addref (struct elf_strtab_hash *tab, bfd_size_type idx)
d200 3
a202 1
_bfd_elf_strtab_delref (struct elf_strtab_hash *tab, bfd_size_type idx)
d213 2
a214 1
_bfd_elf_strtab_clear_all_refs (struct elf_strtab_hash *tab)
d223 2
a224 1
_bfd_elf_strtab_size (struct elf_strtab_hash *tab)
d230 3
a232 1
_bfd_elf_strtab_offset (struct elf_strtab_hash *tab, bfd_size_type idx)
d247 3
a249 1
_bfd_elf_strtab_emit (register bfd *abfd, struct elf_strtab_hash *tab)
d267 1
a267 1
      if (bfd_bwrite (str, len, abfd) != len)
d280 3
a282 1
cmplengthentry (const void *a, const void *b)
d284 2
a285 2
  struct elf_strtab_hash_entry *A = *(struct elf_strtab_hash_entry **) a;
  struct elf_strtab_hash_entry *B = *(struct elf_strtab_hash_entry **) b;
d296 3
a298 1
last4_eq (const void *a, const void *b)
d300 2
a301 2
  const struct elf_strtab_hash_entry *A = a;
  const struct elf_strtab_hash_entry *B = b;
d321 2
a322 1
_bfd_elf_strtab_finalize (struct elf_strtab_hash *tab)
d338 1
a338 1
  array = bfd_malloc (amt);
d368 1
a368 1
      void **p;
d388 1
a388 1
	      ent = *p;
d394 1
a394 1
	    *p = e;
@


1.5.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d33 2
a34 2
  /* Length of this entry.  This includes the zero terminator.  */
  int len;
d39 1
a39 1
    /* Entry this is a suffix of (if len < 0).  */
d41 1
a160 2
      /* 2G strings lose.  */
      BFD_ASSERT (entry->len > 0);
d238 1
a238 1
      register unsigned int len;
d240 2
d243 1
a243 2
      len = tab->array[i]->len;
      if ((int) len < 0)
a245 1
      str = tab->array[i]->root.string;
d256 1
a256 1
/* Compare two elf_strtab_hash_entry structures.  Called via qsort.  */
d259 1
a259 1
strrevcmp (const void *a, const void *b)
a262 5
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;
d264 6
a269 9
  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
d272 2
a273 3
static inline int
is_suffix (const struct elf_strtab_hash_entry *A,
	   const struct elf_strtab_hash_entry *B)
d275 8
d289 1
a289 1
		 B->root.string, B->len - 1) == 0;
d298 2
a299 1
  struct elf_strtab_hash_entry **array, **a, *e;
d301 1
d309 2
a310 1
  /* Sort the strings by suffix and length.  */
d316 3
d320 4
a323 11
    {
      e = tab->array[i];
      if (e->refcount)
	{
	  *a++ = e;
	  /* Adjust the length to not include the zero terminator.  */
	  e->len -= 1;
	}
      else
	e->len = 0;
    }
a325 3
  if (size != 0)
    {
      qsort (array, size, sizeof (struct elf_strtab_hash_entry *), strrevcmp);
d327 1
a327 2
      /* Loop over the sorted array and merge suffixes.  Start from the
	 end because we want eg.
d329 3
a331 3
	 s1 -> "d"
	 s2 -> "bcd"
	 s3 -> "abcd"
d333 10
a342 1
	 to end up as
d344 17
a360 3
	 s3 -> "abcd"
	 s2 _____^
	 s1 _______^
d362 9
a370 4
	 ie. we don't want s1 pointing into the old s2.  */
      e = *--a;
      e->len += 1;
      while (--a >= array)
d372 1
a372 1
	  struct elf_strtab_hash_entry *cmp = *a;
d374 8
a381 2
	  cmp->len += 1;
	  if (is_suffix (e, cmp))
d383 3
a385 2
	      cmp->u.suffix = e;
	      cmp->len = -cmp->len;
a386 2
	  else
	    e = cmp;
d388 6
d399 2
d402 1
a402 1
  /* Assign positions to the strings we want to keep.  */
d407 1
a407 1
      if (e->refcount && e->len > 0)
d416 1
a416 1
  /* Adjust the rest.  */
d420 3
a422 2
      if (e->refcount && e->len < 0)
	e->u.index = e->u.suffix->u.index + (e->u.suffix->len + e->len);
@


1.4
log
@Include libiberty.h
@
text
@d355 1
a355 1
  last4tab = htab_create (size * 4, NULL, last4_eq, NULL);
@


1.3
log
@	* elf-strtab.c (struct elf_strtab_hash_entry): Add u.next.
	(last_eq): Remove.
	(_bfd_elf_strtab_finalize): Don't use a hash table for last
	character chains, instead use an array.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 4
a10 4
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d12 4
a15 4
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d17 3
a19 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 1
@


1.3.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a25 1
#include "libiberty.h"
d354 1
a354 1
  last4tab = htab_create_alloc (size * 4, NULL, last4_eq, NULL, calloc, free);
@


1.3.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a25 1
#include "libiberty.h"
d354 1
a354 1
  last4tab = htab_create_alloc (size * 4, NULL, last4_eq, NULL, calloc, free);
@


1.2
log
@	* elf-strtab.c (_bfd_elf_strtab_finalize): Make first variable i
	size_t.  Rename second i to j.
@
text
@d40 1
a62 1
static int last_eq PARAMS ((const PTR, const PTR));
a315 27
static int
last_eq (a, b)
     const PTR a;
     const PTR b;
{
  struct elf_strtab_hash_entry * A = (struct elf_strtab_hash_entry *) a;
  struct elf_strtab_hash_entry * B = (struct elf_strtab_hash_entry *) b;

  if (B->len >= 5)
    /* Longer strings are just pushed into the hash table,
       they'll be used when looking up for very short strings.  */
    return 0;

  if (memcmp (A->root.string + A->len - 2, B->root.string + B->len - 2, 1)
      != 0)
    /* This was a hashtable collision.  */
    return 0;

  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len - 2) == 0;
}

d324 1
a324 1
  htab_t lasttab = NULL, last4tab = NULL;
d326 1
d341 3
d355 1
a355 2
  lasttab = htab_create (size * 4, NULL, last_eq, NULL);
  if (lasttab == NULL || last4tab == NULL)
d395 1
a395 5
      c = (unsigned char) e->root.string[e->len - 1];
      p = htab_find_slot_with_hash (lasttab, e, c, INSERT);
      if (p == NULL)
	goto alloc_failure;
      if (*p)
d397 1
a397 1
	  struct elf_strtab_hash_entry *ent;
d399 13
a411 3
	  ent = (struct elf_strtab_hash_entry *) *p;
	  e->u.suffix = ent;
	  e->len = 0;
d413 6
a418 2
      else
	*p = (PTR) e;
a423 2
  if (lasttab)
    htab_delete (lasttab);
@


1.1
log
@	* Makefile.am (BFD32_BACKENDS): Add elf-strtab.lo.
	(BFD32_BACKENDS_CFILES): Add elf-strtab.c.
	(elf-strtab.lo): Add rule.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-strtab.lo.
	* configure: Rebuilt.
	* elf-bfd.h (elf_strtab_hash): Forward declare.
	(struct elf_link_hash_table): Change dynstr type to
	struct elf_strtab_hash *.
	(struct elf_obj_tdata): Change strtab_ptr type to
	struct elf_strtab_hash *.
	(_bfd_elf_strtab_init, _bfd_elf_strtab_free, _bfd_elf_strtab_add,
	_bfd_elf_strtab_addref, _bfd_elf_strtab_delref,
	_bfd_elf_strtab_clear_all_refs, _bfd_elf_strtab_size,
	_bfd_elf_strtab_offset, _bfd_elf_strtab_emit,
	_bfd_elf_strtab_finalize): New prototypes.
	* elf-strtab.c: New file.
	* elflink.h (elf_link_add_object_symbols): Use _bfd_elf_strtab_add
	and _bfd_elf_strtab_size instead of _bfd_stringtab calls.
	Call _bfd_elf_strtab_delref if DT_NEEDED entry is not needed or
	when forcing dynamic symbol to local.
	(elf_link_create_dynamic_sections): Call
	_bfd_elf_strtab_init instead of elf_stringtab_init.
	(elf_link_record_local_dynamic_symbol): Likewise, change
	dynstr type.  Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.
	(size_dynamic_sections): Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.  For DT_RUNPATH and Verdaux vda_name fields,
	call _bfd_elf_strtab_addref.  Call elf_finalize_dynstr.
	(elf_adjust_dynstr_offsets, elf_finalize_dynstr): New functions.
	(elf_fix_symbol_flags): Call _bfd_elf_strtab_delref when forcing
	dynamic symbol to local.
	(elf_link_assign_sym_version): Likewise.
	(elf_bfd_final_link): Call _bfd_elf_strtab_emit instead of
	_bfd_stringtab_emit.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Change dynstr
	type.  Call _bfd_elf_strtab functions instead of
	_bfd_stringtab functions.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.
	* elf.c (_bfd_elf_init_reloc_shdr): Likewise.
	(elf_fake_sections): Likewise.
	(assign_section_numbers): Call _bfd_elf_strtab_clear_all_refs
	on shstrtab hash table, call _bfd_elf_strtab_addref on each section
	name in the output.  Call _bfd_elf_strtab_finalize and
	use _bfd_elf_strtab_offset to finalize sh_name section header fields.
	(_bfd_elf_compute_section_file_positions): Use _bfd_elf_strtab_size
	instead of _bfd_stringtab_size.
	(prep_headers): Change shstrtab type.
	Use _bfd_elf_strtab calls instead of _bfd_stringtab calls.
@
text
@d352 7
a358 1
  bfd_size_type size, amt, i;
d389 1
a389 1
      unsigned int i;
d398 1
a398 1
	  for (i = 0; i < 4; i++)
@

