head	1.14;
access;
symbols
	sid-snapshot-20180601:1.14
	sid-snapshot-20180501:1.14
	sid-snapshot-20180401:1.14
	sid-snapshot-20180301:1.14
	sid-snapshot-20180201:1.14
	sid-snapshot-20180101:1.14
	sid-snapshot-20171201:1.14
	sid-snapshot-20171101:1.14
	sid-snapshot-20171001:1.14
	sid-snapshot-20170901:1.14
	sid-snapshot-20170801:1.14
	sid-snapshot-20170701:1.14
	sid-snapshot-20170601:1.14
	sid-snapshot-20170501:1.14
	sid-snapshot-20170401:1.14
	sid-snapshot-20170301:1.14
	sid-snapshot-20170201:1.14
	sid-snapshot-20170101:1.14
	sid-snapshot-20161201:1.14
	sid-snapshot-20161101:1.14
	sid-snapshot-20160901:1.14
	sid-snapshot-20160801:1.14
	sid-snapshot-20160701:1.14
	sid-snapshot-20160601:1.14
	sid-snapshot-20160501:1.14
	sid-snapshot-20160401:1.14
	sid-snapshot-20160301:1.14
	sid-snapshot-20160201:1.14
	sid-snapshot-20160101:1.14
	sid-snapshot-20151201:1.14
	sid-snapshot-20151101:1.14
	sid-snapshot-20151001:1.14
	sid-snapshot-20150901:1.14
	sid-snapshot-20150801:1.14
	sid-snapshot-20150701:1.14
	sid-snapshot-20150601:1.14
	sid-snapshot-20150501:1.14
	sid-snapshot-20150401:1.14
	sid-snapshot-20150301:1.14
	sid-snapshot-20150201:1.14
	sid-snapshot-20150101:1.14
	sid-snapshot-20141201:1.14
	sid-snapshot-20141101:1.14
	sid-snapshot-20141001:1.14
	sid-snapshot-20140901:1.14
	sid-snapshot-20140801:1.14
	sid-snapshot-20140701:1.14
	sid-snapshot-20140601:1.14
	sid-snapshot-20140501:1.14
	sid-snapshot-20140401:1.14
	sid-snapshot-20140301:1.14
	sid-snapshot-20140201:1.14
	sid-snapshot-20140101:1.14
	sid-snapshot-20131201:1.14
	sid-snapshot-20131101:1.14
	sid-snapshot-20131001:1.14
	binutils-2_24-branch:1.14.0.4
	binutils-2_24-branchpoint:1.14
	binutils-2_21_1:1.13
	sid-snapshot-20130901:1.14
	gdb_7_6_1-2013-08-30-release:1.14
	sid-snapshot-20130801:1.14
	sid-snapshot-20130701:1.14
	sid-snapshot-20130601:1.14
	sid-snapshot-20130501:1.14
	gdb_7_6-2013-04-26-release:1.14
	sid-snapshot-20130401:1.14
	binutils-2_23_2:1.13
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	sid-snapshot-20130301:1.14
	sid-snapshot-20130201:1.14
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	gdb_7_5_1-2012-11-29-release:1.13
	binutils-2_23_1:1.13
	sid-snapshot-20121101:1.13
	binutils-2_23:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	gdb_7_5-2012-08-17-release:1.13
	sid-snapshot-20120801:1.13
	binutils-2_23-branch:1.13.0.52
	binutils-2_23-branchpoint:1.13
	gdb_7_5-branch:1.13.0.50
	gdb_7_5-2012-07-18-branchpoint:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	binutils-2_22_branch:1.13.0.48
	gdb_7_4_1-2012-04-26-release:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	gdb_7_4-2012-01-24-release:1.13
	sid-snapshot-20120101:1.13
	gdb_7_4-branch:1.13.0.46
	gdb_7_4-2011-12-13-branchpoint:1.13
	sid-snapshot-20111201:1.13
	binutils-2_22:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	binutils-2_22-branch:1.13.0.44
	binutils-2_22-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	gdb_7_3-2011-07-26-release:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	gdb_7_3-branch:1.13.0.42
	gdb_7_3-2011-04-01-branchpoint:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	binutils-2_21:1.13
	sid-snapshot-20101201:1.13
	binutils-2_21-branch:1.13.0.40
	binutils-2_21-branchpoint:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	binutils-2_20_1:1.13
	gdb_7_2-2010-09-02-release:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	gdb_7_2-branch:1.13.0.38
	gdb_7_2-2010-07-07-branchpoint:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	gdb_7_1-2010-03-18-release:1.13
	sid-snapshot-20100301:1.13
	gdb_7_1-branch:1.13.0.36
	gdb_7_1-2010-02-18-branchpoint:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	gdb_7_0_1-2009-12-22-release:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	binutils-2_20:1.13
	gdb_7_0-2009-10-06-release:1.13
	sid-snapshot-20091001:1.13
	gdb_7_0-branch:1.13.0.34
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.13.0.32
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.13.0.30
	binutils-2_20-branchpoint:1.13
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	msnyder-checkpoint-072509-branch:1.13.0.28
	msnyder-checkpoint-072509-branchpoint:1.13
	sid-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.26
	dje-cgen-play1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.13.0.24
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.22
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.20
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.18
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.16
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.14
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.12
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.10
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.8
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.12.0.34
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.6
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.4
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.32
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.30
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.28
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.26
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.12
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.12.0.24
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	binutils-2_17-branch:1.12.0.22
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.20
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.18
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.16
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.14
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.12
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.10
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.6
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.4
	gdb-csl-arm-20051020-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.9.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.12.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.12
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.6
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.4
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.2
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.4
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.6
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.60
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.58
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.56
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.54
	drow_intercu-20040221-branchpoint:1.7
	binutils-2_15-branch:1.7.0.52
	cagney_bfdfile-20040213-branch:1.7.0.50
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.48
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	csl-arm-2003-q4:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.46
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.44
	cagney_x86i386-20030821-branch:1.7.0.42
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.40
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.38
	jimb-ppc64-linux-20030613-branchpoint:1.7
	binutils-2_14:1.7
	cagney_convert-20030606-branch:1.7.0.36
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.34
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.32
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.30
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.28
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	binutils-2_14-branch:1.7.0.26
	binutils-2_14-branchpoint:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.24
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.22
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.20
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.18
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.16
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.14
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.12
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.10
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.8
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.6
	cagney-unwind-20030108-branchpoint:1.7
	binutils-2_13_2_1:1.6
	binutils-2_13_2:1.6
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.7
	binutils-2_13_1:1.6
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.4
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.2
	carlton_dictionary-20020920-branchpoint:1.7
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.20
	gdb_5_3-branch:1.6.0.18
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.16
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.14
	readline_4_3-import-branchpoint:1.6
	binutils-2_13:1.6
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.6
	binutils-2_13-branch:1.6.0.12
	kseitz_interps-20020528-branch:1.6.0.10
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.8
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.3.2.2
	binutils-2_11_1:1.3.2.2
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.14
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.04.15.53.07;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.11.08.23.01;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.03.11.40.59;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.27.05.45.50;	author shebs;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.19.15.31.30;	author nickc;	state Exp;
branches
	1.7.54.1;
next	1.6;

1.6
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	2001.05.07.09.15.25;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.03.22.53.38;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.07.11.06.37.34;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.7.54.1
date	2004.04.02.16.47.33;	author drow;	state Exp;
branches;
next	;

1.6.10.1
date	2002.10.01.00.45.45;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.06.11.10.04.08;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* Generic ECOFF swapping routines, for BFD.
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002, 2004, 2005,
   2007  Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* NOTE: This is a header file, but it contains executable routines.
   This is done this way because these routines are substantially
   similar, but are not identical, for all ECOFF targets.

   These are routines to swap the ECOFF symbolic information in and
   out.  The routines are defined statically.  You can set breakpoints
   on them in gdb by naming the including source file; e.g.,
   'coff-mips.c':ecoff_swap_hdr_in.

   Before including this header file, one of ECOFF_32, ECOFF_64,
   ECOFF_SIGNED_32 or ECOFF_SIGNED_64 must be defined.  These are
   checked when swapping information that depends upon the target
   size.  This code works for 32 bit and 64 bit ECOFF, but may need to
   be generalized in the future.

   Some header file which defines the external forms of these
   structures must also be included before including this header file.
   Currently this is either coff/mips.h or coff/alpha.h.

   If the symbol TEST is defined when this file is compiled, a
   comparison is made to ensure that, in fact, the output is
   bit-for-bit the same as the input.  Of course, this symbol should
   only be defined when deliberately testing the code on a machine
   with the proper byte sex and such.  */

#ifdef ECOFF_32
#define ECOFF_GET_OFF H_GET_32
#define ECOFF_PUT_OFF H_PUT_32
#endif
#ifdef ECOFF_64
#define ECOFF_GET_OFF H_GET_64
#define ECOFF_PUT_OFF H_PUT_64
#endif
#ifdef ECOFF_SIGNED_32
#define ECOFF_GET_OFF H_GET_S32
#define ECOFF_PUT_OFF H_PUT_S32
#endif
#ifdef ECOFF_SIGNED_64
#define ECOFF_GET_OFF H_GET_S64
#define ECOFF_PUT_OFF H_PUT_S64
#endif

/* ECOFF auxiliary information swapping routines.  These are the same
   for all ECOFF targets, so they are defined in ecofflink.c.  */

extern void _bfd_ecoff_swap_tir_in
  (int, const struct tir_ext *, TIR *);
extern void _bfd_ecoff_swap_tir_out
  (int, const TIR *, struct tir_ext *);
extern void _bfd_ecoff_swap_rndx_in
  (int, const struct rndx_ext *, RNDXR *);
extern void _bfd_ecoff_swap_rndx_out
  (int, const RNDXR *, struct rndx_ext *);

/* Prototypes for functions defined in this file.  */

static void ecoff_swap_hdr_in (bfd *, void *, HDRR *);
static void ecoff_swap_hdr_out (bfd *, const HDRR *, void *);
static void ecoff_swap_fdr_in (bfd *, void *, FDR *);
static void ecoff_swap_fdr_out (bfd *, const FDR *, void *);
static void ecoff_swap_pdr_in (bfd *, void *, PDR *);
static void ecoff_swap_pdr_out (bfd *, const PDR *, void *);
static void ecoff_swap_sym_in (bfd *, void *, SYMR *);
static void ecoff_swap_sym_out (bfd *, const SYMR *, void *);
static void ecoff_swap_ext_in (bfd *, void *, EXTR *);
static void ecoff_swap_ext_out (bfd *, const EXTR *, void *);
static void ecoff_swap_rfd_in (bfd *, void *, RFDT *);
static void ecoff_swap_rfd_out (bfd *, const RFDT *, void *);
static void ecoff_swap_opt_in (bfd *, void *, OPTR *);
static void ecoff_swap_opt_out (bfd *, const OPTR *, void *);
static void ecoff_swap_dnr_in (bfd *, void *, DNR *);
static void ecoff_swap_dnr_out (bfd *, const DNR *, void *);

/* Swap in the symbolic header.  */

static void
ecoff_swap_hdr_in (bfd *abfd, void * ext_copy, HDRR *intern)
{
  struct hdr_ext ext[1];

  *ext = *(struct hdr_ext *) ext_copy;

  intern->magic         = H_GET_S16     (abfd, ext->h_magic);
  intern->vstamp        = H_GET_S16     (abfd, ext->h_vstamp);
  intern->ilineMax      = H_GET_32      (abfd, ext->h_ilineMax);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->h_cbLine);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->h_cbLineOffset);
  intern->idnMax        = H_GET_32      (abfd, ext->h_idnMax);
  intern->cbDnOffset    = ECOFF_GET_OFF (abfd, ext->h_cbDnOffset);
  intern->ipdMax        = H_GET_32      (abfd, ext->h_ipdMax);
  intern->cbPdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbPdOffset);
  intern->isymMax       = H_GET_32      (abfd, ext->h_isymMax);
  intern->cbSymOffset   = ECOFF_GET_OFF (abfd, ext->h_cbSymOffset);
  intern->ioptMax       = H_GET_32      (abfd, ext->h_ioptMax);
  intern->cbOptOffset   = ECOFF_GET_OFF (abfd, ext->h_cbOptOffset);
  intern->iauxMax       = H_GET_32      (abfd, ext->h_iauxMax);
  intern->cbAuxOffset   = ECOFF_GET_OFF (abfd, ext->h_cbAuxOffset);
  intern->issMax        = H_GET_32      (abfd, ext->h_issMax);
  intern->cbSsOffset    = ECOFF_GET_OFF (abfd, ext->h_cbSsOffset);
  intern->issExtMax     = H_GET_32      (abfd, ext->h_issExtMax);
  intern->cbSsExtOffset = ECOFF_GET_OFF (abfd, ext->h_cbSsExtOffset);
  intern->ifdMax        = H_GET_32      (abfd, ext->h_ifdMax);
  intern->cbFdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbFdOffset);
  intern->crfd          = H_GET_32      (abfd, ext->h_crfd);
  intern->cbRfdOffset   = ECOFF_GET_OFF (abfd, ext->h_cbRfdOffset);
  intern->iextMax       = H_GET_32      (abfd, ext->h_iextMax);
  intern->cbExtOffset   = ECOFF_GET_OFF (abfd, ext->h_cbExtOffset);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the symbolic header.  */

static void
ecoff_swap_hdr_out (bfd *abfd, const HDRR *intern_copy, void * ext_ptr)
{
  struct hdr_ext *ext = (struct hdr_ext *) ext_ptr;
  HDRR intern[1];

  *intern = *intern_copy;

  H_PUT_S16     (abfd, intern->magic,         ext->h_magic);
  H_PUT_S16     (abfd, intern->vstamp,        ext->h_vstamp);
  H_PUT_32      (abfd, intern->ilineMax,      ext->h_ilineMax);
  ECOFF_PUT_OFF (abfd, intern->cbLine,        ext->h_cbLine);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset,  ext->h_cbLineOffset);
  H_PUT_32      (abfd, intern->idnMax,        ext->h_idnMax);
  ECOFF_PUT_OFF (abfd, intern->cbDnOffset,    ext->h_cbDnOffset);
  H_PUT_32      (abfd, intern->ipdMax,        ext->h_ipdMax);
  ECOFF_PUT_OFF (abfd, intern->cbPdOffset,    ext->h_cbPdOffset);
  H_PUT_32      (abfd, intern->isymMax,       ext->h_isymMax);
  ECOFF_PUT_OFF (abfd, intern->cbSymOffset,   ext->h_cbSymOffset);
  H_PUT_32      (abfd, intern->ioptMax,       ext->h_ioptMax);
  ECOFF_PUT_OFF (abfd, intern->cbOptOffset,   ext->h_cbOptOffset);
  H_PUT_32      (abfd, intern->iauxMax,       ext->h_iauxMax);
  ECOFF_PUT_OFF (abfd, intern->cbAuxOffset,   ext->h_cbAuxOffset);
  H_PUT_32      (abfd, intern->issMax,        ext->h_issMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsOffset,    ext->h_cbSsOffset);
  H_PUT_32      (abfd, intern->issExtMax,     ext->h_issExtMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsExtOffset, ext->h_cbSsExtOffset);
  H_PUT_32      (abfd, intern->ifdMax,        ext->h_ifdMax);
  ECOFF_PUT_OFF (abfd, intern->cbFdOffset,    ext->h_cbFdOffset);
  H_PUT_32      (abfd, intern->crfd,          ext->h_crfd);
  ECOFF_PUT_OFF (abfd, intern->cbRfdOffset,   ext->h_cbRfdOffset);
  H_PUT_32      (abfd, intern->iextMax,       ext->h_iextMax);
  ECOFF_PUT_OFF (abfd, intern->cbExtOffset,   ext->h_cbExtOffset);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in the file descriptor record.  */

static void
ecoff_swap_fdr_in (bfd *abfd, void * ext_copy, FDR *intern)
{
  struct fdr_ext ext[1];

  *ext = *(struct fdr_ext *) ext_copy;

  intern->adr           = ECOFF_GET_OFF (abfd, ext->f_adr);
  intern->rss           = H_GET_32 (abfd, ext->f_rss);
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->rss == (signed long) 0xffffffff)
    intern->rss = -1;
#endif
  intern->issBase       = H_GET_32 (abfd, ext->f_issBase);
  intern->cbSs          = ECOFF_GET_OFF (abfd, ext->f_cbSs);
  intern->isymBase      = H_GET_32 (abfd, ext->f_isymBase);
  intern->csym          = H_GET_32 (abfd, ext->f_csym);
  intern->ilineBase     = H_GET_32 (abfd, ext->f_ilineBase);
  intern->cline         = H_GET_32 (abfd, ext->f_cline);
  intern->ioptBase      = H_GET_32 (abfd, ext->f_ioptBase);
  intern->copt          = H_GET_32 (abfd, ext->f_copt);
#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  intern->ipdFirst      = H_GET_16 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_16 (abfd, ext->f_cpd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  intern->ipdFirst      = H_GET_32 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_32 (abfd, ext->f_cpd);
#endif
  intern->iauxBase      = H_GET_32 (abfd, ext->f_iauxBase);
  intern->caux          = H_GET_32 (abfd, ext->f_caux);
  intern->rfdBase       = H_GET_32 (abfd, ext->f_rfdBase);
  intern->crfd          = H_GET_32 (abfd, ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
			    >> FDR_BITS1_LANG_SH_BIG);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
			    >> FDR_BITS2_GLEVEL_SH_BIG);
    }
  else
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
			    >> FDR_BITS1_LANG_SH_LITTLE);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
			    >> FDR_BITS2_GLEVEL_SH_LITTLE);
    }
  intern->reserved = 0;

  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->f_cbLineOffset);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->f_cbLine);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the file descriptor record.  */

static void
ecoff_swap_fdr_out (bfd *abfd, const FDR *intern_copy, void * ext_ptr)
{
  struct fdr_ext *ext = (struct fdr_ext *) ext_ptr;
  FDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,       ext->f_adr);
  H_PUT_32      (abfd, intern->rss,       ext->f_rss);
  H_PUT_32      (abfd, intern->issBase,   ext->f_issBase);
  ECOFF_PUT_OFF (abfd, intern->cbSs,      ext->f_cbSs);
  H_PUT_32      (abfd, intern->isymBase,  ext->f_isymBase);
  H_PUT_32      (abfd, intern->csym,      ext->f_csym);
  H_PUT_32      (abfd, intern->ilineBase, ext->f_ilineBase);
  H_PUT_32      (abfd, intern->cline,     ext->f_cline);
  H_PUT_32      (abfd, intern->ioptBase,  ext->f_ioptBase);
  H_PUT_32      (abfd, intern->copt,      ext->f_copt);
#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  H_PUT_16      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_16      (abfd, intern->cpd,       ext->f_cpd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_32      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_32      (abfd, intern->cpd,       ext->f_cpd);
#endif
  H_PUT_32      (abfd, intern->iauxBase,  ext->f_iauxBase);
  H_PUT_32      (abfd, intern->caux,      ext->f_caux);
  H_PUT_32      (abfd, intern->rfdBase,   ext->f_rfdBase);
  H_PUT_32      (abfd, intern->crfd,      ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			  & FDR_BITS1_LANG_BIG)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
			 & FDR_BITS2_GLEVEL_BIG);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }
  else
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			  & FDR_BITS1_LANG_LITTLE)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
			 & FDR_BITS2_GLEVEL_LITTLE);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }

  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->f_cbLineOffset);
  ECOFF_PUT_OFF (abfd, intern->cbLine, ext->f_cbLine);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in the procedure descriptor record.  */

static void
ecoff_swap_pdr_in (bfd *abfd, void * ext_copy, PDR *intern)
{
  struct pdr_ext ext[1];

  *ext = *(struct pdr_ext *) ext_copy;

  memset ((void *) intern, 0, sizeof (*intern));

  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->isym == (signed long) 0xffffffff)
    intern->isym = -1;
  if (intern->iline == (signed long) 0xffffffff)
    intern->iline = -1;

  intern->gp_prologue = H_GET_8 (abfd, ext->p_gp_prologue);
  if (bfd_header_big_endian (abfd))
    {
      intern->gp_used = 0 != (ext->p_bits1[0] & PDR_BITS1_GP_USED_BIG);
      intern->reg_frame = 0 != (ext->p_bits1[0] & PDR_BITS1_REG_FRAME_BIG);
      intern->prof = 0 != (ext->p_bits1[0] & PDR_BITS1_PROF_BIG);
      intern->reserved = (((ext->p_bits1[0] & PDR_BITS1_RESERVED_BIG)
			   << PDR_BITS1_RESERVED_SH_LEFT_BIG)
			  | ((ext->p_bits2[0] & PDR_BITS2_RESERVED_BIG)
			     >> PDR_BITS2_RESERVED_SH_BIG));
    }
  else
    {
      intern->gp_used = 0 != (ext->p_bits1[0] & PDR_BITS1_GP_USED_LITTLE);
      intern->reg_frame = 0 != (ext->p_bits1[0] & PDR_BITS1_REG_FRAME_LITTLE);
      intern->prof = 0 != (ext->p_bits1[0] & PDR_BITS1_PROF_LITTLE);
      intern->reserved = (((ext->p_bits1[0] & PDR_BITS1_RESERVED_LITTLE)
			   >> PDR_BITS1_RESERVED_SH_LITTLE)
			  | ((ext->p_bits2[0] & PDR_BITS2_RESERVED_LITTLE)
			     << PDR_BITS2_RESERVED_SH_LEFT_LITTLE));
    }
  intern->localoff = H_GET_8 (abfd, ext->p_localoff);
#endif

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the procedure descriptor record.  */

static void
ecoff_swap_pdr_out (bfd *abfd, const PDR *intern_copy, void * ext_ptr)
{
  struct pdr_ext *ext = (struct pdr_ext *) ext_ptr;
  PDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_8       (abfd, intern->gp_prologue,  ext->p_gp_prologue);

  if (bfd_header_big_endian (abfd))
    {
      ext->p_bits1[0] = ((intern->gp_used ? PDR_BITS1_GP_USED_BIG : 0)
			 | (intern->reg_frame ? PDR_BITS1_REG_FRAME_BIG : 0)
			 | (intern->prof ? PDR_BITS1_PROF_BIG : 0)
			 | ((intern->reserved
			     >> PDR_BITS1_RESERVED_SH_LEFT_BIG)
			    & PDR_BITS1_RESERVED_BIG));
      ext->p_bits2[0] = ((intern->reserved << PDR_BITS2_RESERVED_SH_BIG)
			 & PDR_BITS2_RESERVED_BIG);
    }
  else
    {
      ext->p_bits1[0] = ((intern->gp_used ? PDR_BITS1_GP_USED_LITTLE : 0)
			 | (intern->reg_frame ? PDR_BITS1_REG_FRAME_LITTLE : 0)
			 | (intern->prof ? PDR_BITS1_PROF_LITTLE : 0)
			 | ((intern->reserved << PDR_BITS1_RESERVED_SH_LITTLE)
			    & PDR_BITS1_RESERVED_LITTLE));
      ext->p_bits2[0] = ((intern->reserved >>
			  PDR_BITS2_RESERVED_SH_LEFT_LITTLE)
			 & PDR_BITS2_RESERVED_LITTLE);
    }
  H_PUT_8 (abfd, intern->localoff, ext->p_localoff);
#endif

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a symbol record.  */

static void
ecoff_swap_sym_in (bfd *abfd, void * ext_copy, SYMR *intern)
{
  struct sym_ext ext[1];

  *ext = *(struct sym_ext *) ext_copy;

  intern->iss           = H_GET_32 (abfd, ext->s_iss);
  intern->value         = ECOFF_GET_OFF (abfd, ext->s_value);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->iss == (signed long) 0xffffffff)
    intern->iss = -1;
#endif

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					     >> SYM_BITS1_ST_SH_BIG;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					     << SYM_BITS1_SC_SH_LEFT_BIG)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					     >> SYM_BITS2_SC_SH_BIG);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					     << SYM_BITS2_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					     >> SYM_BITS1_ST_SH_LITTLE;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					     >> SYM_BITS1_SC_SH_LITTLE)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					     << SYM_BITS2_SC_SH_LEFT_LITTLE);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					     >> SYM_BITS2_INDEX_SH_LITTLE)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			  | ((unsigned int) ext->s_bits4[0]
			     << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
    }

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a symbol record.  */

static void
ecoff_swap_sym_out (bfd *abfd, const SYMR *intern_copy, void * ext_ptr)
{
  struct sym_ext *ext = (struct sym_ext *) ext_ptr;
  SYMR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  H_PUT_32 (abfd, intern->iss, ext->s_iss);
  ECOFF_PUT_OFF (abfd, intern->value, ext->s_value);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			  & SYM_BITS1_ST_BIG)
			 | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			    & SYM_BITS1_SC_BIG));
      ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			  & SYM_BITS2_SC_BIG)
			 | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
			 | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			    & SYM_BITS2_INDEX_BIG));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
    }
  else
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			  & SYM_BITS1_ST_LITTLE)
			 | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			    & SYM_BITS1_SC_LITTLE));
      ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			  & SYM_BITS2_SC_LITTLE)
			 | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
			 | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			    & SYM_BITS2_INDEX_LITTLE));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
    }

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in an external symbol record.  */

static void
ecoff_swap_ext_in (bfd *abfd, void * ext_copy, EXTR *intern)
{
  struct ext_ext ext[1];

  *ext = *(struct ext_ext *) ext_copy;

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
    }
  else
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
    }
  intern->reserved = 0;

#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  intern->ifd = H_GET_S16 (abfd, ext->es_ifd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  intern->ifd = H_GET_S32 (abfd, ext->es_ifd);
#endif

  ecoff_swap_sym_in (abfd, &ext->es_asym, &intern->asym);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out an external symbol record.  */

static void
ecoff_swap_ext_out (bfd *abfd, const EXTR *intern_copy, void * ext_ptr)
{
  struct ext_ext *ext = (struct ext_ext *) ext_ptr;
  EXTR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
      ext->es_bits2[0] = 0;
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
#endif
    }
  else
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
      ext->es_bits2[0] = 0;
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
#endif
    }

#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  H_PUT_S16 (abfd, intern->ifd, ext->es_ifd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_S32 (abfd, intern->ifd, ext->es_ifd);
#endif

  ecoff_swap_sym_out (abfd, &intern->asym, &ext->es_asym);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a relative file descriptor.  */

static void
ecoff_swap_rfd_in (bfd *abfd, void * ext_ptr, RFDT *intern)
{
  struct rfd_ext *ext = (struct rfd_ext *) ext_ptr;

  *intern = H_GET_32 (abfd, ext->rfd);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a relative file descriptor.  */

static void
ecoff_swap_rfd_out (bfd *abfd, const RFDT *intern, void * ext_ptr)
{
  struct rfd_ext *ext = (struct rfd_ext *) ext_ptr;

  H_PUT_32 (abfd, *intern, ext->rfd);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in an optimization symbol.  */

static void
ecoff_swap_opt_in (bfd *abfd, void * ext_copy, OPTR * intern)
{
  struct opt_ext ext[1];

  *ext = *(struct opt_ext *) ext_copy;

  if (bfd_header_big_endian (abfd))
    {
      intern->ot = ext->o_bits1[0];
      intern->value = (((unsigned int) ext->o_bits2[0]
			<< OPT_BITS2_VALUE_SH_LEFT_BIG)
		       | ((unsigned int) ext->o_bits3[0]
			  << OPT_BITS2_VALUE_SH_LEFT_BIG)
		       | ((unsigned int) ext->o_bits4[0]
			  << OPT_BITS2_VALUE_SH_LEFT_BIG));
    }
  else
    {
      intern->ot = ext->o_bits1[0];
      intern->value = ((ext->o_bits2[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE)
		       | (ext->o_bits3[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE)
		       | (ext->o_bits4[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE));
    }

  _bfd_ecoff_swap_rndx_in (bfd_header_big_endian (abfd),
			   &ext->o_rndx, &intern->rndx);

  intern->offset = H_GET_32 (abfd, ext->o_offset);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out an optimization symbol.  */

static void
ecoff_swap_opt_out (bfd *abfd, const OPTR *intern_copy, void * ext_ptr)
{
  struct opt_ext *ext = (struct opt_ext *) ext_ptr;
  OPTR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  if (bfd_header_big_endian (abfd))
    {
      ext->o_bits1[0] = intern->ot;
      ext->o_bits2[0] = intern->value >> OPT_BITS2_VALUE_SH_LEFT_BIG;
      ext->o_bits3[0] = intern->value >> OPT_BITS3_VALUE_SH_LEFT_BIG;
      ext->o_bits4[0] = intern->value >> OPT_BITS4_VALUE_SH_LEFT_BIG;
    }
  else
    {
      ext->o_bits1[0] = intern->ot;
      ext->o_bits2[0] = intern->value >> OPT_BITS2_VALUE_SH_LEFT_LITTLE;
      ext->o_bits3[0] = intern->value >> OPT_BITS3_VALUE_SH_LEFT_LITTLE;
      ext->o_bits4[0] = intern->value >> OPT_BITS4_VALUE_SH_LEFT_LITTLE;
    }

  _bfd_ecoff_swap_rndx_out (bfd_header_big_endian (abfd),
			    &intern->rndx, &ext->o_rndx);

  H_PUT_32 (abfd, intern->value, ext->o_offset);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a dense number.  */

static void
ecoff_swap_dnr_in (bfd *abfd, void * ext_copy, DNR *intern)
{
  struct dnr_ext ext[1];

  *ext = *(struct dnr_ext *) ext_copy;

  intern->rfd = H_GET_32 (abfd, ext->d_rfd);
  intern->index = H_GET_32 (abfd, ext->d_index);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a dense number.  */

static void
ecoff_swap_dnr_out (bfd *abfd, const DNR *intern_copy, void * ext_ptr)
{
  struct dnr_ext *ext = (struct dnr_ext *) ext_ptr;
  DNR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  H_PUT_32 (abfd, intern->rfd, ext->d_rfd);
  H_PUT_32 (abfd, intern->index, ext->d_index);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}
@


1.13
log
@Switch sources over to use the GPL version 3
@
text
@d454 1
a454 1
#endif  
@


1.12
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002, 2004, 2005
   Free Software Foundation, Inc.
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.11
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.10
log
@Convert to ISO C90 formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.9
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002, 2004
d68 1
a68 1
  PARAMS ((int, const struct tir_ext *, TIR *));
d70 1
a70 1
  PARAMS ((int, const TIR *, struct tir_ext *));
d72 1
a72 1
  PARAMS ((int, const struct rndx_ext *, RNDXR *));
d74 1
a74 1
  PARAMS ((int, const RNDXR *, struct rndx_ext *));
d78 16
a93 16
static void ecoff_swap_hdr_in PARAMS ((bfd *, PTR, HDRR *));
static void ecoff_swap_hdr_out PARAMS ((bfd *, const HDRR *, PTR));
static void ecoff_swap_fdr_in PARAMS ((bfd *, PTR, FDR *));
static void ecoff_swap_fdr_out PARAMS ((bfd *, const FDR *, PTR));
static void ecoff_swap_pdr_in PARAMS ((bfd *, PTR, PDR *));
static void ecoff_swap_pdr_out PARAMS ((bfd *, const PDR *, PTR));
static void ecoff_swap_sym_in PARAMS ((bfd *, PTR, SYMR *));
static void ecoff_swap_sym_out PARAMS ((bfd *, const SYMR *, PTR));
static void ecoff_swap_ext_in PARAMS ((bfd *, PTR, EXTR *));
static void ecoff_swap_ext_out PARAMS ((bfd *, const EXTR *, PTR));
static void ecoff_swap_rfd_in PARAMS ((bfd *, PTR, RFDT *));
static void ecoff_swap_rfd_out PARAMS ((bfd *, const RFDT *, PTR));
static void ecoff_swap_opt_in PARAMS ((bfd *, PTR, OPTR *));
static void ecoff_swap_opt_out PARAMS ((bfd *, const OPTR *, PTR));
static void ecoff_swap_dnr_in PARAMS ((bfd *, PTR, DNR *));
static void ecoff_swap_dnr_out PARAMS ((bfd *, const DNR *, PTR));
d98 1
a98 4
ecoff_swap_hdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     HDRR *intern;
d131 1
a131 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d139 1
a139 4
ecoff_swap_hdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const HDRR *intern_copy;
     PTR ext_ptr;
d181 1
a181 4
ecoff_swap_fdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     FDR *intern;
d241 1
a241 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d249 1
a249 4
ecoff_swap_fdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const FDR *intern_copy;
     PTR ext_ptr;
d310 1
a310 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d318 1
a318 4
ecoff_swap_pdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     PDR *intern;
d324 1
a324 1
  memset ((PTR) intern, 0, sizeof (*intern));
d372 1
a372 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d380 1
a380 4
ecoff_swap_pdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const PDR *intern_copy;
     PTR ext_ptr;
d432 1
a432 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d440 1
a440 4
ecoff_swap_sym_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     SYMR *intern;
d486 1
a486 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d494 1
a494 4
ecoff_swap_sym_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const SYMR *intern_copy;
     PTR ext_ptr;
d536 1
a536 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d544 1
a544 4
ecoff_swap_ext_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     EXTR *intern;
d575 1
a575 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d583 1
a583 4
ecoff_swap_ext_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const EXTR *intern_copy;
     PTR ext_ptr;
d625 1
a625 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d633 1
a633 4
ecoff_swap_rfd_in (abfd, ext_ptr, intern)
     bfd *abfd;
     PTR ext_ptr;
     RFDT *intern;
d640 1
a640 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d648 1
a648 4
ecoff_swap_rfd_out (abfd, intern, ext_ptr)
     bfd *abfd;
     const RFDT *intern;
     PTR ext_ptr;
d655 1
a655 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d663 1
a663 4
ecoff_swap_opt_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     OPTR *intern;
d693 1
a693 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d701 1
a701 4
ecoff_swap_opt_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const OPTR *intern_copy;
     PTR ext_ptr;
d730 1
a730 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d738 1
a738 4
ecoff_swap_dnr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     DNR *intern;
d748 1
a748 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d756 1
a756 4
ecoff_swap_dnr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const DNR *intern_copy;
     PTR ext_ptr;
d768 1
a768 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
@


1.8
log
@        Remove MPW support, no longer used.
        * config.bfd (powerpc-*-mpw*): Remove configuration.
        * mpw-config.in, mpw-make.sed: Remove files.
        * ecoffswap.h [MPW_C]: Remove MPW-C-friendly version of code.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
@


1.7
log
@Update to correctly sign-extend 32-bit ECOFF null values (0xffffffff, -1)
@
text
@a326 2
#ifndef MPW_C

a453 72

#else /* MPW_C */
/* Same routines, but with ECOFF_64 code removed, so ^&%$#&! MPW C doesn't
   corrupt itself and then freak out.  */
/* Swap in the procedure descriptor record.  */

static void
ecoff_swap_pdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     PDR *intern;
{
  struct pdr_ext ext[1];

  *ext = *(struct pdr_ext *) ext_copy;

  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the procedure descriptor record.  */

static void
ecoff_swap_pdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const PDR *intern_copy;
     PTR ext_ptr;
{
  struct pdr_ext *ext = (struct pdr_ext *) ext_ptr;
  PDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}
#endif /* MPW_C */
@


1.7.54.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d327 2
d456 72
@


1.6
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d223 1
a223 1
  /* now the fun stuff...  */
d266 2
a267 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d292 1
a292 1
  /* now the fun stuff...  */
d359 5
d405 2
a406 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d504 2
a505 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d544 35
a578 27
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					   >> SYM_BITS1_ST_SH_BIG;
    intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					   << SYM_BITS1_SC_SH_LEFT_BIG)
			| ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					   >> SYM_BITS2_SC_SH_BIG);
    intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
    intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					   << SYM_BITS2_INDEX_SH_LEFT_BIG)
			| (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			| (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
  } else {
    intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					   >> SYM_BITS1_ST_SH_LITTLE;
    intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					   >> SYM_BITS1_SC_SH_LITTLE)
			| ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					   << SYM_BITS2_SC_SH_LEFT_LITTLE);
    intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
    intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					   >> SYM_BITS2_INDEX_SH_LITTLE)
			| (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			| ((unsigned int) ext->s_bits4[0]
			   << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
  }
d597 2
a598 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d603 29
a631 26
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			& SYM_BITS1_ST_BIG)
		       | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			  & SYM_BITS1_SC_BIG));
    ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			& SYM_BITS2_SC_BIG)
		       | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
		       | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			  & SYM_BITS2_INDEX_BIG));
    ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
    ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
  } else {
    ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			& SYM_BITS1_ST_LITTLE)
		       | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			  & SYM_BITS1_SC_LITTLE));
    ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			& SYM_BITS2_SC_LITTLE)
		       | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
		       | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			  & SYM_BITS2_INDEX_LITTLE));
    ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
    ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
  }
d651 13
a663 10
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
    intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
    intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
  } else {
    intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
    intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
    intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
  }
d667 1
a667 1
  intern->ifd           = H_GET_S16 (abfd, ext->es_ifd);
d670 1
a670 1
  intern->ifd           = H_GET_S32 (abfd, ext->es_ifd);
d692 2
a693 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d695 7
a701 6
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			| (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			| (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
    ext->es_bits2[0] = 0;
d703 2
a704 2
    ext->es_bits2[1] = 0;
    ext->es_bits2[2] = 0;
d706 7
a712 5
  } else {
    ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			| (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			| (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
    ext->es_bits2[0] = 0;
d714 2
a715 2
    ext->es_bits2[1] = 0;
    ext->es_bits2[2] = 0;
d717 1
a717 1
  }
d822 2
a823 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d883 2
a884 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
@


1.6.10.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d223 1
a223 1
  /* Now the fun stuff...  */
d266 1
a266 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d291 1
a291 1
  /* Now the fun stuff...  */
a357 5
  if (intern->isym == (signed long) 0xffffffff)
    intern->isym = -1;
  if (intern->iline == (signed long) 0xffffffff)
    intern->iline = -1;

d399 1
a399 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d497 1
a497 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d536 27
a562 35
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->iss == (signed long) 0xffffffff)
    intern->iss = -1;
#endif  

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					     >> SYM_BITS1_ST_SH_BIG;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					     << SYM_BITS1_SC_SH_LEFT_BIG)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					     >> SYM_BITS2_SC_SH_BIG);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					     << SYM_BITS2_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					     >> SYM_BITS1_ST_SH_LITTLE;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					     >> SYM_BITS1_SC_SH_LITTLE)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					     << SYM_BITS2_SC_SH_LEFT_LITTLE);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					     >> SYM_BITS2_INDEX_SH_LITTLE)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			  | ((unsigned int) ext->s_bits4[0]
			     << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
    }
d581 1
a581 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d586 26
a611 29
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			  & SYM_BITS1_ST_BIG)
			 | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			    & SYM_BITS1_SC_BIG));
      ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			  & SYM_BITS2_SC_BIG)
			 | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
			 | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			    & SYM_BITS2_INDEX_BIG));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
    }
  else
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			  & SYM_BITS1_ST_LITTLE)
			 | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			    & SYM_BITS1_SC_LITTLE));
      ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			  & SYM_BITS2_SC_LITTLE)
			 | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
			 | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			    & SYM_BITS2_INDEX_LITTLE));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
    }
d631 10
a640 13
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
    }
  else
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
    }
d644 1
a644 1
  intern->ifd = H_GET_S16 (abfd, ext->es_ifd);
d647 1
a647 1
  intern->ifd = H_GET_S32 (abfd, ext->es_ifd);
d669 1
a669 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d671 6
a676 7
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
      ext->es_bits2[0] = 0;
d678 2
a679 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d681 5
a685 7
    }
  else
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
      ext->es_bits2[0] = 0;
d687 2
a688 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d690 1
a690 1
    }
d795 1
a795 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d855 1
a855 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
@


1.5
log
@	* ecoff.c (bfd_debug_section): Fix initialization.
	* elf.c (_bfd_elf_slurp_version_tables): Change maxidx to unsigned, it
	is always a positive integer. Cast away sign mismatch.
	* elf32-mips.c: Fix misleading comment and typo.
	(_bfd_mips_elf_section_from_bfd_section): Remove unused attribute, use
	correct data type.
	* elflink.c: Fix typo.
	(_bfd_elf_create_dynamic_sections): Remove superfluous initialization.
	* ecoffswap.h (ecoff_swap_fdr_in): Cast away sign mismatch.
@
text
@d48 2
a49 2
#define ecoff_get_off bfd_h_get_32
#define ecoff_put_off bfd_h_put_32
d52 2
a53 2
#define ecoff_get_off bfd_h_get_64
#define ecoff_put_off bfd_h_put_64
d56 2
a57 2
#define ecoff_get_off bfd_h_get_signed_32
#define ecoff_put_off bfd_h_put_signed_32
d60 2
a61 2
#define ecoff_get_off bfd_h_get_signed_64
#define ecoff_put_off bfd_h_put_signed_64
d107 25
a131 25
  intern->magic         = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->h_magic);
  intern->vstamp        = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->h_vstamp);
  intern->ilineMax      = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ilineMax);
  intern->cbLine        = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbLine);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbLineOffset);
  intern->idnMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_idnMax);
  intern->cbDnOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbDnOffset);
  intern->ipdMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ipdMax);
  intern->cbPdOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbPdOffset);
  intern->isymMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_isymMax);
  intern->cbSymOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSymOffset);
  intern->ioptMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ioptMax);
  intern->cbOptOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbOptOffset);
  intern->iauxMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_iauxMax);
  intern->cbAuxOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbAuxOffset);
  intern->issMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_issMax);
  intern->cbSsOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSsOffset);
  intern->issExtMax     = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_issExtMax);
  intern->cbSsExtOffset = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSsExtOffset);
  intern->ifdMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ifdMax);
  intern->cbFdOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbFdOffset);
  intern->crfd          = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_crfd);
  intern->cbRfdOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbRfdOffset);
  intern->iextMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_iextMax);
  intern->cbExtOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbExtOffset);
d152 25
a176 25
  bfd_h_put_signed_16 (abfd, intern->magic, (bfd_byte *)ext->h_magic);
  bfd_h_put_signed_16 (abfd, intern->vstamp, (bfd_byte *)ext->h_vstamp);
  bfd_h_put_32 (abfd, intern->ilineMax, (bfd_byte *)ext->h_ilineMax);
  ecoff_put_off (abfd, intern->cbLine, (bfd_byte *)ext->h_cbLine);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->h_cbLineOffset);
  bfd_h_put_32 (abfd, intern->idnMax, (bfd_byte *)ext->h_idnMax);
  ecoff_put_off (abfd, intern->cbDnOffset, (bfd_byte *)ext->h_cbDnOffset);
  bfd_h_put_32 (abfd, intern->ipdMax, (bfd_byte *)ext->h_ipdMax);
  ecoff_put_off (abfd, intern->cbPdOffset, (bfd_byte *)ext->h_cbPdOffset);
  bfd_h_put_32 (abfd, intern->isymMax, (bfd_byte *)ext->h_isymMax);
  ecoff_put_off (abfd, intern->cbSymOffset, (bfd_byte *)ext->h_cbSymOffset);
  bfd_h_put_32 (abfd, intern->ioptMax, (bfd_byte *)ext->h_ioptMax);
  ecoff_put_off (abfd, intern->cbOptOffset, (bfd_byte *)ext->h_cbOptOffset);
  bfd_h_put_32 (abfd, intern->iauxMax, (bfd_byte *)ext->h_iauxMax);
  ecoff_put_off (abfd, intern->cbAuxOffset, (bfd_byte *)ext->h_cbAuxOffset);
  bfd_h_put_32 (abfd, intern->issMax, (bfd_byte *)ext->h_issMax);
  ecoff_put_off (abfd, intern->cbSsOffset, (bfd_byte *)ext->h_cbSsOffset);
  bfd_h_put_32 (abfd, intern->issExtMax, (bfd_byte *)ext->h_issExtMax);
  ecoff_put_off (abfd, intern->cbSsExtOffset, (bfd_byte *)ext->h_cbSsExtOffset);
  bfd_h_put_32 (abfd, intern->ifdMax, (bfd_byte *)ext->h_ifdMax);
  ecoff_put_off (abfd, intern->cbFdOffset, (bfd_byte *)ext->h_cbFdOffset);
  bfd_h_put_32 (abfd, intern->crfd, (bfd_byte *)ext->h_crfd);
  ecoff_put_off (abfd, intern->cbRfdOffset, (bfd_byte *)ext->h_cbRfdOffset);
  bfd_h_put_32 (abfd, intern->iextMax, (bfd_byte *)ext->h_iextMax);
  ecoff_put_off (abfd, intern->cbExtOffset, (bfd_byte *)ext->h_cbExtOffset);
d179 1
a179 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d196 2
a197 2
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->f_adr);
  intern->rss           = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_rss);
d202 8
a209 8
  intern->issBase       = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_issBase);
  intern->cbSs          = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbSs);
  intern->isymBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_isymBase);
  intern->csym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_csym);
  intern->ilineBase     = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ilineBase);
  intern->cline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_cline);
  intern->ioptBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ioptBase);
  intern->copt          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_copt);
d211 2
a212 2
  intern->ipdFirst      = bfd_h_get_16 (abfd, (bfd_byte *)ext->f_ipdFirst);
  intern->cpd           = bfd_h_get_16 (abfd, (bfd_byte *)ext->f_cpd);
d215 2
a216 2
  intern->ipdFirst      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ipdFirst);
  intern->cpd           = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_cpd);
d218 4
a221 4
  intern->iauxBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_iauxBase);
  intern->caux          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_caux);
  intern->rfdBase       = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_rfdBase);
  intern->crfd          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_crfd);
d224 20
a243 17
  if (bfd_header_big_endian (abfd)) {
    intern->lang        = (ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
					>> FDR_BITS1_LANG_SH_BIG;
    intern->fMerge      = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
    intern->fReadin     = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
    intern->fBigendian  = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
    intern->glevel      = (ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
					>> FDR_BITS2_GLEVEL_SH_BIG;
  } else {
    intern->lang        = (ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
					>> FDR_BITS1_LANG_SH_LITTLE;
    intern->fMerge      = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
    intern->fReadin     = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
    intern->fBigendian  = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
    intern->glevel      = (ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
					>> FDR_BITS2_GLEVEL_SH_LITTLE;
  }
d246 2
a247 2
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbLineOffset);
  intern->cbLine        = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbLine);
d268 10
a277 10
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->f_adr);
  bfd_h_put_32 (abfd, intern->rss, (bfd_byte *)ext->f_rss);
  bfd_h_put_32 (abfd, intern->issBase, (bfd_byte *)ext->f_issBase);
  ecoff_put_off (abfd, intern->cbSs, (bfd_byte *)ext->f_cbSs);
  bfd_h_put_32 (abfd, intern->isymBase, (bfd_byte *)ext->f_isymBase);
  bfd_h_put_32 (abfd, intern->csym, (bfd_byte *)ext->f_csym);
  bfd_h_put_32 (abfd, intern->ilineBase, (bfd_byte *)ext->f_ilineBase);
  bfd_h_put_32 (abfd, intern->cline, (bfd_byte *)ext->f_cline);
  bfd_h_put_32 (abfd, intern->ioptBase, (bfd_byte *)ext->f_ioptBase);
  bfd_h_put_32 (abfd, intern->copt, (bfd_byte *)ext->f_copt);
d279 2
a280 2
  bfd_h_put_16 (abfd, intern->ipdFirst, (bfd_byte *)ext->f_ipdFirst);
  bfd_h_put_16 (abfd, intern->cpd, (bfd_byte *)ext->f_cpd);
d283 2
a284 2
  bfd_h_put_32 (abfd, intern->ipdFirst, (bfd_byte *)ext->f_ipdFirst);
  bfd_h_put_32 (abfd, intern->cpd, (bfd_byte *)ext->f_cpd);
d286 4
a289 4
  bfd_h_put_32 (abfd, intern->iauxBase, (bfd_byte *)ext->f_iauxBase);
  bfd_h_put_32 (abfd, intern->caux, (bfd_byte *)ext->f_caux);
  bfd_h_put_32 (abfd, intern->rfdBase, (bfd_byte *)ext->f_rfdBase);
  bfd_h_put_32 (abfd, intern->crfd, (bfd_byte *)ext->f_crfd);
d292 24
a315 21
  if (bfd_header_big_endian (abfd)) {
    ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			& FDR_BITS1_LANG_BIG)
		       | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
		       | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
		       | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
    ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
		       & FDR_BITS2_GLEVEL_BIG);
    ext->f_bits2[1] = 0;
    ext->f_bits2[2] = 0;
  } else {
    ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			& FDR_BITS1_LANG_LITTLE)
		       | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
		       | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
		       | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
    ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
		       & FDR_BITS2_GLEVEL_LITTLE);
    ext->f_bits2[1] = 0;
    ext->f_bits2[2] = 0;
  }
d317 2
a318 2
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->f_cbLineOffset);
  ecoff_put_off (abfd, intern->cbLine, (bfd_byte *)ext->f_cbLine);
d342 14
a355 17
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->p_adr);
  intern->isym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_isym);
  intern->iline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_iline);
  intern->regmask       = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_regmask);
  intern->regoffset     = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_regoffset);
  intern->iopt          = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->p_iopt);
  intern->fregmask      = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_fregmask);
  intern->fregoffset    = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_fregoffset);
  intern->frameoffset   = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_frameoffset);
  intern->framereg      = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_framereg);
  intern->pcreg         = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_pcreg);
  intern->lnLow         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnLow);
  intern->lnHigh        = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnHigh);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->p_cbLineOffset);
d358 1
a358 1
  intern->gp_prologue = bfd_h_get_8 (abfd, (bfd_byte *) ext->p_gp_prologue);
d379 1
a379 1
  intern->localoff = bfd_h_get_8 (abfd, (bfd_byte *) ext->p_localoff);
d401 14
a414 14
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->p_adr);
  bfd_h_put_32 (abfd, intern->isym, (bfd_byte *)ext->p_isym);
  bfd_h_put_32 (abfd, intern->iline, (bfd_byte *)ext->p_iline);
  bfd_h_put_32 (abfd, intern->regmask, (bfd_byte *)ext->p_regmask);
  bfd_h_put_32 (abfd, intern->regoffset, (bfd_byte *)ext->p_regoffset);
  bfd_h_put_32 (abfd, intern->iopt, (bfd_byte *)ext->p_iopt);
  bfd_h_put_32 (abfd, intern->fregmask, (bfd_byte *)ext->p_fregmask);
  bfd_h_put_32 (abfd, intern->fregoffset, (bfd_byte *)ext->p_fregoffset);
  bfd_h_put_32 (abfd, intern->frameoffset, (bfd_byte *)ext->p_frameoffset);
  bfd_h_put_16 (abfd, intern->framereg, (bfd_byte *)ext->p_framereg);
  bfd_h_put_16 (abfd, intern->pcreg, (bfd_byte *)ext->p_pcreg);
  bfd_h_put_32 (abfd, intern->lnLow, (bfd_byte *)ext->p_lnLow);
  bfd_h_put_32 (abfd, intern->lnHigh, (bfd_byte *)ext->p_lnHigh);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->p_cbLineOffset);
d417 2
a418 1
  bfd_h_put_8 (abfd, intern->gp_prologue, (bfd_byte *) ext->p_gp_prologue);
d441 1
a441 1
  bfd_h_put_8 (abfd, intern->localoff, (bfd_byte *) ext->p_localoff);
d465 14
a478 17
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->p_adr);
  intern->isym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_isym);
  intern->iline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_iline);
  intern->regmask       = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_regmask);
  intern->regoffset     = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_regoffset);
  intern->iopt          = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->p_iopt);
  intern->fregmask      = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_fregmask);
  intern->fregoffset    = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_fregoffset);
  intern->frameoffset   = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_frameoffset);
  intern->framereg      = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_framereg);
  intern->pcreg         = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_pcreg);
  intern->lnLow         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnLow);
  intern->lnHigh        = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnHigh);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->p_cbLineOffset);
d499 14
a512 14
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->p_adr);
  bfd_h_put_32 (abfd, intern->isym, (bfd_byte *)ext->p_isym);
  bfd_h_put_32 (abfd, intern->iline, (bfd_byte *)ext->p_iline);
  bfd_h_put_32 (abfd, intern->regmask, (bfd_byte *)ext->p_regmask);
  bfd_h_put_32 (abfd, intern->regoffset, (bfd_byte *)ext->p_regoffset);
  bfd_h_put_32 (abfd, intern->iopt, (bfd_byte *)ext->p_iopt);
  bfd_h_put_32 (abfd, intern->fregmask, (bfd_byte *)ext->p_fregmask);
  bfd_h_put_32 (abfd, intern->fregoffset, (bfd_byte *)ext->p_fregoffset);
  bfd_h_put_32 (abfd, intern->frameoffset, (bfd_byte *)ext->p_frameoffset);
  bfd_h_put_16 (abfd, intern->framereg, (bfd_byte *)ext->p_framereg);
  bfd_h_put_16 (abfd, intern->pcreg, (bfd_byte *)ext->p_pcreg);
  bfd_h_put_32 (abfd, intern->lnLow, (bfd_byte *)ext->p_lnLow);
  bfd_h_put_32 (abfd, intern->lnHigh, (bfd_byte *)ext->p_lnHigh);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->p_cbLineOffset);
d533 2
a534 2
  intern->iss           = bfd_h_get_32 (abfd, (bfd_byte *)ext->s_iss);
  intern->value         = ecoff_get_off (abfd, (bfd_byte *)ext->s_value);
d583 2
a584 2
  bfd_h_put_32 (abfd, intern->iss, (bfd_byte *)ext->s_iss);
  ecoff_put_off (abfd, intern->value, (bfd_byte *)ext->s_value);
d644 1
a644 1
  intern->ifd           = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->es_ifd);
d647 1
a647 1
  intern->ifd           = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->es_ifd);
d693 1
a693 1
  bfd_h_put_signed_16 (abfd, intern->ifd, (bfd_byte *)ext->es_ifd);
d696 1
a696 1
  bfd_h_put_signed_32 (abfd, intern->ifd, (bfd_byte *)ext->es_ifd);
d717 1
a717 1
  *intern = bfd_h_get_32 (abfd, (bfd_byte *)ext->rfd);
d735 1
a735 1
  bfd_h_put_32 (abfd, *intern, (bfd_byte *)ext->rfd);
d776 1
a776 1
  intern->offset = bfd_h_get_32 (abfd, (bfd_byte *) ext->o_offset);
d815 1
a815 1
  bfd_h_put_32 (abfd, intern->value, (bfd_byte *) ext->o_offset);
d835 2
a836 2
  intern->rfd = bfd_h_get_32 (abfd, (bfd_byte *) ext->d_rfd);
  intern->index = bfd_h_get_32 (abfd, (bfd_byte *) ext->d_index);
d857 2
a858 2
  bfd_h_put_32 (abfd, intern->rfd, (bfd_byte *) ext->d_rfd);
  bfd_h_put_32 (abfd, intern->index, (bfd_byte *) ext->d_index);
@


1.4
log
@Update copyright notices
@
text
@d199 1
a199 1
  if (intern->rss == 0xffffffff)
@


1.3
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* ecoffswap.h: Fix formatting.
	* elf-bfd.h: Likewise.
	* elfarm-nabi.c: Likewise.
	* elfarm-oabi.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-target.h: Likewise.
@
text
@d2 2
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001
   Free Software Foundation, Inc.
@


1.3.2.2
log
@Merge from mainline.
@
text
@d199 1
a199 1
  if (intern->rss == (signed long) 0xffffffff)
@


1.2
log
@The MIPS thinks that addresses are signed.  Sign extend MIPS ECOFF
addresses.
@
text
@d134 1
a134 1
    abort();
d179 1
a179 1
    abort();
d194 1
a194 1
  
d222 1
a222 1
  /* now the fun stuff... */
d247 1
a247 1
    abort();
d263 1
a263 1
  
d287 1
a287 1
  /* now the fun stuff... */
d315 1
a315 1
    abort();
d376 1
a376 1
#endif  
d380 1
a380 1
    abort();
d396 1
a396 1
  
d437 1
a437 1
#endif  
d441 1
a441 1
    abort();
d447 1
a447 1
   corrupt itself and then freak out. */
d459 1
a459 1
  
d480 1
a480 1
    abort();
d496 1
a496 1
  
d514 1
a514 1
    abort();
d530 1
a530 1
  
d534 1
a534 1
  /* now the fun stuff... */
d564 1
a564 1
    abort();
d580 1
a580 1
  
d584 1
a584 1
  /* now the fun stuff... */
d613 1
a613 1
    abort();
d628 2
a629 2
  
  /* now the fun stuff... */
d652 1
a652 1
    abort();
d668 2
a669 2
  
  /* now the fun stuff... */
d701 1
a701 1
    abort();
d719 1
a719 1
    abort();
d737 1
a737 1
    abort();
d778 1
a778 1
    abort();
d817 1
a817 1
    abort();
d838 1
a838 1
    abort();
d860 1
a860 1
    abort();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d30 5
a34 4
   Before including this header file, one of ECOFF_32 or ECOFF_64 must
   be defined.  These are checked when swapping information that
   depends upon the target size.  This code works for 32 bit and 64
   bit ECOFF, but may need to be generalized in the future.
d54 8
d197 1
a197 1
#ifdef ECOFF_64
d209 1
a209 1
#ifdef ECOFF_32
d213 1
a213 1
#ifdef ECOFF_64
d274 1
a274 1
#ifdef ECOFF_32
d278 1
a278 1
#ifdef ECOFF_64
d353 1
a353 1
#ifdef ECOFF_64
d412 1
a412 1
#ifdef ECOFF_64
d641 1
a641 1
#ifdef ECOFF_32
d644 1
a644 1
#ifdef ECOFF_64
d675 1
a675 1
#ifdef ECOFF_64
d684 1
a684 1
#ifdef ECOFF_64
d690 1
a690 1
#ifdef ECOFF_32
d693 1
a693 1
#ifdef ECOFF_64
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

