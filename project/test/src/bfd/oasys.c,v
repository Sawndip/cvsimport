head	1.48;
access;
symbols
	sid-snapshot-20180601:1.48
	sid-snapshot-20180501:1.48
	sid-snapshot-20180401:1.48
	sid-snapshot-20180301:1.48
	sid-snapshot-20180201:1.48
	sid-snapshot-20180101:1.48
	sid-snapshot-20171201:1.48
	sid-snapshot-20171101:1.48
	sid-snapshot-20171001:1.48
	sid-snapshot-20170901:1.48
	sid-snapshot-20170801:1.48
	sid-snapshot-20170701:1.48
	sid-snapshot-20170601:1.48
	sid-snapshot-20170501:1.48
	sid-snapshot-20170401:1.48
	sid-snapshot-20170301:1.48
	sid-snapshot-20170201:1.48
	sid-snapshot-20170101:1.48
	sid-snapshot-20161201:1.48
	sid-snapshot-20161101:1.48
	sid-snapshot-20160901:1.48
	sid-snapshot-20160801:1.48
	sid-snapshot-20160701:1.48
	sid-snapshot-20160601:1.48
	sid-snapshot-20160501:1.48
	sid-snapshot-20160401:1.48
	sid-snapshot-20160301:1.48
	sid-snapshot-20160201:1.48
	sid-snapshot-20160101:1.48
	sid-snapshot-20151201:1.48
	sid-snapshot-20151101:1.48
	sid-snapshot-20151001:1.48
	sid-snapshot-20150901:1.48
	sid-snapshot-20150801:1.48
	sid-snapshot-20150701:1.48
	sid-snapshot-20150601:1.48
	sid-snapshot-20150501:1.48
	sid-snapshot-20150401:1.48
	sid-snapshot-20150301:1.48
	sid-snapshot-20150201:1.48
	sid-snapshot-20150101:1.48
	sid-snapshot-20141201:1.48
	sid-snapshot-20141101:1.48
	sid-snapshot-20141001:1.48
	sid-snapshot-20140901:1.48
	sid-snapshot-20140801:1.48
	sid-snapshot-20140701:1.48
	sid-snapshot-20140601:1.48
	sid-snapshot-20140501:1.48
	sid-snapshot-20140401:1.48
	sid-snapshot-20140301:1.48
	sid-snapshot-20140201:1.48
	sid-snapshot-20140101:1.48
	sid-snapshot-20131201:1.48
	sid-snapshot-20131101:1.48
	sid-snapshot-20131001:1.48
	binutils-2_24-branch:1.48.0.8
	binutils-2_24-branchpoint:1.48
	binutils-2_21_1:1.45
	sid-snapshot-20130901:1.48
	gdb_7_6_1-2013-08-30-release:1.48
	sid-snapshot-20130801:1.48
	sid-snapshot-20130701:1.48
	sid-snapshot-20130601:1.48
	sid-snapshot-20130501:1.48
	gdb_7_6-2013-04-26-release:1.48
	sid-snapshot-20130401:1.48
	binutils-2_23_2:1.48
	gdb_7_6-branch:1.48.0.6
	gdb_7_6-2013-03-12-branchpoint:1.48
	sid-snapshot-20130301:1.48
	sid-snapshot-20130201:1.48
	sid-snapshot-20130101:1.48
	sid-snapshot-20121201:1.48
	gdb_7_5_1-2012-11-29-release:1.48
	binutils-2_23_1:1.48
	sid-snapshot-20121101:1.48
	binutils-2_23:1.48
	sid-snapshot-20121001:1.48
	sid-snapshot-20120901:1.48
	gdb_7_5-2012-08-17-release:1.48
	sid-snapshot-20120801:1.48
	binutils-2_23-branch:1.48.0.4
	binutils-2_23-branchpoint:1.48
	gdb_7_5-branch:1.48.0.2
	gdb_7_5-2012-07-18-branchpoint:1.48
	sid-snapshot-20120701:1.48
	sid-snapshot-20120601:1.48
	sid-snapshot-20120501:1.48
	binutils-2_22_branch:1.47.0.6
	gdb_7_4_1-2012-04-26-release:1.47
	sid-snapshot-20120401:1.48
	sid-snapshot-20120301:1.48
	sid-snapshot-20120201:1.47
	gdb_7_4-2012-01-24-release:1.47
	sid-snapshot-20120101:1.47
	gdb_7_4-branch:1.47.0.4
	gdb_7_4-2011-12-13-branchpoint:1.47
	sid-snapshot-20111201:1.47
	binutils-2_22:1.47
	sid-snapshot-20111101:1.47
	sid-snapshot-20111001:1.47
	binutils-2_22-branch:1.47.0.2
	binutils-2_22-branchpoint:1.47
	gdb_7_3_1-2011-09-04-release:1.45
	sid-snapshot-20110901:1.47
	sid-snapshot-20110801:1.47
	gdb_7_3-2011-07-26-release:1.45
	sid-snapshot-20110701:1.46
	sid-snapshot-20110601:1.45
	sid-snapshot-20110501:1.45
	gdb_7_3-branch:1.45.0.6
	gdb_7_3-2011-04-01-branchpoint:1.45
	sid-snapshot-20110401:1.45
	sid-snapshot-20110301:1.45
	sid-snapshot-20110201:1.45
	sid-snapshot-20110101:1.45
	binutils-2_21:1.45
	sid-snapshot-20101201:1.45
	binutils-2_21-branch:1.45.0.4
	binutils-2_21-branchpoint:1.45
	sid-snapshot-20101101:1.45
	sid-snapshot-20101001:1.45
	binutils-2_20_1:1.41
	gdb_7_2-2010-09-02-release:1.45
	sid-snapshot-20100901:1.45
	sid-snapshot-20100801:1.45
	gdb_7_2-branch:1.45.0.2
	gdb_7_2-2010-07-07-branchpoint:1.45
	sid-snapshot-20100701:1.45
	sid-snapshot-20100601:1.45
	sid-snapshot-20100501:1.45
	sid-snapshot-20100401:1.45
	gdb_7_1-2010-03-18-release:1.44
	sid-snapshot-20100301:1.44
	gdb_7_1-branch:1.44.0.2
	gdb_7_1-2010-02-18-branchpoint:1.44
	sid-snapshot-20100201:1.44
	sid-snapshot-20100101:1.43
	gdb_7_0_1-2009-12-22-release:1.41
	sid-snapshot-20091201:1.42
	sid-snapshot-20091101:1.41
	binutils-2_20:1.41
	gdb_7_0-2009-10-06-release:1.41
	sid-snapshot-20091001:1.41
	gdb_7_0-branch:1.41.0.4
	gdb_7_0-2009-09-16-branchpoint:1.41
	arc-sim-20090309:1.38
	binutils-arc-20081103-branch:1.38.0.26
	binutils-arc-20081103-branchpoint:1.38
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	sid-snapshot-20090901:1.40
	sid-snapshot-20090801:1.39
	msnyder-checkpoint-072509-branch:1.39.0.4
	msnyder-checkpoint-072509-branchpoint:1.39
	sid-snapshot-20090701:1.39
	dje-cgen-play1-branch:1.39.0.2
	dje-cgen-play1-branchpoint:1.39
	sid-snapshot-20090601:1.39
	sid-snapshot-20090501:1.39
	sid-snapshot-20090401:1.38
	arc-20081103-branch:1.38.0.24
	arc-20081103-branchpoint:1.38
	arc-insight_6_8-branch:1.38.0.22
	arc-insight_6_8-branchpoint:1.38
	insight_6_8-branch:1.38.0.20
	insight_6_8-branchpoint:1.38
	sid-snapshot-20090301:1.38
	binutils-2_19_1:1.38
	sid-snapshot-20090201:1.38
	sid-snapshot-20090101:1.38
	reverse-20081226-branch:1.38.0.18
	reverse-20081226-branchpoint:1.38
	sid-snapshot-20081201:1.38
	multiprocess-20081120-branch:1.38.0.16
	multiprocess-20081120-branchpoint:1.38
	sid-snapshot-20081101:1.38
	binutils-2_19:1.38
	sid-snapshot-20081001:1.38
	reverse-20080930-branch:1.38.0.14
	reverse-20080930-branchpoint:1.38
	binutils-2_19-branch:1.38.0.12
	binutils-2_19-branchpoint:1.38
	sid-snapshot-20080901:1.38
	sid-snapshot-20080801:1.38
	reverse-20080717-branch:1.38.0.10
	reverse-20080717-branchpoint:1.38
	sid-snapshot-20080701:1.38
	msnyder-reverse-20080609-branch:1.38.0.8
	msnyder-reverse-20080609-branchpoint:1.38
	drow-reverse-20070409-branch:1.36.0.2
	drow-reverse-20070409-branchpoint:1.36
	sid-snapshot-20080601:1.38
	sid-snapshot-20080501:1.38
	sid-snapshot-20080403:1.38
	sid-snapshot-20080401:1.38
	gdb_6_8-2008-03-27-release:1.38
	sid-snapshot-20080301:1.38
	gdb_6_8-branch:1.38.0.6
	gdb_6_8-2008-02-26-branchpoint:1.38
	sid-snapshot-20080201:1.38
	sid-snapshot-20080101:1.38
	sid-snapshot-20071201:1.38
	sid-snapshot-20071101:1.38
	gdb_6_7_1-2007-10-29-release:1.38
	gdb_6_7-2007-10-10-release:1.38
	sid-snapshot-20071001:1.38
	gdb_6_7-branch:1.38.0.4
	gdb_6_7-2007-09-07-branchpoint:1.38
	binutils-2_18:1.38
	binutils-2_18-branch:1.38.0.2
	binutils-2_18-branchpoint:1.38
	insight_6_6-20070208-release:1.35
	binutils-csl-coldfire-4_1-32:1.33
	binutils-csl-sourcerygxx-4_1-32:1.33
	gdb_6_6-2006-12-18-release:1.35
	binutils-csl-innovasic-fido-3_4_4-33:1.33
	binutils-csl-sourcerygxx-3_4_4-32:1.28
	binutils-csl-coldfire-4_1-30:1.33
	binutils-csl-sourcerygxx-4_1-30:1.33
	binutils-csl-coldfire-4_1-28:1.33
	binutils-csl-sourcerygxx-4_1-29:1.33
	binutils-csl-sourcerygxx-4_1-28:1.33
	gdb_6_6-branch:1.35.0.2
	gdb_6_6-2006-11-15-branchpoint:1.35
	binutils-csl-arm-2006q3-27:1.33
	binutils-csl-sourcerygxx-4_1-27:1.33
	binutils-csl-arm-2006q3-26:1.33
	binutils-csl-sourcerygxx-4_1-26:1.33
	binutils-csl-sourcerygxx-4_1-25:1.33
	binutils-csl-sourcerygxx-4_1-24:1.33
	binutils-csl-sourcerygxx-4_1-23:1.33
	insight_6_5-20061003-release:1.34
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	binutils-csl-sourcerygxx-4_1-21:1.33
	binutils-csl-arm-2006q3-21:1.33
	binutils-csl-sourcerygxx-4_1-22:1.33
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.33
	binutils-csl-sourcerygxx-4_1-20:1.33
	binutils-csl-arm-2006q3-19:1.33
	binutils-csl-sourcerygxx-4_1-19:1.33
	binutils-csl-sourcerygxx-4_1-18:1.33
	binutils-csl-renesas-4_1-9:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.33
	binutils-csl-sourcerygxx-3_4_4-25:1.28
	nickrob-async-20060828-mergepoint:1.35
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	binutils-csl-renesas-4_1-8:1.33
	binutils-csl-renesas-4_1-7:1.33
	binutils-csl-renesas-4_1-6:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33
	binutils-csl-sourcerygxx-4_1-17:1.33
	gdb-csl-20060226-branch-local-2:1.33
	gdb-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-15:1.33
	gdb-csl-sourcerygxx-4_1-13:1.33
	binutils-csl-sourcerygxx-4_1-13:1.33
	binutils-2_17:1.33
	gdb-csl-sourcerygxx-4_1-12:1.33
	binutils-csl-sourcerygxx-4_1-12:1.33
	gdb-csl-sourcerygxx-3_4_4-21:1.33
	binutils-csl-sourcerygxx-3_4_4-21:1.33
	gdb_6_5-20060621-release:1.34
	binutils-csl-wrs-linux-3_4_4-24:1.28
	binutils-csl-wrs-linux-3_4_4-23:1.28
	gdb-csl-sourcerygxx-4_1-9:1.33
	binutils-csl-sourcerygxx-4_1-9:1.33
	gdb-csl-sourcerygxx-4_1-8:1.33
	binutils-csl-sourcerygxx-4_1-8:1.33
	gdb-csl-sourcerygxx-4_1-7:1.33
	binutils-csl-sourcerygxx-4_1-7:1.33
	gdb-csl-arm-2006q1-6:1.33
	binutils-csl-arm-2006q1-6:1.33
	gdb-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-wrs-linux-3_4_4-22:1.28
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33
	binutils-csl-coldfire-4_1-11:1.33
	gdb-csl-sourcerygxx-3_4_4-19:1.33
	binutils-csl-sourcerygxx-3_4_4-19:1.33
	gdb-csl-coldfire-4_1-10:1.33
	gdb_6_5-branch:1.34.0.4
	gdb_6_5-2006-05-14-branchpoint:1.34
	binutils-csl-coldfire-4_1-10:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33
	binutils-csl-sourcerygxx-4_1-5:1.33
	nickrob-async-20060513-branch:1.34.0.2
	nickrob-async-20060513-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-4:1.33
	binutils-csl-sourcerygxx-4_1-4:1.33
	msnyder-reverse-20060502-branch:1.33.0.24
	msnyder-reverse-20060502-branchpoint:1.33
	binutils-csl-wrs-linux-3_4_4-21:1.28
	gdb-csl-morpho-4_1-4:1.33
	binutils-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-wrs-linux-3_4_4-20:1.28
	readline_5_1-import-branch:1.33.0.22
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	binutils-2_17-branch:1.33.0.20
	binutils-2_17-branchpoint:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.18
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.16
	msnyder-reverse-20060331-branchpoint:1.33
	binutils-csl-2_17-branch:1.33.0.14
	binutils-csl-2_17-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.12
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.10
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.33
	msnyder-fork-checkpoint-branch:1.33.0.8
	msnyder-fork-checkpoint-branchpoint:1.33
	gdb-csl-gxxpro-6_3-branch:1.33.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.33
	gdb_6_4-branch:1.33.0.4
	gdb_6_4-2005-11-01-branchpoint:1.33
	gdb-csl-arm-20051020-branch:1.33.0.2
	gdb-csl-arm-20051020-branchpoint:1.33
	binutils-csl-gxxpro-3_4-branch:1.28.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.28
	binutils-2_16_1:1.28
	msnyder-tracepoint-checkpoint-branch:1.32.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.32
	gdb-csl-arm-20050325-2005-q1b:1.28
	binutils-csl-arm-2005q1b:1.28
	binutils-2_16:1.28
	gdb-csl-arm-20050325-2005-q1a:1.28
	binutils-csl-arm-2005q1a:1.28
	csl-arm-20050325-branch:1.28.0.6
	csl-arm-20050325-branchpoint:1.28
	binutils-csl-arm-2005q1-branch:1.28.0.4
	binutils-csl-arm-2005q1-branchpoint:1.28
	binutils-2_16-branch:1.28.0.2
	binutils-2_16-branchpoint:1.28
	csl-arm-2004-q3d:1.26
	gdb_6_3-20041109-release:1.26
	gdb_6_3-branch:1.26.0.2
	gdb_6_3-20041019-branchpoint:1.26
	csl-arm-2004-q3:1.25
	drow_intercu-merge-20040921:1.25
	drow_intercu-merge-20040915:1.25
	jimb-gdb_6_2-e500-branch:1.24.0.6
	jimb-gdb_6_2-e500-branchpoint:1.24
	gdb_6_2-20040730-release:1.24
	gdb_6_2-branch:1.24.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.24
	gdb_6_1_1-20040616-release:1.22
	binutils-2_15:1.22
	binutils-2_15-branchpoint:1.22
	csl-arm-2004-q1a:1.23
	csl-arm-2004-q1:1.22
	gdb_6_1-2004-04-05-release:1.22
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.22
	ezannoni_pie-20040323-branch:1.22.0.14
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.22
	cagney_tramp-20040309-branch:1.22.0.12
	cagney_tramp-20040309-branchpoint:1.22
	gdb_6_1-branch:1.22.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	drow_intercu-20040221-branch:1.22.0.8
	drow_intercu-20040221-branchpoint:1.22
	binutils-2_15-branch:1.22.0.6
	cagney_bfdfile-20040213-branch:1.22.0.4
	cagney_bfdfile-20040213-branchpoint:1.22
	drow-cplus-merge-20040208:1.22
	carlton_dictionary-20040126-merge:1.22
	cagney_bigcore-20040122-branch:1.22.0.2
	cagney_bigcore-20040122-branchpoint:1.22
	drow-cplus-merge-20040113:1.22
	csl-arm-2003-q4:1.22
	drow-cplus-merge-20031224:1.22
	drow-cplus-merge-20031220:1.22
	carlton_dictionary-20031215-merge:1.22
	drow-cplus-merge-20031214:1.22
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.19
	kettenis_sparc-20030918-branch:1.19.0.38
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.36
	cagney_x86i386-20030821-branch:1.19.0.34
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.32
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.19
	binutils-2_14:1.19
	cagney_convert-20030606-branch:1.19.0.28
	cagney_convert-20030606-branchpoint:1.19
	cagney_writestrings-20030508-branch:1.19.0.26
	cagney_writestrings-20030508-branchpoint:1.19
	jimb-ppc64-linux-20030528-branch:1.19.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.19
	carlton_dictionary-20030523-merge:1.19
	cagney_fileio-20030521-branch:1.19.0.22
	cagney_fileio-20030521-branchpoint:1.19
	kettenis_i386newframe-20030517-mergepoint:1.19
	jimb-ppc64-linux-20030509-branch:1.19.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.19
	kettenis_i386newframe-20030504-mergepoint:1.19
	carlton_dictionary-20030430-merge:1.19
	binutils-2_14-branch:1.19.0.18
	binutils-2_14-branchpoint:1.19
	kettenis_i386newframe-20030419-branch:1.19.0.16
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.19
	kettenis_i386newframe-20030406-branch:1.19.0.14
	kettenis_i386newframe-20030406-branchpoint:1.19
	cagney_frameaddr-20030403-branchpoint:1.19
	cagney_frameaddr-20030403-branch:1.19.0.12
	cagney_framebase-20030330-mergepoint:1.19
	cagney_framebase-20030326-branch:1.19.0.10
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.8
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.6
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.19.0.4
	kettenis-i386newframe-20030308-branchpoint:1.19
	carlton_dictionary-20030305-merge:1.19
	cagney_offbyone-20030303-branch:1.19.0.2
	cagney_offbyone-20030303-branchpoint:1.19
	carlton_dictionary-20030207-merge:1.19
	interps-20030202-branch:1.18.0.4
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.17
	binutils-2_13_1:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.14
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.12
	carlton_dictionary-20020920-branchpoint:1.17
	sid-20020905-branchpoint:1.17
	sid-20020905-branch:1.17.0.10
	gdb_5_3-branch:1.17.0.8
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.17.0.6
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.17.0.4
	readline_4_3-import-branchpoint:1.17
	binutils-2_13:1.17
	gdb_5_2_1-2002-07-23-release:1.13
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	kseitz_interps-20020528-branch:1.15.0.2
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.14.0.4
	cagney_regbuf-20020515-branchpoint:1.14
	binutils-2_12_1:1.13
	jimb-macro-020506-branch:1.14.0.2
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.13
	binutils-2_12:1.13
	gdb_5_2-branch:1.13.0.4
	gdb_5_2-2002-03-03-branchpoint:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	binutils-2_11_2:1.5.8.1
	binutils-2_11_1:1.5.8.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.8
	insight-precleanup-2001-01-01:1.5
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.4
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.48
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2012.02.11.15.10.12;	author jkratoch;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.11.15.03.07;	author clm;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.06.01.26.03;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.24.15.41.59;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.23.14.41.30;	author pbrook;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.26.12.23.03;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.23.17.44.55;	author fnf;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.04.15.53.36;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.04.07.19.34;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.11.08.23.02;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.31.23.13.28;	author bje;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.08.14.54.01;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.30.14.23.40;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.22.8.1;
next	1.21;

1.21
date	2003.11.04.10.41.52;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.16.04.11.07;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.17.12.1
	1.17.14.1;
next	1.16;

1.16
date	2002.06.05.03.43.11;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.15.00.18.58;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.09.19.05.33.12;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.28.09.35.16;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.26.11.46.04;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.19.23.42.47;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.18.51.35;	author nickc;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	99.12.10.01.41.22;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.16;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.29.56;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.22.8.1
date	2004.09.16.17.00.36;	author drow;	state Exp;
branches;
next	;

1.17.12.1
date	2002.12.23.19.37.56;	author carlton;	state Exp;
branches;
next	1.17.12.2;

1.17.12.2
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.17.12.3;

1.17.12.3
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	1.17.12.4;

1.17.12.4
date	2003.12.15.23.59.51;	author carlton;	state Exp;
branches;
next	;

1.17.14.1
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.20.01.31.04;	author kseitz;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.5.8.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.48
log
@bfd/
	* oasys.c (oasys_write_header): Fix compilation warning on zero-sized
	memset.
@
text
@/* BFD back-end for oasys objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
   Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support, <sac@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define UNDERSCORE_HACK 1
#include "sysdep.h"
#include "bfd.h"
#include "safe-ctype.h"
#include "libbfd.h"
#include "oasys.h"
#include "liboasys.h"

/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
oasys_read_record (bfd *abfd, oasys_record_union_type *record)
{
  bfd_size_type amt = sizeof (record->header);

  if (bfd_bread ((void *) record, amt, abfd) != amt)
    return FALSE;

  amt = record->header.length - sizeof (record->header);
  if ((long) amt <= 0)
    return TRUE;
  if (bfd_bread ((void *) ((char *) record + sizeof (record->header)), amt, abfd)
      != amt)
    return FALSE;
  return TRUE;
}

static size_t
oasys_string_length (oasys_record_union_type *record)
{
  return record->header.length
    - ((char *) record->symbol.name - (char *) record);
}

/* Slurp the symbol table by reading in all the records at the start file
   till we get to the first section record.

   We'll sort the symbolss into  two lists, defined and undefined. The
   undefined symbols will be placed into the table according to their
   refno.

   We do this by placing all undefined symbols at the front of the table
   moving in, and the defined symbols at the end of the table moving back.  */

static bfd_boolean
oasys_slurp_symbol_table (bfd *const abfd)
{
  oasys_record_union_type record;
  oasys_data_type *data = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  asymbol *dest_defined;
  asymbol *dest;
  char *string_ptr;
  bfd_size_type amt;

  if (data->symbols != NULL)
    return TRUE;

  /* Buy enough memory for all the symbols and all the names.  */
  amt = abfd->symcount;
  amt *= sizeof (asymbol);
  data->symbols = bfd_alloc (abfd, amt);

  amt = data->symbol_string_length;
#ifdef UNDERSCORE_HACK
  /* Buy 1 more char for each symbol to keep the underscore in.  */
  amt += abfd->symcount;
#endif
  data->strings = bfd_alloc (abfd, amt);

  if (!data->symbols || !data->strings)
    return FALSE;

  dest_defined = data->symbols + abfd->symcount - 1;

  string_ptr = data->strings;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  while (loop)
    {
      if (! oasys_read_record (abfd, &record))
	return FALSE;

      switch (record.header.type)
	{
	case oasys_record_is_header_enum:
	  break;
	case oasys_record_is_local_enum:
	case oasys_record_is_symbol_enum:
	  {
	    int flag = record.header.type == (int) oasys_record_is_local_enum ?
	    (BSF_LOCAL) : (BSF_GLOBAL | BSF_EXPORT);

	    size_t length = oasys_string_length (&record);
	    switch (record.symbol.relb & RELOCATION_TYPE_BITS)
	      {
	      case RELOCATION_TYPE_ABS:
		dest = dest_defined--;
		dest->section = bfd_abs_section_ptr;
		dest->flags = 0;

		break;
	      case RELOCATION_TYPE_REL:
		dest = dest_defined--;
		dest->section =
		  OASYS_DATA (abfd)->sections[record.symbol.relb &
					      RELOCATION_SECT_BITS];
		if (record.header.type == (int) oasys_record_is_local_enum)
		  {
		    dest->flags = BSF_LOCAL;
		    if (dest->section == (asection *) (~0))
		      {
			/* It seems that sometimes internal symbols are tied up, but
		       still get output, even though there is no
		       section */
			dest->section = 0;
		      }
		  }
		else
		  dest->flags = flag;
		break;
	      case RELOCATION_TYPE_UND:
		dest = data->symbols + H_GET_16 (abfd, record.symbol.refno);
		dest->section = bfd_und_section_ptr;
		break;
	      case RELOCATION_TYPE_COM:
		dest = dest_defined--;
		dest->name = string_ptr;
		dest->the_bfd = abfd;
		dest->section = bfd_com_section_ptr;
		break;
	      default:
		dest = dest_defined--;
		BFD_ASSERT (FALSE);
		break;
	      }
	    dest->name = string_ptr;
	    dest->the_bfd = abfd;
	    dest->udata.p = NULL;
	    dest->value = H_GET_32 (abfd, record.symbol.value);

#ifdef UNDERSCORE_HACK
	    if (record.symbol.name[0] != '_')
	      {
		string_ptr[0] = '_';
		string_ptr++;
	      }
#endif
	    memcpy (string_ptr, record.symbol.name, length);

	    string_ptr[length] = 0;
	    string_ptr += length + 1;
	  }
	  break;
	default:
	  loop = FALSE;
	}
    }
  return TRUE;
}

static long
oasys_get_symtab_upper_bound (bfd *const abfd)
{
  if (! oasys_slurp_symbol_table (abfd))
    return -1;

  return (abfd->symcount + 1) * (sizeof (oasys_symbol_type *));
}

extern const bfd_target oasys_vec;

static long
oasys_canonicalize_symtab (bfd *abfd, asymbol **location)
{
  asymbol *symbase;
  unsigned int counter;

  if (! oasys_slurp_symbol_table (abfd))
    return -1;

  symbase = OASYS_DATA (abfd)->symbols;
  for (counter = 0; counter < abfd->symcount; counter++)
    *(location++) = symbase++;

  *location = 0;
  return abfd->symcount;
}

/* Archive stuff.  */

static const bfd_target *
oasys_archive_p (bfd *abfd)
{
  oasys_archive_header_type header;
  oasys_extarchive_header_type header_ext;
  unsigned int i;
  file_ptr filepos;
  bfd_size_type amt;

  amt = sizeof (header_ext);
  if (bfd_seek (abfd, (file_ptr) 0, 0) != 0
      || bfd_bread ((void *) &header_ext, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  header.version = H_GET_32 (abfd, header_ext.version);
  header.mod_count = H_GET_32 (abfd, header_ext.mod_count);
  header.mod_tbl_offset = H_GET_32 (abfd, header_ext.mod_tbl_offset);
  header.sym_tbl_size = H_GET_32 (abfd, header_ext.sym_tbl_size);
  header.sym_count = H_GET_32 (abfd, header_ext.sym_count);
  header.sym_tbl_offset = H_GET_32 (abfd, header_ext.sym_tbl_offset);
  header.xref_count = H_GET_32 (abfd, header_ext.xref_count);
  header.xref_lst_offset = H_GET_32 (abfd, header_ext.xref_lst_offset);

  /* There isn't a magic number in an Oasys archive, so the best we
     can do to verify reasonableness is to make sure that the values in
     the header are too weird.  */

  if (header.version > 10000
      || header.mod_count > 10000
      || header.sym_count > 100000
      || header.xref_count > 100000)
    return NULL;

  /* That all worked, let's buy the space for the header and read in
     the headers.  */
  {
    oasys_ar_data_type *ar;
    oasys_module_info_type *module;
    oasys_module_table_type record;

    amt = sizeof (oasys_ar_data_type);
    ar = bfd_alloc (abfd, amt);

    amt = header.mod_count;
    amt *= sizeof (oasys_module_info_type);
    module = bfd_alloc (abfd, amt);

    if (!ar || !module)
      return NULL;

    abfd->tdata.oasys_ar_data = ar;
    ar->module = module;
    ar->module_count = header.mod_count;

    filepos = header.mod_tbl_offset;
    for (i = 0; i < header.mod_count; i++)
      {
	if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
	  return NULL;

	/* There are two ways of specifying the archive header.  */
	  {
	    oasys_extmodule_table_type_b_type record_ext;

	    amt = sizeof (record_ext);
	    if (bfd_bread ((void *) &record_ext, amt, abfd) != amt)
	      return NULL;

	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);

	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);
	    record.module_name_size = H_GET_32 (abfd,
						record_ext.mod_name_length);

	    amt = record.module_name_size;
	    module[i].name = bfd_alloc (abfd, amt + 1);
	    if (!module[i].name)
	      return NULL;
	    if (bfd_bread ((void *) module[i].name, amt, abfd) != amt)
	      return NULL;
	    module[i].name[record.module_name_size] = 0;
	    filepos += (sizeof (record_ext)
			+ record.dep_count * 4
			+ record.module_name_size + 1);
	  }

	module[i].size = record.mod_size;
	module[i].pos = record.file_offset;
	module[i].abfd = 0;
      }
  }
  return abfd->xvec;
}

static bfd_boolean
oasys_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (oasys_data_type);

  abfd->tdata.oasys_obj_data = bfd_alloc (abfd, amt);

  return abfd->tdata.oasys_obj_data != NULL;
}

/* The howto table is build using the top two bits of a reloc byte to
   index into it. The bits are PCREL,WORD/LONG.  */

static reloc_howto_type howto_table[] =
{

  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16",   TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32",   TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE,  0, complain_overflow_signed,   0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE,  0, complain_overflow_signed,   0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
};

/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
oasys_slurp_section_data (bfd *const abfd)
{
  oasys_record_union_type record;
  oasys_data_type *data = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  oasys_per_section_type *per;
  asection *s;
  bfd_size_type amt;

  /* See if the data has been slurped already.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      per = oasys_per_section (s);
      if (per->initialized)
	return TRUE;
    }

  if (data->first_data_record == 0)
    return TRUE;

  if (bfd_seek (abfd, data->first_data_record, SEEK_SET) != 0)
    return FALSE;

  while (loop)
    {
      if (! oasys_read_record (abfd, &record))
	return FALSE;

      switch (record.header.type)
	{
	case oasys_record_is_header_enum:
	  break;
	case oasys_record_is_data_enum:
	  {
	    bfd_byte *src = record.data.data;
	    bfd_byte *end_src = ((bfd_byte *) & record) + record.header.length;
	    bfd_byte *dst_ptr;
	    bfd_byte *dst_base_ptr;
	    unsigned int relbit;
	    unsigned int count;
	    asection *section =
	    data->sections[record.data.relb & RELOCATION_SECT_BITS];
	    bfd_vma dst_offset;

	    per = oasys_per_section (section);

	    if (! per->initialized)
	      {
		arelent **relpp;

		per->data = bfd_zalloc (abfd, section->size);
		if (!per->data)
		  return FALSE;
		relpp = &section->relocation;
		per->reloc_tail_ptr = (oasys_reloc_type **) relpp;
		per->had_vma = FALSE;
		per->initialized = TRUE;
		section->reloc_count = 0;
		section->flags = SEC_ALLOC;
	      }

	    dst_offset = H_GET_32 (abfd, record.data.addr);
	    if (! per->had_vma)
	      {
		/* Take the first vma we see as the base.  */
		section->vma = dst_offset;
		per->had_vma = TRUE;
	      }

	    dst_offset -= section->vma;

	    dst_base_ptr = oasys_per_section (section)->data;
	    dst_ptr = oasys_per_section (section)->data +
	      dst_offset;

	    if (src < end_src)
	      section->flags |= SEC_LOAD | SEC_HAS_CONTENTS;

	    while (src < end_src)
	      {
		unsigned char mod_byte = *src++;
		size_t gap = end_src - src;

		count = 8;
		if (mod_byte == 0 && gap >= 8)
		  {
		    dst_ptr[0] = src[0];
		    dst_ptr[1] = src[1];
		    dst_ptr[2] = src[2];
		    dst_ptr[3] = src[3];
		    dst_ptr[4] = src[4];
		    dst_ptr[5] = src[5];
		    dst_ptr[6] = src[6];
		    dst_ptr[7] = src[7];
		    dst_ptr += 8;
		    src += 8;
		  }
		else
		  {
		    for (relbit = 1; count-- != 0 && src < end_src; relbit <<= 1)
		      {
			if (relbit & mod_byte)
			  {
			    unsigned char reloc = *src;
			    /* This item needs to be relocated.  */
			    switch (reloc & RELOCATION_TYPE_BITS)
			      {
			      case RELOCATION_TYPE_ABS:
				break;

			      case RELOCATION_TYPE_REL:
				{
				  /* Relocate the item relative to the section.  */
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = bfd_alloc (abfd, amt);
				  if (!r)
				    return FALSE;
				  *(per->reloc_tail_ptr) = r;
				  per->reloc_tail_ptr = &r->next;
				  r->next = NULL;
				  /* Reference to undefined symbol.  */
				  src++;
				  /* There is no symbol.  */
				  r->symbol = 0;
				  /* Work out the howto.  */
				  abort ();
				  r->relent.address = dst_ptr - dst_base_ptr;
				  r->relent.howto = &howto_table[reloc >> 6];
				  r->relent.sym_ptr_ptr = NULL;
				  section->reloc_count++;

				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
				}
				break;

			      case RELOCATION_TYPE_UND:
				{
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = bfd_alloc (abfd, amt);
				  if (!r)
				    return FALSE;
				  *(per->reloc_tail_ptr) = r;
				  per->reloc_tail_ptr = &r->next;
				  r->next = NULL;
				  /* Reference to undefined symbol.  */
				  src++;
				  /* Get symbol number.  */
				  r->symbol = (src[0] << 8) | src[1];
				  /* Work out the howto.  */
				  abort ();

				  r->relent.addend = 0;
				  r->relent.address = dst_ptr - dst_base_ptr;
				  r->relent.howto = &howto_table[reloc >> 6];
				  r->relent.sym_ptr_ptr = NULL;
				  section->reloc_count++;

				  src += 2;
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
				}
				break;
			      case RELOCATION_TYPE_COM:
				BFD_FAIL ();
			      }
			  }
			*dst_ptr++ = *src++;
		      }
		  }
	      }
	  }
	  break;
	case oasys_record_is_local_enum:
	case oasys_record_is_symbol_enum:
	case oasys_record_is_section_enum:
	  break;
	default:
	  loop = FALSE;
	}
    }

  return TRUE;

}

#define MAX_SECS 16

static const bfd_target *
oasys_object_p (bfd *abfd)
{
  oasys_data_type *oasys;
  oasys_data_type *save = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;

  abfd->tdata.oasys_obj_data = 0;
  oasys_mkobject (abfd);
  oasys = OASYS_DATA (abfd);
  memset ((void *) oasys->sections, 0xff, sizeof (oasys->sections));

  /* Point to the start of the file.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  oasys->symbol_string_length = 0;

  /* Inspect the records, but only keep the section info -
     remember the size of the symbols.  */
  oasys->first_data_record = 0;
  while (loop)
    {
      oasys_record_union_type record;
      if (! oasys_read_record (abfd, &record))
	goto fail;
      if ((size_t) record.header.length < (size_t) sizeof (record.header))
	goto fail;

      switch ((oasys_record_enum_type) (record.header.type))
	{
	case oasys_record_is_header_enum:
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_symbol_enum:
	case oasys_record_is_local_enum:
	  /* Count symbols and remember their size for a future malloc.  */
	  abfd->symcount++;
	  oasys->symbol_string_length += 1 + oasys_string_length (&record);
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_section_enum:
	  {
	    asection *s;
	    char *buffer;
	    unsigned int section_number;

	    if (record.section.header.length != sizeof (record.section))
	      goto fail;

	    buffer = bfd_alloc (abfd, (bfd_size_type) 3);
	    if (!buffer)
	      goto fail;
	    section_number = record.section.relb & RELOCATION_SECT_BITS;
	    sprintf (buffer, "%u", section_number);
	    s = bfd_make_section (abfd, buffer);
	    oasys->sections[section_number] = s;
	    switch (record.section.relb & RELOCATION_TYPE_BITS)
	      {
	      case RELOCATION_TYPE_ABS:
	      case RELOCATION_TYPE_REL:
		break;
	      case RELOCATION_TYPE_UND:
	      case RELOCATION_TYPE_COM:
		BFD_FAIL ();
	      }

	    s->size = H_GET_32 (abfd, record.section.value);
	    s->vma = H_GET_32 (abfd, record.section.vma);
	    s->flags = 0;
	    had_usefull = TRUE;
	  }
	  break;
	case oasys_record_is_data_enum:
	  oasys->first_data_record = bfd_tell (abfd) - record.header.length;
	case oasys_record_is_debug_enum:
	case oasys_record_is_module_enum:
	case oasys_record_is_named_section_enum:
	case oasys_record_is_end_enum:
	  if (! had_usefull)
	    goto fail;
	  loop = FALSE;
	  break;
	default:
	  goto fail;
	}
    }
  oasys->symbols = NULL;

  /* Oasys support several architectures, but I can't see a simple way
     to discover which one is in a particular file - we'll guess.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_m68k, 0);
  if (abfd->symcount != 0)
    abfd->flags |= HAS_SYMS;

  /* We don't know if a section has data until we've read it.  */
  oasys_slurp_section_data (abfd);

  return abfd->xvec;

fail:
  (void) bfd_release (abfd, oasys);
  abfd->tdata.oasys_obj_data = save;
  return NULL;
}


static void
oasys_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		       asymbol *symbol,
		       symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);

  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
}

static void
oasys_print_symbol (bfd *abfd, void * afile, asymbol *symbol, bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
    case bfd_print_symbol_more:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name = symbol->section == NULL ?
	(const char *) "*abs" : symbol->section->name;

	bfd_print_symbol_vandf (abfd, (void *) file, symbol);

	fprintf (file, " %-5s %s",
		 section_name,
		 symbol->name);
      }
      break;
    }
}

static bfd_boolean
oasys_new_section_hook (bfd *abfd, asection *newsect)
{
  if (!newsect->used_by_bfd)
    {
      newsect->used_by_bfd
	= bfd_alloc (abfd, (bfd_size_type) sizeof (oasys_per_section_type));
      if (!newsect->used_by_bfd)
	return FALSE;
    }
  oasys_per_section (newsect)->data = NULL;
  oasys_per_section (newsect)->section = newsect;
  oasys_per_section (newsect)->offset = 0;
  oasys_per_section (newsect)->initialized = FALSE;
  newsect->alignment_power = 1;

  /* Turn the section string into an index.  */
  sscanf (newsect->name, "%u", &newsect->target_index);

  return _bfd_generic_new_section_hook (abfd, newsect);
}


static long
oasys_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
{
  if (! oasys_slurp_section_data (abfd))
    return -1;
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

static bfd_boolean
oasys_get_section_contents (bfd *abfd,
			    sec_ptr section,
			    void * location,
			    file_ptr offset,
			    bfd_size_type count)
{
  oasys_per_section_type *p = oasys_per_section (section);

  oasys_slurp_section_data (abfd);

  if (! p->initialized)
    (void) memset (location, 0, (size_t) count);
  else
    (void) memcpy (location, (void *) (p->data + offset), (size_t) count);

  return TRUE;
}

static long
oasys_canonicalize_reloc (bfd *ignore_abfd ATTRIBUTE_UNUSED,
			  sec_ptr section,
			  arelent **relptr,
			  asymbol **symbols ATTRIBUTE_UNUSED)
{
  unsigned int reloc_count = 0;
  oasys_reloc_type *src = (oasys_reloc_type *) (section->relocation);

  if (src != NULL)
    abort ();

  *relptr = NULL;
  return section->reloc_count = reloc_count;
}


/* Writing.  */

/* Calculate the checksum and write one record.  */

static bfd_boolean
oasys_write_record (bfd *abfd,
		    oasys_record_enum_type type,
		    oasys_record_union_type *record,
		    size_t size)
{
  int checksum;
  size_t i;
  unsigned char *ptr;

  record->header.length = size;
  record->header.type = (int) type;
  record->header.check_sum = 0;
  record->header.fill = 0;
  ptr = (unsigned char *) &record->pad[0];
  checksum = 0;
  for (i = 0; i < size; i++)
    checksum += *ptr++;
  record->header.check_sum = 0xff & (-checksum);
  if (bfd_bwrite ((void *) record, (bfd_size_type) size, abfd) != size)
    return FALSE;
  return TRUE;
}


/* Write out all the symbols.  */

static bfd_boolean
oasys_write_syms (bfd *abfd)
{
  unsigned int count;
  asymbol **generic = bfd_get_outsymbols (abfd);
  unsigned int sym_index = 0;

  for (count = 0; count < bfd_get_symcount (abfd); count++)
    {
      oasys_symbol_record_type symbol;
      asymbol *const g = generic[count];
      const char *src = g->name;
      char *dst = symbol.name;
      unsigned int l = 0;

      if (bfd_is_com_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_COM;
	  H_PUT_16 (abfd, sym_index, symbol.refno);
	  sym_index++;
	}
      else if (bfd_is_abs_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_ABS;
	  H_PUT_16 (abfd, 0, symbol.refno);
	}
      else if (bfd_is_und_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_UND;
	  H_PUT_16 (abfd, sym_index, symbol.refno);
	  /* Overload the value field with the output sym_index number */
	  sym_index++;
	}
      else if (g->flags & BSF_DEBUGGING)
	/* Throw it away.  */
	continue;
      else
	{
	  if (g->section == NULL)
	    /* Sometime, the oasys tools give out a symbol with illegal
	       bits in it, we'll output it in the same broken way.  */
	    symbol.relb = RELOCATION_TYPE_REL | 0;
	  else
	    symbol.relb = RELOCATION_TYPE_REL | g->section->output_section->target_index;

	  H_PUT_16 (abfd, 0, symbol.refno);
	}

#ifdef UNDERSCORE_HACK
      if (src[l] == '_')
	dst[l++] = '.';
#endif
      while (src[l])
	{
	  dst[l] = src[l];
	  l++;
	}

      H_PUT_32 (abfd, g->value, symbol.value);

      if (g->flags & BSF_LOCAL)
	{
	  if (! oasys_write_record (abfd,
				    oasys_record_is_local_enum,
				    (oasys_record_union_type *) & symbol,
				    offsetof (oasys_symbol_record_type,
					      name[0]) + l))
	    return FALSE;
	}
      else
	{
	  if (! oasys_write_record (abfd,
				    oasys_record_is_symbol_enum,
				    (oasys_record_union_type *) & symbol,
				    offsetof (oasys_symbol_record_type,
					      name[0]) + l))
	    return FALSE;
	}
      g->value = sym_index - 1;
    }

  return TRUE;
}

/* Write a section header for each section.  */

static bfd_boolean
oasys_write_sections (bfd *abfd)
{
  asection *s;
  static oasys_section_record_type out;

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (!ISDIGIT (s->name[0]))
	{
	  (*_bfd_error_handler)
	    (_("%s: can not represent section `%s' in oasys"),
	     bfd_get_filename (abfd), s->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      out.relb = RELOCATION_TYPE_REL | s->target_index;
      H_PUT_32 (abfd, s->size, out.value);
      H_PUT_32 (abfd, s->vma, out.vma);

      if (! oasys_write_record (abfd,
				oasys_record_is_section_enum,
				(oasys_record_union_type *) & out,
				sizeof (out)))
	return FALSE;
    }
  return TRUE;
}

static bfd_boolean
oasys_write_header (bfd *abfd)
{
  /* Create and write the header.  */
  oasys_header_record_type r;
  size_t length = strlen (abfd->filename);

  if (length > (size_t) sizeof (r.module_name))
    length = sizeof (r.module_name);
  else if (length < (size_t) sizeof (r.module_name))
    (void) memset (r.module_name + length, ' ',
		   sizeof (r.module_name) - length);

  (void) memcpy (r.module_name, abfd->filename, length);

  r.version_number = OASYS_VERSION_NUMBER;
  r.rev_number = OASYS_REV_NUMBER;

  return oasys_write_record (abfd, oasys_record_is_header_enum,
			     (oasys_record_union_type *) & r,
			     offsetof (oasys_header_record_type,
				       description[0]));
}

static bfd_boolean
oasys_write_end (bfd *abfd)
{
  oasys_end_record_type end;
  unsigned char null = 0;

  end.relb = RELOCATION_TYPE_ABS;
  H_PUT_32 (abfd, abfd->start_address, end.entry);
  H_PUT_16 (abfd, 0, end.fill);
  end.zero = 0;
  if (! oasys_write_record (abfd,
			    oasys_record_is_end_enum,
			    (oasys_record_union_type *) & end,
			    sizeof (end)))
    return FALSE;

  return bfd_bwrite ((void *) &null, (bfd_size_type) 1, abfd) == 1;
}

static int
comp (const void * ap, const void * bp)
{
  arelent *a = *((arelent **) ap);
  arelent *b = *((arelent **) bp);

  return a->address - b->address;
}

static bfd_boolean
oasys_write_data (bfd *abfd)
{
  asection *s;

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  bfd_byte *raw_data = oasys_per_section (s)->data;
	  oasys_data_record_type processed_data;
	  bfd_size_type current_byte_index = 0;
	  unsigned int relocs_to_go = s->reloc_count;
	  arelent **p = s->orelocation;

	  if (s->reloc_count != 0)
	    /* Sort the reloc records so it's easy to insert the relocs into the
	       data.  */
	    qsort (s->orelocation, s->reloc_count, sizeof (arelent **), comp);

	  current_byte_index = 0;
	  processed_data.relb = s->target_index | RELOCATION_TYPE_REL;

	  while (current_byte_index < s->size)
	    {
	      /* Scan forwards by eight bytes or however much is left and see if
	       there are any relocations going on.  */
	      bfd_byte *mod = &processed_data.data[0];
	      bfd_byte *dst = &processed_data.data[1];

	      unsigned int i = 0;
	      *mod = 0;

	      H_PUT_32 (abfd, s->vma + current_byte_index,
			processed_data.addr);

	      /* Don't start a relocation unless you're sure you can finish it
		 within the same data record.  The worst case relocation is a
		 4-byte relocatable value which is split across two modification
		 bytes (1 relocation byte + 2 symbol reference bytes + 2 data +
		 1 modification byte + 2 data = 8 bytes total).  That's where
		 the magic number 8 comes from.  */
	      while (current_byte_index < s->size && dst <=
		     & processed_data.data[sizeof (processed_data.data) - 8])
		{
		  if (relocs_to_go != 0)
		    {
		      arelent *r = *p;

		      /* There is a relocation, is it for this byte ?  */
		      if (r->address == current_byte_index)
			abort ();
		    }

		  /* If this is coming from an unloadable section then copy
		     zeros.  */
		  if (raw_data == NULL)
		    *dst++ = 0;
		  else
		    *dst++ = *raw_data++;

		  if (++i >= 8)
		    {
		      i = 0;
		      mod = dst++;
		      *mod = 0;
		    }
		  current_byte_index++;
		}

	      /* Don't write a useless null modification byte.  */
	      if (dst == mod + 1)
		--dst;

	      if (! (oasys_write_record
		     (abfd, oasys_record_is_data_enum,
		      ((oasys_record_union_type *) &processed_data),
		      (size_t) (dst - (bfd_byte *) &processed_data))))
		return FALSE;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
oasys_write_object_contents (bfd *abfd)
{
  if (! oasys_write_header (abfd))
    return FALSE;
  if (! oasys_write_syms (abfd))
    return FALSE;
  if (! oasys_write_sections (abfd))
    return FALSE;
  if (! oasys_write_data (abfd))
    return FALSE;
  if (! oasys_write_end (abfd))
    return FALSE;
  return TRUE;
}

/* Set section contents is complicated with OASYS since the format is
   not a byte image, but a record stream.  */

static bfd_boolean
oasys_set_section_contents (bfd *abfd,
			    sec_ptr section,
			    const void * location,
			    file_ptr offset,
			    bfd_size_type count)
{
  if (count != 0)
    {
      if (oasys_per_section (section)->data == NULL)
	{
	  oasys_per_section (section)->data = bfd_alloc (abfd, section->size);
	  if (!oasys_per_section (section)->data)
	    return FALSE;
	}
      (void) memcpy ((void *) (oasys_per_section (section)->data + offset),
		     location, (size_t) count);
    }
  return TRUE;
}



/* Native-level interface to symbols.  */

/* We read the symbols into a buffer, which is discarded when this
   function exits.  We read the strings into a buffer large enough to
   hold them all plus all the cached symbol entries.  */

static asymbol *
oasys_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (oasys_symbol_type);
  oasys_symbol_type *new_symbol_type = bfd_zalloc (abfd, amt);

  if (!new_symbol_type)
    return NULL;
  new_symbol_type->symbol.the_bfd = abfd;
  return &new_symbol_type->symbol;
}

/* User should have checked the file flags; perhaps we should return
   BFD_NO_MORE_SYMBOLS if there are none?  */

static bfd *
oasys_openr_next_archived_file (bfd *arch, bfd *prev)
{
  oasys_ar_data_type *ar = OASYS_AR_DATA (arch);
  oasys_module_info_type *p;

  /* Take the next one from the arch state, or reset.  */
  if (prev == NULL)
    /* Reset the index - the first two entries are bogus.  */
    ar->module_index = 0;

  p = ar->module + ar->module_index;
  ar->module_index++;

  if (ar->module_index <= ar->module_count)
    {
      if (p->abfd == NULL)
	{
	  p->abfd = _bfd_create_empty_archive_element_shell (arch);
	  p->abfd->origin = p->pos;
	  p->abfd->filename = p->name;

	  /* Fixup a pointer to this element for the member.  */
	  p->abfd->arelt_data = (void *) p;
	}
      return p->abfd;
    }

  bfd_set_error (bfd_error_no_more_archived_files);
  return NULL;
}

static bfd_boolean
oasys_find_nearest_line (bfd *abfd ATTRIBUTE_UNUSED,
			 asection *section ATTRIBUTE_UNUSED,
			 asymbol **symbols ATTRIBUTE_UNUSED,
			 bfd_vma offset ATTRIBUTE_UNUSED,
			 const char **filename_ptr ATTRIBUTE_UNUSED,
			 const char **functionname_ptr ATTRIBUTE_UNUSED,
			 unsigned int *line_ptr ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static bfd_boolean
oasys_find_inliner_info (bfd *abfd ATTRIBUTE_UNUSED,
			 const char **filename_ptr ATTRIBUTE_UNUSED,
			 const char **functionname_ptr ATTRIBUTE_UNUSED,
			 unsigned int *line_ptr ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static int
oasys_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
{
  oasys_module_info_type *mod = (oasys_module_info_type *) abfd->arelt_data;

  if (mod == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  buf->st_size = mod->size;
  buf->st_mode = 0666;
  return 0;
}

static int
oasys_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return 0;
}

#define	oasys_close_and_cleanup                    _bfd_generic_close_and_cleanup
#define oasys_bfd_free_cached_info                 _bfd_generic_bfd_free_cached_info
#define oasys_slurp_armap                          bfd_true
#define oasys_slurp_extended_name_table            bfd_true
#define oasys_construct_extended_name_table        ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_true)
#define oasys_truncate_arname                      bfd_dont_truncate_arname
#define oasys_write_armap                          ((bfd_boolean (*) (bfd *, unsigned int, struct orl *, unsigned int, int)) bfd_true)
#define oasys_read_ar_hdr                          bfd_nullvoidptr
#define oasys_write_ar_hdr ((bfd_boolean (*) (bfd *, bfd *)) bfd_false)
#define oasys_get_elt_at_index                     _bfd_generic_get_elt_at_index
#define oasys_update_armap_timestamp               bfd_true
#define oasys_bfd_is_local_label_name              bfd_generic_is_local_label_name
#define oasys_bfd_is_target_special_symbol         ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define oasys_get_lineno                           _bfd_nosymbols_get_lineno
#define oasys_bfd_make_debug_symbol                _bfd_nosymbols_bfd_make_debug_symbol
#define oasys_read_minisymbols                     _bfd_generic_read_minisymbols
#define oasys_minisymbol_to_symbol                 _bfd_generic_minisymbol_to_symbol
#define oasys_bfd_reloc_type_lookup                _bfd_norelocs_bfd_reloc_type_lookup
#define oasys_bfd_reloc_name_lookup          _bfd_norelocs_bfd_reloc_name_lookup
#define oasys_set_arch_mach                        bfd_default_set_arch_mach
#define oasys_get_section_contents_in_window       _bfd_generic_get_section_contents_in_window
#define oasys_bfd_get_relocated_section_contents   bfd_generic_get_relocated_section_contents
#define oasys_bfd_relax_section                    bfd_generic_relax_section
#define oasys_bfd_gc_sections                      bfd_generic_gc_sections
#define oasys_bfd_lookup_section_flags             bfd_generic_lookup_section_flags
#define oasys_bfd_merge_sections                   bfd_generic_merge_sections
#define oasys_bfd_is_group_section                 bfd_generic_is_group_section
#define oasys_bfd_discard_group                    bfd_generic_discard_group
#define oasys_section_already_linked               _bfd_generic_section_already_linked
#define oasys_bfd_define_common_symbol             bfd_generic_define_common_symbol
#define oasys_bfd_link_hash_table_create           _bfd_generic_link_hash_table_create
#define oasys_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
#define oasys_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
#define oasys_bfd_link_just_syms                   _bfd_generic_link_just_syms
#define oasys_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define oasys_bfd_final_link                       _bfd_generic_final_link
#define oasys_bfd_link_split_section               _bfd_generic_link_split_section

const bfd_target oasys_vec =
{
  "oasys",			/* Name.  */
  bfd_target_oasys_flavour,
  BFD_ENDIAN_BIG,		/* Target byte order.  */
  BFD_ENDIAN_BIG,		/* Target headers byte order.  */
  (HAS_RELOC | EXEC_P |		/* Object flags.  */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* Section flags.  */
  0,				/* Leading underscore.  */
  ' ',				/* AR_pad_char.  */
  16,				/* AR_max_namelen.  */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Data.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Headers.  */

  {_bfd_dummy_target,
   oasys_object_p,		/* bfd_check_format.  */
   oasys_archive_p,
   _bfd_dummy_target,
  },
  {				/* bfd_set_format.  */
    bfd_false,
    oasys_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {				/* bfd_write_contents.  */
    bfd_false,
    oasys_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (oasys),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (oasys),
  BFD_JUMP_TABLE_SYMBOLS (oasys),
  BFD_JUMP_TABLE_RELOCS (oasys),
  BFD_JUMP_TABLE_WRITE (oasys),
  BFD_JUMP_TABLE_LINK (oasys),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  NULL
};
@


1.47
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d909 3
a913 1
  (void) memset (r.module_name + length, ' ', sizeof (r.module_name) - length);
@


1.46
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1199 1
@


1.45
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d1227 1
@


1.44
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d3 2
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
@


1.43
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1182 1
@


1.42
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d789 1
a789 1
  unsigned int index = 0;
d802 2
a803 2
	  H_PUT_16 (abfd, index, symbol.refno);
	  index++;
d813 3
a815 3
	  H_PUT_16 (abfd, index, symbol.refno);
	  /* Overload the value field with the output index number */
	  index++;
d862 1
a862 1
      g->value = index - 1;
@


1.41
log
@update copyright dates
@
text
@d1206 2
@


1.40
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.39
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1087 1
a1087 1
  oasys_symbol_type *new = bfd_zalloc (abfd, amt);
d1089 1
a1089 1
  if (!new)
d1091 2
a1092 2
  new->symbol.the_bfd = abfd;
  return &new->symbol;
@


1.38
log
@Switch sources over to use the GPL version 3
@
text
@d1201 1
@


1.37
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.36
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.35
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d1190 1
@


1.34
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d1167 2
a1168 1
oasys_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean exec ATTRIBUTE_UNUSED)
@


1.33
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
a687 1
  newsect->used_by_bfd = bfd_alloc (abfd, (bfd_size_type) sizeof (oasys_per_section_type));
d689 6
a694 1
    return FALSE;
d704 1
a704 1
  return TRUE;
@


1.32
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d387 2
d392 2
a393 2
		per->reloc_tail_ptr
		  = (oasys_reloc_type **) &section->relocation;
@


1.31
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1135 9
@


1.30
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.29
log
@Convert to ISO C90 formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.28
log
@update copyright dates
@
text
@a29 61
static bfd_boolean oasys_slurp_section_data
  PARAMS ((bfd * const));
static bfd_boolean oasys_read_record
  PARAMS ((bfd *, oasys_record_union_type *));
static bfd_boolean oasys_write_sections
  PARAMS ((bfd *));
static bfd_boolean oasys_write_record
  PARAMS ((bfd *, oasys_record_enum_type, oasys_record_union_type *, size_t));
static bfd_boolean oasys_write_syms
  PARAMS ((bfd *));
static bfd_boolean oasys_write_header
  PARAMS ((bfd *));
static bfd_boolean oasys_write_end
  PARAMS ((bfd *));
static bfd_boolean oasys_write_data
  PARAMS ((bfd *));
static size_t oasys_string_length
  PARAMS ((oasys_record_union_type *));
static bfd_boolean oasys_slurp_symbol_table
  PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound
  PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p
  PARAMS ((bfd *));
static bfd_boolean oasys_mkobject
  PARAMS ((bfd *));
static const bfd_target *oasys_object_p
  PARAMS ((bfd *));
static void oasys_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void oasys_print_symbol
  PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type));
static bfd_boolean oasys_new_section_hook
  PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean oasys_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
static int comp
  PARAMS ((const void *, const void *));
static bfd_boolean oasys_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean oasys_set_section_contents
  PARAMS ((bfd *, sec_ptr, const void *, file_ptr, bfd_size_type));
static asymbol *oasys_make_empty_symbol
  PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean oasys_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma,
	   const char **, const char **, unsigned int *));
static int oasys_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

long oasys_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
long oasys_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

d33 1
a33 3
oasys_read_record (abfd, record)
     bfd *abfd;
     oasys_record_union_type *record;
d36 2
a37 1
  if (bfd_bread ((PTR) record, amt, abfd) != amt)
d43 1
a43 1
  if (bfd_bread ((PTR) ((char *) record + sizeof (record->header)), amt, abfd)
d50 1
a50 2
oasys_string_length (record)
     oasys_record_union_type *record;
d56 2
a57 6
/*****************************************************************************/

/*

Slurp the symbol table by reading in all the records at the start file
till we get to the first section record.
d59 3
a61 3
We'll sort the symbolss into  two lists, defined and undefined. The
undefined symbols will be placed into the table according to their
refno.
d63 2
a64 4
We do this by placing all undefined symbols at the front of the table
moving in, and the defined symbols at the end of the table moving back.

*/
d67 1
a67 2
oasys_slurp_symbol_table (abfd)
     bfd *const abfd;
d77 4
a80 5
  if (data->symbols != (asymbol *) NULL)
    {
      return TRUE;
    }
  /* Buy enough memory for all the symbols and all the names */
d83 1
a83 1
  data->symbols = (asymbol *) bfd_alloc (abfd, amt);
d87 1
a87 1
  /* buy 1 more char for each symbol to keep the underscore in*/
a101 1

d104 1
a114 1

d141 1
a141 4
		  {

		    dest->flags = flag;
		  }
a150 1

a151 1

d155 1
a155 1
		BFD_ASSERT (0);
d160 1
a160 1
	    dest->udata.p = (PTR) NULL;
a171 1

d184 1
a184 2
oasys_get_symtab_upper_bound (abfd)
     bfd *const abfd;
d194 2
a195 4
long
oasys_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
d199 1
d201 2
a202 3
    {
      return -1;
    }
d205 2
a206 3
    {
      *(location++) = symbase++;
    }
d211 1
a211 3
/***********************************************************************
*  archive stuff
*/
d214 1
a214 2
oasys_archive_p (abfd)
     bfd *abfd;
d224 1
a224 1
      || bfd_bread ((PTR) &header_ext, amt, abfd) != amt)
d240 12
a251 16
  /*
    There isn't a magic number in an Oasys archive, so the best we
    can do to verify reasonableness is to make sure that the values in
    the header are too weird
    */

  if (header.version > 10000 ||
      header.mod_count > 10000 ||
      header.sym_count > 100000 ||
      header.xref_count > 100000)
    return (const bfd_target *) NULL;

  /*
    That all worked, let's buy the space for the header and read in
    the headers.
    */
d258 1
a258 1
    ar = (oasys_ar_data_type *) bfd_alloc (abfd, amt);
d262 1
a262 1
    module = (oasys_module_info_type *) bfd_alloc (abfd, amt);
d277 1
a277 29
	/* There are two ways of specifying the archive header */

	if (0)
	  {
	    oasys_extmodule_table_type_a_type record_ext;

	    amt = sizeof (record_ext);
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
	      return NULL;

	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);

	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);

	    module[i].name = bfd_alloc (abfd, (bfd_size_type) 33);
	    if (!module[i].name)
	      return NULL;

	    memcpy (module[i].name, record_ext.mod_name, 33);
	    filepos +=
	      sizeof (record_ext) +
	      record.dep_count * 4 +
	      record.depee_count * 4 +
	      record.sect_count * 8 + 187;
	  }
	else
d282 1
a282 1
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
d298 1
a298 1
	    if (bfd_bread ((PTR) module[i].name, amt, abfd) != amt)
d315 1
a315 2
oasys_mkobject (abfd)
     bfd *abfd;
a317 3
  abfd->tdata.oasys_obj_data = (oasys_data_type *) bfd_alloc (abfd, amt);
  return abfd->tdata.oasys_obj_data != NULL;
}
d319 1
a319 9
#define MAX_SECS 16
static const bfd_target *
oasys_object_p (abfd)
     bfd *abfd;
{
  oasys_data_type *oasys;
  oasys_data_type *save = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;
d321 1
a321 116
  abfd->tdata.oasys_obj_data = 0;
  oasys_mkobject (abfd);
  oasys = OASYS_DATA (abfd);
  memset ((PTR) oasys->sections, 0xff, sizeof (oasys->sections));

  /* Point to the start of the file */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  oasys->symbol_string_length = 0;
  /* Inspect the records, but only keep the section info -
     remember the size of the symbols
     */
  oasys->first_data_record = 0;
  while (loop)
    {
      oasys_record_union_type record;
      if (! oasys_read_record (abfd, &record))
	goto fail;
      if ((size_t) record.header.length < (size_t) sizeof (record.header))
	goto fail;


      switch ((oasys_record_enum_type) (record.header.type))
	{
	case oasys_record_is_header_enum:
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_symbol_enum:
	case oasys_record_is_local_enum:
	  /* Count symbols and remember their size for a future malloc   */
	  abfd->symcount++;
	  oasys->symbol_string_length += 1 + oasys_string_length (&record);
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_section_enum:
	  {
	    asection *s;
	    char *buffer;
	    unsigned int section_number;
	    if (record.section.header.length != sizeof (record.section))
	      {
		goto fail;
	      }
	    buffer = bfd_alloc (abfd, (bfd_size_type) 3);
	    if (!buffer)
	      goto fail;
	    section_number = record.section.relb & RELOCATION_SECT_BITS;
	    sprintf (buffer, "%u", section_number);
	    s = bfd_make_section (abfd, buffer);
	    oasys->sections[section_number] = s;
	    switch (record.section.relb & RELOCATION_TYPE_BITS)
	      {
	      case RELOCATION_TYPE_ABS:
	      case RELOCATION_TYPE_REL:
		break;
	      case RELOCATION_TYPE_UND:
	      case RELOCATION_TYPE_COM:
		BFD_FAIL ();
	      }

	    s->size = H_GET_32 (abfd, record.section.value);
	    s->vma = H_GET_32 (abfd, record.section.vma);
	    s->flags = 0;
	    had_usefull = TRUE;
	  }
	  break;
	case oasys_record_is_data_enum:
	  oasys->first_data_record = bfd_tell (abfd) - record.header.length;
	case oasys_record_is_debug_enum:
	case oasys_record_is_module_enum:
	case oasys_record_is_named_section_enum:
	case oasys_record_is_end_enum:
	  if (! had_usefull)
	    goto fail;
	  loop = FALSE;
	  break;
	default:
	  goto fail;
	}
    }
  oasys->symbols = (asymbol *) NULL;
  /*
    Oasys support several architectures, but I can't see a simple way
    to discover which one is in a particular file - we'll guess
    */
  bfd_default_set_arch_mach (abfd, bfd_arch_m68k, 0);
  if (abfd->symcount != 0)
    {
      abfd->flags |= HAS_SYMS;
    }

  /*
    We don't know if a section has data until we've read it..
    */

  oasys_slurp_section_data (abfd);


  return abfd->xvec;

fail:
  (void) bfd_release (abfd, oasys);
  abfd->tdata.oasys_obj_data = save;
  return (const bfd_target *) NULL;
}


static void
oasys_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
d324 2
a325 8
static void
oasys_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;
a326 24
  switch (how)
    {
    case bfd_print_symbol_name:
    case bfd_print_symbol_more:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name = symbol->section == (asection *) NULL ?
	(const char *) "*abs" : symbol->section->name;

	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);

	fprintf (file, " %-5s %s",
		 section_name,
		 symbol->name);
      }
      break;
    }
}
/*
 The howto table is build using the top two bits of a reloc byte to
 index into it. The bits are PCREL,WORD/LONG
*/
d330 4
a333 4
  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32", TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
d336 2
a337 1
/* Read in all the section data and relocation stuff too */
d339 1
a339 2
oasys_slurp_section_data (abfd)
     bfd *const abfd;
d348 2
a349 2
  /* See if the data has been slurped already .. */
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
d361 1
d366 1
a372 1

d387 1
a387 1
		per->data = (bfd_byte *) bfd_zalloc (abfd, section->size);
d401 1
a401 1
		/* Take the first vma we see as the base */
d413 2
a414 3
	      {
		section->flags |= SEC_LOAD | SEC_HAS_CONTENTS;
	      }
d441 1
a441 1
			    /* This item needs to be relocated */
a444 1

d449 1
a449 1
				  /* Relocate the item relative to the section */
d453 1
a453 2
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
d458 2
a459 2
				  r->next = (oasys_reloc_type *) NULL;
				  /* Reference to undefined symbol */
d461 1
a461 1
				  /* There is no symbol */
d463 1
a463 1
				  /* Work out the howto */
d467 1
a467 1
				  r->relent.sym_ptr_ptr = (asymbol **) NULL;
a479 1

d485 1
a485 2
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
d490 2
a491 2
				  r->next = (oasys_reloc_type *) NULL;
				  /* Reference to undefined symbol */
d493 1
a493 1
				  /* Get symbol number */
d495 1
a495 1
				  /* Work out the howto */
d501 1
a501 1
				  r->relent.sym_ptr_ptr = (asymbol **) NULL;
d537 146
d684 1
a684 3
oasys_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
d686 1
a686 2
  newsect->used_by_bfd = (PTR)
    bfd_alloc (abfd, (bfd_size_type) sizeof (oasys_per_section_type));
d689 1
a689 1
  oasys_per_section (newsect)->data = (bfd_byte *) NULL;
a693 1
  /* Turn the section string into an index */
d695 1
d703 1
a703 3
oasys_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
d711 5
a715 6
oasys_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d718 1
d720 1
d722 1
a722 3
    {
      (void) memset (location, 0, (size_t) count);
    }
d724 2
a725 3
    {
      (void) memcpy (location, (PTR) (p->data + offset), (size_t) count);
    }
d729 5
a733 7

long
oasys_canonicalize_reloc (ignore_abfd, section, relptr, symbols)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols ATTRIBUTE_UNUSED;
a736 3
  while (src != (oasys_reloc_type *) NULL)
    {
      abort ();
d738 4
a741 5
      *relptr++ = &src->relent;
      src = src->next;
      reloc_count++;
    }
  *relptr = (arelent *) NULL;
d746 1
d748 1
a749 4
/* Writing */


/* Calculate the checksum and write one record */
d751 4
a754 5
oasys_write_record (abfd, type, record, size)
     bfd *abfd;
     oasys_record_enum_type type;
     oasys_record_union_type *record;
     size_t size;
d767 1
a767 3
    {
      checksum += *ptr++;
    }
d769 1
a769 1
  if (bfd_bwrite ((PTR) record, (bfd_size_type) size, abfd) != size)
d775 2
a776 1
/* Write out all the symbols */
d778 1
a778 2
oasys_write_syms (abfd)
     bfd *abfd;
d783 1
a785 1

a787 1

a801 1

d811 2
a812 4
	{
	  /* throw it away */
	  continue;
	}
d815 6
a820 4
	  if (g->section == (asection *) NULL)
	    {
	      /* Sometime, the oasys tools give out a symbol with illegal
	   bits in it, we'll output it in the same broken way */
a821 6
	      symbol.relb = RELOCATION_TYPE_REL | 0;
	    }
	  else
	    {
	      symbol.relb = RELOCATION_TYPE_REL | g->section->output_section->target_index;
	    }
d824 1
a836 1

d861 1
a862 1
 /* Write a section header for each section */
d864 1
a864 2
oasys_write_sections (abfd)
     bfd *abfd;
d869 1
a869 1
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
d893 1
a893 2
oasys_write_header (abfd)
     bfd *abfd;
d895 1
a895 1
  /* Create and write the header */
d898 1
d900 1
a900 3
    {
      length = sizeof (r.module_name);
    }
d902 2
a903 6
  (void) memcpy (r.module_name,
		 abfd->filename,
		 length);
  (void) memset (r.module_name + length,
		 ' ',
		 sizeof (r.module_name) - length);
a906 6
  if (! oasys_write_record (abfd,
			    oasys_record_is_header_enum,
			    (oasys_record_union_type *) & r,
			    offsetof (oasys_header_record_type,
				      description[0])))
    return FALSE;
d908 4
a911 1
  return TRUE;
d915 1
a915 2
oasys_write_end (abfd)
     bfd *abfd;
d919 1
d929 2
a930 3
  if (bfd_bwrite ((PTR) &null, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
d934 1
a934 3
comp (ap, bp)
     const PTR ap;
     const PTR bp;
d938 1
a941 4
/*
 Writing data..

*/
d943 1
a943 2
oasys_write_data (abfd)
     bfd *abfd;
d946 2
a947 1
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
d956 1
d958 3
a960 3
	    {
/* Sort the reloc records so it's easy to insert the relocs into the
	   data */
a961 5
	      qsort (s->orelocation,
		     s->reloc_count,
		     sizeof (arelent **),
		     comp);
	    }
d968 1
a968 1
	       there are any relocations going on */
a974 1

d979 5
a983 6
 	       within the same data record.  The worst case relocation is a
 	       4-byte relocatable value which is split across two modification
 	       bytes (1 relocation byte + 2 symbol reference bytes + 2 data +
 	       1 modification byte + 2 data = 8 bytes total).  That's where
 	       the magic number 8 comes from.
 	    */
d985 1
a985 1
		     &processed_data.data[sizeof (processed_data.data) - 8])
a986 2


d990 2
a991 2
		      reloc_howto_type *const how = r->howto;
		      /* There is a relocation, is it for this byte ? */
d993 2
a994 2
			{
			  unsigned char rel_byte;
a995 81
			  p++;
			  relocs_to_go--;

			  *mod |= (1 << i);
			  if (how->pc_relative)
			    {
			      rel_byte = RELOCATION_PCREL_BIT;

			      /* Also patch the raw data so that it doesn't have
			 the -ve stuff any more */
			      if (how->size != 2)
				{
				  bfd_put_16 (abfd,
					      bfd_get_16 (abfd, raw_data) +
					      current_byte_index, raw_data);
				}

			      else
				{
				  bfd_put_32 (abfd,
					      bfd_get_32 (abfd, raw_data) +
					      current_byte_index, raw_data);
				}
			    }
			  else
			    {
			      rel_byte = 0;
			    }
			  if (how->size == 2)
			    {
			      rel_byte |= RELOCATION_32BIT_BIT;
			    }

			  /* Is this a section relative relocation, or a symbol
			     relative relocation ? */
			  abort ();

			    {
			      asymbol *sym = *(r->sym_ptr_ptr);

			      /* If this symbol has a section attached, then it
			     has already been resolved.  Change from a symbol
			     ref to a section ref */
			      if (sym->section != (asection *) NULL)
				{
				  rel_byte |= RELOCATION_TYPE_REL;
				  rel_byte |=
				    sym->section->output_section->target_index;
				  *dst++ = rel_byte;
				}
			      else
				{
				  rel_byte |= RELOCATION_TYPE_UND;
				  *dst++ = rel_byte;
				  /* Next two bytes are a symbol index - we can get
			       this from the symbol value which has been zapped
			       into the symbol index in the table when the
			       symbol table was written
			       */
				  *dst++ = sym->value >> 8;
				  *dst++ = sym->value;
				}
			    }
#define ADVANCE { if (++i >= 8) { i = 0; mod = dst++; *mod = 0; } current_byte_index++; }
			  /* relocations never occur from an unloadable section,
		       so we can assume that raw_data is not NULL
		     */
			  *dst++ = *raw_data++;
			  ADVANCE
			    * dst++ = *raw_data++;
			  ADVANCE
			    if (how->size == 2)
			    {
			      *dst++ = *raw_data++;
			      ADVANCE
				* dst++ = *raw_data++;
			      ADVANCE
			    }
			  continue;
			}
		    }
d997 1
a997 1
		   zeros */
d999 1
a999 3
		    {
		      *dst++ = 0;
		    }
d1001 3
d1005 3
a1007 1
		      *dst++ = *raw_data++;
d1009 1
a1009 1
		  ADVANCE
d1012 1
a1012 1
	      /* Don't write a useless null modification byte */
d1014 1
a1014 3
		{
		  --dst;
		}
d1029 1
a1029 2
oasys_write_object_contents (abfd)
     bfd *abfd;
d1044 2
a1046 7


/** exec and core file sections */

/* set section contents is complicated with OASYS since the format is
* not a byte image, but a record stream.
*/
d1048 5
a1052 6
oasys_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d1056 1
a1056 1
      if (oasys_per_section (section)->data == (bfd_byte *) NULL)
d1058 1
a1058 2
	  oasys_per_section (section)->data =
	    (bfd_byte *) (bfd_alloc (abfd, section->size));
d1062 2
a1063 3
      (void) memcpy ((PTR) (oasys_per_section (section)->data + offset),
		     location,
		     (size_t) count);
d1070 1
a1070 1
/* Native-level interface to symbols. */
d1073 2
a1074 2
function exits.  We read the strings into a buffer large enough to
hold them all plus all the cached symbol entries. */
d1077 1
a1077 2
oasys_make_empty_symbol (abfd)
     bfd *abfd;
d1080 2
a1081 1
  oasys_symbol_type *new = (oasys_symbol_type *) bfd_zalloc (abfd, amt);
a1086 3



d1089 1
a1089 1
BFD_NO_MORE_SYMBOLS if there are none? */
d1092 1
a1092 3
oasys_openr_next_archived_file (arch, prev)
     bfd *arch;
     bfd *prev;
d1096 5
a1100 6
  /* take the next one from the arch state, or reset */
  if (prev == (bfd *) NULL)
    {
      /* Reset the index - the first two entries are bogus*/
      ar->module_index = 0;
    }
d1107 1
a1107 1
      if (p->abfd == (bfd *) NULL)
d1113 2
a1114 2
	  /* Fixup a pointer to this element for the member */
	  p->abfd->arelt_data = (PTR) p;
d1118 3
a1120 5
  else
    {
      bfd_set_error (bfd_error_no_more_archived_files);
      return (bfd *) NULL;
    }
d1124 7
a1130 9
oasys_find_nearest_line (abfd, section, symbols, offset,
			 filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
a1132 1

d1136 1
a1136 3
oasys_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
d1139 2
a1140 1
  if (mod == (oasys_module_info_type *) NULL)
d1145 4
a1148 6
  else
    {
      buf->st_size = mod->size;
      buf->st_mode = 0666;
      return 0;
    }
d1152 1
a1152 3
oasys_sizeof_headers (abfd, exec)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean exec ATTRIBUTE_UNUSED;
d1157 32
a1188 46
#define	oasys_close_and_cleanup _bfd_generic_close_and_cleanup
#define oasys_bfd_free_cached_info _bfd_generic_bfd_free_cached_info

#define oasys_slurp_armap bfd_true
#define oasys_slurp_extended_name_table bfd_true
#define oasys_construct_extended_name_table \
  ((bfd_boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
   bfd_true)
#define oasys_truncate_arname bfd_dont_truncate_arname
#define oasys_write_armap \
  ((bfd_boolean (*) \
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \
   bfd_true)
#define oasys_read_ar_hdr bfd_nullvoidptr
#define oasys_get_elt_at_index _bfd_generic_get_elt_at_index
#define oasys_update_armap_timestamp bfd_true

#define oasys_bfd_is_local_label_name bfd_generic_is_local_label_name
#define oasys_bfd_is_target_special_symbol ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define oasys_get_lineno _bfd_nosymbols_get_lineno
#define oasys_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define oasys_read_minisymbols _bfd_generic_read_minisymbols
#define oasys_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define oasys_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

#define oasys_set_arch_mach bfd_default_set_arch_mach

#define oasys_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define oasys_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define oasys_bfd_relax_section bfd_generic_relax_section
#define oasys_bfd_gc_sections bfd_generic_gc_sections
#define oasys_bfd_merge_sections bfd_generic_merge_sections
#define oasys_bfd_is_group_section bfd_generic_is_group_section
#define oasys_bfd_discard_group bfd_generic_discard_group
#define oasys_section_already_linked \
  _bfd_generic_section_already_linked
#define oasys_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define oasys_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define oasys_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define oasys_bfd_link_just_syms _bfd_generic_link_just_syms
#define oasys_bfd_final_link _bfd_generic_final_link
#define oasys_bfd_link_split_section _bfd_generic_link_split_section
a1189 1
/*SUPPRESS 460 */
d1192 1
a1192 1
  "oasys",			/* name */
d1194 3
a1196 3
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
d1200 4
a1203 4
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
d1206 1
a1206 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
d1209 1
a1209 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
d1212 1
a1212 1
   oasys_object_p,		/* bfd_check_format */
d1216 1
a1216 1
  {				/* bfd_set_format */
d1222 1
a1222 1
  {				/* bfd_write_contents */
d1241 1
a1241 1
  (PTR) 0
@


1.27
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
@


1.26
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@a740 8
#if 0
				  r->relent.section =
				    data->sections[reloc &
						   RELOCATION_SECT_BITS];

				  r->relent.addend = -
				    r->relent.section->vma;
#endif
a775 4
#if 0
				  r->relent.section = (asection
						       *) NULL;
#endif
a881 7
#if 0
      if (src->relent.section == (asection *) NULL)
	{
	  src->relent.sym_ptr_ptr = symbols + src->symbol;
	}
#endif

d1212 1
a1212 1
		       relative relocation ? */
a1214 11
#if 0
			  if (r->section != (asection *) NULL)
			    {
			      /* The relent has a section attached, so it must be section
			     relative */
			      rel_byte |= RELOCATION_TYPE_REL;
			      rel_byte |= r->section->output_section->target_index;
			      *dst++ = rel_byte;
			    }
			  else
#endif
@


1.25
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1492 1
@


1.24
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1511 2
@


1.23
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d510 1
a510 1
	    s->_raw_size = H_GET_32 (abfd, record.section.value);
d660 1
a660 1
		per->data = (bfd_byte *) bfd_zalloc (abfd, section->_raw_size);
d1058 1
a1058 1
      H_PUT_32 (abfd, s->_cooked_size, out.value);
d1162 1
a1162 1
	  while (current_byte_index < s->_cooked_size)
d1183 1
a1183 1
	      while (current_byte_index < s->_raw_size && dst <=
d1358 1
a1358 1
	    (bfd_byte *) (bfd_alloc (abfd, section->_cooked_size));
@


1.22
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d1509 1
@


1.22.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d510 1
a510 1
	    s->size = H_GET_32 (abfd, record.section.value);
d660 1
a660 1
		per->data = (bfd_byte *) bfd_zalloc (abfd, section->size);
d1058 1
a1058 1
      H_PUT_32 (abfd, s->size, out.value);
d1162 1
a1162 1
	  while (current_byte_index < s->size)
d1183 1
a1183 1
	      while (current_byte_index < s->size && dst <=
d1358 1
a1358 1
	    (bfd_byte *) (bfd_alloc (abfd, section->size));
a1508 1
#define oasys_bfd_is_group_section bfd_generic_is_group_section
a1509 2
#define oasys_section_already_linked \
  _bfd_generic_section_already_linked
@


1.21
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d327 1
a327 1
    can do to verify reasnableness is to make sure that the values in
@


1.20
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d73 1
a73 1
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
d1349 1
a1349 1
     PTR location;
@


1.19
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d86 1
a86 1
long oasys_get_symtab
d274 1
a274 1
oasys_get_symtab (abfd, location)
@


1.18
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001, 2002
   Free Software Foundation, Inc.
d867 1
a867 1
  oasys_per_section_type *p = (oasys_per_section_type *) section->used_by_bfd;
@


1.17
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d30 7
a36 4
static boolean oasys_slurp_section_data PARAMS ((bfd * const));
static boolean oasys_read_record PARAMS ((bfd *, oasys_record_union_type *));
static boolean oasys_write_sections PARAMS ((bfd *));
static boolean oasys_write_record
d38 22
a59 11
static boolean oasys_write_syms PARAMS ((bfd *));
static boolean oasys_write_header PARAMS ((bfd *));
static boolean oasys_write_end PARAMS ((bfd *));
static boolean oasys_write_data PARAMS ((bfd *));
static size_t oasys_string_length PARAMS ((oasys_record_union_type *));
static boolean oasys_slurp_symbol_table PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p PARAMS ((bfd *));
static boolean oasys_mkobject PARAMS ((bfd *));
static const bfd_target *oasys_object_p PARAMS ((bfd *));
static void oasys_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
d62 5
a66 3
static boolean oasys_new_section_hook PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
static boolean oasys_get_section_contents
d68 5
a72 3
static int comp PARAMS ((const void *, const void *));
static boolean oasys_write_object_contents PARAMS ((bfd *));
static boolean oasys_set_section_contents
d74 5
a78 3
static asymbol *oasys_make_empty_symbol PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file PARAMS ((bfd *, bfd *));
static boolean oasys_find_nearest_line
d81 4
a84 2
static int oasys_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers PARAMS ((bfd *, boolean));
d86 2
a87 1
long oasys_get_symtab PARAMS ((bfd *, asymbol **));
d93 1
a93 1
static boolean
d100 1
a100 1
    return false;
d104 1
a104 1
    return true;
d107 2
a108 2
    return false;
  return true;
d135 1
a135 1
static boolean
d141 1
a141 1
  boolean loop = true;
d149 1
a149 1
      return true;
d164 1
a164 1
    return false;
d170 1
a170 1
    return false;
d175 1
a175 1
	return false;
d255 1
a255 1
	  loop = false;
d258 1
a258 1
  return true;
d431 1
a431 1
static boolean
d447 2
a448 2
  boolean loop = true;
  boolean had_usefull = false;
d475 1
a475 1
	  had_usefull = true;
d482 1
a482 1
	  had_usefull = true;
d513 1
a513 1
	    had_usefull = true;
d524 1
a524 1
	  loop = false;
d604 4
a607 4
  HOWTO (0, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "abs16", true, 0x0000ffff, 0x0000ffff, false),
  HOWTO (0, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "abs32", true, 0xffffffff, 0xffffffff, false),
  HOWTO (0, 0, 1, 16, true, 0, complain_overflow_signed, 0, "pcrel16", true, 0x0000ffff, 0x0000ffff, false),
  HOWTO (0, 0, 2, 32, true, 0, complain_overflow_signed, 0, "pcrel32", true, 0xffffffff, 0xffffffff, false)
d611 1
a611 1
static boolean
d617 1
a617 1
  boolean loop = true;
d627 1
a627 1
	return true;
d631 1
a631 1
    return true;
d634 1
a634 1
    return false;
d638 1
a638 1
	return false;
d662 1
a662 1
		  return false;
d665 2
a666 2
		per->had_vma = false;
		per->initialized = true;
d676 1
a676 1
		per->had_vma = true;
d731 1
a731 1
				    return false;
d773 1
a773 1
				    return false;
d819 1
a819 1
	  loop = false;
d823 1
a823 1
  return true;
d827 1
a827 1
static boolean
d835 1
a835 1
    return false;
d839 1
a839 1
  oasys_per_section (newsect)->initialized = false;
d845 1
a845 1
  return true;
d859 1
a859 1
static boolean
d877 1
a877 1
  return true;
d916 1
a916 1
static boolean
d939 2
a940 2
    return false;
  return true;
d945 1
a945 1
static boolean
d1021 1
a1021 1
	    return false;
d1030 1
a1030 1
	    return false;
d1035 1
a1035 1
  return true;
d1040 1
a1040 1
static boolean
d1055 1
a1055 1
	  return false;
d1065 1
a1065 1
	return false;
d1067 1
a1067 1
  return true;
d1070 1
a1070 1
static boolean
d1096 1
a1096 1
    return false;
d1098 1
a1098 1
  return true;
d1101 1
a1101 1
static boolean
d1115 1
a1115 1
    return false;
d1117 2
a1118 2
    return false;
  return true;
d1135 1
a1135 1
static boolean
d1312 1
a1312 1
		return false;
d1317 1
a1317 1
  return true;
d1320 1
a1320 1
static boolean
d1325 1
a1325 1
    return false;
d1327 1
a1327 1
    return false;
d1329 1
a1329 1
    return false;
d1331 1
a1331 1
    return false;
d1333 2
a1334 2
    return false;
  return true;
d1345 1
a1345 1
static boolean
d1360 1
a1360 1
	    return false;
d1366 1
a1366 1
  return true;
d1432 1
a1432 1
static boolean
d1443 1
a1443 1
  return false;
d1469 1
a1469 1
     boolean exec ATTRIBUTE_UNUSED;
d1480 1
a1480 1
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d1484 1
a1484 1
  ((boolean (*) \
@


1.17.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,
   2002, 2003 Free Software Foundation, Inc.
d30 4
a33 7
static bfd_boolean oasys_slurp_section_data
  PARAMS ((bfd * const));
static bfd_boolean oasys_read_record
  PARAMS ((bfd *, oasys_record_union_type *));
static bfd_boolean oasys_write_sections
  PARAMS ((bfd *));
static bfd_boolean oasys_write_record
d35 11
a45 22
static bfd_boolean oasys_write_syms
  PARAMS ((bfd *));
static bfd_boolean oasys_write_header
  PARAMS ((bfd *));
static bfd_boolean oasys_write_end
  PARAMS ((bfd *));
static bfd_boolean oasys_write_data
  PARAMS ((bfd *));
static size_t oasys_string_length
  PARAMS ((oasys_record_union_type *));
static bfd_boolean oasys_slurp_symbol_table
  PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound
  PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p
  PARAMS ((bfd *));
static bfd_boolean oasys_mkobject
  PARAMS ((bfd *));
static const bfd_target *oasys_object_p
  PARAMS ((bfd *));
static void oasys_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d48 3
a50 5
static bfd_boolean oasys_new_section_hook
  PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean oasys_get_section_contents
d52 7
a58 11
static int comp
  PARAMS ((const void *, const void *));
static bfd_boolean oasys_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean oasys_set_section_contents
  PARAMS ((bfd *, sec_ptr, const void *, file_ptr, bfd_size_type));
static asymbol *oasys_make_empty_symbol
  PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean oasys_find_nearest_line
d61 2
a62 4
static int oasys_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d64 1
a64 2
long oasys_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
d70 1
a70 1
static bfd_boolean
d77 1
a77 1
    return FALSE;
d81 1
a81 1
    return TRUE;
d84 2
a85 2
    return FALSE;
  return TRUE;
d112 1
a112 1
static bfd_boolean
d118 1
a118 1
  bfd_boolean loop = TRUE;
d126 1
a126 1
      return TRUE;
d141 1
a141 1
    return FALSE;
d147 1
a147 1
    return FALSE;
d152 1
a152 1
	return FALSE;
d232 1
a232 1
	  loop = FALSE;
d235 1
a235 1
  return TRUE;
d251 1
a251 1
oasys_canonicalize_symtab (abfd, location)
d304 1
a304 1
    can do to verify reasonableness is to make sure that the values in
d408 1
a408 1
static bfd_boolean
d424 2
a425 2
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;
d452 1
a452 1
	  had_usefull = TRUE;
d459 1
a459 1
	  had_usefull = TRUE;
d490 1
a490 1
	    had_usefull = TRUE;
d501 1
a501 1
	  loop = FALSE;
d581 4
a584 4
  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32", TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
d588 1
a588 1
static bfd_boolean
d594 1
a594 1
  bfd_boolean loop = TRUE;
d604 1
a604 1
	return TRUE;
d608 1
a608 1
    return TRUE;
d611 1
a611 1
    return FALSE;
d615 1
a615 1
	return FALSE;
d639 1
a639 1
		  return FALSE;
d642 2
a643 2
		per->had_vma = FALSE;
		per->initialized = TRUE;
d653 1
a653 1
		per->had_vma = TRUE;
d708 1
a708 1
				    return FALSE;
d750 1
a750 1
				    return FALSE;
d796 1
a796 1
	  loop = FALSE;
d800 1
a800 1
  return TRUE;
d804 1
a804 1
static bfd_boolean
d812 1
a812 1
    return FALSE;
d816 1
a816 1
  oasys_per_section (newsect)->initialized = FALSE;
d822 1
a822 1
  return TRUE;
d836 1
a836 1
static bfd_boolean
d844 1
a844 1
  oasys_per_section_type *p = oasys_per_section (section);
d854 1
a854 1
  return TRUE;
d893 1
a893 1
static bfd_boolean
d916 2
a917 2
    return FALSE;
  return TRUE;
d922 1
a922 1
static bfd_boolean
d998 1
a998 1
	    return FALSE;
d1007 1
a1007 1
	    return FALSE;
d1012 1
a1012 1
  return TRUE;
d1017 1
a1017 1
static bfd_boolean
d1032 1
a1032 1
	  return FALSE;
d1042 1
a1042 1
	return FALSE;
d1044 1
a1044 1
  return TRUE;
d1047 1
a1047 1
static bfd_boolean
d1073 1
a1073 1
    return FALSE;
d1075 1
a1075 1
  return TRUE;
d1078 1
a1078 1
static bfd_boolean
d1092 1
a1092 1
    return FALSE;
d1094 2
a1095 2
    return FALSE;
  return TRUE;
d1112 1
a1112 1
static bfd_boolean
d1289 1
a1289 1
		return FALSE;
d1294 1
a1294 1
  return TRUE;
d1297 1
a1297 1
static bfd_boolean
d1302 1
a1302 1
    return FALSE;
d1304 1
a1304 1
    return FALSE;
d1306 1
a1306 1
    return FALSE;
d1308 1
a1308 1
    return FALSE;
d1310 2
a1311 2
    return FALSE;
  return TRUE;
d1322 1
a1322 1
static bfd_boolean
d1326 1
a1326 1
     const PTR location;
d1337 1
a1337 1
	    return FALSE;
d1343 1
a1343 1
  return TRUE;
d1409 1
a1409 1
static bfd_boolean
d1420 1
a1420 1
  return FALSE;
d1446 1
a1446 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d1457 1
a1457 1
  ((bfd_boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d1461 1
a1461 1
  ((bfd_boolean (*) \
@


1.17.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d30 4
a33 7
static bfd_boolean oasys_slurp_section_data
  PARAMS ((bfd * const));
static bfd_boolean oasys_read_record
  PARAMS ((bfd *, oasys_record_union_type *));
static bfd_boolean oasys_write_sections
  PARAMS ((bfd *));
static bfd_boolean oasys_write_record
d35 11
a45 22
static bfd_boolean oasys_write_syms
  PARAMS ((bfd *));
static bfd_boolean oasys_write_header
  PARAMS ((bfd *));
static bfd_boolean oasys_write_end
  PARAMS ((bfd *));
static bfd_boolean oasys_write_data
  PARAMS ((bfd *));
static size_t oasys_string_length
  PARAMS ((oasys_record_union_type *));
static bfd_boolean oasys_slurp_symbol_table
  PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound
  PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p
  PARAMS ((bfd *));
static bfd_boolean oasys_mkobject
  PARAMS ((bfd *));
static const bfd_target *oasys_object_p
  PARAMS ((bfd *));
static void oasys_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d48 3
a50 5
static bfd_boolean oasys_new_section_hook
  PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean oasys_get_section_contents
d52 3
a54 5
static int comp
  PARAMS ((const void *, const void *));
static bfd_boolean oasys_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean oasys_set_section_contents
d56 3
a58 5
static asymbol *oasys_make_empty_symbol
  PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean oasys_find_nearest_line
d61 2
a62 4
static int oasys_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d64 1
a64 2
long oasys_get_symtab
  PARAMS ((bfd *, asymbol **));
d70 1
a70 1
static bfd_boolean
d77 1
a77 1
    return FALSE;
d81 1
a81 1
    return TRUE;
d84 2
a85 2
    return FALSE;
  return TRUE;
d112 1
a112 1
static bfd_boolean
d118 1
a118 1
  bfd_boolean loop = TRUE;
d126 1
a126 1
      return TRUE;
d141 1
a141 1
    return FALSE;
d147 1
a147 1
    return FALSE;
d152 1
a152 1
	return FALSE;
d232 1
a232 1
	  loop = FALSE;
d235 1
a235 1
  return TRUE;
d408 1
a408 1
static bfd_boolean
d424 2
a425 2
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;
d452 1
a452 1
	  had_usefull = TRUE;
d459 1
a459 1
	  had_usefull = TRUE;
d490 1
a490 1
	    had_usefull = TRUE;
d501 1
a501 1
	  loop = FALSE;
d581 4
a584 4
  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32", TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
d588 1
a588 1
static bfd_boolean
d594 1
a594 1
  bfd_boolean loop = TRUE;
d604 1
a604 1
	return TRUE;
d608 1
a608 1
    return TRUE;
d611 1
a611 1
    return FALSE;
d615 1
a615 1
	return FALSE;
d639 1
a639 1
		  return FALSE;
d642 2
a643 2
		per->had_vma = FALSE;
		per->initialized = TRUE;
d653 1
a653 1
		per->had_vma = TRUE;
d708 1
a708 1
				    return FALSE;
d750 1
a750 1
				    return FALSE;
d796 1
a796 1
	  loop = FALSE;
d800 1
a800 1
  return TRUE;
d804 1
a804 1
static bfd_boolean
d812 1
a812 1
    return FALSE;
d816 1
a816 1
  oasys_per_section (newsect)->initialized = FALSE;
d822 1
a822 1
  return TRUE;
d836 1
a836 1
static bfd_boolean
d854 1
a854 1
  return TRUE;
d893 1
a893 1
static bfd_boolean
d916 2
a917 2
    return FALSE;
  return TRUE;
d922 1
a922 1
static bfd_boolean
d998 1
a998 1
	    return FALSE;
d1007 1
a1007 1
	    return FALSE;
d1012 1
a1012 1
  return TRUE;
d1017 1
a1017 1
static bfd_boolean
d1032 1
a1032 1
	  return FALSE;
d1042 1
a1042 1
	return FALSE;
d1044 1
a1044 1
  return TRUE;
d1047 1
a1047 1
static bfd_boolean
d1073 1
a1073 1
    return FALSE;
d1075 1
a1075 1
  return TRUE;
d1078 1
a1078 1
static bfd_boolean
d1092 1
a1092 1
    return FALSE;
d1094 2
a1095 2
    return FALSE;
  return TRUE;
d1112 1
a1112 1
static bfd_boolean
d1289 1
a1289 1
		return FALSE;
d1294 1
a1294 1
  return TRUE;
d1297 1
a1297 1
static bfd_boolean
d1302 1
a1302 1
    return FALSE;
d1304 1
a1304 1
    return FALSE;
d1306 1
a1306 1
    return FALSE;
d1308 1
a1308 1
    return FALSE;
d1310 2
a1311 2
    return FALSE;
  return TRUE;
d1322 1
a1322 1
static bfd_boolean
d1337 1
a1337 1
	    return FALSE;
d1343 1
a1343 1
  return TRUE;
d1409 1
a1409 1
static bfd_boolean
d1420 1
a1420 1
  return FALSE;
d1446 1
a1446 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d1457 1
a1457 1
  ((bfd_boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d1461 1
a1461 1
  ((bfd_boolean (*) \
@


1.17.12.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,
   2002, 2003 Free Software Foundation, Inc.
d867 1
a867 1
  oasys_per_section_type *p = oasys_per_section (section);
@


1.17.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d73 1
a73 1
  PARAMS ((bfd *, sec_ptr, const void *, file_ptr, bfd_size_type));
d86 1
a86 1
long oasys_canonicalize_symtab
d274 1
a274 1
oasys_canonicalize_symtab (abfd, location)
d1349 1
a1349 1
     const PTR location;
@


1.17.12.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d327 1
a327 1
    can do to verify reasonableness is to make sure that the values in
@


1.16
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d257 1
a257 1
  if (oasys_slurp_symbol_table (abfd) == false)
d414 1
a414 1
  return abfd->tdata.oasys_obj_data ? true : false;
d499 1
a499 1
	  if (had_usefull == false)
d603 1
a603 1
      if (per->initialized == true)
d635 1
a635 1
	    if (per->initialized == false)
d649 1
a649 1
	    if (per->had_vma == false)
d731 7
a737 10
				  /* Fake up the data to look like it's got the -ve pc in it, this makes
				       it much easier to convert into other formats. This is done by
				       hitting the addend.
				       */
				  if (r->relent.howto->pc_relative == true)
				    {
				      r->relent.addend -= dst_ptr - dst_base_ptr;
				    }


d772 7
a778 11
				  /* Fake up the data to look like it's got the -ve pc in it, this makes
				       it much easier to convert into other formats. This is done by
				       hitting the addend.
				       */
				  if (r->relent.howto->pc_relative == true)
				    {
				      r->relent.addend -= dst_ptr - dst_base_ptr;
				    }



d846 1
a846 1
  if (p->initialized == false)
@


1.15
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1493 1
@


1.15.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a1492 1
#define oasys_bfd_discard_group bfd_generic_discard_group
@


1.15.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d257 1
a257 1
  if (! oasys_slurp_symbol_table (abfd))
d414 1
a414 1
  return abfd->tdata.oasys_obj_data != NULL;
d499 1
a499 1
	  if (! had_usefull)
d603 1
a603 1
      if (per->initialized)
d635 1
a635 1
	    if (! per->initialized)
d649 1
a649 1
	    if (! per->had_vma)
d731 10
a740 7
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
d775 11
a785 7
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
d853 1
a853 1
  if (! p->initialized)
@


1.14
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1496 1
@


1.14.4.1
log
@merge from trunk
@
text
@a1492 1
#define oasys_bfd_discard_group bfd_generic_discard_group
a1495 1
#define oasys_bfd_link_just_syms _bfd_generic_link_just_syms
@


1.13
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001
d1494 1
@


1.12
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d25 1
a25 1
#include <ctype.h>
d1033 1
a1033 1
      if (!isdigit ((unsigned char) s->name[0]))
@


1.11
log
@Add missing prototypes
@
text
@d30 2
a31 2
static boolean oasys_read_record PARAMS ((bfd *,
					  oasys_record_union_type *));
d33 2
a34 4
static boolean oasys_write_record PARAMS ((bfd *,
					   oasys_record_enum_type,
					   oasys_record_union_type *,
					   size_t));
d46 2
a47 1
static void oasys_print_symbol PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type));
d59 2
a60 1
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, char **, char **, unsigned int *));
d65 2
a66 1
long oasys_canonicalize_reloc PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
a68 1
PROTO (static boolean, oasys_slurp_section_data, (bfd * CONST abfd));
d75 2
a76 2
  if (bfd_read ((PTR) record, 1, sizeof (record->header), abfd)
      != sizeof (record->header))
d79 2
a80 1
  if ((size_t) record->header.length <= (size_t) sizeof (record->header))
d82 2
a83 4
  if (bfd_read ((PTR) (((char *) record) + sizeof (record->header)),
		1, record->header.length - sizeof (record->header),
		abfd)
      != record->header.length - sizeof (record->header))
d87 1
d114 1
a114 1
     bfd *CONST abfd;
d122 1
a122 1

d129 5
a133 2
  data->symbols =
    (asymbol *) bfd_alloc (abfd, sizeof (asymbol) * abfd->symcount);
d136 1
a136 4
  data->strings = bfd_alloc (abfd, data->symbol_string_length +
			     abfd->symcount);
#else
  data->strings = bfd_alloc (abfd, data->symbol_string_length);
d138 2
d196 1
a196 1
		dest = data->symbols + bfd_h_get_16 (abfd, record.symbol.refno);
d215 1
a215 1
	    dest->value = bfd_h_get_32 (abfd, record.symbol.value);
d240 1
a240 1
     bfd *CONST abfd;
d282 1
d284 3
a286 3
  if (bfd_seek (abfd, (file_ptr) 0, false) != 0
      || (bfd_read ((PTR) & header_ext, 1, sizeof (header_ext), abfd)
	  != sizeof (header_ext)))
d293 8
a300 8
  header.version = bfd_h_get_32 (abfd, header_ext.version);
  header.mod_count = bfd_h_get_32 (abfd, header_ext.mod_count);
  header.mod_tbl_offset = bfd_h_get_32 (abfd, header_ext.mod_tbl_offset);
  header.sym_tbl_size = bfd_h_get_32 (abfd, header_ext.sym_tbl_size);
  header.sym_count = bfd_h_get_32 (abfd, header_ext.sym_count);
  header.sym_tbl_offset = bfd_h_get_32 (abfd, header_ext.sym_tbl_offset);
  header.xref_count = bfd_h_get_32 (abfd, header_ext.xref_count);
  header.xref_lst_offset = bfd_h_get_32 (abfd, header_ext.xref_lst_offset);
d319 6
a324 2
    oasys_ar_data_type *ar =
    (oasys_ar_data_type *) bfd_alloc (abfd, sizeof (oasys_ar_data_type));
d326 3
a328 4
    oasys_module_info_type *module =
    (oasys_module_info_type *)
    bfd_alloc (abfd, sizeof (oasys_module_info_type) * header.mod_count);
    oasys_module_table_type record;
d348 3
a350 2
	    if (bfd_read ((PTR) & record_ext, 1, sizeof (record_ext), abfd)
		!= sizeof (record_ext))
d353 2
a354 2
	    record.mod_size = bfd_h_get_32 (abfd, record_ext.mod_size);
	    record.file_offset = bfd_h_get_32 (abfd, record_ext.file_offset);
d356 3
a358 3
	    record.dep_count = bfd_h_get_32 (abfd, record_ext.dep_count);
	    record.depee_count = bfd_h_get_32 (abfd, record_ext.depee_count);
	    record.sect_count = bfd_h_get_32 (abfd, record_ext.sect_count);
d360 1
a360 1
	    module[i].name = bfd_alloc (abfd, 33);
d374 3
a376 2
	    if (bfd_read ((PTR) & record_ext, 1, sizeof (record_ext), abfd)
		!= sizeof (record_ext))
d379 2
a380 2
	    record.mod_size = bfd_h_get_32 (abfd, record_ext.mod_size);
	    record.file_offset = bfd_h_get_32 (abfd, record_ext.file_offset);
d382 5
a386 4
	    record.dep_count = bfd_h_get_32 (abfd, record_ext.dep_count);
	    record.depee_count = bfd_h_get_32 (abfd, record_ext.depee_count);
	    record.sect_count = bfd_h_get_32 (abfd, record_ext.sect_count);
	    record.module_name_size = bfd_h_get_32 (abfd, record_ext.mod_name_length);
d388 2
a389 1
	    module[i].name = bfd_alloc (abfd, record.module_name_size + 1);
d392 1
a392 3
	    if (bfd_read ((PTR) module[i].name, 1, record.module_name_size,
			  abfd)
		!= record.module_name_size)
d395 3
a397 5
	    filepos +=
	      sizeof (record_ext) +
	      record.dep_count * 4 +
	      record.module_name_size + 1;

a399 1

a403 1

d412 2
a413 2

  abfd->tdata.oasys_obj_data = (oasys_data_type *) bfd_alloc (abfd, sizeof (oasys_data_type));
d470 1
a470 1
	    buffer = bfd_alloc (abfd, 3);
d487 2
a488 2
	    s->_raw_size = bfd_h_get_32 (abfd, record.section.value);
	    s->vma = bfd_h_get_32 (abfd, record.section.vma);
d562 2
a563 2
	CONST char *section_name = symbol->section == (asection *) NULL ?
	(CONST char *) "*abs" : symbol->section->name;
d590 1
a590 1
     bfd *CONST abfd;
a594 1

a595 1

d597 1
d640 2
a641 1
		per->reloc_tail_ptr = (oasys_reloc_type **) & (section->relocation);
d648 1
a648 1
	    dst_offset = bfd_h_get_32 (abfd, record.data.addr);
d702 5
a706 4
				  oasys_reloc_type *r =
				  (oasys_reloc_type *)
				  bfd_alloc (abfd,
					     sizeof (oasys_reloc_type));
d747 5
a751 4
				  oasys_reloc_type *r =
				  (oasys_reloc_type *)
				  bfd_alloc (abfd,
					     sizeof (oasys_reloc_type));
d817 1
a817 1
    bfd_alloc (abfd, sizeof (oasys_per_section_type));
d855 1
a855 1
      (void) memset (location, 0, (int) count);
d859 1
a859 1
      (void) memcpy (location, (PTR) (p->data + offset), (int) count);
d922 1
a922 1
  if (bfd_write ((PTR) record, 1, size, abfd) != size)
d940 1
a940 1
      asymbol *CONST g = generic[count];
d942 1
a942 1
      CONST char *src = g->name;
d949 1
a949 1
	  bfd_h_put_16 (abfd, index, symbol.refno);
d955 1
a955 1
	  bfd_h_put_16 (abfd, 0, symbol.refno);
d961 1
a961 1
	  bfd_h_put_16 (abfd, index, symbol.refno);
d983 1
a983 1
	  bfd_h_put_16 (abfd, 0, symbol.refno);
d995 1
a995 1
      bfd_h_put_32 (abfd, g->value, symbol.value);
d1042 2
a1043 2
      bfd_h_put_32 (abfd, s->_cooked_size, out.value);
      bfd_h_put_32 (abfd, s->vma, out.vma);
d1092 2
a1093 2
  bfd_h_put_32 (abfd, abfd->start_address, end.entry);
  bfd_h_put_16 (abfd, 0, end.fill);
d1100 1
a1100 1
  if (bfd_write ((PTR) & null, 1, 1, abfd) != 1)
d1107 2
a1108 2
     CONST PTR ap;
     CONST PTR bp;
d1157 2
a1158 2
	      bfd_h_put_32 (abfd, s->vma + current_byte_index,
			    processed_data.addr);
d1230 1
a1230 1
			      asymbol *p = *(r->sym_ptr_ptr);
d1235 1
a1235 1
			      if (p->section != (asection *) NULL)
d1239 1
a1239 1
				    p->section->output_section->target_index;
d1251 2
a1252 2
				  *dst++ = p->value >> 8;
				  *dst++ = p->value;
d1292 4
a1295 5
	      if (! oasys_write_record (abfd,
					oasys_record_is_data_enum,
					((oasys_record_union_type *)
					 & processed_data),
					dst - (bfd_byte *) & processed_data))
d1365 2
a1366 3

  oasys_symbol_type *new =
  (oasys_symbol_type *) bfd_zalloc (abfd, sizeof (oasys_symbol_type));
d1417 2
a1418 7
oasys_find_nearest_line (abfd,
			 section,
			 symbols,
			 offset,
			 filename_ptr,
			 functionname_ptr,
			 line_ptr)
d1423 2
a1424 2
     char **filename_ptr ATTRIBUTE_UNUSED;
     char **functionname_ptr ATTRIBUTE_UNUSED;
d1549 1
a1549 1
  
@


1.10
log
@
	* oasys.c: Add missing prototypes.

	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Add unused
	attribute for parameter.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.

	* versados.c (get_4): Make static.
	(get_10): Make static.
	Add missing prototypes.
	(process_esd): Fix call to versados_new_symbol.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d64 4
a67 1
/* Read in all the section data and relocation stuff too */
a244 3

/*
*/
@


1.9
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999
d41 22
@


1.8
log
@	* archive.c (offsetof): Remove define.
	* elf.c: Likewise.
	* oasys.c: Likewise
	* sysdep.h (offsetof): Define.
@
text
@d520 2
a521 2
oasys_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d539 1
a539 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
@


1.7
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@a29 8
/* XXX - FIXME.  offsetof belongs in the system-specific files in
   ../include/sys. */
/* Define offsetof for those systems which lack it */

#ifndef offsetof
#define offsetof(type, identifier) (size_t) &(((type *) 0)->identifier)
#endif

@


1.6
log
@Update copyright notices
@
text
@d1479 1
@


1.5
log
@Revert previous patch.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.5.8.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999
@


1.4
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a1460 1
#define oasys_allow_commons_in_armap bfd_true
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d1461 1
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d1534 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d518 1
a518 1
     bfd *ignore_abfd;
d529 1
a529 1
     bfd *ignore_abfd;
d847 1
a847 1
     bfd *ignore_abfd;
d850 1
a850 1
     asymbol **symbols;
d1406 7
a1412 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     char **filename_ptr;
     char **functionname_ptr;
     unsigned int *line_ptr;
d1439 2
a1440 2
     bfd *abfd;
     boolean exec;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

