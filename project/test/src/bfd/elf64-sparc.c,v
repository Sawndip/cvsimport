head	1.131;
access;
symbols
	sid-snapshot-20180601:1.131
	sid-snapshot-20180501:1.131
	sid-snapshot-20180401:1.131
	sid-snapshot-20180301:1.131
	sid-snapshot-20180201:1.131
	sid-snapshot-20180101:1.131
	sid-snapshot-20171201:1.131
	sid-snapshot-20171101:1.131
	sid-snapshot-20171001:1.131
	sid-snapshot-20170901:1.131
	sid-snapshot-20170801:1.131
	sid-snapshot-20170701:1.131
	sid-snapshot-20170601:1.131
	sid-snapshot-20170501:1.131
	sid-snapshot-20170401:1.131
	sid-snapshot-20170301:1.131
	sid-snapshot-20170201:1.131
	sid-snapshot-20170101:1.131
	sid-snapshot-20161201:1.131
	sid-snapshot-20161101:1.131
	sid-snapshot-20160901:1.131
	sid-snapshot-20160801:1.131
	sid-snapshot-20160701:1.131
	sid-snapshot-20160601:1.131
	sid-snapshot-20160501:1.131
	sid-snapshot-20160401:1.131
	sid-snapshot-20160301:1.131
	sid-snapshot-20160201:1.131
	sid-snapshot-20160101:1.131
	sid-snapshot-20151201:1.131
	sid-snapshot-20151101:1.131
	sid-snapshot-20151001:1.131
	sid-snapshot-20150901:1.131
	sid-snapshot-20150801:1.131
	sid-snapshot-20150701:1.131
	sid-snapshot-20150601:1.131
	sid-snapshot-20150501:1.131
	sid-snapshot-20150401:1.131
	sid-snapshot-20150301:1.131
	sid-snapshot-20150201:1.131
	sid-snapshot-20150101:1.131
	sid-snapshot-20141201:1.131
	sid-snapshot-20141101:1.131
	sid-snapshot-20141001:1.131
	sid-snapshot-20140901:1.131
	sid-snapshot-20140801:1.131
	sid-snapshot-20140701:1.131
	sid-snapshot-20140601:1.131
	sid-snapshot-20140501:1.131
	sid-snapshot-20140401:1.131
	sid-snapshot-20140301:1.131
	sid-snapshot-20140201:1.131
	sid-snapshot-20140101:1.131
	sid-snapshot-20131201:1.131
	sid-snapshot-20131101:1.131
	sid-snapshot-20131001:1.131
	binutils-2_24-branch:1.131.0.2
	binutils-2_24-branchpoint:1.131
	binutils-2_21_1:1.124.2.1
	sid-snapshot-20130901:1.131
	gdb_7_6_1-2013-08-30-release:1.130
	sid-snapshot-20130801:1.131
	sid-snapshot-20130701:1.131
	sid-snapshot-20130601:1.131
	sid-snapshot-20130501:1.131
	gdb_7_6-2013-04-26-release:1.130
	sid-snapshot-20130401:1.131
	binutils-2_23_2:1.130
	gdb_7_6-branch:1.130.0.6
	gdb_7_6-2013-03-12-branchpoint:1.130
	sid-snapshot-20130301:1.130
	sid-snapshot-20130201:1.130
	sid-snapshot-20130101:1.130
	sid-snapshot-20121201:1.130
	gdb_7_5_1-2012-11-29-release:1.130
	binutils-2_23_1:1.130
	sid-snapshot-20121101:1.130
	binutils-2_23:1.130
	sid-snapshot-20121001:1.130
	sid-snapshot-20120901:1.130
	gdb_7_5-2012-08-17-release:1.130
	sid-snapshot-20120801:1.130
	binutils-2_23-branch:1.130.0.4
	binutils-2_23-branchpoint:1.130
	gdb_7_5-branch:1.130.0.2
	gdb_7_5-2012-07-18-branchpoint:1.130
	sid-snapshot-20120701:1.129
	sid-snapshot-20120601:1.128
	sid-snapshot-20120501:1.127
	binutils-2_22_branch:1.127.0.6
	gdb_7_4_1-2012-04-26-release:1.127
	sid-snapshot-20120401:1.127
	sid-snapshot-20120301:1.127
	sid-snapshot-20120201:1.127
	gdb_7_4-2012-01-24-release:1.127
	sid-snapshot-20120101:1.127
	gdb_7_4-branch:1.127.0.4
	gdb_7_4-2011-12-13-branchpoint:1.127
	sid-snapshot-20111201:1.127
	binutils-2_22:1.127
	sid-snapshot-20111101:1.127
	sid-snapshot-20111001:1.127
	binutils-2_22-branch:1.127.0.2
	binutils-2_22-branchpoint:1.127
	gdb_7_3_1-2011-09-04-release:1.125
	sid-snapshot-20110901:1.126
	sid-snapshot-20110801:1.126
	gdb_7_3-2011-07-26-release:1.125
	sid-snapshot-20110701:1.126
	sid-snapshot-20110601:1.126
	sid-snapshot-20110501:1.126
	gdb_7_3-branch:1.125.0.2
	gdb_7_3-2011-04-01-branchpoint:1.125
	sid-snapshot-20110401:1.125
	sid-snapshot-20110301:1.124
	sid-snapshot-20110201:1.124
	sid-snapshot-20110101:1.124
	binutils-2_21:1.124
	sid-snapshot-20101201:1.124
	binutils-2_21-branch:1.124.0.2
	binutils-2_21-branchpoint:1.124
	sid-snapshot-20101101:1.124
	sid-snapshot-20101001:1.122
	binutils-2_20_1:1.119
	gdb_7_2-2010-09-02-release:1.121
	sid-snapshot-20100901:1.121
	sid-snapshot-20100801:1.121
	gdb_7_2-branch:1.121.0.2
	gdb_7_2-2010-07-07-branchpoint:1.121
	sid-snapshot-20100701:1.121
	sid-snapshot-20100601:1.121
	sid-snapshot-20100501:1.121
	sid-snapshot-20100401:1.121
	gdb_7_1-2010-03-18-release:1.120
	sid-snapshot-20100301:1.121
	gdb_7_1-branch:1.120.0.2
	gdb_7_1-2010-02-18-branchpoint:1.120
	sid-snapshot-20100201:1.119
	sid-snapshot-20100101:1.119
	gdb_7_0_1-2009-12-22-release:1.119
	sid-snapshot-20091201:1.119
	sid-snapshot-20091101:1.119
	binutils-2_20:1.119
	gdb_7_0-2009-10-06-release:1.119
	sid-snapshot-20091001:1.119
	gdb_7_0-branch:1.119.0.4
	gdb_7_0-2009-09-16-branchpoint:1.119
	arc-sim-20090309:1.117
	binutils-arc-20081103-branch:1.117.0.22
	binutils-arc-20081103-branchpoint:1.117
	binutils-2_20-branch:1.119.0.2
	binutils-2_20-branchpoint:1.119
	sid-snapshot-20090901:1.118
	sid-snapshot-20090801:1.118
	msnyder-checkpoint-072509-branch:1.118.0.4
	msnyder-checkpoint-072509-branchpoint:1.118
	sid-snapshot-20090701:1.118
	dje-cgen-play1-branch:1.118.0.2
	dje-cgen-play1-branchpoint:1.118
	sid-snapshot-20090601:1.118
	sid-snapshot-20090501:1.117
	sid-snapshot-20090401:1.117
	arc-20081103-branch:1.117.0.20
	arc-20081103-branchpoint:1.117
	arc-insight_6_8-branch:1.117.0.18
	arc-insight_6_8-branchpoint:1.117
	insight_6_8-branch:1.117.0.16
	insight_6_8-branchpoint:1.117
	sid-snapshot-20090301:1.117
	binutils-2_19_1:1.117
	sid-snapshot-20090201:1.117
	sid-snapshot-20090101:1.117
	reverse-20081226-branch:1.117.0.14
	reverse-20081226-branchpoint:1.117
	sid-snapshot-20081201:1.117
	multiprocess-20081120-branch:1.117.0.12
	multiprocess-20081120-branchpoint:1.117
	sid-snapshot-20081101:1.117
	binutils-2_19:1.117
	sid-snapshot-20081001:1.117
	reverse-20080930-branch:1.117.0.10
	reverse-20080930-branchpoint:1.117
	binutils-2_19-branch:1.117.0.8
	binutils-2_19-branchpoint:1.117
	sid-snapshot-20080901:1.117
	sid-snapshot-20080801:1.117
	reverse-20080717-branch:1.117.0.6
	reverse-20080717-branchpoint:1.117
	sid-snapshot-20080701:1.117
	msnyder-reverse-20080609-branch:1.117.0.4
	msnyder-reverse-20080609-branchpoint:1.117
	drow-reverse-20070409-branch:1.112.0.2
	drow-reverse-20070409-branchpoint:1.112
	sid-snapshot-20080601:1.117
	sid-snapshot-20080501:1.117
	sid-snapshot-20080403:1.117
	sid-snapshot-20080401:1.117
	gdb_6_8-2008-03-27-release:1.117
	sid-snapshot-20080301:1.117
	gdb_6_8-branch:1.117.0.2
	gdb_6_8-2008-02-26-branchpoint:1.117
	sid-snapshot-20080201:1.116
	sid-snapshot-20080101:1.116
	sid-snapshot-20071201:1.116
	sid-snapshot-20071101:1.116
	gdb_6_7_1-2007-10-29-release:1.115
	gdb_6_7-2007-10-10-release:1.115
	sid-snapshot-20071001:1.115
	gdb_6_7-branch:1.115.0.4
	gdb_6_7-2007-09-07-branchpoint:1.115
	binutils-2_18:1.115
	binutils-2_18-branch:1.115.0.2
	binutils-2_18-branchpoint:1.115
	insight_6_6-20070208-release:1.110
	binutils-csl-coldfire-4_1-32:1.107
	binutils-csl-sourcerygxx-4_1-32:1.107
	gdb_6_6-2006-12-18-release:1.110
	binutils-csl-innovasic-fido-3_4_4-33:1.107
	binutils-csl-sourcerygxx-3_4_4-32:1.103
	binutils-csl-coldfire-4_1-30:1.107
	binutils-csl-sourcerygxx-4_1-30:1.107
	binutils-csl-coldfire-4_1-28:1.107
	binutils-csl-sourcerygxx-4_1-29:1.107
	binutils-csl-sourcerygxx-4_1-28:1.107
	gdb_6_6-branch:1.110.0.2
	gdb_6_6-2006-11-15-branchpoint:1.110
	binutils-csl-arm-2006q3-27:1.107
	binutils-csl-sourcerygxx-4_1-27:1.107
	binutils-csl-arm-2006q3-26:1.107
	binutils-csl-sourcerygxx-4_1-26:1.107
	binutils-csl-sourcerygxx-4_1-25:1.107
	binutils-csl-sourcerygxx-4_1-24:1.107
	binutils-csl-sourcerygxx-4_1-23:1.107
	insight_6_5-20061003-release:1.107
	gdb-csl-symbian-6_4_50_20060226-12:1.107
	binutils-csl-sourcerygxx-4_1-21:1.107
	binutils-csl-arm-2006q3-21:1.107
	binutils-csl-sourcerygxx-4_1-22:1.107
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.107
	binutils-csl-sourcerygxx-4_1-20:1.107
	binutils-csl-arm-2006q3-19:1.107
	binutils-csl-sourcerygxx-4_1-19:1.107
	binutils-csl-sourcerygxx-4_1-18:1.107
	binutils-csl-renesas-4_1-9:1.107
	gdb-csl-sourcerygxx-3_4_4-25:1.107
	binutils-csl-sourcerygxx-3_4_4-25:1.103
	nickrob-async-20060828-mergepoint:1.108
	gdb-csl-symbian-6_4_50_20060226-11:1.107
	binutils-csl-renesas-4_1-8:1.107
	binutils-csl-renesas-4_1-7:1.107
	binutils-csl-renesas-4_1-6:1.107
	gdb-csl-sourcerygxx-4_1-17:1.107
	binutils-csl-sourcerygxx-4_1-17:1.107
	gdb-csl-20060226-branch-local-2:1.107
	gdb-csl-sourcerygxx-4_1-14:1.107
	binutils-csl-sourcerygxx-4_1-14:1.107
	binutils-csl-sourcerygxx-4_1-15:1.107
	gdb-csl-sourcerygxx-4_1-13:1.107
	binutils-csl-sourcerygxx-4_1-13:1.107
	binutils-2_17:1.107
	gdb-csl-sourcerygxx-4_1-12:1.107
	binutils-csl-sourcerygxx-4_1-12:1.107
	gdb-csl-sourcerygxx-3_4_4-21:1.107
	binutils-csl-sourcerygxx-3_4_4-21:1.107
	gdb_6_5-20060621-release:1.107
	binutils-csl-wrs-linux-3_4_4-24:1.103
	binutils-csl-wrs-linux-3_4_4-23:1.103
	gdb-csl-sourcerygxx-4_1-9:1.107
	binutils-csl-sourcerygxx-4_1-9:1.107
	gdb-csl-sourcerygxx-4_1-8:1.107
	binutils-csl-sourcerygxx-4_1-8:1.107
	gdb-csl-sourcerygxx-4_1-7:1.107
	binutils-csl-sourcerygxx-4_1-7:1.107
	gdb-csl-arm-2006q1-6:1.107
	binutils-csl-arm-2006q1-6:1.107
	gdb-csl-sourcerygxx-4_1-6:1.107
	binutils-csl-sourcerygxx-4_1-6:1.107
	binutils-csl-wrs-linux-3_4_4-22:1.103
	gdb-csl-symbian-6_4_50_20060226-10:1.107
	gdb-csl-symbian-6_4_50_20060226-9:1.107
	gdb-csl-symbian-6_4_50_20060226-8:1.107
	gdb-csl-coldfire-4_1-11:1.107
	binutils-csl-coldfire-4_1-11:1.107
	gdb-csl-sourcerygxx-3_4_4-19:1.107
	binutils-csl-sourcerygxx-3_4_4-19:1.107
	gdb-csl-coldfire-4_1-10:1.107
	gdb_6_5-branch:1.107.0.30
	gdb_6_5-2006-05-14-branchpoint:1.107
	binutils-csl-coldfire-4_1-10:1.107
	gdb-csl-sourcerygxx-4_1-5:1.107
	binutils-csl-sourcerygxx-4_1-5:1.107
	nickrob-async-20060513-branch:1.107.0.28
	nickrob-async-20060513-branchpoint:1.107
	gdb-csl-sourcerygxx-4_1-4:1.107
	binutils-csl-sourcerygxx-4_1-4:1.107
	msnyder-reverse-20060502-branch:1.107.0.26
	msnyder-reverse-20060502-branchpoint:1.107
	binutils-csl-wrs-linux-3_4_4-21:1.103
	gdb-csl-morpho-4_1-4:1.107
	binutils-csl-morpho-4_1-4:1.107
	gdb-csl-sourcerygxx-3_4_4-17:1.107
	binutils-csl-sourcerygxx-3_4_4-17:1.107
	binutils-csl-wrs-linux-3_4_4-20:1.103
	readline_5_1-import-branch:1.107.0.24
	readline_5_1-import-branchpoint:1.107
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.107
	binutils-2_17-branch:1.107.0.22
	binutils-2_17-branchpoint:1.107
	gdb-csl-symbian-20060226-branch:1.107.0.20
	gdb-csl-symbian-20060226-branchpoint:1.107
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.107
	msnyder-reverse-20060331-branch:1.107.0.18
	msnyder-reverse-20060331-branchpoint:1.107
	binutils-csl-2_17-branch:1.107.0.16
	binutils-csl-2_17-branchpoint:1.107
	gdb-csl-available-20060303-branch:1.107.0.14
	gdb-csl-available-20060303-branchpoint:1.107
	gdb-csl-20060226-branch:1.107.0.12
	gdb-csl-20060226-branchpoint:1.107
	gdb_6_4-20051202-release:1.107
	msnyder-fork-checkpoint-branch:1.107.0.10
	msnyder-fork-checkpoint-branchpoint:1.107
	gdb-csl-gxxpro-6_3-branch:1.107.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.107
	gdb_6_4-branch:1.107.0.6
	gdb_6_4-2005-11-01-branchpoint:1.107
	gdb-csl-arm-20051020-branch:1.107.0.4
	gdb-csl-arm-20051020-branchpoint:1.107
	binutils-csl-gxxpro-3_4-branch:1.103.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.103
	binutils-2_16_1:1.103
	msnyder-tracepoint-checkpoint-branch:1.107.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.107
	gdb-csl-arm-20050325-2005-q1b:1.103
	binutils-csl-arm-2005q1b:1.103
	binutils-2_16:1.103
	gdb-csl-arm-20050325-2005-q1a:1.103
	binutils-csl-arm-2005q1a:1.103
	csl-arm-20050325-branch:1.103.0.6
	csl-arm-20050325-branchpoint:1.103
	binutils-csl-arm-2005q1-branch:1.103.0.4
	binutils-csl-arm-2005q1-branchpoint:1.103
	binutils-2_16-branch:1.103.0.2
	binutils-2_16-branchpoint:1.103
	csl-arm-2004-q3d:1.97
	gdb_6_3-20041109-release:1.96
	gdb_6_3-branch:1.96.0.2
	gdb_6_3-20041019-branchpoint:1.96
	csl-arm-2004-q3:1.96
	drow_intercu-merge-20040921:1.96
	drow_intercu-merge-20040915:1.94
	jimb-gdb_6_2-e500-branch:1.93.0.6
	jimb-gdb_6_2-e500-branchpoint:1.93
	gdb_6_2-20040730-release:1.93
	gdb_6_2-branch:1.93.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.93
	gdb_6_1_1-20040616-release:1.82
	binutils-2_15:1.82.6.2
	binutils-2_15-branchpoint:1.82
	csl-arm-2004-q1a:1.91
	csl-arm-2004-q1:1.86
	gdb_6_1-2004-04-05-release:1.82
	drow_intercu-merge-20040402:1.86
	drow_intercu-merge-20040327:1.85
	ezannoni_pie-20040323-branch:1.83.0.2
	ezannoni_pie-20040323-branchpoint:1.83
	cagney_tramp-20040321-mergepoint:1.82
	cagney_tramp-20040309-branch:1.82.0.12
	cagney_tramp-20040309-branchpoint:1.82
	gdb_6_1-branch:1.82.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.82
	drow_intercu-20040221-branch:1.82.0.8
	drow_intercu-20040221-branchpoint:1.82
	binutils-2_15-branch:1.82.0.6
	cagney_bfdfile-20040213-branch:1.82.0.4
	cagney_bfdfile-20040213-branchpoint:1.82
	drow-cplus-merge-20040208:1.82
	carlton_dictionary-20040126-merge:1.82
	cagney_bigcore-20040122-branch:1.82.0.2
	cagney_bigcore-20040122-branchpoint:1.82
	drow-cplus-merge-20040113:1.82
	csl-arm-2003-q4:1.82
	drow-cplus-merge-20031224:1.82
	drow-cplus-merge-20031220:1.82
	carlton_dictionary-20031215-merge:1.82
	drow-cplus-merge-20031214:1.82
	carlton-dictionary-20031111-merge:1.80
	gdb_6_0-2003-10-04-release:1.73
	kettenis_sparc-20030918-branch:1.78.0.6
	kettenis_sparc-20030918-branchpoint:1.78
	carlton_dictionary-20030917-merge:1.78
	ezannoni_pie-20030916-branchpoint:1.78
	ezannoni_pie-20030916-branch:1.78.0.4
	cagney_x86i386-20030821-branch:1.78.0.2
	cagney_x86i386-20030821-branchpoint:1.78
	carlton_dictionary-20030805-merge:1.75
	carlton_dictionary-20030627-merge:1.74
	gdb_6_0-branch:1.73.0.2
	gdb_6_0-2003-06-23-branchpoint:1.73
	jimb-ppc64-linux-20030613-branch:1.72.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.72
	binutils-2_14:1.70
	cagney_convert-20030606-branch:1.72.0.2
	cagney_convert-20030606-branchpoint:1.72
	cagney_writestrings-20030508-branch:1.71.0.8
	cagney_writestrings-20030508-branchpoint:1.71
	jimb-ppc64-linux-20030528-branch:1.71.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.71
	carlton_dictionary-20030523-merge:1.71
	cagney_fileio-20030521-branch:1.71.0.4
	cagney_fileio-20030521-branchpoint:1.71
	kettenis_i386newframe-20030517-mergepoint:1.71
	jimb-ppc64-linux-20030509-branch:1.71.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.71
	kettenis_i386newframe-20030504-mergepoint:1.70
	carlton_dictionary-20030430-merge:1.70
	binutils-2_14-branch:1.70.0.10
	binutils-2_14-branchpoint:1.70
	kettenis_i386newframe-20030419-branch:1.70.0.8
	kettenis_i386newframe-20030419-branchpoint:1.70
	carlton_dictionary-20030416-merge:1.70
	cagney_frameaddr-20030409-mergepoint:1.70
	kettenis_i386newframe-20030406-branch:1.70.0.6
	kettenis_i386newframe-20030406-branchpoint:1.70
	cagney_frameaddr-20030403-branchpoint:1.70
	cagney_frameaddr-20030403-branch:1.70.0.4
	cagney_framebase-20030330-mergepoint:1.70
	cagney_framebase-20030326-branch:1.70.0.2
	cagney_framebase-20030326-branchpoint:1.70
	cagney_lazyid-20030317-branch:1.69.0.8
	cagney_lazyid-20030317-branchpoint:1.69
	kettenis-i386newframe-20030316-mergepoint:1.69
	offbyone-20030313-branch:1.69.0.6
	offbyone-20030313-branchpoint:1.69
	kettenis-i386newframe-20030308-branch:1.69.0.4
	kettenis-i386newframe-20030308-branchpoint:1.69
	carlton_dictionary-20030305-merge:1.69
	cagney_offbyone-20030303-branch:1.69.0.2
	cagney_offbyone-20030303-branchpoint:1.69
	carlton_dictionary-20030207-merge:1.68
	interps-20030202-branch:1.67.0.2
	interps-20030202-branchpoint:1.67
	cagney-unwind-20030108-branch:1.65.0.2
	cagney-unwind-20030108-branchpoint:1.65
	binutils-2_13_2_1:1.58.2.3
	binutils-2_13_2:1.58.2.3
	carlton_dictionary-20021223-merge:1.65
	gdb_5_3-2002-12-12-release:1.59
	carlton_dictionary-20021115-merge:1.63
	binutils-2_13_1:1.58.2.2
	kseitz_interps-20021105-merge:1.60
	kseitz_interps-20021103-merge:1.60
	drow-cplus-merge-20021020:1.60
	drow-cplus-merge-20021025:1.60
	carlton_dictionary-20021025-merge:1.60
	carlton_dictionary-20021011-merge:1.60
	drow-cplus-branch:1.60.0.2
	drow-cplus-branchpoint:1.60
	kseitz_interps-20020930-merge:1.60
	carlton_dictionary-20020927-merge:1.60
	carlton_dictionary-branch:1.59.0.10
	carlton_dictionary-20020920-branchpoint:1.59
	sid-20020905-branchpoint:1.59
	sid-20020905-branch:1.59.0.8
	gdb_5_3-branch:1.59.0.6
	gdb_5_3-2002-09-04-branchpoint:1.59
	kseitz_interps-20020829-merge:1.59
	cagney_sysregs-20020825-branch:1.59.0.4
	cagney_sysregs-20020825-branchpoint:1.59
	readline_4_3-import-branch:1.59.0.2
	readline_4_3-import-branchpoint:1.59
	binutils-2_13:1.58
	gdb_5_2_1-2002-07-23-release:1.49
	binutils-2_13-branchpoint:1.58
	binutils-2_13-branch:1.58.0.2
	kseitz_interps-20020528-branch:1.53.0.6
	kseitz_interps-20020528-branchpoint:1.53
	cagney_regbuf-20020515-branch:1.53.0.4
	cagney_regbuf-20020515-branchpoint:1.53
	binutils-2_12_1:1.48.2.4
	jimb-macro-020506-branch:1.53.0.2
	jimb-macro-020506-branchpoint:1.53
	gdb_5_2-2002-04-29-release:1.49
	binutils-2_12:1.48.2.1
	gdb_5_2-branch:1.49.0.2
	gdb_5_2-2002-03-03-branchpoint:1.49
	binutils-2_12-branch:1.48.0.2
	binutils-2_12-branchpoint:1.48
	gdb_5_1_1-2002-01-24-release:1.30
	gdb_5_1_0_1-2002-01-03-release:1.30
	cygnus_cvs_20020108_pre:1.47
	gdb_5_1_0_1-2002-01-03-branch:1.30.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.30
	gdb_5_1-2001-11-21-release:1.30
	gdb_s390-2001-09-26-branch:1.30.0.4
	gdb_s390-2001-09-26-branchpoint:1.30
	gdb_5_1-2001-07-29-branch:1.30.0.2
	gdb_5_1-2001-07-29-branchpoint:1.30
	binutils-2_11_2:1.21.2.3
	binutils-2_11_1:1.21.2.3
	binutils-2_11:1.21
	x86_64versiong3:1.25
	binutils-2_11-branch:1.21.0.2
	insight-precleanup-2001-01-01:1.20
	binutils-2_10_1:1.12.2.1
	binutils-2_10:1.12
	gdb-premipsmulti-2000-06-06-branch:1.15.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.15
	gdb_5_0-2000-05-19-release:1.12
	gdb_4_18_2-2000-05-18-release:1.12
	gdb_4_95_1-2000-05-11-snapshot:1.12
	gdb_4_95_0-2000-04-27-snapshot:1.12
	gdb_5_0-2000-04-10-branch:1.12.0.4
	gdb_5_0-2000-04-10-branchpoint:1.12
	binutils-2_10-branch:1.12.0.2
	binutils-2_10-branchpoint:1.12
	binutils_latest_snapshot:1.131
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.5
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.131
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2012.07.13.14.22.48;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2012.06.29.14.46.02;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2012.05.01.16.07.34;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2011.09.21.20.49.12;	author davem;	state Exp;
branches;
next	1.126;

1.126
date	2011.04.11.08.13.21;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2011.03.14.15.54.58;	author rsandifo;	state Exp;
branches;
next	1.124;

1.124
date	2010.10.22.12.08.28;	author ro;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.121;

1.121
date	2010.02.19.05.07.49;	author hjl;	state Exp;
branches;
next	1.120;

1.120
date	2010.02.08.20.28.43;	author davem;	state Exp;
branches;
next	1.119;

1.119
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2009.05.21.14.15.49;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2007.10.18.09.13.51;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2007.07.10.04.08.12;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.110;

1.110
date	2006.10.18.23.58.51;	author vapier;	state Exp;
branches;
next	1.109;

1.109
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2005.05.04.15.53.27;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	2005.04.19.21.26.29;	author davem;	state Exp;
branches;
next	1.104;

1.104
date	2005.04.13.22.29.35;	author jakub;	state Exp;
branches;
next	1.103;

1.103
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2005.01.31.23.13.25;	author bje;	state Exp;
branches;
next	1.101;

1.101
date	2005.01.10.11.23.01;	author ebotcazou;	state Exp;
branches;
next	1.100;

1.100
date	2005.01.09.19.48.28;	author ebotcazou;	state Exp;
branches;
next	1.99;

1.99
date	2005.01.09.09.26.55;	author ebotcazou;	state Exp;
branches;
next	1.98;

1.98
date	2005.01.05.15.24.56;	author ebotcazou;	state Exp;
branches;
next	1.97;

1.97
date	2004.10.21.15.28.26;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2004.09.16.14.52.07;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.29.13.46.34;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.27.03.13.15;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.19.14.25.48;	author jakub;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.15.06.03.59;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.14.09.50.07;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2004.03.26.06.13.40;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.25.12.48.41;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches
	1.82.6.1
	1.82.8.1;
next	1.81;

1.81
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.78;

1.78
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2003.08.11.14.26.11;	author jakub;	state Exp;
branches;
next	1.76;

1.76
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.25.06.40.20;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.19.13.21.53;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.05.30.15.50.11;	author jakub;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.09.02.27.11;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.19.09.26.51;	author jakub;	state Exp;
branches
	1.70.8.1
	1.70.10.1;
next	1.69;

1.69
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.24.23.44.44;	author jakub;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.12.06.21.05;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.11.23.42.29;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.05.22.59.23;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.24.15.54.22;	author jakub;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches
	1.59.10.1;
next	1.58;

1.58
date	2002.07.11.05.33.28;	author amodra;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2002.07.10.04.59.42;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.08.03.01.47;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.05.13.32.02;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.16.04.58.12;	author amodra;	state Exp;
branches
	1.53.4.1
	1.53.6.1;
next	1.52;

1.52
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.03.17.42.39;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.01.10.00.49;	author rth;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.19.12.40.28;	author jakub;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.12.21.22.35.23;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.23.13.16.39;	author jakub;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.15.04.13.35;	author aoliva;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.11.23.51.36;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.07.16.50.36;	author jakub;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.25.22.12.29;	author jakub;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.23.15.14.16;	author jakub;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.17.09.44.18;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.11.07.59.54;	author aj;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.11.19.40.32;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.28.09.23.53;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.23.23.56.22;	author aoliva;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.19.22.35.47;	author jakub;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.09.17.53.16;	author jakub;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.09.17.31.11;	author jakub;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.09.16.19.25;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.12.08.18.34.32;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.20.10.38.45;	author jakub;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.16.20.49.53;	author geoffk;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.16.17.42.21;	author jakub;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.26.06.41.33;	author jakub;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.26.06.39.51;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.02.28.03.50.32;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.08.09.15.07.32;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.08.02.22.31.18;	author rth;	state Exp;
branches;
next	1.7;

1.7
date	99.07.30.21.42.21;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.07.30.21.34.43;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.07.16.21.28.40;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.07.16.21.25.28;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.07.13.18.21.25;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.06.10.20.59.54;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.124.2.1
date	2011.04.27.07.17.38;	author amodra;	state Exp;
branches;
next	;

1.82.6.1
date	2004.04.08.12.41.45;	author amodra;	state Exp;
branches;
next	1.82.6.2;

1.82.6.2
date	2004.04.16.03.41.35;	author amodra;	state Exp;
branches;
next	1.82.6.3;

1.82.6.3
date	2005.01.05.15.26.27;	author ebotcazou;	state Exp;
branches;
next	;

1.82.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.82.8.2;

1.82.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.82.8.3;

1.82.8.3
date	2004.09.16.17.00.32;	author drow;	state Exp;
branches;
next	1.82.8.4;

1.82.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.70.8.1
date	2003.05.18.09.43.47;	author kettenis;	state Exp;
branches;
next	;

1.70.10.1
date	2003.06.19.13.27.57;	author amodra;	state Exp;
branches;
next	;

1.60.2.1
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.59.10.1
date	2002.09.27.20.02.55;	author carlton;	state Exp;
branches;
next	1.59.10.2;

1.59.10.2
date	2002.11.15.19.18.27;	author carlton;	state Exp;
branches;
next	1.59.10.3;

1.59.10.3
date	2002.12.23.19.37.49;	author carlton;	state Exp;
branches;
next	1.59.10.4;

1.59.10.4
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.59.10.5;

1.59.10.5
date	2003.03.06.00.56.17;	author carlton;	state Exp;
branches;
next	1.59.10.6;

1.59.10.6
date	2003.04.16.19.56.45;	author carlton;	state Exp;
branches;
next	1.59.10.7;

1.59.10.7
date	2003.05.23.18.40.27;	author carlton;	state Exp;
branches;
next	1.59.10.8;

1.59.10.8
date	2003.06.27.21.49.23;	author carlton;	state Exp;
branches;
next	1.59.10.9;

1.59.10.9
date	2003.08.05.17.12.51;	author carlton;	state Exp;
branches;
next	1.59.10.10;

1.59.10.10
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.59.10.11;

1.59.10.11
date	2003.11.11.23.50.24;	author carlton;	state Exp;
branches;
next	1.59.10.12;

1.59.10.12
date	2003.12.15.23.59.40;	author carlton;	state Exp;
branches;
next	;

1.58.2.1
date	2002.10.28.18.45.44;	author drow;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.11.06.04.32.04;	author drow;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.11.14.16.23.07;	author obrien;	state Exp;
branches;
next	;

1.53.4.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.53.6.1
date	2002.06.20.01.30.43;	author kseitz;	state Exp;
branches;
next	1.53.6.2;

1.53.6.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.53.6.3;

1.53.6.3
date	2002.08.09.18.34.16;	author kseitz;	state Exp;
branches;
next	1.53.6.4;

1.53.6.4
date	2002.10.01.00.45.48;	author kseitz;	state Exp;
branches;
next	;

1.48.2.1
date	2002.02.19.13.10.28;	author jakub;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.04.01.10.03.25;	author rth;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2002.04.27.08.30.13;	author amodra;	state Exp;
branches;
next	;

1.21.2.1
date	2001.05.28.15.17.48;	author nickc;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.06.11.10.04.14;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.131
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@/* SPARC-specific support for 64-bit ELF
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/sparc.h"
#include "opcode/sparc.h"
#include "elfxx-sparc.h"

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
#define MINUS_ONE (~ (bfd_vma) 0)

/* Due to the way how we handle R_SPARC_OLO10, each entry in a SHT_RELA
   section can represent up to two relocs, we must tell the user to allocate
   more space.  */

static long
elf64_sparc_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  return (sec->reloc_count * 2 + 1) * sizeof (arelent *);
}

static long
elf64_sparc_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 2;
}

/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
   them.  We cannot use generic elf routines for this,  because R_SPARC_OLO10
   has secondary addend in ELF64_R_TYPE_DATA.  We handle it as two relocations
   for the same location,  R_SPARC_LO10 and R_SPARC_13.  */

static bfd_boolean
elf64_sparc_slurp_one_reloc_table (bfd *abfd, asection *asect,
				   Elf_Internal_Shdr *rel_hdr,
				   asymbol **symbols, bfd_boolean dynamic)
{
  void * allocated = NULL;
  bfd_byte *native_relocs;
  arelent *relent;
  unsigned int i;
  int entsize;
  bfd_size_type count;
  arelent *relents;

  allocated = bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    goto error_return;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || bfd_bread (allocated, rel_hdr->sh_size, abfd) != rel_hdr->sh_size)
    goto error_return;

  native_relocs = (bfd_byte *) allocated;

  relents = asect->relocation + canon_reloc_count (asect);

  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf64_External_Rela));

  count = rel_hdr->sh_size / entsize;

  for (i = 0, relent = relents; i < count;
       i++, relent++, native_relocs += entsize)
    {
      Elf_Internal_Rela rela;
      unsigned int r_type;

      bfd_elf64_swap_reloca_in (abfd, native_relocs, &rela);

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a normal BFD reloc is always section relative,
	 and the address of a dynamic reloc is absolute..  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
	relent->address = rela.r_offset;
      else
	relent->address = rela.r_offset - asect->vma;

      if (ELF64_R_SYM (rela.r_info) == STN_UNDEF)
	relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
      else
	{
	  asymbol **ps, *s;

	  ps = symbols + ELF64_R_SYM (rela.r_info) - 1;
	  s = *ps;

	  /* Canonicalize ELF section symbols.  FIXME: Why?  */
	  if ((s->flags & BSF_SECTION_SYM) == 0)
	    relent->sym_ptr_ptr = ps;
	  else
	    relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
	}

      relent->addend = rela.r_addend;

      r_type = ELF64_R_TYPE_ID (rela.r_info);
      if (r_type == R_SPARC_OLO10)
	{
	  relent->howto = _bfd_sparc_elf_info_to_howto_ptr (R_SPARC_LO10);
	  relent[1].address = relent->address;
	  relent++;
	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	  relent->addend = ELF64_R_TYPE_DATA (rela.r_info);
	  relent->howto = _bfd_sparc_elf_info_to_howto_ptr (R_SPARC_13);
	}
      else
	relent->howto = _bfd_sparc_elf_info_to_howto_ptr (r_type);
    }

  canon_reloc_count (asect) += relent - relents;

  if (allocated != NULL)
    free (allocated);

  return TRUE;

 error_return:
  if (allocated != NULL)
    free (allocated);
  return FALSE;
}

/* Read in and swap the external relocs.  */

static bfd_boolean
elf64_sparc_slurp_reloc_table (bfd *abfd, asection *asect,
			       asymbol **symbols, bfd_boolean dynamic)
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = d->rel.hdr;
      rel_hdr2 = d->rela.hdr;

      BFD_ASSERT ((rel_hdr && asect->rel_filepos == rel_hdr->sh_offset)
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      asect->reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
    }

  amt = asect->reloc_count;
  amt *= 2 * sizeof (arelent);
  asect->relocation = (arelent *) bfd_alloc (abfd, amt);
  if (asect->relocation == NULL)
    return FALSE;

  /* The elf64_sparc_slurp_one_reloc_table routine increments
     canon_reloc_count.  */
  canon_reloc_count (asect) = 0;

  if (rel_hdr
      && !elf64_sparc_slurp_one_reloc_table (abfd, asect, rel_hdr, symbols,
					     dynamic))
    return FALSE;

  if (rel_hdr2
      && !elf64_sparc_slurp_one_reloc_table (abfd, asect, rel_hdr2, symbols,
					     dynamic))
    return FALSE;

  return TRUE;
}

/* Canonicalize the relocs.  */

static long
elf64_sparc_canonicalize_reloc (bfd *abfd, sec_ptr section,
				arelent **relptr, asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < canon_reloc_count (section); i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return canon_reloc_count (section);
}


/* Canonicalize the dynamic relocation entries.  Note that we return
   the dynamic relocations as a single block, although they are
   actually associated with particular sections; the interface, which
   was designed for SunOS style shared libraries, expects that there
   is only one set of dynamic relocs.  Any section that was actually
   installed in the BFD, and has type SHT_REL or SHT_RELA, and uses
   the dynamic symbol table, is considered to be a dynamic reloc
   section.  */

static long
elf64_sparc_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
					asymbol **syms)
{
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! elf64_sparc_slurp_reloc_table (abfd, s, syms, TRUE))
	    return -1;
	  count = canon_reloc_count (s);
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Write out the relocs.  */

static void
elf64_sparc_write_relocs (bfd *abfd, asection *sec, void * data)
{
  bfd_boolean *failedp = (bfd_boolean *) data;
  Elf_Internal_Shdr *rela_hdr;
  bfd_vma addr_offset;
  Elf64_External_Rela *outbound_relocas, *src_rela;
  unsigned int idx, count;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  /* If we have already failed, don't do anything.  */
  if (*failedp)
    return;

  if ((sec->flags & SEC_RELOC) == 0)
    return;

  /* The linker backend writes the relocs out itself, and sets the
     reloc_count field to zero to inhibit writing them here.  Also,
     sometimes the SEC_RELOC flag gets set even when there aren't any
     relocs.  */
  if (sec->reloc_count == 0)
    return;

  /* We can combine two relocs that refer to the same address
     into R_SPARC_OLO10 if first one is R_SPARC_LO10 and the
     latter is R_SPARC_13 with no associated symbol.  */
  count = 0;
  for (idx = 0; idx < sec->reloc_count; idx++)
    {
      bfd_vma addr;

      ++count;

      addr = sec->orelocation[idx]->address;
      if (sec->orelocation[idx]->howto->type == R_SPARC_LO10
	  && idx < sec->reloc_count - 1)
	{
	  arelent *r = sec->orelocation[idx + 1];

	  if (r->howto->type == R_SPARC_13
	      && r->address == addr
	      && bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      && (*r->sym_ptr_ptr)->value == 0)
	    ++idx;
	}
    }

  rela_hdr = elf_section_data (sec)->rela.hdr;

  rela_hdr->sh_size = rela_hdr->sh_entsize * count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  /* Figure out whether the relocations are RELA or REL relocations.  */
  if (rela_hdr->sh_type != SHT_RELA)
    abort ();

  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;

  /* orelocation has the data, reloc_count has the count...  */
  outbound_relocas = (Elf64_External_Rela *) rela_hdr->contents;
  src_rela = outbound_relocas;

  for (idx = 0; idx < sec->reloc_count; idx++)
    {
      Elf_Internal_Rela dst_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      if (ptr->howto->type == R_SPARC_LO10
	  && idx < sec->reloc_count - 1)
	{
	  arelent *r = sec->orelocation[idx + 1];

	  if (r->howto->type == R_SPARC_13
	      && r->address == ptr->address
	      && bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      && (*r->sym_ptr_ptr)->value == 0)
	    {
	      idx++;
	      dst_rela.r_info
		= ELF64_R_INFO (n, ELF64_R_TYPE_INFO (r->addend,
						      R_SPARC_OLO10));
	    }
	  else
	    dst_rela.r_info = ELF64_R_INFO (n, R_SPARC_LO10);
	}
      else
	dst_rela.r_info = ELF64_R_INFO (n, ptr->howto->type);

      dst_rela.r_offset = ptr->address + addr_offset;
      dst_rela.r_addend = ptr->addend;

      bfd_elf64_swap_reloca_out (abfd, &dst_rela, (bfd_byte *) src_rela);
      ++src_rela;
    }
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it for STT_REGISTER symbols.  */

static bfd_boolean
elf64_sparc_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			     Elf_Internal_Sym *sym, const char **namep,
			     flagword *flagsp ATTRIBUTE_UNUSED,
			     asection **secp ATTRIBUTE_UNUSED,
			     bfd_vma *valp ATTRIBUTE_UNUSED)
{
  static const char *const stt_types[] = { "NOTYPE", "OBJECT", "FUNCTION" };

  if ((abfd->flags & DYNAMIC) == 0
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

  if (ELF_ST_TYPE (sym->st_info) == STT_REGISTER)
    {
      int reg;
      struct _bfd_sparc_elf_app_reg *p;

      reg = (int)sym->st_value;
      switch (reg & ~1)
	{
	case 2: reg -= 2; break;
	case 6: reg -= 4; break;
	default:
          (*_bfd_error_handler)
            (_("%B: Only registers %%g[2367] can be declared using STT_REGISTER"),
             abfd);
	  return FALSE;
	}

      if (info->output_bfd->xvec != abfd->xvec
	  || (abfd->flags & DYNAMIC) != 0)
        {
	  /* STT_REGISTER only works when linking an elf64_sparc object.
	     If STT_REGISTER comes from a dynamic object, don't put it into
	     the output bfd.  The dynamic linker will recheck it.  */
	  *namep = NULL;
	  return TRUE;
        }

      p = _bfd_sparc_elf_hash_table(info)->app_regs + reg;

      if (p->name != NULL && strcmp (p->name, *namep))
	{
          (*_bfd_error_handler)
            (_("Register %%g%d used incompatibly: %s in %B, previously %s in %B"),
             abfd, p->abfd, (int) sym->st_value,
             **namep ? *namep : "#scratch",
             *p->name ? p->name : "#scratch");
	  return FALSE;
	}

      if (p->name == NULL)
	{
	  if (**namep)
	    {
	      struct elf_link_hash_entry *h;

	      h = (struct elf_link_hash_entry *)
		bfd_link_hash_lookup (info->hash, *namep, FALSE, FALSE, FALSE);

	      if (h != NULL)
		{
		  unsigned char type = h->type;

		  if (type > STT_FUNC)
		    type = 0;
		  (*_bfd_error_handler)
		    (_("Symbol `%s' has differing types: REGISTER in %B, previously %s in %B"),
		     abfd, p->abfd, *namep, stt_types[type]);
		  return FALSE;
		}

	      p->name = bfd_hash_allocate (&info->hash->table,
					   strlen (*namep) + 1);
	      if (!p->name)
		return FALSE;

	      strcpy (p->name, *namep);
	    }
	  else
	    p->name = "";
	  p->bind = ELF_ST_BIND (sym->st_info);
	  p->abfd = abfd;
	  p->shndx = sym->st_shndx;
	}
      else
	{
	  if (p->bind == STB_WEAK
	      && ELF_ST_BIND (sym->st_info) == STB_GLOBAL)
	    {
	      p->bind = STB_GLOBAL;
	      p->abfd = abfd;
	    }
	}
      *namep = NULL;
      return TRUE;
    }
  else if (*namep && **namep
	   && info->output_bfd->xvec == abfd->xvec)
    {
      int i;
      struct _bfd_sparc_elf_app_reg *p;

      p = _bfd_sparc_elf_hash_table(info)->app_regs;
      for (i = 0; i < 4; i++, p++)
	if (p->name != NULL && ! strcmp (p->name, *namep))
	  {
	    unsigned char type = ELF_ST_TYPE (sym->st_info);

	    if (type > STT_FUNC)
	      type = 0;
	    (*_bfd_error_handler)
	      (_("Symbol `%s' has differing types: %s in %B, previously REGISTER in %B"),
	       abfd, p->abfd, *namep, stt_types[type]);
	    return FALSE;
	  }
    }
  return TRUE;
}

/* This function takes care of emitting STT_REGISTER symbols
   which we cannot easily keep in the symbol hash table.  */

static bfd_boolean
elf64_sparc_output_arch_syms (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info,
			      void * flaginfo,
			      int (*func) (void *, const char *,
					   Elf_Internal_Sym *,
					   asection *,
					   struct elf_link_hash_entry *))
{
  int reg;
  struct _bfd_sparc_elf_app_reg *app_regs =
    _bfd_sparc_elf_hash_table(info)->app_regs;
  Elf_Internal_Sym sym;

  /* We arranged in size_dynamic_sections to put the STT_REGISTER entries
     at the end of the dynlocal list, so they came at the end of the local
     symbols in the symtab.  Except that they aren't STB_LOCAL, so we need
     to back up symtab->sh_info.  */
  if (elf_hash_table (info)->dynlocal)
    {
      bfd * dynobj = elf_hash_table (info)->dynobj;
      asection *dynsymsec = bfd_get_linker_section (dynobj, ".dynsym");
      struct elf_link_local_dynamic_entry *e;

      for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	if (e->input_indx == -1)
	  break;
      if (e)
	{
	  elf_section_data (dynsymsec->output_section)->this_hdr.sh_info
	    = e->dynindx;
	}
    }

  if (info->strip == strip_all)
    return TRUE;

  for (reg = 0; reg < 4; reg++)
    if (app_regs [reg].name != NULL)
      {
	if (info->strip == strip_some
	    && bfd_hash_lookup (info->keep_hash,
				app_regs [reg].name,
				FALSE, FALSE) == NULL)
	  continue;

	sym.st_value = reg < 2 ? reg + 2 : reg + 4;
	sym.st_size = 0;
	sym.st_other = 0;
	sym.st_info = ELF_ST_INFO (app_regs [reg].bind, STT_REGISTER);
	sym.st_shndx = app_regs [reg].shndx;
	sym.st_target_internal = 0;
	if ((*func) (flaginfo, app_regs [reg].name, &sym,
		     sym.st_shndx == SHN_ABS
		     ? bfd_abs_section_ptr : bfd_und_section_ptr,
		     NULL) != 1)
	  return FALSE;
      }

  return TRUE;
}

static int
elf64_sparc_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_REGISTER)
    return STT_REGISTER;
  else
    return type;
}

/* A STB_GLOBAL,STT_REGISTER symbol should be BSF_GLOBAL
   even in SHN_UNDEF section.  */

static void
elf64_sparc_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED, asymbol *asym)
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  if (elfsym->internal_elf_sym.st_info
      == ELF_ST_INFO (STB_GLOBAL, STT_REGISTER))
    {
      asym->flags |= BSF_GLOBAL;
    }
}


/* Functions for dealing with the e_flags field.  */

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf64_sparc_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  bfd_boolean error;
  flagword new_flags, old_flags;
  int new_mm, old_mm;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))   /* First call, no flags set */
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  else if (new_flags == old_flags)      /* Compatible flags are ok */
    ;

  else                                  /* Incompatible flags */
    {
      error = FALSE;

#define EF_SPARC_ISA_EXTENSIONS \
  (EF_SPARC_SUN_US1 | EF_SPARC_SUN_US3 | EF_SPARC_HAL_R1)

      if ((ibfd->flags & DYNAMIC) != 0)
	{
	  /* We don't want dynamic objects memory ordering and
	     architecture to have any role. That's what dynamic linker
	     should do.  */
	  new_flags &= ~(EF_SPARCV9_MM | EF_SPARC_ISA_EXTENSIONS);
	  new_flags |= (old_flags
			& (EF_SPARCV9_MM | EF_SPARC_ISA_EXTENSIONS));
	}
      else
	{
	  /* Choose the highest architecture requirements.  */
	  old_flags |= (new_flags & EF_SPARC_ISA_EXTENSIONS);
	  new_flags |= (old_flags & EF_SPARC_ISA_EXTENSIONS);
	  if ((old_flags & (EF_SPARC_SUN_US1 | EF_SPARC_SUN_US3))
	      && (old_flags & EF_SPARC_HAL_R1))
	    {
	      error = TRUE;
	      (*_bfd_error_handler)
		(_("%B: linking UltraSPARC specific with HAL specific code"),
		 ibfd);
	    }
	  /* Choose the most restrictive memory ordering.  */
	  old_mm = (old_flags & EF_SPARCV9_MM);
	  new_mm = (new_flags & EF_SPARCV9_MM);
	  old_flags &= ~EF_SPARCV9_MM;
	  new_flags &= ~EF_SPARCV9_MM;
	  if (new_mm < old_mm)
	    old_mm = new_mm;
	  old_flags |= old_mm;
	  new_flags |= old_mm;
	}

      /* Warn about any other mismatches */
      if (new_flags != old_flags)
        {
          error = TRUE;
          (*_bfd_error_handler)
            (_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
             ibfd, (long) new_flags, (long) old_flags);
        }

      elf_elfheader (obfd)->e_flags = old_flags;

      if (error)
        {
          bfd_set_error (bfd_error_bad_value);
          return FALSE;
        }
    }
  return _bfd_sparc_elf_merge_private_bfd_data (ibfd, obfd);
}

/* MARCO: Set the correct entry size for the .stab section.  */

static bfd_boolean
elf64_sparc_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
			   Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED,
			   asection *sec)
{
  const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".stab") == 0)
    {
      /* Even in the 64bit case the stab entries are only 12 bytes long.  */
      elf_section_data (sec)->this_hdr.sh_entsize = 12;
    }

  return TRUE;
}

/* Print a STT_REGISTER symbol to file FILE.  */

static const char *
elf64_sparc_print_symbol_all (bfd *abfd ATTRIBUTE_UNUSED, void * filep,
			      asymbol *symbol)
{
  FILE *file = (FILE *) filep;
  int reg, type;

  if (ELF_ST_TYPE (((elf_symbol_type *) symbol)->internal_elf_sym.st_info)
      != STT_REGISTER)
    return NULL;

  reg = ((elf_symbol_type *) symbol)->internal_elf_sym.st_value;
  type = symbol->flags;
  fprintf (file, "REG_%c%c%11s%c%c    R", "GOLI" [reg / 8], '0' + (reg & 7), "",
		 ((type & BSF_LOCAL)
		  ? (type & BSF_GLOBAL) ? '!' : 'l'
	          : (type & BSF_GLOBAL) ? 'g' : ' '),
	         (type & BSF_WEAK) ? 'w' : ' ');
  if (symbol->name == NULL || symbol->name [0] == '\0')
    return "#scratch";
  else
    return symbol->name;
}

static enum elf_reloc_type_class
elf64_sparc_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			      const asection *rel_sec ATTRIBUTE_UNUSED,
			      const Elf_Internal_Rela *rela)
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_SPARC_RELATIVE:
      return reloc_class_relative;
    case R_SPARC_JMP_SLOT:
      return reloc_class_plt;
    case R_SPARC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Relocations in the 64 bit SPARC ELF ABI are more complex than in
   standard ELF, because R_SPARC_OLO10 has secondary addend in
   ELF64_R_TYPE_DATA field.  This structure is used to redirect the
   relocation handling routines.  */

const struct elf_size_info elf64_sparc_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  4,		/* hash-table entry size.  */
  /* Internal relocations per external relocations.
     For link purposes we use just 1 internal per
     1 external, for assembly and slurp symbol table
     we use 2.  */
  1,
  64,		/* arch_size.  */
  3,		/* log_file_align.  */
  ELFCLASS64,
  EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_checksum_contents,
  elf64_sparc_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  elf64_sparc_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
};

#define TARGET_BIG_SYM	bfd_elf64_sparc_vec
#define TARGET_BIG_NAME	"elf64-sparc"
#define ELF_ARCH	bfd_arch_sparc
#define ELF_MAXPAGESIZE 0x100000
#define ELF_COMMONPAGESIZE 0x2000

/* This is the official ABI value.  */
#define ELF_MACHINE_CODE EM_SPARCV9

/* This is the value that we used before the ABI was released.  */
#define ELF_MACHINE_ALT1 EM_OLD_SPARCV9

#define elf_backend_reloc_type_class \
  elf64_sparc_reloc_type_class
#define bfd_elf64_get_reloc_upper_bound \
  elf64_sparc_get_reloc_upper_bound
#define bfd_elf64_get_dynamic_reloc_upper_bound \
  elf64_sparc_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_reloc \
  elf64_sparc_canonicalize_reloc
#define bfd_elf64_canonicalize_dynamic_reloc \
  elf64_sparc_canonicalize_dynamic_reloc
#define elf_backend_add_symbol_hook \
  elf64_sparc_add_symbol_hook
#define elf_backend_get_symbol_type \
  elf64_sparc_get_symbol_type
#define elf_backend_symbol_processing \
  elf64_sparc_symbol_processing
#define elf_backend_print_symbol_all \
  elf64_sparc_print_symbol_all
#define elf_backend_output_arch_syms \
  elf64_sparc_output_arch_syms
#define bfd_elf64_bfd_merge_private_bfd_data \
  elf64_sparc_merge_private_bfd_data
#define elf_backend_fake_sections \
  elf64_sparc_fake_sections
#define elf_backend_size_info \
  elf64_sparc_size_info

#define elf_backend_plt_sym_val	\
  _bfd_sparc_elf_plt_sym_val
#define bfd_elf64_bfd_link_hash_table_create \
  _bfd_sparc_elf_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free \
  _bfd_sparc_elf_link_hash_table_free
#define elf_info_to_howto \
  _bfd_sparc_elf_info_to_howto
#define elf_backend_copy_indirect_symbol \
  _bfd_sparc_elf_copy_indirect_symbol
#define bfd_elf64_bfd_reloc_type_lookup \
  _bfd_sparc_elf_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup \
  _bfd_sparc_elf_reloc_name_lookup
#define bfd_elf64_bfd_relax_section \
  _bfd_sparc_elf_relax_section
#define bfd_elf64_new_section_hook \
  _bfd_sparc_elf_new_section_hook

#define elf_backend_create_dynamic_sections \
  _bfd_sparc_elf_create_dynamic_sections
#define elf_backend_relocs_compatible \
  _bfd_elf_relocs_compatible
#define elf_backend_check_relocs \
  _bfd_sparc_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
  _bfd_sparc_elf_adjust_dynamic_symbol
#define elf_backend_omit_section_dynsym \
  _bfd_sparc_elf_omit_section_dynsym
#define elf_backend_size_dynamic_sections \
  _bfd_sparc_elf_size_dynamic_sections
#define elf_backend_relocate_section \
  _bfd_sparc_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
  _bfd_sparc_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
  _bfd_sparc_elf_finish_dynamic_sections

#define bfd_elf64_mkobject \
  _bfd_sparc_elf_mkobject
#define elf_backend_object_p \
  _bfd_sparc_elf_object_p
#define elf_backend_gc_mark_hook \
  _bfd_sparc_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook \
  _bfd_sparc_elf_gc_sweep_hook
#define elf_backend_init_index_section \
  _bfd_elf_init_1_index_section

#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 0
#define elf_backend_plt_readonly 0
#define elf_backend_want_plt_sym 1
#define elf_backend_got_header_size 8
#define elf_backend_rela_normal 1

/* Section 5.2.4 of the ABI specifies a 256-byte boundary for the table.  */
#define elf_backend_plt_alignment 8

#define elf_backend_post_process_headers	_bfd_elf_set_osabi

#include "elf64-target.h"

/* FreeBSD support */
#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM bfd_elf64_sparc_freebsd_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME "elf64-sparc-freebsd"
#undef	ELF_OSABI
#define	ELF_OSABI ELFOSABI_FREEBSD

#undef  elf64_bed
#define elf64_bed				elf64_sparc_fbsd_bed

#include "elf64-target.h"

/* Solaris 2.  */

#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM				bfd_elf64_sparc_sol2_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME				"elf64-sparc-sol2"

/* Restore default: we cannot use ELFOSABI_SOLARIS, otherwise ELFOSABI_NONE
   objects won't be recognized.  */
#undef	ELF_OSABI

#undef elf64_bed
#define elf64_bed				elf64_sparc_sol2_bed

/* The 64-bit static TLS arena size is rounded to the nearest 16-byte
   boundary.  */
#undef elf_backend_static_tls_alignment
#define elf_backend_static_tls_alignment	16

#include "elf64-target.h"
@


1.130
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d768 3
a770 1
elf64_sparc_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.129
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d60 1
a60 1
  PTR allocated = NULL;
d68 1
a68 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d282 1
a282 1
elf64_sparc_write_relocs (bfd *abfd, asection *sec, PTR data)
d333 1
a333 1
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
d548 2
a549 2
			      PTR flaginfo,
			      int (*func) (PTR, const char *,
d744 1
a744 1
elf64_sparc_print_symbol_all (bfd *abfd ATTRIBUTE_UNUSED, PTR filep,
@


1.128
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d566 1
a566 1
      asection *dynsymsec = bfd_get_section_by_name (dynobj, ".dynsym");
@


1.127
log
@Annotate sparc objects with cpu hardware capabilities used.

bfd/

	* elfxx-sparc.c (_bfd_sparc_elf_merge_private_bfd_data): New.
	* elfxx-sparc.h: Declare it.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Call it.
	* elf64-sparc.c (elf64_sparc_merge_private_bfd_data): Likewise.

binutils/

	* readelf.c (display_sparc_hwcaps): New.
	(display_sparc_gnu_attribute): New.
	(process_sparc_specific): New.
	(process_arch_specific): When EM_SPARC, EM_SPARC32PLUS,
	or EM_SPARCV9 invoke process_sparc_specific.

gas/

	* config/tc-sparc.c (hwcap_seen): New bitmask, defined when
	not TE_SOLARIS.
	(sparc_ip): When not TE_SOLARIS, accumulate hwcap bits from
	sparc_opcode->flags of instruction into hwcap_seen.
	(sparc_md_end): Create Tag_GNU_Sparc_HWCAPS attribute if
	hwcap_seen is non-zero and not TE_SOLARIS.

gas/testsuite/

	* gas/sparc/hpcvis3.s: Update for fixed fchksum16 mnemonic.
	* gas/sparc/hpcvis3.d: Likewise.

include/elf/

	* sparc.h (Tag_GNU_Sparc_HWCAPS): New object attribute.
	(ELF_SPARC_HWCAP_*): New HWCAPS bitmask values.

include/opcode/

	* sparc.h (struct sparc_opcode): Expand 'flags' to unsigned int.
	(F_MUL32, F_DIV32, F_FSMULD, F_V8PLUS, F_POPC, F_VIS, F_VIS2,
	F_ASI_BLK_INIT, F_FMAF, F_VIS3, F_HPC, F_RANDOM, F_TRANS,
	F_FJFMAU, F_IMA, F_ASI_CACHE_SPARING): New flag bits.

opcodes/

	* sparc-opc.c (sparc_opcodes): Annotate table with HWCAP flag
	bits.  Fix "fchksm16" mnemonic.
@
text
@d548 1
a548 1
			      PTR finfo,
d597 1
a597 1
	if ((*func) (finfo, app_regs [reg].name, &sym,
@


1.126
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d718 1
a718 1
  return TRUE;
@


1.125
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d429 3
a431 2
      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
    elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.124
log
@	ld:
	* emulparams/elf32_sparc_sol2.sh (OUTPUT_FORMAT): Set to
	elf32-sparc-sol2.
	* emulparams/elf64_sparc_sol2.sh (OUTPUT_FORMAT): Set to
	elf64-sparc-sol2.

	gas:
	* config/tc-sparc.h [TE_SOLARIS] (ELF_TARGET_FORMAT): Define as
	elf32-sparc-sol2.
	(ELF64_TARGET_FORMAT): Define as elf64-sparc-sol2.

	bfd:
	* elfxx-sparc.c (tpoff): Define bed, static_tls_size.
	Consider static_tls_alignment.

	* elf32-sparc.c (TARGET_BIG_SYM): Redefine to
	bfd_elf32_sparc_sol2_vec.
	(TARGET_BIG_NAME): Redefine to elf32-sparc-sol2.
	(elf32_bed): Redefine to elf32_sparc_sol2_bed.
	(elf_backend_static_tls_alignment): Redefine to 8.
	Include elf32-target.h.
	(elf_backend_static_tls_alignment): Undef again for VxWorks.

	* elf64-sparc.c (TARGET_BIG_SYM): Redefine to
	bfd_elf64_sparc_sol2_vec.
	(TARGET_BIG_NAME): Redefine to elf64-sparc-sol2.
	(ELF_OSABI): Undef.
	(elf64_bed): Redefine to elf64_sparc_sol2_bed.
	(elf_backend_static_tls_alignment): Redefine to 16.
	Include elf64-target.h.

	* config.bfd (sparc-*-solaris2.[0-6]): Split from sparc-*-elf*.
	Set targ_defvec to bfd_elf32_sparc_sol2_vec.
	[BFD64] (sparc-*-solaris2*): Set targ_defvec to
	bfd_elf32_sparc_sol2_vec.
	Replace bfd_elf64_sparc_vec by bfd_elf64_sparc_sol2_vec in
	targ_selvecs.

	* configure.in: Handle bfd_elf32_sparc_sol2_vec,
	bfd_elf64_sparc_sol2_vec.
	* configure: Regenerate.

	* targets.c (bfd_elf32_sparc_sol2_vec): Declare.
	(bfd_elf64_sparc_sol2_vec): Declare.
	(_bfd_target_vector): Add bfd_elf32_sparc_sol2_vec,
	bfd_elf64_sparc_sol2_vec.
@
text
@d594 1
@


1.124.2.1
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d429 2
a430 3
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;
@


1.123
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d937 20
@


1.122
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d166 2
a167 2
      rel_hdr = &d->rel_hdr;
      rel_hdr2 = d->rel_hdr2;
d169 1
a169 1
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
d196 3
a198 2
  if (!elf64_sparc_slurp_one_reloc_table (abfd, asect, rel_hdr, symbols,
					  dynamic))
d329 1
a329 1
  rela_hdr = &elf_section_data (sec)->rel_hdr;
@


1.121
log
@Don't set ELFOSABI_LINUX in dynamic ifunc-using executable.

bfd/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_add_symbol_hook): Don't set
	has_ifunc_symbols if the symbol comes from a shared library.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): Likewise.

ld/testsuite/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc.exp: Expect System V OSABI in dynamic
	ifunc-using executable.
@
text
@d101 1
a101 1
      if (ELF64_R_SYM (rela.r_info) == 0)
@


1.120
log
@include/

	* elf/sparc.h (R_SPARC_JMP_IREL, R_SPARC_IRELATIVE): Define.

bfd/

	* reloc.c (BFD_RELOC_SPARC_JMP_IREL): New.
	(BFD_RELOC_SPARC_IRELATIVE): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* elfxx-sparc.h (_bfd_sparc_elf_link_hash_table): Add loc_hash_table
	and loc_hash_memory.
	(_bfd_sparc_elf_link_hash_table_free): Declare.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): New.
	(elf_backend_add_symbol_hook, elf_backend_post_process_headers,
	bfd_elf32_bfd_link_hash_table_free): Define.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Set
	has_ifunc_symbols if STT_GNU_IFUNC.
	(bfd_elf64_bfd_link_hash_table_free): Define.
	(elf_backend_post_process_headers): Define always.
	* elfxx-sparc.c (sparc_jmp_irel_howto, sparc_irelative_howto): New.
	(sparc_reloc_map): Add entries for new IFUNC relocs.
	(_bfd_sparc_elf_reloc_type_lookup): Handle new IFUNC relocs.
	(_bfd_sparc_elf_info_to_howto_ptr): Likewise.
	(elf_sparc_local_htab_hash, elf_sparc_local_htab_eq,
	elf_sparc_get_local_sym_hash): New.
	(_bfd_sparc_elf_create_dynamic_sections): Move PLT ops initialization
	from here...
	(_bfd_sparc_elf_link_hash_table_create): ... to here.  Allocate
	local hash table.
	(_bfd_sparc_elf_link_hash_table_free): New.
	(create_ifunc_sections): New.
	(_bfd_sparc_elf_check_relocs): Unconditionally assign htab->elf.dynobj
	and call create_ifunc_sections().  For local STT_GNU_IFUNC symbols
	cons up a fake local hash table entry for it.  Unconditionally add
	a PLT refcount for STT_GNU_IFUNC symbols when h->def_regular.  Count
	dyn relocs for ifunc.
	(_bfd_sparc_elf_adjust_dynamic_symbol): Handle ifunc.
	(allocate_dynrelocs):  Unconditionally emit a PLT entry when STT_GNU_IFUNC
	and h->def_regular.  Count GOT dyn relocs for ifunc.
	(allocate_local_dynrelocs): New function.
	(_bfd_sparc_elf_size_dynamic_sections): Invoke it over the local hash table.
	Emit dynamic relocs to irelplt when not shared.  Treat iplt like splt.
	(_bfd_sparc_elf_relocate_section): Handle ifunc relocations by hand.
	(_bfd_sparc_elf_finish_dynamic_symbol): Adjust for non-dynamic ifunc plt
	in iplt/irelplt.

ld/testsuite/

	* ld-ifunc/ifunc.exp: Run for sparc.
@
text
@d427 2
a428 1
  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
@


1.119
log
@update copyright dates
@
text
@d427 3
d862 2
d918 2
a929 2
#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers	_bfd_elf_set_osabi
@


1.118
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.117
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d541 5
a545 4
			      PTR finfo, bfd_boolean (*func) (PTR, const char *,
							      Elf_Internal_Sym *,
							      asection *,
							      struct elf_link_hash_entry *))
d589 4
a592 4
	if (! (*func) (finfo, app_regs [reg].name, &sym,
		       sym.st_shndx == SHN_ABS
			 ? bfd_abs_section_ptr : bfd_und_section_ptr,
		       NULL))
@


1.116
log
@	PR ld/4424
	* config.bfd (targ_selvecs): Add bfd_elf64_alpha_vec for
	alpha/FreeBSD.  Add bfd_elf64_sparc_vec for sparc64/FreeBSD.
	Add bfd_elf32_i386_vec and bfd_efi_app_ia32_vec for i386/FreeBSD.
	(targ64_selvecs): Set for i386/FreeBSD.
	* elf-bfd.h (elf_backend_data): Add relocs_compatible.
	(_bfd_elf_default_relocs_compatible): Declare.
	(_bfd_elf_relocs_compatible): Declare.
	* elfxx-target.h (elf_backend_relocs_compatible): Define.
	(elfNN_bed): Init new relocs_compatible field.
	* elflink.c (_bfd_elf_default_relocs_compatible): New function.
	(_bfd_elf_relocs_compatible): New function.
	(elf_link_add_object_symbols): Call bed->relocs_compatible.
	* elf32-i386.c (elf_backend_relocs_compatible): Define.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d444 1
a444 1
      if (info->hash->creator != abfd->xvec
d513 1
a513 1
	   && info->hash->creator == abfd->xvec)
@


1.115
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@d873 2
@


1.114
log
@Switch sources over to use the GPL version 3
@
text
@d801 1
@


1.113
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.112
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.111
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d862 2
@


1.110
log
@2006-10-18  Roy Marples  <uberlord@@gentoo.org>

	* bfd/elf64-sparc.c: Add FreeBSD support.
	(elf64_sparc_fbsd_post_process_headers): New function.
	* bfd/targets.c (_bfd_target_vector): Add bfd_elf64_sparc_freebsd_vec.
	* bfd/config.bfd (sparc64-*-freebsd*): Set targ_defvec to bfd_elf64_sparc_freebsd_vec.
	* bfd/configure.in: Add entry for bfd_elf64_sparc_freebsd_vec.
	* bfd/configure: Regenerate.
	* gas/config/tc-sparc.c (md_parse_option): Treat any target starting with elf32-sparc
	as a viable target for the -32 switch and any target starting with elf64-sparc as a
	viable target for the -64 switch.
	(sparc_target_format): For 64-bit ELF flavoured output use ELF_TARGET_FORMAT64
	while for 32-bit ELF flavoured output use ELF_TARGET_FORMAT.
	* gas/config/tc-sparc.h (ELF_TARGET_FORMAT, ELF_TARGET_FORMAT64): Define.
	* ld/emulparams/elf64_sparc_fbsd.sh (OUTPUT_FORMAT): Define as elf64-sparc-freebsd.
@
text
@d913 2
a914 16

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void
elf64_sparc_fbsd_post_process_headers (bfd *abfd,
                                       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr *i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1 */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
}
d917 1
a917 1
#define elf_backend_post_process_headers	elf64_sparc_fbsd_post_process_headers
@


1.109
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d907 30
@


1.108
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d892 2
@


1.107
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d817 1
@


1.106
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.105
log
@	* elfxx-sparc.c: New file.
	* elfxx-sparc.h: New file.
	* Makefile.in (BFD32_BACKENDS): Add elfxx-sparc.lo
	(BFD32_BACKENDS_CFILES): Add elfxx-sparc.c
	(elfxx-sparc.lo): New rule.
	(elf32-sparc.lo): Add elfxx-sparc.h dependency.
	(elf64-sparc.lo): Likewise.
	* configure.in (bfd_elf32_sparc_vec): Add elfxx-sparc.lo
	(bfd_elf64_sparc_vec): Likewise.
	* configure: Regenerate.
	* elf32-sparc.c: Remove common code now in elfxx-sparc.c
	* elf64-sparc.c: Likewise, also use elf64_sparc_*() naming
	which is more consistent with elf32-sparc.c
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.104
log
@2005-04-14  David S. Miller  <davem@@davemloft.net>

bfd/
	Add TLS support for 64-bit Sparc ELF.
	*  elf64-sparc.c (sparc64_elf_dyn_relocs,
	sparc64_elf_link_hash_entry, sparc64_elf_obj_tdata): New structs.
	(GOT_UNKNOWN, GOT_NORMAL, GOT_TLD_GD, GOT_TLD_IE,
	sparc64_elf_hash_entry, sparc64_elf_tdata,
	sparc64_elf_local_got_tls_type): New defines.
	(sparc64_elf_mkobject): New function.
	(sparc64_elf_link_hash_table): Add members for dynamic linker
	sections PLT, RELPLT, DYNBSS, and RELBSS.  Add tls_ldm_got
	uion to track TLS GOT references.  Add sym_sec to cache
	mappings from local sym to section.
	(link_hash_newfunc): New function.
	(sparc64_elf_bfd_link_hash_table_create): Rename to
	sparc64_elf_link_hash_table_create for consistency.
	Pass link_hash_newfunc to _bfd_elf_link_hash_table_init.
	(sparc64_elf_create_dynamic_sections): Initialize new section
	members of sparc64_elf_link_hash_table.  Only init srelbss
	if not-shared.
	(sparc64_elf_copy_indirect_symbol, sparc64_elf_tls_transition):
	New functions.
	(SPARC_NOP): Define.
	(sparc64_elf_build_plt, sparc64_elf_plt_entry_offset,
	sparc64_elf_plt_ptr_offset): Delete.
	(sparc64_plt_entry_build): New function to build PLT entries
	gradually instread of all at once at the end of linking.
	(sparc64_elf_check_relocs): Delete dynobj, sgot, and srelgot
	local vars.  Get them from sparc64_elf_hash_table instead.
	Check early on if r_symndx is in bounds.  Handle TLS transitions.
	Account for TLS GOT references and DF_STATIC_TLS, as needed.
	For TLS relocs, record the tls_type in either
	sparc64_elf_local_got_tls_type or sparc64_elf_hash_entry as
	appropriate.  For R_SPARC_TLS_{GD,LDM}_CALL, emit a reference
	to the __tls_get_addr symbol.  For PLT relocs, track references
	via h->plt.refcount.  When R_SPARC_{PC10,PC22,PC_HH22,PC_HM10,
	PC_LM22} and h not-NULL, set h->non_got_ref.  For global data
	symbol references, count the number of relocations needed for
	that symbol.  For default switch case, don't error, this lets
	the TLS relocs not explicitly handled by this function get
	accepted.
	(sparc64_elf_gc_mark_hook, sparc64_gc_sweep_hook): New functions.
	(sparc64_elf_adjust_dynamic_symbol): Remove dynobj local var, get
	it from sparc64_elf_hash_table.  Store the real PLT offset
	in h->plt.offset, and build PLT entries one at a time.  Also
	get .dynbss section pointer from htab.
	(allocate_dynrelocs, readonly_dynrelocs,
	sparc64_omit_section_dynsym): New functions.
	(sparc64_elf_omit_section_dynsym): Use these new functions as
	helpers.
	(dtpoff_base, tpoff): New functions.
	(sparc64_elf_relocate_section): Kill dynobj, sgot, and splt
	locals, get them from sparc64_elf_hash_table.  Handle TLS
	relocations and refcounting in main relocation loop.
	(sparc64_elf_finish_dynamic_symbol): Use
	sparc64_elf_link_hash_table.  Build PLT entries as we see
	them.  Handle TLS GOT relocations.
	(sparc64_elf_finish_dynamic_sections): Get sgot and dynobj
	from sparc64_elf_hash_table.  Initialize only PLT header
	not all entries since we not build PLT entries one by one.
	(elf_backend_copy_indirect_symbol, bfd_elf64_mkobject,
	elf_backend_gc_mark_hook, elf_backend_gc_sweep_hook,
	elf_backend_can_gc_sections, elf_backend_can_refcount): Define.
ld/testsuite/
	* ld-selective/sel-dump.exp: Do not exclude sparc64-*.
	* ld-selective/selective.exp: Likewise.
	* ld-sparc/sparc.exp: Add {32,64}-bit prefix to test
	names so we know which one is failing.  Run sparc64 TLS
	tests on multi-arch sparc platforms.
	* ld-sparc/tls64.sd, ld-sparc/tlssunbin64.dd,
	ld-sparc/tlssunbin64.rd, ld/testsuite/ld-sparc/tlssunbin64.sd,
	ld-sparc/tlssunbin64.td, ld-sparc/tlssunnopic64.dd,
	ld-sparc/tlssunnopic64.rd, ld-sparc/tlssunnopic64.sd,
	ld-sparc/tlssunpic64.dd, ld-sparc/tlssunpic64.rd,
	ld-sparc/tlssunpic64.sd, ld-sparc/tlssunpic64.td): Update now
	that sparc64 ELF does support TLS.
@
text
@a24 6

/* This is defined if one wants to build upward compatible binaries
   with the original sparc64-elf toolchain.  The support is kept in for
   now but is turned off by default.  dje 970930  */
/*#define SPARC64_OLD_RELOCS*/

d27 1
a31 317
static reloc_howto_type *sparc64_elf_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void sparc64_elf_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean sparc64_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean sparc64_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean sparc64_elf_omit_section_dynsym
  PARAMS ((bfd *, struct bfd_link_info *, asection *));
static bfd_boolean sparc64_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean sparc64_elf_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean sparc64_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static bfd_boolean sparc64_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean sparc64_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean sparc64_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean sparc64_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *sparc64_elf_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean sparc64_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void sparc64_elf_copy_indirect_symbol
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
	  struct elf_link_hash_entry *));
static int sparc64_elf_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));

static bfd_boolean sparc64_elf_mkobject
  PARAMS ((bfd *));
static bfd_boolean sparc64_elf_object_p
  PARAMS ((bfd *));
static enum elf_reloc_type_class sparc64_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static asection *sparc64_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean sparc64_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_reloc_status_type init_insn_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *,
	   bfd *, bfd_vma *, bfd_vma *));
static int sparc64_plt_entry_build
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, bfd_vma *));
static int sparc64_elf_get_symbol_type
  PARAMS (( Elf_Internal_Sym *, int));
static bfd_boolean sparc64_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static bfd_boolean sparc64_elf_output_arch_syms
  PARAMS ((bfd *, struct bfd_link_info *, PTR,
	   bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *,
			    asection *, struct elf_link_hash_entry *)));
static void sparc64_elf_symbol_processing
  PARAMS ((bfd *, asymbol *));
static bfd_boolean sparc64_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static const char *sparc64_elf_print_symbol_all
  PARAMS ((bfd *, PTR, asymbol *));
static long sparc64_elf_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));
static long sparc64_elf_get_dynamic_reloc_upper_bound
  PARAMS ((bfd *));
static bfd_boolean sparc64_elf_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, asymbol **, bfd_boolean));
static bfd_boolean sparc64_elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long sparc64_elf_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long sparc64_elf_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
static void sparc64_elf_write_relocs
  PARAMS ((bfd *, asection *, PTR));

/* The relocation "howto" table.  */

static bfd_reloc_status_type sparc_elf_notsup_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type sparc_elf_wdisp16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type sparc_elf_hix22_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type sparc_elf_lox10_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static reloc_howto_type sparc64_elf_howto_table[] =
{
  HOWTO(R_SPARC_NONE,      0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_8,         0,0, 8,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_8",       FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_32,        0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_32",      FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_DISP8,     0,0, 8,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP8",   FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_DISP16,    0,1,16,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP16",  FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_DISP32,    0,2,32,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP32",  FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_WDISP30,   2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP30", FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_WDISP22,   2,2,22,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP22", FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HI22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HI22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_22,        0,2,22,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_22",      FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_13,        0,2,13,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_13",      FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_LO10,      0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LO10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT10,     0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT10",   FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT13,     0,2,13,FALSE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_GOT13",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_GOT22,    10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT22",   FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC10,      0,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC22,     10,2,22,TRUE, 0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PC22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WPLT30,    2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WPLT30",  FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_COPY,      0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_COPY",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_GLOB_DAT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GLOB_DAT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_JMP_SLOT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_JMP_SLOT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_RELATIVE,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_RELATIVE",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_UA32,      0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA32",    FALSE,0,0xffffffff,TRUE),
#ifndef SPARC64_OLD_RELOCS
  HOWTO(R_SPARC_PLT32,     0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT32",   FALSE,0,0xffffffff,TRUE),
  /* These aren't implemented yet.  */
  HOWTO(R_SPARC_HIPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_HIPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_LOPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_LOPLT10",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT32,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT32",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT10",  FALSE,0,0x00000000,TRUE),
#endif
  HOWTO(R_SPARC_10,        0,2,10,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_10",      FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_11,        0,2,11,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_11",      FALSE,0,0x000007ff,TRUE),
  HOWTO(R_SPARC_64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_OLO10,     0,2,13,FALSE,0,complain_overflow_signed,  sparc_elf_notsup_reloc, "R_SPARC_OLO10",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_HH22,     42,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HM10,     32,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_LM22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HH22,  42,2,22,TRUE, 0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_PC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HM10,  32,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC_LM22,  10,2,22,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WDISP16,   2,2,16,TRUE, 0,complain_overflow_signed,  sparc_elf_wdisp16_reloc,"R_SPARC_WDISP16", FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_WDISP19,   2,2,19,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP19", FALSE,0,0x0007ffff,TRUE),
  HOWTO(R_SPARC_UNUSED_42, 0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_UNUSED_42",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_7,         0,2, 7,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_7",       FALSE,0,0x0000007f,TRUE),
  HOWTO(R_SPARC_5,         0,2, 5,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_5",       FALSE,0,0x0000001f,TRUE),
  HOWTO(R_SPARC_6,         0,2, 6,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_6",       FALSE,0,0x0000003f,TRUE),
  HOWTO(R_SPARC_DISP64,    0,4,64,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP64",  FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_PLT64,     0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT64",   FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_HIX22,     0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,  "R_SPARC_HIX22",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_LOX10,     0,4, 0,FALSE,0,complain_overflow_dont,    sparc_elf_lox10_reloc,  "R_SPARC_LOX10",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_H44,      22,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_H44",     FALSE,0,0x003fffff,FALSE),
  HOWTO(R_SPARC_M44,      12,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_M44",     FALSE,0,0x000003ff,FALSE),
  HOWTO(R_SPARC_L44,       0,2,13,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_L44",     FALSE,0,0x00000fff,FALSE),
  HOWTO(R_SPARC_REGISTER,  0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_notsup_reloc, "R_SPARC_REGISTER",FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_UA64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_UA16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_GD_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_GD_CALL,2,2,30,TRUE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_HI22,10,2,22,FALSE,0,complain_overflow_dont, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_LO10,0,2,10,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LDM_CALL,2,2,30,TRUE,0,complain_overflow_signed, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDO_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,"R_SPARC_TLS_LDO_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_LOX10,0,2,0,FALSE,0,complain_overflow_dont,  sparc_elf_lox10_reloc,  "R_SPARC_TLS_LDO_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDO_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LD,0,0, 0,FALSE,0,complain_overflow_dont,     bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_LDX,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LDX",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LE_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc, "R_SPARC_TLS_LE_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LE_LOX10,0,2,0,FALSE,0,complain_overflow_dont,   sparc_elf_lox10_reloc,  "R_SPARC_TLS_LE_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_DTPMOD32,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPMOD64,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD64",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF32,0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF32",FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF64,0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF64",FALSE,0,MINUS_ONE,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF32,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF64,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF64",FALSE,0,0x00000000,TRUE)
};

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct elf_reloc_map sparc_reloc_map[] =
{
  { BFD_RELOC_NONE, R_SPARC_NONE, },
  { BFD_RELOC_16, R_SPARC_16, },
  { BFD_RELOC_16_PCREL, R_SPARC_DISP16 },
  { BFD_RELOC_8, R_SPARC_8 },
  { BFD_RELOC_8_PCREL, R_SPARC_DISP8 },
  { BFD_RELOC_CTOR, R_SPARC_64 },
  { BFD_RELOC_32, R_SPARC_32 },
  { BFD_RELOC_32_PCREL, R_SPARC_DISP32 },
  { BFD_RELOC_HI22, R_SPARC_HI22 },
  { BFD_RELOC_LO10, R_SPARC_LO10, },
  { BFD_RELOC_32_PCREL_S2, R_SPARC_WDISP30 },
  { BFD_RELOC_64_PCREL, R_SPARC_DISP64 },
  { BFD_RELOC_SPARC22, R_SPARC_22 },
  { BFD_RELOC_SPARC13, R_SPARC_13 },
  { BFD_RELOC_SPARC_GOT10, R_SPARC_GOT10 },
  { BFD_RELOC_SPARC_GOT13, R_SPARC_GOT13 },
  { BFD_RELOC_SPARC_GOT22, R_SPARC_GOT22 },
  { BFD_RELOC_SPARC_PC10, R_SPARC_PC10 },
  { BFD_RELOC_SPARC_PC22, R_SPARC_PC22 },
  { BFD_RELOC_SPARC_WPLT30, R_SPARC_WPLT30 },
  { BFD_RELOC_SPARC_COPY, R_SPARC_COPY },
  { BFD_RELOC_SPARC_GLOB_DAT, R_SPARC_GLOB_DAT },
  { BFD_RELOC_SPARC_JMP_SLOT, R_SPARC_JMP_SLOT },
  { BFD_RELOC_SPARC_RELATIVE, R_SPARC_RELATIVE },
  { BFD_RELOC_SPARC_WDISP22, R_SPARC_WDISP22 },
  { BFD_RELOC_SPARC_UA16, R_SPARC_UA16 },
  { BFD_RELOC_SPARC_UA32, R_SPARC_UA32 },
  { BFD_RELOC_SPARC_UA64, R_SPARC_UA64 },
  { BFD_RELOC_SPARC_10, R_SPARC_10 },
  { BFD_RELOC_SPARC_11, R_SPARC_11 },
  { BFD_RELOC_SPARC_64, R_SPARC_64 },
  { BFD_RELOC_SPARC_OLO10, R_SPARC_OLO10 },
  { BFD_RELOC_SPARC_HH22, R_SPARC_HH22 },
  { BFD_RELOC_SPARC_HM10, R_SPARC_HM10 },
  { BFD_RELOC_SPARC_LM22, R_SPARC_LM22 },
  { BFD_RELOC_SPARC_PC_HH22, R_SPARC_PC_HH22 },
  { BFD_RELOC_SPARC_PC_HM10, R_SPARC_PC_HM10 },
  { BFD_RELOC_SPARC_PC_LM22, R_SPARC_PC_LM22 },
  { BFD_RELOC_SPARC_WDISP16, R_SPARC_WDISP16 },
  { BFD_RELOC_SPARC_WDISP19, R_SPARC_WDISP19 },
  { BFD_RELOC_SPARC_7, R_SPARC_7 },
  { BFD_RELOC_SPARC_5, R_SPARC_5 },
  { BFD_RELOC_SPARC_6, R_SPARC_6 },
  { BFD_RELOC_SPARC_DISP64, R_SPARC_DISP64 },
  { BFD_RELOC_SPARC_TLS_GD_HI22, R_SPARC_TLS_GD_HI22 },
  { BFD_RELOC_SPARC_TLS_GD_LO10, R_SPARC_TLS_GD_LO10 },
  { BFD_RELOC_SPARC_TLS_GD_ADD, R_SPARC_TLS_GD_ADD },
  { BFD_RELOC_SPARC_TLS_GD_CALL, R_SPARC_TLS_GD_CALL },
  { BFD_RELOC_SPARC_TLS_LDM_HI22, R_SPARC_TLS_LDM_HI22 },
  { BFD_RELOC_SPARC_TLS_LDM_LO10, R_SPARC_TLS_LDM_LO10 },
  { BFD_RELOC_SPARC_TLS_LDM_ADD, R_SPARC_TLS_LDM_ADD },
  { BFD_RELOC_SPARC_TLS_LDM_CALL, R_SPARC_TLS_LDM_CALL },
  { BFD_RELOC_SPARC_TLS_LDO_HIX22, R_SPARC_TLS_LDO_HIX22 },
  { BFD_RELOC_SPARC_TLS_LDO_LOX10, R_SPARC_TLS_LDO_LOX10 },
  { BFD_RELOC_SPARC_TLS_LDO_ADD, R_SPARC_TLS_LDO_ADD },
  { BFD_RELOC_SPARC_TLS_IE_HI22, R_SPARC_TLS_IE_HI22 },
  { BFD_RELOC_SPARC_TLS_IE_LO10, R_SPARC_TLS_IE_LO10 },
  { BFD_RELOC_SPARC_TLS_IE_LD, R_SPARC_TLS_IE_LD },
  { BFD_RELOC_SPARC_TLS_IE_LDX, R_SPARC_TLS_IE_LDX },
  { BFD_RELOC_SPARC_TLS_IE_ADD, R_SPARC_TLS_IE_ADD },
  { BFD_RELOC_SPARC_TLS_LE_HIX22, R_SPARC_TLS_LE_HIX22 },
  { BFD_RELOC_SPARC_TLS_LE_LOX10, R_SPARC_TLS_LE_LOX10 },
  { BFD_RELOC_SPARC_TLS_DTPMOD32, R_SPARC_TLS_DTPMOD32 },
  { BFD_RELOC_SPARC_TLS_DTPMOD64, R_SPARC_TLS_DTPMOD64 },
  { BFD_RELOC_SPARC_TLS_DTPOFF32, R_SPARC_TLS_DTPOFF32 },
  { BFD_RELOC_SPARC_TLS_DTPOFF64, R_SPARC_TLS_DTPOFF64 },
  { BFD_RELOC_SPARC_TLS_TPOFF32, R_SPARC_TLS_TPOFF32 },
  { BFD_RELOC_SPARC_TLS_TPOFF64, R_SPARC_TLS_TPOFF64 },
#ifndef SPARC64_OLD_RELOCS
  { BFD_RELOC_SPARC_PLT32, R_SPARC_PLT32 },
#endif
  { BFD_RELOC_SPARC_PLT64, R_SPARC_PLT64 },
  { BFD_RELOC_SPARC_HIX22, R_SPARC_HIX22 },
  { BFD_RELOC_SPARC_LOX10, R_SPARC_LOX10 },
  { BFD_RELOC_SPARC_H44, R_SPARC_H44 },
  { BFD_RELOC_SPARC_M44, R_SPARC_M44 },
  { BFD_RELOC_SPARC_L44, R_SPARC_L44 },
  { BFD_RELOC_SPARC_REGISTER, R_SPARC_REGISTER }
};

static reloc_howto_type *
sparc64_elf_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;
  for (i = 0; i < sizeof (sparc_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (sparc_reloc_map[i].bfd_reloc_val == code)
	return &sparc64_elf_howto_table[(int) sparc_reloc_map[i].elf_reloc_val];
    }
  return 0;
}

static void
sparc64_elf_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  BFD_ASSERT (ELF64_R_TYPE_ID (dst->r_info) < (unsigned int) R_SPARC_max_std);
  cache_ptr->howto = &sparc64_elf_howto_table[ELF64_R_TYPE_ID (dst->r_info)];
}

struct sparc64_elf_section_data
{
  struct bfd_elf_section_data elf;
  unsigned int do_relax, reloc_count;
};

#define sec_do_relax(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->do_relax
#define canon_reloc_count(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->reloc_count

d37 1
a37 3
sparc64_elf_get_reloc_upper_bound (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d43 1
a43 2
sparc64_elf_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d54 3
a56 6
sparc64_elf_slurp_one_reloc_table (abfd, asect, rel_hdr, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     Elf_Internal_Shdr *rel_hdr;
     asymbol **symbols;
     bfd_boolean dynamic;
d87 1
d118 2
a119 2
      BFD_ASSERT (ELF64_R_TYPE_ID (rela.r_info) < (unsigned int) R_SPARC_max_std);
      if (ELF64_R_TYPE_ID (rela.r_info) == R_SPARC_OLO10)
d121 1
a121 1
	  relent->howto = &sparc64_elf_howto_table[R_SPARC_LO10];
d126 1
a126 1
	  relent->howto = &sparc64_elf_howto_table[R_SPARC_13];
d129 1
a129 1
	relent->howto = &sparc64_elf_howto_table[ELF64_R_TYPE_ID (rela.r_info)];
d148 2
a149 5
sparc64_elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     bfd_boolean dynamic;
d191 1
a191 1
  /* The sparc64_elf_slurp_one_reloc_table routine increments
d195 1
a195 1
  if (!sparc64_elf_slurp_one_reloc_table (abfd, asect, rel_hdr, symbols,
d200 1
a200 1
      && !sparc64_elf_slurp_one_reloc_table (abfd, asect, rel_hdr2, symbols,
d210 2
a211 5
sparc64_elf_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d240 2
a241 4
sparc64_elf_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d261 1
a261 1
	  if (! sparc64_elf_slurp_reloc_table (abfd, s, syms, TRUE))
d279 1
a279 4
sparc64_elf_write_relocs (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d283 1
d341 7
a359 9

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	dst_rela.r_offset = ptr->address;
      else
	dst_rela.r_offset = ptr->address + sec->vma;

d406 1
d408 1
d414 2
a415 5
/* The SPARC linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */
d417 6
a422 1
struct sparc64_elf_dyn_relocs
d424 1
a424 1
  struct sparc64_elf_dyn_relocs *next;
d426 4
a429 2
  /* The input section of the reloc.  */
  asection *sec;
d431 11
a441 2
  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;
d443 9
a451 3
  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};
d453 1
a453 1
/* SPARC ELF linker hash entry.  */
d455 9
a463 3
struct sparc64_elf_link_hash_entry
{
  struct elf_link_hash_entry elf;
d465 5
a469 2
  /* Track dynamic relocs copied for this symbol.  */
  struct sparc64_elf_dyn_relocs *dyn_relocs;
d471 2
a472 6
#define GOT_UNKNOWN     0
#define GOT_NORMAL      1
#define GOT_TLS_GD      2
#define GOT_TLS_IE      3
  unsigned char tls_type;
};
d474 3
a476 1
#define sparc64_elf_hash_entry(ent) ((struct sparc64_elf_link_hash_entry *)(ent))
d478 7
a484 3
struct sparc64_elf_obj_tdata
{
  struct elf_obj_tdata root;
d486 4
a489 2
  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
d491 25
a515 3
  /* TRUE if TLS GD relocs has been seen for this object.  */
  bfd_boolean has_tlsgd;
};
d517 5
a521 2
#define sparc64_elf_tdata(abfd) \
  ((struct sparc64_elf_obj_tdata *) (abfd)->tdata.any)
d523 8
a530 11
#define sparc64_elf_local_got_tls_type(abfd) \
  (sparc64_elf_tdata (abfd)->local_got_tls_type)

static bfd_boolean
sparc64_elf_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct sparc64_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
d534 2
a535 1
/* Sparc64 ELF linker hash table.  */
d537 7
a543 1
struct sparc64_elf_app_reg
d545 4
a548 5
  unsigned char bind;
  unsigned short shndx;
  bfd *abfd;
  char *name;
};
d550 9
a558 3
struct sparc64_elf_link_hash_table
{
  struct elf_link_hash_table elf;
d560 9
a568 12
  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;
d570 2
a571 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d573 8
a580 2
  struct sparc64_elf_app_reg app_regs [4];
};
d582 11
a592 1
/* Get the Sparc64 ELF linker hash table from a link_info structure.  */
d594 2
a595 2
#define sparc64_elf_hash_table(p) \
  ((struct sparc64_elf_link_hash_table *) ((p)->hash))
d597 2
a598 7
/* Create an entry in an SPARC ELF linker hash table.  */

static struct bfd_hash_entry *
link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d600 4
a603 22
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct sparc64_elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct sparc64_elf_link_hash_entry *eh;

      eh = (struct sparc64_elf_link_hash_entry *) entry;
      eh->dyn_relocs = NULL;
      eh->tls_type = GOT_UNKNOWN;
    }

  return entry;
d606 2
a607 1
/* Create a SPARC64 ELF linker hash table.  */
d609 2
a610 3
static struct bfd_link_hash_table *
sparc64_elf_link_hash_table_create (abfd)
     bfd *abfd;
d612 1
a612 2
  struct sparc64_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct sparc64_elf_link_hash_table);
d614 3
a616 5
  ret = (struct sparc64_elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc))
d618 1
a618 2
      free (ret);
      return NULL;
a619 2

  return &ret->elf.root;
d622 2
a623 2
/* Create .got and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */
d625 2
a626 30
static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct sparc64_elf_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = sparc64_elf_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (htab->sgot != NULL);

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot, SEC_ALLOC
							 | SEC_LOAD
							 | SEC_HAS_CONTENTS
							 | SEC_IN_MEMORY
							 | SEC_LINKER_CREATED
							 | SEC_READONLY)
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rela.plt, .got, .rela.got, .dynbss, and
   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */
d629 1
a629 3
sparc64_elf_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d631 3
a633 1
  struct sparc64_elf_link_hash_table *htab;
d635 3
a637 3
  htab = sparc64_elf_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;
d639 2
a640 2
  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;
d642 5
a646 5
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d648 2
a649 3
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();
d651 3
a653 2
  return TRUE;
}
d655 2
a656 1
/* Copy the extra info we tack onto an elf_link_hash_entry.  */
d658 1
a658 3208
static void
sparc64_elf_copy_indirect_symbol (bed, dir, ind)
     const struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  struct sparc64_elf_link_hash_entry *edir, *eind;

  edir = (struct sparc64_elf_link_hash_entry *) dir;
  eind = (struct sparc64_elf_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct sparc64_elf_dyn_relocs **pp;
	  struct sparc64_elf_dyn_relocs *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct sparc64_elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

static int
sparc64_elf_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_SPARC_TLS_GD_HI22:
      if (is_local)
	return R_SPARC_TLS_LE_HIX22;
      return R_SPARC_TLS_IE_HI22;
    case R_SPARC_TLS_GD_LO10:
      if (is_local)
	return R_SPARC_TLS_LE_LOX10;
      return R_SPARC_TLS_IE_LO10;
    case R_SPARC_TLS_IE_HI22:
      if (is_local)
	return R_SPARC_TLS_LE_HIX22;
      return r_type;
    case R_SPARC_TLS_IE_LO10:
      if (is_local)
	return R_SPARC_TLS_LE_LOX10;
      return r_type;
    case R_SPARC_TLS_LDM_HI22:
      return R_SPARC_TLS_LE_HIX22;
    case R_SPARC_TLS_LDM_LO10:
      return R_SPARC_TLS_LE_LOX10;
    }

  return r_type;
}


/* Utility for performing the standard initial work of an instruction
   relocation.
   *PRELOCATION will contain the relocated item.
   *PINSN will contain the instruction from the input stream.
   If the result is `bfd_reloc_other' the caller can continue with
   performing the relocation.  Otherwise it must stop and return the
   value to its caller.  */

static bfd_reloc_status_type
init_insn_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 prelocation,
		 pinsn)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     bfd_vma *prelocation;
     bfd_vma *pinsn;
{
  bfd_vma relocation;
  reloc_howto_type *howto = reloc_entry->howto;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* This works because partial_inplace is FALSE.  */
  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }

  *prelocation = relocation;
  *pinsn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  return bfd_reloc_other;
}

/* For unsupported relocs.  */

static bfd_reloc_status_type
sparc_elf_notsup_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
{
  return bfd_reloc_notsupported;
}

/* Handle the WDISP16 reloc.  */

static bfd_reloc_status_type
sparc_elf_wdisp16_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_vma insn;
  bfd_reloc_status_type status;

  status = init_insn_reloc (abfd, reloc_entry, symbol, data,
			    input_section, output_bfd, &relocation, &insn);
  if (status != bfd_reloc_other)
    return status;

  insn &= ~ (bfd_vma) 0x303fff;
  insn |= (((relocation >> 2) & 0xc000) << 6) | ((relocation >> 2) & 0x3fff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((bfd_signed_vma) relocation < - 0x40000
      || (bfd_signed_vma) relocation > 0x3ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

/* Handle the HIX22 reloc.  */

static bfd_reloc_status_type
sparc_elf_hix22_reloc (abfd,
		       reloc_entry,
		       symbol,
		       data,
		       input_section,
		       output_bfd,
		       error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_vma insn;
  bfd_reloc_status_type status;

  status = init_insn_reloc (abfd, reloc_entry, symbol, data,
			    input_section, output_bfd, &relocation, &insn);
  if (status != bfd_reloc_other)
    return status;

  relocation ^= MINUS_ONE;
  insn = (insn &~ (bfd_vma) 0x3fffff) | ((relocation >> 10) & 0x3fffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((relocation & ~ (bfd_vma) 0xffffffff) != 0)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

/* Handle the LOX10 reloc.  */

static bfd_reloc_status_type
sparc_elf_lox10_reloc (abfd,
		       reloc_entry,
		       symbol,
		       data,
		       input_section,
		       output_bfd,
		       error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_vma insn;
  bfd_reloc_status_type status;

  status = init_insn_reloc (abfd, reloc_entry, symbol, data,
			    input_section, output_bfd, &relocation, &insn);
  if (status != bfd_reloc_other)
    return status;

  insn = (insn &~ (bfd_vma) 0x1fff) | 0x1c00 | (relocation & 0x3ff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  return bfd_reloc_ok;
}

/* PLT/GOT stuff */

/* Both the headers and the entries are icache aligned.  */
#define PLT_ENTRY_SIZE		32
#define PLT_HEADER_SIZE		(4 * PLT_ENTRY_SIZE)
#define LARGE_PLT_THRESHOLD	32768
#define GOT_RESERVED_ENTRIES	1

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/sparcv9/ld.so.1"

#define SPARC_NOP 0x01000000

static int
sparc64_plt_entry_build (output_bfd, splt, offset, max, r_offset)
     bfd *output_bfd;
     asection *splt;
     bfd_vma offset;
     bfd_vma max;
     bfd_vma *r_offset;
{
  unsigned char *entry = splt->contents + offset;
  const unsigned int nop = SPARC_NOP;
  int index;

  if (offset < (LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE))
    {
      unsigned int sethi, ba;

      *r_offset = offset;

      index = (offset / PLT_ENTRY_SIZE);

      sethi = 0x03000000 | (index * PLT_ENTRY_SIZE);
      ba = 0x30680000
	| (((splt->contents + PLT_ENTRY_SIZE) - (entry + 4)) / 4 & 0x7ffff);

      bfd_put_32 (output_bfd, (bfd_vma) sethi, entry);
      bfd_put_32 (output_bfd, (bfd_vma) ba,    entry + 4);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 8);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 12);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 16);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 20);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 24);
      bfd_put_32 (output_bfd, (bfd_vma) nop,   entry + 28);
    }
  else
    {
      unsigned char *ptr;
      unsigned int ldx;
      int block, last_block, ofs, last_ofs, chunks_this_block;
      const int insn_chunk_size = (6 * 4);
      const int ptr_chunk_size = (1 * 8);
      const int entries_per_block = 160;
      const int block_size = entries_per_block * (insn_chunk_size
						  + ptr_chunk_size);

      /* Entries 32768 and higher are grouped into blocks of 160.
	 The blocks are further subdivided into 160 sequences of
	 6 instructions and 160 pointers.  If a block does not require
	 the full 160 entries, let's say it requires N, then there
	 will be N sequences of 6 instructions and N pointers.  */

      offset -= (LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE);
      max -= (LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE);

      block = offset / block_size;
      last_block = max / block_size;
      if (block != last_block)
	{
	  chunks_this_block = 160;
	}
      else
	{
	  last_ofs = max % block_size;
	  chunks_this_block = last_ofs / (insn_chunk_size + ptr_chunk_size);
	}

      ofs = offset % block_size;

      index = (LARGE_PLT_THRESHOLD +
	       (block * 160) +
	       (ofs / insn_chunk_size));

      ptr = splt->contents
	+ (LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE)
	+ (block * block_size)
	+ (chunks_this_block * insn_chunk_size)
	+ (ofs / insn_chunk_size) * ptr_chunk_size;

      *r_offset = (bfd_vma) (ptr - splt->contents);

      ldx = 0xc25be000 | ((ptr - (entry+4)) & 0x1fff);

      /* mov %o7,%g5
	 call .+8
	 nop
	 ldx [%o7+P],%g1
	 jmpl %o7+%g1,%g1
	 mov %g5,%o7  */
      bfd_put_32 (output_bfd, (bfd_vma) 0x8a10000f, entry);
      bfd_put_32 (output_bfd, (bfd_vma) 0x40000002, entry + 4);
      bfd_put_32 (output_bfd, (bfd_vma) SPARC_NOP,  entry + 8);
      bfd_put_32 (output_bfd, (bfd_vma) ldx,        entry + 12);
      bfd_put_32 (output_bfd, (bfd_vma) 0x83c3c001, entry + 16);
      bfd_put_32 (output_bfd, (bfd_vma) 0x9e100005, entry + 20);

      bfd_put_64 (output_bfd, (bfd_vma) (splt->contents - (entry + 4)), ptr);
    }

  return index - 4;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
sparc64_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  struct sparc64_elf_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;

  if (info->relocatable || !(sec->flags & SEC_ALLOC))
    return TRUE;

  htab = sparc64_elf_hash_table (info);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_offsets = elf_local_got_offsets (abfd);

  sreloc = NULL;

  rel_end = relocs + NUM_SHDR_ENTRIES (& elf_section_data (sec)->rel_hdr);
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF64_R_SYM (rel->r_info);
      r_type = ELF64_R_TYPE_ID (rel->r_info);

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
	  return FALSE;
	}

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      r_type = sparc64_elf_tls_transition (info, r_type, h == NULL);
      switch (r_type)
	{
	case R_SPARC_TLS_LDM_HI22:
	case R_SPARC_TLS_LDM_LO10:
	  htab->tls_ldm_got.refcount += 1;
	  break;

	case R_SPARC_TLS_LE_HIX22:
	case R_SPARC_TLS_LE_LOX10:
	  if (info->shared)
	    goto r_sparc_plt32;
	  break;

	case R_SPARC_TLS_IE_HI22:
	case R_SPARC_TLS_IE_LO10:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_SPARC_GOT10:
	case R_SPARC_GOT13:
	case R_SPARC_GOT22:
	case R_SPARC_TLS_GD_HI22:
	case R_SPARC_TLS_GD_LO10:
	  /* This symbol requires a global offset table entry.  */
	  {
	    int tls_type, old_tls_type;

	    switch (r_type)
	      {
	      default:
	      case R_SPARC_GOT10:
	      case R_SPARC_GOT13:
	      case R_SPARC_GOT22:
		tls_type = GOT_NORMAL;
		break;
	      case R_SPARC_TLS_GD_HI22:
	      case R_SPARC_TLS_GD_LO10:
		tls_type = GOT_TLS_GD;
		break;
	      case R_SPARC_TLS_IE_HI22:
	      case R_SPARC_TLS_IE_LO10:
		tls_type = GOT_TLS_IE;
		break;
	      }

	    if (h != NULL)
	      {
		h->got.refcount += 1;
		old_tls_type = sparc64_elf_hash_entry(h)->tls_type;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;

		    size = symtab_hdr->sh_info;
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		    sparc64_elf_local_got_tls_type (abfd)
		      = (char *) (local_got_refcounts + symtab_hdr->sh_info);
		  }
		local_got_refcounts[r_symndx] += 1;
		old_tls_type = sparc64_elf_local_got_tls_type (abfd) [r_symndx];
	      }

	    /* If a TLS symbol is accessed using IE at least once,
	       there is no point to use dynamic model for it.  */
	    if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
		&& (old_tls_type != GOT_TLS_GD
		    || tls_type != GOT_TLS_IE))
	      {
		if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		  tls_type = old_tls_type;
		else
		  {
		    (*_bfd_error_handler)
		      (_("%B: `%s' accessed both as normal and thread local symbol"),
		       abfd, h ? h->root.root.string : "<local>");
		    return FALSE;
		  }
	      }

	    if (old_tls_type != tls_type)
	      {
		if (h != NULL)
		  sparc64_elf_hash_entry (h)->tls_type = tls_type;
		else
		  sparc64_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
	      }
	  }

	  if (htab->sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return FALSE;
	    }
	  break;

	case R_SPARC_TLS_GD_CALL:
	case R_SPARC_TLS_LDM_CALL:
	  if (info->shared)
	    {
	      /* These are basically R_SPARC_TLS_WPLT30 relocs against
		 __tls_get_addr.  */
	      struct bfd_link_hash_entry *bh = NULL;
	      if (! _bfd_generic_link_add_one_symbol (info, abfd,
						      "__tls_get_addr", 0,
						      bfd_und_section_ptr, 0,
						      NULL, FALSE, FALSE,
						      &bh))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	    }
	  else
	    break;
	  /* Fall through */

	case R_SPARC_PLT32:
	case R_SPARC_WPLT30:
	case R_SPARC_HIPLT22:
	case R_SPARC_LOPLT10:
	case R_SPARC_PCPLT32:
	case R_SPARC_PCPLT22:
	case R_SPARC_PCPLT10:
	case R_SPARC_PLT64:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */

	  if (h == NULL)
	    {
	      /* It does not make sense to have a procedure linkage
                 table entry for a local symbol.  */
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	  h->needs_plt = 1;

	  if (ELF64_R_TYPE_ID (rel->r_info) == R_SPARC_PLT32
	      || ELF64_R_TYPE_ID (rel->r_info) == R_SPARC_PLT64)
	    goto r_sparc_plt32;
	  h->plt.refcount += 1;
	  break;

	case R_SPARC_PC10:
	case R_SPARC_PC22:
	case R_SPARC_PC_HH22:
	case R_SPARC_PC_HM10:
	case R_SPARC_PC_LM22:
	  if (h != NULL)
	    h->non_got_ref = 1;

	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */

	case R_SPARC_DISP8:
	case R_SPARC_DISP16:
	case R_SPARC_DISP32:
	case R_SPARC_DISP64:
	case R_SPARC_WDISP30:
	case R_SPARC_WDISP22:
	case R_SPARC_WDISP19:
	case R_SPARC_WDISP16:
	case R_SPARC_8:
	case R_SPARC_16:
	case R_SPARC_32:
	case R_SPARC_HI22:
	case R_SPARC_22:
	case R_SPARC_13:
	case R_SPARC_LO10:
	case R_SPARC_UA16:
	case R_SPARC_UA32:
	case R_SPARC_10:
	case R_SPARC_11:
	case R_SPARC_64:
	case R_SPARC_OLO10:
	case R_SPARC_HH22:
	case R_SPARC_HM10:
	case R_SPARC_LM22:
	case R_SPARC_7:
	case R_SPARC_5:
	case R_SPARC_6:
	case R_SPARC_HIX22:
	case R_SPARC_LOX10:
	case R_SPARC_H44:
	case R_SPARC_M44:
	case R_SPARC_L44:
	case R_SPARC_UA64:
	  if (h != NULL)
	    h->non_got_ref = 1;

	r_sparc_plt32:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      h->plt.refcount += 1;
	    }

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the relocs_copied field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (! sparc64_elf_howto_table[r_type].pc_relative
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (!info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct sparc64_elf_dyn_relocs *p;
	      struct sparc64_elf_dyn_relocs **head;

	      /* When creating a shared object, we must copy these
		 relocs into the output file.  We create a reloc
		 section in dynobj and make room for the reloc.  */
	      if (sreloc == NULL)
		{
		  const char *name;
		  bfd *dynobj;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;
		  dynobj = htab->elf.dynobj;

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct sparc64_elf_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;

		  head = ((struct sparc64_elf_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof *p;
		  p = ((struct sparc64_elf_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, amt));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (sparc64_elf_howto_table[r_type].pc_relative)
		p->pc_count += 1;
	    }

	  break;

	case R_SPARC_REGISTER:
	  /* Nothing to do.  */
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it for STT_REGISTER symbols.  */

static bfd_boolean
sparc64_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp ATTRIBUTE_UNUSED;
     bfd_vma *valp ATTRIBUTE_UNUSED;
{
  static const char *const stt_types[] = { "NOTYPE", "OBJECT", "FUNCTION" };

  if (ELF_ST_TYPE (sym->st_info) == STT_REGISTER)
    {
      int reg;
      struct sparc64_elf_app_reg *p;

      reg = (int)sym->st_value;
      switch (reg & ~1)
	{
	case 2: reg -= 2; break;
	case 6: reg -= 4; break;
	default:
          (*_bfd_error_handler)
            (_("%B: Only registers %%g[2367] can be declared using STT_REGISTER"),
             abfd);
	  return FALSE;
	}

      if (info->hash->creator != abfd->xvec
	  || (abfd->flags & DYNAMIC) != 0)
        {
	  /* STT_REGISTER only works when linking an elf64_sparc object.
	     If STT_REGISTER comes from a dynamic object, don't put it into
	     the output bfd.  The dynamic linker will recheck it.  */
	  *namep = NULL;
	  return TRUE;
        }

      p = sparc64_elf_hash_table(info)->app_regs + reg;

      if (p->name != NULL && strcmp (p->name, *namep))
	{
          (*_bfd_error_handler)
            (_("Register %%g%d used incompatibly: %s in %B, previously %s in %B"),
             abfd, p->abfd, (int) sym->st_value,
             **namep ? *namep : "#scratch",
             *p->name ? p->name : "#scratch");
	  return FALSE;
	}

      if (p->name == NULL)
	{
	  if (**namep)
	    {
	      struct elf_link_hash_entry *h;

	      h = (struct elf_link_hash_entry *)
		bfd_link_hash_lookup (info->hash, *namep, FALSE, FALSE, FALSE);

	      if (h != NULL)
		{
		  unsigned char type = h->type;

		  if (type > STT_FUNC)
		    type = 0;
		  (*_bfd_error_handler)
		    (_("Symbol `%s' has differing types: REGISTER in %B, previously %s in %B"),
		     abfd, p->abfd, *namep, stt_types[type]);
		  return FALSE;
		}

	      p->name = bfd_hash_allocate (&info->hash->table,
					   strlen (*namep) + 1);
	      if (!p->name)
		return FALSE;

	      strcpy (p->name, *namep);
	    }
	  else
	    p->name = "";
	  p->bind = ELF_ST_BIND (sym->st_info);
	  p->abfd = abfd;
	  p->shndx = sym->st_shndx;
	}
      else
	{
	  if (p->bind == STB_WEAK
	      && ELF_ST_BIND (sym->st_info) == STB_GLOBAL)
	    {
	      p->bind = STB_GLOBAL;
	      p->abfd = abfd;
	    }
	}
      *namep = NULL;
      return TRUE;
    }
  else if (*namep && **namep
	   && info->hash->creator == abfd->xvec)
    {
      int i;
      struct sparc64_elf_app_reg *p;

      p = sparc64_elf_hash_table(info)->app_regs;
      for (i = 0; i < 4; i++, p++)
	if (p->name != NULL && ! strcmp (p->name, *namep))
	  {
	    unsigned char type = ELF_ST_TYPE (sym->st_info);

	    if (type > STT_FUNC)
	      type = 0;
	    (*_bfd_error_handler)
	      (_("Symbol `%s' has differing types: %s in %B, previously REGISTER in %B"),
	       abfd, p->abfd, *namep, stt_types[type]);
	    return FALSE;
	  }
    }
  return TRUE;
}

/* This function takes care of emitting STT_REGISTER symbols
   which we cannot easily keep in the symbol hash table.  */

static bfd_boolean
sparc64_elf_output_arch_syms (output_bfd, info, finfo, func)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     PTR finfo;
     bfd_boolean (*func)
       PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *,
		struct elf_link_hash_entry *));
{
  int reg;
  struct sparc64_elf_app_reg *app_regs =
    sparc64_elf_hash_table(info)->app_regs;
  Elf_Internal_Sym sym;

  /* We arranged in size_dynamic_sections to put the STT_REGISTER entries
     at the end of the dynlocal list, so they came at the end of the local
     symbols in the symtab.  Except that they aren't STB_LOCAL, so we need
     to back up symtab->sh_info.  */
  if (elf_hash_table (info)->dynlocal)
    {
      bfd * dynobj = elf_hash_table (info)->dynobj;
      asection *dynsymsec = bfd_get_section_by_name (dynobj, ".dynsym");
      struct elf_link_local_dynamic_entry *e;

      for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	if (e->input_indx == -1)
	  break;
      if (e)
	{
	  elf_section_data (dynsymsec->output_section)->this_hdr.sh_info
	    = e->dynindx;
	}
    }

  if (info->strip == strip_all)
    return TRUE;

  for (reg = 0; reg < 4; reg++)
    if (app_regs [reg].name != NULL)
      {
	if (info->strip == strip_some
	    && bfd_hash_lookup (info->keep_hash,
				app_regs [reg].name,
				FALSE, FALSE) == NULL)
	  continue;

	sym.st_value = reg < 2 ? reg + 2 : reg + 4;
	sym.st_size = 0;
	sym.st_other = 0;
	sym.st_info = ELF_ST_INFO (app_regs [reg].bind, STT_REGISTER);
	sym.st_shndx = app_regs [reg].shndx;
	if (! (*func) (finfo, app_regs [reg].name, &sym,
		       sym.st_shndx == SHN_ABS
			 ? bfd_abs_section_ptr : bfd_und_section_ptr,
		       NULL))
	  return FALSE;
      }

  return TRUE;
}

static int
sparc64_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym * elf_sym;
     int type;
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_REGISTER)
    return STT_REGISTER;
  else
    return type;
}

/* A STB_GLOBAL,STT_REGISTER symbol should be BSF_GLOBAL
   even in SHN_UNDEF section.  */

static void
sparc64_elf_symbol_processing (abfd, asym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *asym;
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  if (elfsym->internal_elf_sym.st_info
      == ELF_ST_INFO (STB_GLOBAL, STT_REGISTER))
    {
      asym->flags |= BSF_GLOBAL;
    }
}

static asection *
sparc64_elf_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel ATTRIBUTE_UNUSED;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (h->root.type)
	{
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  return h->root.u.def.section;

	case bfd_link_hash_common:
	  return h->root.u.c.p->section;

	default:
	  break;
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */
static bfd_boolean
sparc64_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct sparc64_elf_link_hash_entry *eh;
	  struct sparc64_elf_dyn_relocs **pp;
	  struct sparc64_elf_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct sparc64_elf_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF64_R_TYPE_ID (rel->r_info);
      r_type = sparc64_elf_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_SPARC_TLS_LDM_HI22:
	case R_SPARC_TLS_LDM_LO10:
	  if (sparc64_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	    sparc64_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_SPARC_TLS_GD_HI22:
	case R_SPARC_TLS_GD_LO10:
	case R_SPARC_TLS_IE_HI22:
	case R_SPARC_TLS_IE_LO10:
	case R_SPARC_GOT10:
	case R_SPARC_GOT13:
	case R_SPARC_GOT22:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
	  break;

	case R_SPARC_PC10:
	case R_SPARC_PC22:
	case R_SPARC_PC_HH22:
	case R_SPARC_PC_HM10:
	case R_SPARC_PC_LM22:
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */

	case R_SPARC_DISP8:
	case R_SPARC_DISP16:
	case R_SPARC_DISP32:
	case R_SPARC_DISP64:
	case R_SPARC_WDISP30:
	case R_SPARC_WDISP22:
	case R_SPARC_WDISP19:
	case R_SPARC_WDISP16:
	case R_SPARC_8:
	case R_SPARC_16:
	case R_SPARC_32:
	case R_SPARC_HI22:
	case R_SPARC_22:
	case R_SPARC_13:
	case R_SPARC_LO10:
	case R_SPARC_UA16:
	case R_SPARC_UA32:
	case R_SPARC_PLT32:
	case R_SPARC_10:
	case R_SPARC_11:
	case R_SPARC_64:
	case R_SPARC_OLO10:
	case R_SPARC_HH22:
	case R_SPARC_HM10:
	case R_SPARC_LM22:
	case R_SPARC_7:
	case R_SPARC_5:
	case R_SPARC_6:
	case R_SPARC_HIX22:
	case R_SPARC_LOX10:
	case R_SPARC_H44:
	case R_SPARC_M44:
	case R_SPARC_L44:
	case R_SPARC_UA64:
	  if (info->shared)
	    break;
	  /* Fall through.  */

	case R_SPARC_WPLT30:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
sparc64_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  struct sparc64_elf_link_hash_table *htab;
  struct sparc64_elf_link_hash_entry * eh;
  struct sparc64_elf_dyn_relocs *p;
  asection *s;
  unsigned int power_of_two;

  htab = sparc64_elf_hash_table (info);

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (htab->elf.dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later
     (although we could actually do it here).  The STT_NOTYPE
     condition is a hack specifically for the Oracle libraries
     delivered for Solaris; for some inexplicable reason, they define
     some of their functions as STT_NOTYPE when they really should be
     STT_FUNC.  */
  if (h->type == STT_FUNC
      || h->needs_plt
      || (h->type == STT_NOTYPE
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && (h->root.u.def.section->flags & SEC_CODE) != 0))
    {
      if (h->plt.refcount <= 0
	  || (! info->shared
	      && !h->def_dynamic
	      && !h->ref_dynamic
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
	{
	  /* This case can occur if we saw a WPLT30 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a WDISP30 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  eh = (struct sparc64_elf_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  /* We must generate a R_SPARC_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      htab->srelbss->size += sizeof (Elf64_External_Rela);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  16-bytes is the size
     of the largest type that requires hard alignment -- long double.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
  s = htab->sdynbss;
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct sparc64_elf_link_hash_table *htab;
  struct sparc64_elf_link_hash_entry *eh;
  struct sparc64_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = sparc64_elf_hash_table (info);

  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
	{
	  asection *s = htab->splt;

	  /* The first four bit in .plt is reserved.  */
	  if (s->size == 0)
	    s->size = PLT_HEADER_SIZE;

	  /* The procedure linkage table size is bounded by the magnitude
	     of the offset we can describe in the entry.  */
	  if (s->size >= (bfd_vma)1 << 32)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	  if (s->size >= LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE)
	    {
	      bfd_vma off = s->size - LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE;


	      off = (off % (160 * PLT_ENTRY_SIZE)) / PLT_ENTRY_SIZE;

	      h->plt.offset = (s->size - (off * 8));
	    }
	  else
	    h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  /* If R_SPARC_TLS_IE_{HI22,LO10} symbol is now local to the binary,
     make it a R_SPARC_TLS_LE_{HI22,LO10} requiring no TLS entry.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && sparc64_elf_hash_entry(h)->tls_type == GOT_TLS_IE)
    h->got.offset = (bfd_vma) -1;
  else if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
      int tls_type = sparc64_elf_hash_entry(h)->tls_type;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->size;
      s->size += 8;
      /* R_SPARC_TLS_GD_HI{22,LO10} needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->size += 8;
      dyn = htab->elf.dynamic_sections_created;
      /* R_SPARC_TLS_IE_{HI22,LO10} needs one dynamic relocation,
	 R_SPARC_TLS_GD_{HI22,LO10} needs one if local symbol and two if
	 global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->size += 2 * sizeof (Elf64_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
	htab->srelgot->size += sizeof (Elf64_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct sparc64_elf_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if (h->def_regular
	  && (h->forced_local
	      || info->symbolic))
	{
	  struct sparc64_elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct sparc64_elf_link_hash_entry *eh;
  struct sparc64_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct sparc64_elf_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Return true if the dynamic symbol for a given section should be
   omitted when creating a shared library.  */

static bfd_boolean
sparc64_elf_omit_section_dynsym (bfd *output_bfd,
				 struct bfd_link_info *info,
				 asection *p)
{
  /* We keep the .got section symbol so that explicit relocations
     against the _GLOBAL_OFFSET_TABLE_ symbol emitted in PIC mode
     can be turned into relocations against the .got symbol.  */
  if (strcmp (p->name, ".got") == 0)
    return FALSE;

  return _bfd_elf_link_omit_section_dynsym (output_bfd, info, p);
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
sparc64_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct sparc64_elf_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd *ibfd;

  htab = sparc64_elf_hash_table (info);
  dynobj = htab->elf.dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct sparc64_elf_dyn_relocs *p;

	  for (p = *((struct sparc64_elf_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->size += p->count * sizeof (Elf64_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_tls_type = sparc64_elf_local_got_tls_type (ibfd);
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->size;
	      s->size += 8;
	      if (*local_tls_type == GOT_TLS_GD)
		s->size += 8;
	      if (info->shared
		  || *local_tls_type == GOT_TLS_GD
		  || *local_tls_type == GOT_TLS_IE)
		srel->size += sizeof (Elf64_External_Rela);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for
	 R_SPARC_TLS_LDM_{HI22,LO10} relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += (2 * 8);
      htab->srelgot->size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);

  /* The 32-bit sparc BFD backend has a hack that, iff the .got
     section is larger than 0x1000 bytes, it increments the
     .got base by 0x1000 so that 13 bit relocations are more
     likely to work.

     On 64-bit we have to be more careful, since sethi+or will
     not create a proper 64-bit sign extended negative value
     for relocations to the first 0x1000 bytes of the .got area.
     We could do this using sethi+xor tricks just like the
     sparc backend of GCC does, in order to make this work at
     some point.  Just... not today.  */

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip = FALSE;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strncmp (name, ".rela", 5) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is to handle .rela.bss and
		 .rel.plt.  We must create it in
		 create_dynamic_sections, because it must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (s != htab->splt && s != htab->sgot)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  Zero the memory
	 for the benefit of .rela.plt, which has 4 unused entries
	 at the beginning, and we don't want garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in sparc64_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      int reg;
      struct sparc64_elf_app_reg * app_regs;
      struct elf_strtab_hash *dynstr;
      struct elf_link_hash_table *eht = elf_hash_table (info);

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->srelplt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	return FALSE;

      /* If any dynamic relocs apply to a read-only section,
	 then we need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				(PTR) info);

      if (info->flags & DF_TEXTREL)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}

      /* Add dynamic STT_REGISTER symbols and corresponding DT_SPARC_REGISTER
	 entries if needed.  */
      app_regs = sparc64_elf_hash_table (info)->app_regs;
      dynstr = eht->dynstr;

      for (reg = 0; reg < 4; reg++)
	if (app_regs [reg].name != NULL)
	  {
	    struct elf_link_local_dynamic_entry *entry, *e;

	    if (!add_dynamic_entry (DT_SPARC_REGISTER, 0))
	      return FALSE;

	    entry = (struct elf_link_local_dynamic_entry *)
	      bfd_hash_allocate (&info->hash->table, sizeof (*entry));
	    if (entry == NULL)
	      return FALSE;

	    /* We cheat here a little bit: the symbol will not be local, so we
	       put it at the end of the dynlocal linked list.  We will fix it
	       later on, as we have to fix other fields anyway.  */
	    entry->isym.st_value = reg < 2 ? reg + 2 : reg + 4;
	    entry->isym.st_size = 0;
	    if (*app_regs [reg].name != '\0')
	      entry->isym.st_name
		= _bfd_elf_strtab_add (dynstr, app_regs[reg].name, FALSE);
	    else
	      entry->isym.st_name = 0;
	    entry->isym.st_other = 0;
	    entry->isym.st_info = ELF_ST_INFO (app_regs [reg].bind,
					       STT_REGISTER);
	    entry->isym.st_shndx = app_regs [reg].shndx;
	    entry->next = NULL;
	    entry->input_bfd = output_bfd;
	    entry->input_indx = -1;

	    if (eht->dynlocal == NULL)
	      eht->dynlocal = entry;
	    else
	      {
		for (e = eht->dynlocal; e->next; e = e->next)
		  ;
		e->next = entry;
	      }
	    eht->dynsymcount++;
	  }
    }
#undef add_dynamic_entry

  return TRUE;
}

static bfd_boolean
sparc64_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct sparc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct sparc64_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}

static bfd_boolean
sparc64_elf_relax_section (abfd, section, link_info, again)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
     bfd_boolean *again;
{
  *again = FALSE;
  sec_do_relax (section) = 1;
  return TRUE;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  return address - htab->tls_size - htab->tls_sec->vma;
}

/* Relocate a SPARC64 ELF section.  */

static bfd_boolean
sparc64_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  struct sparc64_elf_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  bfd_vma got_base;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocatable)
    return TRUE;

  htab = sparc64_elf_hash_table (info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  if (elf_hash_table (info)->hgot == NULL)
    got_base = 0;
  else
    got_base = elf_hash_table (info)->hgot->root.u.def.value;

  sreloc = elf_section_data (input_section)->sreloc;

  rel = relocs;
  relend = relocs + NUM_SHDR_ENTRIES (& elf_section_data (input_section)->rel_hdr);
  for (; rel < relend; rel++)
    {
      int r_type, tls_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation, off;
      bfd_reloc_status_type r;
      bfd_boolean is_plt = FALSE;
      bfd_boolean unresolved_reloc;

      r_type = ELF64_R_TYPE_ID (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_SPARC_max_std)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = sparc64_elf_howto_table + r_type;

      /* This is a final link.  */
      r_symndx = ELF64_R_SYM (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  if (warned)
	    {
	      /* To avoid generating warning messages about truncated
		 relocations, set the relocation's address to be the same as
		 the start of this section.  */
	      if (input_section->output_section != NULL)
		relocation = input_section->output_section->vma;
	      else
		relocation = 0;
	    }
	}

      switch (r_type)
	{
	case R_SPARC_GOT10:
	case R_SPARC_GOT13:
	case R_SPARC_GOT22:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    {
	      bfd_boolean dyn;

	      off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);
	      dyn = elf_hash_table (info)->dynamic_sections_created;

	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && (info->symbolic
			  || h->dynindx == -1
			  || h->forced_local)
		      && h->def_regular))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 8, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  htab->sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}
	      else
		unresolved_reloc = FALSE;
	    }
	  else
	    {
	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already processed this entry.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{

		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      /* We need to generate a R_SPARC_RELATIVE reloc
			 for the dynamic linker.  */
		      s = htab->srelgot;
		      BFD_ASSERT (s != NULL);

		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
		      outrel.r_addend = relocation;
		      relocation = 0;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  bfd_put_64 (output_bfd, relocation,
			      htab->sgot->contents + off);
		  local_got_offsets[r_symndx] |= 1;
		}
	    }
	  relocation = htab->sgot->output_offset + off - got_base;
	  break;

	case R_SPARC_PLT32:
	case R_SPARC_PLT64:
	  if (h == NULL || h->plt.offset == (bfd_vma) -1)
	    {
	      r_type = (r_type == R_SPARC_PLT32) ? R_SPARC_32 : R_SPARC_64;
	      goto r_sparc_plt32;
	    }
	  /* Fall through.  */

	case R_SPARC_WPLT30:
	case R_SPARC_HIPLT22:
	case R_SPARC_LOPLT10:
	case R_SPARC_PCPLT32:
	case R_SPARC_PCPLT22:
	case R_SPARC_PCPLT10:
	r_sparc_wplt30:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Relocation is to the entry for this symbol in the
             procedure linkage table.  */
	  BFD_ASSERT (h != NULL);

	  if (h->plt.offset == (bfd_vma) -1 || htab->splt == NULL)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  if (r_type == R_SPARC_PLT32 || r_type == R_SPARC_PLT64)
	    {
	      r_type = r_type == R_SPARC_PLT32 ? R_SPARC_32 : R_SPARC_64;
	      is_plt = TRUE;
	      goto r_sparc_plt32;
	    }
	  break;

	case R_SPARC_PC10:
	case R_SPARC_PC22:
	case R_SPARC_PC_HH22:
	case R_SPARC_PC_HM10:
	case R_SPARC_PC_LM22:
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */
	case R_SPARC_DISP8:
	case R_SPARC_DISP16:
	case R_SPARC_DISP32:
	case R_SPARC_DISP64:
	case R_SPARC_WDISP30:
	case R_SPARC_WDISP22:
	case R_SPARC_WDISP19:
	case R_SPARC_WDISP16:
	case R_SPARC_8:
	case R_SPARC_16:
	case R_SPARC_32:
	case R_SPARC_HI22:
	case R_SPARC_22:
	case R_SPARC_13:
	case R_SPARC_LO10:
	case R_SPARC_UA16:
	case R_SPARC_UA32:
	case R_SPARC_10:
	case R_SPARC_11:
	case R_SPARC_64:
	case R_SPARC_OLO10:
	case R_SPARC_HH22:
	case R_SPARC_HM10:
	case R_SPARC_LM22:
	case R_SPARC_7:
	case R_SPARC_5:
	case R_SPARC_6:
	case R_SPARC_HIX22:
	case R_SPARC_LOX10:
	case R_SPARC_H44:
	case R_SPARC_M44:
	case R_SPARC_L44:
	case R_SPARC_UA64:
	r_sparc_plt32:
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && (! howto->pc_relative
		   || (h != NULL
		       && h->dynindx != -1
		       && (! info->symbolic
			   || !h->def_regular))))
	      || (!info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      bfd_boolean skip, relocate = FALSE;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      BFD_ASSERT (sreloc != NULL);

	      skip = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      /* Optimize unaligned reloc usage now that we know where
		 it finally resides.  */
	      switch (r_type)
		{
		case R_SPARC_16:
		  if (outrel.r_offset & 1)
		    r_type = R_SPARC_UA16;
		  break;
		case R_SPARC_UA16:
		  if (!(outrel.r_offset & 1))
		    r_type = R_SPARC_16;
		  break;
		case R_SPARC_32:
		  if (outrel.r_offset & 3)
		    r_type = R_SPARC_UA32;
		  break;
		case R_SPARC_UA32:
		  if (!(outrel.r_offset & 3))
		    r_type = R_SPARC_32;
		  break;
		case R_SPARC_64:
		  if (outrel.r_offset & 7)
		    r_type = R_SPARC_UA64;
		  break;
		case R_SPARC_UA64:
		  if (!(outrel.r_offset & 7))
		    r_type = R_SPARC_64;
		  break;
	  	case R_SPARC_DISP8:
		case R_SPARC_DISP16:
	  	case R_SPARC_DISP32:
	  	case R_SPARC_DISP64:
		  /* If the symbol is not dynamic, we should not keep
		     a dynamic relocation.  But an .rela.* slot has been
		     allocated for it, output R_SPARC_NONE.
		     FIXME: Add code tracking needed dynamic relocs as
		     e.g. i386 has.  */
		  if (h->dynindx == -1)
		    skip = TRUE, relocate = TRUE;
		  break;
		}

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      /* h->dynindx may be -1 if the symbol was marked to
		 become local.  */
	      else if (h != NULL && ! is_plt
		       && ((! info->symbolic && h->dynindx != -1)
			   || !h->def_regular))
		{
		  BFD_ASSERT (h->dynindx != -1);
		  outrel.r_info
		    = ELF64_R_INFO (h->dynindx,
				    ELF64_R_TYPE_INFO (
				      ELF64_R_TYPE_DATA (rel->r_info),
				      r_type));
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  if (r_type == R_SPARC_64)
		    {
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		  else
		    {
		      long indx;

		      if (is_plt)
			sec = htab->splt;

		      if (bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;

			  /* FIXME: we really should be able to link non-pic
			     shared libraries.  */
			  if (indx == 0)
			    {
			      BFD_FAIL ();
			      (*_bfd_error_handler)
				(_("%B: probably compiled without -fPIC?"),
				 input_bfd);
			      bfd_set_error (bfd_error_bad_value);
			      return FALSE;
			    }
			}

		      outrel.r_info
			= ELF64_R_INFO (indx,
					ELF64_R_TYPE_INFO (
					  ELF64_R_TYPE_DATA (rel->r_info),
					  r_type));
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		}

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* This reloc will be computed at runtime, so there's no
		 need to do anything now.  */
	      if (! relocate)
		continue;
	    }
	  break;

	case R_SPARC_TLS_GD_HI22:
	case R_SPARC_TLS_GD_LO10:
	case R_SPARC_TLS_IE_HI22:
	case R_SPARC_TLS_IE_LO10:
	  r_type = sparc64_elf_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sparc64_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = sparc64_elf_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type == GOT_TLS_IE)
		switch (ELF64_R_TYPE_ID (rel->r_info))
		  {
		  case R_SPARC_TLS_GD_HI22:
		  case R_SPARC_TLS_IE_HI22:
		    r_type = R_SPARC_TLS_LE_HIX22;
		    break;
		  default:
		    r_type = R_SPARC_TLS_LE_LOX10;
		    break;
		  }
	    }
	  if (tls_type == GOT_TLS_IE)
	    switch (r_type)
	      {
	      case R_SPARC_TLS_GD_HI22:
		r_type = R_SPARC_TLS_IE_HI22;
		break;
	      case R_SPARC_TLS_GD_LO10:
		r_type = R_SPARC_TLS_IE_LO10;
		break;
	      }

	  if (r_type == R_SPARC_TLS_LE_HIX22)
	    {
	      relocation = tpoff (info, relocation);
	      break;
	    }
	  if (r_type == R_SPARC_TLS_LE_LOX10)
	    {
	      /* Change add into xor.  */
	      relocation = tpoff (info, relocation);
	      bfd_put_32 (output_bfd, (bfd_get_32 (input_bfd,
						   contents + rel->r_offset)
				       | 0x80182000), contents + rel->r_offset);
	      break;
	    }

	  if (h != NULL)
	    {
	      off = h->got.offset;
	      h->got.offset |= 1;
	    }
	  else
	    {
	      BFD_ASSERT (local_got_offsets != NULL);
	      off = local_got_offsets[r_symndx];
	      local_got_offsets[r_symndx] |= 1;
	    }

	r_sparc_tlsldm:
	  if (htab->sgot == NULL)
	    abort ();

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf64_External_Rela *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      bfd_put_64 (output_bfd, 0, htab->sgot->contents + off);
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_SPARC_TLS_IE_HI22
		  || r_type == R_SPARC_TLS_IE_LO10)
		dr_type = R_SPARC_TLS_TPOFF64;
	      else
		dr_type = R_SPARC_TLS_DTPMOD64;
	      if (dr_type == R_SPARC_TLS_TPOFF64 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);
	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					 (bfd_byte *) loc);

	      if (r_type == R_SPARC_TLS_GD_HI22
		  || r_type == R_SPARC_TLS_GD_LO10)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + 8);
		    }
		  else
		    {
		      bfd_put_64 (output_bfd, 0,
				  htab->sgot->contents + off + 8);
		      outrel.r_info = ELF64_R_INFO (indx,
						    R_SPARC_TLS_DTPOFF64);
		      outrel.r_offset += 8;
		      htab->srelgot->reloc_count++;
		      loc++;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 (bfd_byte *) loc);
		    }
		}
	      else if (dr_type == R_SPARC_TLS_DTPMOD64)
		{
		  bfd_put_64 (output_bfd, 0,
			      htab->sgot->contents + off + 8);
		}
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  relocation = htab->sgot->output_offset + off - got_base;
	  unresolved_reloc = FALSE;
	  howto = sparc64_elf_howto_table + r_type;
	  break;

	case R_SPARC_TLS_LDM_HI22:
	case R_SPARC_TLS_LDM_LO10:
	  if (! info->shared)
	    {
	      bfd_put_32 (output_bfd, SPARC_NOP, contents + rel->r_offset);
	      continue;
	    }
	  off = htab->tls_ldm_got.offset;
	  htab->tls_ldm_got.offset |= 1;
	  goto r_sparc_tlsldm;

	case R_SPARC_TLS_LDO_HIX22:
	case R_SPARC_TLS_LDO_LOX10:
	  if (info->shared)
	    {
	      relocation -= dtpoff_base (info);
	      break;
	    }

	  r_type = (r_type == R_SPARC_TLS_LDO_HIX22
		    ? R_SPARC_TLS_LE_HIX22 : R_SPARC_TLS_LE_LOX10);
	  /* Fall through.  */

	case R_SPARC_TLS_LE_HIX22:
	case R_SPARC_TLS_LE_LOX10:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate = FALSE;

	      BFD_ASSERT (sreloc != NULL);
	      skip = FALSE;
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else
		{
		  outrel.r_info = ELF64_R_INFO (0, r_type);
		  outrel.r_addend = relocation - dtpoff_base (info)
				    + rel->r_addend;
		}

	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					 (bfd_byte *) (((Elf64_External_Rela *)
							sreloc->contents)
						       + sreloc->reloc_count));
	      ++sreloc->reloc_count;
	      continue;
	    }
	  relocation = tpoff (info, relocation);
	  break;

	case R_SPARC_TLS_LDM_CALL:
	  if (! info->shared)
	    {
	      /* mov %g0, %o0 */
	      bfd_put_32 (output_bfd, 0x90100000, contents + rel->r_offset);
	      continue;
	    }
	  /* Fall through */

	case R_SPARC_TLS_GD_CALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sparc64_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = sparc64_elf_hash_entry(h)->tls_type;
	  if (! info->shared
	      || (r_type == R_SPARC_TLS_GD_CALL && tls_type == GOT_TLS_IE))
	    {
	      bfd_vma insn;

	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* GD -> LE */
		  bfd_put_32 (output_bfd, SPARC_NOP, contents + rel->r_offset);
		  continue;
		}

	      /* GD -> IE */
	      if (rel + 1 < relend
		  && ELF64_R_TYPE_ID (rel[1].r_info) == R_SPARC_TLS_GD_ADD
		  && rel[1].r_offset == rel->r_offset + 4
		  && ELF64_R_SYM (rel[1].r_info) == r_symndx
		  && (((insn = bfd_get_32 (input_bfd,
					   contents + rel[1].r_offset))
		       >> 25) & 0x1f) == 8)
		{
		  /* We have
		     call __tls_get_addr, %tgd_call(foo)
		      add %reg1, %reg2, %o0, %tgd_add(foo)
		     and change it into IE:
		     ldx [%reg1 + %reg2], %o0, %tie_ldx(foo)
		     add %g7, %o0, %o0, %tie_add(foo).
		     add is 0x80000000 | (rd << 25) | (rs1 << 14) | rs2,
		     ldx is 0xc0580000 | (rd << 25) | (rs1 << 14) | rs2.  */
		  bfd_put_32 (output_bfd, insn | 0xc0580000,
			      contents + rel->r_offset);
		  bfd_put_32 (output_bfd, 0x9001c008,
			      contents + rel->r_offset + 4);
		  rel++;
		  continue;
		}

	      bfd_put_32 (output_bfd, 0x9001c008, contents + rel->r_offset);
	      continue;
	    }

	  h = (struct elf_link_hash_entry *)
	      bfd_link_hash_lookup (info->hash, "__tls_get_addr", FALSE,
				    FALSE, TRUE);
	  BFD_ASSERT (h != NULL);
	  r_type = R_SPARC_WPLT30;
	  howto = sparc64_elf_howto_table + r_type;
	  goto r_sparc_wplt30;

	case R_SPARC_TLS_GD_ADD:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sparc64_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = sparc64_elf_hash_entry(h)->tls_type;
	  if (! info->shared || tls_type == GOT_TLS_IE)
	    {
	      /* add %reg1, %reg2, %reg3, %tgd_add(foo)
		 changed into IE:
		 ldx [%reg1 + %reg2], %reg3, %tie_ldx(foo)
		 or LE:
		 add %g7, %reg2, %reg3.  */
	      bfd_vma insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if ((h != NULL && h->dynindx != -1) || info->shared)
		relocation = insn | 0xc0580000;
	      else
		relocation = (insn & ~0x7c000) | 0x1c000;
	      bfd_put_32 (output_bfd, relocation, contents + rel->r_offset);
	    }
	  continue;

	case R_SPARC_TLS_LDM_ADD:
	  if (! info->shared)
	    bfd_put_32 (output_bfd, SPARC_NOP, contents + rel->r_offset);
	  continue;

	case R_SPARC_TLS_LDO_ADD:
	  if (! info->shared)
	    {
	      /* Change rs1 into %g7.  */
	      bfd_vma insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      insn = (insn & ~0x7c000) | 0x1c000;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    }
	  continue;

	case R_SPARC_TLS_IE_LD:
	case R_SPARC_TLS_IE_LDX:
	  if (! info->shared && (h == NULL || h->dynindx == -1))
	    {
	      bfd_vma insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      int rs2 = insn & 0x1f;
	      int rd = (insn >> 25) & 0x1f;

	      if (rs2 == rd)
		relocation = SPARC_NOP;
	      else
		relocation = 0x80100000 | (insn & 0x3e00001f);
	      bfd_put_32 (output_bfd, relocation, contents + rel->r_offset);
	    }
	  continue;

	case R_SPARC_TLS_IE_ADD:
	  /* Totally useless relocation.  */
	  continue;

	case R_SPARC_TLS_DTPOFF64:
	  relocation -= dtpoff_base (info);
	  break;

	default:
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic))
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
	   (long) rel->r_offset,
	   h->root.root.string);

      r = bfd_reloc_continue;
      if (r_type == R_SPARC_OLO10)
	{
	    bfd_vma x;

	    relocation += rel->r_addend;
	    relocation = (relocation & 0x3ff) + ELF64_R_TYPE_DATA (rel->r_info);

	    x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	    x = (x & ~(bfd_vma) 0x1fff) | (relocation & 0x1fff);
	    bfd_put_32 (input_bfd, x, contents + rel->r_offset);

	    r = bfd_check_overflow (howto->complain_on_overflow,
				    howto->bitsize, howto->rightshift,
				    bfd_arch_bits_per_address (input_bfd),
				    relocation);
	}
      else if (r_type == R_SPARC_WDISP16)
	{
	  bfd_vma x;

	  relocation += rel->r_addend;
	  relocation -= (input_section->output_section->vma
			 + input_section->output_offset);
	  relocation -= rel->r_offset;

	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  x |= ((((relocation >> 2) & 0xc000) << 6)
		| ((relocation >> 2) & 0x3fff));
	  bfd_put_32 (input_bfd, x, contents + rel->r_offset);

	  r = bfd_check_overflow (howto->complain_on_overflow,
				  howto->bitsize, howto->rightshift,
				  bfd_arch_bits_per_address (input_bfd),
				  relocation);
	}
      else if (r_type == R_SPARC_TLS_LDO_HIX22
	       || r_type == R_SPARC_TLS_LE_HIX22)
	{
	  bfd_vma x;

	  relocation += rel->r_addend;
	  if (r_type == R_SPARC_TLS_LE_HIX22)
	    relocation ^= MINUS_ONE;

	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  x = (x & ~(bfd_vma) 0x3fffff) | ((relocation >> 10) & 0x3fffff);
	  bfd_put_32 (input_bfd, x, contents + rel->r_offset);
	  r = bfd_reloc_ok;
	}
      if (r_type == R_SPARC_TLS_LDO_LOX10
	  || r_type == R_SPARC_TLS_LE_LOX10)
	{
	  bfd_vma x;

	  relocation += rel->r_addend;
	  relocation &= 0x3ff;
	  if (r_type == R_SPARC_TLS_LE_LOX10)
	    relocation |= 0x1c00;

	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  x = (x & ~(bfd_vma) 0x1fff) | relocation;
	  bfd_put_32 (input_bfd, x, contents + rel->r_offset);

	  r = bfd_reloc_ok;
	}
      else if (r_type == R_SPARC_HIX22)
	{
	  bfd_vma x;

	  relocation += rel->r_addend;
	  relocation = relocation ^ MINUS_ONE;

	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  x = (x & ~(bfd_vma) 0x3fffff) | ((relocation >> 10) & 0x3fffff);
	  bfd_put_32 (input_bfd, x, contents + rel->r_offset);

	  r = bfd_check_overflow (howto->complain_on_overflow,
				  howto->bitsize, howto->rightshift,
				  bfd_arch_bits_per_address (input_bfd),
				  relocation);
	}
      else if (r_type == R_SPARC_LOX10)
	{
	  bfd_vma x;

	  relocation += rel->r_addend;
	  relocation = (relocation & 0x3ff) | 0x1c00;

	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  x = (x & ~(bfd_vma) 0x1fff) | relocation;
	  bfd_put_32 (input_bfd, x, contents + rel->r_offset);

	  r = bfd_reloc_ok;
	}
      else if ((r_type == R_SPARC_WDISP30 || r_type == R_SPARC_WPLT30)
	       && sec_do_relax (input_section)
	       && rel->r_offset + 4 < input_section->size)
	{
#define G0		0
#define O7		15
#define XCC		(2 << 20)
#define COND(x)		(((x)&0xf)<<25)
#define CONDA		COND(0x8)
#define INSN_BPA	(F2(0,1) | CONDA | BPRED | XCC)
#define INSN_BA		(F2(0,2) | CONDA)
#define INSN_OR		F3(2, 0x2, 0)
#define INSN_NOP	F2(0,4)

	  bfd_vma x, y;

	  /* If the instruction is a call with either:
	     restore
	     arithmetic instruction with rd == %o7
	     where rs1 != %o7 and rs2 if it is register != %o7
	     then we can optimize if the call destination is near
	     by changing the call into a branch always.  */
	  x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  y = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
	  if ((x & OP(~0)) == OP(1) && (y & OP(~0)) == OP(2))
	    {
	      if (((y & OP3(~0)) == OP3(0x3d) /* restore */
		   || ((y & OP3(0x28)) == 0 /* arithmetic */
		       && (y & RD(~0)) == RD(O7)))
		  && (y & RS1(~0)) != RS1(O7)
		  && ((y & F3I(~0))
		      || (y & RS2(~0)) != RS2(O7)))
		{
		  bfd_vma reloc;

		  reloc = relocation + rel->r_addend - rel->r_offset;
		  reloc -= (input_section->output_section->vma
			    + input_section->output_offset);

		  /* Ensure the branch fits into simm22.  */
		  if ((reloc & 3) == 0
		      && ((reloc & ~(bfd_vma)0x7fffff) == 0
			  || ((reloc | 0x7fffff) == ~(bfd_vma)0)))
		    {
		      reloc >>= 2;

		      /* Check whether it fits into simm19.  */
		      if ((reloc & 0x3c0000) == 0
			  || (reloc & 0x3c0000) == 0x3c0000)
			x = INSN_BPA | (reloc & 0x7ffff); /* ba,pt %xcc */
		      else
			x = INSN_BA | (reloc & 0x3fffff); /* ba */
		      bfd_put_32 (input_bfd, x, contents + rel->r_offset);
		      r = bfd_reloc_ok;
		      if (rel->r_offset >= 4
			  && (y & (0xffffffff ^ RS1(~0)))
			     == (INSN_OR | RD(O7) | RS2(G0)))
			{
			  bfd_vma z;
			  unsigned int reg;

			  z = bfd_get_32 (input_bfd,
					  contents + rel->r_offset - 4);
			  if ((z & (0xffffffff ^ RD(~0)))
			      != (INSN_OR | RS1(O7) | RS2(G0)))
			    break;

			  /* The sequence was
			     or %o7, %g0, %rN
			     call foo
			     or %rN, %g0, %o7

			     If call foo was replaced with ba, replace
			     or %rN, %g0, %o7 with nop.  */

			  reg = (y & RS1(~0)) >> 14;
			  if (reg != ((z & RD(~0)) >> 25)
			      || reg == G0 || reg == O7)
			    break;

			  bfd_put_32 (input_bfd, (bfd_vma) INSN_NOP,
				      contents + rel->r_offset + 4);
			}

		    }
		}
	    }
	}

      if (r == bfd_reloc_continue)
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section,
			rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
sparc64_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  bfd *dynobj;
  struct sparc64_elf_link_hash_table *htab;

  htab = sparc64_elf_hash_table (info);
  dynobj = htab->elf.dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *srela;
      Elf_Internal_Rela rela;
      bfd_byte *loc;
      bfd_vma r_offset;
      int rela_index;

      /* This symbol has an entry in the PLT.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = htab->splt;
      srela = htab->srelplt;
      BFD_ASSERT (splt != NULL && srela != NULL);

      /* Fill in the entry in the procedure linkage table.  */
      rela_index = sparc64_plt_entry_build (output_bfd, splt, h->plt.offset,
					    splt->size, &r_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = r_offset
	+ (splt->output_section->vma + splt->output_offset);
      if (h->plt.offset < (LARGE_PLT_THRESHOLD * PLT_ENTRY_SIZE))
	{
	  rela.r_addend = 0;
	}
      else
	{
	  rela.r_addend = -(h->plt.offset + 4)
			  -(splt->output_section->vma + splt->output_offset);
	}
      rela.r_info = ELF64_R_INFO (h->dynindx, R_SPARC_JMP_SLOT);

      /* Adjust for the first 4 reserved elements in the .plt section
	 when setting the offset in the .rela.plt section.
	 Sun forgot to read their own ABI and copied elf32-sparc behaviour,
	 thus .plt[4] has corresponding .rela.plt[0] and so on.  */

      loc = srela->contents;
      loc += rela_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if (!h->ref_regular_nonweak)
	    sym->st_value = 0;
	}
    }

  if (h->got.offset != (bfd_vma) -1
      && sparc64_elf_hash_entry(h)->tls_type != GOT_TLS_GD
      && sparc64_elf_hash_entry(h)->tls_type != GOT_TLS_IE)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the GOT.  Set it up.  */

      sgot = htab->sgot;
      srela = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && h->def_regular)
	{
	  asection *sec = h->root.u.def.section;
	  rela.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + sec->output_section->vma
			   + sec->output_offset);
	}
      else
	{
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_SPARC_GLOB_DAT);
	  rela.r_addend = 0;
	}

      bfd_put_64 (output_bfd, (bfd_vma) 0,
		  sgot->contents + (h->got.offset &~ (bfd_vma) 1));
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbols needs a copy reloc.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_SPARC_COPY);
      rela.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
sparc64_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  int stt_regidx = -1;
  asection *sdyn;
  struct sparc64_elf_link_hash_table *htab;

  htab = sparc64_elf_hash_table (info);
  dynobj = htab->elf.dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf64_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  bfd_boolean size;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    case DT_PLTGOT:   name = ".plt"; size = FALSE; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = TRUE; break;
	    case DT_JMPREL:   name = ".rela.plt"; size = FALSE; break;
	    case DT_SPARC_REGISTER:
	      if (stt_regidx == -1)
		{
		  stt_regidx =
		    _bfd_elf_link_lookup_local_dynindx (info, output_bfd, -1);
		  if (stt_regidx == -1)
		    return FALSE;
		}
	      dyn.d_un.d_val = stt_regidx++;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      /* fallthrough */
	    default:	  name = NULL; size = FALSE; break;
	    }

	  if (name != NULL)
	    {
	      asection *s;

	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s == NULL)
		dyn.d_un.d_val = 0;
	      else
		{
		  if (! size)
		    dyn.d_un.d_ptr = s->vma;
		  else
		    dyn.d_un.d_val = s->size;
		}
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	    }
	}

      /* Initialize the contents of the .plt section.  */
      if (splt->size > 0)
	memset (splt->contents, 0, 4 * PLT_ENTRY_SIZE);

      elf_section_data (splt->output_section)->this_hdr.sh_entsize =
	PLT_ENTRY_SIZE;
    }

  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  if (htab->sgot && htab->sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgot->contents);
      else
	bfd_put_64 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    htab->sgot->contents);
    }

  if (htab->sgot)
    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize = 8;

  return TRUE;
}


/* Functions for dealing with the e_flags field.  */

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
sparc64_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  bfd_boolean error;
  flagword new_flags, old_flags;
  int new_mm, old_mm;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))   /* First call, no flags set */
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  else if (new_flags == old_flags)      /* Compatible flags are ok */
    ;

  else                                  /* Incompatible flags */
    {
      error = FALSE;

#define EF_SPARC_ISA_EXTENSIONS \
  (EF_SPARC_SUN_US1 | EF_SPARC_SUN_US3 | EF_SPARC_HAL_R1)

      if ((ibfd->flags & DYNAMIC) != 0)
d714 3
a716 4
sparc64_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
d734 2
a735 4
sparc64_elf_print_symbol_all (abfd, filep, symbol)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filep;
     asymbol *symbol;
a756 15
/* Set the right machine number for a SPARC64 ELF file.  */

static bfd_boolean
sparc64_elf_object_p (abfd)
     bfd *abfd;
{
  unsigned long mach = bfd_mach_sparc_v9;

  if (elf_elfheader (abfd)->e_flags & EF_SPARC_SUN_US3)
    mach = bfd_mach_sparc_v9b;
  else if (elf_elfheader (abfd)->e_flags & EF_SPARC_SUN_US1)
    mach = bfd_mach_sparc_v9a;
  return bfd_default_set_arch_mach (abfd, bfd_arch_sparc, mach);
}

d758 1
a758 2
sparc64_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
a772 18
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
sparc64_elf_plt_sym_val (bfd_vma i, const asection *plt,
			 const arelent *rel ATTRIBUTE_UNUSED)
{
  bfd_vma j;

  i += PLT_HEADER_SIZE / PLT_ENTRY_SIZE;
  if (i < LARGE_PLT_THRESHOLD)
    return plt->vma + i * PLT_ENTRY_SIZE;

  j = (i - LARGE_PLT_THRESHOLD) % 160;
  i -= j;
  return plt->vma + i * PLT_ENTRY_SIZE + j * 4 * 6;
}

d778 1
a778 1
const struct elf_size_info sparc64_elf_size_info =
d800 1
a800 1
  sparc64_elf_write_relocs,
d803 1
a803 1
  sparc64_elf_slurp_reloc_table,
d824 2
a825 7
#define bfd_elf64_bfd_link_hash_table_create \
  sparc64_elf_link_hash_table_create

#define elf_info_to_howto \
  sparc64_elf_info_to_howto
#define elf_backend_copy_indirect_symbol \
  sparc64_elf_copy_indirect_symbol
d827 1
a827 1
  sparc64_elf_get_reloc_upper_bound
d829 1
a829 1
  sparc64_elf_get_dynamic_reloc_upper_bound
d831 1
a831 1
  sparc64_elf_canonicalize_reloc
d833 26
a858 1
  sparc64_elf_canonicalize_dynamic_reloc
d860 1
a860 1
  sparc64_elf_reloc_type_lookup
d862 1
a862 1
  sparc64_elf_relax_section
d864 1
a864 1
  sparc64_elf_new_section_hook
d867 1
a867 7
  sparc64_elf_create_dynamic_sections
#define elf_backend_add_symbol_hook \
  sparc64_elf_add_symbol_hook
#define elf_backend_get_symbol_type \
  sparc64_elf_get_symbol_type
#define elf_backend_symbol_processing \
  sparc64_elf_symbol_processing
d869 1
a869 1
  sparc64_elf_check_relocs
d871 1
a871 1
  sparc64_elf_adjust_dynamic_symbol
d873 1
a873 1
  sparc64_elf_omit_section_dynsym
d875 1
a875 1
  sparc64_elf_size_dynamic_sections
d877 1
a877 1
  sparc64_elf_relocate_section
d879 1
a879 1
  sparc64_elf_finish_dynamic_symbol
d881 1
a881 11
  sparc64_elf_finish_dynamic_sections
#define elf_backend_print_symbol_all \
  sparc64_elf_print_symbol_all
#define elf_backend_output_arch_syms \
  sparc64_elf_output_arch_syms
#define bfd_elf64_bfd_merge_private_bfd_data \
  sparc64_elf_merge_private_bfd_data
#define elf_backend_fake_sections \
  sparc64_elf_fake_sections
#define elf_backend_plt_sym_val	\
  sparc64_elf_plt_sym_val
a882 2
#define elf_backend_size_info \
  sparc64_elf_size_info
d884 1
a884 1
  sparc64_elf_mkobject
d886 1
a886 1
  sparc64_elf_object_p
d888 1
a888 1
  sparc64_elf_gc_mark_hook
d890 1
a890 3
  sparc64_elf_gc_sweep_hook
#define elf_backend_reloc_type_class \
  sparc64_elf_reloc_type_class
@


1.103
log
@update copyright dates
@
text
@a24 1
#include "opcode/sparc.h"
d32 1
a36 9
static struct bfd_link_hash_table * sparc64_elf_bfd_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean sparc64_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_reloc_status_type init_insn_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *,
	   bfd *, bfd_vma *, bfd_vma *));
a40 8

static void sparc64_elf_build_plt
  PARAMS ((bfd *, unsigned char *, int));
static bfd_vma sparc64_elf_plt_entry_offset
  PARAMS ((bfd_vma));
static bfd_vma sparc64_elf_plt_ptr_offset
  PARAMS ((bfd_vma, bfd_vma));

d42 1
a42 1
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
d46 4
d54 50
a114 4

static bfd_boolean sparc64_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));

a116 1

d119 1
a119 1
static bfd_boolean sparc64_elf_new_section_hook
d121 2
a122 13
static bfd_boolean sparc64_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sparc64_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean sparc64_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean sparc64_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean sparc64_elf_object_p PARAMS ((bfd *));
static long sparc64_elf_get_reloc_upper_bound PARAMS ((bfd *, asection *));
static long sparc64_elf_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
d131 2
a132 3
static void sparc64_elf_write_relocs PARAMS ((bfd *, asection *, PTR));
static enum elf_reloc_type_class sparc64_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d751 66
d829 1
a829 1
  struct elf_link_hash_table root;
d834 12
d855 33
a887 1
/* Create a Sparc64 ELF linker hash table.  */
d890 1
a890 1
sparc64_elf_bfd_link_hash_table_create (abfd)
d897 1
a897 1
  if (ret == (struct sparc64_elf_link_hash_table *) NULL)
d900 1
a900 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       _bfd_elf_link_hash_newfunc))
d906 1
a906 1
  return &ret->root.root;
d909 1
a909 1
/* Create .got and .rela.got sections in DYNOBJ and set up
d957 10
d969 92
d1257 1
a1257 1
/* Fill in the .plt section.  */
d1259 2
a1260 2
static void
sparc64_elf_build_plt (output_bfd, contents, nentries)
d1262 4
a1265 2
     unsigned char *contents;
     int nentries;
d1267 3
a1269 11
  const unsigned int nop = 0x01000000;
  int i, j;

  /* The first four entries are reserved, and are initially undefined.
     We fill them with `illtrap 0' to force ld.so to do something.  */

  for (i = 0; i < PLT_HEADER_SIZE/4; ++i)
    bfd_put_32 (output_bfd, (bfd_vma) 0, contents+i*4);

  /* The first 32768 entries are close enough to plt1 to get there via
     a straight branch.  */
d1271 1
a1271 1
  for (i = 4; i < LARGE_PLT_THRESHOLD && i < nentries; ++i)
a1272 1
      unsigned char *entry = contents + i * PLT_ENTRY_SIZE;
d1275 1
a1275 2
      /* sethi (. - plt0), %g1 */
      sethi = 0x03000000 | (i * PLT_ENTRY_SIZE);
d1277 5
a1281 2
      /* ba,a,pt %xcc, plt1 */
      ba = 0x30680000 | (((contents+PLT_ENTRY_SIZE) - (entry+4)) / 4 & 0x7ffff);
d1292 1
a1292 6

  /* Now the tricky bit.  Entries 32768 and higher are grouped in blocks of
     160: 160 entries and 160 pointers.  This is to separate code from data,
     which is much friendlier on the cache.  */

  for (; i < nentries; i += 160)
d1294 21
a1314 2
      int block = (i + 160 <= nentries ? 160 : nentries - i);
      for (j = 0; j < block; ++j)
d1316 7
a1322 2
	  unsigned char *entry, *ptr;
	  unsigned int ldx;
d1324 1
a1324 2
	  entry = contents + i*PLT_ENTRY_SIZE + j*4*6;
	  ptr = contents + i*PLT_ENTRY_SIZE + block*4*6 + j*8;
d1326 26
a1351 2
	  /* ldx [%o7 + ptr - (entry+4)], %g1 */
	  ldx = 0xc25be000 | ((ptr - (entry+4)) & 0x1fff);
d1353 1
a1353 15
	  /* mov %o7,%g5
	     call .+8
	     nop
	     ldx [%o7+P],%g1
	     jmpl %o7+%g1,%g1
	     mov %g5,%o7  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0x8a10000f, entry);
	  bfd_put_32 (output_bfd, (bfd_vma) 0x40000002, entry + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) nop,        entry + 8);
	  bfd_put_32 (output_bfd, (bfd_vma) ldx,        entry + 12);
	  bfd_put_32 (output_bfd, (bfd_vma) 0x83c3c001, entry + 16);
	  bfd_put_32 (output_bfd, (bfd_vma) 0x9e100005, entry + 20);

	  bfd_put_64 (output_bfd, (bfd_vma) (contents - (entry + 4)), ptr);
	}
a1354 12
}

/* Return the offset of a particular plt entry within the .plt section.  */

static bfd_vma
sparc64_elf_plt_entry_offset (index)
     bfd_vma index;
{
  bfd_vma block, ofs;

  if (index < LARGE_PLT_THRESHOLD)
    return index * PLT_ENTRY_SIZE;
d1356 1
a1356 29
  /* See above for details.  */

  block = (index - LARGE_PLT_THRESHOLD) / 160;
  ofs = (index - LARGE_PLT_THRESHOLD) % 160;

  return (LARGE_PLT_THRESHOLD + block * 160) * PLT_ENTRY_SIZE + ofs * 6 * 4;
}

static bfd_vma
sparc64_elf_plt_ptr_offset (index, max)
     bfd_vma index;
     bfd_vma max;
{
  bfd_vma block, ofs, last;

  BFD_ASSERT(index >= LARGE_PLT_THRESHOLD);

  /* See above for details.  */

  block = (((index - LARGE_PLT_THRESHOLD) / 160) * 160) + LARGE_PLT_THRESHOLD;
  ofs = index - block;
  if (block + 160 > max)
    last = (max - LARGE_PLT_THRESHOLD) % 160;
  else
    last = 160;

  return (block * PLT_ENTRY_SIZE
	  + last * 6*4
	  + ofs * 8);
d1370 1
a1370 1
  bfd *dynobj;
a1375 2
  asection *sgot;
  asection *srelgot;
d1381 1
a1381 1
  dynobj = elf_hash_table (info)->dynobj;
a1385 2
  sgot = NULL;
  srelgot = NULL;
d1391 1
d1396 9
d1410 2
a1411 1
      switch (ELF64_R_TYPE_ID (rel->r_info))
d1413 17
d1433 2
d1436 2
d1439 17
a1455 7
	  if (dynobj == NULL)
	    {
	      /* Create the .got and .rela.got sections.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! create_got_section (dynobj, info))
		return FALSE;
	    }
d1457 8
a1464 5
	  if (sgot == NULL)
	    {
	      sgot = sparc64_elf_hash_table (info)->sgot;
	      BFD_ASSERT (sgot != NULL);
	    }
d1466 5
a1470 5
	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = sparc64_elf_hash_table (info)->srelgot;
	      BFD_ASSERT (srelgot != NULL);
	    }
d1472 13
a1484 8
	  if (h != NULL)
	    {
	      if (h->got.offset != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      h->got.offset = sgot->size;
d1486 13
a1498 4
	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1500 11
a1510 1
		}
d1512 6
a1517 1
	      srelgot->size += sizeof (Elf64_External_Rela);
d1519 5
a1523 1
	  else
d1525 10
a1534 30
	      /* This is a global offset table entry for a local
                 symbol.  */
	      if (local_got_offsets == NULL)
		{
		  bfd_size_type size;
		  register unsigned int i;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_vma);
		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_got_offsets == NULL)
		    return FALSE;
		  elf_local_got_offsets (abfd) = local_got_offsets;
		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
		}
	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      local_got_offsets[r_symndx] = sgot->size;

	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
                     output a R_SPARC_RELATIVE reloc so that the
                     dynamic linker can adjust this GOT entry.  */
		  srelgot->size += sizeof (Elf64_External_Rela);
		}
d1536 3
d1540 1
a1540 18
	  sgot->size += 8;

	  /* Doesn't work for 64-bit -fPIC, since sethi/or builds
	     unsigned numbers.  If we permit ourselves to modify
	     code so we get sethi/xor, this could work.
	     Question: do we consider conditionally re-enabling
             this for -fpic, once we know about object code models?  */
	  /* If the .got section is more than 0x1000 bytes, we add
	     0x1000 to the value of _GLOBAL_OFFSET_TABLE_, so that 13
	     bit relocations have a greater chance of working.  */
	  /*
	  if (sgot->size >= 0x1000
	      && elf_hash_table (info)->hgot->root.u.def.value == 0)
	    elf_hash_table (info)->hgot->root.u.def.value = 0x1000;
	  */

	  break;

a1541 1
	case R_SPARC_PLT32:
d1549 4
a1552 4
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */
d1562 8
a1569 12
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  h->needs_plt = 1;
	  if (ELF64_R_TYPE_ID (rel->r_info) != R_SPARC_PLT32
	      && ELF64_R_TYPE_ID (rel->r_info) != R_SPARC_PLT64)
	    break;
	  /* Fall through.  */
d1575 3
d1582 1
a1590 3
	  if (h == NULL)
	    break;
	  /* Fall through.  */
d1598 1
d1616 44
a1659 10
	case R_SPARC_UA16:
	  /* When creating a shared object, we must copy these relocs
	     into the output file.  We create a reloc section in
	     dynobj and make room for the reloc.

	     But don't do this for debugging sections -- this shows up
	     with DWARF2 -- first because they are not loaded, and
	     second because DWARF sez the debug info is not to be
	     biased by the load address.  */
	  if (info->shared && (sec->flags & SEC_ALLOC))
d1661 6
d1670 1
d1683 4
d1702 36
a1737 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d1740 3
a1742 1
	      sreloc->size += sizeof (Elf64_External_Rela);
d1744 1
d1752 1
a1752 3
	  (*_bfd_error_handler) (_("%B: check_relocs: unhandled reloc type %d"),
				abfd, ELF64_R_TYPE_ID (rel->r_info));
	  return FALSE;
d1975 169
d2155 3
a2157 1
  bfd *dynobj;
d2161 1
a2161 1
  dynobj = elf_hash_table (info)->dynobj;
d2164 1
a2164 1
  BFD_ASSERT (dynobj != NULL
d2185 6
a2190 5
      if (! info->shared
	  && !h->def_dynamic
	  && !h->ref_dynamic
	  && h->root.type != bfd_link_hash_undefweak
	  && h->root.type != bfd_link_hash_undefined)
d2193 6
a2198 46
             file, but none of the input files were dynamic objects.
             In such a case, we don't actually need to build a
             procedure linkage table, and we can just do a WDISP30
             reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
	  return TRUE;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* The first four bit in .plt is reserved.  */
      if (s->size == 0)
	s->size = PLT_HEADER_SIZE;

      /* To simplify matters later, just store the plt index here.  */
      h->plt.offset = s->size / PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = sparc64_elf_plt_entry_offset (h->plt.offset);
	}

      /* Make room for this entry.  */
      s->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */

      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);

      s->size += sizeof (Elf64_External_Rela);

      /* The procedure linkage table size is bounded by the magnitude
	 of the offset we can describe in the entry.  */
      if (s->size >= (bfd_vma)1 << 32)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
d2203 2
d2228 21
a2258 3
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

d2265 1
a2265 5
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf64_External_Rela);
d2277 1
d2295 2
a2296 2
/* Return true if the dynamic symbol for a given section should be
   omitted when creating a shared library.  */
d2299 3
a2301 3
sparc64_elf_omit_section_dynsym (bfd *output_bfd,
				 struct bfd_link_info *info,
				 asection *p)
d2303 49
a2351 5
  /* We keep the .got section symbol so that explicit relocations
     against the _GLOBAL_OFFSET_TABLE_ symbol emitted in PIC mode
     can be turned into relocations against the .got symbol.  */
  if (strcmp (p->name, ".got") == 0)
    return FALSE;
d2353 1
a2353 2
  return _bfd_elf_link_omit_section_dynsym (output_bfd, info, p);
}
d2355 4
a2358 1
/* Set the sizes of the dynamic sections.  */
d2360 11
a2370 8
static bfd_boolean
sparc64_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  bfd_boolean relplt;
d2372 2
a2373 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d2375 4
a2378 4
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
d2380 2
a2381 4
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d2386 2
a2387 8
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = sparc64_elf_hash_table (info)->srelgot;
      if (s != NULL)
	s->size = 0;
d2390 8
a2397 5
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relplt = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
d2399 3
a2401 2
      const char *name;
      bfd_boolean strip;
d2403 284
a2686 2
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;
a2691 2
      strip = FALSE;

a2708 3
	      if (strcmp (name, ".rela.plt") == 0)
		relplt = TRUE;

d2714 1
a2714 2
      else if (strcmp (name, ".plt") != 0
	       && strncmp (name, ".got", 4) != 0)
d2755 1
a2755 1
      if (relplt)
d2769 6
d2861 30
d2905 1
a2905 1
  bfd *dynobj;
a2909 2
  asection *sgot;
  asection *splt;
d2917 1
a2917 1
  dynobj = elf_hash_table (info)->dynobj;
d2922 1
a2922 1
  if (elf_hash_table(info)->hgot == NULL)
d2927 1
a2927 3
  sgot = splt = sreloc = NULL;
  if (dynobj != NULL)
    splt = bfd_get_section_by_name (dynobj, ".plt");
d2933 1
a2933 1
      int r_type;
d2984 295
a3278 56
 do_dynreloc:
      /* When generating a shared object, these relocations are copied
	 into the output file to be resolved at run time.  */
      if (info->shared && r_symndx != 0 && (input_section->flags & SEC_ALLOC))
	{
	  switch (r_type)
	    {
	    case R_SPARC_PC10:
	    case R_SPARC_PC22:
	    case R_SPARC_PC_HH22:
	    case R_SPARC_PC_HM10:
	    case R_SPARC_PC_LM22:
	      if (h != NULL
		  && !strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_"))
		break;
	      /* Fall through.  */
	    case R_SPARC_DISP8:
	    case R_SPARC_DISP16:
	    case R_SPARC_DISP32:
	    case R_SPARC_DISP64:
	    case R_SPARC_WDISP30:
	    case R_SPARC_WDISP22:
	    case R_SPARC_WDISP19:
	    case R_SPARC_WDISP16:
	      if (h == NULL)
		break;
	      /* Fall through.  */
	    case R_SPARC_8:
	    case R_SPARC_16:
	    case R_SPARC_32:
	    case R_SPARC_HI22:
	    case R_SPARC_22:
	    case R_SPARC_13:
	    case R_SPARC_LO10:
	    case R_SPARC_UA32:
	    case R_SPARC_10:
	    case R_SPARC_11:
	    case R_SPARC_64:
	    case R_SPARC_OLO10:
	    case R_SPARC_HH22:
	    case R_SPARC_HM10:
	    case R_SPARC_LM22:
	    case R_SPARC_7:
	    case R_SPARC_5:
	    case R_SPARC_6:
	    case R_SPARC_HIX22:
	    case R_SPARC_LOX10:
	    case R_SPARC_H44:
	    case R_SPARC_M44:
	    case R_SPARC_L44:
	    case R_SPARC_UA64:
	    case R_SPARC_UA16:
	      {
		Elf_Internal_Rela outrel;
		bfd_byte *loc;
		bfd_boolean skip, relocate;
d3280 2
a3281 7
		if (sreloc == NULL)
		  {
		    const char *name =
		      (bfd_elf_string_from_elf_section
		       (input_bfd,
			elf_elfheader (input_bfd)->e_shstrndx,
			elf_section_data (input_section)->rel_hdr.sh_name));
d3283 10
a3292 2
		    if (name == NULL)
		      return FALSE;
d3294 2
a3295 4
		    BFD_ASSERT (strncmp (name, ".rela", 5) == 0
				&& strcmp (bfd_get_section_name(input_bfd,
								input_section),
					   name + 5) == 0);
d3297 12
a3308 3
		    sreloc = bfd_get_section_by_name (dynobj, name);
		    BFD_ASSERT (sreloc != NULL);
		  }
d3310 8
a3317 2
		skip = FALSE;
		relocate = FALSE;
d3319 24
a3342 14
		outrel.r_offset =
		  _bfd_elf_section_offset (output_bfd, info, input_section,
					   rel->r_offset);
		if (outrel.r_offset == (bfd_vma) -1)
		  skip = TRUE;
		else if (outrel.r_offset == (bfd_vma) -2)
		  skip = TRUE, relocate = TRUE;

		outrel.r_offset += (input_section->output_section->vma
				    + input_section->output_offset);

		/* Optimize unaligned reloc usage now that we know where
		   it finally resides.  */
		switch (r_type)
d3344 3
a3346 14
		  case R_SPARC_16:
		    if (outrel.r_offset & 1) r_type = R_SPARC_UA16;
		    break;
		  case R_SPARC_UA16:
		    if (!(outrel.r_offset & 1)) r_type = R_SPARC_16;
		    break;
		  case R_SPARC_32:
		    if (outrel.r_offset & 3) r_type = R_SPARC_UA32;
		    break;
		  case R_SPARC_UA32:
		    if (!(outrel.r_offset & 3)) r_type = R_SPARC_32;
		    break;
		  case R_SPARC_64:
		    if (outrel.r_offset & 7) r_type = R_SPARC_UA64;
d3348 2
a3349 14
		  case R_SPARC_UA64:
		    if (!(outrel.r_offset & 7)) r_type = R_SPARC_64;
		    break;
		  case R_SPARC_DISP8:
		  case R_SPARC_DISP16:
		  case R_SPARC_DISP32:
		  case R_SPARC_DISP64:
		    /* If the symbol is not dynamic, we should not keep
		       a dynamic relocation.  But an .rela.* slot has been
		       allocated for it, output R_SPARC_NONE.
		       FIXME: Add code tracking needed dynamic relocs as
		       e.g. i386 has.  */
		    if (h->dynindx == -1)
		      skip = TRUE, relocate = TRUE;
d3352 11
d3364 4
a3367 87
		/* FIXME: Dynamic reloc handling really needs to be rewritten.  */
		if (!skip
		    && h != NULL
		    && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		    && h->root.type == bfd_link_hash_undefweak)
		  skip = TRUE, relocate = TRUE;

		if (skip)
		  memset (&outrel, 0, sizeof outrel);
		/* h->dynindx may be -1 if the symbol was marked to
		   become local.  */
		else if (h != NULL && ! is_plt
			 && ((! info->symbolic && h->dynindx != -1)
			     || !h->def_regular))
		  {
		    BFD_ASSERT (h->dynindx != -1);
		    outrel.r_info
		      = ELF64_R_INFO (h->dynindx,
				      ELF64_R_TYPE_INFO (
					ELF64_R_TYPE_DATA (rel->r_info),
							   r_type));
		    outrel.r_addend = rel->r_addend;
		  }
		else
		  {
		    outrel.r_addend = relocation + rel->r_addend;
		    if (r_type == R_SPARC_64)
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
		    else
		      {
			long indx;

			if (is_plt)
			  sec = splt;

			if (bfd_is_abs_section (sec))
			  indx = 0;
			else if (sec == NULL || sec->owner == NULL)
			  {
			    bfd_set_error (bfd_error_bad_value);
			    return FALSE;
			  }
			else
			  {
			    asection *osec;

			    osec = sec->output_section;
			    indx = elf_section_data (osec)->dynindx;

			    /* We are turning this relocation into one
			       against a section symbol, so subtract out
			       the output section's address but not the
			       offset of the input section in the output
			       section.  */
			    outrel.r_addend -= osec->vma;

			    /* FIXME: we really should be able to link non-pic
			       shared libraries.  */
			    if (indx == 0)
			      {
				BFD_FAIL ();
				(*_bfd_error_handler)
				  (_("%B: probably compiled without -fPIC?"),
				   input_bfd);
				bfd_set_error (bfd_error_bad_value);
				return FALSE;
			      }
			  }

			outrel.r_info
			  = ELF64_R_INFO (indx,
					  ELF64_R_TYPE_INFO (
					    ELF64_R_TYPE_DATA (rel->r_info),
							       r_type));
		      }
		  }

		loc = sreloc->contents;
		loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
		bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

		/* This reloc will be computed at runtime, so there's no
		   need to do anything now.  */
		if (! relocate)
		  continue;
	      }
	    break;
d3369 1
a3369 10
	}

      switch (r_type)
	{
	case R_SPARC_GOT10:
	case R_SPARC_GOT13:
	case R_SPARC_GOT22:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (sgot == NULL)
d3371 6
a3376 2
	      sgot = sparc64_elf_hash_table (info)->sgot;
	      BFD_ASSERT (sgot != NULL);
d3381 13
a3393 1
	      bfd_boolean dyn;
d3395 29
a3423 3
	      off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);
	      dyn = elf_hash_table (info)->dynamic_sections_created;
d3425 2
a3426 6
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && (info->symbolic
			  || h->dynindx == -1
			  || h->forced_local)
		      && h->def_regular))
d3428 7
a3434 14
		  /* This is actually a static link, or it is a -Bsymbolic
		     link and the symbol is defined locally, or the symbol
		     was forced to be local because of a version file.  We
		     must initialize this entry in the global offset table.
		     Since the offset must always be a multiple of 8, we
		     use the least significant bit to record whether we
		     have initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This is
		     done in the finish_dynamic_symbol routine.  */

		  if ((off & 1) != 0)
		    off &= ~1;
d3437 9
a3445 3
		      bfd_put_64 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
d3448 32
a3479 2
	      else
		unresolved_reloc = FALSE;
d3481 8
a3488 1
	  else
d3490 2
a3491 3
	      BFD_ASSERT (local_got_offsets != NULL);
	      off = local_got_offsets[r_symndx];
	      BFD_ASSERT (off != (bfd_vma) -1);
d3493 13
a3505 5
	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already processed this entry.  */
	      if ((off & 1) != 0)
		off &= ~1;
d3508 14
a3521 1
		  local_got_offsets[r_symndx] |= 1;
d3523 8
a3530 5
		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
d3532 10
a3541 7
		      /* The Solaris 2.7 64-bit linker adds the contents
			 of the location to the value of the reloc.
			 Note this is different behaviour to the
			 32-bit linker, which both adds the contents
			 and ignores the addend.  So clear the location.  */
		      bfd_put_64 (output_bfd, (bfd_vma) 0,
				  sgot->contents + off);
d3543 6
a3548 4
		      /* We need to generate a R_SPARC_RELATIVE reloc
			 for the dynamic linker.  */
		      s = sparc64_elf_hash_table (info)->srelgot;
		      BFD_ASSERT (s != NULL);
d3550 23
a3572 11
		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		  else
		    bfd_put_64 (output_bfd, relocation, sgot->contents + off);
d3574 3
a3577 2
	  relocation = sgot->output_offset + off - got_base;
	  goto do_default;
d3579 3
a3581 10
	case R_SPARC_WPLT30:
	case R_SPARC_PLT32:
	case R_SPARC_HIPLT22:
	case R_SPARC_LOPLT10:
	case R_SPARC_PCPLT32:
	case R_SPARC_PCPLT22:
	case R_SPARC_PCPLT10:
	case R_SPARC_PLT64:
	  /* Relocation is to the entry for this symbol in the
             procedure linkage table.  */
d3583 30
d3614 2
a3615 1
	  if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d3617 4
a3620 4
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      goto do_default;
d3622 1
d3624 3
a3626 7
	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ sparc64_elf_plt_entry_offset (h->plt.offset));
	  unresolved_reloc = FALSE;
	  if (r_type == R_SPARC_WPLT30)
	    goto do_wplt30;
	  if (r_type == R_SPARC_PLT32 || r_type == R_SPARC_PLT64)
d3628 9
a3636 3
	      r_type = r_type == R_SPARC_PLT32 ? R_SPARC_32 : R_SPARC_64;
	      is_plt = TRUE;
	      goto do_dynreloc;
d3638 1
a3638 1
	  goto do_default;
d3640 3
a3642 3
	case R_SPARC_OLO10:
	  {
	    bfd_vma x;
d3644 3
a3646 2
	    relocation += rel->r_addend;
	    relocation = (relocation & 0x3ff) + ELF64_R_TYPE_DATA (rel->r_info);
d3648 3
a3650 3
	    x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	    x = (x & ~(bfd_vma) 0x1fff) | (relocation & 0x1fff);
	    bfd_put_32 (input_bfd, x, contents + rel->r_offset);
d3652 12
a3663 6
	    r = bfd_check_overflow (howto->complain_on_overflow,
				    howto->bitsize, howto->rightshift,
				    bfd_arch_bits_per_address (input_bfd),
				    relocation);
	  }
	  break;
d3665 3
a3667 2
	case R_SPARC_WDISP16:
	  {
d3671 1
a3671 4
	    /* Adjust for pc-relative-ness.  */
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset);
	    relocation -= rel->r_offset;
d3674 1
a3674 3
	    x &= ~(bfd_vma) 0x303fff;
	    x |= ((((relocation >> 2) & 0xc000) << 6)
		  | ((relocation >> 2) & 0x3fff));
d3681 4
a3684 2
	  }
	  break;
d3686 19
a3704 3
	case R_SPARC_HIX22:
	  {
	    bfd_vma x;
d3706 13
a3718 2
	    relocation += rel->r_addend;
	    relocation = relocation ^ MINUS_ONE;
d3720 8
a3727 3
	    x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	    x = (x & ~(bfd_vma) 0x3fffff) | ((relocation >> 10) & 0x3fffff);
	    bfd_put_32 (input_bfd, x, contents + rel->r_offset);
d3729 5
a3733 6
	    r = bfd_check_overflow (howto->complain_on_overflow,
				    howto->bitsize, howto->rightshift,
				    bfd_arch_bits_per_address (input_bfd),
				    relocation);
	  }
	  break;
d3735 2
a3736 3
	case R_SPARC_LOX10:
	  {
	    bfd_vma x;
d3738 12
a3749 2
	    relocation += rel->r_addend;
	    relocation = (relocation & 0x3ff) | 0x1c00;
d3751 2
a3752 3
	    x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	    x = (x & ~(bfd_vma) 0x1fff) | relocation;
	    bfd_put_32 (input_bfd, x, contents + rel->r_offset);
d3754 3
a3756 3
	    r = bfd_reloc_ok;
	  }
	  break;
d3758 6
a3763 5
	case R_SPARC_WDISP30:
	do_wplt30:
	  if (sec_do_relax (input_section)
	      && rel->r_offset + 4 < input_section->size)
	    {
d3774 1
a3774 1
	      bfd_vma x, y;
d3776 16
a3791 9
	      /* If the instruction is a call with either:
		 restore
		 arithmetic instruction with rd == %o7
		 where rs1 != %o7 and rs2 if it is register != %o7
		 then we can optimize if the call destination is near
		 by changing the call into a branch always.  */
	      x = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      y = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
	      if ((x & OP(~0)) == OP(1) && (y & OP(~0)) == OP(2))
d3793 10
a3802 6
		  if (((y & OP3(~0)) == OP3(0x3d) /* restore */
		       || ((y & OP3(0x28)) == 0 /* arithmetic */
			   && (y & RD(~0)) == RD(O7)))
		      && (y & RS1(~0)) != RS1(O7)
		      && ((y & F3I(~0))
			  || (y & RS2(~0)) != RS2(O7)))
a3803 12
		      bfd_vma reloc;

		      reloc = relocation + rel->r_addend - rel->r_offset;
		      reloc -= (input_section->output_section->vma
				+ input_section->output_offset);
		      if (reloc & 3)
			goto do_default;

		      /* Ensure the branch fits into simm22.  */
		      if ((reloc & ~(bfd_vma)0x7fffff)
			   && ((reloc | 0x7fffff) != MINUS_ONE))
			goto do_default;
d3843 1
a3843 1
		      break;
a3846 8
	  /* Fall through.  */

	default:
	do_default:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, rel->r_addend);
	  break;
d3849 4
a3852 11
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic))
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd, input_section,
	   (long) rel->r_offset,
	   h->root.root.string);
d3854 1
a3854 1
      switch (r)
d3856 8
a3863 2
	case bfd_reloc_ok:
	  break;
d3865 3
a3867 25
	default:
	case bfd_reloc_outofrange:
	  abort ();

	case bfd_reloc_overflow:
	  {
	    const char *name;

	    /* The Solaris native linker silently disregards
	       overflows.  We don't, but this breaks stabs debugging
	       info, whose relocations are only 32-bits wide.  Ignore
	       overflows in this case and also for discarded entries.  */
	    if ((r_type == R_SPARC_32 || r_type == R_SPARC_DISP32)
		&& (((input_section->flags & SEC_DEBUGGING) != 0
		     && strcmp (bfd_section_name (input_bfd, input_section),
			       ".stab") == 0)
		    || _bfd_elf_section_offset (output_bfd, info,
						input_section,
						rel->r_offset) == (bfd_vma)-1))
	      break;

	    if (h != NULL)
	      {
		if (h->root.type == bfd_link_hash_undefweak
		    && howto->pc_relative)
d3869 7
a3875 6
		    /* Assume this is a call protected by other code that
		       detect the symbol is undefined.  If this is the case,
		       we can safely ignore the overflow.  If not, the
		       program is hosed anyway, and a little warning isn't
		       going to help.  */
		    break;
d3877 4
a3880 10

	        name = NULL;
	      }
	    else
	      {
		name = (bfd_elf_string_from_elf_section
			(input_bfd,
			 symtab_hdr->sh_link,
			 sym->st_name));
		if (name == NULL)
a3881 2
		if (*name == '\0')
		  name = bfd_section_name (input_bfd, sec);
d3883 2
a3884 7
	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd, input_section,
		    rel->r_offset)))
	      return FALSE;
	  }
	break;
d3902 1
d3904 2
a3905 1
  dynobj = elf_hash_table (info)->dynobj;
d3913 2
d3920 2
a3921 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
d3924 4
d3929 3
a3931 2

      if (h->plt.offset < LARGE_PLT_THRESHOLD)
a3932 1
	  rela.r_offset = sparc64_elf_plt_entry_offset (h->plt.offset);
d3937 1
a3937 3
	  bfd_vma max = splt->size / PLT_ENTRY_SIZE;
	  rela.r_offset = sparc64_elf_plt_ptr_offset (h->plt.offset, max);
	  rela.r_addend = -(sparc64_elf_plt_entry_offset (h->plt.offset) + 4)
a3939 1
      rela.r_offset += (splt->output_section->vma + splt->output_offset);
d3948 1
a3948 1
      loc += (h->plt.offset - 4) * sizeof (Elf64_External_Rela);
d3965 3
a3967 1
  if (h->got.offset != (bfd_vma) -1)
d3976 2
a3977 2
      sgot = sparc64_elf_hash_table (info)->sgot;
      srela = sparc64_elf_hash_table (info)->srelgot;
d4053 1
a4053 1
  asection *sgot;
d4055 2
a4056 1
  dynobj = elf_hash_table (info)->dynobj;
d4094 1
a4094 1
	    default:	      name = NULL; size = FALSE; break;
d4117 1
a4117 2
	sparc64_elf_build_plt (output_bfd, splt->contents,
			       (int) (splt->size / PLT_ENTRY_SIZE));
d4125 1
a4125 3
  sgot = sparc64_elf_hash_table (info)->sgot;
  BFD_ASSERT (sgot != NULL);
  if (sgot->size > 0)
d4128 1
a4128 1
	bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents);
d4132 1
a4132 1
		    sgot->contents);
d4135 2
a4136 1
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 8;
a4140 16
static enum elf_reloc_type_class
sparc64_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_SPARC_RELATIVE:
      return reloc_class_relative;
    case R_SPARC_JMP_SLOT:
      return reloc_class_plt;
    case R_SPARC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}
d4296 17
d4383 1
a4383 1
  sparc64_elf_bfd_link_hash_table_create
d4387 2
d4439 2
d4443 4
d4450 2
d4455 1
a4460 2
#define elf_backend_got_header_size 8

@


1.102
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
@


1.101
log
@	* elf64-sparc.c (sparc64_elf_adjust_dynamic_symbol): When linking a
	non-shared object, do not reserve space in .plt and .rela.plt
	for regular symbols neither defined nor referenced in shared objects.
@
text
@a1270 1
#if 0
d1279 1
d1283 1
a1283 1
#endif
@


1.100
log
@	* elf64-sparc.c (struct sparc64_elf_link_hash_table): New 'sgot' and
	'srelgot' fields.
	(create_got_section): New function.
	(sparc64_elf_create_dynamic_sections): Likewise.
	(sparc64_elf_check_relocs): Invoke create_got_section instead of
	_bfd_elf_create_got_section.  Use the sgot and srelgot shortcuts.
	(sparc64_elf_size_dynamic_sections): Use the srelgot shortcut.
	(sparc64_elf_relocate_section): Use the sgot and srelgot shortcuts.
	(sparc64_elf_finish_dynamic_symbol): Likewise.
	(sparc64_elf_finish_dynamic_sections): Use the sgot shortcut.
	(elf_backend_create_dynamic_sections): Define to
	sparc64_elf_create_dynamic_sections.
@
text
@d1683 5
a1687 1
      if (! elf_hash_table (info)->dynamic_sections_created)
@


1.99
log
@	* elf32-sparc.c (elf32_sparc_omit_section_dynsym): New function.
	(elf_backend_omit_section_dynsym): Define to it.
	* elf64-sparc.c (sparc64_elf_omit_section_dynsym): New function.
	(elf_backend_omit_section_dynsym): Define to it.
@
text
@d39 4
d745 4
d779 51
d1199 1
a1199 1
	      /* Create the .got section.  */
d1201 1
a1201 1
	      if (! _bfd_elf_create_got_section (dynobj, info))
d1207 1
a1207 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d1213 2
a1214 15
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 3))
		    return FALSE;
		}
d1860 1
a1860 1
      s = bfd_get_section_by_name (dynobj, ".rela.got");
d2373 1
a2373 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d2447 1
a2447 1
		      s = bfd_get_section_by_name(dynobj, ".rela.got");
d2828 2
a2829 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
d2977 1
a2977 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d3255 1
a3255 1
  _bfd_elf_create_dynamic_sections
@


1.98
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from STABS debugging sections again.
@
text
@d59 2
d1765 17
d3220 2
@


1.97
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2636 1
a2636 1
	       overflows for discarded entries.  */
d2638 6
a2643 2
		&& _bfd_elf_section_offset (output_bfd, info, input_section,
					    rel->r_offset) == (bfd_vma) -1)
@


1.96
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d2655 1
a2655 1
	        name = h->root.root.string;
d2669 3
a2671 2
		   (info, name, howto->name, (bfd_vma) 0,
		    input_bfd, input_section, rel->r_offset)))
@


1.95
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1616 1
a1616 1
		  || h->weakdef != NULL
d1692 1
a1692 1
  if (h->weakdef != NULL)
d1694 4
a1697 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.94
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1268 1
a1268 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1615 1
a1615 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d1617 3
a1619 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d1629 1
a1629 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
d1642 1
a1642 1
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
d1662 1
a1662 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1735 1
a1735 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d2222 1
a2222 2
			     || (h->elf_link_hash_flags
				 & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2324 2
a2325 2
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2613 1
a2613 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d2735 1
a2735 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2744 1
a2744 2
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
d2773 1
a2773 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2794 1
a2794 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.93
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d1371 2
a1372 3
	  (*_bfd_error_handler) (_("%s: check_relocs: unhandled reloc type %d"),
				bfd_archive_filename (abfd),
				ELF64_R_TYPE_ID (rel->r_info));
d1407 2
a1408 2
            (_("%s: Only registers %%g[2367] can be declared using STT_REGISTER"),
             bfd_archive_filename (abfd));
d1427 4
a1430 4
            (_("Register %%g%d used incompatibly: %s in %s, previously %s in %s"),
             (int) sym->st_value,
             **namep ? *namep : "#scratch", bfd_archive_filename (abfd),
             *p->name ? p->name : "#scratch", bfd_archive_filename (p->abfd));
d1450 2
a1451 3
		    (_("Symbol `%s' has differing types: REGISTER in %s, previously %s in %s"),
		     *namep, bfd_archive_filename (abfd),
		     stt_types[type], bfd_archive_filename (p->abfd));
d1495 2
a1496 3
	      (_("Symbol `%s' has differing types: %s in %s, previously REGISTER in %s"),
	       *namep, stt_types[type], bfd_archive_filename (abfd),
	       bfd_archive_filename (p->abfd));
d2275 2
a2276 2
				  (_("%s: probably compiled without -fPIC?"),
				   bfd_archive_filename (input_bfd));
d2619 2
a2620 3
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
d3002 2
a3003 2
		(_("%s: linking UltraSPARC specific with HAL specific code"),
		 bfd_archive_filename (ibfd));
d3021 2
a3022 2
            (_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
             bfd_archive_filename (ibfd), (long) new_flags, (long) old_flags);
@


1.92
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a796 1
  bfd_size_type sz;
d812 1
a812 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.91
log
@	* elf64-alpha.c (elf64_alpha_read_ecoff_info): Don't assign
	structure field removed in 2004-04-24 patch.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): Warning fix.

	* elf-bfd.h (struct elf_backend_data <elf_backend_section_flags>):
	Constify hdr arg.
	* elf32-arm.h (elf32_arm_section_flags): Likewise.
	* elf64-alpha.c (elf64_alpha_section_flags): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_flags): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set the bfd_section
	field before calling elf_backend_section_flags.
@
text
@d481 1
a481 1
      if (asect->_raw_size == 0)
d797 1
d813 2
a814 1
  if (reloc_entry->address > input_section->_cooked_size)
d1178 1
a1178 1
	      h->got.offset = sgot->_raw_size;
d1187 1
a1187 1
	      srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1212 1
a1212 1
	      local_got_offsets[r_symndx] = sgot->_raw_size;
d1219 1
a1219 1
		  srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1223 1
a1223 1
	  sgot->_raw_size += 8;
d1234 1
a1234 1
	  if (sgot->_raw_size >= 0x1000
d1364 1
a1364 1
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
d1658 2
a1659 2
      if (s->_raw_size == 0)
	s->_raw_size = PLT_HEADER_SIZE;
d1662 1
a1662 1
      h->plt.offset = s->_raw_size / PLT_ENTRY_SIZE;
d1677 1
a1677 1
      s->_raw_size += PLT_ENTRY_SIZE;
d1684 1
a1684 1
      s->_raw_size += sizeof (Elf64_External_Rela);
d1688 1
a1688 1
      if (s->_raw_size >= (bfd_vma)1 << 32)
d1742 1
a1742 1
      srel->_raw_size += sizeof (Elf64_External_Rela);
d1754 1
a1754 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d1763 1
a1763 1
  h->root.u.def.value = s->_raw_size;
d1766 1
a1766 1
  s->_raw_size += h->size;
d1792 1
a1792 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1805 1
a1805 1
	s->_raw_size = 0;
d1828 1
a1828 1
	  if (s->_raw_size == 0)
d1867 2
a1868 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d2521 1
a2521 1
	      && rel->r_offset + 4 < input_section->_raw_size)
d2728 1
a2728 1
	  bfd_vma max = splt->_raw_size / PLT_ENTRY_SIZE;
d2861 1
a2861 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2901 1
a2901 6
		    {
		      if (s->_cooked_size != 0)
			dyn.d_un.d_val = s->_cooked_size;
		      else
			dyn.d_un.d_val = s->_raw_size;
		    }
d2908 1
a2908 1
      if (splt->_raw_size > 0)
d2910 1
a2910 1
			       (int) (splt->_raw_size / PLT_ENTRY_SIZE));
d2920 1
a2920 1
  if (sgot->_raw_size > 0)
@


1.90
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d3115 1
a3115 1
			 const arelent *rel)
@


1.89
log
@bfd/
	* elf32-sparc.c (elf32_sparc_relocate_section): Handle
	relocs against hidden/protected undefweak symbols properly.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
gas/testsuite/
	* gas/cfi/cfi-sparc64-1.d: Update.
ld/testsuite/
	* ld-elfvsb/elfvsb.exp: XFAIL some tests on sparc64.
	* ld-shared/shared.exp: Likewise.
@
text
@d3110 18
d3227 2
@


1.88
log
@	* elf64-sparc.c (sparc64_elf_check_relocs): Fix thinko last change.
@
text
@d2216 7
@


1.87
log
@	* elf32-sparc.c (elf32_sparc_relocate_section): Don't abort
	when statically linking PIC code.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2030 3
a2032 2
  sgot = sreloc = NULL;
  splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.86
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2030 2
a2031 1
  sgot = splt = sreloc = NULL;
d2413 1
a2413 1
	  if (h->plt.offset == (bfd_vma) -1)
a2418 6
	    }

	  if (splt == NULL)
	    {
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
@


1.85
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d1181 1
a1181 1
		  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d1264 1
a1264 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
a1991 11
/* This is the condition under which finish_dynamic_symbol will be called
   from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol
   routine, we'll need to do something about initializing any .plt and
   .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H)			\
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d2319 1
a2319 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
@


1.84
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d64 1
a64 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d1388 1
a1388 1
     const Elf_Internal_Sym *sym;
@


1.83
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d3 1
a3 1
   2003 Free Software Foundation, Inc.
d1879 1
a1879 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.82
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d2082 4
a2085 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.82.6.1
log
@Merge from mainline
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d64 1
a64 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1181 1
a1181 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1264 1
a1264 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1388 1
a1388 1
     Elf_Internal_Sym *sym;
d1879 1
a1879 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1992 11
d2082 4
a2085 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2330 1
a2330 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
@


1.82.6.2
log
@	PR 48.
	* elf32-sparc.c (elf32_sparc_relocate_section): Don't abort
	when statically linking PIC code.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@a2030 2
  if (dynobj != NULL)
    splt = bfd_get_section_by_name (dynobj, ".plt");
d2412 1
a2412 1
	  if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d2418 6
@


1.82.6.3
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from STABS debugging sections again.
@
text
@d2638 1
a2638 1
	       overflows in this case and also for discarded entries.  */
d2640 2
a2641 6
		&& (((input_section->flags & SEC_DEBUGGING) != 0
		     && strcmp (bfd_section_name (input_bfd, input_section),
			       ".stab") == 0)
		    || _bfd_elf_section_offset (output_bfd, info,
						input_section,
						rel->r_offset) == (bfd_vma)-1))
@


1.82.8.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d64 1
a64 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1388 1
a1388 1
     Elf_Internal_Sym *sym;
d1879 1
a1879 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2082 4
a2085 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.82.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1181 1
a1181 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1264 1
a1264 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1992 11
d2330 1
a2330 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
@


1.82.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d481 1
a481 1
      if (asect->size == 0)
d812 1
a812 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1176 1
a1176 1
	      h->got.offset = sgot->size;
d1185 1
a1185 1
	      srelgot->size += sizeof (Elf64_External_Rela);
d1210 1
a1210 1
	      local_got_offsets[r_symndx] = sgot->size;
d1217 1
a1217 1
		  srelgot->size += sizeof (Elf64_External_Rela);
d1221 1
a1221 1
	  sgot->size += 8;
d1232 1
a1232 1
	  if (sgot->size >= 0x1000
d1362 1
a1362 1
	      sreloc->size += sizeof (Elf64_External_Rela);
d1371 3
a1373 2
	  (*_bfd_error_handler) (_("%B: check_relocs: unhandled reloc type %d"),
				abfd, ELF64_R_TYPE_ID (rel->r_info));
d1408 2
a1409 2
            (_("%B: Only registers %%g[2367] can be declared using STT_REGISTER"),
             abfd);
d1428 4
a1431 4
            (_("Register %%g%d used incompatibly: %s in %B, previously %s in %B"),
             abfd, p->abfd, (int) sym->st_value,
             **namep ? *namep : "#scratch",
             *p->name ? p->name : "#scratch");
d1451 3
a1453 2
		    (_("Symbol `%s' has differing types: REGISTER in %B, previously %s in %B"),
		     abfd, p->abfd, *namep, stt_types[type]);
d1497 3
a1499 2
	      (_("Symbol `%s' has differing types: %s in %B, previously REGISTER in %B"),
	       abfd, p->abfd, *namep, stt_types[type]);
d1656 2
a1657 2
      if (s->size == 0)
	s->size = PLT_HEADER_SIZE;
d1660 1
a1660 1
      h->plt.offset = s->size / PLT_ENTRY_SIZE;
d1675 1
a1675 1
      s->size += PLT_ENTRY_SIZE;
d1682 1
a1682 1
      s->size += sizeof (Elf64_External_Rela);
d1686 1
a1686 1
      if (s->size >= (bfd_vma)1 << 32)
d1740 1
a1740 1
      srel->size += sizeof (Elf64_External_Rela);
d1752 2
a1753 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1762 1
a1762 1
  h->root.u.def.value = s->size;
d1765 1
a1765 1
  s->size += h->size;
d1791 1
a1791 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1804 1
a1804 1
	s->size = 0;
d1827 1
a1827 1
	  if (s->size == 0)
d1866 2
a1867 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
a2030 2
  if (dynobj != NULL)
    splt = bfd_get_section_by_name (dynobj, ".plt");
a2213 7
		/* FIXME: Dynamic reloc handling really needs to be rewritten.  */
		if (!skip
		    && h != NULL
		    && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		    && h->root.type == bfd_link_hash_undefweak)
		  skip = TRUE, relocate = TRUE;

d2270 2
a2271 2
				  (_("%B: probably compiled without -fPIC?"),
				   input_bfd);
d2412 1
a2412 1
	  if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d2420 6
d2517 1
a2517 1
	      && rel->r_offset + 4 < input_section->size)
d2620 3
a2622 2
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd, input_section,
d2724 1
a2724 1
	  bfd_vma max = splt->size / PLT_ENTRY_SIZE;
d2857 1
a2857 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d2897 6
a2902 1
		    dyn.d_un.d_val = s->size;
d2909 1
a2909 1
      if (splt->size > 0)
d2911 1
a2911 1
			       (int) (splt->size / PLT_ENTRY_SIZE));
d2921 1
a2921 1
  if (sgot->size > 0)
d3009 2
a3010 2
		(_("%B: linking UltraSPARC specific with HAL specific code"),
		 ibfd);
d3028 2
a3029 2
            (_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
             ibfd, (long) new_flags, (long) old_flags);
a3106 18
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
sparc64_elf_plt_sym_val (bfd_vma i, const asection *plt,
			 const arelent *rel ATTRIBUTE_UNUSED)
{
  bfd_vma j;

  i += PLT_HEADER_SIZE / PLT_ENTRY_SIZE;
  if (i < LARGE_PLT_THRESHOLD)
    return plt->vma + i * PLT_ENTRY_SIZE;

  j = (i - LARGE_PLT_THRESHOLD) % 160;
  i -= j;
  return plt->vma + i * PLT_ENTRY_SIZE + j * 4 * 6;
}

a3205 2
#define elf_backend_plt_sym_val	\
  sparc64_elf_plt_sym_val
@


1.82.8.4
log
@Merge from mainline.
@
text
@d1268 1
a1268 1
	  h->needs_plt = 1;
d1615 8
a1622 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d1632 1
a1632 1
      || h->needs_plt
d1645 1
a1645 1
	  BFD_ASSERT (h->needs_plt);
d1665 1
a1665 1
	  && !h->def_regular)
d1695 1
a1695 1
  if (h->u.weakdef != NULL)
d1697 4
a1700 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1738 1
a1738 1
      h->needs_copy = 1;
d2225 2
a2226 1
			     || !h->def_regular))
d2328 2
a2329 2
			  || h->forced_local)
		      && h->def_regular))
d2617 1
a2617 1
	       && h->def_dynamic))
d2739 1
a2739 1
      if (!h->def_regular)
d2748 2
a2749 1
	  if (!h->ref_regular_nonweak)
d2778 1
a2778 1
	  && h->def_regular)
d2799 1
a2799 1
  if (h->needs_copy)
@


1.81
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d68 2
a69 1
	   bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *, asection *)));
d1515 2
a1516 1
       PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *));
d1562 2
a1563 1
			 ? bfd_abs_section_ptr : bfd_und_section_ptr))
@


1.80
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1505 1
a1505 1
/* This function takes care of emiting STT_REGISTER symbols
@


1.79
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d2073 1
a2073 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d2250 2
a2251 10
			else if (h == NULL)
			  sec = local_sections[r_symndx];
			else
			  {
			    BFD_ASSERT (h->root.type == bfd_link_hash_defined
					|| (h->root.type
					    == bfd_link_hash_defweak));
			    sec = h->root.u.def.section;
			  }
			if (sec != NULL && bfd_is_abs_section (sec))
@


1.78
log
@Better handking for unresolved symbols
@
text
@a3238 1
#define elf_backend_plt_header_size PLT_HEADER_SIZE
@


1.77
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d2077 1
a2077 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2079 5
a2083 3
	  relocation = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
a2084 27
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;

@


1.76
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2109 1
a2109 1
		      (!info->shared || info->no_undefined
@


1.75
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d521 1
a521 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
@


1.74
log
@Correct spelling of "relocatable".
@
text
@d2100 1
a2100 1
	  else if (info->shared
@


1.73
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore R_SPARC_DISP32
	reloc overflow on discarded eh_frame entries.
@
text
@d1104 1
a1104 1
  if (info->relocateable || !(sec->flags & SEC_ALLOC))
d2025 1
a2025 1
  if (info->relocateable)
@


1.72
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d2687 1
a2687 1
	    if (r_type == R_SPARC_32
@


1.71
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1784 1
a1784 1
      if (! info->shared)
d1883 1
a1883 1
      if (!info->shared)
@


1.70
log
@	* elf64-sparc.c (struct sparc64_elf_section_data): Add reloc_count
	field.
	(canon_reloc_count): Define.
	(sparc64_elf_slurp_one_reloc_table, sparc64_elf_slurp_reloc_table,
	sparc64_elf_canonicalize_dynamic_reloc): Use it instead of
	reloc_count.
	(sparc64_elf_canonicalize_reloc): New routine.
	(bfd_elf64_canonicalize_reloc): Define.
@
text
@d3173 1
a3173 1
  8,		/* file_align.  */
@


1.70.10.1
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore R_SPARC_DISP32
	reloc overflow on discarded eh_frame entries.
@
text
@d2687 1
a2687 1
	    if ((r_type == R_SPARC_32 || r_type == R_SPARC_DISP32)
@


1.70.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d3173 1
a3173 1
  3,		/* log_file_align.  */
@


1.69
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d99 2
d316 11
d377 1
a377 1
  relents = asect->relocation + asect->reloc_count;
d432 1
a432 1
  asect->reloc_count += relent - relents;
d494 3
a496 2
  /* The sparc64_elf_slurp_one_reloc_table routine increments reloc_count.  */
  asect->reloc_count = 0;
d510 26
d571 1
a571 1
	  count = s->reloc_count;
a1960 9
struct sparc64_elf_section_data
{
  struct bfd_elf_section_data elf;
  unsigned int do_relax;
};

#define sec_do_relax(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->do_relax

d3211 2
@


1.68
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a2069 1
		   && (!info->symbolic || info->allow_shlib_undefined)
a2084 1

d2616 1
a2616 1
	  /* FALLTHROUGH */
a2820 1

d2923 2
a2924 4
	{
	  sparc64_elf_build_plt (output_bfd, splt->contents,
				 (int) (splt->_raw_size / PLT_ENTRY_SIZE));
	}
d3135 2
a3136 2
  4,		/* hash-table entry size */
  /* internal relocations per external relocations.
d3141 2
a3142 2
  64,		/* arch_size */
  8,		/* file_align */
@


1.67
log
@bfd/
	* elf32-sparc.c (_bfd_sparc_elf_howto_table): Add TLS relocs.
	(elf32_sparc_rev32_howto): New variable.
	(sparc_reloc_map): Add TLS relocs.
	(elf32_sparc_reloc_type_lookup, elf32_sparc_info_to_howto):
	Handle REV32.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc, elf32_sparc_mkobject):
	New functions.
	(struct elf32_sparc_dyn_relocs, struct elf32_sparc_link_hash_entry,
	struct elf32_sparc_link_hash_table):
	New structures.
	(elf32_sparc_tdata, elf32_sparc_local_got_tls_type,
	elf32_sparc_hash_table): Define.
	(link_hash_newfunc, elf32_sparc_link_hash_table_create,
	create_got_section, elf32_sparc_create_dynamic_sections,
	elf32_sparc_copy_indirect_symbol, elf32_sparc_tls_transition): New
	functions.
	(elf32_sparc_check_relocs): Handle TLS relocs.  Add dynamic reloc
	reference counting.
	(elf32_sparc_gc_sweep_hook): Likewise.
	(elf32_sparc_adjust_dynamic_symbol): Likewise.
	(elf32_sparc_size_dynamic_sections): Likewise.
	(elf32_sparc_relocate_section): Likewise.
	(allocate_dynrelocs, readonly_dynrelocs, dtpoff_base, tpoff):
	New functions.
	(elf32_sparc_object_p): Allocate backend private object data.
	(bfd_elf32_bfd_link_hash_table_create,
	elf_backend_copy_indirect_symbol, bfd_elf32_mkobject,
	elf_backend_can_refcount): Define.
	(elf_backend_create_dynamic_sections): Define to
	elf32_sparc_create_dynamic_sections.
	* reloc.c: Add SPARC TLS relocs.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf64-sparc.c (sparc64_elf_howto_table): Add TLS relocs.
	(sparc_reloc_map): Likewise.
gas/
	* config/tc-sparc.c (sparc_ip): Handle TLS % operators.
	(tc_gen_reloc): Handle TLS relocs.
	(sparc_cons, cons_fix_new_sparc): Handle %r_tls_dtpoff.
	* config/tc-sparc.h (tc_fix_adjustable): Don't adjust TLS
	relocs.
	* config/obj-elf.c (obj_elf_section_word): Handle tls.
	(obj_elf_type): Handle tls_object.
include/
	* elf/sparc.h: Add TLS relocs.  Move R_SPARC_REV32 to 252.
ld/testsuite/
	* ld-sparc/sparc.exp: New.
	* ld-sparc/tlsg32.s: New test.
	* ld-sparc/tlsg32.sd: Likewise.
	* ld-sparc/tlsg64.s: Likewise.
	* ld-sparc/tlsg64.sd: Likewise.
	* ld-sparc/tlslib.s: Likewise.
	* ld-sparc/tlsnopic.s: Likewise.
	* ld-sparc/tlspic.s: Likewise.
	* ld-sparc/tlssunbin32.dd: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunbin32.s: Likewise.
	* ld-sparc/tlssunbin32.sd: Likewise.
	* ld-sparc/tlssunbin32.td: Likewise.
	* ld-sparc/tlssunbin64.dd: Likewise.
	* ld-sparc/tlssunbin64.rd: Likewise.
	* ld-sparc/tlssunbin64.s: Likewise.
	* ld-sparc/tlssunbin64.sd: Likewise.
	* ld-sparc/tlssunbin64.td: Likewise.
	* ld-sparc/tlssunbinpic32.s: Likewise.
	* ld-sparc/tlssunbinpic64.s: Likewise.
	* ld-sparc/tlssunnopic32.dd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunnopic32.s: Likewise.
	* ld-sparc/tlssunnopic32.sd: Likewise.
	* ld-sparc/tlssunnopic64.dd: Likewise.
	* ld-sparc/tlssunnopic64.rd: Likewise.
	* ld-sparc/tlssunnopic64.s: Likewise.
	* ld-sparc/tlssunnopic64.sd: Likewise.
	* ld-sparc/tlssunpic32.dd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-sparc/tlssunpic32.s: Likewise.
	* ld-sparc/tlssunpic32.sd: Likewise.
	* ld-sparc/tlssunpic32.td: Likewise.
	* ld-sparc/tlssunpic64.dd: Likewise.
	* ld-sparc/tlssunpic64.rd: Likewise.
	* ld-sparc/tlssunpic64.s: Likewise.
	* ld-sparc/tlssunpic64.sd: Likewise.
	* ld-sparc/tlssunpic64.td: Likewise.
@
text
@d1928 1
a1928 1
  ((struct sparc64_elf_section_data *) (sec)->used_by_bfd)->do_relax
@


1.66
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d176 25
a200 1
  HOWTO(R_SPARC_UA16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      FALSE,0,0x0000ffff,TRUE)
d254 24
@


1.65
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d80 2
d1873 24
a1896 2
#define SET_SEC_DO_RELAX(section) do { elf_section_data(section)->tdata = (void *)1; } while (0)
#define SEC_DO_RELAX(section) (elf_section_data(section)->tdata == (void *)1)
d1906 1
a1906 1
  SET_SEC_DO_RELAX (section);
d2483 1
a2483 1
	  if (SEC_DO_RELAX (input_section)
d3143 2
@


1.64
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d54 1
a54 1
static boolean sparc64_elf_check_relocs
d57 1
a57 1
static boolean sparc64_elf_adjust_dynamic_symbol
d59 1
a59 1
static boolean sparc64_elf_size_dynamic_sections
d63 1
a63 1
static boolean sparc64_elf_add_symbol_hook
d66 1
a66 1
static boolean sparc64_elf_output_arch_syms
d68 1
a68 1
	   boolean (*) (PTR, const char *, Elf_Internal_Sym *, asection *)));
d72 1
a72 1
static boolean sparc64_elf_merge_private_bfd_data
d75 1
a75 1
static boolean sparc64_elf_fake_sections
d80 3
a82 3
static boolean sparc64_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean sparc64_elf_relocate_section
d85 1
a85 1
static boolean sparc64_elf_finish_dynamic_symbol
d88 1
a88 1
static boolean sparc64_elf_finish_dynamic_sections
d90 1
a90 1
static boolean sparc64_elf_object_p PARAMS ((bfd *));
d93 4
a96 4
static boolean sparc64_elf_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, asymbol **, boolean));
static boolean sparc64_elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
d116 24
a139 24
  HOWTO(R_SPARC_NONE,      0,0, 0,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_NONE",    false,0,0x00000000,true),
  HOWTO(R_SPARC_8,         0,0, 8,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_8",       false,0,0x000000ff,true),
  HOWTO(R_SPARC_16,        0,1,16,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_16",      false,0,0x0000ffff,true),
  HOWTO(R_SPARC_32,        0,2,32,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_32",      false,0,0xffffffff,true),
  HOWTO(R_SPARC_DISP8,     0,0, 8,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP8",   false,0,0x000000ff,true),
  HOWTO(R_SPARC_DISP16,    0,1,16,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP16",  false,0,0x0000ffff,true),
  HOWTO(R_SPARC_DISP32,    0,2,32,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP32",  false,0,0xffffffff,true),
  HOWTO(R_SPARC_WDISP30,   2,2,30,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP30", false,0,0x3fffffff,true),
  HOWTO(R_SPARC_WDISP22,   2,2,22,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP22", false,0,0x003fffff,true),
  HOWTO(R_SPARC_HI22,     10,2,22,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HI22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_22,        0,2,22,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_22",      false,0,0x003fffff,true),
  HOWTO(R_SPARC_13,        0,2,13,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_13",      false,0,0x00001fff,true),
  HOWTO(R_SPARC_LO10,      0,2,10,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LO10",    false,0,0x000003ff,true),
  HOWTO(R_SPARC_GOT10,     0,2,10,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT10",   false,0,0x000003ff,true),
  HOWTO(R_SPARC_GOT13,     0,2,13,false,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_GOT13",   false,0,0x00001fff,true),
  HOWTO(R_SPARC_GOT22,    10,2,22,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT22",   false,0,0x003fffff,true),
  HOWTO(R_SPARC_PC10,      0,2,10,true, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC10",    false,0,0x000003ff,true),
  HOWTO(R_SPARC_PC22,     10,2,22,true, 0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PC22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_WPLT30,    2,2,30,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WPLT30",  false,0,0x3fffffff,true),
  HOWTO(R_SPARC_COPY,      0,0,00,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_COPY",    false,0,0x00000000,true),
  HOWTO(R_SPARC_GLOB_DAT,  0,0,00,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GLOB_DAT",false,0,0x00000000,true),
  HOWTO(R_SPARC_JMP_SLOT,  0,0,00,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_JMP_SLOT",false,0,0x00000000,true),
  HOWTO(R_SPARC_RELATIVE,  0,0,00,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_RELATIVE",false,0,0x00000000,true),
  HOWTO(R_SPARC_UA32,      0,2,32,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA32",    false,0,0xffffffff,true),
d141 1
a141 1
  HOWTO(R_SPARC_PLT32,     0,2,32,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT32",   false,0,0xffffffff,true),
d143 5
a147 5
  HOWTO(R_SPARC_HIPLT22,   0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_HIPLT22",  false,0,0x00000000,true),
  HOWTO(R_SPARC_LOPLT10,   0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_LOPLT10",  false,0,0x00000000,true),
  HOWTO(R_SPARC_PCPLT32,   0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT32",  false,0,0x00000000,true),
  HOWTO(R_SPARC_PCPLT22,   0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT22",  false,0,0x00000000,true),
  HOWTO(R_SPARC_PCPLT10,   0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT10",  false,0,0x00000000,true),
d149 26
a174 26
  HOWTO(R_SPARC_10,        0,2,10,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_10",      false,0,0x000003ff,true),
  HOWTO(R_SPARC_11,        0,2,11,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_11",      false,0,0x000007ff,true),
  HOWTO(R_SPARC_64,        0,4,64,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_64",      false,0,MINUS_ONE, true),
  HOWTO(R_SPARC_OLO10,     0,2,13,false,0,complain_overflow_signed,  sparc_elf_notsup_reloc, "R_SPARC_OLO10",   false,0,0x00001fff,true),
  HOWTO(R_SPARC_HH22,     42,2,22,false,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_HH22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_HM10,     32,2,10,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HM10",    false,0,0x000003ff,true),
  HOWTO(R_SPARC_LM22,     10,2,22,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LM22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_PC_HH22,  42,2,22,true, 0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_PC_HH22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_PC_HM10,  32,2,10,true, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_HM10",    false,0,0x000003ff,true),
  HOWTO(R_SPARC_PC_LM22,  10,2,22,true, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_LM22",    false,0,0x003fffff,true),
  HOWTO(R_SPARC_WDISP16,   2,2,16,true, 0,complain_overflow_signed,  sparc_elf_wdisp16_reloc,"R_SPARC_WDISP16", false,0,0x00000000,true),
  HOWTO(R_SPARC_WDISP19,   2,2,19,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP19", false,0,0x0007ffff,true),
  HOWTO(R_SPARC_UNUSED_42, 0,0, 0,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_UNUSED_42",false,0,0x00000000,true),
  HOWTO(R_SPARC_7,         0,2, 7,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_7",       false,0,0x0000007f,true),
  HOWTO(R_SPARC_5,         0,2, 5,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_5",       false,0,0x0000001f,true),
  HOWTO(R_SPARC_6,         0,2, 6,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_6",       false,0,0x0000003f,true),
  HOWTO(R_SPARC_DISP64,    0,4,64,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP64",  false,0,MINUS_ONE, true),
  HOWTO(R_SPARC_PLT64,     0,4,64,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT64",   false,0,MINUS_ONE, true),
  HOWTO(R_SPARC_HIX22,     0,4, 0,false,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,  "R_SPARC_HIX22",   false,0,MINUS_ONE, false),
  HOWTO(R_SPARC_LOX10,     0,4, 0,false,0,complain_overflow_dont,    sparc_elf_lox10_reloc,  "R_SPARC_LOX10",   false,0,MINUS_ONE, false),
  HOWTO(R_SPARC_H44,      22,2,22,false,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_H44",     false,0,0x003fffff,false),
  HOWTO(R_SPARC_M44,      12,2,10,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_M44",     false,0,0x000003ff,false),
  HOWTO(R_SPARC_L44,       0,2,13,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_L44",     false,0,0x00000fff,false),
  HOWTO(R_SPARC_REGISTER,  0,4, 0,false,0,complain_overflow_bitfield,sparc_elf_notsup_reloc, "R_SPARC_REGISTER",false,0,MINUS_ONE, false),
  HOWTO(R_SPARC_UA64,        0,4,64,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA64",      false,0,MINUS_ONE, true),
  HOWTO(R_SPARC_UA16,        0,1,16,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      false,0,0x0000ffff,true)
d288 1
a288 1
static boolean
d294 1
a294 1
     boolean dynamic;
d374 1
a374 1
  return true;
d379 1
a379 1
  return false;
d384 1
a384 1
static boolean
d389 1
a389 1
     boolean dynamic;
d397 1
a397 1
    return true;
d403 1
a403 1
	return true;
d418 1
a418 1
	return true;
d429 1
a429 1
    return false;
d436 1
a436 1
    return false;
d441 1
a441 1
    return false;
d443 1
a443 1
  return true;
d479 1
a479 1
	  if (! sparc64_elf_slurp_reloc_table (abfd, s, syms, true))
d502 1
a502 1
  boolean *failedp = (boolean *) data;
d553 1
a553 1
      *failedp = true;
d593 1
a593 1
	      *failedp = true;
d603 1
a603 1
	  *failedp = true;
d717 1
a717 1
  /* This works because partial_inplace is false.  */
d997 1
a997 1
static boolean
d1015 1
a1015 1
    return true;
d1050 1
a1050 1
		return false;
d1074 1
a1074 1
		    return false;
d1091 1
a1091 1
		    return false;
d1109 1
a1109 1
		    return false;
d1167 1
a1167 1
	      return false;
d1174 1
a1174 1
		return false;
d1246 1
a1246 1
		    return false;
d1265 1
a1265 1
			return false;
d1283 1
a1283 1
	  return false;
d1287 1
a1287 1
  return true;
d1293 1
a1293 1
static boolean
d1319 1
a1319 1
	  return false;
d1329 1
a1329 1
	  return true;
d1341 1
a1341 1
	  return false;
d1351 1
a1351 1
		bfd_link_hash_lookup (info->hash, *namep, false, false, false);
d1363 1
a1363 1
		  return false;
d1369 1
a1369 1
		return false;
d1389 1
a1389 1
      return true;
d1409 1
a1409 1
	    return false;
d1412 1
a1412 1
  return true;
d1418 1
a1418 1
static boolean
d1423 2
a1424 2
     boolean (*func) PARAMS ((PTR, const char *,
			      Elf_Internal_Sym *, asection *));
d1452 1
a1452 1
    return true;
d1460 1
a1460 1
				false, false) == NULL)
d1471 1
a1471 1
	  return false;
d1474 1
a1474 1
  return true;
d1512 1
a1512 1
static boolean
d1556 1
a1556 1
	  return true;
d1596 1
a1596 1
	  return false;
d1599 1
a1599 1
      return true;
d1611 1
a1611 1
      return true;
d1622 1
a1622 1
    return true;
d1664 1
a1664 1
	return false;
d1674 1
a1674 1
  return true;
d1679 1
a1679 1
static boolean
d1686 1
a1686 1
  boolean relplt;
d1717 1
a1717 1
  relplt = false;
d1721 1
a1721 1
      boolean strip;
d1730 1
a1730 1
      strip = false;
d1745 1
a1745 1
	      strip = true;
d1750 1
a1750 1
		relplt = true;
d1775 1
a1775 1
	return false;
d1796 1
a1796 1
	    return false;
d1805 1
a1805 1
	    return false;
d1811 1
a1811 1
	return false;
d1816 1
a1816 1
	    return false;
d1830 1
a1830 1
	      return false;
d1835 1
a1835 1
	      return false;
d1844 1
a1844 1
		= _bfd_elf_strtab_add (dynstr, app_regs[reg].name, false);
d1868 1
a1868 1
  return true;
d1874 1
a1874 1
static boolean
d1879 1
a1879 1
     boolean *again;
d1881 1
a1881 1
  *again = false;
d1883 1
a1883 1
  return true;
d1899 1
a1899 1
static boolean
d1923 1
a1923 1
    return true;
d1949 2
a1950 2
      boolean is_plt = false;
      boolean unresolved_reloc;
d1956 1
a1956 1
	  return false;
d1965 1
a1965 1
      unresolved_reloc = false;
d1989 1
a1989 1
		unresolved_reloc = true;
d2009 1
a2009 1
		return false;
d2077 1
a2077 1
		boolean skip, relocate;
d2088 1
a2088 1
		      return false;
d2099 2
a2100 2
		skip = false;
		relocate = false;
d2106 1
a2106 1
		  skip = true;
d2108 1
a2108 1
		  skip = true, relocate = true;
d2145 1
a2145 1
		      skip = true, relocate = true;
d2191 1
a2191 1
			    return false;
d2216 1
a2216 1
				return false;
d2256 1
a2256 1
	      boolean dyn;
d2291 1
a2291 1
		unresolved_reloc = false;
d2372 1
a2372 1
	  unresolved_reloc = false;
d2378 1
a2378 1
	      is_plt = true;
d2613 1
a2613 1
		  return false;
d2620 1
a2620 1
	      return false;
d2626 1
a2626 1
  return true;
d2632 1
a2632 1
static boolean
d2773 1
a2773 1
  return true;
d2778 1
a2778 1
static boolean
d2806 1
a2806 1
	  boolean size;
d2812 3
a2814 3
	    case DT_PLTGOT:   name = ".plt"; size = false; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = true; break;
	    case DT_JMPREL:   name = ".rela.plt"; size = false; break;
d2821 1
a2821 1
		    return false;
d2826 1
a2826 1
	    default:	      name = NULL; size = false; break;
d2879 1
a2879 1
  return true;
d2904 1
a2904 1
static boolean
d2909 1
a2909 1
  boolean error;
d2915 1
a2915 1
    return true;
d2922 1
a2922 1
      elf_flags_init (obfd) = true;
d2931 1
a2931 1
      error = false;
d2953 1
a2953 1
	      error = true;
d2972 1
a2972 1
          error = true;
d2983 1
a2983 1
          return false;
d2986 1
a2986 1
  return true;
d2991 1
a2991 1
static boolean
d3006 2
a3007 2
  
  return true;
d3040 1
a3040 1
static boolean
@


1.63
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't zero
	relocs for discarded FDEs.  Remove dead code.
	(_bfd_elf_write_section_eh_frame_hdr): Remove dead code.
	* elflink.h (elf_bfd_discard_info): Don't save edited relocs.
	Tidy conditions under which stabs are edited.  Formatting.
	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from discarded relocs.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Add reloc output
	section adjustments after testing magic values.
@
text
@d76 1
a76 1
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));
d258 1
a258 1
     Elf64_Internal_Rela *dst;
d326 1
a326 1
      bfd_elf64_swap_reloca_in (abfd, (Elf64_External_Rela *) native_relocs, &rela);
d629 1
a629 1
      bfd_elf64_swap_reloca_out (abfd, &dst_rela, src_rela);
d2076 1
d2228 3
a2230 5
		bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					   (((Elf64_External_Rela *)
					     sreloc->contents)
					    + sreloc->reloc_count));
		++sreloc->reloc_count;
d2310 1
a2310 1
		      asection *srelgot;
d2312 1
d2324 2
a2325 2
		      srelgot = bfd_get_section_by_name(dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);
d2332 3
a2334 5
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 (((Elf64_External_Rela *)
						   srelgot->contents)
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
d2648 1
d2680 3
a2682 3
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + (h->plt.offset - 4)));
d2704 1
d2739 3
a2741 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
d2748 1
d2763 2
a2764 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d2994 1
a2994 1
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d3087 4
a3090 4
  NULL,
  NULL,
  NULL,
  NULL
@


1.62
log
@	* elf64-sparc.c (sparc64_elf_adjust_dynamic_symbol): Correct
	references to large plt symbols.
@
text
@d2587 1
a2587 1
	       overflows in this case.  */
d2589 2
a2590 3
		&& (input_section->flags & SEC_DEBUGGING) != 0
		&& strcmp (bfd_section_name (input_bfd, input_section),
			   ".stab") == 0)
@


1.61
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Adjust addend of
	dynamic relocs against section symbols for the output section vma.
@
text
@d1566 3
d1578 1
a1578 1
	  h->root.u.def.value = s->_raw_size;
a1579 3

      /* To simplify matters later, just store the plt index here.  */
      h->plt.offset = s->_raw_size / PLT_ENTRY_SIZE;
@


1.60
log
@	* elf32-sparc.c (elf32_sparc_relocate_section): Put R_SPARC_RELATIVE
	addend into r_addend, not *r_offset.
	(elf32_sparc_finish_dynamic_symbol): Likewise.
	* elf64-sparc.c (sparc64_elf_finish_dynamic_symbol): Clear xword at
	R_SPARC_RELATIVE's r_offset.
@
text
@d2167 1
d2169 1
a2169 4
		      {
			outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
			outrel.r_addend = relocation + rel->r_addend;
		      }
d2199 7
a2223 1
			outrel.r_addend = relocation + rel->r_addend;
@


1.60.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d54 1
a54 1
static bfd_boolean sparc64_elf_check_relocs
d57 1
a57 1
static bfd_boolean sparc64_elf_adjust_dynamic_symbol
d59 1
a59 1
static bfd_boolean sparc64_elf_size_dynamic_sections
d63 1
a63 1
static bfd_boolean sparc64_elf_add_symbol_hook
d66 1
a66 1
static bfd_boolean sparc64_elf_output_arch_syms
d68 1
a68 2
	   bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *,
			    asection *, struct elf_link_hash_entry *)));
d72 1
a72 1
static bfd_boolean sparc64_elf_merge_private_bfd_data
d75 2
a76 2
static bfd_boolean sparc64_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d80 3
a82 5
static bfd_boolean sparc64_elf_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean sparc64_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sparc64_elf_relocate_section
d85 1
a85 1
static bfd_boolean sparc64_elf_finish_dynamic_symbol
d88 1
a88 1
static bfd_boolean sparc64_elf_finish_dynamic_sections
d90 1
a90 1
static bfd_boolean sparc64_elf_object_p PARAMS ((bfd *));
d93 4
a96 6
static bfd_boolean sparc64_elf_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, asymbol **, bfd_boolean));
static bfd_boolean sparc64_elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long sparc64_elf_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
d116 24
a139 24
  HOWTO(R_SPARC_NONE,      0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_8,         0,0, 8,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_8",       FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_32,        0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_32",      FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_DISP8,     0,0, 8,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP8",   FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_DISP16,    0,1,16,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP16",  FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_DISP32,    0,2,32,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP32",  FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_WDISP30,   2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP30", FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_WDISP22,   2,2,22,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP22", FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HI22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HI22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_22,        0,2,22,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_22",      FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_13,        0,2,13,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_13",      FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_LO10,      0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LO10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT10,     0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT10",   FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT13,     0,2,13,FALSE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_GOT13",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_GOT22,    10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT22",   FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC10,      0,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC22,     10,2,22,TRUE, 0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PC22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WPLT30,    2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WPLT30",  FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_COPY,      0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_COPY",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_GLOB_DAT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GLOB_DAT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_JMP_SLOT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_JMP_SLOT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_RELATIVE,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_RELATIVE",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_UA32,      0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA32",    FALSE,0,0xffffffff,TRUE),
d141 1
a141 1
  HOWTO(R_SPARC_PLT32,     0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT32",   FALSE,0,0xffffffff,TRUE),
d143 5
a147 5
  HOWTO(R_SPARC_HIPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_HIPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_LOPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_LOPLT10",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT32,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT32",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT10",  FALSE,0,0x00000000,TRUE),
d149 26
a174 50
  HOWTO(R_SPARC_10,        0,2,10,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_10",      FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_11,        0,2,11,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_11",      FALSE,0,0x000007ff,TRUE),
  HOWTO(R_SPARC_64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_OLO10,     0,2,13,FALSE,0,complain_overflow_signed,  sparc_elf_notsup_reloc, "R_SPARC_OLO10",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_HH22,     42,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HM10,     32,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_LM22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HH22,  42,2,22,TRUE, 0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_PC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HM10,  32,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC_LM22,  10,2,22,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WDISP16,   2,2,16,TRUE, 0,complain_overflow_signed,  sparc_elf_wdisp16_reloc,"R_SPARC_WDISP16", FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_WDISP19,   2,2,19,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP19", FALSE,0,0x0007ffff,TRUE),
  HOWTO(R_SPARC_UNUSED_42, 0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_UNUSED_42",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_7,         0,2, 7,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_7",       FALSE,0,0x0000007f,TRUE),
  HOWTO(R_SPARC_5,         0,2, 5,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_5",       FALSE,0,0x0000001f,TRUE),
  HOWTO(R_SPARC_6,         0,2, 6,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_6",       FALSE,0,0x0000003f,TRUE),
  HOWTO(R_SPARC_DISP64,    0,4,64,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP64",  FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_PLT64,     0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT64",   FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_HIX22,     0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,  "R_SPARC_HIX22",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_LOX10,     0,4, 0,FALSE,0,complain_overflow_dont,    sparc_elf_lox10_reloc,  "R_SPARC_LOX10",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_H44,      22,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_H44",     FALSE,0,0x003fffff,FALSE),
  HOWTO(R_SPARC_M44,      12,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_M44",     FALSE,0,0x000003ff,FALSE),
  HOWTO(R_SPARC_L44,       0,2,13,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_L44",     FALSE,0,0x00000fff,FALSE),
  HOWTO(R_SPARC_REGISTER,  0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_notsup_reloc, "R_SPARC_REGISTER",FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_UA64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_UA16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_GD_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_GD_CALL,2,2,30,TRUE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_HI22,10,2,22,FALSE,0,complain_overflow_dont, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_LO10,0,2,10,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LDM_CALL,2,2,30,TRUE,0,complain_overflow_signed, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDO_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,"R_SPARC_TLS_LDO_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_LOX10,0,2,0,FALSE,0,complain_overflow_dont,  sparc_elf_lox10_reloc,  "R_SPARC_TLS_LDO_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDO_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LD,0,0, 0,FALSE,0,complain_overflow_dont,     bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_LDX,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LDX",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LE_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc, "R_SPARC_TLS_LE_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LE_LOX10,0,2,0,FALSE,0,complain_overflow_dont,   sparc_elf_lox10_reloc,  "R_SPARC_TLS_LE_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_DTPMOD32,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPMOD64,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD64",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF32,0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF32",FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF64,0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF64",FALSE,0,MINUS_ONE,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF32,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF64,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF64",FALSE,0,0x00000000,TRUE)
a227 24
  { BFD_RELOC_SPARC_TLS_GD_HI22, R_SPARC_TLS_GD_HI22 },
  { BFD_RELOC_SPARC_TLS_GD_LO10, R_SPARC_TLS_GD_LO10 },
  { BFD_RELOC_SPARC_TLS_GD_ADD, R_SPARC_TLS_GD_ADD },
  { BFD_RELOC_SPARC_TLS_GD_CALL, R_SPARC_TLS_GD_CALL },
  { BFD_RELOC_SPARC_TLS_LDM_HI22, R_SPARC_TLS_LDM_HI22 },
  { BFD_RELOC_SPARC_TLS_LDM_LO10, R_SPARC_TLS_LDM_LO10 },
  { BFD_RELOC_SPARC_TLS_LDM_ADD, R_SPARC_TLS_LDM_ADD },
  { BFD_RELOC_SPARC_TLS_LDM_CALL, R_SPARC_TLS_LDM_CALL },
  { BFD_RELOC_SPARC_TLS_LDO_HIX22, R_SPARC_TLS_LDO_HIX22 },
  { BFD_RELOC_SPARC_TLS_LDO_LOX10, R_SPARC_TLS_LDO_LOX10 },
  { BFD_RELOC_SPARC_TLS_LDO_ADD, R_SPARC_TLS_LDO_ADD },
  { BFD_RELOC_SPARC_TLS_IE_HI22, R_SPARC_TLS_IE_HI22 },
  { BFD_RELOC_SPARC_TLS_IE_LO10, R_SPARC_TLS_IE_LO10 },
  { BFD_RELOC_SPARC_TLS_IE_LD, R_SPARC_TLS_IE_LD },
  { BFD_RELOC_SPARC_TLS_IE_LDX, R_SPARC_TLS_IE_LDX },
  { BFD_RELOC_SPARC_TLS_IE_ADD, R_SPARC_TLS_IE_ADD },
  { BFD_RELOC_SPARC_TLS_LE_HIX22, R_SPARC_TLS_LE_HIX22 },
  { BFD_RELOC_SPARC_TLS_LE_LOX10, R_SPARC_TLS_LE_LOX10 },
  { BFD_RELOC_SPARC_TLS_DTPMOD32, R_SPARC_TLS_DTPMOD32 },
  { BFD_RELOC_SPARC_TLS_DTPMOD64, R_SPARC_TLS_DTPMOD64 },
  { BFD_RELOC_SPARC_TLS_DTPOFF32, R_SPARC_TLS_DTPOFF32 },
  { BFD_RELOC_SPARC_TLS_DTPOFF64, R_SPARC_TLS_DTPOFF64 },
  { BFD_RELOC_SPARC_TLS_TPOFF32, R_SPARC_TLS_TPOFF32 },
  { BFD_RELOC_SPARC_TLS_TPOFF64, R_SPARC_TLS_TPOFF64 },
d258 1
a258 1
     Elf_Internal_Rela *dst;
a263 11
struct sparc64_elf_section_data
{
  struct bfd_elf_section_data elf;
  unsigned int do_relax, reloc_count;
};

#define sec_do_relax(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->do_relax
#define canon_reloc_count(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->reloc_count

d288 1
a288 1
static bfd_boolean
d294 1
a294 1
     bfd_boolean dynamic;
d314 1
a314 1
  relents = asect->relocation + canon_reloc_count (asect);
d326 1
a326 1
      bfd_elf64_swap_reloca_in (abfd, native_relocs, &rela);
d369 1
a369 1
  canon_reloc_count (asect) += relent - relents;
d374 1
a374 1
  return TRUE;
d379 1
a379 1
  return FALSE;
d384 1
a384 1
static bfd_boolean
d389 1
a389 1
     bfd_boolean dynamic;
d397 1
a397 1
    return TRUE;
d403 1
a403 1
	return TRUE;
d418 1
a418 1
	return TRUE;
d429 1
a429 1
    return FALSE;
d431 2
a432 3
  /* The sparc64_elf_slurp_one_reloc_table routine increments
     canon_reloc_count.  */
  canon_reloc_count (asect) = 0;
d436 1
a436 1
    return FALSE;
d441 1
a441 24
    return FALSE;

  return TRUE;
}

/* Canonicalize the relocs.  */

static long
sparc64_elf_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < canon_reloc_count (section); i++)
    *relptr++ = tblptr++;
d443 1
a443 3
  *relptr = NULL;

  return canon_reloc_count (section);
a445 1

d479 1
a479 1
	  if (! sparc64_elf_slurp_reloc_table (abfd, s, syms, TRUE))
d481 1
a481 1
	  count = canon_reloc_count (s);
d502 1
a502 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d553 1
a553 1
      *failedp = TRUE;
d593 1
a593 1
	      *failedp = TRUE;
d603 1
a603 1
	  *failedp = TRUE;
d629 1
a629 1
      bfd_elf64_swap_reloca_out (abfd, &dst_rela, (bfd_byte *) src_rela);
d717 1
a717 1
  /* This works because partial_inplace is FALSE.  */
d997 1
a997 1
static bfd_boolean
d1014 2
a1015 2
  if (info->relocatable || !(sec->flags & SEC_ALLOC))
    return TRUE;
d1050 1
a1050 1
		return FALSE;
d1074 1
a1074 1
		    return FALSE;
d1091 1
a1091 1
		    return FALSE;
d1109 1
a1109 1
		    return FALSE;
d1167 1
a1167 1
	      return FALSE;
d1174 1
a1174 1
		return FALSE;
d1246 1
a1246 1
		    return FALSE;
d1265 1
a1265 1
			return FALSE;
d1283 1
a1283 1
	  return FALSE;
d1287 1
a1287 1
  return TRUE;
d1293 1
a1293 1
static bfd_boolean
d1319 1
a1319 1
	  return FALSE;
d1329 1
a1329 1
	  return TRUE;
d1341 1
a1341 1
	  return FALSE;
d1351 1
a1351 1
		bfd_link_hash_lookup (info->hash, *namep, FALSE, FALSE, FALSE);
d1363 1
a1363 1
		  return FALSE;
d1369 1
a1369 1
		return FALSE;
d1389 1
a1389 1
      return TRUE;
d1409 1
a1409 1
	    return FALSE;
d1412 1
a1412 1
  return TRUE;
d1415 1
a1415 1
/* This function takes care of emitting STT_REGISTER symbols
d1418 1
a1418 1
static bfd_boolean
d1423 2
a1424 3
     bfd_boolean (*func)
       PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *,
		struct elf_link_hash_entry *));
d1452 1
a1452 1
    return TRUE;
d1460 1
a1460 1
				FALSE, FALSE) == NULL)
d1470 2
a1471 3
			 ? bfd_abs_section_ptr : bfd_und_section_ptr,
		       NULL))
	  return FALSE;
d1474 1
a1474 1
  return TRUE;
d1512 1
a1512 1
static bfd_boolean
d1556 1
a1556 1
	  return TRUE;
a1565 3
      /* To simplify matters later, just store the plt index here.  */
      h->plt.offset = s->_raw_size / PLT_ENTRY_SIZE;

d1575 1
a1575 1
	  h->root.u.def.value = sparc64_elf_plt_entry_offset (h->plt.offset);
d1578 3
d1596 1
a1596 1
	  return FALSE;
d1599 1
a1599 1
      return TRUE;
d1611 1
a1611 1
      return TRUE;
d1622 1
a1622 1
    return TRUE;
d1664 1
a1664 1
	return FALSE;
d1674 1
a1674 1
  return TRUE;
d1679 1
a1679 1
static bfd_boolean
d1686 1
a1686 1
  bfd_boolean relplt;
d1694 1
a1694 1
      if (info->executable)
d1717 1
a1717 1
  relplt = FALSE;
d1721 1
a1721 1
      bfd_boolean strip;
d1730 1
a1730 1
      strip = FALSE;
d1745 1
a1745 1
	      strip = TRUE;
d1750 1
a1750 1
		relplt = TRUE;
d1775 1
a1775 1
	return FALSE;
d1793 1
a1793 1
      if (info->executable)
d1796 1
a1796 1
	    return FALSE;
d1805 1
a1805 1
	    return FALSE;
d1811 1
a1811 1
	return FALSE;
d1816 1
a1816 1
	    return FALSE;
d1830 1
a1830 1
	      return FALSE;
d1835 1
a1835 1
	      return FALSE;
d1844 1
a1844 1
		= _bfd_elf_strtab_add (dynstr, app_regs[reg].name, FALSE);
d1868 1
a1868 1
  return TRUE;
d1871 2
a1872 12
static bfd_boolean
sparc64_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct sparc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct sparc64_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;
d1874 1
a1874 4
  return _bfd_elf_new_section_hook (abfd, sec);
}

static bfd_boolean
d1879 1
a1879 1
     bfd_boolean *again;
d1881 3
a1883 3
  *again = FALSE;
  sec_do_relax (section) = 1;
  return TRUE;
d1899 1
a1899 1
static bfd_boolean
d1922 2
a1923 2
  if (info->relocatable)
    return TRUE;
d1949 2
a1950 2
      bfd_boolean is_plt = FALSE;
      bfd_boolean unresolved_reloc;
d1956 1
a1956 1
	  return FALSE;
d1965 1
a1965 1
      unresolved_reloc = FALSE;
d1970 1
a1970 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1974 4
a1977 1
	  bfd_boolean warned;
d1979 3
a1981 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	  if (warned)
d1983 28
d2014 1
d2076 1
a2076 2
		bfd_byte *loc;
		bfd_boolean skip, relocate;
d2087 1
a2087 1
		      return FALSE;
d2098 2
a2099 2
		skip = FALSE;
		relocate = FALSE;
d2105 1
a2105 1
		  skip = TRUE;
d2107 1
a2107 1
		  skip = TRUE, relocate = TRUE;
d2144 1
a2144 1
		      skip = TRUE, relocate = TRUE;
a2166 1
		    outrel.r_addend = relocation + rel->r_addend;
d2168 4
a2171 1
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
d2178 10
a2187 2

			if (bfd_is_abs_section (sec))
d2192 1
a2192 1
			    return FALSE;
a2200 7
			    /* We are turning this relocation into one
			       against a section symbol, so subtract out
			       the output section's address but not the
			       offset of the input section in the output
			       section.  */
			    outrel.r_addend -= osec->vma;

d2210 1
a2210 1
				return FALSE;
d2219 1
d2223 5
a2227 3
		loc = sreloc->contents;
		loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
		bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2253 1
a2253 1
	      bfd_boolean dyn;
d2288 1
a2288 1
		unresolved_reloc = FALSE;
d2307 1
a2307 1
		      asection *s;
a2308 1
		      bfd_byte *loc;
d2320 2
a2321 2
		      s = bfd_get_section_by_name(dynobj, ".rela.got");
		      BFD_ASSERT (s != NULL);
d2328 5
a2332 3
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2370 1
a2370 1
	  unresolved_reloc = FALSE;
d2376 1
a2376 1
	      is_plt = TRUE;
d2457 1
a2457 1
	  if (sec_do_relax (input_section)
d2544 1
a2544 1
	  /* Fall through.  */
d2583 5
a2587 4
	       overflows for discarded entries.  */
	    if ((r_type == R_SPARC_32 || r_type == R_SPARC_DISP32)
		&& _bfd_elf_section_offset (output_bfd, info, input_section,
					    rel->r_offset) == (bfd_vma) -1)
d2612 1
a2612 1
		  return FALSE;
d2619 1
a2619 1
	      return FALSE;
d2625 1
a2625 1
  return TRUE;
d2631 1
a2631 1
static bfd_boolean
a2646 1
      bfd_byte *loc;
d2678 3
a2680 3
      loc = srela->contents;
      loc += (h->plt.offset - 4) * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a2701 1
      bfd_byte *loc;
d2736 4
a2739 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a2745 1
      bfd_byte *loc;
d2748 1
d2760 4
a2763 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d2772 1
a2772 1
  return TRUE;
d2777 1
a2777 1
static bfd_boolean
d2805 1
a2805 1
	  bfd_boolean size;
d2811 3
a2813 3
	    case DT_PLTGOT:   name = ".plt"; size = FALSE; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = TRUE; break;
	    case DT_JMPREL:   name = ".rela.plt"; size = FALSE; break;
d2820 1
a2820 1
		    return FALSE;
d2825 1
a2825 1
	    default:	      name = NULL; size = FALSE; break;
d2853 4
a2856 2
	sparc64_elf_build_plt (output_bfd, splt->contents,
			       (int) (splt->_raw_size / PLT_ENTRY_SIZE));
d2878 1
a2878 1
  return TRUE;
d2903 1
a2903 1
static bfd_boolean
d2908 1
a2908 1
  bfd_boolean error;
d2914 1
a2914 1
    return TRUE;
d2921 1
a2921 1
      elf_flags_init (obfd) = TRUE;
d2930 1
a2930 1
      error = FALSE;
d2952 1
a2952 1
	      error = TRUE;
d2971 1
a2971 1
          error = TRUE;
d2982 1
a2982 1
          return FALSE;
d2985 1
a2985 1
  return TRUE;
d2990 1
a2990 1
static bfd_boolean
d2993 1
a2993 1
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d3005 2
a3006 2

  return TRUE;
d3039 1
a3039 1
static bfd_boolean
d3067 2
a3068 2
  4,		/* hash-table entry size.  */
  /* Internal relocations per external relocations.
d3073 2
a3074 2
  64,		/* arch_size.  */
  3,		/* log_file_align.  */
d3086 4
a3089 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
a3111 2
#define bfd_elf64_canonicalize_reloc \
  sparc64_elf_canonicalize_reloc
a3117 2
#define bfd_elf64_new_section_hook \
  sparc64_elf_new_section_hook
d3164 1
@


1.59
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@a2729 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d2734 2
@


1.59.10.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d2730 1
a2734 2
      bfd_put_64 (output_bfd, (bfd_vma) 0,
		  sgot->contents + (h->got.offset &~ (bfd_vma) 1));
@


1.59.10.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a1565 3
      /* To simplify matters later, just store the plt index here.  */
      h->plt.offset = s->_raw_size / PLT_ENTRY_SIZE;

d1575 1
a1575 1
	  h->root.u.def.value = sparc64_elf_plt_entry_offset (h->plt.offset);
d1578 3
a2166 1
		    outrel.r_addend = relocation + rel->r_addend;
d2168 4
a2171 1
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
a2200 7
			    /* We are turning this relocation into one
			       against a section symbol, so subtract out
			       the output section's address but not the
			       offset of the input section in the output
			       section.  */
			    outrel.r_addend -= osec->vma;

d2219 1
d2583 1
a2583 1
	       overflows for discarded entries.  */
d2585 3
a2587 2
		&& _bfd_elf_section_offset (output_bfd, info, input_section,
					    rel->r_offset) == (bfd_vma) -1)
@


1.59.10.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d54 1
a54 1
static bfd_boolean sparc64_elf_check_relocs
d57 1
a57 1
static bfd_boolean sparc64_elf_adjust_dynamic_symbol
d59 1
a59 1
static bfd_boolean sparc64_elf_size_dynamic_sections
d63 1
a63 1
static bfd_boolean sparc64_elf_add_symbol_hook
d66 1
a66 1
static bfd_boolean sparc64_elf_output_arch_syms
d68 1
a68 1
	   bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *, asection *)));
d72 1
a72 1
static bfd_boolean sparc64_elf_merge_private_bfd_data
d75 2
a76 2
static bfd_boolean sparc64_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d80 3
a82 3
static bfd_boolean sparc64_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sparc64_elf_relocate_section
d85 1
a85 1
static bfd_boolean sparc64_elf_finish_dynamic_symbol
d88 1
a88 1
static bfd_boolean sparc64_elf_finish_dynamic_sections
d90 1
a90 1
static bfd_boolean sparc64_elf_object_p PARAMS ((bfd *));
d93 4
a96 4
static bfd_boolean sparc64_elf_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, asymbol **, bfd_boolean));
static bfd_boolean sparc64_elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d116 24
a139 24
  HOWTO(R_SPARC_NONE,      0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_8,         0,0, 8,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_8",       FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_32,        0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_32",      FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_DISP8,     0,0, 8,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP8",   FALSE,0,0x000000ff,TRUE),
  HOWTO(R_SPARC_DISP16,    0,1,16,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP16",  FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_DISP32,    0,2,32,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP32",  FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_WDISP30,   2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP30", FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_WDISP22,   2,2,22,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP22", FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HI22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HI22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_22,        0,2,22,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_22",      FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_13,        0,2,13,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_13",      FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_LO10,      0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LO10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT10,     0,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT10",   FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_GOT13,     0,2,13,FALSE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_GOT13",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_GOT22,    10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GOT22",   FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC10,      0,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC22,     10,2,22,TRUE, 0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PC22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WPLT30,    2,2,30,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WPLT30",  FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_COPY,      0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_COPY",    FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_GLOB_DAT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_GLOB_DAT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_JMP_SLOT,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_JMP_SLOT",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_RELATIVE,  0,0,00,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_RELATIVE",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_UA32,      0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA32",    FALSE,0,0xffffffff,TRUE),
d141 1
a141 1
  HOWTO(R_SPARC_PLT32,     0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT32",   FALSE,0,0xffffffff,TRUE),
d143 5
a147 5
  HOWTO(R_SPARC_HIPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_HIPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_LOPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_LOPLT10",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT32,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT32",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT22,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT22",  FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_PCPLT10,   0,0,00,FALSE,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PCPLT10",  FALSE,0,0x00000000,TRUE),
d149 26
a174 26
  HOWTO(R_SPARC_10,        0,2,10,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_10",      FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_11,        0,2,11,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_11",      FALSE,0,0x000007ff,TRUE),
  HOWTO(R_SPARC_64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_OLO10,     0,2,13,FALSE,0,complain_overflow_signed,  sparc_elf_notsup_reloc, "R_SPARC_OLO10",   FALSE,0,0x00001fff,TRUE),
  HOWTO(R_SPARC_HH22,     42,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_HM10,     32,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_LM22,     10,2,22,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HH22,  42,2,22,TRUE, 0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_PC_HH22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_PC_HM10,  32,2,10,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_HM10",    FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_PC_LM22,  10,2,22,TRUE, 0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_PC_LM22",    FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_WDISP16,   2,2,16,TRUE, 0,complain_overflow_signed,  sparc_elf_wdisp16_reloc,"R_SPARC_WDISP16", FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_WDISP19,   2,2,19,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_WDISP19", FALSE,0,0x0007ffff,TRUE),
  HOWTO(R_SPARC_UNUSED_42, 0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_UNUSED_42",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_7,         0,2, 7,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_7",       FALSE,0,0x0000007f,TRUE),
  HOWTO(R_SPARC_5,         0,2, 5,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_5",       FALSE,0,0x0000001f,TRUE),
  HOWTO(R_SPARC_6,         0,2, 6,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_6",       FALSE,0,0x0000003f,TRUE),
  HOWTO(R_SPARC_DISP64,    0,4,64,TRUE, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP64",  FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_PLT64,     0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_PLT64",   FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_HIX22,     0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,  "R_SPARC_HIX22",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_LOX10,     0,4, 0,FALSE,0,complain_overflow_dont,    sparc_elf_lox10_reloc,  "R_SPARC_LOX10",   FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_H44,      22,2,22,FALSE,0,complain_overflow_unsigned,bfd_elf_generic_reloc,  "R_SPARC_H44",     FALSE,0,0x003fffff,FALSE),
  HOWTO(R_SPARC_M44,      12,2,10,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_M44",     FALSE,0,0x000003ff,FALSE),
  HOWTO(R_SPARC_L44,       0,2,13,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_L44",     FALSE,0,0x00000fff,FALSE),
  HOWTO(R_SPARC_REGISTER,  0,4, 0,FALSE,0,complain_overflow_bitfield,sparc_elf_notsup_reloc, "R_SPARC_REGISTER",FALSE,0,MINUS_ONE, FALSE),
  HOWTO(R_SPARC_UA64,        0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA64",      FALSE,0,MINUS_ONE, TRUE),
  HOWTO(R_SPARC_UA16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      FALSE,0,0x0000ffff,TRUE)
d258 1
a258 1
     Elf_Internal_Rela *dst;
d288 1
a288 1
static bfd_boolean
d294 1
a294 1
     bfd_boolean dynamic;
d326 1
a326 1
      bfd_elf64_swap_reloca_in (abfd, native_relocs, &rela);
d374 1
a374 1
  return TRUE;
d379 1
a379 1
  return FALSE;
d384 1
a384 1
static bfd_boolean
d389 1
a389 1
     bfd_boolean dynamic;
d397 1
a397 1
    return TRUE;
d403 1
a403 1
	return TRUE;
d418 1
a418 1
	return TRUE;
d429 1
a429 1
    return FALSE;
d436 1
a436 1
    return FALSE;
d441 1
a441 1
    return FALSE;
d443 1
a443 1
  return TRUE;
d479 1
a479 1
	  if (! sparc64_elf_slurp_reloc_table (abfd, s, syms, TRUE))
d502 1
a502 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d553 1
a553 1
      *failedp = TRUE;
d593 1
a593 1
	      *failedp = TRUE;
d603 1
a603 1
	  *failedp = TRUE;
d629 1
a629 1
      bfd_elf64_swap_reloca_out (abfd, &dst_rela, (bfd_byte *) src_rela);
d717 1
a717 1
  /* This works because partial_inplace is FALSE.  */
d997 1
a997 1
static bfd_boolean
d1015 1
a1015 1
    return TRUE;
d1050 1
a1050 1
		return FALSE;
d1074 1
a1074 1
		    return FALSE;
d1091 1
a1091 1
		    return FALSE;
d1109 1
a1109 1
		    return FALSE;
d1167 1
a1167 1
	      return FALSE;
d1174 1
a1174 1
		return FALSE;
d1246 1
a1246 1
		    return FALSE;
d1265 1
a1265 1
			return FALSE;
d1283 1
a1283 1
	  return FALSE;
d1287 1
a1287 1
  return TRUE;
d1293 1
a1293 1
static bfd_boolean
d1319 1
a1319 1
	  return FALSE;
d1329 1
a1329 1
	  return TRUE;
d1341 1
a1341 1
	  return FALSE;
d1351 1
a1351 1
		bfd_link_hash_lookup (info->hash, *namep, FALSE, FALSE, FALSE);
d1363 1
a1363 1
		  return FALSE;
d1369 1
a1369 1
		return FALSE;
d1389 1
a1389 1
      return TRUE;
d1409 1
a1409 1
	    return FALSE;
d1412 1
a1412 1
  return TRUE;
d1418 1
a1418 1
static bfd_boolean
d1423 2
a1424 2
     bfd_boolean (*func)
       PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *));
d1452 1
a1452 1
    return TRUE;
d1460 1
a1460 1
				FALSE, FALSE) == NULL)
d1471 1
a1471 1
	  return FALSE;
d1474 1
a1474 1
  return TRUE;
d1512 1
a1512 1
static bfd_boolean
d1556 1
a1556 1
	  return TRUE;
d1596 1
a1596 1
	  return FALSE;
d1599 1
a1599 1
      return TRUE;
d1611 1
a1611 1
      return TRUE;
d1622 1
a1622 1
    return TRUE;
d1664 1
a1664 1
	return FALSE;
d1674 1
a1674 1
  return TRUE;
d1679 1
a1679 1
static bfd_boolean
d1686 1
a1686 1
  bfd_boolean relplt;
d1717 1
a1717 1
  relplt = FALSE;
d1721 1
a1721 1
      bfd_boolean strip;
d1730 1
a1730 1
      strip = FALSE;
d1745 1
a1745 1
	      strip = TRUE;
d1750 1
a1750 1
		relplt = TRUE;
d1775 1
a1775 1
	return FALSE;
d1796 1
a1796 1
	    return FALSE;
d1805 1
a1805 1
	    return FALSE;
d1811 1
a1811 1
	return FALSE;
d1816 1
a1816 1
	    return FALSE;
d1830 1
a1830 1
	      return FALSE;
d1835 1
a1835 1
	      return FALSE;
d1844 1
a1844 1
		= _bfd_elf_strtab_add (dynstr, app_regs[reg].name, FALSE);
d1868 1
a1868 1
  return TRUE;
d1874 1
a1874 1
static bfd_boolean
d1879 1
a1879 1
     bfd_boolean *again;
d1881 1
a1881 1
  *again = FALSE;
d1883 1
a1883 1
  return TRUE;
d1899 1
a1899 1
static bfd_boolean
d1923 1
a1923 1
    return TRUE;
d1949 2
a1950 2
      bfd_boolean is_plt = FALSE;
      bfd_boolean unresolved_reloc;
d1956 1
a1956 1
	  return FALSE;
d1965 1
a1965 1
      unresolved_reloc = FALSE;
d1989 1
a1989 1
		unresolved_reloc = TRUE;
d2009 1
a2009 1
		return FALSE;
d2076 1
a2076 2
		bfd_byte *loc;
		bfd_boolean skip, relocate;
d2087 1
a2087 1
		      return FALSE;
d2098 2
a2099 2
		skip = FALSE;
		relocate = FALSE;
d2105 1
a2105 1
		  skip = TRUE;
d2107 1
a2107 1
		  skip = TRUE, relocate = TRUE;
d2144 1
a2144 1
		      skip = TRUE, relocate = TRUE;
d2190 1
a2190 1
			    return FALSE;
d2215 1
a2215 1
				return FALSE;
d2227 5
a2231 3
		loc = sreloc->contents;
		loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
		bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2257 1
a2257 1
	      bfd_boolean dyn;
d2292 1
a2292 1
		unresolved_reloc = FALSE;
d2311 1
a2311 1
		      asection *s;
a2312 1
		      bfd_byte *loc;
d2324 2
a2325 2
		      s = bfd_get_section_by_name(dynobj, ".rela.got");
		      BFD_ASSERT (s != NULL);
d2332 5
a2336 3
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2374 1
a2374 1
	  unresolved_reloc = FALSE;
d2380 1
a2380 1
	      is_plt = TRUE;
d2615 1
a2615 1
		  return FALSE;
d2622 1
a2622 1
	      return FALSE;
d2628 1
a2628 1
  return TRUE;
d2634 1
a2634 1
static bfd_boolean
a2649 1
      bfd_byte *loc;
d2681 3
a2683 3
      loc = srela->contents;
      loc += (h->plt.offset - 4) * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a2704 1
      bfd_byte *loc;
d2739 4
a2742 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a2748 1
      bfd_byte *loc;
d2763 4
a2766 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d2775 1
a2775 1
  return TRUE;
d2780 1
a2780 1
static bfd_boolean
d2808 1
a2808 1
	  bfd_boolean size;
d2814 3
a2816 3
	    case DT_PLTGOT:   name = ".plt"; size = FALSE; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = TRUE; break;
	    case DT_JMPREL:   name = ".rela.plt"; size = FALSE; break;
d2823 1
a2823 1
		    return FALSE;
d2828 1
a2828 1
	    default:	      name = NULL; size = FALSE; break;
d2881 1
a2881 1
  return TRUE;
d2906 1
a2906 1
static bfd_boolean
d2911 1
a2911 1
  bfd_boolean error;
d2917 1
a2917 1
    return TRUE;
d2924 1
a2924 1
      elf_flags_init (obfd) = TRUE;
d2933 1
a2933 1
      error = FALSE;
d2955 1
a2955 1
	      error = TRUE;
d2974 1
a2974 1
          error = TRUE;
d2985 1
a2985 1
          return FALSE;
d2988 1
a2988 1
  return TRUE;
d2993 1
a2993 1
static bfd_boolean
d2996 1
a2996 1
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d3008 2
a3009 2

  return TRUE;
d3042 1
a3042 1
static bfd_boolean
d3089 4
a3092 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
@


1.59.10.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a79 2
static bfd_boolean sparc64_elf_new_section_hook
  PARAMS ((bfd *, asection *));
d174 1
a174 25
  HOWTO(R_SPARC_UA16,        0,1,16,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA16",      FALSE,0,0x0000ffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_GD_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_GD_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_GD_CALL,2,2,30,TRUE,0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_TLS_GD_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_HI22,10,2,22,FALSE,0,complain_overflow_dont, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_LO10,0,2,10,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_LDM_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LDM_CALL,2,2,30,TRUE,0,complain_overflow_signed, bfd_elf_generic_reloc,  "R_SPARC_TLS_LDM_CALL",FALSE,0,0x3fffffff,TRUE),
  HOWTO(R_SPARC_TLS_LDO_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc,"R_SPARC_TLS_LDO_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_LOX10,0,2,0,FALSE,0,complain_overflow_dont,  sparc_elf_lox10_reloc,  "R_SPARC_TLS_LDO_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_LDO_ADD,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_LDO_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_HI22,10,2,22,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_HI22",FALSE,0,0x003fffff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LO10,0,2,10,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LO10",FALSE,0,0x000003ff,TRUE),
  HOWTO(R_SPARC_TLS_IE_LD,0,0, 0,FALSE,0,complain_overflow_dont,     bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_LDX,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_LDX",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_IE_ADD,0,0, 0,FALSE,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_TLS_IE_ADD",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_LE_HIX22,0,2,0,FALSE,0,complain_overflow_bitfield,sparc_elf_hix22_reloc, "R_SPARC_TLS_LE_HIX22",FALSE,0,0x003fffff, FALSE),
  HOWTO(R_SPARC_TLS_LE_LOX10,0,2,0,FALSE,0,complain_overflow_dont,   sparc_elf_lox10_reloc,  "R_SPARC_TLS_LE_LOX10",FALSE,0,0x000003ff, FALSE),
  HOWTO(R_SPARC_TLS_DTPMOD32,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPMOD64,0,0, 0,FALSE,0,complain_overflow_dont,  bfd_elf_generic_reloc,  "R_SPARC_TLS_DTPMOD64",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF32,0,2,32,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF32",FALSE,0,0xffffffff,TRUE),
  HOWTO(R_SPARC_TLS_DTPOFF64,0,4,64,FALSE,0,complain_overflow_bitfield,bfd_elf_generic_reloc,"R_SPARC_TLS_DTPOFF64",FALSE,0,MINUS_ONE,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF32,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF32",FALSE,0,0x00000000,TRUE),
  HOWTO(R_SPARC_TLS_TPOFF64,0,0, 0,FALSE,0,complain_overflow_dont,   bfd_elf_generic_reloc,  "R_SPARC_TLS_TPOFF64",FALSE,0,0x00000000,TRUE)
a227 24
  { BFD_RELOC_SPARC_TLS_GD_HI22, R_SPARC_TLS_GD_HI22 },
  { BFD_RELOC_SPARC_TLS_GD_LO10, R_SPARC_TLS_GD_LO10 },
  { BFD_RELOC_SPARC_TLS_GD_ADD, R_SPARC_TLS_GD_ADD },
  { BFD_RELOC_SPARC_TLS_GD_CALL, R_SPARC_TLS_GD_CALL },
  { BFD_RELOC_SPARC_TLS_LDM_HI22, R_SPARC_TLS_LDM_HI22 },
  { BFD_RELOC_SPARC_TLS_LDM_LO10, R_SPARC_TLS_LDM_LO10 },
  { BFD_RELOC_SPARC_TLS_LDM_ADD, R_SPARC_TLS_LDM_ADD },
  { BFD_RELOC_SPARC_TLS_LDM_CALL, R_SPARC_TLS_LDM_CALL },
  { BFD_RELOC_SPARC_TLS_LDO_HIX22, R_SPARC_TLS_LDO_HIX22 },
  { BFD_RELOC_SPARC_TLS_LDO_LOX10, R_SPARC_TLS_LDO_LOX10 },
  { BFD_RELOC_SPARC_TLS_LDO_ADD, R_SPARC_TLS_LDO_ADD },
  { BFD_RELOC_SPARC_TLS_IE_HI22, R_SPARC_TLS_IE_HI22 },
  { BFD_RELOC_SPARC_TLS_IE_LO10, R_SPARC_TLS_IE_LO10 },
  { BFD_RELOC_SPARC_TLS_IE_LD, R_SPARC_TLS_IE_LD },
  { BFD_RELOC_SPARC_TLS_IE_LDX, R_SPARC_TLS_IE_LDX },
  { BFD_RELOC_SPARC_TLS_IE_ADD, R_SPARC_TLS_IE_ADD },
  { BFD_RELOC_SPARC_TLS_LE_HIX22, R_SPARC_TLS_LE_HIX22 },
  { BFD_RELOC_SPARC_TLS_LE_LOX10, R_SPARC_TLS_LE_LOX10 },
  { BFD_RELOC_SPARC_TLS_DTPMOD32, R_SPARC_TLS_DTPMOD32 },
  { BFD_RELOC_SPARC_TLS_DTPMOD64, R_SPARC_TLS_DTPMOD64 },
  { BFD_RELOC_SPARC_TLS_DTPOFF32, R_SPARC_TLS_DTPOFF32 },
  { BFD_RELOC_SPARC_TLS_DTPOFF64, R_SPARC_TLS_DTPOFF64 },
  { BFD_RELOC_SPARC_TLS_TPOFF32, R_SPARC_TLS_TPOFF32 },
  { BFD_RELOC_SPARC_TLS_TPOFF64, R_SPARC_TLS_TPOFF64 },
d1871 2
a1872 24
struct sparc64_elf_section_data
{
  struct bfd_elf_section_data elf;
  unsigned int do_relax;
};

#define sec_do_relax(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->do_relax

static bfd_boolean
sparc64_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct sparc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct sparc64_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}
d1882 1
a1882 1
  sec_do_relax (section) = 1;
d2459 1
a2459 1
	  if (sec_do_relax (input_section)
a3118 2
#define bfd_elf64_new_section_hook \
  sparc64_elf_new_section_hook
@


1.59.10.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d2070 1
d2086 1
d2618 1
a2618 1
	  /* Fall through.  */
d2823 1
d2926 4
a2929 2
	sparc64_elf_build_plt (output_bfd, splt->contents,
			       (int) (splt->_raw_size / PLT_ENTRY_SIZE));
d3140 2
a3141 2
  4,		/* hash-table entry size.  */
  /* Internal relocations per external relocations.
d3146 2
a3147 2
  64,		/* arch_size.  */
  8,		/* file_align.  */
@


1.59.10.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a98 2
static long sparc64_elf_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
a313 11
struct sparc64_elf_section_data
{
  struct bfd_elf_section_data elf;
  unsigned int do_relax, reloc_count;
};

#define sec_do_relax(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->do_relax
#define canon_reloc_count(sec) \
  ((struct sparc64_elf_section_data *) elf_section_data (sec))->reloc_count

d364 1
a364 1
  relents = asect->relocation + canon_reloc_count (asect);
d419 1
a419 1
  canon_reloc_count (asect) += relent - relents;
d481 2
a482 3
  /* The sparc64_elf_slurp_one_reloc_table routine increments
     canon_reloc_count.  */
  canon_reloc_count (asect) = 0;
a495 26
/* Canonicalize the relocs.  */

static long
sparc64_elf_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  unsigned int i;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < canon_reloc_count (section); i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return canon_reloc_count (section);
}


d531 1
a531 1
	  count = canon_reloc_count (s);
d1921 9
a3179 2
#define bfd_elf64_canonicalize_reloc \
  sparc64_elf_canonicalize_reloc
@


1.59.10.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d3173 1
a3173 1
  3,		/* log_file_align.  */
@


1.59.10.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1104 1
a1104 1
  if (info->relocatable || !(sec->flags & SEC_ALLOC))
d1784 1
a1784 1
      if (info->executable)
d1883 1
a1883 1
      if (info->executable)
d2025 1
a2025 1
  if (info->relocatable)
d2687 1
a2687 1
	    if ((r_type == R_SPARC_32 || r_type == R_SPARC_DISP32)
@


1.59.10.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d2100 1
a2100 1
	  else if (!info->executable
@


1.59.10.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d521 1
a521 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2077 4
a2080 1
	  bfd_boolean warned;
d2082 23
a2104 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	  if (warned)
d2106 7
@


1.59.10.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2073 1
a2073 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2250 10
a2259 2

			if (bfd_is_abs_section (sec))
d3239 1
@


1.59.10.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d68 1
a68 2
	   bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *,
			    asection *, struct elf_link_hash_entry *)));
d1505 1
a1505 1
/* This function takes care of emitting STT_REGISTER symbols
d1514 1
a1514 2
       PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *,
		struct elf_link_hash_entry *));
d1560 1
a1560 2
			 ? bfd_abs_section_ptr : bfd_und_section_ptr,
		       NULL))
@


1.58
log
@	* elf32-i386.c (elf_i386_relocate_section): Don't complain about
	unresolved debugging relocs in dynamic applications.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d1922 3
d1960 1
a1961 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d3157 1
@


1.58.2.1
log
@Merge from mainline.
@
text
@d2747 1
a2751 2
      bfd_put_64 (output_bfd, (bfd_vma) 0,
		  sgot->contents + (h->got.offset &~ (bfd_vma) 1));
@


1.58.2.2
log
@        * elf64-sparc.c (sparc64_elf_relocate_section): Adjust addend of
        dynamic relocs against section symbols for the output section vma.
@
text
@a2183 1
		    outrel.r_addend = relocation + rel->r_addend;
d2185 4
a2188 1
		      outrel.r_info = ELF64_R_INFO (0, R_SPARC_RELATIVE);
a2217 7
			    /* We are turning this relocation into one
			       against a section symbol, so subtract out
			       the output section's address but not the
			       offset of the input section in the output
			       section.  */
			    outrel.r_addend -= osec->vma;

d2236 1
@


1.58.2.3
log
@2002-11-14  David O'Brien  <obrien@@FreeBSD.org>
	Merge from mainline:
	2002-11-12  Thomas Moestl <tmm@@FreeBSD.org>
	* elf64-sparc.c (sparc64_elf_adjust_dynamic_symbol): Correct
	references to large plt symbols.

Approved by:  Daniel Jacobowitz <drow@@mvista.com>
              Message-ID: <20021114003410.GA15753@@nevyn.them.org>
@
text
@a1565 3
      /* To simplify matters later, just store the plt index here.  */
      h->plt.offset = s->_raw_size / PLT_ENTRY_SIZE;

d1575 1
a1575 1
	  h->root.u.def.value = sparc64_elf_plt_entry_offset (h->plt.offset);
d1577 3
@


1.57
log
@	* elf.c: (assign_section_numbers) Set sh_entsize for .stab only
	when not already set.
	* elf64-sparc.c: (sparc64_elf_fake_sections): New function.
	(elf_backend_fake_sections): Define.
@
text
@d2571 3
d2575 1
a2575 2
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
@


1.56
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d75 3
d3001 21
d3159 2
@


1.55
log
@	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Check the hash
	table is elf64-sparc.
@
text
@d714 1
a714 1
  /* This works because partial_inplace == false.  */
@


1.54
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1389 1
a1389 1
	   && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.53
log
@	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.
@
text
@d3070 1
@


1.53.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1389 1
a1389 1
	   && info->hash->creator == abfd->xvec)
a3069 1
  bfd_elf64_swap_symbol_in,
@


1.53.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a74 3
static boolean sparc64_elf_fake_sections
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));

d714 1
a714 1
  /* This works because partial_inplace is false.  */
a2567 3
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
d2569 2
a2570 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0
a2997 21

/* MARCO: Set the correct entry size for the .stab section.  */

static boolean
sparc64_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
{
  const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".stab") == 0)
    {
      /* Even in the 64bit case the stab entries are only 12 bytes long.  */
      elf_section_data (sec)->this_hdr.sh_entsize = 12;
    }
  
  return true;
}
a3134 2
#define elf_backend_fake_sections \
  sparc64_elf_fake_sections
@


1.53.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a1921 3
  if (info->relocateable)
    return true;

d1957 21
a1978 1
      r_symndx = ELF64_R_SYM (rel->r_info);
a3173 1
#define elf_backend_rela_normal 1
@


1.53.6.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d2730 1
a2734 2
      bfd_put_64 (output_bfd, (bfd_vma) 0,
		  sgot->contents + (h->got.offset &~ (bfd_vma) 1));
@


1.53.4.1
log
@merge from trunk
@
text
@d1389 1
a1389 1
	   && info->hash->creator == abfd->xvec)
a3069 1
  bfd_elf64_swap_symbol_in,
@


1.52
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1388 2
a1389 3
  else if (! *namep || ! **namep)
    return true;
  else
@


1.51
log
@	* elf32-sparc.c (elf32_sparc_relocate_section): Don't emit dynamic
	PC relative relocs against hidden symbols.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d662 1
a662 1
  ret = (struct sparc64_elf_link_hash_table *) bfd_zalloc (abfd, amt);
d669 1
a669 1
      bfd_release (abfd, ret);
@


1.50
log
@        * elf32-sparc.c (WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
        (elf32_sparc_relocate_section): Use it to figure out when to
        initialize .got entries.
        * elf64-sparc.c: Similarly.
@
text
@d2056 1
a2060 1
	    case R_SPARC_DISP64:
d2148 12
@


1.49
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d1884 11
d1942 1
a1942 1
      bfd_vma relocation;
d1945 1
d1980 1
d1993 2
a1997 1
	      boolean skip_it = false;
d1999 6
a2004 91

	      switch (r_type)
		{
		case R_SPARC_WPLT30:
		case R_SPARC_PLT32:
		case R_SPARC_HIPLT22:
		case R_SPARC_LOPLT10:
		case R_SPARC_PCPLT32:
		case R_SPARC_PCPLT22:
		case R_SPARC_PCPLT10:
		case R_SPARC_PLT64:
		  if (h->plt.offset != (bfd_vma) -1)
		    skip_it = true;
		  break;

		case R_SPARC_GOT10:
		case R_SPARC_GOT13:
		case R_SPARC_GOT22:
		  if (elf_hash_table(info)->dynamic_sections_created
		      && (!info->shared
			  || (!info->symbolic && h->dynindx != -1)
			  || !(h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR)))
		    skip_it = true;
		  break;

		case R_SPARC_PC10:
		case R_SPARC_PC22:
		case R_SPARC_PC_HH22:
		case R_SPARC_PC_HM10:
		case R_SPARC_PC_LM22:
		  if (!strcmp(h->root.root.string, "_GLOBAL_OFFSET_TABLE_"))
		    break;
		  /* FALLTHRU */

		case R_SPARC_8:
		case R_SPARC_16:
		case R_SPARC_32:
		case R_SPARC_DISP8:
		case R_SPARC_DISP16:
		case R_SPARC_DISP32:
		case R_SPARC_WDISP30:
		case R_SPARC_WDISP22:
		case R_SPARC_HI22:
		case R_SPARC_22:
		case R_SPARC_13:
		case R_SPARC_LO10:
		case R_SPARC_UA32:
		case R_SPARC_10:
		case R_SPARC_11:
		case R_SPARC_64:
		case R_SPARC_OLO10:
		case R_SPARC_HH22:
		case R_SPARC_HM10:
		case R_SPARC_LM22:
		case R_SPARC_WDISP19:
		case R_SPARC_WDISP16:
		case R_SPARC_7:
		case R_SPARC_5:
		case R_SPARC_6:
		case R_SPARC_DISP64:
		case R_SPARC_HIX22:
		case R_SPARC_LOX10:
		case R_SPARC_H44:
		case R_SPARC_M44:
		case R_SPARC_L44:
		case R_SPARC_UA64:
		case R_SPARC_UA16:
		  if (info->shared
		      && ((!info->symbolic && h->dynindx != -1)
			  || !(h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR))
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_SPARC_{32,64} relocations in
			     its sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
		    skip_it = true;
		  break;
		}

	      if (skip_it)
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
d2006 3
a2008 5
		{
		  relocation = (h->root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		}
d2011 1
a2011 1
	    relocation = 0;
d2016 1
a2016 1
	    relocation = 0;
d2037 1
a2037 1
do_dynreloc:
d2256 3
a2258 1
	      bfd_vma off = h->got.offset;
d2260 1
d2262 1
a2262 1
	      if (! elf_hash_table (info)->dynamic_sections_created
d2264 4
a2267 3
		      && (info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR)))
d2290 2
a2291 1
	      relocation = sgot->output_offset + off - got_base;
a2294 2
	      bfd_vma off;

a2339 1
	      relocation = sgot->output_offset + off - got_base;
d2341 1
d2373 1
d2556 11
@


1.48
log
@Fixes for better translation into other languages
@
text
@d2164 1
a2164 1
		boolean skip;
d2187 1
d2194 2
d2307 2
a2308 1
		continue;
@


1.48.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2164 1
a2164 1
		boolean skip, relocate;
a2186 1
		relocate = false;
a2192 2
		else if (outrel.r_offset == (bfd_vma) -2)
		  skip = true, relocate = true;
d2304 1
a2304 2
		if (! relocate)
		  continue;
@


1.48.2.2
log
@        * elf32-sparc.c (WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
        (elf32_sparc_relocate_section): Use it to figure out when to
        initialize .got entries.
        * elf64-sparc.c: Similarly.
@
text
@a1883 11
/* This is the condition under which finish_dynamic_symbol will be called
   from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol
   routine, we'll need to do something about initializing any .plt and
   .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H)			\
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1931 1
a1931 1
      bfd_vma relocation, off;
a1933 1
      boolean unresolved_reloc;
a1967 1
      unresolved_reloc = false;
a1979 2

	  relocation = 0;
d1983 1
d1985 91
a2075 6
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = true;
d2077 5
a2081 3
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
d2084 1
a2084 1
	    ;
d2089 1
a2089 1
	    ;
d2110 1
a2110 1
 do_dynreloc:
d2329 1
a2329 3
	      boolean dyn;

	      off = h->got.offset;
a2330 1
	      dyn = elf_hash_table (info)->dynamic_sections_created;
d2332 1
a2332 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d2334 3
a2336 4
		      && (info->symbolic
			  || h->dynindx == -1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2359 1
a2359 2
	      else
		unresolved_reloc = false;
d2363 2
d2410 1
a2411 1
	  relocation = sgot->output_offset + off - got_base;
a2442 1
	  unresolved_reloc = false;
a2624 11

      if (unresolved_reloc
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	(*_bfd_error_handler)
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
	   (long) rel->r_offset,
	   h->root.root.string);
@


1.48.2.3
log
@Merge from mainline.
@
text
@a2055 1
	    case R_SPARC_DISP64:
d2060 1
a2147 12
		    break;
		  case R_SPARC_DISP8:
		  case R_SPARC_DISP16:
		  case R_SPARC_DISP32:
		  case R_SPARC_DISP64:
		    /* If the symbol is not dynamic, we should not keep
		       a dynamic relocation.  But an .rela.* slot has been
		       allocated for it, output R_SPARC_NONE.
		       FIXME: Add code tracking needed dynamic relocs as
		       e.g. i386 has.  */
		    if (h->dynindx == -1)
		      skip = true, relocate = true;
@


1.48.2.4
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1388 3
a1390 2
  else if (*namep && **namep
	   && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.47
log
@	* elf32-sparc.c (_bfd_sparc_elf_howto_table): Fix dst_mask for
	R_SPARC_DISP32.  Support R_SPARC_PLT32.
	(sparc_reloc_map): Add BFD_RELOC_16_PCREL and BFD_RELOC_SPARC_PLT32.
	(elf32_sparc_check_relocs): Handle R_SPARC_PLT32.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_howto_table): Fix dst_mask for
	R_SPARC_DISP32.  Support R_SPARC_PLT32 and R_SPARC_PLT64.
	(sparc_reloc_map): Add BFD_RELOC_16_PCREL, BFD_RELOC_64_PCREL
	and BFD_RELOC_SPARC_PLT32.
	(sparc64_elf_check_relocs): Handle R_SPARC_PLT32 and R_SPARC_PLT64.
	(sparc64_elf_relocate_section): Likewise.
	* reloc.c (bfd_reloc_code_type): Add BFD_RELOC_SPARC_PLT32.
	* bfd-in2.h, libbfd.h: Rebuilt.

	* config/tc-sparc.h (TC_PARSE_CONS_EXPRESSION): Define.
	(sparc_cons): Provide prototype.
	* config/tc-sparc.c (tc_gen_reloc): Handle BFD_RELOC_*_PCREL and
	BFD_RELOC_SPARC_PLT{32,64}.  Enumerate for which relocs
	reloc->addend = fixp->fx_addnumber shouldn't be done instead of
	enumarating for which pc relative ones it should be done.
	(sparc_cons_special_reloc): New variable.
	(sparc_cons): New function.
	(cons_fix_new_sparc): Use sparc_cons_special_reloc.
	* testsuite/gas/sparc/pcrel.s: New test.
	* testsuite/gas/sparc/pcrel.d: Expected output.
	* testsuite/gas/sparc/pcrel64.s: New test.
	* testsuite/gas/sparc/pcrel64.d: Expected output.
	* testsuite/gas/sparc/plt.s: New test.
	* testsuite/gas/sparc/plt.d: Expected output.
	* testsuite/gas/sparc/plt64.s: New test.
	* testsuite/gas/sparc/plt64.d: Expected output.
	* testsuite/gas/sparc/sparc.exp: Add pcrel, pcrel64, plt and plt64
	tests.
@
text
@d1334 1
a1334 1
            (_("Register %%g%d used incompatibly: %s in %s"),
d1336 1
a1336 3
             **namep ? *namep : "#scratch", bfd_archive_filename (abfd));
          (*_bfd_error_handler)
            (_("  previously %s in %s"),
d1357 2
a1358 4
		    (_("Symbol `%s' has differing types: %s in %s"),
		     *namep, "REGISTER", bfd_archive_filename (abfd));
		  (*_bfd_error_handler)
		    (_("  previously %s in %s"),
d1404 3
a1406 5
	      (_("Symbol `%s' has differing types: %s in %s"),
	       *namep, stt_types[type], bfd_archive_filename (abfd));
	    (*_bfd_error_handler)
	      (_("  previously %s in %s"),
	       "REGISTER", bfd_archive_filename (p->abfd));
@


1.46
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d119 1
a119 1
  HOWTO(R_SPARC_DISP32,    0,2,32,true, 0,complain_overflow_signed,  bfd_elf_generic_reloc,  "R_SPARC_DISP32",  false,0,0x00ffffff,true),
d138 1
a139 1
  HOWTO(R_SPARC_PLT32,     0,0,00,false,0,complain_overflow_dont,    sparc_elf_notsup_reloc, "R_SPARC_PLT32",    false,0,0x00000000,true),
d163 1
a163 1
  HOWTO(R_SPARC_PLT64,     0,4,64,false,0,complain_overflow_bitfield,sparc_elf_notsup_reloc, "R_SPARC_PLT64",   false,0,MINUS_ONE, false),
d183 1
d192 1
d225 3
d1175 4
a1178 2
	  break;

d1939 1
d2116 1
d2231 1
a2231 1
		else if (h != NULL
d2255 3
a2257 1
			if (h == NULL)
d2447 6
@


1.45
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@a71 2
static boolean sparc64_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
a2942 18
/* Copy backend specific data from one object module to another */
static boolean
sparc64_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
              || (elf_elfheader (obfd)->e_flags
                  == elf_elfheader (ibfd)->e_flags));

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a3163 2
#define bfd_elf64_bfd_copy_private_bfd_data \
  sparc64_elf_copy_private_bfd_data
@


1.44
log
@	* elf32-sparc.c (elf32_sparc_relocate_section): Don't clear
	relocations in non-alloced sections against global symbols
	defined in shared library being built.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2187 5
a2191 15
		if (elf_section_data (input_section)->stab_info == NULL)
		  outrel.r_offset = rel->r_offset;
		else
		  {
		    bfd_vma off;

		    off = (_bfd_stab_section_offset
			   (output_bfd, &elf_hash_table (info)->stab_info,
			    input_section,
			    &elf_section_data (input_section)->stab_info,
			    rel->r_offset));
		    if (off == MINUS_ONE)
		      skip = true;
		    outrel.r_offset = off;
		  }
@


1.43
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d2056 9
a2064 1
			       & ELF_LINK_HASH_DEF_REGULAR)))
@


1.42
log
@* elf64-sparc.c (sparc64_elf_relocate_section): Disregard
overflows in the .stab section.
@
text
@d1972 1
a1972 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.41
log
@2001-11-11  H.J. Lu <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_finish_dynamic_sections): Call
	_bfd_elf_strtab_size instead of _bfd_stringtab_size.

	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Change
	dynstr type to `struct elf_strtab_hash *'.
@
text
@d2630 10
@


1.40
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1789 1
a1789 1
      struct bfd_strtab_hash *dynstr;
@


1.39
log
@	* Makefile.am (BFD32_BACKENDS): Add elf-strtab.lo.
	(BFD32_BACKENDS_CFILES): Add elf-strtab.c.
	(elf-strtab.lo): Add rule.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-strtab.lo.
	* configure: Rebuilt.
	* elf-bfd.h (elf_strtab_hash): Forward declare.
	(struct elf_link_hash_table): Change dynstr type to
	struct elf_strtab_hash *.
	(struct elf_obj_tdata): Change strtab_ptr type to
	struct elf_strtab_hash *.
	(_bfd_elf_strtab_init, _bfd_elf_strtab_free, _bfd_elf_strtab_add,
	_bfd_elf_strtab_addref, _bfd_elf_strtab_delref,
	_bfd_elf_strtab_clear_all_refs, _bfd_elf_strtab_size,
	_bfd_elf_strtab_offset, _bfd_elf_strtab_emit,
	_bfd_elf_strtab_finalize): New prototypes.
	* elf-strtab.c: New file.
	* elflink.h (elf_link_add_object_symbols): Use _bfd_elf_strtab_add
	and _bfd_elf_strtab_size instead of _bfd_stringtab calls.
	Call _bfd_elf_strtab_delref if DT_NEEDED entry is not needed or
	when forcing dynamic symbol to local.
	(elf_link_create_dynamic_sections): Call
	_bfd_elf_strtab_init instead of elf_stringtab_init.
	(elf_link_record_local_dynamic_symbol): Likewise, change
	dynstr type.  Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.
	(size_dynamic_sections): Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.  For DT_RUNPATH and Verdaux vda_name fields,
	call _bfd_elf_strtab_addref.  Call elf_finalize_dynstr.
	(elf_adjust_dynstr_offsets, elf_finalize_dynstr): New functions.
	(elf_fix_symbol_flags): Call _bfd_elf_strtab_delref when forcing
	dynamic symbol to local.
	(elf_link_assign_sym_version): Likewise.
	(elf_bfd_final_link): Call _bfd_elf_strtab_emit instead of
	_bfd_stringtab_emit.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Change dynstr
	type.  Call _bfd_elf_strtab functions instead of
	_bfd_stringtab functions.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.
	* elf.c (_bfd_elf_init_reloc_shdr): Likewise.
	(elf_fake_sections): Likewise.
	(assign_section_numbers): Call _bfd_elf_strtab_clear_all_refs
	on shstrtab hash table, call _bfd_elf_strtab_addref on each section
	name in the output.  Call _bfd_elf_strtab_finalize and
	use _bfd_elf_strtab_offset to finalize sh_name section header fields.
	(_bfd_elf_compute_section_file_positions): Use _bfd_elf_strtab_size
	instead of _bfd_stringtab_size.
	(prep_headers): Change shstrtab type.
	Use _bfd_elf_strtab calls instead of _bfd_stringtab calls.
@
text
@d2106 1
a2106 1
      if (info->shared && (input_section->flags & SEC_ALLOC))
@


1.38
log
@	* elf64-sparc.c (sparc64_elf_build_plt): Fix .plt[32768+] slot
	computation.
@
text
@d1843 1
a1843 1
		= _bfd_stringtab_add (dynstr, app_regs[reg].name, true, false);
@


1.37
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d924 2
a925 2
	  /* ldx [%o7 + ptr - entry+4], %g1 */
	  ldx = 0xc25be000 | ((ptr - entry+4) & 0x1fff);
@


1.36
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d99 2
a100 1
static enum elf_reloc_type_class sparc64_elf_reloc_type_class PARAMS ((int));
d2921 2
a2922 2
sparc64_elf_reloc_type_class (type)
     int type;
d2924 1
a2924 1
  switch (type)
@


1.35
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1272 1
a1272 1
				bfd_get_filename(abfd),
d1294 1
a1294 1
  static char *stt_types[] = { "NOTYPE", "OBJECT", "FUNCTION" };
d1309 1
a1309 1
             bfd_get_filename (abfd));
d1328 6
a1333 5
            (_("Register %%g%d used incompatibly: "
               "previously declared in %s to %s, in %s redefined to %s"),
             (int)sym->st_value,
             bfd_get_filename (p->abfd), *p->name ? p->name : "#scratch",
             bfd_get_filename (abfd), **namep ? *namep : "#scratch");
d1350 5
a1354 1
		  if (type > STT_FUNC) type = 0;
d1356 2
a1357 3
		    (_("Symbol `%s' has differing types: "
		       "previously %s, REGISTER in %s"),
		     *namep, stt_types [type], bfd_get_filename (abfd));
d1399 5
a1403 1
	    if (type > STT_FUNC) type = 0;
d1405 2
a1406 4
	      (_("Symbol `%s' has differing types: "
		 "REGISTER in %s, %s in %s"),
	       *namep, bfd_get_filename (p->abfd), stt_types [type],
	       bfd_get_filename (abfd));
d2281 1
a2281 1
				   bfd_get_filename (input_bfd));
d3011 1
a3011 1
		 bfd_get_filename (ibfd));
d3030 1
a3030 1
             bfd_get_filename (ibfd), (long)new_flags, (long)old_flags);
@


1.34
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2072 2
a2073 1
	  else if (info->shared && !info->symbolic
@


1.33
log
@	* elf-bfd.h (enum elf_reloc_type_class): New.
	(struct elf_backend_data): Add elf_backend_reloc_type_class.
	(_bfd_elf_reloc_type_class): New.
	* elfxx-target.h (elf_backend_reloc_type_class): Define.
	(elfNN_bed): Add elf_backend_reloc_type_class.
	* elf.c (_bfd_elf_reloc_type_class): New.
	* elf32-i386.c (elf_i386_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(elf_i386_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_i386_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_sparc_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_sparc_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf64-sparc.c (sparc64_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(sparc64_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(sparc64_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add reltext field.
	(elfNN_ia64_hash_table_create): Clear ia64_info.
	(get_reloc_section): Set DF_TEXTREL if the reloc is against read-only
	section.
	(elfNN_ia64_size_dynamic_sections): Use ia64_info->reltext flag
	instead of looking up section names for DT_TEXTREL.
	(elfNN_ia64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elflink.h (size_dynamic_sections): Add spare DT_NULL tags.
	(struct elf_link_sort_rela): New.
	(elf_link_sort_cmp1, elf_link_sort_cmp2, elf_link_sort_relocs): New.
	(elf_bfd_final_link): Call elf_link_sort_relocs.
	Convert one spare DT_NULL into DT_RELCOUNT resp. DT_RELACOUNT if
	necessary.

	* bfdlink.h (struct bfd_link_info): Add combreloc and
	spare_dynamic_tags fields.

	* emultempl/elf32.em (place_orphan): Place orphan .rel* sections
	into .rel.dyn resp. .rela.dyn if combreloc.
	(get_script): If .x linker script is equal to .xn, only put it
	once into the binary.
	Add .xc and .xsc scripts.
	(parse_args): Handle -z combreloc and -z nocombreloc.
	* scripttempl/elf.sc (.rela.sbss): Fix a typo.
	For .xc and .xsc scripts put all .rel* or .rela* input sections
	but .rel*.plt and PLT-like sections into .rel.dyn resp. .rela.dyn.
	* genscripts.sh (GENERATE_COMBRELOC_SCRIPT): Set if SCRIPT_NAME
	is elf.
	Strip trailing whitespace from script.
	Generate .xc and .xsc scripts if requested.
	* ldmain.c (main): Initialize link_info.combreloc and
	link_info.spare_dynamic_tags.
	* lexsup.c (OPTION_SPARE_DYNAMIC_TAGS): Define.
	(ld_options): Add --spare-dynamic-tags option.
	(parse_args): Likewise.
	* ld.texinfo: Document -z combreloc and -z nocombreloc.
	* ldint.texinfo: Document .xc and .xsc linker scripts.
	* NEWS: Add notes about -z combreloc and SHF_MERGE.
@
text
@d50 1
a50 1
  PARAMS ((int));
d52 1
a52 1
  PARAMS ((int, int));
d180 1
a180 1
static CONST struct elf_reloc_map sparc_reloc_map[] =
d297 1
a297 1
  allocated = (PTR) bfd_malloc ((size_t) rel_hdr->sh_size);
d302 1
a302 2
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d387 1
d418 3
a420 3
  asect->relocation = ((arelent *)
		       bfd_alloc (abfd,
				  asect->reloc_count * 2 * sizeof (arelent)));
d656 1
d658 1
a658 2
  ret = ((struct sparc64_elf_link_hash_table *)
	 bfd_zalloc (abfd, sizeof (struct sparc64_elf_link_hash_table)));
d776 2
a777 2
  insn = (insn & ~0x303fff) | ((((relocation >> 2) & 0xc000) << 6)
			       | ((relocation >> 2) & 0x3fff));
d815 1
a815 1
  insn = (insn & ~0x3fffff) | ((relocation >> 10) & 0x3fffff);
d851 1
a851 1
  insn = (insn & ~0x1fff) | 0x1c00 | (relocation & 0x3ff);
d882 1
a882 1
    bfd_put_32 (output_bfd, 0, contents+i*4);
d898 8
a905 8
      bfd_put_32 (output_bfd, sethi, entry);
      bfd_put_32 (output_bfd, ba, entry+4);
      bfd_put_32 (output_bfd, nop, entry+8);
      bfd_put_32 (output_bfd, nop, entry+12);
      bfd_put_32 (output_bfd, nop, entry+16);
      bfd_put_32 (output_bfd, nop, entry+20);
      bfd_put_32 (output_bfd, nop, entry+24);
      bfd_put_32 (output_bfd, nop, entry+28);
d926 12
a937 6
	  bfd_put_32 (output_bfd, 0x8a10000f, entry);    /* mov %o7,%g5 */
	  bfd_put_32 (output_bfd, 0x40000002, entry+4);  /* call .+8 */
	  bfd_put_32 (output_bfd, nop, entry+8);         /* nop */
	  bfd_put_32 (output_bfd, ldx, entry+12);        /* ldx [%o7+P],%g1 */
	  bfd_put_32 (output_bfd, 0x83c3c001, entry+16); /* jmpl %o7+%g1,%g1 */
	  bfd_put_32 (output_bfd, 0x9e100005, entry+20); /* mov %g5,%o7 */
d939 1
a939 1
	  bfd_put_64 (output_bfd, contents - (entry+4), ptr);
d948 1
a948 1
     int index;
d950 1
a950 1
  int block, ofs;
d960 1
a960 2
  return ((bfd_vma) (LARGE_PLT_THRESHOLD + block*160) * PLT_ENTRY_SIZE
	  + ofs * 6*4);
d965 2
a966 1
     int index, max;
d968 1
a968 1
  int block, ofs, last;
d974 1
a974 2
  block = (((index - LARGE_PLT_THRESHOLD) / 160) * 160)
	  + LARGE_PLT_THRESHOLD;
d1095 1
a1095 1
		  size_t size;
d1098 2
a1099 1
		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
d1777 3
d1785 1
a1785 1
      if (! info->shared)
d1787 1
a1787 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d1793 4
a1796 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d1800 3
a1802 4
      if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (Elf64_External_Rela)))
d1807 1
a1807 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d1821 1
a1821 1
	    if (! bfd_elf64_add_dynamic_entry (info, DT_SPARC_REGISTER, 0))
d1858 1
d2377 2
a2378 1
		      bfd_put_64 (output_bfd, 0, sgot->contents + off);
d2444 1
a2444 1
	    x = (x & ~0x1fff) | (relocation & 0x1fff);
d2465 3
a2467 2
	    x = (x & ~0x303fff) | ((((relocation >> 2) & 0xc000) << 6)
				   | ((relocation >> 2) & 0x3fff));
d2485 1
a2485 1
	    x = (x & ~0x3fffff) | ((relocation >> 10) & 0x3fffff);
d2503 1
a2503 1
	    x = (x & ~0x1fff) | relocation;
d2592 1
a2592 1
			  bfd_put_32 (input_bfd, INSN_NOP,
d2697 1
a2697 1
	  int max = splt->_raw_size / PLT_ENTRY_SIZE;
d2743 1
a2743 1
		       + (h->got.offset &~ 1));
d2885 2
a2886 2
	  sparc64_elf_build_plt(output_bfd, splt->contents,
				splt->_raw_size / PLT_ENTRY_SIZE);
@


1.32
log
@	* elf64-sparc.c (sparc64_elf_output_arch_syms): Add missing
	prototype.
	* nlm32-alpha.c (nlm_alpha_write_external): Fix warning.
@
text
@d99 1
d1252 2
a1671 1
  boolean reltext;
a1702 1
  reltext = false;
a1734 12
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0)
		reltext = true;

d1797 1
a1797 1
      if (reltext)
a1800 1
	  info->flags |= DF_TEXTREL;
d2900 17
d3168 2
@


1.31
log
@2001-08-10  Andreas Jaeger  <aj@@suse.de>

	* elf64-sparc.c: Add missing prototypes.
	* elf32-cris.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d66 3
@


1.30
log
@	* elf32-sparc.c (_bfd_sparc_elf_howto_table): Remove support for
	R_SPARC_UA64.
	(elf32_sparc_check_relocs): Likewise.
	Only create .rela section for alloced sections in shared libraries.
	(elf32_sparc_relocate_section): Likewise.
	Remove redundant check.
	Optimize unaligned reloc usage.
	* elf64-sparc.c (sparc64_elf_relocate_section): Remove redundant
	check.

	* testsuite/gas/sparc/unalign.s: Remove .uaxword test.
	* testsuite/gas/sparc/unalign.d: Adjust accordingly.
@
text
@d38 4
a41 1
  PARAMS((bfd *));
d48 1
a48 1
  PARAMS((bfd *, unsigned char *, int));
d50 1
a50 1
  PARAMS((int));
d52 1
a52 1
  PARAMS((int, int));
d55 2
a56 2
  PARAMS((bfd *, struct bfd_link_info *, asection *sec,
	  const Elf_Internal_Rela *));
d58 1
a58 1
  PARAMS((struct bfd_link_info *, struct elf_link_hash_entry *));
d60 1
a60 1
  PARAMS((bfd *, struct bfd_link_info *));
d65 1
a65 1
        const char **, flagword *, asection **, bfd_vma *));
d74 2
d81 5
d3038 2
a3039 2
  	          : (type & BSF_GLOBAL) ? 'g' : ' '),
  	         (type & BSF_WEAK) ? 'w' : ' ');
@


1.29
log
@Add support for .uahword, .uaword and .uaxword pseudo ops
@
text
@d2286 2
a2287 6
		   need to do anything now, unless this is a RELATIVE
		   reloc in an unallocated section.  */
		if (skip
		    || (input_section->flags & SEC_ALLOC) != 0
		    || ELF64_R_TYPE_ID (outrel.r_info) != R_SPARC_RELATIVE)
		  continue;
@


1.28
log
@* elf64-sparc.c (sparc64_elf_slurp_reloc_table): Fix typo
s/ENTIRES/ENTRIES/.
@
text
@d191 26
a216 25
  /* ??? Doesn't dwarf use this?  */
/*{ BFD_RELOC_SPARC_UA32, R_SPARC_UA32 }, not used?? */
  {BFD_RELOC_SPARC_10, R_SPARC_10},
  {BFD_RELOC_SPARC_11, R_SPARC_11},
  {BFD_RELOC_SPARC_64, R_SPARC_64},
  {BFD_RELOC_SPARC_OLO10, R_SPARC_OLO10},
  {BFD_RELOC_SPARC_HH22, R_SPARC_HH22},
  {BFD_RELOC_SPARC_HM10, R_SPARC_HM10},
  {BFD_RELOC_SPARC_LM22, R_SPARC_LM22},
  {BFD_RELOC_SPARC_PC_HH22, R_SPARC_PC_HH22},
  {BFD_RELOC_SPARC_PC_HM10, R_SPARC_PC_HM10},
  {BFD_RELOC_SPARC_PC_LM22, R_SPARC_PC_LM22},
  {BFD_RELOC_SPARC_WDISP16, R_SPARC_WDISP16},
  {BFD_RELOC_SPARC_WDISP19, R_SPARC_WDISP19},
  {BFD_RELOC_SPARC_7, R_SPARC_7},
  {BFD_RELOC_SPARC_5, R_SPARC_5},
  {BFD_RELOC_SPARC_6, R_SPARC_6},
  {BFD_RELOC_SPARC_DISP64, R_SPARC_DISP64},
  {BFD_RELOC_SPARC_PLT64, R_SPARC_PLT64},
  {BFD_RELOC_SPARC_HIX22, R_SPARC_HIX22},
  {BFD_RELOC_SPARC_LOX10, R_SPARC_LOX10},
  {BFD_RELOC_SPARC_H44, R_SPARC_H44},
  {BFD_RELOC_SPARC_M44, R_SPARC_M44},
  {BFD_RELOC_SPARC_L44, R_SPARC_L44},
  {BFD_RELOC_SPARC_REGISTER, R_SPARC_REGISTER}
@


1.27
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@d1905 1
a1905 1
  relend = relocs + NUM_SHDR_ENTIRES (& elf_section_data (input_section)->rel_hdr);
@


1.26
log
@Update copyright notices
@
text
@d399 1
a399 1
      asect->reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
d999 1
a999 2
  rel_end = relocs + elf_section_data (sec)->rel_hdr.sh_size
		     / elf_section_data (sec)->rel_hdr.sh_entsize;
d1905 1
a1905 2
  relend = relocs + elf_section_data (input_section)->rel_hdr.sh_size
		    / elf_section_data (input_section)->rel_hdr.sh_entsize;
@


1.25
log
@	* elf32-sparc.c (elf32_sparc_finish_dynamic_symbol): Don't make PLT
	entries that could serve as a definition for a weak symbol.
	* elf64-sparc.c (sparc64_elf_finish_dynamic_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 95, 96, 97, 98, 99, 2000, 2001
@


1.24
log
@	* elf64-sparc.c (sparc64_elf_copy_private_bfd_data): New function.
@
text
@d2712 7
@


1.23
log
@	* elf64-sparc.c (sparc64_elf_check_relocs): Don't trust reloc_count.
	(sparc64_elf_relocate_section): Likewise.
@
text
@d66 2
d2900 18
d3139 2
a3140 1

@


1.22
log
@* elf32-sparc.c (_bfd_sparc_elf_howto_table): Treat R_SPARC_UA32
similar to R_SPARC_32.
* elf64-sparc.c	(sparc64_elf_howto_table): Likewise.
@
text
@d997 2
a998 1
  rel_end = relocs + sec->reloc_count;
d1904 2
a1905 1
  relend = relocs + input_section->reloc_count;
@


1.21
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 95, 96, 97, 98, 99, 2000
d121 1
a121 1
  HOWTO(R_SPARC_UA32,      0,0,00,false,0,complain_overflow_dont,    bfd_elf_generic_reloc,  "R_SPARC_UA32",    false,0,0x00000000,true),
@


1.21.2.1
log
@Implemnent .uahword .uaword and .uaxword
@
text
@d121 1
a121 1
  HOWTO(R_SPARC_UA32,      0,2,32,false,0,complain_overflow_bitfield,bfd_elf_generic_reloc,  "R_SPARC_UA32",    false,0,0xffffffff,true),
d189 25
a213 26
  { BFD_RELOC_SPARC_UA16, R_SPARC_UA16 },
  { BFD_RELOC_SPARC_UA32, R_SPARC_UA32 },
  { BFD_RELOC_SPARC_UA64, R_SPARC_UA64 },
  { BFD_RELOC_SPARC_10, R_SPARC_10 },
  { BFD_RELOC_SPARC_11, R_SPARC_11 },
  { BFD_RELOC_SPARC_64, R_SPARC_64 },
  { BFD_RELOC_SPARC_OLO10, R_SPARC_OLO10 },
  { BFD_RELOC_SPARC_HH22, R_SPARC_HH22 },
  { BFD_RELOC_SPARC_HM10, R_SPARC_HM10 },
  { BFD_RELOC_SPARC_LM22, R_SPARC_LM22 },
  { BFD_RELOC_SPARC_PC_HH22, R_SPARC_PC_HH22 },
  { BFD_RELOC_SPARC_PC_HM10, R_SPARC_PC_HM10 },
  { BFD_RELOC_SPARC_PC_LM22, R_SPARC_PC_LM22 },
  { BFD_RELOC_SPARC_WDISP16, R_SPARC_WDISP16 },
  { BFD_RELOC_SPARC_WDISP19, R_SPARC_WDISP19 },
  { BFD_RELOC_SPARC_7, R_SPARC_7 },
  { BFD_RELOC_SPARC_5, R_SPARC_5 },
  { BFD_RELOC_SPARC_6, R_SPARC_6 },
  { BFD_RELOC_SPARC_DISP64, R_SPARC_DISP64 },
  { BFD_RELOC_SPARC_PLT64, R_SPARC_PLT64 },
  { BFD_RELOC_SPARC_HIX22, R_SPARC_HIX22 },
  { BFD_RELOC_SPARC_LOX10, R_SPARC_LOX10 },
  { BFD_RELOC_SPARC_H44, R_SPARC_H44 },
  { BFD_RELOC_SPARC_M44, R_SPARC_M44 },
  { BFD_RELOC_SPARC_L44, R_SPARC_L44 },
  { BFD_RELOC_SPARC_REGISTER, R_SPARC_REGISTER }
@


1.21.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.21.2.3
log
@Merge from mainline.
@
text
@a65 2
static boolean sparc64_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d398 1
a398 1
      asect->reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
d998 1
a998 1
  rel_end = relocs + NUM_SHDR_ENTRIES (& elf_section_data (sec)->rel_hdr);
d1904 1
a1904 1
  relend = relocs + NUM_SHDR_ENTRIES (& elf_section_data (input_section)->rel_hdr);
a2708 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
a2896 18
/* Copy backend specific data from one object module to another */
static boolean
sparc64_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
              || (elf_elfheader (obfd)->e_flags
                  == elf_elfheader (ibfd)->e_flags));

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

d3118 1
a3118 2
#define bfd_elf64_bfd_copy_private_bfd_data \
  sparc64_elf_copy_private_bfd_data
@


1.20
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@a653 1

a962 1

@


1.19
log
@gas/
	* config/tc-sparc.c (sparc_ip): Fix a bug which caused v9_arg_p
	instructions to loose any special insn->architecture mask.

	* config/tc-sparc.c (v9a_asr_table): Add v9b ASRs.
	(sparc_md_end, sparc_arch_types, sparc_arch,
	sparc_elf_final_processing): Handle v8plusb and v9b architectures.
	(sparc_ip): Handle siam mode operands. Support v9b ASRs (and
	request v9b architecture if they are used).

bfd/
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data,
	elf32_sparc_object_p, elf32_sparc_final_write_processing):
	Support v8plusb.
	* elf64-sparc.c (sparc64_elf_merge_private_bfd_data,
	sparc64_elf_object_p): Support v9b.
	* archures.c: Declare v8plusb and v9b machines.
	* bfd-in2.h: Ditto.
	* cpu-sparc.c: Ditto.

include/opcode/
	* sparc.h (enum sparc_opcode_arch_val): Add SPARC_OPCODE_ARCH_V9B.
	Note that '3' is used for siam operand.

opcodes/
	* sparc-dis.c (v9a_asr_reg_names): Add v9b ASRs.
	(compute_arch_mask): Add v8plusb and v9b machines.
	(print_insn_sparc): siam mode decoding, accept ASRs up to 25.
	* opcodes/sparc-opc.c: Support for Cheetah instruction set.
	(prefetch_table): Add #invalidate.
@
text
@d243 1
a243 1
   
d259 1
a259 1
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of 
d295 1
a295 1
  
d401 2
a402 2
  asect->relocation = ((arelent *) 
		       bfd_alloc (abfd, 
d409 1
a409 1
    
d413 2
a414 2
  
  if (rel_hdr2 
d537 1
a537 1
  /* orelocation has the data, reloc_count has the count... */
d631 1
a631 1
  
a850 1

d861 1
a861 1
  
d895 1
a895 1
  
d938 1
a938 1
  return ((bfd_vma)(LARGE_PLT_THRESHOLD + block*160) * PLT_ENTRY_SIZE
a964 1

d1199 1
a1199 1
	     dynobj and make room for the reloc. 
d1248 1
a1248 1
	  (*_bfd_error_handler)(_("%s: check_relocs: unhandled reloc type %d"),
d1277 1
a1277 1
      
d1318 1
a1318 1
	      
d1810 1
a1810 1
	      
a1854 1
/*ARGSUSED*/
d2371 1
a2371 1
		      
d2620 1
a2620 1
		       we can safely ignore the overflow.  If not, the 
d2625 1
a2625 1
		  
d2671 1
a2671 1
      /* This symbol has an entry in the PLT.  Set it up. */
d2896 1
a2896 1
/* Functions for dealing with the e_flags field. */
d2922 1
a2922 1
                      
d2925 1
a2925 1
                            
d2996 1
a2996 1
  
d3048 1
a3048 1
     we use 2. */
d3081 1
a3081 1
  
@


1.18
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Clear the location
	of a GOT reloc.
@
text
@d2932 4
a2935 1
  
d2941 1
a2941 1
	  new_flags &= ~(EF_SPARCV9_MM | EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1);
d2943 1
a2943 3
			& (EF_SPARCV9_MM
			   | EF_SPARC_SUN_US1
			   | EF_SPARC_HAL_R1));
d2948 4
a2951 4
	  old_flags |= (new_flags & (EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1));
	  new_flags |= (old_flags & (EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1));
	  if ((old_flags & (EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1))
	      == (EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1))
d3024 4
a3027 2
  
  if (elf_elfheader (abfd)->e_flags & EF_SPARC_SUN_US1)
@


1.17
log
@	* elf64-sparc.c (sparc64_elf_relocate_section): Set relocation address
	for undefined symbols to be the beginning of the section.

	* elf64-sparc.c (sparc64_elf_adjust_dynamic_symbol): Don't allocate
	four extra entries at the beginning of the .rela.plt section.
	(sparc64_elf_finish_dynamic_symbol): Adjust the offset in the .rela.plt
	section to account for the four reserved entries in the .plt section.
@
text
@a2360 1
		  bfd_put_64 (output_bfd, relocation, sgot->contents + off);
d2368 7
d2391 2
@


1.16
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@a1559 6
      /* The first plt entries are reserved, and the relocations must
	 pair up exactly.  */
      if (s->_raw_size == 0)
	s->_raw_size += (PLT_HEADER_SIZE/PLT_ENTRY_SIZE
			 * sizeof (Elf64_External_Rela));

d2076 9
a2084 1
	      relocation = 0;
d2691 5
d2698 1
a2698 1
				  + h->plt.offset));
@


1.15
log
@	* elf64-sparc.c (sparc64_elf_relax_section): New.
	(sparc64_elf_relocate_section): Optimize tail call into branch always
	if possible.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	(elf32_sparc_relax_section): New.
@
text
@d1806 1
@


1.14
log
@	* elf64-sparc.c: Add ATTRIBUTE_UNUSED to unused function parameters.
	Remove unusued variables.
	(sparc64_elf_relocate_section): Change r_symndx type to unsigned long.
	(sparc64_elf_merge_private_bfd_data): Fix shared library case from
	previous fix, so that shared libs really don't influence targets
	extension mask and memory model.
@
text
@d25 1
d69 2
d1859 16
d2416 2
d2493 91
d3076 2
@


1.13
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d215 1
a215 1
     bfd *abfd;
d229 1
a229 1
     bfd *abfd;
d243 1
a243 1
     bfd *abfd;
a268 1
  struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
a502 1
      unsigned int i;
d724 7
a730 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d746 1
a746 1
     char **error_message;
d784 1
a784 1
     char **error_message;
d821 1
a821 1
     char **error_message;
d1266 3
a1268 3
     flagword *flagsp;
     asection **secp;
     bfd_vma *valp;
d1388 1
a1388 1
     bfd *output_bfd;
d1461 1
a1461 1
     bfd *abfd;
d1899 1
a1899 1
      long r_symndx;
d2810 2
a2811 2
	  old_flags &= ~(EF_SPARCV9_MM | EF_SPARC_SUN_US1 | EF_SPARC_HAL_R1);
	  old_flags |= (new_flags
d2864 1
a2864 1
     bfd *abfd;
@


1.12
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2052 3
a2054 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d2061 2
a2062 1
		      (!info->shared || info->no_undefined))))
@


1.12.2.1
log
@Merge from mainline
@
text
@d2052 1
a2052 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d2059 1
a2059 2
		      (!info->shared || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
@


1.11
log
@2000-02-27  Jakub Jelinek  <jakub@@redhat.com>

	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Don't bump
	architecture if the object causing the bump is dynamic.
	* elf64-sparc.c (sparc64_elf_merge_private_bfd_data): Likewise,
	and also don't it for memory ordering.
	(sparc64_elf_write_relocs): Take src_rela out of the loop.
@
text
@d2058 2
a2059 1
		      input_section, rel->r_offset)))
@


1.10
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d478 1
a478 1
  Elf64_External_Rela *outbound_relocas;
d538 1
a542 1
      Elf64_External_Rela *src_rela;
a547 1
      src_rela = outbound_relocas + idx;
d605 1
d2803 34
a2836 19
      old_flags |= (new_flags & (EF_SPARC_SUN_US1|EF_SPARC_HAL_R1));
      new_flags |= (old_flags & (EF_SPARC_SUN_US1|EF_SPARC_HAL_R1));
      if ((old_flags & (EF_SPARC_SUN_US1|EF_SPARC_HAL_R1)) ==
           (EF_SPARC_SUN_US1|EF_SPARC_HAL_R1))
        {
          error = true;
          (*_bfd_error_handler)
            (_("%s: linking UltraSPARC specific with HAL specific code"),
             bfd_get_filename (ibfd));
        }
        
      /* Choose the most restrictive memory ordering */
      old_mm = (old_flags & EF_SPARCV9_MM);
      new_mm = (new_flags & EF_SPARCV9_MM);
      old_flags &= ~EF_SPARCV9_MM;
      new_flags &= ~EF_SPARCV9_MM;
      if (new_mm < old_mm) old_mm = new_mm;
      old_flags |= old_mm;
      new_flags |= old_mm;
@


1.9
log
@1999-08-09  Jakub Jelinek  <jj@@ultra.linux.cz>

	* elf64-sparc.c (sparc64_elf_relocate_section): Back out part of
	the Sep. 4th, 1998 change.  glibc 2.0.x dynamic linker had bug,
	not binutils.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
@
text
@d1755 1
a1755 1
	  _bfd_strip_section_from_output (s);
@


1.8
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elflink.h (elf_bfd_final_link): Copy the whole isym, not just
        some fields.
        * elf64-sparc.c (sparc64_elf_output_arch_syms): Declare used
        variables and initialize them.
@
text
@d2252 1
a2252 9

			/* For non-RELATIVE dynamic relocations, we keep the
			   same symbol, and so generally the same addend.  But
			   we do need to adjust those relocations referencing
			   sections.  */
			outrel.r_addend = rel->r_addend;
			if (r_symndx < symtab_hdr->sh_info
			    && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
			  outrel.r_addend += sec->output_offset+sym->st_value;
@


1.7
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf64-sparc.c (sparc64_elf_build_plt): Cosmetic change - ABI
        wants ba,a,pt %xcc instead of %icc.
        Emit correct .PLT0-(.PLTN+4) initial value into the pointer slots
        of large PLT entries.
        (sparc64_elf_plt_ptr_offset): Fix calculation.
        (sparc64_elf_finish_dynamic_symbol): Negative value of R_SPARC_JMP_SLOT
        addend should be relative to load address, not .plt section start.
        (sparc64_elf_size_info): Sparc64 uses 32bit .hash entries.
@
text
@d1406 2
@


1.6
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf-bfd.h (struct elf_backend_data): Add
        print_symbol_all and output_arch_syms backend methods.
        * elfxx-target.h: Likewise.
        * elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create,
        sparc64_elf_add_symbol_hook, sparc64_elf_output_arch_syms,
        sparc64_elf_get_symbol_type, sparc64_elf_symbol_processing): New
        functions.
        (sparc64_elf_size_dynamic_sections): Leave space for STT_REGISTER
        symbols in .dynsym, add their names into .dynstr. Put those symbols
        into dynlocal.
        (sparc64_elf_finish_dynamic_sections): Fix up DT_SPARC_REGISTER
        pointers to STT_REGISTER symbols in dynsym section.
        (sparc64_elf_print_symbol_all): New function.
        * elf.c (bfd_elf_print_symbol): Allow special backend symbol
        printing using the print_symbol_all hook.
@
text
@d878 2
a879 2
      /* ba,a,pt %icc, plt1 */
      ba = 0x30480000 | (((contents+PLT_ENTRY_SIZE) - (entry+4)) / 4 & 0x7ffff);
d916 1
a916 1
	  bfd_put_64 (output_bfd, contents - entry+4, ptr);
d951 7
a957 3
  block = (index - LARGE_PLT_THRESHOLD) / 160;
  ofs = (index - LARGE_PLT_THRESHOLD) % 160;
  last = (max - LARGE_PLT_THRESHOLD) % 160;
d959 1
a959 1
  return ((LARGE_PLT_THRESHOLD + block*160) * PLT_ENTRY_SIZE
d2573 2
a2574 1
	  rela.r_addend = -(sparc64_elf_plt_entry_offset (h->plt.offset) + 4);
d2904 1
a2904 1
  8,		/* hash-table entry size */
@


1.5
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf64-sparc.c (sparc64_elf_info_to_howto): Use ELF64_R_TYPE_ID.
        (sparc64_elf_get_reloc_upper_bound,
        sparc64_elf_get_dynamic_reloc_upper_bound,
        sparc64_elf_slurp_one_reloc_table, sparc64_elf_slurp_reloc_table,
        sparc64_elf_canonicalize_dynamic_reloc, sparc64_elf_write_relocs):
        New functions.
        (sparc64_elf_check_relocs, sparc64_elf_relocate_section): Use
        ELF64_R_TYPE_ID/DATA where appropriate.
@
text
@d35 2
d56 7
d608 46
d1254 215
d1768 5
d1799 47
d2671 1
d2702 11
d2842 2
d2845 25
d2934 3
d2950 6
d2968 4
@


1.4
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf64-sparc.c (sparc64_elf_size_dynamic_sections): Remove
        DT_SPARC_PLTFMT.
@
text
@d62 9
d223 374
a596 2
  BFD_ASSERT (ELF64_R_TYPE (dst->r_info) < (unsigned int) R_SPARC_max_std);
  cache_ptr->howto = &sparc64_elf_howto_table[ELF64_R_TYPE (dst->r_info)];
d952 1
a952 1
      switch (ELF64_R_TYPE (rel->r_info))
d1191 1
a1191 1
				ELF64_R_TYPE (rel->r_info));
d1579 1
a1579 1
      r_type = ELF64_R_TYPE (rel->r_info);
d1865 5
a1869 1
		    outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d1919 5
a1923 1
			outrel.r_info = ELF64_R_INFO (indx, r_type);
d1947 1
a1947 1
		    || ELF64_R_TYPE (outrel.r_info) != R_SPARC_RELATIVE)
d2523 39
d2575 6
d2602 2
@


1.3
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d1128 1
a1128 3
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_SPARC_PLTFMT,
						(info->shared != 0) + 1))
@


1.2
log
@Jakub Jelinek  <jj@@ultra.linux.cz>
        * elf64_sparc.c (sparc64_elf_relocate_section): Use R_SPARC_max_std
        instead of R_SPARC_max.
        (sparc64_elf_info_to_howto): Likewise.
        * elf32_sparc.c (elf32_sparc_relocate_section): Likewise.
        (elf32_sparc_info_to_howto): Likewise; handle vtable relocations.
@
text
@a53 2
static boolean sparc64_elf_adjust_dynindx
  PARAMS((struct elf_link_hash_entry *, PTR));
a1146 45
  /* If we are generating a shared library, we generate a section
     symbol for each output section for which we might need to copy
     relocs.  These are local symbols, which means that they must come
     first in the dynamic symbol table.  That means we must increment
     the dynamic symbol index of every other dynamic symbol.  */
  if (info->shared)
    {
      int c;

      c = 0;
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LINKER_CREATED) != 0
	      || (s->flags & SEC_ALLOC) == 0)
	    continue;

	  elf_section_data (s)->dynindx = c + 1;

	  /* These symbols will have no names, so we don't need to
             fiddle with dynstr_index.  */

	  ++c;
	}

      elf_link_hash_traverse (elf_hash_table (info),
			      sparc64_elf_adjust_dynindx,
			      (PTR) &c);
      elf_hash_table (info)->dynsymcount += c;
    }

  return true;
}

/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
sparc64_elf_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  int *cp = (int *) cparg;

  if (h->dynindx != -1)
    h->dynindx += *cp;
a1148 1

a2043 44

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;
      int c;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;

      c = 0;
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx;

	  if (elf_section_data (s)->dynindx == 0)
	    continue;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  BFD_ASSERT (indx > 0);
	  sym.st_shndx = indx;

	  bfd_elf64_swap_symbol_out (output_bfd, &sym,
				     (PTR) (((Elf64_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));

	  ++c;
	}

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info = c + 1;
    }
@


1.1
log
@Initial revision
@
text
@d216 1
a216 1
  BFD_ASSERT (ELF64_R_TYPE (dst->r_info) < (unsigned int) R_SPARC_max);
d1249 1
a1249 1
      if (r_type < 0 || r_type >= (int) R_SPARC_max)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

