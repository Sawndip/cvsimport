head	1.154;
access;
symbols
	sid-snapshot-20180601:1.154
	sid-snapshot-20180501:1.154
	sid-snapshot-20180401:1.154
	sid-snapshot-20180301:1.154
	sid-snapshot-20180201:1.154
	sid-snapshot-20180101:1.154
	sid-snapshot-20171201:1.154
	sid-snapshot-20171101:1.154
	sid-snapshot-20171001:1.154
	sid-snapshot-20170901:1.154
	sid-snapshot-20170801:1.154
	sid-snapshot-20170701:1.154
	sid-snapshot-20170601:1.154
	sid-snapshot-20170501:1.154
	sid-snapshot-20170401:1.154
	sid-snapshot-20170301:1.154
	sid-snapshot-20170201:1.154
	sid-snapshot-20170101:1.154
	sid-snapshot-20161201:1.154
	sid-snapshot-20161101:1.154
	sid-snapshot-20160901:1.154
	sid-snapshot-20160801:1.154
	sid-snapshot-20160701:1.154
	sid-snapshot-20160601:1.154
	sid-snapshot-20160501:1.154
	sid-snapshot-20160401:1.154
	sid-snapshot-20160301:1.154
	sid-snapshot-20160201:1.154
	sid-snapshot-20160101:1.154
	sid-snapshot-20151201:1.154
	sid-snapshot-20151101:1.154
	sid-snapshot-20151001:1.154
	sid-snapshot-20150901:1.154
	sid-snapshot-20150801:1.154
	sid-snapshot-20150701:1.154
	sid-snapshot-20150601:1.154
	sid-snapshot-20150501:1.154
	sid-snapshot-20150401:1.154
	sid-snapshot-20150301:1.154
	sid-snapshot-20150201:1.154
	sid-snapshot-20150101:1.154
	sid-snapshot-20141201:1.154
	sid-snapshot-20141101:1.154
	sid-snapshot-20141001:1.154
	sid-snapshot-20140901:1.154
	sid-snapshot-20140801:1.154
	sid-snapshot-20140701:1.154
	sid-snapshot-20140601:1.154
	sid-snapshot-20140501:1.154
	sid-snapshot-20140401:1.154
	sid-snapshot-20140301:1.154
	sid-snapshot-20140201:1.154
	sid-snapshot-20140101:1.154
	sid-snapshot-20131201:1.154
	sid-snapshot-20131101:1.154
	sid-snapshot-20131001:1.154
	binutils-2_24-branch:1.154.0.2
	binutils-2_24-branchpoint:1.154
	binutils-2_21_1:1.138.2.1
	sid-snapshot-20130901:1.154
	gdb_7_6_1-2013-08-30-release:1.153
	sid-snapshot-20130801:1.154
	sid-snapshot-20130701:1.154
	sid-snapshot-20130601:1.154
	sid-snapshot-20130501:1.153
	gdb_7_6-2013-04-26-release:1.153
	sid-snapshot-20130401:1.153
	binutils-2_23_2:1.150
	gdb_7_6-branch:1.153.0.2
	gdb_7_6-2013-03-12-branchpoint:1.153
	sid-snapshot-20130301:1.153
	sid-snapshot-20130201:1.153
	sid-snapshot-20130101:1.152
	sid-snapshot-20121201:1.152
	gdb_7_5_1-2012-11-29-release:1.148
	binutils-2_23_1:1.150
	sid-snapshot-20121101:1.151
	binutils-2_23:1.150
	sid-snapshot-20121001:1.151
	sid-snapshot-20120901:1.151
	gdb_7_5-2012-08-17-release:1.148
	sid-snapshot-20120801:1.151
	binutils-2_23-branch:1.150.0.2
	binutils-2_23-branchpoint:1.150
	gdb_7_5-branch:1.148.0.2
	gdb_7_5-2012-07-18-branchpoint:1.148
	sid-snapshot-20120701:1.148
	sid-snapshot-20120601:1.148
	sid-snapshot-20120501:1.146
	binutils-2_22_branch:1.142.0.4
	gdb_7_4_1-2012-04-26-release:1.143
	sid-snapshot-20120401:1.145
	sid-snapshot-20120301:1.145
	sid-snapshot-20120201:1.145
	gdb_7_4-2012-01-24-release:1.143
	sid-snapshot-20120101:1.144
	gdb_7_4-branch:1.143.0.2
	gdb_7_4-2011-12-13-branchpoint:1.143
	sid-snapshot-20111201:1.143
	binutils-2_22:1.142
	sid-snapshot-20111101:1.143
	sid-snapshot-20111001:1.143
	binutils-2_22-branch:1.142.0.2
	binutils-2_22-branchpoint:1.142
	gdb_7_3_1-2011-09-04-release:1.139
	sid-snapshot-20110901:1.142
	sid-snapshot-20110801:1.142
	gdb_7_3-2011-07-26-release:1.139
	sid-snapshot-20110701:1.141
	sid-snapshot-20110601:1.141
	sid-snapshot-20110501:1.141
	gdb_7_3-branch:1.139.0.2
	gdb_7_3-2011-04-01-branchpoint:1.139
	sid-snapshot-20110401:1.139
	sid-snapshot-20110301:1.138
	sid-snapshot-20110201:1.138
	sid-snapshot-20110101:1.138
	binutils-2_21:1.138
	sid-snapshot-20101201:1.138
	binutils-2_21-branch:1.138.0.2
	binutils-2_21-branchpoint:1.138
	sid-snapshot-20101101:1.138
	sid-snapshot-20101001:1.137
	binutils-2_20_1:1.122.4.3
	gdb_7_2-2010-09-02-release:1.136
	sid-snapshot-20100901:1.137
	sid-snapshot-20100801:1.137
	gdb_7_2-branch:1.136.0.2
	gdb_7_2-2010-07-07-branchpoint:1.136
	sid-snapshot-20100701:1.134
	sid-snapshot-20100601:1.134
	sid-snapshot-20100501:1.134
	sid-snapshot-20100401:1.132
	gdb_7_1-2010-03-18-release:1.130
	sid-snapshot-20100301:1.130
	gdb_7_1-branch:1.130.0.2
	gdb_7_1-2010-02-18-branchpoint:1.130
	sid-snapshot-20100201:1.130
	sid-snapshot-20100101:1.126
	gdb_7_0_1-2009-12-22-release:1.123
	sid-snapshot-20091201:1.124
	sid-snapshot-20091101:1.124
	binutils-2_20:1.122.4.2
	gdb_7_0-2009-10-06-release:1.123
	sid-snapshot-20091001:1.124
	gdb_7_0-branch:1.123.0.2
	gdb_7_0-2009-09-16-branchpoint:1.123
	arc-sim-20090309:1.107
	binutils-arc-20081103-branch:1.114.0.6
	binutils-arc-20081103-branchpoint:1.114
	binutils-2_20-branch:1.122.0.4
	binutils-2_20-branchpoint:1.122
	sid-snapshot-20090901:1.122
	sid-snapshot-20090801:1.122
	msnyder-checkpoint-072509-branch:1.122.0.2
	msnyder-checkpoint-072509-branchpoint:1.122
	sid-snapshot-20090701:1.120
	dje-cgen-play1-branch:1.120.0.2
	dje-cgen-play1-branchpoint:1.120
	sid-snapshot-20090601:1.120
	sid-snapshot-20090501:1.120
	sid-snapshot-20090401:1.120
	arc-20081103-branch:1.114.0.4
	arc-20081103-branchpoint:1.114
	arc-insight_6_8-branch:1.107.0.6
	arc-insight_6_8-branchpoint:1.107
	insight_6_8-branch:1.107.0.4
	insight_6_8-branchpoint:1.107
	sid-snapshot-20090301:1.118
	binutils-2_19_1:1.113.2.1
	sid-snapshot-20090201:1.118
	sid-snapshot-20090101:1.116
	reverse-20081226-branch:1.116.0.4
	reverse-20081226-branchpoint:1.116
	sid-snapshot-20081201:1.116
	multiprocess-20081120-branch:1.116.0.2
	multiprocess-20081120-branchpoint:1.116
	sid-snapshot-20081101:1.114
	binutils-2_19:1.113.2.1
	sid-snapshot-20081001:1.114
	reverse-20080930-branch:1.114.0.2
	reverse-20080930-branchpoint:1.114
	binutils-2_19-branch:1.113.0.2
	binutils-2_19-branchpoint:1.113
	sid-snapshot-20080901:1.111
	sid-snapshot-20080801:1.111
	reverse-20080717-branch:1.111.0.2
	reverse-20080717-branchpoint:1.111
	sid-snapshot-20080701:1.108
	msnyder-reverse-20080609-branch:1.108.0.2
	msnyder-reverse-20080609-branchpoint:1.108
	drow-reverse-20070409-branch:1.92.0.2
	drow-reverse-20070409-branchpoint:1.92
	sid-snapshot-20080601:1.108
	sid-snapshot-20080501:1.107
	sid-snapshot-20080403:1.107
	sid-snapshot-20080401:1.107
	gdb_6_8-2008-03-27-release:1.107
	sid-snapshot-20080301:1.107
	gdb_6_8-branch:1.107.0.2
	gdb_6_8-2008-02-26-branchpoint:1.107
	sid-snapshot-20080201:1.102
	sid-snapshot-20080101:1.102
	sid-snapshot-20071201:1.102
	sid-snapshot-20071101:1.102
	gdb_6_7_1-2007-10-29-release:1.101
	gdb_6_7-2007-10-10-release:1.101
	sid-snapshot-20071001:1.102
	gdb_6_7-branch:1.101.0.2
	gdb_6_7-2007-09-07-branchpoint:1.101
	binutils-2_18:1.99
	binutils-2_18-branch:1.99.0.2
	binutils-2_18-branchpoint:1.99
	insight_6_6-20070208-release:1.91
	binutils-csl-coldfire-4_1-32:1.87
	binutils-csl-sourcerygxx-4_1-32:1.87
	gdb_6_6-2006-12-18-release:1.91
	binutils-csl-innovasic-fido-3_4_4-33:1.87
	binutils-csl-sourcerygxx-3_4_4-32:1.62
	binutils-csl-coldfire-4_1-30:1.87
	binutils-csl-sourcerygxx-4_1-30:1.87
	binutils-csl-coldfire-4_1-28:1.87
	binutils-csl-sourcerygxx-4_1-29:1.87
	binutils-csl-sourcerygxx-4_1-28:1.87
	gdb_6_6-branch:1.91.0.2
	gdb_6_6-2006-11-15-branchpoint:1.91
	binutils-csl-arm-2006q3-27:1.87
	binutils-csl-sourcerygxx-4_1-27:1.87
	binutils-csl-arm-2006q3-26:1.87
	binutils-csl-sourcerygxx-4_1-26:1.87
	binutils-csl-sourcerygxx-4_1-25:1.87
	binutils-csl-sourcerygxx-4_1-24:1.87
	binutils-csl-sourcerygxx-4_1-23:1.87
	insight_6_5-20061003-release:1.89
	gdb-csl-symbian-6_4_50_20060226-12:1.84
	binutils-csl-sourcerygxx-4_1-21:1.87
	binutils-csl-arm-2006q3-21:1.87
	binutils-csl-sourcerygxx-4_1-22:1.87
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.87
	binutils-csl-sourcerygxx-4_1-20:1.87
	binutils-csl-arm-2006q3-19:1.87
	binutils-csl-sourcerygxx-4_1-19:1.87
	binutils-csl-sourcerygxx-4_1-18:1.87
	binutils-csl-renesas-4_1-9:1.87
	gdb-csl-sourcerygxx-3_4_4-25:1.81
	binutils-csl-sourcerygxx-3_4_4-25:1.62
	nickrob-async-20060828-mergepoint:1.89
	gdb-csl-symbian-6_4_50_20060226-11:1.84
	binutils-csl-renesas-4_1-8:1.87
	binutils-csl-renesas-4_1-7:1.87
	binutils-csl-renesas-4_1-6:1.87
	gdb-csl-sourcerygxx-4_1-17:1.84
	binutils-csl-sourcerygxx-4_1-17:1.87
	gdb-csl-20060226-branch-local-2:1.84
	gdb-csl-sourcerygxx-4_1-14:1.84
	binutils-csl-sourcerygxx-4_1-14:1.87
	binutils-csl-sourcerygxx-4_1-15:1.87
	gdb-csl-sourcerygxx-4_1-13:1.84
	binutils-csl-sourcerygxx-4_1-13:1.87
	binutils-2_17:1.87
	gdb-csl-sourcerygxx-4_1-12:1.84
	binutils-csl-sourcerygxx-4_1-12:1.87
	gdb-csl-sourcerygxx-3_4_4-21:1.84
	binutils-csl-sourcerygxx-3_4_4-21:1.87
	gdb_6_5-20060621-release:1.89
	binutils-csl-wrs-linux-3_4_4-24:1.62
	binutils-csl-wrs-linux-3_4_4-23:1.62
	gdb-csl-sourcerygxx-4_1-9:1.84
	binutils-csl-sourcerygxx-4_1-9:1.87
	gdb-csl-sourcerygxx-4_1-8:1.84
	binutils-csl-sourcerygxx-4_1-8:1.87
	gdb-csl-sourcerygxx-4_1-7:1.84
	binutils-csl-sourcerygxx-4_1-7:1.87
	gdb-csl-arm-2006q1-6:1.84
	binutils-csl-arm-2006q1-6:1.87
	gdb-csl-sourcerygxx-4_1-6:1.84
	binutils-csl-sourcerygxx-4_1-6:1.87
	binutils-csl-wrs-linux-3_4_4-22:1.62
	gdb-csl-symbian-6_4_50_20060226-10:1.84
	gdb-csl-symbian-6_4_50_20060226-9:1.84
	gdb-csl-symbian-6_4_50_20060226-8:1.84
	gdb-csl-coldfire-4_1-11:1.84
	binutils-csl-coldfire-4_1-11:1.87
	gdb-csl-sourcerygxx-3_4_4-19:1.84
	binutils-csl-sourcerygxx-3_4_4-19:1.87
	gdb-csl-coldfire-4_1-10:1.84
	gdb_6_5-branch:1.89.0.4
	gdb_6_5-2006-05-14-branchpoint:1.89
	binutils-csl-coldfire-4_1-10:1.87
	gdb-csl-sourcerygxx-4_1-5:1.84
	binutils-csl-sourcerygxx-4_1-5:1.87
	nickrob-async-20060513-branch:1.89.0.2
	nickrob-async-20060513-branchpoint:1.89
	gdb-csl-sourcerygxx-4_1-4:1.84
	binutils-csl-sourcerygxx-4_1-4:1.87
	msnyder-reverse-20060502-branch:1.87.0.10
	msnyder-reverse-20060502-branchpoint:1.87
	binutils-csl-wrs-linux-3_4_4-21:1.62
	gdb-csl-morpho-4_1-4:1.84
	binutils-csl-morpho-4_1-4:1.87
	gdb-csl-sourcerygxx-3_4_4-17:1.84
	binutils-csl-sourcerygxx-3_4_4-17:1.87
	binutils-csl-wrs-linux-3_4_4-20:1.62
	readline_5_1-import-branch:1.87.0.8
	readline_5_1-import-branchpoint:1.87
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.84
	binutils-2_17-branch:1.87.0.6
	binutils-2_17-branchpoint:1.87
	gdb-csl-symbian-20060226-branch:1.84.0.6
	gdb-csl-symbian-20060226-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.84
	msnyder-reverse-20060331-branch:1.87.0.4
	msnyder-reverse-20060331-branchpoint:1.87
	binutils-csl-2_17-branch:1.87.0.2
	binutils-csl-2_17-branchpoint:1.87
	gdb-csl-available-20060303-branch:1.84.0.4
	gdb-csl-available-20060303-branchpoint:1.84
	gdb-csl-20060226-branch:1.84.0.2
	gdb-csl-20060226-branchpoint:1.84
	gdb_6_4-20051202-release:1.81
	msnyder-fork-checkpoint-branch:1.81.0.8
	msnyder-fork-checkpoint-branchpoint:1.81
	gdb-csl-gxxpro-6_3-branch:1.81.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.81
	gdb_6_4-branch:1.81.0.4
	gdb_6_4-2005-11-01-branchpoint:1.81
	gdb-csl-arm-20051020-branch:1.81.0.2
	gdb-csl-arm-20051020-branchpoint:1.81
	binutils-csl-gxxpro-3_4-branch:1.62.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.62
	binutils-2_16_1:1.62
	msnyder-tracepoint-checkpoint-branch:1.69.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.69
	gdb-csl-arm-20050325-2005-q1b:1.63
	binutils-csl-arm-2005q1b:1.62
	binutils-2_16:1.62
	gdb-csl-arm-20050325-2005-q1a:1.63
	binutils-csl-arm-2005q1a:1.62
	csl-arm-20050325-branch:1.63.0.2
	csl-arm-20050325-branchpoint:1.63
	binutils-csl-arm-2005q1-branch:1.62.0.4
	binutils-csl-arm-2005q1-branchpoint:1.62
	binutils-2_16-branch:1.62.0.2
	binutils-2_16-branchpoint:1.62
	csl-arm-2004-q3d:1.58
	gdb_6_3-20041109-release:1.58
	gdb_6_3-branch:1.58.0.2
	gdb_6_3-20041019-branchpoint:1.58
	csl-arm-2004-q3:1.58
	drow_intercu-merge-20040921:1.57
	drow_intercu-merge-20040915:1.57
	jimb-gdb_6_2-e500-branch:1.57.0.6
	jimb-gdb_6_2-e500-branchpoint:1.57
	gdb_6_2-20040730-release:1.57
	gdb_6_2-branch:1.57.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.57
	gdb_6_1_1-20040616-release:1.53
	binutils-2_15:1.53.6.2
	binutils-2_15-branchpoint:1.53
	csl-arm-2004-q1a:1.54
	csl-arm-2004-q1:1.54
	gdb_6_1-2004-04-05-release:1.53
	drow_intercu-merge-20040402:1.54
	drow_intercu-merge-20040327:1.54
	ezannoni_pie-20040323-branch:1.54.0.2
	ezannoni_pie-20040323-branchpoint:1.54
	cagney_tramp-20040321-mergepoint:1.54
	cagney_tramp-20040309-branch:1.53.0.12
	cagney_tramp-20040309-branchpoint:1.53
	gdb_6_1-branch:1.53.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.53
	drow_intercu-20040221-branch:1.53.0.8
	drow_intercu-20040221-branchpoint:1.53
	binutils-2_15-branch:1.53.0.6
	cagney_bfdfile-20040213-branch:1.53.0.4
	cagney_bfdfile-20040213-branchpoint:1.53
	drow-cplus-merge-20040208:1.53
	carlton_dictionary-20040126-merge:1.53
	cagney_bigcore-20040122-branch:1.53.0.2
	cagney_bigcore-20040122-branchpoint:1.53
	drow-cplus-merge-20040113:1.53
	csl-arm-2003-q4:1.52
	drow-cplus-merge-20031224:1.52
	drow-cplus-merge-20031220:1.52
	carlton_dictionary-20031215-merge:1.52
	drow-cplus-merge-20031214:1.52
	carlton-dictionary-20031111-merge:1.51
	gdb_6_0-2003-10-04-release:1.49
	kettenis_sparc-20030918-branch:1.49.0.24
	kettenis_sparc-20030918-branchpoint:1.49
	carlton_dictionary-20030917-merge:1.49
	ezannoni_pie-20030916-branchpoint:1.49
	ezannoni_pie-20030916-branch:1.49.0.22
	cagney_x86i386-20030821-branch:1.49.0.20
	cagney_x86i386-20030821-branchpoint:1.49
	carlton_dictionary-20030805-merge:1.49
	carlton_dictionary-20030627-merge:1.49
	gdb_6_0-branch:1.49.0.18
	gdb_6_0-2003-06-23-branchpoint:1.49
	jimb-ppc64-linux-20030613-branch:1.49.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.49
	binutils-2_14:1.49
	cagney_convert-20030606-branch:1.49.0.14
	cagney_convert-20030606-branchpoint:1.49
	cagney_writestrings-20030508-branch:1.49.0.12
	cagney_writestrings-20030508-branchpoint:1.49
	jimb-ppc64-linux-20030528-branch:1.49.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.49
	carlton_dictionary-20030523-merge:1.49
	cagney_fileio-20030521-branch:1.49.0.8
	cagney_fileio-20030521-branchpoint:1.49
	kettenis_i386newframe-20030517-mergepoint:1.49
	jimb-ppc64-linux-20030509-branch:1.49.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.49
	kettenis_i386newframe-20030504-mergepoint:1.49
	carlton_dictionary-20030430-merge:1.49
	binutils-2_14-branch:1.49.0.4
	binutils-2_14-branchpoint:1.49
	kettenis_i386newframe-20030419-branch:1.49.0.2
	kettenis_i386newframe-20030419-branchpoint:1.49
	carlton_dictionary-20030416-merge:1.49
	cagney_frameaddr-20030409-mergepoint:1.48
	kettenis_i386newframe-20030406-branch:1.47.0.4
	kettenis_i386newframe-20030406-branchpoint:1.47
	cagney_frameaddr-20030403-branchpoint:1.47
	cagney_frameaddr-20030403-branch:1.47.0.2
	cagney_framebase-20030330-mergepoint:1.42
	cagney_framebase-20030326-branch:1.42.0.14
	cagney_framebase-20030326-branchpoint:1.42
	cagney_lazyid-20030317-branch:1.42.0.12
	cagney_lazyid-20030317-branchpoint:1.42
	kettenis-i386newframe-20030316-mergepoint:1.42
	offbyone-20030313-branch:1.42.0.10
	offbyone-20030313-branchpoint:1.42
	kettenis-i386newframe-20030308-branch:1.42.0.8
	kettenis-i386newframe-20030308-branchpoint:1.42
	carlton_dictionary-20030305-merge:1.42
	cagney_offbyone-20030303-branch:1.42.0.6
	cagney_offbyone-20030303-branchpoint:1.42
	carlton_dictionary-20030207-merge:1.42
	interps-20030202-branch:1.42.0.4
	interps-20030202-branchpoint:1.42
	cagney-unwind-20030108-branch:1.42.0.2
	cagney-unwind-20030108-branchpoint:1.42
	binutils-2_13_2_1:1.32.2.2
	binutils-2_13_2:1.32.2.2
	carlton_dictionary-20021223-merge:1.42
	gdb_5_3-2002-12-12-release:1.33
	carlton_dictionary-20021115-merge:1.40
	binutils-2_13_1:1.32.2.2
	kseitz_interps-20021105-merge:1.38
	kseitz_interps-20021103-merge:1.38
	drow-cplus-merge-20021020:1.36
	drow-cplus-merge-20021025:1.37
	carlton_dictionary-20021025-merge:1.38
	carlton_dictionary-20021011-merge:1.36
	drow-cplus-branch:1.36.0.2
	drow-cplus-branchpoint:1.36
	kseitz_interps-20020930-merge:1.36
	carlton_dictionary-20020927-merge:1.36
	carlton_dictionary-branch:1.34.0.2
	carlton_dictionary-20020920-branchpoint:1.34
	sid-20020905-branchpoint:1.33
	sid-20020905-branch:1.33.0.8
	gdb_5_3-branch:1.33.0.6
	gdb_5_3-2002-09-04-branchpoint:1.33
	kseitz_interps-20020829-merge:1.33
	cagney_sysregs-20020825-branch:1.33.0.4
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.2
	readline_4_3-import-branchpoint:1.33
	binutils-2_13:1.32
	gdb_5_2_1-2002-07-23-release:1.28
	binutils-2_13-branchpoint:1.32
	binutils-2_13-branch:1.32.0.2
	kseitz_interps-20020528-branch:1.30.0.6
	kseitz_interps-20020528-branchpoint:1.30
	cagney_regbuf-20020515-branch:1.30.0.4
	cagney_regbuf-20020515-branchpoint:1.30
	binutils-2_12_1:1.28.2.2
	jimb-macro-020506-branch:1.30.0.2
	jimb-macro-020506-branchpoint:1.30
	gdb_5_2-2002-04-29-release:1.28
	binutils-2_12:1.28
	gdb_5_2-branch:1.28.0.4
	gdb_5_2-2002-03-03-branchpoint:1.28
	binutils-2_12-branch:1.28.0.2
	binutils-2_12-branchpoint:1.28
	gdb_5_1_1-2002-01-24-release:1.20
	gdb_5_1_0_1-2002-01-03-release:1.20
	cygnus_cvs_20020108_pre:1.27
	gdb_5_1_0_1-2002-01-03-branch:1.20.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.20
	gdb_5_1-2001-11-21-release:1.20
	gdb_s390-2001-09-26-branch:1.20.0.4
	gdb_s390-2001-09-26-branchpoint:1.20
	gdb_5_1-2001-07-29-branch:1.20.0.2
	gdb_5_1-2001-07-29-branchpoint:1.20
	binutils-2_11_2:1.18.2.2
	binutils-2_11_1:1.18.2.2
	binutils-2_11:1.18
	x86_64versiong3:1.18
	binutils-2_11-branch:1.18.0.2
	insight-precleanup-2001-01-01:1.17
	binutils-2_10_1:1.12.2.1
	binutils-2_10:1.12.2.1
	gdb-premipsmulti-2000-06-06-branch:1.14.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.14
	gdb_5_0-2000-05-19-release:1.13
	gdb_4_18_2-2000-05-18-release:1.13
	gdb_4_95_1-2000-05-11-snapshot:1.13
	gdb_4_95_0-2000-04-27-snapshot:1.13
	gdb_5_0-2000-04-10-branch:1.13.0.2
	gdb_5_0-2000-04-10-branchpoint:1.13
	binutils-2_10-branch:1.12.0.2
	binutils-2_10-branchpoint:1.12
	binutils_latest_snapshot:1.154
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.9
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.154
date	2013.05.29.14.58.35;	author nickc;	state Exp;
branches;
next	1.153;

1.153
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2012.11.09.08.29.29;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2012.08.01.01.29.12;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2012.07.26.18.20.39;	author ccoutant;	state Exp;
branches;
next	1.149;

1.149
date	2012.07.24.21.06.57;	author ccoutant;	state Exp;
branches;
next	1.148;

1.148
date	2012.05.16.13.57.11;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2012.05.03.12.49.22;	author gingold;	state Exp;
branches;
next	1.146;

1.146
date	2012.04.27.19.03.04;	author mark;	state Exp;
branches;
next	1.145;

1.145
date	2012.01.04.08.44.04;	author gingold;	state Exp;
branches;
next	1.144;

1.144
date	2011.12.13.14.02.17;	author gingold;	state Exp;
branches;
next	1.143;

1.143
date	2011.09.30.10.39.44;	author gingold;	state Exp;
branches;
next	1.142;

1.142
date	2011.07.26.21.31.37;	author jakub;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.28.12.50.32;	author vapier;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.07.17.47.23;	author ccoutant;	state Exp;
branches;
next	1.139;

1.139
date	2011.03.03.23.43.08;	author msnyder;	state Exp;
branches;
next	1.138;

1.138
date	2010.10.29.12.10.23;	author hjl;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2010.07.14.22.18.07;	author ccoutant;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.06.21.13.57;	author hjl;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.03.20.52.22;	author ccoutant;	state Exp;
branches;
next	1.134;

1.134
date	2010.04.20.09.53.05;	author jakub;	state Exp;
branches;
next	1.133;

1.133
date	2010.04.05.19.29.35;	author jakub;	state Exp;
branches;
next	1.132;

1.132
date	2010.04.01.05.24.52;	author jakub;	state Exp;
branches;
next	1.131;

1.131
date	2010.03.04.04.01.53;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2010.01.19.23.17.57;	author ccoutant;	state Exp;
branches;
next	1.129;

1.129
date	2010.01.11.09.43.08;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.11.08.36.19;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2010.01.04.11.44.30;	author brobecke;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.31.14.10.29;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2009.09.24.00.11.51;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	2009.07.10.15.26.56;	author tromey;	state Exp;
branches
	1.122.4.1;
next	1.121;

1.121
date	2009.07.03.17.02.43;	author davek;	state Exp;
branches;
next	1.120;

1.120
date	2009.03.16.12.41.26;	author ams;	state Exp;
branches;
next	1.119;

1.119
date	2009.03.12.10.57.18;	author ams;	state Exp;
branches;
next	1.118;

1.118
date	2009.01.30.01.04.47;	author nemet;	state Exp;
branches;
next	1.117;

1.117
date	2009.01.22.08.54.20;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2008.11.18.14.05.00;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	2008.11.10.23.39.19;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2008.09.08.21.58.29;	author drow;	state Exp;
branches;
next	1.113;

1.113
date	2008.09.05.17.55.07;	author drow;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2008.09.05.17.48.08;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2008.07.14.00.10.09;	author csilvers;	state Exp;
branches;
next	1.110;

1.110
date	2008.07.11.09.18.19;	author schwab;	state Exp;
branches;
next	1.109;

1.109
date	2008.07.10.01.32.22;	author csilvers;	state Exp;
branches;
next	1.108;

1.108
date	2008.05.21.11.46.42;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.22.15.27.38;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.20.15.56.33;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.16.10.51.38;	author nathan;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.12.00.25.59;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2007.09.21.16.16.17;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.02.13.29.20;	author hjl;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.01.06.09.20;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.26.08.31.03;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2007.07.19.16.51.10;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.26.14.28.13;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.23.08.40.54;	author schwab;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.22.08.13.12;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.23.17.38.07;	author carlos;	state Exp;
branches;
next	1.91;

1.91
date	2006.09.17.02.44.38;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.02.10.01.56;	author bje;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.11.15.01.18;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.06.04.52.03;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.06.01.36.52;	author hjl;	state Exp;
branches;
next	1.84;

1.84
date	2006.02.15.22.29.42;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.17.17.12.58;	author hjl;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.27.16.07.36;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.22.19.50.27;	author wilson;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.20.18.13.32;	author wilson;	state Exp;
branches;
next	1.79;

1.79
date	2005.08.17.14.28.00;	author hjl;	state Exp;
branches;
next	1.78;

1.78
date	2005.08.10.23.33.39;	author wilson;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.07.14.47.02;	author fnf;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.08.21.42.33;	author pkoning;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.06.13.43.21;	author hjl;	state Exp;
branches;
next	1.74;

1.74
date	2005.06.10.10.14.23;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2005.06.09.13.32.30;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2005.06.06.14.28.30;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.06.14.16.45;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2005.06.04.16.33.09;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.23.17.44.52;	author fnf;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.05.14.25.22;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.04.15.53.06;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.03.20.36.37;	author fnf;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.29.20.10.42;	author fnf;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.17.08.24.28;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.21.18.00.17;	author fnf;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.17.17.11.59;	author hjl;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.05.10.37.05;	author fnf;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.24.07.07.19;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.21.01.58.03;	author bje;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.07.00.01.25;	author zack;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.15.14.21.42;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.12.05.34.16;	author amodra;	state Exp;
branches
	1.53.6.1
	1.53.8.1
	1.53.12.1;
next	1.52;

1.52
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.30.09.50.02;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.19.09.01.53;	author nathan;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.16.00.30.24;	author aoliva;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.09.09.56.17;	author aoliva;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.01.10.49.02;	author bje;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2003.04.01.10.31.34;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.01.10.18.54;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.01.00.12.12;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.12.10.26.01;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.07.22.19.59;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.07.14.36.31;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.23.12.41.32;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.24.07.11.16;	author nickc;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2002.09.23.16.13.52;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.20.07.28.54;	author nickc;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.07.17.12.17.18;	author rearnsha;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.27.11.51.42;	author amodra;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2002.06.25.19.10.00;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.04.12.01.02;	author amodra;	state Exp;
branches
	1.30.6.1;
next	1.29;

1.29
date	2002.03.20.19.15.30;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.30.10.28.47;	author nickc;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.11.14.11.16.47;	author jakub;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.13.23.37.41;	author rth;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.13.20.13.29;	author geoffk;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.06.10.01.09;	author ciceron;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.08.11.17.34;	author aoliva;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.21.11.52.42;	author aj;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.23.20.27.53;	author kazu;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.16.19.29.48;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.02.20.21.40;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.19.10.53.01;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.07.18.36.04;	author wilson;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.28.03.39.28;	author ian;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.02.23.22.29.38;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.23.22.27.55;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.07.14.08.49.38;	author mmitchel;	state Exp;
branches;
next	1.8;

1.8
date	99.07.11.19.49.30;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.02.21.03.50;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	99.06.26.16.05.58;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.06.26.15.48.47;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.06.10.21.28.56;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.02.46.47;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.05.06.17.12.02;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.138.2.1
date	2011.05.29.04.51.06;	author amodra;	state Exp;
branches;
next	;

1.122.4.1
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	1.122.4.2;

1.122.4.2
date	2009.09.24.00.16.31;	author amodra;	state Exp;
branches;
next	1.122.4.3;

1.122.4.3
date	2010.01.11.08.37.17;	author amodra;	state Exp;
branches;
next	;

1.113.2.1
date	2008.09.19.04.03.00;	author drow;	state Exp;
branches;
next	1.113.2.2;

1.113.2.2
date	2009.03.02.13.38.34;	author amodra;	state Exp;
branches;
next	1.113.2.3;

1.113.2.3
date	2009.03.02.13.50.55;	author amodra;	state Exp;
branches;
next	;

1.53.6.1
date	2004.03.15.14.26.08;	author amodra;	state Exp;
branches;
next	1.53.6.2;

1.53.6.2
date	2004.05.06.23.56.56;	author zack;	state Exp;
branches;
next	;

1.53.8.1
date	2004.03.27.17.37.30;	author drow;	state Exp;
branches;
next	1.53.8.2;

1.53.8.2
date	2004.09.16.17.00.18;	author drow;	state Exp;
branches;
next	;

1.53.12.1
date	2004.03.21.23.57.25;	author cagney;	state Exp;
branches;
next	;

1.47.2.1
date	2003.04.10.21.33.44;	author cagney;	state Exp;
branches;
next	;

1.36.2.1
date	2002.10.26.17.11.57;	author drow;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2003.12.14.20.26.37;	author drow;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2004.01.13.16.11.36;	author drow;	state Exp;
branches;
next	;

1.34.2.1
date	2002.09.27.20.02.53;	author carlton;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2002.12.23.19.37.35;	author carlton;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2003.11.11.23.50.11;	author carlton;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2003.12.15.23.59.17;	author carlton;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2004.01.26.19.11.04;	author carlton;	state Exp;
branches;
next	;

1.32.2.1
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.10.28.18.45.43;	author drow;	state Exp;
branches;
next	;

1.30.6.1
date	2002.07.22.21.46.41;	author kseitz;	state Exp;
branches;
next	1.30.6.2;

1.30.6.2
date	2002.10.01.00.45.43;	author kseitz;	state Exp;
branches;
next	1.30.6.3;

1.30.6.3
date	2002.11.03.22.01.34;	author ezannoni;	state Exp;
branches;
next	;

1.28.2.1
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.05.09.11.50.20;	author amodra;	state Exp;
branches;
next	;

1.18.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.06.11.10.04.08;	author amodra;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.10.07.21.36.13;	author ciceron;	state Exp;
branches;
next	;

1.12.2.1
date	2000.04.19.11.13.16;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.154
log
@	* dwarf2.c (struct dwarf2_debug): Add fields for handling
	alternate debug info source.
	(dwarf_debug_sections): Add entries for alternate .debug_str and
	.debug_info sections.
	(dwarf_debug_section_enum): Likewise.
	(read_alt_indirect_string): New function.  Handles a
	DW_FORM_GNU_strp_alt attribute.
	(read_alt_indirect_ref): New function.  Handles a
	DW_FORM_GNU_ref_alt attribute.
	(read_attribute_value): Process DW_FORM_GNU_ref_alt and
	DW_FORM_GNU_strp_alt.
	(find_abstract_instance_name): Handle DW_FORM_GNU_ref_alt
	attributes.
	(_bfd_dwarf2_cleanup_debug_info): Free alternate debug info
	sources.
	* opncls.c (GNU_DEBUGALTLINK): Define.
	(bfd_get_alt_debug_link_info): New function.
	(separate_alt_debug_file_exists): New function.
	(find_separate_debug_file): Add parameters for fetch and check
	functions.
	(bfd_follow_gnu_debugaltlink): New function.
	* bfd-in2.h: Regenerate.
@
text
@/* DWARF 2 support.
   Copyright 1994-2013 Free Software Foundation, Inc.

   Adapted from gdb/dwarf2read.c by Gavin Koch of Cygnus Solutions
   (gavin@@cygnus.com).

   From the dwarf2read.c header:
   Adapted by Gary Funck (gary@@intrepid.com), Intrepid Technology,
   Inc.  with support from Florida State University (under contract
   with the Ada Joint Program Office), and Silicon Graphics, Inc.
   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,
   based on Fred Fish's (Cygnus Support) implementation of DWARF 1
   support in dwarfread.c

   This file is part of BFD.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "dwarf2.h"

/* The data in the .debug_line statement prologue looks like this.  */

struct line_head
{
  bfd_vma total_length;
  unsigned short version;
  bfd_vma prologue_length;
  unsigned char minimum_instruction_length;
  unsigned char maximum_ops_per_insn;
  unsigned char default_is_stmt;
  int line_base;
  unsigned char line_range;
  unsigned char opcode_base;
  unsigned char *standard_opcode_lengths;
};

/* Attributes have a name and a value.  */

struct attribute
{
  enum dwarf_attribute name;
  enum dwarf_form form;
  union
  {
    char *str;
    struct dwarf_block *blk;
    bfd_uint64_t val;
    bfd_int64_t sval;
  }
  u;
};

/* Blocks are a bunch of untyped bytes.  */
struct dwarf_block
{
  unsigned int size;
  bfd_byte *data;
};

struct adjusted_section
{
  asection *section;
  bfd_vma adj_vma;
};

struct dwarf2_debug
{
  /* A list of all previously read comp_units.  */
  struct comp_unit *all_comp_units;

  /* Last comp unit in list above.  */
  struct comp_unit *last_comp_unit;

  /* Names of the debug sections.  */
  const struct dwarf_debug_section *debug_sections;

  /* The next unread compilation unit within the .debug_info section.
     Zero indicates that the .debug_info section has not been loaded
     into a buffer yet.  */
  bfd_byte *info_ptr;

  /* Pointer to the end of the .debug_info section memory buffer.  */
  bfd_byte *info_ptr_end;

  /* Pointer to the bfd, section and address of the beginning of the
     section.  The bfd might be different than expected because of
     gnu_debuglink sections.  */
  bfd *bfd_ptr;
  asection *sec;
  bfd_byte *sec_info_ptr;

  /* Support for alternate debug info sections created by the DWZ utility:
     This includes a pointer to an alternate bfd which contains *extra*,
     possibly duplicate debug sections, and pointers to the loaded
     .debug_str and .debug_info sections from this bfd.  */
  bfd *          alt_bfd_ptr;
  bfd_byte *     alt_dwarf_str_buffer;
  bfd_size_type  alt_dwarf_str_size;
  bfd_byte *     alt_dwarf_info_buffer;
  bfd_size_type  alt_dwarf_info_size;

  /* A pointer to the memory block allocated for info_ptr.  Neither
     info_ptr nor sec_info_ptr are guaranteed to stay pointing to the
     beginning of the malloc block.  This is used only to free the
     memory later.  */
  bfd_byte *info_ptr_memory;

  /* Pointer to the symbol table.  */
  asymbol **syms;

  /* Pointer to the .debug_abbrev section loaded into memory.  */
  bfd_byte *dwarf_abbrev_buffer;

  /* Length of the loaded .debug_abbrev section.  */
  bfd_size_type dwarf_abbrev_size;

  /* Buffer for decode_line_info.  */
  bfd_byte *dwarf_line_buffer;

  /* Length of the loaded .debug_line section.  */
  bfd_size_type dwarf_line_size;

  /* Pointer to the .debug_str section loaded into memory.  */
  bfd_byte *dwarf_str_buffer;

  /* Length of the loaded .debug_str section.  */
  bfd_size_type dwarf_str_size;

  /* Pointer to the .debug_ranges section loaded into memory. */
  bfd_byte *dwarf_ranges_buffer;

  /* Length of the loaded .debug_ranges section. */
  bfd_size_type dwarf_ranges_size;

  /* If the most recent call to bfd_find_nearest_line was given an
     address in an inlined function, preserve a pointer into the
     calling chain for subsequent calls to bfd_find_inliner_info to
     use. */
  struct funcinfo *inliner_chain;

  /* Number of sections whose VMA we must adjust.  */
  unsigned int adjusted_section_count;

  /* Array of sections with adjusted VMA.  */
  struct adjusted_section *adjusted_sections;

  /* Number of times find_line is called.  This is used in
     the heuristic for enabling the info hash tables.  */
  int info_hash_count;

#define STASH_INFO_HASH_TRIGGER    100

  /* Hash table mapping symbol names to function infos.  */
  struct info_hash_table *funcinfo_hash_table;

  /* Hash table mapping symbol names to variable infos.  */
  struct info_hash_table *varinfo_hash_table;

  /* Head of comp_unit list in the last hash table update.  */
  struct comp_unit *hash_units_head;

  /* Status of info hash.  */
  int info_hash_status;
#define STASH_INFO_HASH_OFF        0
#define STASH_INFO_HASH_ON         1
#define STASH_INFO_HASH_DISABLED   2

  /* True if we opened bfd_ptr.  */
  bfd_boolean close_on_cleanup;
};

struct arange
{
  struct arange *next;
  bfd_vma low;
  bfd_vma high;
};

/* A minimal decoding of DWARF2 compilation units.  We only decode
   what's needed to get to the line number information.  */

struct comp_unit
{
  /* Chain the previously read compilation units.  */
  struct comp_unit *next_unit;

  /* Likewise, chain the compilation unit read after this one.
     The comp units are stored in reversed reading order.  */
  struct comp_unit *prev_unit;

  /* Keep the bfd convenient (for memory allocation).  */
  bfd *abfd;

  /* The lowest and highest addresses contained in this compilation
     unit as specified in the compilation unit header.  */
  struct arange arange;

  /* The DW_AT_name attribute (for error messages).  */
  char *name;

  /* The abbrev hash table.  */
  struct abbrev_info **abbrevs;

  /* Note that an error was found by comp_unit_find_nearest_line.  */
  int error;

  /* The DW_AT_comp_dir attribute.  */
  char *comp_dir;

  /* TRUE if there is a line number table associated with this comp. unit.  */
  int stmtlist;

  /* Pointer to the current comp_unit so that we can find a given entry
     by its reference.  */
  bfd_byte *info_ptr_unit;

  /* Pointer to the start of the debug section, for DW_FORM_ref_addr.  */
  bfd_byte *sec_info_ptr;

  /* The offset into .debug_line of the line number table.  */
  unsigned long line_offset;

  /* Pointer to the first child die for the comp unit.  */
  bfd_byte *first_child_die_ptr;

  /* The end of the comp unit.  */
  bfd_byte *end_ptr;

  /* The decoded line number, NULL if not yet decoded.  */
  struct line_info_table *line_table;

  /* A list of the functions found in this comp. unit.  */
  struct funcinfo *function_table;

  /* A list of the variables found in this comp. unit.  */
  struct varinfo *variable_table;

  /* Pointer to dwarf2_debug structure.  */
  struct dwarf2_debug *stash;

  /* DWARF format version for this unit - from unit header.  */
  int version;

  /* Address size for this unit - from unit header.  */
  unsigned char addr_size;

  /* Offset size for this unit - from unit header.  */
  unsigned char offset_size;

  /* Base address for this unit - from DW_AT_low_pc attribute of
     DW_TAG_compile_unit DIE */
  bfd_vma base_address;

  /* TRUE if symbols are cached in hash table for faster lookup by name.  */
  bfd_boolean cached;
};

/* This data structure holds the information of an abbrev.  */
struct abbrev_info
{
  unsigned int number;		/* Number identifying abbrev.  */
  enum dwarf_tag tag;		/* DWARF tag.  */
  int has_children;		/* Boolean.  */
  unsigned int num_attrs;	/* Number of attributes.  */
  struct attr_abbrev *attrs;	/* An array of attribute descriptions.  */
  struct abbrev_info *next;	/* Next in chain.  */
};

struct attr_abbrev
{
  enum dwarf_attribute name;
  enum dwarf_form form;
};

/* Map of uncompressed DWARF debug section name to compressed one.  It
   is terminated by NULL uncompressed_name.  */

const struct dwarf_debug_section dwarf_debug_sections[] =
{
  { ".debug_abbrev",		".zdebug_abbrev" },
  { ".debug_aranges",		".zdebug_aranges" },
  { ".debug_frame",		".zdebug_frame" },
  { ".debug_info",		".zdebug_info" },
  { ".debug_info",		".zdebug_info" },
  { ".debug_line",		".zdebug_line" },
  { ".debug_loc",		".zdebug_loc" },
  { ".debug_macinfo",		".zdebug_macinfo" },
  { ".debug_macro",		".zdebug_macro" },
  { ".debug_pubnames",		".zdebug_pubnames" },
  { ".debug_pubtypes",		".zdebug_pubtypes" },
  { ".debug_ranges",		".zdebug_ranges" },
  { ".debug_static_func",	".zdebug_static_func" },
  { ".debug_static_vars",	".zdebug_static_vars" },
  { ".debug_str",		".zdebug_str", },
  { ".debug_str",		".zdebug_str", },
  { ".debug_types",		".zdebug_types" },
  /* GNU DWARF 1 extensions */
  { ".debug_sfnames",		".zdebug_sfnames" },
  { ".debug_srcinfo",		".zebug_srcinfo" },
  /* SGI/MIPS DWARF 2 extensions */
  { ".debug_funcnames",		".zdebug_funcnames" },
  { ".debug_typenames",		".zdebug_typenames" },
  { ".debug_varnames",		".zdebug_varnames" },
  { ".debug_weaknames",		".zdebug_weaknames" },
  { NULL,			NULL },
};

/* NB/ Numbers in this enum must match up with indicies
   into the dwarf_debug_sections[] array above.  */
enum dwarf_debug_section_enum
{
  debug_abbrev = 0,
  debug_aranges,
  debug_frame,
  debug_info,
  debug_info_alt,
  debug_line,
  debug_loc,
  debug_macinfo,
  debug_macro,
  debug_pubnames,
  debug_pubtypes,
  debug_ranges,
  debug_static_func,
  debug_static_vars,
  debug_str,
  debug_str_alt,
  debug_types,
  debug_sfnames,
  debug_srcinfo,
  debug_funcnames,
  debug_typenames,
  debug_varnames,
  debug_weaknames
};

#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif
#ifndef ATTR_ALLOC_CHUNK
#define ATTR_ALLOC_CHUNK 4
#endif

/* Variable and function hash tables.  This is used to speed up look-up
   in lookup_symbol_in_var_table() and lookup_symbol_in_function_table().
   In order to share code between variable and function infos, we use
   a list of untyped pointer for all variable/function info associated with
   a symbol.  We waste a bit of memory for list with one node but that
   simplifies the code.  */

struct info_list_node
{
  struct info_list_node *next;
  void *info;
};

/* Info hash entry.  */
struct info_hash_entry
{
  struct bfd_hash_entry root;
  struct info_list_node *head;
};

struct info_hash_table
{
  struct bfd_hash_table base;
};

/* Function to create a new entry in info hash table. */

static struct bfd_hash_entry *
info_hash_table_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  struct info_hash_entry *ret = (struct info_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     derived class.  */
  if (ret == NULL)
    {
      ret = (struct info_hash_entry *) bfd_hash_allocate (table,
                                                          sizeof (* ret));
      if (ret == NULL)
	return NULL;
    }

  /* Call the allocation method of the base class.  */
  ret = ((struct info_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  /* Initialize the local fields here.  */
  if (ret)
    ret->head = NULL;

  return (struct bfd_hash_entry *) ret;
}

/* Function to create a new info hash table.  It returns a pointer to the
   newly created table or NULL if there is any error.  We need abfd
   solely for memory allocation.  */

static struct info_hash_table *
create_info_hash_table (bfd *abfd)
{
  struct info_hash_table *hash_table;

  hash_table = ((struct info_hash_table *)
		bfd_alloc (abfd, sizeof (struct info_hash_table)));
  if (!hash_table)
    return hash_table;

  if (!bfd_hash_table_init (&hash_table->base, info_hash_table_newfunc,
			    sizeof (struct info_hash_entry)))
    {
      bfd_release (abfd, hash_table);
      return NULL;
    }

  return hash_table;
}

/* Insert an info entry into an info hash table.  We do not check of
   duplicate entries.  Also, the caller need to guarantee that the
   right type of info in inserted as info is passed as a void* pointer.
   This function returns true if there is no error.  */

static bfd_boolean
insert_info_hash_table (struct info_hash_table *hash_table,
			const char *key,
			void *info,
			bfd_boolean copy_p)
{
  struct info_hash_entry *entry;
  struct info_list_node *node;

  entry = (struct info_hash_entry*) bfd_hash_lookup (&hash_table->base,
						     key, TRUE, copy_p);
  if (!entry)
    return FALSE;

  node = (struct info_list_node *) bfd_hash_allocate (&hash_table->base,
                                                      sizeof (*node));
  if (!node)
    return FALSE;

  node->info = info;
  node->next = entry->head;
  entry->head = node;

  return TRUE;
}

/* Look up an info entry list from an info hash table.  Return NULL
   if there is none. */

static struct info_list_node *
lookup_info_hash_table (struct info_hash_table *hash_table, const char *key)
{
  struct info_hash_entry *entry;

  entry = (struct info_hash_entry*) bfd_hash_lookup (&hash_table->base, key,
						     FALSE, FALSE);
  return entry ? entry->head : NULL;
}

/* Read a section into its appropriate place in the dwarf2_debug
   struct (indicated by SECTION_BUFFER and SECTION_SIZE).  If SYMS is
   not NULL, use bfd_simple_get_relocated_section_contents to read the
   section contents, otherwise use bfd_get_section_contents.  Fail if
   the located section does not contain at least OFFSET bytes.  */

static bfd_boolean
read_section (bfd *           abfd,
	      const struct dwarf_debug_section *sec,
	      asymbol **      syms,
	      bfd_uint64_t    offset,
	      bfd_byte **     section_buffer,
	      bfd_size_type * section_size)
{
  asection *msec;
  const char *section_name = sec->uncompressed_name;

  /* The section may have already been read.  */
  if (*section_buffer == NULL)
    {
      msec = bfd_get_section_by_name (abfd, section_name);
      if (! msec)
	{
	  section_name = sec->compressed_name;
          if (section_name != NULL)
            msec = bfd_get_section_by_name (abfd, section_name);
	}
      if (! msec)
	{
	  (*_bfd_error_handler) (_("Dwarf Error: Can't find %s section."),
                                 sec->uncompressed_name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      *section_size = msec->rawsize ? msec->rawsize : msec->size;
      if (syms)
	{
	  *section_buffer
	    = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
	  if (! *section_buffer)
	    return FALSE;
	}
      else
	{
	  *section_buffer = (bfd_byte *) bfd_malloc (*section_size);
	  if (! *section_buffer)
	    return FALSE;
	  if (! bfd_get_section_contents (abfd, msec, *section_buffer,
					  0, *section_size))
	    return FALSE;
	}
    }

  /* It is possible to get a bad value for the offset into the section
     that the client wants.  Validate it here to avoid trouble later.  */
  if (offset != 0 && offset >= *section_size)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Offset (%lu)"
			       " greater than or equal to %s size (%lu)."),
			     (long) offset, section_name, *section_size);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}

/* VERBATIM
   The following function up to the END VERBATIM mark are
   copied directly from dwarf2read.c.  */

/* Read dwarf information from a buffer.  */

static unsigned int
read_1_byte (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *buf)
{
  return bfd_get_8 (abfd, buf);
}

static int
read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *buf)
{
  return bfd_get_signed_8 (abfd, buf);
}

static unsigned int
read_2_bytes (bfd *abfd, bfd_byte *buf)
{
  return bfd_get_16 (abfd, buf);
}

static unsigned int
read_4_bytes (bfd *abfd, bfd_byte *buf)
{
  return bfd_get_32 (abfd, buf);
}

static bfd_uint64_t
read_8_bytes (bfd *abfd, bfd_byte *buf)
{
  return bfd_get_64 (abfd, buf);
}

static bfd_byte *
read_n_bytes (bfd *abfd ATTRIBUTE_UNUSED,
	      bfd_byte *buf,
	      unsigned int size ATTRIBUTE_UNUSED)
{
  return buf;
}

static char *
read_string (bfd *abfd ATTRIBUTE_UNUSED,
	     bfd_byte *buf,
	     unsigned int *bytes_read_ptr)
{
  /* Return a pointer to the embedded string.  */
  char *str = (char *) buf;

  if (*str == '\0')
    {
      *bytes_read_ptr = 1;
      return NULL;
    }

  *bytes_read_ptr = strlen (str) + 1;
  return str;
}

/* END VERBATIM */

static char *
read_indirect_string (struct comp_unit * unit,
		      bfd_byte *         buf,
		      unsigned int *     bytes_read_ptr)
{
  bfd_uint64_t offset;
  struct dwarf2_debug *stash = unit->stash;
  char *str;

  if (unit->offset_size == 4)
    offset = read_4_bytes (unit->abfd, buf);
  else
    offset = read_8_bytes (unit->abfd, buf);

  *bytes_read_ptr = unit->offset_size;

  if (! read_section (unit->abfd, &stash->debug_sections[debug_str],
                      stash->syms, offset,
		      &stash->dwarf_str_buffer, &stash->dwarf_str_size))
    return NULL;

  str = (char *) stash->dwarf_str_buffer + offset;
  if (*str == '\0')
    return NULL;
  return str;
}

/* Like read_indirect_string but uses a .debug_str located in
   an alternate filepointed to by the .gnu_debuglink section.
   Used to impement DW_FORM_GNU_strp_alt.  */

static char *
read_alt_indirect_string (struct comp_unit * unit,
			  bfd_byte *         buf,
			  unsigned int *     bytes_read_ptr)
{
  bfd_uint64_t offset;
  struct dwarf2_debug *stash = unit->stash;
  char *str;

  if (unit->offset_size == 4)
    offset = read_4_bytes (unit->abfd, buf);
  else
    offset = read_8_bytes (unit->abfd, buf);

  *bytes_read_ptr = unit->offset_size;

  if (stash->alt_bfd_ptr == NULL)
    {
      bfd *  debug_bfd;
      char * debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);

      if (debug_filename == NULL)
	return NULL;

      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
	  || ! bfd_check_format (debug_bfd, bfd_object))
	{
	  if (debug_bfd)
	    bfd_close (debug_bfd);

	  /* FIXME: Should we report our failure to follow the debuglink ?  */
	  free (debug_filename);
	  return NULL;
	}
      stash->alt_bfd_ptr = debug_bfd;
    }
  
  if (! read_section (unit->stash->alt_bfd_ptr,
		      stash->debug_sections + debug_str_alt,
		      NULL, /* FIXME: Do we need to load alternate symbols ?  */
		      offset,
		      &stash->alt_dwarf_str_buffer,
		      &stash->alt_dwarf_str_size))
    return NULL;

  str = (char *) stash->alt_dwarf_str_buffer + offset;
  if (*str == '\0')
    return NULL;

  return str;
}

/* Resolve an alternate reference from UNIT at OFFSET.
   Returns a pointer into the loaded alternate CU upon success
   or NULL upon failure.  */

static bfd_byte *
read_alt_indirect_ref (struct comp_unit * unit,
		       bfd_uint64_t       offset)
{
  struct dwarf2_debug *stash = unit->stash;

  if (stash->alt_bfd_ptr == NULL)
    {
      bfd *  debug_bfd;
      char * debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);

      if (debug_filename == NULL)
	return FALSE;

      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
	  || ! bfd_check_format (debug_bfd, bfd_object))
	{
	  if (debug_bfd)
	    bfd_close (debug_bfd);

	  /* FIXME: Should we report our failure to follow the debuglink ?  */
	  free (debug_filename);
	  return NULL;
	}
      stash->alt_bfd_ptr = debug_bfd;
    }
  
  if (! read_section (unit->stash->alt_bfd_ptr,
		      stash->debug_sections + debug_info_alt,
		      NULL, /* FIXME: Do we need to load alternate symbols ?  */
		      offset,
		      &stash->alt_dwarf_info_buffer,
		      &stash->alt_dwarf_info_size))
    return NULL;

  return stash->alt_dwarf_info_buffer + offset;
}

static bfd_uint64_t
read_address (struct comp_unit *unit, bfd_byte *buf)
{
  int signed_vma = get_elf_backend_data (unit->abfd)->sign_extend_vma;

  if (signed_vma)
    {
      switch (unit->addr_size)
	{
	case 8:
	  return bfd_get_signed_64 (unit->abfd, buf);
	case 4:
	  return bfd_get_signed_32 (unit->abfd, buf);
	case 2:
	  return bfd_get_signed_16 (unit->abfd, buf);
	default:
	  abort ();
	}
    }
  else
    {
      switch (unit->addr_size)
	{
	case 8:
	  return bfd_get_64 (unit->abfd, buf);
	case 4:
	  return bfd_get_32 (unit->abfd, buf);
	case 2:
	  return bfd_get_16 (unit->abfd, buf);
	default:
	  abort ();
	}
    }
}

/* Lookup an abbrev_info structure in the abbrev hash table.  */

static struct abbrev_info *
lookup_abbrev (unsigned int number, struct abbrev_info **abbrevs)
{
  unsigned int hash_number;
  struct abbrev_info *abbrev;

  hash_number = number % ABBREV_HASH_SIZE;
  abbrev = abbrevs[hash_number];

  while (abbrev)
    {
      if (abbrev->number == number)
	return abbrev;
      else
	abbrev = abbrev->next;
    }

  return NULL;
}

/* In DWARF version 2, the description of the debugging information is
   stored in a separate .debug_abbrev section.  Before we read any
   dies from a section we read in all abbreviations and install them
   in a hash table.  */

static struct abbrev_info**
read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)
{
  struct abbrev_info **abbrevs;
  bfd_byte *abbrev_ptr;
  struct abbrev_info *cur_abbrev;
  unsigned int abbrev_number, bytes_read, abbrev_name;
  unsigned int abbrev_form, hash_number;
  bfd_size_type amt;

  if (! read_section (abfd, &stash->debug_sections[debug_abbrev],
                      stash->syms, offset,
		      &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))
    return NULL;

  amt = sizeof (struct abbrev_info*) * ABBREV_HASH_SIZE;
  abbrevs = (struct abbrev_info **) bfd_zalloc (abfd, amt);
  if (abbrevs == NULL)
    return NULL;

  abbrev_ptr = stash->dwarf_abbrev_buffer + offset;
  abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
  abbrev_ptr += bytes_read;

  /* Loop until we reach an abbrev number of 0.  */
  while (abbrev_number)
    {
      amt = sizeof (struct abbrev_info);
      cur_abbrev = (struct abbrev_info *) bfd_zalloc (abfd, amt);
      if (cur_abbrev == NULL)
	return NULL;

      /* Read in abbrev header.  */
      cur_abbrev->number = abbrev_number;
      cur_abbrev->tag = (enum dwarf_tag)
	read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr);
      abbrev_ptr += 1;

      /* Now read in declarations.  */
      abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;

      while (abbrev_name)
	{
	  if ((cur_abbrev->num_attrs % ATTR_ALLOC_CHUNK) == 0)
	    {
	      struct attr_abbrev *tmp;

	      amt = cur_abbrev->num_attrs + ATTR_ALLOC_CHUNK;
	      amt *= sizeof (struct attr_abbrev);
	      tmp = (struct attr_abbrev *) bfd_realloc (cur_abbrev->attrs, amt);
	      if (tmp == NULL)
		{
		  size_t i;

		  for (i = 0; i < ABBREV_HASH_SIZE; i++)
		    {
		      struct abbrev_info *abbrev = abbrevs[i];

		      while (abbrev)
			{
			  free (abbrev->attrs);
			  abbrev = abbrev->next;
			}
		    }
		  return NULL;
		}
	      cur_abbrev->attrs = tmp;
	    }

	  cur_abbrev->attrs[cur_abbrev->num_attrs].name
	    = (enum dwarf_attribute) abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form
	    = (enum dwarf_form) abbrev_form;
	  abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
	  abbrev_ptr += bytes_read;
	  abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
	  abbrev_ptr += bytes_read;
	}

      hash_number = abbrev_number % ABBREV_HASH_SIZE;
      cur_abbrev->next = abbrevs[hash_number];
      abbrevs[hash_number] = cur_abbrev;

      /* Get next abbreviation.
	 Under Irix6 the abbreviations for a compilation unit are not
	 always properly terminated with an abbrev number of 0.
	 Exit loop if we encounter an abbreviation which we have
	 already read (which means we are about to read the abbreviations
	 for the next compile unit) or if the end of the abbreviation
	 table is reached.  */
      if ((unsigned int) (abbrev_ptr - stash->dwarf_abbrev_buffer)
	  >= stash->dwarf_abbrev_size)
	break;
      abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      if (lookup_abbrev (abbrev_number,abbrevs) != NULL)
	break;
    }

  return abbrevs;
}

/* Read an attribute value described by an attribute form.  */

static bfd_byte *
read_attribute_value (struct attribute *attr,
		      unsigned form,
		      struct comp_unit *unit,
		      bfd_byte *info_ptr)
{
  bfd *abfd = unit->abfd;
  unsigned int bytes_read;
  struct dwarf_block *blk;
  bfd_size_type amt;

  attr->form = (enum dwarf_form) form;

  switch (form)
    {
    case DW_FORM_ref_addr:
      /* DW_FORM_ref_addr is an address in DWARF2, and an offset in
	 DWARF3.  */
      if (unit->version == 3 || unit->version == 4)
	{
	  if (unit->offset_size == 4)
	    attr->u.val = read_4_bytes (unit->abfd, info_ptr);
	  else
	    attr->u.val = read_8_bytes (unit->abfd, info_ptr);
	  info_ptr += unit->offset_size;
	  break;
	}
      /* FALLTHROUGH */
    case DW_FORM_addr:
      attr->u.val = read_address (unit, info_ptr);
      info_ptr += unit->addr_size;
      break;
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_sec_offset:
      if (unit->offset_size == 4)
	attr->u.val = read_4_bytes (unit->abfd, info_ptr);
      else
	attr->u.val = read_8_bytes (unit->abfd, info_ptr);
      info_ptr += unit->offset_size;
      break;
    case DW_FORM_block2:
      amt = sizeof (struct dwarf_block);
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
      if (blk == NULL)
	return NULL;
      blk->size = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      attr->u.blk = blk;
      break;
    case DW_FORM_block4:
      amt = sizeof (struct dwarf_block);
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
      if (blk == NULL)
	return NULL;
      blk->size = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      attr->u.blk = blk;
      break;
    case DW_FORM_data2:
      attr->u.val = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      break;
    case DW_FORM_data4:
      attr->u.val = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      break;
    case DW_FORM_data8:
      attr->u.val = read_8_bytes (abfd, info_ptr);
      info_ptr += 8;
      break;
    case DW_FORM_string:
      attr->u.str = read_string (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_strp:
      attr->u.str = read_indirect_string (unit, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_GNU_strp_alt:
      attr->u.str = read_alt_indirect_string (unit, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_exprloc:
    case DW_FORM_block:
      amt = sizeof (struct dwarf_block);
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
      if (blk == NULL)
	return NULL;
      blk->size = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      attr->u.blk = blk;
      break;
    case DW_FORM_block1:
      amt = sizeof (struct dwarf_block);
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
      if (blk == NULL)
	return NULL;
      blk->size = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      attr->u.blk = blk;
      break;
    case DW_FORM_data1:
      attr->u.val = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      break;
    case DW_FORM_flag:
      attr->u.val = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      break;
    case DW_FORM_flag_present:
      attr->u.val = 1;
      break;
    case DW_FORM_sdata:
      attr->u.sval = read_signed_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_udata:
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_ref1:
      attr->u.val = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      break;
    case DW_FORM_ref2:
      attr->u.val = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      break;
    case DW_FORM_ref4:
      attr->u.val = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      break;
    case DW_FORM_ref8:
      attr->u.val = read_8_bytes (abfd, info_ptr);
      info_ptr += 8;
      break;
    case DW_FORM_ref_sig8:
      attr->u.val = read_8_bytes (abfd, info_ptr);
      info_ptr += 8;
      break;
    case DW_FORM_ref_udata:
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_indirect:
      form = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      info_ptr = read_attribute_value (attr, form, unit, info_ptr);
      break;
    default:
      (*_bfd_error_handler) (_("Dwarf Error: Invalid or unhandled FORM value: %#x."),
			     form);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  return info_ptr;
}

/* Read an attribute described by an abbreviated attribute.  */

static bfd_byte *
read_attribute (struct attribute *attr,
		struct attr_abbrev *abbrev,
		struct comp_unit *unit,
		bfd_byte *info_ptr)
{
  attr->name = abbrev->name;
  info_ptr = read_attribute_value (attr, abbrev->form, unit, info_ptr);
  return info_ptr;
}

/* Source line information table routines.  */

#define FILE_ALLOC_CHUNK 5
#define DIR_ALLOC_CHUNK 5

struct line_info
{
  struct line_info* prev_line;
  bfd_vma address;
  char *filename;
  unsigned int line;
  unsigned int column;
  unsigned int discriminator;
  unsigned char op_index;
  unsigned char end_sequence;		/* End of (sequential) code sequence.  */
};

struct fileinfo
{
  char *name;
  unsigned int dir;
  unsigned int time;
  unsigned int size;
};

struct line_sequence
{
  bfd_vma               low_pc;
  struct line_sequence* prev_sequence;
  struct line_info*     last_line;  /* Largest VMA.  */
};

struct line_info_table
{
  bfd*                  abfd;
  unsigned int          num_files;
  unsigned int          num_dirs;
  unsigned int          num_sequences;
  char *                comp_dir;
  char **               dirs;
  struct fileinfo*      files;
  struct line_sequence* sequences;
  struct line_info*     lcl_head;   /* Local head; used in 'add_line_info'.  */
};

/* Remember some information about each function.  If the function is
   inlined (DW_TAG_inlined_subroutine) it may have two additional
   attributes, DW_AT_call_file and DW_AT_call_line, which specify the
   source code location where this function was inlined.  */

struct funcinfo
{
  /* Pointer to previous function in list of all functions.  */
  struct funcinfo *prev_func;
  /* Pointer to function one scope higher.  */
  struct funcinfo *caller_func;
  /* Source location file name where caller_func inlines this func.  */
  char *caller_file;
  /* Source location line number where caller_func inlines this func.  */
  int caller_line;
  /* Source location file name.  */
  char *file;
  /* Source location line number.  */
  int line;
  int tag;
  char *name;
  struct arange arange;
  /* Where the symbol is defined.  */
  asection *sec;
};

struct varinfo
{
  /* Pointer to previous variable in list of all variables */
  struct varinfo *prev_var;
  /* Source location file name */
  char *file;
  /* Source location line number */
  int line;
  int tag;
  char *name;
  bfd_vma addr;
  /* Where the symbol is defined */
  asection *sec;
  /* Is this a stack variable? */
  unsigned int stack: 1;
};

/* Return TRUE if NEW_LINE should sort after LINE.  */

static inline bfd_boolean
new_line_sorts_after (struct line_info *new_line, struct line_info *line)
{
  return (new_line->address > line->address
	  || (new_line->address == line->address
	      && (new_line->op_index > line->op_index
		  || (new_line->op_index == line->op_index
		      && new_line->end_sequence < line->end_sequence))));
}


/* Adds a new entry to the line_info list in the line_info_table, ensuring
   that the list is sorted.  Note that the line_info list is sorted from
   highest to lowest VMA (with possible duplicates); that is,
   line_info->prev_line always accesses an equal or smaller VMA.  */

static bfd_boolean
add_line_info (struct line_info_table *table,
	       bfd_vma address,
	       unsigned char op_index,
	       char *filename,
	       unsigned int line,
	       unsigned int column,
	       unsigned int discriminator,
	       int end_sequence)
{
  bfd_size_type amt = sizeof (struct line_info);
  struct line_sequence* seq = table->sequences;
  struct line_info* info = (struct line_info *) bfd_alloc (table->abfd, amt);

  if (info == NULL)
    return FALSE;

  /* Set member data of 'info'.  */
  info->prev_line = NULL;
  info->address = address;
  info->op_index = op_index;
  info->line = line;
  info->column = column;
  info->discriminator = discriminator;
  info->end_sequence = end_sequence;

  if (filename && filename[0])
    {
      info->filename = (char *) bfd_alloc (table->abfd, strlen (filename) + 1);
      if (info->filename == NULL)
	return FALSE;
      strcpy (info->filename, filename);
    }
  else
    info->filename = NULL;

  /* Find the correct location for 'info'.  Normally we will receive
     new line_info data 1) in order and 2) with increasing VMAs.
     However some compilers break the rules (cf. decode_line_info) and
     so we include some heuristics for quickly finding the correct
     location for 'info'. In particular, these heuristics optimize for
     the common case in which the VMA sequence that we receive is a
     list of locally sorted VMAs such as
       p...z a...j  (where a < j < p < z)

     Note: table->lcl_head is used to head an *actual* or *possible*
     sub-sequence within the list (such as a...j) that is not directly
     headed by table->last_line

     Note: we may receive duplicate entries from 'decode_line_info'.  */

  if (seq
      && seq->last_line->address == address
      && seq->last_line->op_index == op_index
      && seq->last_line->end_sequence == end_sequence)
    {
      /* We only keep the last entry with the same address and end
	 sequence.  See PR ld/4986.  */
      if (table->lcl_head == seq->last_line)
	table->lcl_head = info;
      info->prev_line = seq->last_line->prev_line;
      seq->last_line = info;
    }
  else if (!seq || seq->last_line->end_sequence)
    {
      /* Start a new line sequence.  */
      amt = sizeof (struct line_sequence);
      seq = (struct line_sequence *) bfd_malloc (amt);
      if (seq == NULL)
	return FALSE;
      seq->low_pc = address;
      seq->prev_sequence = table->sequences;
      seq->last_line = info;
      table->lcl_head = info;
      table->sequences = seq;
      table->num_sequences++;
    }
  else if (new_line_sorts_after (info, seq->last_line))
    {
      /* Normal case: add 'info' to the beginning of the current sequence.  */
      info->prev_line = seq->last_line;
      seq->last_line = info;

      /* lcl_head: initialize to head a *possible* sequence at the end.  */
      if (!table->lcl_head)
	table->lcl_head = info;
    }
  else if (!new_line_sorts_after (info, table->lcl_head)
	   && (!table->lcl_head->prev_line
	       || new_line_sorts_after (info, table->lcl_head->prev_line)))
    {
      /* Abnormal but easy: lcl_head is the head of 'info'.  */
      info->prev_line = table->lcl_head->prev_line;
      table->lcl_head->prev_line = info;
    }
  else
    {
      /* Abnormal and hard: Neither 'last_line' nor 'lcl_head'
	 are valid heads for 'info'.  Reset 'lcl_head'.  */
      struct line_info* li2 = seq->last_line; /* Always non-NULL.  */
      struct line_info* li1 = li2->prev_line;

      while (li1)
	{
	  if (!new_line_sorts_after (info, li2)
	      && new_line_sorts_after (info, li1))
	    break;

	  li2 = li1; /* always non-NULL */
	  li1 = li1->prev_line;
	}
      table->lcl_head = li2;
      info->prev_line = table->lcl_head->prev_line;
      table->lcl_head->prev_line = info;
      if (address < seq->low_pc)
        seq->low_pc = address;
    }
  return TRUE;
}

/* Extract a fully qualified filename from a line info table.
   The returned string has been malloc'ed and it is the caller's
   responsibility to free it.  */

static char *
concat_filename (struct line_info_table *table, unsigned int file)
{
  char *filename;

  if (file - 1 >= table->num_files)
    {
      /* FILE == 0 means unknown.  */
      if (file)
	(*_bfd_error_handler)
	  (_("Dwarf Error: mangled line number section (bad file number)."));
      return strdup ("<unknown>");
    }

  filename = table->files[file - 1].name;

  if (!IS_ABSOLUTE_PATH (filename))
    {
      char *dir_name = NULL;
      char *subdir_name = NULL;
      char *name;
      size_t len;

      if (table->files[file - 1].dir)
	subdir_name = table->dirs[table->files[file - 1].dir - 1];

      if (!subdir_name || !IS_ABSOLUTE_PATH (subdir_name))
	dir_name = table->comp_dir;

      if (!dir_name)
	{
	  dir_name = subdir_name;
	  subdir_name = NULL;
	}

      if (!dir_name)
	return strdup (filename);

      len = strlen (dir_name) + strlen (filename) + 2;

      if (subdir_name)
	{
	  len += strlen (subdir_name) + 1;
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, "%s/%s/%s", dir_name, subdir_name, filename);
	}
      else
	{
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, "%s/%s", dir_name, filename);
	}

      return name;
    }

  return strdup (filename);
}

static bfd_boolean
arange_add (const struct comp_unit *unit, struct arange *first_arange,
	    bfd_vma low_pc, bfd_vma high_pc)
{
  struct arange *arange;

  /* Ignore empty ranges.  */
  if (low_pc == high_pc)
    return TRUE;

  /* If the first arange is empty, use it.  */
  if (first_arange->high == 0)
    {
      first_arange->low = low_pc;
      first_arange->high = high_pc;
      return TRUE;
    }

  /* Next see if we can cheaply extend an existing range.  */
  arange = first_arange;
  do
    {
      if (low_pc == arange->high)
	{
	  arange->high = high_pc;
	  return TRUE;
	}
      if (high_pc == arange->low)
	{
	  arange->low = low_pc;
	  return TRUE;
	}
      arange = arange->next;
    }
  while (arange);

  /* Need to allocate a new arange and insert it into the arange list.
     Order isn't significant, so just insert after the first arange. */
  arange = (struct arange *) bfd_alloc (unit->abfd, sizeof (*arange));
  if (arange == NULL)
    return FALSE;
  arange->low = low_pc;
  arange->high = high_pc;
  arange->next = first_arange->next;
  first_arange->next = arange;
  return TRUE;
}

/* Compare function for line sequences.  */

static int
compare_sequences (const void* a, const void* b)
{
  const struct line_sequence* seq1 = a;
  const struct line_sequence* seq2 = b;

  /* Sort by low_pc as the primary key.  */
  if (seq1->low_pc < seq2->low_pc)
    return -1;
  if (seq1->low_pc > seq2->low_pc)
    return 1;

  /* If low_pc values are equal, sort in reverse order of
     high_pc, so that the largest region comes first.  */
  if (seq1->last_line->address < seq2->last_line->address)
    return 1;
  if (seq1->last_line->address > seq2->last_line->address)
    return -1;

  if (seq1->last_line->op_index < seq2->last_line->op_index)
    return 1;
  if (seq1->last_line->op_index > seq2->last_line->op_index)
    return -1;

  return 0;
}

/* Sort the line sequences for quick lookup.  */

static bfd_boolean
sort_line_sequences (struct line_info_table* table)
{
  bfd_size_type amt;
  struct line_sequence* sequences;
  struct line_sequence* seq;
  unsigned int n = 0;
  unsigned int num_sequences = table->num_sequences;
  bfd_vma last_high_pc;

  if (num_sequences == 0)
    return TRUE;

  /* Allocate space for an array of sequences.  */
  amt = sizeof (struct line_sequence) * num_sequences;
  sequences = (struct line_sequence *) bfd_alloc (table->abfd, amt);
  if (sequences == NULL)
    return FALSE;

  /* Copy the linked list into the array, freeing the original nodes.  */
  seq = table->sequences;
  for (n = 0; n < num_sequences; n++)
    {
      struct line_sequence* last_seq = seq;

      BFD_ASSERT (seq);
      sequences[n].low_pc = seq->low_pc;
      sequences[n].prev_sequence = NULL;
      sequences[n].last_line = seq->last_line;
      seq = seq->prev_sequence;
      free (last_seq);
    }
  BFD_ASSERT (seq == NULL);

  qsort (sequences, n, sizeof (struct line_sequence), compare_sequences);

  /* Make the list binary-searchable by trimming overlapping entries
     and removing nested entries.  */
  num_sequences = 1;
  last_high_pc = sequences[0].last_line->address;
  for (n = 1; n < table->num_sequences; n++)
    {
      if (sequences[n].low_pc < last_high_pc)
        {
	  if (sequences[n].last_line->address <= last_high_pc)
	    /* Skip nested entries.  */
	    continue;

	  /* Trim overlapping entries.  */
	  sequences[n].low_pc = last_high_pc;
        }
      last_high_pc = sequences[n].last_line->address;
      if (n > num_sequences)
        {
          /* Close up the gap.  */
          sequences[num_sequences].low_pc = sequences[n].low_pc;
          sequences[num_sequences].last_line = sequences[n].last_line;
        }
      num_sequences++;
    }

  table->sequences = sequences;
  table->num_sequences = num_sequences;
  return TRUE;
}

/* Decode the line number information for UNIT.  */

static struct line_info_table*
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
{
  bfd *abfd = unit->abfd;
  struct line_info_table* table;
  bfd_byte *line_ptr;
  bfd_byte *line_end;
  struct line_head lh;
  unsigned int i, bytes_read, offset_size;
  char *cur_file, *cur_dir;
  unsigned char op_code, extended_op, adj_opcode;
  unsigned int exop_len;
  bfd_size_type amt;

  if (! read_section (abfd, &stash->debug_sections[debug_line],
                      stash->syms, unit->line_offset,
		      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
    return NULL;

  amt = sizeof (struct line_info_table);
  table = (struct line_info_table *) bfd_alloc (abfd, amt);
  if (table == NULL)
    return NULL;
  table->abfd = abfd;
  table->comp_dir = unit->comp_dir;

  table->num_files = 0;
  table->files = NULL;

  table->num_dirs = 0;
  table->dirs = NULL;

  table->num_sequences = 0;
  table->sequences = NULL;

  table->lcl_head = NULL;

  line_ptr = stash->dwarf_line_buffer + unit->line_offset;

  /* Read in the prologue.  */
  lh.total_length = read_4_bytes (abfd, line_ptr);
  line_ptr += 4;
  offset_size = 4;
  if (lh.total_length == 0xffffffff)
    {
      lh.total_length = read_8_bytes (abfd, line_ptr);
      line_ptr += 8;
      offset_size = 8;
    }
  else if (lh.total_length == 0 && unit->addr_size == 8)
    {
      /* Handle (non-standard) 64-bit DWARF2 formats.  */
      lh.total_length = read_4_bytes (abfd, line_ptr);
      line_ptr += 4;
      offset_size = 8;
    }
  line_end = line_ptr + lh.total_length;
  lh.version = read_2_bytes (abfd, line_ptr);
  if (lh.version < 2 || lh.version > 4)
    {
      (*_bfd_error_handler)
	(_("Dwarf Error: Unhandled .debug_line version %d."), lh.version);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  line_ptr += 2;
  if (offset_size == 4)
    lh.prologue_length = read_4_bytes (abfd, line_ptr);
  else
    lh.prologue_length = read_8_bytes (abfd, line_ptr);
  line_ptr += offset_size;
  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  if (lh.version >= 4)
    {
      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr);
      line_ptr += 1;
    }
  else
    lh.maximum_ops_per_insn = 1;
  if (lh.maximum_ops_per_insn == 0)
    {
      (*_bfd_error_handler)
	(_("Dwarf Error: Invalid maximum operations per instruction."));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  lh.default_is_stmt = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.line_base = read_1_signed_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.line_range = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.opcode_base = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  amt = lh.opcode_base * sizeof (unsigned char);
  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);

  lh.standard_opcode_lengths[0] = 1;

  for (i = 1; i < lh.opcode_base; ++i)
    {
      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr);
      line_ptr += 1;
    }

  /* Read directory table.  */
  while ((cur_dir = read_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      line_ptr += bytes_read;

      if ((table->num_dirs % DIR_ALLOC_CHUNK) == 0)
	{
	  char **tmp;

	  amt = table->num_dirs + DIR_ALLOC_CHUNK;
	  amt *= sizeof (char *);

	  tmp = (char **) bfd_realloc (table->dirs, amt);
	  if (tmp == NULL)
	    goto fail;
	  table->dirs = tmp;
	}

      table->dirs[table->num_dirs++] = cur_dir;
    }

  line_ptr += bytes_read;

  /* Read file name table.  */
  while ((cur_file = read_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      line_ptr += bytes_read;

      if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
	{
	  struct fileinfo *tmp;

	  amt = table->num_files + FILE_ALLOC_CHUNK;
	  amt *= sizeof (struct fileinfo);

	  tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
	  if (tmp == NULL)
	    goto fail;
	  table->files = tmp;
	}

      table->files[table->num_files].name = cur_file;
      table->files[table->num_files].dir =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      table->files[table->num_files].time =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      table->files[table->num_files].size =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      table->num_files++;
    }

  line_ptr += bytes_read;

  /* Read the statement sequences until there's nothing left.  */
  while (line_ptr < line_end)
    {
      /* State machine registers.  */
      bfd_vma address = 0;
      unsigned char op_index = 0;
      char * filename = table->num_files ? concat_filename (table, 1) : NULL;
      unsigned int line = 1;
      unsigned int column = 0;
      unsigned int discriminator = 0;
      int is_stmt = lh.default_is_stmt;
      int end_sequence = 0;
      /* eraxxon@@alumni.rice.edu: Against the DWARF2 specs, some
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = (bfd_vma) -1;
      bfd_vma high_pc = 0;

      /* Decode the table.  */
      while (! end_sequence)
	{
	  op_code = read_1_byte (abfd, line_ptr);
	  line_ptr += 1;

	  if (op_code >= lh.opcode_base)
	    {
	      /* Special operand.  */
	      adj_opcode = op_code - lh.opcode_base;
	      if (lh.maximum_ops_per_insn == 1)
		address += (adj_opcode / lh.line_range
			    * lh.minimum_instruction_length);
	      else
		{
		  address += ((op_index + adj_opcode / lh.line_range)
			      / lh.maximum_ops_per_insn
			      * lh.minimum_instruction_length);
		  op_index = ((op_index + adj_opcode / lh.line_range)
			      % lh.maximum_ops_per_insn);
		}
	      line += lh.line_base + (adj_opcode % lh.line_range);
	      /* Append row to matrix using current values.  */
	      if (!add_line_info (table, address, op_index, filename,
				  line, column, discriminator, 0))
		goto line_fail;
              discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      exop_len = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      extended_op = read_1_byte (abfd, line_ptr);
	      line_ptr += 1;

	      switch (extended_op)
		{
		case DW_LNE_end_sequence:
		  end_sequence = 1;
		  if (!add_line_info (table, address, op_index, filename, line,
				      column, discriminator, end_sequence))
		    goto line_fail;
                  discriminator = 0;
		  if (address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
		  if (!arange_add (unit, &unit->arange, low_pc, high_pc))
		    goto line_fail;
		  break;
		case DW_LNE_set_address:
		  address = read_address (unit, line_ptr);
		  op_index = 0;
		  line_ptr += unit->addr_size;
		  break;
		case DW_LNE_define_file:
		  cur_file = read_string (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
		    {
		      struct fileinfo *tmp;

		      amt = table->num_files + FILE_ALLOC_CHUNK;
		      amt *= sizeof (struct fileinfo);
		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
		      if (tmp == NULL)
			goto line_fail;
		      table->files = tmp;
		    }
		  table->files[table->num_files].name = cur_file;
		  table->files[table->num_files].dir =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  table->files[table->num_files].time =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  table->files[table->num_files].size =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  table->num_files++;
		  break;
		case DW_LNE_set_discriminator:
		  discriminator =
                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  break;
		case DW_LNE_HP_source_file_correlation:
		  line_ptr += exop_len - 1;
		  break;
		default:
		  (*_bfd_error_handler)
		    (_("Dwarf Error: mangled line number section."));
		  bfd_set_error (bfd_error_bad_value);
		line_fail:
		  if (filename != NULL)
		    free (filename);
		  goto fail;
		}
	      break;
	    case DW_LNS_copy:
	      if (!add_line_info (table, address, op_index,
				  filename, line, column, discriminator, 0))
		goto line_fail;
              discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	      break;
	    case DW_LNS_advance_pc:
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * read_unsigned_leb128 (abfd, line_ptr,
						    &bytes_read));
	      else
		{
		  bfd_vma adjust = read_unsigned_leb128 (abfd, line_ptr,
							 &bytes_read);
		  address = ((op_index + adjust) / lh.maximum_ops_per_insn
			     * lh.minimum_instruction_length);
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_advance_line:
	      line += read_signed_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_set_file:
	      {
		unsigned int file;

		/* The file and directory tables are 0
		   based, the references are 1 based.  */
		file = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		line_ptr += bytes_read;
		if (filename)
		  free (filename);
		filename = concat_filename (table, file);
		break;
	      }
	    case DW_LNS_set_column:
	      column = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_negate_stmt:
	      is_stmt = (!is_stmt);
	      break;
	    case DW_LNS_set_basic_block:
	      break;
	    case DW_LNS_const_add_pc:
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * ((255 - lh.opcode_base) / lh.line_range));
	      else
		{
		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
		  address += (lh.minimum_instruction_length
			      * ((op_index + adjust)
				 / lh.maximum_ops_per_insn));
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      break;
	    case DW_LNS_fixed_advance_pc:
	      address += read_2_bytes (abfd, line_ptr);
	      op_index = 0;
	      line_ptr += 2;
	      break;
	    default:
	      /* Unknown standard opcode, ignore it.  */
	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
		{
		  (void) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		}
	      break;
	    }
	}

      if (filename)
	free (filename);
    }

  if (sort_line_sequences (table))
    return table;

 fail:
  if (table->sequences != NULL)
    free (table->sequences);
  if (table->files != NULL)
    free (table->files);
  if (table->dirs != NULL)
    free (table->dirs);
  return NULL;
}

/* If ADDR is within TABLE set the output parameters and return TRUE,
   otherwise return FALSE.  The output parameters, FILENAME_PTR and
   LINENUMBER_PTR, are pointers to the objects to be filled in.  */

static bfd_boolean
lookup_address_in_line_info_table (struct line_info_table *table,
				   bfd_vma addr,
				   const char **filename_ptr,
				   unsigned int *linenumber_ptr,
				   unsigned int *discriminator_ptr)
{
  struct line_sequence *seq = NULL;
  struct line_info *each_line;
  int low, high, mid;

  /* Binary search the array of sequences.  */
  low = 0;
  high = table->num_sequences;
  while (low < high)
    {
      mid = (low + high) / 2;
      seq = &table->sequences[mid];
      if (addr < seq->low_pc)
	high = mid;
      else if (addr >= seq->last_line->address)
	low = mid + 1;
      else
	break;
    }

  if (seq && addr >= seq->low_pc && addr < seq->last_line->address)
    {
      /* Note: seq->last_line should be a descendingly sorted list.  */
      for (each_line = seq->last_line;
           each_line;
           each_line = each_line->prev_line)
        if (addr >= each_line->address)
          break;

      if (each_line
          && !(each_line->end_sequence || each_line == seq->last_line))
        {
          *filename_ptr = each_line->filename;
          *linenumber_ptr = each_line->line;
          if (discriminator_ptr)
            *discriminator_ptr = each_line->discriminator;
          return TRUE;
        }
    }

  *filename_ptr = NULL;
  return FALSE;
}

/* Read in the .debug_ranges section for future reference.  */

static bfd_boolean
read_debug_ranges (struct comp_unit *unit)
{
  struct dwarf2_debug *stash = unit->stash;
  return read_section (unit->abfd, &stash->debug_sections[debug_ranges],
                       stash->syms, 0,
		       &stash->dwarf_ranges_buffer, &stash->dwarf_ranges_size);
}

/* Function table functions.  */

/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.
   Note that we need to find the function that has the smallest
   range that contains ADDR, to handle inlined functions without
   depending upon them being ordered in TABLE by increasing range. */

static bfd_boolean
lookup_address_in_function_table (struct comp_unit *unit,
				  bfd_vma addr,
				  struct funcinfo **function_ptr,
				  const char **functionname_ptr)
{
  struct funcinfo* each_func;
  struct funcinfo* best_fit = NULL;
  struct arange *arange;

  for (each_func = unit->function_table;
       each_func;
       each_func = each_func->prev_func)
    {
      for (arange = &each_func->arange;
	   arange;
	   arange = arange->next)
	{
	  if (addr >= arange->low && addr < arange->high)
	    {
	      if (!best_fit
		  || (arange->high - arange->low
		      < best_fit->arange.high - best_fit->arange.low))
		best_fit = each_func;
	    }
	}
    }

  if (best_fit)
    {
      *functionname_ptr = best_fit->name;
      *function_ptr = best_fit;
      return TRUE;
    }
  else
    {
      return FALSE;
    }
}

/* If SYM at ADDR is within function table of UNIT, set FILENAME_PTR
   and LINENUMBER_PTR, and return TRUE.  */

static bfd_boolean
lookup_symbol_in_function_table (struct comp_unit *unit,
				 asymbol *sym,
				 bfd_vma addr,
				 const char **filename_ptr,
				 unsigned int *linenumber_ptr)
{
  struct funcinfo* each_func;
  struct funcinfo* best_fit = NULL;
  struct arange *arange;
  const char *name = bfd_asymbol_name (sym);
  asection *sec = bfd_get_section (sym);

  for (each_func = unit->function_table;
       each_func;
       each_func = each_func->prev_func)
    {
      for (arange = &each_func->arange;
	   arange;
	   arange = arange->next)
	{
	  if ((!each_func->sec || each_func->sec == sec)
	      && addr >= arange->low
	      && addr < arange->high
	      && each_func->name
	      && strcmp (name, each_func->name) == 0
	      && (!best_fit
		  || (arange->high - arange->low
		      < best_fit->arange.high - best_fit->arange.low)))
	    best_fit = each_func;
	}
    }

  if (best_fit)
    {
      best_fit->sec = sec;
      *filename_ptr = best_fit->file;
      *linenumber_ptr = best_fit->line;
      return TRUE;
    }
  else
    return FALSE;
}

/* Variable table functions.  */

/* If SYM is within variable table of UNIT, set FILENAME_PTR and
   LINENUMBER_PTR, and return TRUE.  */

static bfd_boolean
lookup_symbol_in_variable_table (struct comp_unit *unit,
				 asymbol *sym,
				 bfd_vma addr,
				 const char **filename_ptr,
				 unsigned int *linenumber_ptr)
{
  const char *name = bfd_asymbol_name (sym);
  asection *sec = bfd_get_section (sym);
  struct varinfo* each;

  for (each = unit->variable_table; each; each = each->prev_var)
    if (each->stack == 0
	&& each->file != NULL
	&& each->name != NULL
	&& each->addr == addr
	&& (!each->sec || each->sec == sec)
	&& strcmp (name, each->name) == 0)
      break;

  if (each)
    {
      each->sec = sec;
      *filename_ptr = each->file;
      *linenumber_ptr = each->line;
      return TRUE;
    }
  else
    return FALSE;
}

static char *
find_abstract_instance_name (struct comp_unit *unit,
			     struct attribute *attr_ptr)
{
  bfd *abfd = unit->abfd;
  bfd_byte *info_ptr;
  unsigned int abbrev_number, bytes_read, i;
  struct abbrev_info *abbrev;
  bfd_uint64_t die_ref = attr_ptr->u.val;
  struct attribute attr;
  char *name = NULL;

  /* DW_FORM_ref_addr can reference an entry in a different CU. It
     is an offset from the .debug_info section, not the current CU.  */
  if (attr_ptr->form == DW_FORM_ref_addr)
    {
      /* We only support DW_FORM_ref_addr within the same file, so
	 any relocations should be resolved already.  */
      if (!die_ref)
	abort ();

      info_ptr = unit->sec_info_ptr + die_ref;
    }
  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)
    {
      info_ptr = read_alt_indirect_ref (unit, die_ref);
      if (info_ptr == NULL)
	{
	  (*_bfd_error_handler)
	    (_("Dwarf Error: Unable to read alt ref %u."), die_ref);
	  bfd_set_error (bfd_error_bad_value);
	  return name;
	}
    }
  else
    info_ptr = unit->info_ptr_unit + die_ref;

  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
  info_ptr += bytes_read;

  if (abbrev_number)
    {
      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);
      if (! abbrev)
	{
	  (*_bfd_error_handler)
	    (_("Dwarf Error: Could not find abbrev number %u."), abbrev_number);
	  bfd_set_error (bfd_error_bad_value);
	}
      else
	{
	  for (i = 0; i < abbrev->num_attrs; ++i)
	    {
	      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit,
					 info_ptr);
	      if (info_ptr == NULL)
		break;
	      switch (attr.name)
		{
		case DW_AT_name:
		  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name
		     over DW_AT_name.  */
		  if (name == NULL)
		    name = attr.u.str;
		  break;
		case DW_AT_specification:
		  name = find_abstract_instance_name (unit, &attr);
		  break;
		case DW_AT_linkage_name:
		case DW_AT_MIPS_linkage_name:
		  name = attr.u.str;
		  break;
		default:
		  break;
		}
	    }
	}
    }
  return name;
}

static bfd_boolean
read_rangelist (struct comp_unit *unit, struct arange *arange,
		bfd_uint64_t offset)
{
  bfd_byte *ranges_ptr;
  bfd_vma base_address = unit->base_address;

  if (! unit->stash->dwarf_ranges_buffer)
    {
      if (! read_debug_ranges (unit))
	return FALSE;
    }
  ranges_ptr = unit->stash->dwarf_ranges_buffer + offset;

  for (;;)
    {
      bfd_vma low_pc;
      bfd_vma high_pc;

      low_pc = read_address (unit, ranges_ptr);
      ranges_ptr += unit->addr_size;
      high_pc = read_address (unit, ranges_ptr);
      ranges_ptr += unit->addr_size;

      if (low_pc == 0 && high_pc == 0)
	break;
      if (low_pc == -1UL && high_pc != -1UL)
	base_address = high_pc;
      else
	{
	  if (!arange_add (unit, arange,
			   base_address + low_pc, base_address + high_pc))
	    return FALSE;
	}
    }
  return TRUE;
}

/* DWARF2 Compilation unit functions.  */

/* Scan over each die in a comp. unit looking for functions to add
   to the function table and variables to the variable table.  */

static bfd_boolean
scan_unit_for_symbols (struct comp_unit *unit)
{
  bfd *abfd = unit->abfd;
  bfd_byte *info_ptr = unit->first_child_die_ptr;
  int nesting_level = 1;
  struct funcinfo **nested_funcs;
  int nested_funcs_size;

  /* Maintain a stack of in-scope functions and inlined functions, which we
     can use to set the caller_func field.  */
  nested_funcs_size = 32;
  nested_funcs = (struct funcinfo **)
    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));
  if (nested_funcs == NULL)
    return FALSE;
  nested_funcs[nesting_level] = 0;

  while (nesting_level)
    {
      unsigned int abbrev_number, bytes_read, i;
      struct abbrev_info *abbrev;
      struct attribute attr;
      struct funcinfo *func;
      struct varinfo *var;
      bfd_vma low_pc = 0;
      bfd_vma high_pc = 0;
      bfd_boolean high_pc_relative = FALSE;

      abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;

      if (! abbrev_number)
	{
	  nesting_level--;
	  continue;
	}

      abbrev = lookup_abbrev (abbrev_number,unit->abbrevs);
      if (! abbrev)
	{
	  (*_bfd_error_handler)
	    (_("Dwarf Error: Could not find abbrev number %u."),
	     abbrev_number);
	  bfd_set_error (bfd_error_bad_value);
	  goto fail;
	}

      var = NULL;
      if (abbrev->tag == DW_TAG_subprogram
	  || abbrev->tag == DW_TAG_entry_point
	  || abbrev->tag == DW_TAG_inlined_subroutine)
	{
	  bfd_size_type amt = sizeof (struct funcinfo);
	  func = (struct funcinfo *) bfd_zalloc (abfd, amt);
	  if (func == NULL)
	    goto fail;
	  func->tag = abbrev->tag;
	  func->prev_func = unit->function_table;
	  unit->function_table = func;
	  BFD_ASSERT (!unit->cached);

	  if (func->tag == DW_TAG_inlined_subroutine)
	    for (i = nesting_level - 1; i >= 1; i--)
	      if (nested_funcs[i])
		{
		  func->caller_func = nested_funcs[i];
		  break;
		}
	  nested_funcs[nesting_level] = func;
	}
      else
	{
	  func = NULL;
	  if (abbrev->tag == DW_TAG_variable)
	    {
	      bfd_size_type amt = sizeof (struct varinfo);
	      var = (struct varinfo *) bfd_zalloc (abfd, amt);
	      if (var == NULL)
		goto fail;
	      var->tag = abbrev->tag;
	      var->stack = 1;
	      var->prev_var = unit->variable_table;
	      unit->variable_table = var;
	      BFD_ASSERT (!unit->cached);
	    }

	  /* No inline function in scope at this nesting level.  */
	  nested_funcs[nesting_level] = 0;
	}

      for (i = 0; i < abbrev->num_attrs; ++i)
	{
	  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr);
	  if (info_ptr == NULL)
	    goto fail;

	  if (func)
	    {
	      switch (attr.name)
		{
		case DW_AT_call_file:
		  func->caller_file = concat_filename (unit->line_table,
						       attr.u.val);
		  break;

		case DW_AT_call_line:
		  func->caller_line = attr.u.val;
		  break;

		case DW_AT_abstract_origin:
		case DW_AT_specification:
		  func->name = find_abstract_instance_name (unit, &attr);
		  break;

		case DW_AT_name:
		  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name
		     over DW_AT_name.  */
		  if (func->name == NULL)
		    func->name = attr.u.str;
		  break;

		case DW_AT_linkage_name:
		case DW_AT_MIPS_linkage_name:
		  func->name = attr.u.str;
		  break;

		case DW_AT_low_pc:
		  low_pc = attr.u.val;
		  break;

		case DW_AT_high_pc:
		  high_pc = attr.u.val;
		  high_pc_relative = attr.form != DW_FORM_addr;
		  break;

		case DW_AT_ranges:
		  if (!read_rangelist (unit, &func->arange, attr.u.val))
		    goto fail;
		  break;

		case DW_AT_decl_file:
		  func->file = concat_filename (unit->line_table,
						attr.u.val);
		  break;

		case DW_AT_decl_line:
		  func->line = attr.u.val;
		  break;

		default:
		  break;
		}
	    }
	  else if (var)
	    {
	      switch (attr.name)
		{
		case DW_AT_name:
		  var->name = attr.u.str;
		  break;

		case DW_AT_decl_file:
		  var->file = concat_filename (unit->line_table,
					       attr.u.val);
		  break;

		case DW_AT_decl_line:
		  var->line = attr.u.val;
		  break;

		case DW_AT_external:
		  if (attr.u.val != 0)
		    var->stack = 0;
		  break;

		case DW_AT_location:
		  switch (attr.form)
		    {
		    case DW_FORM_block:
		    case DW_FORM_block1:
		    case DW_FORM_block2:
		    case DW_FORM_block4:
		    case DW_FORM_exprloc:
		      if (*attr.u.blk->data == DW_OP_addr)
			{
			  var->stack = 0;

			  /* Verify that DW_OP_addr is the only opcode in the
			     location, in which case the block size will be 1
			     plus the address size.  */
			  /* ??? For TLS variables, gcc can emit
			     DW_OP_addr <addr> DW_OP_GNU_push_tls_address
			     which we don't handle here yet.  */
			  if (attr.u.blk->size == unit->addr_size + 1U)
			    var->addr = bfd_get (unit->addr_size * 8,
						 unit->abfd,
						 attr.u.blk->data + 1);
			}
		      break;

		    default:
		      break;
		    }
		  break;

		default:
		  break;
		}
	    }
	}

      if (high_pc_relative)
	high_pc += low_pc;

      if (func && high_pc != 0)
	{
	  if (!arange_add (unit, &func->arange, low_pc, high_pc))
	    goto fail;
	}

      if (abbrev->has_children)
	{
	  nesting_level++;

	  if (nesting_level >= nested_funcs_size)
	    {
	      struct funcinfo **tmp;

	      nested_funcs_size *= 2;
	      tmp = (struct funcinfo **)
		bfd_realloc (nested_funcs,
			     nested_funcs_size * sizeof (struct funcinfo *));
	      if (tmp == NULL)
		goto fail;
	      nested_funcs = tmp;
	    }
	  nested_funcs[nesting_level] = 0;
	}
    }

  free (nested_funcs);
  return TRUE;

 fail:
  free (nested_funcs);
  return FALSE;
}

/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This
   includes the compilation unit header that proceeds the DIE's, but
   does not include the length field that precedes each compilation
   unit header.  END_PTR points one past the end of this comp unit.
   OFFSET_SIZE is the size of DWARF2 offsets (either 4 or 8 bytes).

   This routine does not read the whole compilation unit; only enough
   to get to the line number information for the compilation unit.  */

static struct comp_unit *
parse_comp_unit (struct dwarf2_debug *stash,
		 bfd_vma unit_length,
		 bfd_byte *info_ptr_unit,
		 unsigned int offset_size)
{
  struct comp_unit* unit;
  unsigned int version;
  bfd_uint64_t abbrev_offset = 0;
  unsigned int addr_size;
  struct abbrev_info** abbrevs;
  unsigned int abbrev_number, bytes_read, i;
  struct abbrev_info *abbrev;
  struct attribute attr;
  bfd_byte *info_ptr = stash->info_ptr;
  bfd_byte *end_ptr = info_ptr + unit_length;
  bfd_size_type amt;
  bfd_vma low_pc = 0;
  bfd_vma high_pc = 0;
  bfd *abfd = stash->bfd_ptr;
  bfd_boolean high_pc_relative = FALSE;

  version = read_2_bytes (abfd, info_ptr);
  info_ptr += 2;
  BFD_ASSERT (offset_size == 4 || offset_size == 8);
  if (offset_size == 4)
    abbrev_offset = read_4_bytes (abfd, info_ptr);
  else
    abbrev_offset = read_8_bytes (abfd, info_ptr);
  info_ptr += offset_size;
  addr_size = read_1_byte (abfd, info_ptr);
  info_ptr += 1;

  if (version != 2 && version != 3 && version != 4)
    {
      (*_bfd_error_handler)
	(_("Dwarf Error: found dwarf version '%u', this reader"
	   " only handles version 2, 3 and 4 information."), version);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  if (addr_size > sizeof (bfd_vma))
    {
      (*_bfd_error_handler)
	(_("Dwarf Error: found address size '%u', this reader"
	   " can not handle sizes greater than '%u'."),
	 addr_size,
	 (unsigned int) sizeof (bfd_vma));
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  if (addr_size != 2 && addr_size != 4 && addr_size != 8)
    {
      (*_bfd_error_handler)
	("Dwarf Error: found address size '%u', this reader"
	 " can only handle address sizes '2', '4' and '8'.", addr_size);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  /* Read the abbrevs for this compilation unit into a table.  */
  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);
  if (! abbrevs)
    return 0;

  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
  info_ptr += bytes_read;
  if (! abbrev_number)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Bad abbrev number: %u."),
			     abbrev_number);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  abbrev = lookup_abbrev (abbrev_number, abbrevs);
  if (! abbrev)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %u."),
			     abbrev_number);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  amt = sizeof (struct comp_unit);
  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);
  if (unit == NULL)
    return NULL;
  unit->abfd = abfd;
  unit->version = version;
  unit->addr_size = addr_size;
  unit->offset_size = offset_size;
  unit->abbrevs = abbrevs;
  unit->end_ptr = end_ptr;
  unit->stash = stash;
  unit->info_ptr_unit = info_ptr_unit;
  unit->sec_info_ptr = stash->sec_info_ptr;

  for (i = 0; i < abbrev->num_attrs; ++i)
    {
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr);
      if (info_ptr == NULL)
	return NULL;

      /* Store the data if it is of an attribute we want to keep in a
	 partial symbol table.  */
      switch (attr.name)
	{
	case DW_AT_stmt_list:
	  unit->stmtlist = 1;
	  unit->line_offset = attr.u.val;
	  break;

	case DW_AT_name:
	  unit->name = attr.u.str;
	  break;

	case DW_AT_low_pc:
	  low_pc = attr.u.val;
	  /* If the compilation unit DIE has a DW_AT_low_pc attribute,
	     this is the base address to use when reading location
	     lists or range lists. */
	  if (abbrev->tag == DW_TAG_compile_unit)
	    unit->base_address = low_pc;
	  break;

	case DW_AT_high_pc:
	  high_pc = attr.u.val;
	  high_pc_relative = attr.form != DW_FORM_addr;
	  break;

	case DW_AT_ranges:
	  if (!read_rangelist (unit, &unit->arange, attr.u.val))
	    return NULL;
	  break;

	case DW_AT_comp_dir:
	  {
	    char *comp_dir = attr.u.str;
	    if (comp_dir)
	      {
		/* Irix 6.2 native cc prepends <machine>.: to the compilation
		   directory, get rid of it.  */
		char *cp = strchr (comp_dir, ':');

		if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
		  comp_dir = cp + 1;
	      }
	    unit->comp_dir = comp_dir;
	    break;
	  }

	default:
	  break;
	}
    }
  if (high_pc_relative)
    high_pc += low_pc;
  if (high_pc != 0)
    {
      if (!arange_add (unit, &unit->arange, low_pc, high_pc))
	return NULL;
    }

  unit->first_child_die_ptr = info_ptr;
  return unit;
}

/* Return TRUE if UNIT may contain the address given by ADDR.  When
   there are functions written entirely with inline asm statements, the
   range info in the compilation unit header may not be correct.  We
   need to consult the line info table to see if a compilation unit
   really contains the given address.  */

static bfd_boolean
comp_unit_contains_address (struct comp_unit *unit, bfd_vma addr)
{
  struct arange *arange;

  if (unit->error)
    return FALSE;

  arange = &unit->arange;
  do
    {
      if (addr >= arange->low && addr < arange->high)
	return TRUE;
      arange = arange->next;
    }
  while (arange);

  return FALSE;
}

/* If UNIT contains ADDR, set the output parameters to the values for
   the line containing ADDR.  The output parameters, FILENAME_PTR,
   FUNCTIONNAME_PTR, and LINENUMBER_PTR, are pointers to the objects
   to be filled in.

   Return TRUE if UNIT contains ADDR, and no errors were encountered;
   FALSE otherwise.  */

static bfd_boolean
comp_unit_find_nearest_line (struct comp_unit *unit,
			     bfd_vma addr,
			     const char **filename_ptr,
			     const char **functionname_ptr,
			     unsigned int *linenumber_ptr,
			     unsigned int *discriminator_ptr,
			     struct dwarf2_debug *stash)
{
  bfd_boolean line_p;
  bfd_boolean func_p;
  struct funcinfo *function;

  if (unit->error)
    return FALSE;

  if (! unit->line_table)
    {
      if (! unit->stmtlist)
	{
	  unit->error = 1;
	  return FALSE;
	}

      unit->line_table = decode_line_info (unit, stash);

      if (! unit->line_table)
	{
	  unit->error = 1;
	  return FALSE;
	}

      if (unit->first_child_die_ptr < unit->end_ptr
	  && ! scan_unit_for_symbols (unit))
	{
	  unit->error = 1;
	  return FALSE;
	}
    }

  function = NULL;
  func_p = lookup_address_in_function_table (unit, addr,
					     &function, functionname_ptr);
  if (func_p && (function->tag == DW_TAG_inlined_subroutine))
    stash->inliner_chain = function;
  line_p = lookup_address_in_line_info_table (unit->line_table, addr,
					      filename_ptr,
					      linenumber_ptr,
					      discriminator_ptr);
  return line_p || func_p;
}

/* Check to see if line info is already decoded in a comp_unit.
   If not, decode it.  Returns TRUE if no errors were encountered;
   FALSE otherwise.  */

static bfd_boolean
comp_unit_maybe_decode_line_info (struct comp_unit *unit,
				  struct dwarf2_debug *stash)
{
  if (unit->error)
    return FALSE;

  if (! unit->line_table)
    {
      if (! unit->stmtlist)
	{
	  unit->error = 1;
	  return FALSE;
	}

      unit->line_table = decode_line_info (unit, stash);

      if (! unit->line_table)
	{
	  unit->error = 1;
	  return FALSE;
	}

      if (unit->first_child_die_ptr < unit->end_ptr
	  && ! scan_unit_for_symbols (unit))
	{
	  unit->error = 1;
	  return FALSE;
	}
    }

  return TRUE;
}

/* If UNIT contains SYM at ADDR, set the output parameters to the
   values for the line containing SYM.  The output parameters,
   FILENAME_PTR, and LINENUMBER_PTR, are pointers to the objects to be
   filled in.

   Return TRUE if UNIT contains SYM, and no errors were encountered;
   FALSE otherwise.  */

static bfd_boolean
comp_unit_find_line (struct comp_unit *unit,
		     asymbol *sym,
		     bfd_vma addr,
		     const char **filename_ptr,
		     unsigned int *linenumber_ptr,
		     struct dwarf2_debug *stash)
{
  if (!comp_unit_maybe_decode_line_info (unit, stash))
    return FALSE;

  if (sym->flags & BSF_FUNCTION)
    return lookup_symbol_in_function_table (unit, sym, addr,
					    filename_ptr,
					    linenumber_ptr);

  return lookup_symbol_in_variable_table (unit, sym, addr,
					  filename_ptr,
					  linenumber_ptr);
}

static struct funcinfo *
reverse_funcinfo_list (struct funcinfo *head)
{
  struct funcinfo *rhead;
  struct funcinfo *temp;

  for (rhead = NULL; head; head = temp)
    {
      temp = head->prev_func;
      head->prev_func = rhead;
      rhead = head;
    }
  return rhead;
}

static struct varinfo *
reverse_varinfo_list (struct varinfo *head)
{
  struct varinfo *rhead;
  struct varinfo *temp;

  for (rhead = NULL; head; head = temp)
    {
      temp = head->prev_var;
      head->prev_var = rhead;
      rhead = head;
    }
  return rhead;
}

/* Extract all interesting funcinfos and varinfos of a compilation
   unit into hash tables for faster lookup.  Returns TRUE if no
   errors were enountered; FALSE otherwise.  */

static bfd_boolean
comp_unit_hash_info (struct dwarf2_debug *stash,
		     struct comp_unit *unit,
		     struct info_hash_table *funcinfo_hash_table,
		     struct info_hash_table *varinfo_hash_table)
{
  struct funcinfo* each_func;
  struct varinfo* each_var;
  bfd_boolean okay = TRUE;

  BFD_ASSERT (stash->info_hash_status != STASH_INFO_HASH_DISABLED);

  if (!comp_unit_maybe_decode_line_info (unit, stash))
    return FALSE;

  BFD_ASSERT (!unit->cached);

  /* To preserve the original search order, we went to visit the function
     infos in the reversed order of the list.  However, making the list
     bi-directional use quite a bit of extra memory.  So we reverse
     the list first, traverse the list in the now reversed order and
     finally reverse the list again to get back the original order.  */
  unit->function_table = reverse_funcinfo_list (unit->function_table);
  for (each_func = unit->function_table;
       each_func && okay;
       each_func = each_func->prev_func)
    {
      /* Skip nameless functions. */
      if (each_func->name)
	/* There is no need to copy name string into hash table as
	   name string is either in the dwarf string buffer or
	   info in the stash.  */
	okay = insert_info_hash_table (funcinfo_hash_table, each_func->name,
				       (void*) each_func, FALSE);
    }
  unit->function_table = reverse_funcinfo_list (unit->function_table);
  if (!okay)
    return FALSE;

  /* We do the same for variable infos.  */
  unit->variable_table = reverse_varinfo_list (unit->variable_table);
  for (each_var = unit->variable_table;
       each_var && okay;
       each_var = each_var->prev_var)
    {
      /* Skip stack vars and vars with no files or names.  */
      if (each_var->stack == 0
	  && each_var->file != NULL
	  && each_var->name != NULL)
	/* There is no need to copy name string into hash table as
	   name string is either in the dwarf string buffer or
	   info in the stash.  */
	okay = insert_info_hash_table (varinfo_hash_table, each_var->name,
				       (void*) each_var, FALSE);
    }

  unit->variable_table = reverse_varinfo_list (unit->variable_table);
  unit->cached = TRUE;
  return okay;
}

/* Locate a section in a BFD containing debugging info.  The search starts
   from the section after AFTER_SEC, or from the first section in the BFD if
   AFTER_SEC is NULL.  The search works by examining the names of the
   sections.  There are three permissiable names.  The first two are given
   by DEBUG_SECTIONS[debug_info] (whose standard DWARF2 names are .debug_info
   and .zdebug_info).  The third is a prefix .gnu.linkonce.wi.
   This is a variation on the .debug_info section which has a checksum
   describing the contents appended onto the name.  This allows the linker to
   identify and discard duplicate debugging sections for different
   compilation units.  */
#define GNU_LINKONCE_INFO ".gnu.linkonce.wi."

static asection *
find_debug_info (bfd *abfd, const struct dwarf_debug_section *debug_sections,
                 asection *after_sec)
{
  asection *msec;
  const char *look;

  if (after_sec == NULL)
    {
      look = debug_sections[debug_info].uncompressed_name;
      msec = bfd_get_section_by_name (abfd, look);
      if (msec != NULL)
	return msec;

      look = debug_sections[debug_info].compressed_name;
      if (look != NULL)
	{
	  msec = bfd_get_section_by_name (abfd, look);
	  if (msec != NULL)
	    return msec;
	}

      for (msec = abfd->sections; msec != NULL; msec = msec->next)
	if (CONST_STRNEQ (msec->name, GNU_LINKONCE_INFO))
	  return msec;

      return NULL;
    }

  for (msec = after_sec->next; msec != NULL; msec = msec->next)
    {
      look = debug_sections[debug_info].uncompressed_name;
      if (strcmp (msec->name, look) == 0)
	return msec;

      look = debug_sections[debug_info].compressed_name;
      if (look != NULL && strcmp (msec->name, look) == 0)
	return msec;

      if (CONST_STRNEQ (msec->name, GNU_LINKONCE_INFO))
	return msec;
    }

  return NULL;
}

/* Unset vmas for adjusted sections in STASH.  */

static void
unset_sections (struct dwarf2_debug *stash)
{
  unsigned int i;
  struct adjusted_section *p;

  i = stash->adjusted_section_count;
  p = stash->adjusted_sections;
  for (; i > 0; i--, p++)
    p->section->vma = 0;
}

/* Set unique VMAs for loadable and DWARF sections in ABFD and save
   VMAs in STASH for unset_sections.  */

static bfd_boolean
place_sections (bfd *abfd, struct dwarf2_debug *stash)
{
  struct adjusted_section *p;
  unsigned int i;

  if (stash->adjusted_section_count != 0)
    {
      i = stash->adjusted_section_count;
      p = stash->adjusted_sections;
      for (; i > 0; i--, p++)
	p->section->vma = p->adj_vma;
    }
  else
    {
      asection *sect;
      bfd_vma last_vma = 0, last_dwarf = 0;
      bfd_size_type amt;
      const char *debug_info_name;

      debug_info_name = stash->debug_sections[debug_info].uncompressed_name;
      i = 0;
      for (sect = abfd->sections; sect != NULL; sect = sect->next)
	{
	  bfd_size_type sz;
	  int is_debug_info;

	  if (sect->vma != 0)
	    continue;

	  /* We need to adjust the VMAs of any .debug_info sections.
	     Skip compressed ones, since no relocations could target
	     them - they should not appear in object files anyway.  */
	  if (strcmp (sect->name, debug_info_name) == 0)
	    is_debug_info = 1;
	  else if (CONST_STRNEQ (sect->name, GNU_LINKONCE_INFO))
	    is_debug_info = 1;
	  else
	    is_debug_info = 0;

	  if (!is_debug_info && (sect->flags & SEC_LOAD) == 0)
	    continue;

	  sz = sect->rawsize ? sect->rawsize : sect->size;
	  if (sz == 0)
	    continue;

	  i++;
	}

      amt = i * sizeof (struct adjusted_section);
      p = (struct adjusted_section *) bfd_alloc (abfd, amt);
      if (! p)
	return FALSE;

      stash->adjusted_sections = p;
      stash->adjusted_section_count = i;

      for (sect = abfd->sections; sect != NULL; sect = sect->next)
	{
	  bfd_size_type sz;
	  int is_debug_info;

	  if (sect->vma != 0)
	    continue;

	  /* We need to adjust the VMAs of any .debug_info sections.
	     Skip compressed ones, since no relocations could target
	     them - they should not appear in object files anyway.  */
	  if (strcmp (sect->name, debug_info_name) == 0)
	    is_debug_info = 1;
	  else if (CONST_STRNEQ (sect->name, GNU_LINKONCE_INFO))
	    is_debug_info = 1;
	  else
	    is_debug_info = 0;

	  if (!is_debug_info && (sect->flags & SEC_LOAD) == 0)
	    continue;

	  sz = sect->rawsize ? sect->rawsize : sect->size;
	  if (sz == 0)
	    continue;

	  p->section = sect;
	  if (is_debug_info)
	    {
	      BFD_ASSERT (sect->alignment_power == 0);
	      sect->vma = last_dwarf;
	      last_dwarf += sz;
	    }
	  else if (last_vma != 0)
	    {
	      /* Align the new address to the current section
		 alignment.  */
	      last_vma = ((last_vma
			   + ~((bfd_vma) -1 << sect->alignment_power))
			  & ((bfd_vma) -1 << sect->alignment_power));
	      sect->vma = last_vma;
	      last_vma += sect->vma + sz;
	    }
	  else
	    last_vma += sect->vma + sz;

	  p->adj_vma = sect->vma;

	  p++;
	}
    }

  return TRUE;
}

/* Look up a funcinfo by name using the given info hash table.  If found,
   also update the locations pointed to by filename_ptr and linenumber_ptr.

   This function returns TRUE if a funcinfo that matches the given symbol
   and address is found with any error; otherwise it returns FALSE.  */

static bfd_boolean
info_hash_lookup_funcinfo (struct info_hash_table *hash_table,
			   asymbol *sym,
			   bfd_vma addr,
			   const char **filename_ptr,
			   unsigned int *linenumber_ptr)
{
  struct funcinfo* each_func;
  struct funcinfo* best_fit = NULL;
  struct info_list_node *node;
  struct arange *arange;
  const char *name = bfd_asymbol_name (sym);
  asection *sec = bfd_get_section (sym);

  for (node = lookup_info_hash_table (hash_table, name);
       node;
       node = node->next)
    {
      each_func = (struct funcinfo *) node->info;
      for (arange = &each_func->arange;
	   arange;
	   arange = arange->next)
	{
	  if ((!each_func->sec || each_func->sec == sec)
	      && addr >= arange->low
	      && addr < arange->high
	      && (!best_fit
		  || (arange->high - arange->low
		      < best_fit->arange.high - best_fit->arange.low)))
	    best_fit = each_func;
	}
    }

  if (best_fit)
    {
      best_fit->sec = sec;
      *filename_ptr = best_fit->file;
      *linenumber_ptr = best_fit->line;
      return TRUE;
    }

  return FALSE;
}

/* Look up a varinfo by name using the given info hash table.  If found,
   also update the locations pointed to by filename_ptr and linenumber_ptr.

   This function returns TRUE if a varinfo that matches the given symbol
   and address is found with any error; otherwise it returns FALSE.  */

static bfd_boolean
info_hash_lookup_varinfo (struct info_hash_table *hash_table,
			  asymbol *sym,
			  bfd_vma addr,
			  const char **filename_ptr,
			  unsigned int *linenumber_ptr)
{
  const char *name = bfd_asymbol_name (sym);
  asection *sec = bfd_get_section (sym);
  struct varinfo* each;
  struct info_list_node *node;

  for (node = lookup_info_hash_table (hash_table, name);
       node;
       node = node->next)
    {
      each = (struct varinfo *) node->info;
      if (each->addr == addr
	  && (!each->sec || each->sec == sec))
	{
	  each->sec = sec;
	  *filename_ptr = each->file;
	  *linenumber_ptr = each->line;
	  return TRUE;
	}
    }

  return FALSE;
}

/* Update the funcinfo and varinfo info hash tables if they are
   not up to date.  Returns TRUE if there is no error; otherwise
   returns FALSE and disable the info hash tables.  */

static bfd_boolean
stash_maybe_update_info_hash_tables (struct dwarf2_debug *stash)
{
  struct comp_unit *each;

  /* Exit if hash tables are up-to-date.  */
  if (stash->all_comp_units == stash->hash_units_head)
    return TRUE;

  if (stash->hash_units_head)
    each = stash->hash_units_head->prev_unit;
  else
    each = stash->last_comp_unit;

  while (each)
    {
      if (!comp_unit_hash_info (stash, each, stash->funcinfo_hash_table,
				stash->varinfo_hash_table))
	{
	  stash->info_hash_status = STASH_INFO_HASH_DISABLED;
	  return FALSE;
	}
      each = each->prev_unit;
    }

  stash->hash_units_head = stash->all_comp_units;
  return TRUE;
}

/* Check consistency of info hash tables.  This is for debugging only. */

static void ATTRIBUTE_UNUSED
stash_verify_info_hash_table (struct dwarf2_debug *stash)
{
  struct comp_unit *each_unit;
  struct funcinfo *each_func;
  struct varinfo *each_var;
  struct info_list_node *node;
  bfd_boolean found;

  for (each_unit = stash->all_comp_units;
       each_unit;
       each_unit = each_unit->next_unit)
    {
      for (each_func = each_unit->function_table;
	   each_func;
	   each_func = each_func->prev_func)
	{
	  if (!each_func->name)
	    continue;
	  node = lookup_info_hash_table (stash->funcinfo_hash_table,
					 each_func->name);
	  BFD_ASSERT (node);
	  found = FALSE;
	  while (node && !found)
	    {
	      found = node->info == each_func;
	      node = node->next;
	    }
	  BFD_ASSERT (found);
	}

      for (each_var = each_unit->variable_table;
	   each_var;
	   each_var = each_var->prev_var)
	{
	  if (!each_var->name || !each_var->file || each_var->stack)
	    continue;
	  node = lookup_info_hash_table (stash->varinfo_hash_table,
					 each_var->name);
	  BFD_ASSERT (node);
	  found = FALSE;
	  while (node && !found)
	    {
	      found = node->info == each_var;
	      node = node->next;
	    }
	  BFD_ASSERT (found);
	}
    }
}

/* Check to see if we want to enable the info hash tables, which consume
   quite a bit of memory.  Currently we only check the number times
   bfd_dwarf2_find_line is called.  In the future, we may also want to
   take the number of symbols into account.  */

static void
stash_maybe_enable_info_hash_tables (bfd *abfd, struct dwarf2_debug *stash)
{
  BFD_ASSERT (stash->info_hash_status == STASH_INFO_HASH_OFF);

  if (stash->info_hash_count++ < STASH_INFO_HASH_TRIGGER)
    return;

  /* FIXME: Maybe we should check the reduce_memory_overheads
     and optimize fields in the bfd_link_info structure ?  */

  /* Create hash tables.  */
  stash->funcinfo_hash_table = create_info_hash_table (abfd);
  stash->varinfo_hash_table = create_info_hash_table (abfd);
  if (!stash->funcinfo_hash_table || !stash->varinfo_hash_table)
    {
      /* Turn off info hashes if any allocation above fails.  */
      stash->info_hash_status = STASH_INFO_HASH_DISABLED;
      return;
    }
  /* We need a forced update so that the info hash tables will
     be created even though there is no compilation unit.  That
     happens if STASH_INFO_HASH_TRIGGER is 0.  */
  stash_maybe_update_info_hash_tables (stash);
  stash->info_hash_status = STASH_INFO_HASH_ON;
}

/* Find the file and line associated with a symbol and address using the
   info hash tables of a stash. If there is a match, the function returns
   TRUE and update the locations pointed to by filename_ptr and linenumber_ptr;
   otherwise it returns FALSE.  */

static bfd_boolean
stash_find_line_fast (struct dwarf2_debug *stash,
		      asymbol *sym,
		      bfd_vma addr,
		      const char **filename_ptr,
		      unsigned int *linenumber_ptr)
{
  BFD_ASSERT (stash->info_hash_status == STASH_INFO_HASH_ON);

  if (sym->flags & BSF_FUNCTION)
    return info_hash_lookup_funcinfo (stash->funcinfo_hash_table, sym, addr,
				      filename_ptr, linenumber_ptr);
  return info_hash_lookup_varinfo (stash->varinfo_hash_table, sym, addr,
				   filename_ptr, linenumber_ptr);
}

/* Read debug information from DEBUG_BFD when DEBUG_BFD is specified.
   If DEBUG_BFD is not specified, we read debug information from ABFD
   or its gnu_debuglink. The results will be stored in PINFO.
   The function returns TRUE iff debug information is ready.  */

bfd_boolean
_bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,
                              const struct dwarf_debug_section *debug_sections,
                              asymbol **symbols,
                              void **pinfo)
{
  bfd_size_type amt = sizeof (struct dwarf2_debug);
  bfd_size_type total_size;
  asection *msec;
  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;

  if (stash != NULL)
    return TRUE;

  stash = (struct dwarf2_debug *) bfd_zalloc (abfd, amt);
  if (! stash)
    return FALSE;
  stash->debug_sections = debug_sections;
  stash->syms = symbols;

  *pinfo = stash;

  if (debug_bfd == NULL)
    debug_bfd = abfd;

  msec = find_debug_info (debug_bfd, debug_sections, NULL);
  if (msec == NULL && abfd == debug_bfd)
    {
      char * debug_filename = bfd_follow_gnu_debuglink (abfd, DEBUGDIR);

      if (debug_filename == NULL)
	/* No dwarf2 info, and no gnu_debuglink to follow.
	   Note that at this point the stash has been allocated, but
	   contains zeros.  This lets future calls to this function
	   fail more quickly.  */
	return FALSE;

      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
	  || ! bfd_check_format (debug_bfd, bfd_object)
	  || (msec = find_debug_info (debug_bfd,
				      debug_sections, NULL)) == NULL)
	{
	  if (debug_bfd)
	    bfd_close (debug_bfd);
	  /* FIXME: Should we report our failure to follow the debuglink ?  */
	  free (debug_filename);
	  return FALSE;
	}
      stash->close_on_cleanup = TRUE;
    }
  stash->bfd_ptr = debug_bfd;

  /* There can be more than one DWARF2 info section in a BFD these
     days.  First handle the easy case when there's only one.  If
     there's more than one, try case two: none of the sections is
     compressed.  In that case, read them all in and produce one
     large stash.  We do this in two passes - in the first pass we
     just accumulate the section sizes, and in the second pass we
     read in the section's contents.  (The allows us to avoid
     reallocing the data as we add sections to the stash.)  If
     some or all sections are compressed, then do things the slow
     way, with a bunch of reallocs.  */

  if (! find_debug_info (debug_bfd, debug_sections, msec))
    {
      /* Case 1: only one info section.  */
      total_size = msec->size;
      if (! read_section (debug_bfd, &stash->debug_sections[debug_info],
			  symbols, 0,
			  &stash->info_ptr_memory, &total_size))
	return FALSE;
    }
  else
    {
      /* Case 2: multiple sections.  */
      for (total_size = 0;
	   msec;
	   msec = find_debug_info (debug_bfd, debug_sections, msec))
	total_size += msec->size;

      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);
      if (stash->info_ptr_memory == NULL)
	return FALSE;

      total_size = 0;
      for (msec = find_debug_info (debug_bfd, debug_sections, NULL);
	   msec;
	   msec = find_debug_info (debug_bfd, debug_sections, msec))
	{
	  bfd_size_type size;

	  size = msec->size;
	  if (size == 0)
	    continue;

	  if (!(bfd_simple_get_relocated_section_contents
		(debug_bfd, msec, stash->info_ptr_memory + total_size,
		 symbols)))
	    return FALSE;

	  total_size += size;
	}
    }

  stash->info_ptr = stash->info_ptr_memory;
  stash->info_ptr_end = stash->info_ptr + total_size;
  stash->sec = find_debug_info (debug_bfd, debug_sections, NULL);
  stash->sec_info_ptr = stash->info_ptr;
  return TRUE;
}

/* Find the source code location of SYMBOL.  If SYMBOL is NULL
   then find the nearest source code location corresponding to
   the address SECTION + OFFSET.
   Returns TRUE if the line is found without error and fills in
   FILENAME_PTR and LINENUMBER_PTR.  In the case where SYMBOL was
   NULL the FUNCTIONNAME_PTR is also filled in.
   SYMBOLS contains the symbol table for ABFD.
   DEBUG_SECTIONS contains the name of the dwarf debug sections.
   ADDR_SIZE is the number of bytes in the initial .debug_info length
   field and in the abbreviation offset, or zero to indicate that the
   default value should be used.  */

static bfd_boolean
find_line (bfd *abfd,
           const struct dwarf_debug_section *debug_sections,
	   asection *section,
	   bfd_vma offset,
	   asymbol *symbol,
	   asymbol **symbols,
	   const char **filename_ptr,
	   const char **functionname_ptr,
	   unsigned int *linenumber_ptr,
	   unsigned int *discriminator_ptr,
	   unsigned int addr_size,
	   void **pinfo)
{
  /* Read each compilation unit from the section .debug_info, and check
     to see if it contains the address we are searching for.  If yes,
     lookup the address, and return the line number info.  If no, go
     on to the next compilation unit.

     We keep a list of all the previously read compilation units, and
     a pointer to the next un-read compilation unit.  Check the
     previously read units before reading more.  */
  struct dwarf2_debug *stash;
  /* What address are we looking for?  */
  bfd_vma addr;
  struct comp_unit* each;
  bfd_vma found = FALSE;
  bfd_boolean do_line;

  *filename_ptr = NULL;
  if (functionname_ptr != NULL)
    *functionname_ptr = NULL;
  *linenumber_ptr = 0;
  if (discriminator_ptr)
    *discriminator_ptr = 0;

  if (! _bfd_dwarf2_slurp_debug_info (abfd, NULL,
				      debug_sections, symbols, pinfo))
    return FALSE;

  stash = (struct dwarf2_debug *) *pinfo;

  /* In a relocatable file, 2 functions may have the same address.
     We change the section vma so that they won't overlap.  */
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
    {
      if (! place_sections (abfd, stash))
	return FALSE;
    }

  do_line = (section == NULL
	     && offset == 0
	     && functionname_ptr == NULL
	     && symbol != NULL);
  if (do_line)
    {
      addr = symbol->value;
      section = bfd_get_section (symbol);
    }
  else if (section != NULL
	   && functionname_ptr != NULL
	   && symbol == NULL)
    addr = offset;
  else
    abort ();

  if (section->output_section)
    addr += section->output_section->vma + section->output_offset;
  else
    addr += section->vma;

  /* A null info_ptr indicates that there is no dwarf2 info
     (or that an error occured while setting up the stash).  */
  if (! stash->info_ptr)
    return FALSE;

  stash->inliner_chain = NULL;

  /* Check the previously read comp. units first.  */
  if (do_line)
    {
      /* The info hash tables use quite a bit of memory.  We may not want to
	 always use them.  We use some heuristics to decide if and when to
	 turn it on.  */
      if (stash->info_hash_status == STASH_INFO_HASH_OFF)
	stash_maybe_enable_info_hash_tables (abfd, stash);

      /* Keep info hash table up to date if they are available.  Note that we
	 may disable the hash tables if there is any error duing update. */
      if (stash->info_hash_status == STASH_INFO_HASH_ON)
	stash_maybe_update_info_hash_tables (stash);

      if (stash->info_hash_status == STASH_INFO_HASH_ON)
	{
	  found = stash_find_line_fast (stash, symbol, addr, filename_ptr,
					linenumber_ptr);
	  if (found)
	    goto done;
	}
      else
	{
	  /* Check the previously read comp. units first.  */
	  for (each = stash->all_comp_units; each; each = each->next_unit)
	    if ((symbol->flags & BSF_FUNCTION) == 0
		|| each->arange.high == 0
		|| comp_unit_contains_address (each, addr))
	      {
		found = comp_unit_find_line (each, symbol, addr, filename_ptr,
					     linenumber_ptr, stash);
		if (found)
		  goto done;
	      }
	}
    }
  else
    {
      for (each = stash->all_comp_units; each; each = each->next_unit)
	{
	  found = ((each->arange.high == 0
		    || comp_unit_contains_address (each, addr))
		   && comp_unit_find_nearest_line (each, addr,
						   filename_ptr,
						   functionname_ptr,
						   linenumber_ptr,
						   discriminator_ptr,
						   stash));
	  if (found)
	    goto done;
	}
    }

  /* The DWARF2 spec says that the initial length field, and the
     offset of the abbreviation table, should both be 4-byte values.
     However, some compilers do things differently.  */
  if (addr_size == 0)
    addr_size = 4;
  BFD_ASSERT (addr_size == 4 || addr_size == 8);

  /* Read each remaining comp. units checking each as they are read.  */
  while (stash->info_ptr < stash->info_ptr_end)
    {
      bfd_vma length;
      unsigned int offset_size = addr_size;
      bfd_byte *info_ptr_unit = stash->info_ptr;

      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr);
      /* A 0xffffff length is the DWARF3 way of indicating
	 we use 64-bit offsets, instead of 32-bit offsets.  */
      if (length == 0xffffffff)
	{
	  offset_size = 8;
	  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4);
	  stash->info_ptr += 12;
	}
      /* A zero length is the IRIX way of indicating 64-bit offsets,
	 mostly because the 64-bit length will generally fit in 32
	 bits, and the endianness helps.  */
      else if (length == 0)
	{
	  offset_size = 8;
	  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4);
	  stash->info_ptr += 8;
	}
      /* In the absence of the hints above, we assume 32-bit DWARF2
	 offsets even for targets with 64-bit addresses, because:
	   a) most of the time these targets will not have generated
	      more than 2Gb of debug info and so will not need 64-bit
	      offsets,
	 and
	   b) if they do use 64-bit offsets but they are not using
	      the size hints that are tested for above then they are
	      not conforming to the DWARF3 standard anyway.  */
      else if (addr_size == 8)
	{
	  offset_size = 4;
	  stash->info_ptr += 4;
	}
      else
	stash->info_ptr += 4;

      if (length > 0)
	{
	  each = parse_comp_unit (stash, length, info_ptr_unit,
				  offset_size);
	  if (!each)
	    /* The dwarf information is damaged, don't trust it any
	       more.  */
	    break;
	  stash->info_ptr += length;

	  if (stash->all_comp_units)
	    stash->all_comp_units->prev_unit = each;
	  else
	    stash->last_comp_unit = each;

	  each->next_unit = stash->all_comp_units;
	  stash->all_comp_units = each;

	  /* DW_AT_low_pc and DW_AT_high_pc are optional for
	     compilation units.  If we don't have them (i.e.,
	     unit->high == 0), we need to consult the line info table
	     to see if a compilation unit contains the given
	     address.  */
	  if (do_line)
	    found = (((symbol->flags & BSF_FUNCTION) == 0
		      || each->arange.high == 0
		      || comp_unit_contains_address (each, addr))
		     && comp_unit_find_line (each, symbol, addr,
					     filename_ptr,
					     linenumber_ptr,
					     stash));
	  else
	    found = ((each->arange.high == 0
		      || comp_unit_contains_address (each, addr))
		     && comp_unit_find_nearest_line (each, addr,
						     filename_ptr,
						     functionname_ptr,
						     linenumber_ptr,
						     discriminator_ptr,
						     stash));

	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
	      == stash->sec->size)
	    {
	      stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,
                                            stash->sec);
	      stash->sec_info_ptr = stash->info_ptr;
	    }

	  if (found)
	    goto done;
	}
    }

 done:
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
    unset_sections (stash);

  return found;
}

/* The DWARF2 version of find_nearest_line.
   Return TRUE if the line is found without error.  */

bfd_boolean
_bfd_dwarf2_find_nearest_line (bfd *abfd,
                               const struct dwarf_debug_section *debug_sections,
			       asection *section,
			       asymbol **symbols,
			       bfd_vma offset,
			       const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *linenumber_ptr,
                               unsigned int *discriminator_ptr,
			       unsigned int addr_size,
			       void **pinfo)
{
  return find_line (abfd, debug_sections, section, offset, NULL, symbols,
                    filename_ptr, functionname_ptr, linenumber_ptr,
                    discriminator_ptr, addr_size, pinfo);
}

/* The DWARF2 version of find_line.
   Return TRUE if the line is found without error.  */

bfd_boolean
_bfd_dwarf2_find_line (bfd *abfd,
		       asymbol **symbols,
		       asymbol *symbol,
		       const char **filename_ptr,
		       unsigned int *linenumber_ptr,
                       unsigned int *discriminator_ptr,
		       unsigned int addr_size,
		       void **pinfo)
{
  return find_line (abfd, dwarf_debug_sections, NULL, 0, symbol, symbols,
                    filename_ptr, NULL, linenumber_ptr, discriminator_ptr,
                    addr_size, pinfo);
}

bfd_boolean
_bfd_dwarf2_find_inliner_info (bfd *abfd ATTRIBUTE_UNUSED,
			       const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *linenumber_ptr,
			       void **pinfo)
{
  struct dwarf2_debug *stash;

  stash = (struct dwarf2_debug *) *pinfo;
  if (stash)
    {
      struct funcinfo *func = stash->inliner_chain;

      if (func && func->caller_func)
	{
	  *filename_ptr = func->caller_file;
	  *functionname_ptr = func->caller_func->name;
	  *linenumber_ptr = func->caller_line;
	  stash->inliner_chain = func->caller_func;
	  return TRUE;
	}
    }

  return FALSE;
}

void
_bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)
{
  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;
  struct comp_unit *each;

  if (abfd == NULL || stash == NULL)
    return;

  for (each = stash->all_comp_units; each; each = each->next_unit)
    {
      struct abbrev_info **abbrevs = each->abbrevs;
      struct funcinfo *function_table = each->function_table;
      struct varinfo *variable_table = each->variable_table;
      size_t i;

      for (i = 0; i < ABBREV_HASH_SIZE; i++)
	{
	  struct abbrev_info *abbrev = abbrevs[i];

	  while (abbrev)
	    {
	      free (abbrev->attrs);
	      abbrev = abbrev->next;
	    }
	}

      if (each->line_table)
	{
	  free (each->line_table->dirs);
	  free (each->line_table->files);
	}

      while (function_table)
	{
	  if (function_table->file)
	    {
	      free (function_table->file);
	      function_table->file = NULL;
	    }

	  if (function_table->caller_file)
	    {
	      free (function_table->caller_file);
	      function_table->caller_file = NULL;
	    }
	  function_table = function_table->prev_func;
	}

      while (variable_table)
	{
	  if (variable_table->file)
	    {
	      free (variable_table->file);
	      variable_table->file = NULL;
	    }

	  variable_table = variable_table->prev_var;
	}
    }

  if (stash->dwarf_abbrev_buffer)
    free (stash->dwarf_abbrev_buffer);
  if (stash->dwarf_line_buffer)
    free (stash->dwarf_line_buffer);
  if (stash->dwarf_str_buffer)
    free (stash->dwarf_str_buffer);
  if (stash->dwarf_ranges_buffer)
    free (stash->dwarf_ranges_buffer);
  if (stash->info_ptr_memory)
    free (stash->info_ptr_memory);
  if (stash->close_on_cleanup)
    bfd_close (stash->bfd_ptr);
  if (stash->alt_dwarf_str_buffer)
    free (stash->alt_dwarf_str_buffer);
  if (stash->alt_dwarf_info_buffer)
    free (stash->alt_dwarf_info_buffer);
  if (stash->alt_bfd_ptr)
    bfd_close (stash->alt_bfd_ptr);
}
@


1.153
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d110 10
d302 1
d313 1
d326 2
d334 1
d345 1
d502 2
a503 2
  /* read_section is a noop if the section has already been read.  */
  if (!*section_buffer)
d644 98
d945 1
d995 4
d1071 1
a1071 1
      (*_bfd_error_handler) (_("Dwarf Error: Invalid or unhandled FORM value: %u."),
d2117 1
a2117 1
  char *name = 0;
d2130 11
d2143 1
d3827 6
@


1.152
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d2012 1
a2012 1
  else 
d3511 1
a3511 1
	  
d3514 1
a3514 1
	  
@


1.151
log
@	* dwarf2.c (struct dwarf2_debug): Add close_on_cleanup.
	(_bfd_dwarf2_slurp_debug_info): Set close_on_cleanup if we open
	gnu_debuglink bfd.
	(_bfd_dwarf2_cleanup_debug_info): Act on close_on_cleanup.
@
text
@d3627 1
a3627 1
  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;;
@


1.150
log
@2012-07-26  Teresa Johnson  <tejohnson@@google.com>

	* bfd/dwarf2.c (find_line): Initialize discriminator_ptr
	if it is non-NULL.
@
text
@d176 3
d3212 1
d3242 1
d3244 1
a3301 3
  stash->syms = symbols;
  stash->bfd_ptr = debug_bfd;

d3695 2
@


1.149
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d3347 2
@


1.148
log
@	* dwarf2.c: Formatting.
	(arange_add): Pass in unit rather than bfd.  Update callers.
	Ignore empty ranges.  Don't ask for cleared memory.
	(parse_comp_unit): Only set unit->base_address if processing
	DW_TAG_compile_unit.
	(find_debug_info): Optimise section lookup.
	(place_sections): Use bfd_alloc for stash->adjusted_sections.
	(find_line): Match previously parsed comp unit addresses as we
	do for newly parsed comp units.
@
text
@d983 1
d1084 1
d1100 1
d1579 1
d1614 1
a1614 1
				  line, column, 0))
d1616 1
d1634 2
a1635 2
		  if (!add_line_info (table, address, op_index, filename,
				      line, column, end_sequence))
d1637 1
d1677 2
a1678 1
		  (void) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
d1696 1
a1696 1
				  filename, line, column, 0))
d1698 1
d1799 2
a1800 1
				   unsigned int *linenumber_ptr)
d1835 2
d2566 1
d2607 2
a2608 1
					      linenumber_ptr);
d3324 1
d3436 1
d3530 1
d3565 1
d3570 2
a3571 2
                    filename_ptr, functionname_ptr, linenumber_ptr, addr_size,
		    pinfo);
d3583 1
d3588 2
a3589 1
                    filename_ptr, NULL, linenumber_ptr, addr_size, pinfo);
@


1.147
log
@2012-05-03  Tristan Gingold  <gingold@@adacore.com>

        * dwarf2.c (decode_line_info): Ignore
        DW_LNE_HP_source_file_correlation.
@
text
@d408 2
a409 2
  hash_table = (struct info_hash_table *)
      bfd_alloc (abfd, sizeof (struct info_hash_table));
d506 1
a506 1
	      = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
d525 2
a526 1
      (*_bfd_error_handler) (_("Dwarf Error: Offset (%lu) greater than or equal to %s size (%lu)."),
d1018 1
a1018 1
   source code location where this function was inlined. */
d1022 12
a1033 6
  struct funcinfo *prev_func;		/* Pointer to previous function in list of all functions */
  struct funcinfo *caller_func;		/* Pointer to function one scope higher */
  char *caller_file;			/* Source location file name where caller_func inlines this func */
  int caller_line;			/* Source location line number where caller_func inlines this func */
  char *file;				/* Source location file name */
  int line;				/* Source location line number */
d1037 2
a1038 1
  asection *sec;			/* Where the symbol is defined */
d1259 1
a1259 1
arange_add (bfd *abfd, struct arange *first_arange,
d1264 5
a1268 1
  /* If the first arange is empty, use it. */
d1296 1
a1296 1
  arange = (struct arange *) bfd_zalloc (abfd, sizeof (*arange));
d1597 2
a1598 2
		address += (adj_opcode / lh.line_range)
			   * lh.minimum_instruction_length;
d1601 5
a1605 5
		  address += ((op_index + (adj_opcode / lh.line_range))
			      / lh.maximum_ops_per_insn)
			     * lh.minimum_instruction_length;
		  op_index = (op_index + (adj_opcode / lh.line_range))
			     % lh.maximum_ops_per_insn;
d1620 1
a1620 1
              exop_len = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
d1636 1
a1636 1
		  if (!arange_add (unit->abfd, &unit->arange, low_pc, high_pc))
d1674 3
a1676 3
                case DW_LNE_HP_source_file_correlation:
                  line_ptr += exop_len - 1;
                  break;
d1678 2
a1679 1
		  (*_bfd_error_handler) (_("Dwarf Error: mangled line number section."));
d1698 3
a1700 3
		address += lh.minimum_instruction_length
			   * read_unsigned_leb128 (abfd, line_ptr,
						   &bytes_read);
d1705 2
a1706 2
		  address = ((op_index + adjust) / lh.maximum_ops_per_insn)
			    * lh.minimum_instruction_length;
d1739 2
a1740 2
		address += lh.minimum_instruction_length
			   * ((255 - lh.opcode_base) / lh.line_range);
d1744 3
a1746 2
		  address += lh.minimum_instruction_length
			     * ((op_index + adjust) / lh.maximum_ops_per_insn);
d1872 3
a1874 2
	      if (!best_fit ||
		  ((arange->high - arange->low) < (best_fit->arange.high - best_fit->arange.low)))
d1922 2
a1923 2
		  || ((arange->high - arange->low)
		      < (best_fit->arange.high - best_fit->arange.low))))
d2008 2
a2009 2
	  (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %u."),
				 abbrev_number);
d2074 1
a2074 1
	  if (!arange_add (unit->abfd, arange,
d2100 1
a2100 1
      bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));
d2304 1
a2304 1
	  if (!arange_add (unit->abfd, &func->arange, low_pc, high_pc))
d2318 2
a2319 2
                 bfd_realloc (nested_funcs,
                              (nested_funcs_size * sizeof (struct funcinfo *)));
d2380 3
a2382 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%u', this reader only handles version 2, 3 and 4 information."), version);
d2389 5
a2393 3
      (*_bfd_error_handler) (_("Dwarf Error: found address size '%u', this reader can not handle sizes greater than '%u'."),
			 addr_size,
			 (unsigned int) sizeof (bfd_vma));
d2400 3
a2402 1
      (*_bfd_error_handler) ("Dwarf Error: found address size '%u', this reader can only handle address sizes '2', '4' and '8'.", addr_size);
d2410 1
a2410 1
      return 0;
d2417 1
a2417 1
			 abbrev_number);
d2426 1
a2426 1
			 abbrev_number);
d2469 2
a2470 1
	  unit->base_address = low_pc;
d2507 1
a2507 1
      if (!arange_add (unit->abfd, &unit->arange, low_pc, high_pc))
d2777 9
a2785 1
  asection * msec;
d2787 7
a2793 1
  msec = after_sec != NULL ? after_sec->next : abfd->sections;
d2795 8
a2802 1
  while (msec)
d2804 2
a2805 2
      if (strcmp (msec->name,
                  debug_sections[debug_info].uncompressed_name) == 0)
d2808 2
a2809 3
      if (debug_sections[debug_info].compressed_name != NULL
          && strcmp (msec->name,
                     debug_sections[debug_info].compressed_name) == 0)
a2813 2

      msec = msec->next;
d2887 1
a2887 1
      p = (struct adjusted_section *) bfd_zalloc (abfd, amt);
d2981 2
a2982 2
		  || ((arange->high - arange->low)
		      < (best_fit->arange.high - best_fit->arange.low))))
d3402 1
d3416 2
a3417 1
	  found = (comp_unit_contains_address (each, addr)
d3530 1
a3530 1
done:
@


1.146
log
@       * dwarf2.c (scan_unit_for_symbols): Account for DW_AT_high_pc
       possibly being relative to DW_AT_low_pc.
       (parse_comp_unit): Likewise.
@
text
@d1404 1
d1608 2
a1609 2
	      /* Ignore length.  */
	      line_ptr += 1;
d1662 3
@


1.145
log
@2012-01-04  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* dwarf2.c (_bfd_dwarf2_slurp_debug_info): Factor out the part
	which reads DWARF2 and stores in stash from find_line.
	(find_line) Call _bfd_dwarf2_slurp_debug_info.
	* libbfd-in.h (_bfd_dwarf2_slurp_debug_info): Add declaration.
	* libbfd.h (_bfd_dwarf2_slurp_debug_info): Regenerate.
	* mach-o.c (dsym_subdir): The name of subdir where debug
	information may be stored.
	(bfd_mach_o_lookup_uuid_command): New. Lookup a load command whose
	type is UUID.
	(bfd_mach_o_dsym_for_uuid_p): New. Check if the specified BFD is
	corresponding to the executable.
	(bfd_mach_o_find_dsym): New. Find a debug information BFD in the
	specified binary file.
	(bfd_mach_o_follow_dsym): New. Find a debug information BFD for
	the original BFD.
	(bfd_mach_o_find_nearest_line): Check dSYM files for Mach-O
	executables, dylibs, and bundles.
	(bfd_mach_o_close_and_cleanup): Clean up BFDs for the dSYM file.
	* mach-o.h (dsym_bfd): The BFD of the dSYM file.
@
text
@d2095 1
d2201 1
d2280 3
d2346 1
d2449 1
d2477 2
@


1.144
log
@2011-12-13  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* dwarf2.c (bfd_dwarf2_cleanup_debug_info): Accept stash as an
	argument like other functions to support formats other than ELF.
	* elf-bfd.h (bfd_dwarf2_cleanup_debug_info): Move to bfd-in.h.
	* elf.c (_bfd_elf_close_and_cleanup): Pass dwarf2_find_line_info
	in tdata as a parameter.
	* libbfd-in.h (bfd_dwarf2_cleanup_debug_info): Move from
	elf-bfd.h.
	* libbfd.h (bfd_dwarf2_cleanup_debug_info): Regenerate.
	* mach-o-target.c (bfd_mach_o_close_and_cleanup): Remove the
	fallback macro.
	(bfd_mach_o_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Add the definition
	which calls _bfd_dwarf2_find_nearest_line.
	(bfd_mach_o_close_and_cleanup): Likewise.
	* mach-o.h (mach_o_data_struct): Add dwarf2_find_line_info.
	(bfd_mach_o_find_nearest_line): Add declaration.
	(bfd_mach_o_close_and_cleanup): Add declaration.
@
text
@d3120 116
d3276 4
a3279 1
  stash = (struct dwarf2_debug *) *pinfo;
d3281 3
a3283 3
  if (! stash)
    {
      bfd_size_type amt = sizeof (struct dwarf2_debug);
d3285 1
a3285 5
      stash = (struct dwarf2_debug *) bfd_zalloc (abfd, amt);
      if (! stash)
	return FALSE;
      stash->debug_sections = debug_sections;
    }
a3314 99
  *filename_ptr = NULL;
  if (! do_line)
    *functionname_ptr = NULL;
  *linenumber_ptr = 0;

  if (! *pinfo)
    {
      bfd *debug_bfd;
      bfd_size_type total_size;
      asection *msec;

      *pinfo = stash;

      msec = find_debug_info (abfd, debug_sections, NULL);
      if (msec == NULL)
	{
	  char * debug_filename = bfd_follow_gnu_debuglink (abfd, DEBUGDIR);

	  if (debug_filename == NULL)
	    /* No dwarf2 info, and no gnu_debuglink to follow.
	       Note that at this point the stash has been allocated, but
	       contains zeros.  This lets future calls to this function
	       fail more quickly.  */
	    goto done;

	  if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
	      || ! bfd_check_format (debug_bfd, bfd_object)
	      || (msec = find_debug_info (debug_bfd,
                                          debug_sections, NULL)) == NULL)
	    {
	      if (debug_bfd)
		bfd_close (debug_bfd);
	      /* FIXME: Should we report our failure to follow the debuglink ?  */
	      free (debug_filename);
	      goto done;
	    }
	}
      else
	debug_bfd = abfd;

      /* There can be more than one DWARF2 info section in a BFD these
	 days.  First handle the easy case when there's only one.  If
	 there's more than one, try case two: none of the sections is
	 compressed.  In that case, read them all in and produce one
	 large stash.  We do this in two passes - in the first pass we
	 just accumulate the section sizes, and in the second pass we
	 read in the section's contents.  (The allows us to avoid
	 reallocing the data as we add sections to the stash.)  If
	 some or all sections are compressed, then do things the slow
	 way, with a bunch of reallocs.  */

      if (! find_debug_info (debug_bfd, debug_sections, msec))
	{
	  /* Case 1: only one info section.  */
	  total_size = msec->size;
	  if (! read_section (debug_bfd, &stash->debug_sections[debug_info],
                              symbols, 0,
			      &stash->info_ptr_memory, &total_size))
	    goto done;
	}
      else
	{
	  /* Case 2: multiple sections.  */
	  for (total_size = 0;
               msec;
               msec = find_debug_info (debug_bfd, debug_sections, msec))
	    total_size += msec->size;

	  stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);
	  if (stash->info_ptr_memory == NULL)
	    goto done;

	  total_size = 0;
	  for (msec = find_debug_info (debug_bfd, debug_sections, NULL);
	       msec;
	       msec = find_debug_info (debug_bfd, debug_sections, msec))
	    {
	      bfd_size_type size;

	      size = msec->size;
	      if (size == 0)
		continue;

	      if (!(bfd_simple_get_relocated_section_contents
		    (debug_bfd, msec, stash->info_ptr_memory + total_size,
		     symbols)))
		goto done;

	      total_size += size;
	    }
	}

      stash->info_ptr = stash->info_ptr_memory;
      stash->info_ptr_end = stash->info_ptr + total_size;
      stash->sec = find_debug_info (debug_bfd, debug_sections, NULL);
      stash->sec_info_ptr = stash->info_ptr;
      stash->syms = symbols;
      stash->bfd_ptr = debug_bfd;
    }
d3319 1
a3319 1
    goto done;
@


1.143
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@d3530 1
a3530 1
_bfd_dwarf2_cleanup_debug_info (bfd *abfd)
d3532 1
a3533 1
  struct dwarf2_debug *stash;
d3535 1
a3535 6
  if (abfd == NULL || elf_tdata (abfd) == NULL)
    return;

  stash = (struct dwarf2_debug *) elf_tdata (abfd)->dwarf2_find_line_info;

  if (stash == NULL)
@


1.142
log
@	* dwarf2.c (dwarf_debug_sections): Add .debug_macro
	and .zdebug_macro entry.
	(dwarf_debug_section_enum): Add debug_macro.

	* NEWS: Mention .debug_macro support.
	* dwarf.c (read_and_display_attr_value): Don't print a tab
	if attribute is 0.
	(get_AT_name): Handle DW_AT_GNU_macros.
	(get_line_filename_and_dirname, display_debug_macro): New
	functions.
	(debug_displays): Add an entry for .debug_macro and .zdebug_macro.
	* readelf.c (process_section_headers): With do_debug_macinfo
	handle also .debug_macro sections.
	* dwarf.h (dwarf_section_display_enum): Add macro.
@
text
@d93 3
d475 1
a475 1
	      enum dwarf_debug_section_enum sec,
d482 1
a482 1
  const char *section_name = dwarf_debug_sections[sec].uncompressed_name;
d490 3
a492 2
	  section_name = dwarf_debug_sections[sec].compressed_name;
	  msec = bfd_get_section_by_name (abfd, section_name);
d496 2
a497 1
	  (*_bfd_error_handler) (_("Dwarf Error: Can't find %s section."), section_name);
d614 2
a615 1
  if (! read_section (unit->abfd, debug_str, stash->syms, offset,
d697 2
a698 1
  if (! read_section (abfd, debug_abbrev, stash->syms, offset,
d1406 2
a1407 1
  if (! read_section (abfd, debug_line, stash->syms, unit->line_offset,
d1822 2
a1823 1
  return read_section (unit->abfd, debug_ranges, stash->syms, 0,
d2729 3
a2731 2
   sections.  There are two permissiable names.  The first is .debug_info.
   This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.
a2735 2
#define DWARF2_DEBUG_INFO ".debug_info"
#define DWARF2_COMPRESSED_DEBUG_INFO ".zdebug_info"
d2739 2
a2740 1
find_debug_info (bfd *abfd, asection *after_sec)
d2748 2
a2749 1
      if (strcmp (msec->name, DWARF2_DEBUG_INFO) == 0)
d2752 3
a2754 1
      if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
d2801 1
d2803 1
d2816 1
a2816 1
	  if (strcmp (sect->name, DWARF2_DEBUG_INFO) == 0)
d2852 1
a2852 1
	  if (strcmp (sect->name, DWARF2_DEBUG_INFO) == 0)
d3127 1
d3134 1
d3169 1
d3213 1
a3213 1
      msec = find_debug_info (abfd, NULL);
d3227 2
a3228 1
	      || (msec = find_debug_info (debug_bfd, NULL)) == NULL)
d3251 1
a3251 1
      if (! find_debug_info (debug_bfd, msec))
d3255 2
a3256 1
	  if (! read_section (debug_bfd, debug_info, symbols, 0,
d3263 3
a3265 1
	  for (total_size = 0; msec; msec = find_debug_info (debug_bfd, msec))
d3273 1
a3273 1
	  for (msec = find_debug_info (debug_bfd, NULL);
d3275 1
a3275 1
	       msec = find_debug_info (debug_bfd, msec))
d3294 1
a3294 1
      stash->sec = find_debug_info (debug_bfd, NULL);
d3449 2
a3450 1
	      stash->sec = find_debug_info (stash->bfd_ptr, stash->sec);
d3471 1
d3481 2
a3482 2
  return find_line (abfd, section, offset, NULL, symbols, filename_ptr,
		    functionname_ptr, linenumber_ptr, addr_size,
d3498 2
a3499 3
  return find_line (abfd, NULL, 0, symbol, symbols, filename_ptr,
		    NULL, linenumber_ptr, addr_size,
		    pinfo);
@


1.141
log
@bfd: constify a few arrays
@
text
@d290 1
d318 1
@


1.140
log
@	* dwarf2.c (scan_unit_for_symbols): Check for DW_AT_specification.
@
text
@d281 1
a281 1
struct dwarf_debug_section dwarf_debug_sections[] =
@


1.139
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2.c (scan_unit_for_symbols): Stop memory leak.
@
text
@d2167 1
@


1.138
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d2151 1
a2151 1
	    return FALSE;
@


1.138.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a2166 1
		case DW_AT_specification:
@


1.137
log
@	PR ld/11817
	* dwarf2.c (read_section): Revert patch for compressed debug sections.
	(find_line): Likewise.
	(read_and_uncompress_section): Remove.
@
text
@d278 54
d470 1
a470 2
	      const char *    section_name,
	      const char *    compressed_section_name,
d477 1
a477 1
  bfd_boolean section_is_compressed = FALSE;
d483 1
a483 1
      if (! msec && compressed_section_name)
d485 2
a486 2
	  msec = bfd_get_section_by_name (abfd, compressed_section_name);
	  section_is_compressed = TRUE;
a511 10

      if (section_is_compressed)
	{
	  if (! bfd_uncompress_section_contents (section_buffer, section_size))
	    {
	      (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
d607 1
a607 2
  if (! read_section (unit->abfd, ".debug_str", ".zdebug_str",
		      stash->syms, offset,
d689 1
a689 2
  if (! read_section (abfd, ".debug_abbrev", ".zdebug_abbrev",
		      stash->syms, offset,
d1397 1
a1397 2
  if (! read_section (abfd, ".debug_line", ".zdebug_line",
		      stash->syms, unit->line_offset,
d1812 1
a1812 2
  return read_section (unit->abfd, ".debug_ranges", ".zdebug_ranges",
		       stash->syms, 0,
d3234 1
a3234 2
	  if (! read_section (debug_bfd, ".debug_info", ".zdebug_info",
			      symbols, 0,
d3240 1
a3240 1
	  int all_uncompressed = 1;
d3242 1
a3242 11
	    {
	      total_size += msec->size;
	      if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
		all_uncompressed = 0;
	    }
	  if (all_uncompressed)
	    {
	      /* Case 2: multiple sections, but none is compressed.  */
	      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);
	      if (stash->info_ptr_memory == NULL)
		goto done;
d3244 3
a3246 6
	      total_size = 0;
	      for (msec = find_debug_info (debug_bfd, NULL);
		   msec;
		   msec = find_debug_info (debug_bfd, msec))
		{
		  bfd_size_type size;
d3248 15
a3262 26
		  size = msec->size;
		  if (size == 0)
		    continue;

		  if (!(bfd_simple_get_relocated_section_contents
			(debug_bfd, msec, stash->info_ptr_memory + total_size,
			 symbols)))
		    goto done;

		  total_size += size;
		}
	    }
	  else
	    {
	      /* Case 3: multiple sections, some or all compressed.  */
	      stash->info_ptr_memory = NULL;
	      total_size = 0;
	      for (msec = find_debug_info (debug_bfd, NULL);
		   msec;
		   msec = find_debug_info (debug_bfd, msec))
		{
		  bfd_size_type size = msec->size;
		  bfd_byte *buffer, *tmp;

		  if (size == 0)
		    continue;
d3264 1
a3264 25
		  buffer = (bfd_simple_get_relocated_section_contents
			    (debug_bfd, msec, NULL, symbols));
		  if (! buffer)
		    goto done;

		  if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
		    {
		      if (! bfd_uncompress_section_contents (&buffer, &size))
			{
			  free (buffer);
			  goto done;
			}
		    }
		  tmp = (bfd_byte *) bfd_realloc (stash->info_ptr_memory,
						  total_size + size);
		  if (tmp == NULL)
		    {
		      free (buffer);
		      goto done;
		    }
		  stash->info_ptr_memory = tmp;
		  memcpy (stash->info_ptr_memory + total_size, buffer, size);
		  free (buffer);
		  total_size += size;
		}
@


1.136
log
@Initialize prev_line.

2010-07-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (add_line_info): Initialize prev_line.
@
text
@a407 48
/* Read a section, uncompress it if necessary, and relocate it.  */

static bfd_boolean
read_and_uncompress_section (bfd *           abfd,
			     asection *      msec,
			     bfd_boolean     section_is_compressed,
			     asymbol **      syms,
			     bfd_byte **     section_buffer,
			     bfd_size_type * section_size)
{
  /* Get the unrelocated contents of the section.  */
  *section_buffer = (bfd_byte *) bfd_malloc (*section_size);
  if (! *section_buffer)
    return FALSE;
  if (! bfd_get_section_contents (abfd, msec, *section_buffer,
				  0, *section_size))
    return FALSE;

  if (section_is_compressed)
    {
      if (! bfd_uncompress_section_contents (section_buffer, section_size))
	{
	  (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."),
				 bfd_get_section_name (abfd, msec));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  if (syms)
    {
      /* We want to relocate the data we've already read (and
	 decompressed), so we store a pointer to the data in
	 the bfd_section, and tell it that the contents are
	 already in memory.  */
      BFD_ASSERT (msec->contents == NULL && (msec->flags & SEC_IN_MEMORY) == 0);
      msec->contents = *section_buffer;
      msec->flags |= SEC_IN_MEMORY;
      msec->size = *section_size;
      *section_buffer
	  = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
      if (! *section_buffer)
	return FALSE;
    }

  return TRUE;
}

d443 16
d460 9
a468 3
      if (! read_and_uncompress_section (abfd, msec, section_is_compressed,
					 syms, section_buffer, section_size))
	return FALSE;
a3245 2
		  bfd_boolean is_compressed =
		      strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0;
d3250 3
a3252 3
		  if (! read_and_uncompress_section (debug_bfd, msec,
		  				     is_compressed, symbols,
		  				     &buffer, &size))
d3255 8
@


1.135
log
@bfd/ChangeLog:

	* compress.c (bfd_uncompress_section_contents): Add ATTRIBUTE_UNUSED.
	* dwarf2.c (read_and_uncompress_section): New function.
	(read_section): Call it.
	(find_line): Likewise.

binutils/ChangeLog:

	* objdump.c (load_specific_debug_section): Decompress section contents
	before applying relocations.
	* readelf.c (load_specific_debug_section): Update section size after
	decompression.

gas/ChangeLog:

	* Makefile.am: Add compress-debug.c and compress-debug.h.
	* Makefile.in: Regenerate.
	* config.in: Add HAVE_ZLIB_H.
	* configure.in: Check for zlib.h.
	* configure: Regenerate.

	* as.c (parse_args): Add --compress-debug-sections and
	--nocompress-debug-sections.
	* as.h (flag_compress_debug): New variable.
	* compress-debug.c: New file.
	* compress-debug.h: New file.
	* write.c: Include compress-debug.h.
	(compress_frag): New function.
	(compress_debug): New function.
	(write_object_file): Compress debug sections if requested.
@
text
@d1061 1
@


1.134
log
@	* dwarf2.c (find_abstract_instance_name, scan_unit_for_symbols): Treat
	DW_AT_linkage_name the same as DW_AT_MIPS_linkage_name.
@
text
@d408 48
a490 16
      if (syms)
	{
	  *section_buffer
	      = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
	  if (! *section_buffer)
	    return FALSE;
	}
      else
	{
	  *section_buffer = (bfd_byte *) bfd_malloc (*section_size);
	  if (! *section_buffer)
	    return FALSE;
	  if (! bfd_get_section_contents (abfd, msec, *section_buffer,
					  0, *section_size))
	    return FALSE;
	}
d492 3
a494 9
      if (section_is_compressed)
	{
	  if (! bfd_uncompress_section_contents (section_buffer, section_size))
	    {
	      (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
d3271 2
d3277 3
a3279 3
		  buffer = (bfd_simple_get_relocated_section_contents
			    (debug_bfd, msec, NULL, symbols));
		  if (! buffer)
a3281 8
		  if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
		    {
		      if (! bfd_uncompress_section_contents (&buffer, &size))
			{
			  free (buffer);
			  goto done;
			}
		    }
@


1.133
log
@include/
	* dwarf2.h (DWARF2_Internal_LineInfo): Add li_max_ops_per_insn
	field.
bfd/
	* dwarf2.c (struct line_head): Add maximum_ops_per_insn field.
	(struct line_info): Add op_index field, change end_sequence type to
	unsigned char.
	(new_line_sorts_after): For the same address compare op_index.
	(add_line_info): Add op_index argument, store it into the structure.
	(decode_line_info): Complain about unknown versions of .debug_line.
	Initialize maximum_ops_per_insn.  Add op_index state register and
	track it.
binutils/
	* dwarf.c (struct State_Machine_Registers): Add op_index field,
	change end_sequence type to unsigned char.
	(reset_state_machine): Clear op_index.
	(process_extended_line_op): For DW_LNE_set_address clear op_index.
	(display_debug_lines_raw): Initialize li_max_ops_per_insn.
	Track op_index state machine register and print it if
	li_max_ops_per_insn is != 1.
	(display_debug_lines_decoded): Likewise.
@
text
@d1953 2
a1954 1
		  /* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
d1961 1
d2131 2
a2132 1
		  /* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
d2137 1
@


1.132
log
@	* dwarf2.c (read_attribute_value): Handle CU version 4
	for DW_FORM_ref_addr, handle DW_FORM_sec_offset, DW_FORM_exprloc
	and DW_FORM_flag_present.  For unknown form value return NULL.
	(scan_unit_for_symbols): For DW_AT_location handle DW_FORM_exprloc
	like DW_FORM_block.
	(parse_comp_unit): Allow CU version 4.
@
text
@d48 1
d932 2
a933 1
  int end_sequence;		/* End of (sequential) code sequence.  */
d1007 3
a1009 1
	      && new_line->end_sequence < line->end_sequence));
d1021 1
d1036 1
d1068 1
d1264 5
d1399 7
d1414 14
d1508 1
d1532 11
a1542 2
	      address += (adj_opcode / lh.line_range)
		* lh.minimum_instruction_length;
d1545 2
a1546 1
	      if (!add_line_info (table, address, filename, line, column, 0))
d1565 2
a1566 2
		  if (!add_line_info (table, address, filename, line, column,
				      end_sequence))
d1577 1
d1620 2
a1621 1
	      if (!add_line_info (table, address, filename, line, column, 0))
d1629 12
a1640 2
	      address += lh.minimum_instruction_length
		* read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
d1670 10
a1679 2
	      address += lh.minimum_instruction_length
		      * ((255 - lh.opcode_base) / lh.line_range);
d1683 1
@


1.131
log
@	PR 11302
	* dwarf2.c (read_abbrevs): Return NULL on alloc failures.
	(read_attribute_value, decode_line_info): Likewise.
	(add_line_info, read_rangelist): Return FALSE on alloc failures.
	(arange_add, sort_line_sequences): Likewise.
	(find_abstract_instance_name): Handle failures from called funcs.
	(scan_unit_for_symbols, parse_comp_unit, decode_line_info): Likewise.
	(find_line): Realloc to a temp, and handle alloc fail.
@
text
@d763 1
a763 1
      if (unit->version == 3)
d777 7
d826 1
d857 3
d901 1
d2128 1
d2232 1
a2232 1
  if (version != 2 && version != 3)
d2234 1
a2234 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%u', this reader only handles version 2 and 3 information."), version);
@


1.130
log
@	* dwarf2.c (read_attribute_value): Add DW_FORM_ref_sig8.
@
text
@d649 1
a649 1
    return 0;
d653 2
d665 2
d780 2
d791 2
d822 2
d833 2
d1002 1
a1002 1
static void
d1014 3
d1026 3
a1028 2
      if (info->filename)
	strcpy (info->filename, filename);
d1064 2
d1113 1
d1180 3
a1182 2
static void
arange_add (bfd *abfd, struct arange *first_arange, bfd_vma low_pc, bfd_vma high_pc)
d1191 1
a1191 1
      return;
d1201 1
a1201 1
	  return;
d1206 1
a1206 1
	  return;
d1215 2
d1221 1
d1250 1
a1250 1
static void
d1261 1
a1261 1
    return;
d1266 2
d1313 1
d1334 1
a1334 1
    return 0;
d1338 2
d1416 1
a1416 4
	    {
	      free (table->dirs);
	      return NULL;
	    }
d1439 1
a1439 5
	    {
	      free (table->files);
	      free (table->dirs);
	      return NULL;
	    }
d1490 2
a1491 1
	      add_line_info (table, address, filename, line, column, 0);
d1509 3
a1511 2
		  add_line_info (table, address, filename, line, column,
				 end_sequence);
d1516 2
a1517 1
		  arange_add (unit->abfd, &unit->arange, low_pc, high_pc);
d1534 1
a1534 6
			{
			  free (table->files);
			  free (table->dirs);
			  free (filename);
			  return NULL;
			}
d1556 4
a1559 4
		  free (filename);
		  free (table->files);
		  free (table->dirs);
		  return NULL;
d1563 2
a1564 1
	      add_line_info (table, address, filename, line, column, 0);
d1624 2
a1625 1
  sort_line_sequences (table);
d1627 8
a1634 1
  return table;
d1869 4
a1872 1
	      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr);
d1892 1
a1892 1
  return (name);
d1895 3
a1897 2
static void
read_rangelist (struct comp_unit *unit, struct arange *arange, bfd_uint64_t offset)
d1905 1
a1905 1
	return;
d1924 5
a1928 1
	arange_add (unit->abfd, arange, base_address + low_pc, base_address + high_pc);
d1930 1
d1978 3
a1980 2
	  (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %u."),
			     abbrev_number);
d1982 1
a1982 2
	  free (nested_funcs);
	  return FALSE;
d1992 2
d2015 2
d2031 2
d2039 2
a2040 1
		  func->caller_file = concat_filename (unit->line_table, attr.u.val);
d2070 2
a2071 1
		  read_rangelist (unit, &func->arange, attr.u.val);
d2146 2
a2147 1
	  arange_add (unit->abfd, &func->arange, low_pc, high_pc);
d2163 1
a2163 4
		{
		  free (nested_funcs);
		  return FALSE;
		}
d2172 4
d2268 2
d2283 2
d2312 2
a2313 1
	  read_rangelist (unit, &unit->arange, attr.u.val);
d2338 2
a2339 1
      arange_add (unit->abfd, &unit->arange, low_pc, high_pc);
d3162 1
a3162 1
		  bfd_byte* buffer;
d3180 8
a3187 2
		  stash->info_ptr_memory =  (bfd_byte *)
                      bfd_realloc (stash->info_ptr_memory, total_size + size);
@


1.129
log
@update copyright date
@
text
@d861 4
@


1.128
log
@	PR 6832
	* dwarf2.c (struct comp_unit): Add sec_info_ptr.
	(find_abstract_instance_name): Use it.
	(parse_comp_unit): Set it.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.127
log
@        Fix -Wshadow warnings in dwarf2.c (seen on alpha-tru64).
        * dwarf2.c (concat_filename): Rename dirname with dir_name
        to void shadowing the dirname function.
        Rename subdirname with subdir_name to stay consistent with
        the new dir_name variable name.
@
text
@d219 3
d1817 1
a1817 1
      info_ptr = unit->stash->sec_info_ptr + die_ref;
d2225 1
@


1.126
log
@        * dwarf2.c (struct line_sequence): New struct.
        (struct line_info_table): Add num_sequences, remove last_line,
        add sequences.
        (add_line_info): Add new sequences as necessary.
        (compare_sequences): New function.
        (sort_line_sequences): New function.
        (decode_line_info): Initialize new fields in line table.
        Call sort_line_sequences.
        (lookup_address_in_line_info_table): Binary search for proper
        sequence.
@
text
@d1112 2
a1113 2
      char *dirname = NULL;
      char *subdirname = NULL;
d1118 1
a1118 1
	subdirname = table->dirs[table->files[file - 1].dir - 1];
d1120 2
a1121 2
      if (!subdirname || !IS_ABSOLUTE_PATH (subdirname))
	dirname = table->comp_dir;
d1123 1
a1123 1
      if (!dirname)
d1125 2
a1126 2
	  dirname = subdirname;
	  subdirname = NULL;
d1129 1
a1129 1
      if (!dirname)
d1132 1
a1132 1
      len = strlen (dirname) + strlen (filename) + 2;
d1134 1
a1134 1
      if (subdirname)
d1136 1
a1136 1
	  len += strlen (subdirname) + 1;
d1139 1
a1139 1
	    sprintf (name, "%s/%s/%s", dirname, subdirname, filename);
d1145 1
a1145 1
	    sprintf (name, "%s/%s", dirname, filename);
@


1.125
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d911 7
d920 9
a928 8
  bfd* abfd;
  unsigned int num_files;
  unsigned int num_dirs;
  char *comp_dir;
  char **dirs;
  struct fileinfo* files;
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
d992 1
d1020 1
a1020 1
     sequence within the list (such as a...j) that is not directly
d1025 3
a1027 3
  if (table->last_line
      && table->last_line->address == address
      && table->last_line->end_sequence == end_sequence)
d1031 1
a1031 1
      if (table->lcl_head == table->last_line)
d1033 2
a1034 2
      info->prev_line = table->last_line->prev_line;
      table->last_line = info;
d1036 1
a1036 2
  else if (!table->last_line
      || new_line_sorts_after (info, table->last_line))
d1038 15
a1052 3
      /* Normal case: add 'info' to the beginning of the list */
      info->prev_line = table->last_line;
      table->last_line = info;
d1068 3
a1070 3
      /* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	 heads for 'info'.  Reset 'lcl_head'.  */
      struct line_info* li2 = table->last_line; /* always non-NULL */
d1085 2
d1194 89
d1314 3
a1316 2
  table->files = NULL;
  table->last_line = NULL;
d1597 2
d1612 1
a1612 1
  /* Note: table->last_line should be a descendingly sorted list. */
d1614 1
d1616 14
a1629 5
  for (each_line = table->last_line;
       each_line;
       each_line = each_line->prev_line)
    if (addr >= each_line->address)
      break;
d1631 1
a1631 2
  if (each_line
      && !(each_line->end_sequence || each_line == table->last_line))
d1633 14
a1646 3
      *filename_ptr = each_line->filename;
      *linenumber_ptr = each_line->line;
      return TRUE;
d1653 1
a1653 1
/* Read in the .debug_ranges section for future reference */
@


1.124
log
@	PR binutils/10654
	* dwarf2.c (lookup_address_in_line_info_table): Remove workaround
	for invalid location lists generated by gcc-2.95 and Intel 6.0 C++.
	Remove "function" parm, adjust caller.
@
text
@d1471 7
a1477 10
	      {
		int i;

		/* Unknown standard opcode, ignore it.  */
		for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
		  {
		    (void) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		    line_ptr += bytes_read;
		  }
	      }
a2468 1
      struct adjusted_section *p;
@


1.123
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@a1497 1
				   struct funcinfo *function,
d1502 1
a1502 3
  struct line_info* next_line = table->last_line;
  struct line_info* each_line = NULL;
  *filename_ptr = NULL;
d1504 5
a1508 4
  if (!next_line)
    return FALSE;

  each_line = next_line->prev_line;
d1510 2
a1511 6
  /* Check for large addresses */
  if (addr > next_line->address)
    each_line = NULL; /* ensure we skip over the normal case */

  /* Normal case: search the list; save  */
  while (each_line && next_line)
d1513 2
a1514 65
      /* If we have an address match, save this info.  This allows us
	 to return as good as results as possible for strange debugging
	 info.  */
      bfd_boolean addr_match = FALSE;
      if (each_line->address <= addr && addr < next_line->address)
	{
	  addr_match = TRUE;

	  /* If this line appears to span functions, and addr is in the
	     later function, return the first line of that function instead
	     of the last line of the earlier one.  This check is for GCC
	     2.95, which emits the first line number for a function late.  */

	  if (function != NULL)
	    {
	      bfd_vma lowest_pc;
	      struct arange *arange;

	      /* Find the lowest address in the function's range list */
	      lowest_pc = function->arange.low;
	      for (arange = &function->arange;
		   arange;
		   arange = arange->next)
		{
		  if (function->arange.low < lowest_pc)
		    lowest_pc = function->arange.low;
		}
	      /* Check for spanning function and set outgoing line info */
	      if (addr >= lowest_pc
		  && each_line->address < lowest_pc
		  && next_line->address > lowest_pc)
		{
		  *filename_ptr = next_line->filename;
		  *linenumber_ptr = next_line->line;
		}
	      else
		{
		  *filename_ptr = each_line->filename;
		  *linenumber_ptr = each_line->line;
		}
	    }
	  else
	    {
	      *filename_ptr = each_line->filename;
	      *linenumber_ptr = each_line->line;
	    }
	}

      if (addr_match && !each_line->end_sequence)
	return TRUE; /* we have definitely found what we want */

      next_line = each_line;
      each_line = each_line->prev_line;
    }

  /* At this point each_line is NULL but next_line is not.  If we found
     a candidate end-of-sequence point in the loop above, we can return
     that (compatibility with a bug in the Intel compiler); otherwise,
     assuming that we found the containing function for this address in
     this compilation unit, return the first line we have a number for
     (compatibility with GCC 2.95).  */
  if (*filename_ptr == NULL && function != NULL)
    {
      *filename_ptr = next_line->filename;
      *linenumber_ptr = next_line->line;
d1518 1
d2233 1
a2233 1
					      function, filename_ptr,
@


1.122
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d103 1
a103 1
  bfd * bfd;
d319 2
a320 1
      ret = bfd_hash_allocate (table, sizeof (* ret));
d345 2
a346 1
  hash_table = bfd_alloc (abfd, sizeof (struct info_hash_table));
d379 2
a380 1
  node = bfd_hash_allocate (&hash_table->base, sizeof (*node));
d448 1
a448 1
	  *section_buffer = bfd_malloc (*section_size);
d649 1
a649 1
  abbrevs = bfd_zalloc (abfd, amt);
d659 1
a659 1
      cur_abbrev = bfd_zalloc (abfd, amt);
d683 1
a683 1
	      tmp = bfd_realloc (cur_abbrev->attrs, amt);
d772 1
a772 1
      blk = bfd_alloc (abfd, amt);
d781 1
a781 1
      blk = bfd_alloc (abfd, amt);
d810 1
a810 1
      blk = bfd_alloc (abfd, amt);
d819 1
a819 1
      blk = bfd_alloc (abfd, amt);
d984 1
a984 1
  struct line_info* info = bfd_alloc (table->abfd, amt);
d994 1
a994 1
      info->filename = bfd_alloc (table->abfd, strlen (filename) + 1);
d1115 1
a1115 1
	  name = bfd_malloc (len);
d1121 1
a1121 1
	  name = bfd_malloc (len);
d1165 1
a1165 1
  arange = bfd_zalloc (abfd, sizeof (*arange));
d1193 1
a1193 1
  table = bfd_alloc (abfd, amt);
d1245 1
a1245 1
  lh.standard_opcode_lengths = bfd_alloc (abfd, amt);
d1267 1
a1267 1
	  tmp = bfd_realloc (table->dirs, amt);
d1293 1
a1293 1
	  tmp = bfd_realloc (table->files, amt);
d1389 1
a1389 1
		      tmp = bfd_realloc (table->files, amt);
d1843 2
a1844 1
  nested_funcs = bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));
d1884 1
a1884 1
	  func = bfd_zalloc (abfd, amt);
d1905 1
a1905 1
	      var = bfd_zalloc (abfd, amt);
d2043 3
a2045 3
	      tmp = bfd_realloc (nested_funcs,
				 (nested_funcs_size
				  * sizeof (struct funcinfo *)));
d2089 1
a2089 1
  bfd *abfd = stash->bfd;
d2150 1
a2150 1
  unit = bfd_zalloc (abfd, amt);
d2657 1
a2657 1
      each_func = node->info;
d2705 1
a2705 1
      each = node->info;
d2896 1
a2896 1
  stash = *pinfo;
d2902 1
a2902 1
      stash = bfd_zalloc (abfd, amt);
d3006 1
a3006 1
	      stash->info_ptr_memory = bfd_malloc (total_size);
d3057 2
a3058 2
		  stash->info_ptr_memory = bfd_realloc (stash->info_ptr_memory,
							total_size + size);
d3071 1
a3071 1
      stash->bfd = debug_bfd;
d3145 1
a3145 1
      length = read_4_bytes (stash->bfd, stash->info_ptr);
d3151 1
a3151 1
	  length = read_8_bytes (stash->bfd, stash->info_ptr + 4);
d3160 1
a3160 1
	  length = read_4_bytes (stash->bfd, stash->info_ptr + 4);
d3223 1
a3223 1
	      stash->sec = find_debug_info (stash->bfd, stash->sec);
d3284 1
a3284 1
  stash = *pinfo;
d3311 1
a3311 1
  stash = elf_tdata (abfd)->dwarf2_find_line_info;
@


1.122.4.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d103 1
a103 1
  bfd *bfd_ptr;
d319 1
a319 2
      ret = (struct info_hash_entry *) bfd_hash_allocate (table,
                                                          sizeof (* ret));
d344 1
a344 2
  hash_table = (struct info_hash_table *)
      bfd_alloc (abfd, sizeof (struct info_hash_table));
d377 1
a377 2
  node = (struct info_list_node *) bfd_hash_allocate (&hash_table->base,
                                                      sizeof (*node));
d445 1
a445 1
	  *section_buffer = (bfd_byte *) bfd_malloc (*section_size);
d646 1
a646 1
  abbrevs = (struct abbrev_info **) bfd_zalloc (abfd, amt);
d656 1
a656 1
      cur_abbrev = (struct abbrev_info *) bfd_zalloc (abfd, amt);
d680 1
a680 1
	      tmp = (struct attr_abbrev *) bfd_realloc (cur_abbrev->attrs, amt);
d769 1
a769 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d778 1
a778 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d807 1
a807 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d816 1
a816 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d981 1
a981 1
  struct line_info* info = (struct line_info *) bfd_alloc (table->abfd, amt);
d991 1
a991 1
      info->filename = (char *) bfd_alloc (table->abfd, strlen (filename) + 1);
d1112 1
a1112 1
	  name = (char *) bfd_malloc (len);
d1118 1
a1118 1
	  name = (char *) bfd_malloc (len);
d1162 1
a1162 1
  arange = (struct arange *) bfd_zalloc (abfd, sizeof (*arange));
d1190 1
a1190 1
  table = (struct line_info_table *) bfd_alloc (abfd, amt);
d1242 1
a1242 1
  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
d1264 1
a1264 1
	  tmp = (char **) bfd_realloc (table->dirs, amt);
d1290 1
a1290 1
	  tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
d1386 1
a1386 1
		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
d1840 1
a1840 2
  nested_funcs = (struct funcinfo **)
      bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));
d1880 1
a1880 1
	  func = (struct funcinfo *) bfd_zalloc (abfd, amt);
d1901 1
a1901 1
	      var = (struct varinfo *) bfd_zalloc (abfd, amt);
d2039 3
a2041 3
	      tmp = (struct funcinfo **)
                 bfd_realloc (nested_funcs,
                              (nested_funcs_size * sizeof (struct funcinfo *)));
d2085 1
a2085 1
  bfd *abfd = stash->bfd_ptr;
d2146 1
a2146 1
  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);
d2653 1
a2653 1
      each_func = (struct funcinfo *) node->info;
d2701 1
a2701 1
      each = (struct varinfo *) node->info;
d2892 1
a2892 1
  stash = (struct dwarf2_debug *) *pinfo;
d2898 1
a2898 1
      stash = (struct dwarf2_debug *) bfd_zalloc (abfd, amt);
d3002 1
a3002 1
	      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);
d3053 2
a3054 2
		  stash->info_ptr_memory =  (bfd_byte *)
                      bfd_realloc (stash->info_ptr_memory, total_size + size);
d3067 1
a3067 1
      stash->bfd_ptr = debug_bfd;
d3141 1
a3141 1
      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr);
d3147 1
a3147 1
	  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4);
d3156 1
a3156 1
	  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4);
d3219 1
a3219 1
	      stash->sec = find_debug_info (stash->bfd_ptr, stash->sec);
d3280 1
a3280 1
  stash = (struct dwarf2_debug *) *pinfo;
d3307 1
a3307 1
  stash = (struct dwarf2_debug *) elf_tdata (abfd)->dwarf2_find_line_info;
@


1.122.4.2
log
@	PR binutils/10654
	* dwarf2.c (lookup_address_in_line_info_table): Remove workaround
	for invalid location lists generated by gcc-2.95 and Intel 6.0 C++.
	Remove "function" parm, adjust caller.
@
text
@d1498 1
d1503 33
a1535 1
  struct line_info *each_line;
d1537 36
a1572 5
  for (each_line = table->last_line;
       each_line;
       each_line = each_line->prev_line)
    if (addr >= each_line->address)
      break;
d1574 7
a1580 2
  if (each_line
      && !(each_line->end_sequence || each_line == table->last_line))
d1582 2
a1583 2
      *filename_ptr = each_line->filename;
      *linenumber_ptr = each_line->line;
a1586 1
  *filename_ptr = NULL;
d2301 1
a2301 1
					      filename_ptr,
@


1.122.4.3
log
@	PR 6832
	* dwarf2.c (struct comp_unit): Add sec_info_ptr.
	(find_abstract_instance_name): Use it.
	(parse_comp_unit): Set it.
@
text
@a218 3
  /* Pointer to the start of the debug section, for DW_FORM_ref_addr.  */
  bfd_byte *sec_info_ptr;

d1683 1
a1683 1
      info_ptr = unit->sec_info_ptr + die_ref;
a2090 1
  unit->sec_info_ptr = stash->sec_info_ptr;
@


1.121
log
@2009-07-03  Cary Coutant  <ccoutant@@google.com>

	* dwarf2.c (decode_line_info): Ignore DW_LNE_set_discriminator.
@
text
@d38 1
a38 1
#include "elf/dwarf2.h"
@


1.120
log
@2009-03-16  Andrew Stubbs  <ams@@codesourcery.com>

	* dwarf2.c (read_section): Always use rawsize, if available.
@
text
@d1408 4
@


1.119
log
@2009-03-12  Andrew Stubbs  <ams@@codesourcery.com>

	* dwarf2.c (read_section): Always check the offset, even when the
	section has been read before.
@
text
@d435 1
a437 1
	  *section_size = msec->size;
a444 1
	  *section_size = msec->rawsize ? msec->rawsize : msec->size;
@


1.118
log
@	* dwarf2.c (read_rangelist): Use read_address to read low_pc and
	high_pc in order to properly sign-extend VMAs.
@
text
@d420 1
a420 5
  if (*section_buffer)
    return TRUE;

  msec = bfd_get_section_by_name (abfd, section_name);
  if (! msec && compressed_section_name)
d422 7
a428 32
      msec = bfd_get_section_by_name (abfd, compressed_section_name);
      section_is_compressed = TRUE;
    }
  if (! msec)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Can't find %s section."), section_name);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (syms)
    {
      *section_size = msec->size;
      *section_buffer
	  = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
      if (! *section_buffer)
	return FALSE;
    }
  else
    {
      *section_size = msec->rawsize ? msec->rawsize : msec->size;
      *section_buffer = bfd_malloc (*section_size);
      if (! *section_buffer)
	return FALSE;
      if (! bfd_get_section_contents (abfd, msec, *section_buffer,
				      0, *section_size))
	return FALSE;
    }

  if (section_is_compressed)
    {
      if (! bfd_uncompress_section_contents (section_buffer, section_size))
d430 1
a430 1
	  (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
d434 29
@


1.117
log
@	PR 6832
	* dwarf2.c (find_line): Don't update stash->sec_info_ptr until
	after comp_unit_find_line call.
@
text
@d1806 5
a1810 14
      if (unit->addr_size == 4)
	{
	  low_pc = read_4_bytes (unit->abfd, ranges_ptr);
	  ranges_ptr += 4;
	  high_pc = read_4_bytes (unit->abfd, ranges_ptr);
	  ranges_ptr += 4;
	}
      else
	{
	  low_pc = read_8_bytes (unit->abfd, ranges_ptr);
	  ranges_ptr += 8;
	  high_pc = read_8_bytes (unit->abfd, ranges_ptr);
	  ranges_ptr += 8;
	}
@


1.116
log
@        * dwarf2.c (read_section): Fix formatting.
        (read_n_bytes): Remove unhelpful comment.
        (read_indirect_string): Pass symbol table to read_section in case
        the .debug_str section needs relocating.

        PR 7037
        * elf32-cr16.c (cr16_elf_howto_table): Zero the src_mask field of
        the reloc descriptions.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
a3191 7
	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
	      == stash->sec->size)
	    {
	      stash->sec = find_debug_info (stash->bfd, stash->sec);
	      stash->sec_info_ptr = stash->info_ptr;
	    }

d3221 8
@


1.115
log
@	PR 7012
	* dwarf2.c (find_line): Don't keep stale pointers into realloc'd
	memory.  Return on errors.  Fix memory leak.
	(_bfd_dwarf2_cleanup_debug_info): Free dwarf_str_buffer.
@
text
@d402 1
a402 1
   struct (indicated by SECTION_BUFFER and SECTION_SIZE).  If syms is
d404 2
a405 1
   section contents, otherwise use bfd_get_section_contents.  */
d408 7
a414 4
read_section (bfd *abfd,
	      const char* section_name, const char* compressed_section_name,
	      asymbol** syms, bfd_uint64_t offset,
	      bfd_byte **section_buffer, bfd_size_type *section_size)
d466 1
a466 1
   * that the client wants.  Validate it here to avoid trouble later.  */
d470 1
a470 1
			     offset, section_name, *section_size);
a518 3
  /* If the size of a host char is 8 bits, we can return a pointer
     to the buffer, otherwise we have to copy the data to a buffer
     allocated on the temporary obstack.  */
d529 1
d540 2
d543 3
a545 3
read_indirect_string (struct comp_unit* unit,
		      bfd_byte *buf,
		      unsigned int *bytes_read_ptr)
d555 1
d559 1
a559 1
		      0, offset,
d561 1
a561 1
    return 0;
a568 2
/* END VERBATIM */

@


1.114
log
@	PR ld/3191
	* dwarf2.c (struct adjusted_section): Renamed from struct
	loadable_section.
	(struct dwarf2_debug): Adjust for renaming.  Add version field.
	(read_attribute_value): Correctly handle DW_FORM_ref_addr for
	DWARF3.
	(find_abstract_instance_name): Pass a pointer to
	attribute instead of offset.  For DW_FORM_ref_addr, get the
	entry at the offset from the .debug_info section.
	(scan_unit_for_symbols): Update.
	(parse_comp_unit): Allow DWARF3.  Save the version.
	(unset_sections): Update for renaming.
	(place_sections): Likewise.  Set new VMAs for DWARF sections
	also.
@
text
@a2991 2
	  stash->info_ptr = stash->info_ptr_memory;
	  stash->info_ptr_end = stash->info_ptr + total_size;
d3009 1
a3009 3
	      stash->info_ptr = stash->info_ptr_memory;
	      stash->info_ptr_end = stash->info_ptr;

a3014 1
		  bfd_size_type start;
d3020 4
a3023 6
		  start = stash->info_ptr_end - stash->info_ptr;

		  if ((bfd_simple_get_relocated_section_contents
		       (debug_bfd, msec, stash->info_ptr + start, symbols))
		      == NULL)
		    continue;
d3025 1
a3025 1
		  stash->info_ptr_end = stash->info_ptr + start + size;
a3026 2

	      BFD_ASSERT (stash->info_ptr_end == stash->info_ptr + total_size);
d3031 2
a3032 3
	      stash->info_ptr_memory = bfd_malloc (1);
	      stash->info_ptr = stash->info_ptr_memory;
	      stash->info_ptr_end = stash->info_ptr;
d3038 7
a3044 3
		  bfd_byte* buffer
		      = (bfd_simple_get_relocated_section_contents
			 (debug_bfd, msec, NULL, symbols));
d3046 2
a3047 1
		    continue;
d3051 4
a3054 1
			continue;
d3056 3
a3058 4
		  stash->info_ptr = bfd_realloc (stash->info_ptr,
						 stash->info_ptr_end
						 - stash->info_ptr + size);
		  memcpy (stash->info_ptr_end, buffer, size);
d3060 1
a3060 1
		  stash->info_ptr_end += size;
d3065 2
d3366 10
a3375 4
  free (stash->dwarf_abbrev_buffer);
  free (stash->dwarf_line_buffer);
  free (stash->dwarf_ranges_buffer);
  free (stash->info_ptr_memory);
@


1.113
log
@Fix last commit.
@
text
@d78 1
a78 1
struct loadable_section
d146 2
a147 2
  /* Number of loadable sections.  */
  unsigned int loadable_section_count;
d149 2
a150 2
  /* Array of loadable sections.  */
  struct loadable_section *loadable_sections;
d240 3
d748 13
a761 2
      /* FIXME: DWARF3 draft says DW_FORM_ref_addr is offset_size.  */
    case DW_FORM_ref_addr:
d1722 2
a1723 1
find_abstract_instance_name (struct comp_unit *unit, bfd_uint64_t die_ref)
d1729 1
d1733 13
a1745 1
  info_ptr = unit->info_ptr_unit + die_ref;
d1771 1
a1771 1
		  name = find_abstract_instance_name (unit, attr.u.val);
d1933 1
a1933 1
		  func->name = find_abstract_instance_name (unit, attr.u.val);
d2101 1
a2101 1
  if (version != 2)
d2103 1
a2103 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%u', this reader only handles version 2 information."), version);
d2151 1
d2504 1
a2504 1
/* Unset vmas for loadable sections in STASH.  */
d2510 1
a2510 1
  struct loadable_section *p;
d2512 2
a2513 2
  i = stash->loadable_section_count;
  p = stash->loadable_sections;
d2518 2
a2519 2
/* Set unique vmas for loadable sections in ABFD and save vmas in
   STASH for unset_sections.  */
d2524 1
a2524 1
  struct loadable_section *p;
d2527 1
a2527 1
  if (stash->loadable_section_count != 0)
d2529 2
a2530 2
      i = stash->loadable_section_count;
      p = stash->loadable_sections;
d2537 1
a2537 1
      bfd_vma last_vma = 0;
d2539 1
a2539 1
      struct loadable_section *p;
d2545 1
d2547 14
a2560 1
	  if (sect->vma != 0 || (sect->flags & SEC_LOAD) == 0)
d2570 2
a2571 2
      amt = i * sizeof (struct loadable_section);
      p = (struct loadable_section *) bfd_zalloc (abfd, amt);
d2575 2
a2576 2
      stash->loadable_sections = p;
      stash->loadable_section_count = i;
d2581 14
d2596 1
a2596 1
	  if (sect->vma != 0 || (sect->flags & SEC_LOAD) == 0)
d2604 7
a2610 1
	  if (last_vma != 0)
d2618 1
d2620 3
a2623 1
	  last_vma += sect->vma + sz;
@


1.113.2.1
log
@	PR ld/3191
	* dwarf2.c (struct adjusted_section): Renamed from struct
	loadable_section.
	(struct dwarf2_debug): Adjust for renaming.  Add version field.
	(read_attribute_value): Correctly handle DW_FORM_ref_addr for
	DWARF3.
	(find_abstract_instance_name): Pass a pointer to
	attribute instead of offset.  For DW_FORM_ref_addr, get the
	entry at the offset from the .debug_info section.
	(scan_unit_for_symbols): Update.
	(parse_comp_unit): Allow DWARF3.  Save the version.
	(unset_sections): Update for renaming.
	(place_sections): Likewise.  Set new VMAs for DWARF sections
	also.
@
text
@d78 1
a78 1
struct adjusted_section
d146 2
a147 2
  /* Number of sections whose VMA we must adjust.  */
  unsigned int adjusted_section_count;
d149 2
a150 2
  /* Array of sections with adjusted VMA.  */
  struct adjusted_section *adjusted_sections;
a239 3
  /* DWARF format version for this unit - from unit header.  */
  int version;

d745 2
a747 13
      /* DW_FORM_ref_addr is an address in DWARF2, and an offset in
	 DWARF3.  */
      if (unit->version == 3)
	{
	  if (unit->offset_size == 4)
	    attr->u.val = read_4_bytes (unit->abfd, info_ptr);
	  else
	    attr->u.val = read_8_bytes (unit->abfd, info_ptr);
	  info_ptr += unit->offset_size;
	  break;
	}
      /* FALLTHROUGH */
    case DW_FORM_addr:
d1708 1
a1708 2
find_abstract_instance_name (struct comp_unit *unit,
			     struct attribute *attr_ptr)
a1713 1
  bfd_uint64_t die_ref = attr_ptr->u.val;
d1717 1
a1717 13
  /* DW_FORM_ref_addr can reference an entry in a different CU. It
     is an offset from the .debug_info section, not the current CU.  */
  if (attr_ptr->form == DW_FORM_ref_addr)
    {
      /* We only support DW_FORM_ref_addr within the same file, so
	 any relocations should be resolved already.  */
      if (!die_ref)
	abort ();

      info_ptr = unit->stash->sec_info_ptr + die_ref;
    }
  else 
    info_ptr = unit->info_ptr_unit + die_ref;
d1743 1
a1743 1
		  name = find_abstract_instance_name (unit, &attr);
d1905 1
a1905 1
		  func->name = find_abstract_instance_name (unit, &attr);
d2073 1
a2073 1
  if (version != 2 && version != 3)
d2075 1
a2075 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%u', this reader only handles version 2 and 3 information."), version);
a2122 1
  unit->version = version;
d2475 1
a2475 1
/* Unset vmas for adjusted sections in STASH.  */
d2481 1
a2481 1
  struct adjusted_section *p;
d2483 2
a2484 2
  i = stash->adjusted_section_count;
  p = stash->adjusted_sections;
d2489 2
a2490 2
/* Set unique VMAs for loadable and DWARF sections in ABFD and save
   VMAs in STASH for unset_sections.  */
d2495 1
a2495 1
  struct adjusted_section *p;
d2498 1
a2498 1
  if (stash->adjusted_section_count != 0)
d2500 2
a2501 2
      i = stash->adjusted_section_count;
      p = stash->adjusted_sections;
d2508 1
a2508 1
      bfd_vma last_vma = 0, last_dwarf = 0;
d2510 1
a2510 1
      struct adjusted_section *p;
a2515 1
	  int is_debug_info;
d2517 1
a2517 14
	  if (sect->vma != 0)
	    continue;

	  /* We need to adjust the VMAs of any .debug_info sections.
	     Skip compressed ones, since no relocations could target
	     them - they should not appear in object files anyway.  */
	  if (strcmp (sect->name, DWARF2_DEBUG_INFO) == 0)
	    is_debug_info = 1;
	  else if (CONST_STRNEQ (sect->name, GNU_LINKONCE_INFO))
	    is_debug_info = 1;
	  else
	    is_debug_info = 0;

	  if (!is_debug_info && (sect->flags & SEC_LOAD) == 0)
d2527 2
a2528 2
      amt = i * sizeof (struct adjusted_section);
      p = (struct adjusted_section *) bfd_zalloc (abfd, amt);
d2532 2
a2533 2
      stash->adjusted_sections = p;
      stash->adjusted_section_count = i;
a2537 14
	  int is_debug_info;

	  if (sect->vma != 0)
	    continue;

	  /* We need to adjust the VMAs of any .debug_info sections.
	     Skip compressed ones, since no relocations could target
	     them - they should not appear in object files anyway.  */
	  if (strcmp (sect->name, DWARF2_DEBUG_INFO) == 0)
	    is_debug_info = 1;
	  else if (CONST_STRNEQ (sect->name, GNU_LINKONCE_INFO))
	    is_debug_info = 1;
	  else
	    is_debug_info = 0;
d2539 1
a2539 1
	  if (!is_debug_info && (sect->flags & SEC_LOAD) == 0)
d2547 1
a2547 7
	  if (is_debug_info)
	    {
	      BFD_ASSERT (sect->alignment_power == 0);
	      sect->vma = last_dwarf;
	      last_dwarf += sz;
	    }
	  else if (last_vma != 0)
a2554 1
	      last_vma += sect->vma + sz;
a2555 3
	  else
	    last_vma += sect->vma + sz;

d2557 1
@


1.113.2.2
log
@backport 2008-11-11  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d2992 2
d3011 3
a3013 1
	      total_size = 0;
d3019 1
d3025 6
a3030 4
		  if (!(bfd_simple_get_relocated_section_contents
			(debug_bfd, msec, stash->info_ptr_memory + total_size,
			 symbols)))
		    goto done;
d3032 1
a3032 1
		  total_size += size;
d3034 2
d3040 3
a3042 2
	      stash->info_ptr_memory = NULL;
	      total_size = 0;
d3048 4
a3051 3
		  bfd_byte* buffer;

		  if (size == 0)
a3052 6

		  buffer = (bfd_simple_get_relocated_section_contents
			    (debug_bfd, msec, NULL, symbols));
		  if (! buffer)
		    goto done;

d3056 1
a3056 4
			{
			  free (buffer);
			  goto done;
			}
d3058 4
a3061 3
		  stash->info_ptr_memory = bfd_realloc (stash->info_ptr_memory,
							total_size + size);
		  memcpy (stash->info_ptr_memory + total_size, buffer, size);
d3063 1
a3063 1
		  total_size += size;
a3067 2
      stash->info_ptr = stash->info_ptr_memory;
      stash->info_ptr_end = stash->info_ptr + total_size;
d3367 4
a3370 10
  if (stash->dwarf_abbrev_buffer)
    free (stash->dwarf_abbrev_buffer);
  if (stash->dwarf_line_buffer)
    free (stash->dwarf_line_buffer);
  if (stash->dwarf_str_buffer)
    free (stash->dwarf_str_buffer);
  if (stash->dwarf_ranges_buffer)
    free (stash->dwarf_ranges_buffer);
  if (stash->info_ptr_memory)
    free (stash->info_ptr_memory);
@


1.113.2.3
log
@backport 2009-01-22  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d3189 7
a3224 8

	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
	      == stash->sec->size)
	    {
	      stash->sec = find_debug_info (stash->bfd, stash->sec);
	      stash->sec_info_ptr = stash->info_ptr;
	    }

@


1.112
log
@	* dwarf2.c: Change leading whitespace to tabs.
@
text
@d444 1
a444 1
	                              0, *section_size))
d551 2
a552 2
	              0, offset,
	              &stash->dwarf_str_buffer, &stash->dwarf_str_size))
d636 2
a637 2
	              stash->syms, offset,
	              &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))
d1169 2
a1170 2
	              stash->syms, unit->line_offset,
	              &stash->dwarf_line_buffer, &stash->dwarf_line_size))
d1574 2
a1575 2
	               stash->syms, 0,
	               &stash->dwarf_ranges_buffer, &stash->dwarf_ranges_size);
d2923 2
a2924 2
	                      symbols, 0,
	                      &stash->info_ptr_memory, &total_size))
d2936 1
a2936 1
	        all_uncompressed = 0;
d2963 1
a2963 1
	              == NULL)
d2981 18
a2998 18
	          bfd_size_type size = msec->size;
	          bfd_byte* buffer
	              = (bfd_simple_get_relocated_section_contents
	                 (debug_bfd, msec, NULL, symbols));
	          if (! buffer)
	            continue;
	          if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
	            {
	              if (! bfd_uncompress_section_contents (&buffer, &size))
	                continue;
	            }
	          stash->info_ptr = bfd_realloc (stash->info_ptr,
	                                         stash->info_ptr_end
	                                         - stash->info_ptr + size);
	          memcpy (stash->info_ptr_end, buffer, size);
	          free (buffer);
	          stash->info_ptr_end += size;
	        }
@


1.111
log
@2008-07-13  Craig Silverstein  <csilvers@@google.com>

	* dwarf2.c (struct dwarf2_debug): New variable info_ptr_memory.
	(find_line): Use info_ptr_memory instead of sec_info_ptr.
	(_bfd_dwarf2_cleanup_debug_info): Likewise.
@
text
@d323 1
a323 1
         bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
d405 3
a407 3
              const char* section_name, const char* compressed_section_name,
              asymbol** syms, bfd_uint64_t offset,
              bfd_byte **section_buffer, bfd_size_type *section_size)
d433 1
a433 1
          = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
d435 1
a435 1
        return FALSE;
d442 1
a442 1
        return FALSE;
d444 2
a445 2
                                      0, *section_size))
        return FALSE;
d451 5
a455 5
        {
          (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
          bfd_set_error (bfd_error_bad_value);
          return FALSE;
        }
d551 2
a552 2
                      0, offset,
                      &stash->dwarf_str_buffer, &stash->dwarf_str_size))
d636 2
a637 2
                      stash->syms, offset,
                      &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))
d1169 2
a1170 2
                      stash->syms, unit->line_offset,
                      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
d1574 2
a1575 2
                       stash->syms, 0,
                       &stash->dwarf_ranges_buffer, &stash->dwarf_ranges_size);
d2908 9
a2916 9
         days.  First handle the easy case when there's only one.  If
         there's more than one, try case two: none of the sections is
         compressed.  In that case, read them all in and produce one
         large stash.  We do this in two passes - in the first pass we
         just accumulate the section sizes, and in the second pass we
         read in the section's contents.  (The allows us to avoid
         reallocing the data as we add sections to the stash.)  If
         some or all sections are compressed, then do things the slow
         way, with a bunch of reallocs.  */
d2919 10
a2928 10
        {
          /* Case 1: only one info section.  */
          total_size = msec->size;
          if (! read_section (debug_bfd, ".debug_info", ".zdebug_info",
                              symbols, 0,
                              &stash->info_ptr_memory, &total_size))
            goto done;
          stash->info_ptr = stash->info_ptr_memory;
          stash->info_ptr_end = stash->info_ptr + total_size;
        }
d2930 71
a3000 71
        {
          int all_uncompressed = 1;
          for (total_size = 0; msec; msec = find_debug_info (debug_bfd, msec))
            {
              total_size += msec->size;
              if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
                all_uncompressed = 0;
            }
          if (all_uncompressed)
            {
              /* Case 2: multiple sections, but none is compressed.  */
              stash->info_ptr_memory = bfd_malloc (total_size);
              if (stash->info_ptr_memory == NULL)
        	goto done;

              stash->info_ptr = stash->info_ptr_memory;
              stash->info_ptr_end = stash->info_ptr;

              for (msec = find_debug_info (debug_bfd, NULL);
        	   msec;
        	   msec = find_debug_info (debug_bfd, msec))
        	{
        	  bfd_size_type size;
        	  bfd_size_type start;

        	  size = msec->size;
        	  if (size == 0)
        	    continue;

        	  start = stash->info_ptr_end - stash->info_ptr;

        	  if ((bfd_simple_get_relocated_section_contents
        	       (debug_bfd, msec, stash->info_ptr + start, symbols))
                      == NULL)
        	    continue;

        	  stash->info_ptr_end = stash->info_ptr + start + size;
        	}

              BFD_ASSERT (stash->info_ptr_end == stash->info_ptr + total_size);
            }
          else
            {
              /* Case 3: multiple sections, some or all compressed.  */
              stash->info_ptr_memory = bfd_malloc (1);
              stash->info_ptr = stash->info_ptr_memory;
              stash->info_ptr_end = stash->info_ptr;
              for (msec = find_debug_info (debug_bfd, NULL);
        	   msec;
        	   msec = find_debug_info (debug_bfd, msec))
        	{
                  bfd_size_type size = msec->size;
                  bfd_byte* buffer
                      = (bfd_simple_get_relocated_section_contents
                         (debug_bfd, msec, NULL, symbols));
                  if (! buffer)
                    continue;
                  if (strcmp (msec->name, DWARF2_COMPRESSED_DEBUG_INFO) == 0)
                    {
                      if (! bfd_uncompress_section_contents (&buffer, &size))
                        continue;
                    }
                  stash->info_ptr = bfd_realloc (stash->info_ptr,
                                                 stash->info_ptr_end
                                                 - stash->info_ptr + size);
                  memcpy (stash->info_ptr_end, buffer, size);
                  free (buffer);
                  stash->info_ptr_end += size;
                }
            }
        }
d3109 1
a3109 1
          stash->info_ptr += 4;
@


1.110
log
@(read_section): Take pointer to bfd_size_type instead
of unsigned long as last parameter.
(struct dwarf2_debug): Define dwarf_abbrev_size, dwarf_line_size,
dwarf_str_size and dwarf_ranges_size as bfd_size_type instead of
unsigned long.
@
text
@d107 6
d2924 1
a2924 1
                              &stash->info_ptr, &total_size))
d2926 1
d2941 2
a2942 2
              stash->info_ptr = bfd_malloc (total_size);
              if (stash->info_ptr == NULL)
d2945 1
d2974 2
a2975 1
              stash->info_ptr = bfd_malloc (1);
d3304 1
a3304 1
  free (stash->sec_info_ptr);
@


1.109
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d114 1
a114 1
  unsigned long dwarf_abbrev_size;
d120 1
a120 1
  unsigned long dwarf_line_size;
d126 1
a126 1
  unsigned long dwarf_str_size;
d132 1
a132 1
  unsigned long dwarf_ranges_size;
d401 1
a401 1
              bfd_byte **section_buffer, unsigned long *section_size)
@


1.108
log
@        PR 868
        * dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Free memory allocated
        for filenames in function tables and variable tables.
@
text
@d392 73
d544 4
a547 33
  if (! stash->dwarf_str_buffer)
    {
      asection *msec;
      bfd *abfd = unit->abfd;
      bfd_size_type sz;

      msec = bfd_get_section_by_name (abfd, ".debug_str");
      if (! msec)
	{
	  (*_bfd_error_handler)
	    (_("Dwarf Error: Can't find .debug_str section."));
	  bfd_set_error (bfd_error_bad_value);
	  return NULL;
	}

      sz = msec->rawsize ? msec->rawsize : msec->size;
      stash->dwarf_str_size = sz;
      stash->dwarf_str_buffer = bfd_alloc (abfd, sz);
      if (! stash->dwarf_str_buffer)
	return NULL;

      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_str_buffer,
				      0, sz))
	return NULL;
    }

  if (offset >= stash->dwarf_str_size)
    {
      (*_bfd_error_handler) (_("Dwarf Error: DW_FORM_strp offset (%lu) greater than or equal to .debug_str size (%lu)."),
			     (unsigned long) offset, stash->dwarf_str_size);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
d629 4
a632 27
  if (! stash->dwarf_abbrev_buffer)
    {
      asection *msec;

      msec = bfd_get_section_by_name (abfd, ".debug_abbrev");
      if (! msec)
	{
	  (*_bfd_error_handler) (_("Dwarf Error: Can't find .debug_abbrev section."));
	  bfd_set_error (bfd_error_bad_value);
	  return 0;
	}

      stash->dwarf_abbrev_size = msec->size;
      stash->dwarf_abbrev_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
      if (! stash->dwarf_abbrev_buffer)
	  return 0;
    }

  if (offset >= stash->dwarf_abbrev_size)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%lu) greater than or equal to .debug_abbrev size (%lu)."),
			     (unsigned long) offset, stash->dwarf_abbrev_size);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }
d1162 4
a1165 29
  if (! stash->dwarf_line_buffer)
    {
      asection *msec;

      msec = bfd_get_section_by_name (abfd, ".debug_line");
      if (! msec)
	{
	  (*_bfd_error_handler) (_("Dwarf Error: Can't find .debug_line section."));
	  bfd_set_error (bfd_error_bad_value);
	  return 0;
	}

      stash->dwarf_line_size = msec->size;
      stash->dwarf_line_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
      if (! stash->dwarf_line_buffer)
	return 0;
    }

  /* It is possible to get a bad value for the line_offset.  Validate
     it here so that we won't get a segfault below.  */
  if (unit->line_offset >= stash->dwarf_line_size)
    {
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%lu) greater than or equal to .debug_line size (%lu)."),
			     unit->line_offset, stash->dwarf_line_size);
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }
d1567 3
a1569 21
  if (! stash->dwarf_ranges_buffer)
    {
      bfd *abfd = unit->abfd;
      asection *msec;

      msec = bfd_get_section_by_name (abfd, ".debug_ranges");
      if (! msec)
	{
	  (*_bfd_error_handler) (_("Dwarf Error: Can't find .debug_ranges section."));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      stash->dwarf_ranges_size = msec->size;
      stash->dwarf_ranges_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
      if (! stash->dwarf_ranges_buffer)
	return FALSE;
    }
  return TRUE;
d2442 1
d2457 3
d2901 91
a2991 35
      /* There can be more than one DWARF2 info section in a BFD these days.
	 Read them all in and produce one large stash.  We do this in two
	 passes - in the first pass we just accumulate the section sizes.
	 In the second pass we read in the section's contents.  The allows
	 us to avoid reallocing the data as we add sections to the stash.  */
      for (total_size = 0; msec; msec = find_debug_info (debug_bfd, msec))
	total_size += msec->size;

      stash->info_ptr = bfd_alloc (debug_bfd, total_size);
      if (stash->info_ptr == NULL)
	goto done;

      stash->info_ptr_end = stash->info_ptr;

      for (msec = find_debug_info (debug_bfd, NULL);
	   msec;
	   msec = find_debug_info (debug_bfd, msec))
	{
	  bfd_size_type size;
	  bfd_size_type start;

	  size = msec->size;
	  if (size == 0)
	    continue;

	  start = stash->info_ptr_end - stash->info_ptr;

	  if ((bfd_simple_get_relocated_section_contents
	       (debug_bfd, msec, stash->info_ptr + start, symbols)) == NULL)
	    continue;

	  stash->info_ptr_end = stash->info_ptr + start + size;
	}

      BFD_ASSERT (stash->info_ptr_end == stash->info_ptr + total_size);
d3295 1
@


1.107
log
@        PR 868
        *dwarf2.c: Revert previous patch.  All of the allocate memory is
        on an obstack which will be freed at some other time.
@
text
@d3205 2
d3225 27
@


1.106
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d659 2
a660 6
			  struct abbrev_info * a = abbrev;

			  abbrev = a->next;
			  if (a->attrs)
			    free (abbrev->attrs);
			  free (a);
a662 2

		  free (abbrevs);
d1126 1
a1126 3
/* Decode the line number information for UNIT.
   Note: this function allocates memory.  It is the caller's
   responsibility to free it.  */
d1128 1
a1128 1
static struct line_info_table *
a1249 1
	      free (table);
a1276 1
	      free (table);
a1372 1
			  free (table);
a1395 1
		  free (table);
d1817 1
a1817 4
   to the function table and variables to the variable table.
   Returns TRUE upon success, FALSE otherwise.  Allocates memory
   blocks to the unit->function_table and unit->variable_table fields.
   It is the caller's responsibility to free this memory.  */
d1834 1
a1834 1
  nested_funcs[nesting_level] = NULL;
a1870 1

a1891 1

d3204 2
a3205 2
      struct funcinfo * function_table = each->function_table;
      struct varinfo *  variable_table = each->variable_table;
d3207 1
a3207 1
      if (each->abbrevs != NULL)
d3209 1
a3209 1
	  size_t i;
d3211 1
a3211 1
	  for (i = 0; i < ABBREV_HASH_SIZE; i++)
d3213 2
a3214 11
	      struct abbrev_info *abbrev = each->abbrevs[i];

	      while (abbrev)
		{
		  struct abbrev_info * a = abbrev;

		  abbrev = a->next;
		  if (a->attrs)
		    free (a->attrs);
		  free (a);
		}
a3215 3

	  free (each->abbrevs);
	  each->abbrevs = NULL;
d3220 2
a3221 9
	  /* FIXME: We should free the line_info structures as well.  */
	  if (each->line_table->dirs)
	    free (each->line_table->dirs);

	  if (each->line_table->files)
	    free (each->line_table->files);

	  free (each->line_table);
	  each->line_table = NULL;
a3222 31

      while (function_table)
	{
	  struct funcinfo * f = function_table;

	  function_table = f->prev_func;

	  if (f->file)
	    free (f->file);

	  if (f->caller_file)
	    free (f->caller_file);

	  free (f);
	}

      each->function_table = NULL;

      while (variable_table)
	{
	  struct varinfo *  v = variable_table;

	  variable_table = variable_table->prev_var;

	  if (v->file)
	    free (v->file);

	  free (v);
	}

      each->variable_table = NULL;
@


1.105
log
@PR 868
   * dwarf2.c (read_abbrevs): Free the abbreviation table if we run
   out of memory.
   (decode_line_info): Free the line_info_table before returning a
   failure result.
   (_bfd_dwarf2_cleanup_debug_info): Free the abbreviation table.
   Free the line table.  Free the function table.  Free the variable
   table.
@
text
@d1258 1
@


1.104
log
@	* dwarf2.c (find_line): Don't trust debug information after an
	unparseable compilation unit.
@
text
@d659 6
a664 2
			  free (abbrev->attrs);
			  abbrev = abbrev->next;
d667 2
d1132 3
a1134 1
/* Decode the line number information for UNIT.  */
d1136 1
a1136 1
static struct line_info_table*
d1285 1
d1382 1
d1406 1
d1828 4
a1831 1
   to the function table and variables to the variable table.  */
d1848 1
a1848 1
  nested_funcs[nesting_level] = 0;
d1885 1
d1907 1
d3220 2
a3221 2
      struct abbrev_info **abbrevs = each->abbrevs;
      size_t i;
d3223 1
a3223 1
      for (i = 0; i < ABBREV_HASH_SIZE; i++)
d3225 1
a3225 1
	  struct abbrev_info *abbrev = abbrevs[i];
d3227 1
a3227 1
	  while (abbrev)
d3229 11
a3239 2
	      free (abbrev->attrs);
	      abbrev = abbrev->next;
d3241 3
d3248 9
a3256 2
	  free (each->line_table->dirs);
	  free (each->line_table->files);
d3258 31
@


1.103
log
@	PR 5755
	* arange-set.c: Delete.
	* arange-set.h: Delete.
	* dwarf2.c: Revert 2007-09-21 changes.
	* Makefile.am: Likewise.
	* Makefile.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d3071 4
d3084 31
a3114 34
	  if (each)
	    {
	      if (stash->all_comp_units)
		stash->all_comp_units->prev_unit = each;
	      else
		stash->last_comp_unit = each;

	      each->next_unit = stash->all_comp_units;
	      stash->all_comp_units = each;

	      /* DW_AT_low_pc and DW_AT_high_pc are optional for
		 compilation units.  If we don't have them (i.e.,
		 unit->high == 0), we need to consult the line info
		 table to see if a compilation unit contains the given
		 address.  */
	      if (do_line)
		found = (((symbol->flags & BSF_FUNCTION) == 0
			  || each->arange.high == 0
			  || comp_unit_contains_address (each, addr))
			 && comp_unit_find_line (each, symbol, addr,
						 filename_ptr,
						 linenumber_ptr,
						 stash));
	      else
		found = ((each->arange.high == 0
			  || comp_unit_contains_address (each, addr))
			 && comp_unit_find_nearest_line (each, addr,
							 filename_ptr,
							 functionname_ptr,
							 linenumber_ptr,
							 stash));
	      if (found)
		goto done;
	    }
@


1.102
log
@* Makefile.am (BFD32_LIBS): Add arange-set.lo.
  (BFD32_LIBS_CFILES): Add arange-set.c.
  (SOURCE_HFILES): Add arange-set.h
  (dwarf2.lo): Add dependency upon arange-set.h.
  (arange-set.lo): New target.
* Makefile.in: Regenerate.
* arange-set.c: New file.
* arange-set.h: New file.
* dwarf2.c: Include arange-set.h.
  (struct dwarf2_debug) Add new fields comp_unit_count and comp_unit_arange_set.
  (struct comp_unit) Replace field arange with a new field arange_set.
  (dwarf2_arange_set_allocate, dwarf2_arange_set_deallocate,
  (dwarf2_combine_arange_value, dwarf2_arange_set_new,
  (dwarf2_arange_set_with_value_new, dwarf2_comp_unit_arange_add): New
  functions to utilize arange set in dwarf2.c.
  (arange_add): Formatting change for a line longer than 80 characters.
  (decode_line_info): Replace call target arange_add with
  (dwarf2_comp_unit_arange_add.
  (read_rangelist_insert_arange_list,
  (read_rangelist_comp_unit_arange_add): New functions used as callbacks
  for read_rangelist.
  (read_rangelist): Change interface to accept a callback and data to
  allow caller to select the action peformed on a new range list read.
  (scan_unit_for_symbols): Use new interface of read_rangelist.
  (parse_comp_unit): Create an arange set for each new comp unit.  Use new
  interface of read_rangelist.  Replace call to arange_add with that to
  dwarf2_comp_unit_arange_add.
  (comp_unit_contains_address): Replace sequential search with a call to
  arange_set_lookup_address, which can handles large set efficiently.
  (stash_copy_local_aranges, stash_maybe_enable_arange_set,
  (stash_find_nearest_line_fast): New functions maintaining and using a
  valued global arange set for all compilation units to speed up
  bfd_dwarf2_find_nearest_line.
  (find_line): Use global arange set.  Replace sequential search over all
  compilation units with a call to stash_find_nearest_line_fast.  Add
  book keeping to count number of compilation units.  Replace empty
  arange list test with a call to arange_set_empty_p.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
a38 1
#include "arange-set.h"
a91 3
  /* Number of comp units. */
  int comp_unit_count;

a165 16

  /* Arange-set for fast lookup.  The aranges in this set have pointers
     to compilation units containing them.  In the unlikely case that there
     are multiple compilation units associated with an arange, the arange-set
     is a NULL pointer and we need to fall back to sequential search.  */
  arange_set comp_unit_arange_set;

  /* Status of global arange set.  */
  int arange_set_status;
#define STASH_ARANGE_SET_OFF		0
#define STASH_ARANGE_SET_ON		1
#define STASH_ARANGE_SET_DISABLED	2

  /* Build a whole binary arange-set for compilation unit look-up
     if there are at least this many compilation units.  */
#define STASH_ARANGE_SET_TRIGGER	500
a167 4
/* Simple singly linked list for aranges.  We now use a more scalable
   arange-set for aranges in compilation units.  For functions, we still
   use this since it is more efficient for simple cases.  */

a170 2
  /* The lowest and highest addresses contained a compilation
     unit as specified in the compilation unit's header.  */
d190 3
a192 2
  /* The set of aranges in a compilation unit.  */
  arange_set arange_set;
d873 2
a874 2
  struct line_info* last_line;  /* Largest VMA.  */
  struct line_info* lcl_head;   /* Local head; used in 'add_line_info'.  */
d884 6
a889 6
  struct funcinfo *prev_func;		/* Pointer to previous function in list of all functions.  */
  struct funcinfo *caller_func;		/* Pointer to function one scope higher.  */
  char *caller_file;			/* Source location file name where caller_func inlines this func.  */
  int caller_line;			/* Source location line number where caller_func inlines this func.  */
  char *file;				/* Source location file name.  */
  int line;				/* Source location line number.  */
d893 1
a893 1
  asection *sec;			/* Where the symbol is defined.  */
d898 1
a898 1
  /* Pointer to previous variable in list of all variables.  */
d900 1
a900 1
  /* Source location file name.  */
d902 1
a902 1
  /* Source location line number.  */
d907 1
a907 1
  /* Where the symbol is defined.  */
d909 1
a909 1
  /* Is this a stack variable?  */
a912 86
/* Arange-sets:
 
   To handle extremely large binaries, we want to use a more efficient data
   structure than a singly-linked list to represent aranges.  So instead we
   use an arange-set, which supports efficient insertions and queries.  We
   use a simple arange-set with no values attached to represent the aranges
   in a compilation unit and we also use a global arange-set to store all
   the aranges in all the compilation units.  The global arange-set stores
   values which are pointers to the compilation units.

   Normally aranges in the global set do not overlap, but this can happen.
   To simplify things and to prevent excessive memory usage, an arange in
   the global set can only point to at most one compilation unit.  In case
   of an overlap, the pointer is set to NULL, meaning that there are more
   than one compilation units containing that arange.  Code that looks up
   the global set should fall back to searching all compilation units if
   that happens.  */
 
/* Allocate memory for an arange set.  */ 

static void *
dwarf2_arange_set_allocate (int size, void *data)
{
  return bfd_alloc ((bfd *) data, size);
}

/* Deallocate memory of an arange set.  */ 

static void
dwarf2_arange_set_deallocate (void *object ATTRIBUTE_UNUSED,
			      void *data ATTRIBUTE_UNUSED)
{
  /* Do nothing. Let BFD clean up when it's done.  */
}

/* Combine two comp unit pointers.  If they are the same,
   return either one, otherwise return NULL.  */

static arange_value_type
dwarf2_combine_arange_value (arange_value_type value1,
			     arange_value_type value2,
			     void *data ATTRIBUTE_UNUSED)
{
  return ((value1 == value2) ? value1 : 0); 
}

/* Create a simple arange set that does not store values.  */

static arange_set
dwarf2_arange_set_new (bfd *abfd)
{
  return arange_set_new (dwarf2_arange_set_allocate,
			 dwarf2_arange_set_deallocate,
			 FALSE, NULL, NULL, NULL, NULL, (void *) abfd);
}

/* Create an arange set that stores pointers to compilation units.  */

static arange_set
dwarf2_arange_set_with_value_new (bfd *abfd)
{
  return arange_set_new (dwarf2_arange_set_allocate,
			 dwarf2_arange_set_deallocate,
			 TRUE, NULL, NULL, dwarf2_combine_arange_value,
			 NULL, (void *) abfd);
}

/* Add an arange to a compilation unit.  Add the arange to both the
   unit's valueless arange set and the global arange set.  */

static void
dwarf2_comp_unit_arange_add (struct comp_unit *unit,
			     bfd_vma low, 
			     bfd_vma high)
{
  /* Add arange to unit's local arange set.  */
  arange_set_insert (unit->arange_set, low, high - 1, 0);

  if (unit->stash->arange_set_status == STASH_ARANGE_SET_ON)
    {
      BFD_ASSERT (unit->stash->comp_unit_arange_set);
      arange_set_insert (unit->stash->comp_unit_arange_set, low, high - 1,
			 (arange_value_type) unit);
    }
}

d938 1
a938 1
  struct line_info * info = bfd_alloc (table->abfd, amt);
d982 1
a982 1
	   || new_line_sorts_after (info, table->last_line))
d984 1
a984 1
      /* Normal case: add 'info' to the beginning of the list.  */
d1004 1
a1004 1
      struct line_info* li2 = table->last_line; /* Always non-NULL.  */
d1013 1
a1013 1
	  li2 = li1; /* Always non-NULL.  */
d1087 1
a1087 2
arange_add (bfd *abfd, struct arange *first_arange, bfd_vma low_pc,
	    bfd_vma high_pc)
d1091 1
a1091 1
  /* If the first arange is empty, use it.  */
d1118 1
a1118 1
     Order isn't significant, so just insert after the first arange.  */
d1353 1
a1353 1
		  dwarf2_comp_unit_arange_add (unit, low_pc, high_pc);
d1770 1
a1770 17
  return name;
}

/* Type of callback function used in read_rangelist below.  */

typedef void (*read_rangelist_callback_t)(struct comp_unit*, bfd_vma,
					  bfd_vma, void*);

/* Call back to add an arange to the old-style arange list.  */

static void
read_rangelist_insert_arange_list (struct comp_unit *unit,
				   bfd_vma low,
				   bfd_vma high,
				   void *data)
{
  arange_add (unit->abfd, (struct arange*) data, low, high);
a1772 14
/* Callback to add an arange in the arange set of a compilation unit.  */

static void
read_rangelist_comp_unit_arange_add (struct comp_unit *unit,
				     bfd_vma low,
				     bfd_vma high,
				     void *data ATTRIBUTE_UNUSED)
{
  dwarf2_comp_unit_arange_add (unit, low, high);
}

/* Read ARANGE list of a compilation unit.  For each read arange,
   call the supplied callback function for further processing.  */

d1774 1
a1774 4
read_rangelist (struct comp_unit *unit,
	        bfd_uint64_t offset,
		read_rangelist_callback_t callback,
		void *callback_data)
d1810 1
a1810 3
	/* Call callback to process new arange.  */
	(callback) (unit, base_address + low_pc, base_address + high_pc,
		    callback_data);
d1943 1
a1943 3
		  read_rangelist (unit, attr.u.val,
				  read_rangelist_insert_arange_list,
				  & func->arange);
a2144 1
  unit->arange_set = dwarf2_arange_set_new (abfd);
d2176 1
a2176 2
	  read_rangelist (unit, attr.u.val,
			  read_rangelist_comp_unit_arange_add, NULL);
a2181 1

a2198 1

d2200 3
a2202 1
    dwarf2_comp_unit_arange_add (unit, low_pc, high_pc);
d2217 15
a2231 1
  return arange_set_lookup_address (unit->arange_set, addr, NULL, NULL, NULL);
a2802 101
typedef struct
{
  struct dwarf2_debug * stash;
  arange_set            set;
  struct comp_unit *    unit;
} stash_copy_local_aranges_data_t;

static int
stash_copy_local_aranges (bfd_vma low,
			  bfd_vma high,
			  arange_value_type data ATTRIBUTE_UNUSED,
			  void *info)
{
  bfd_boolean status;

  stash_copy_local_aranges_data_t *copy_data = info;
  status = arange_set_insert (copy_data->set, low, high,
			      (arange_value_type) copy_data->unit);

  return status ? 0 : 1;
}

static bfd_boolean
stash_maybe_enable_arange_set (bfd *abfd, struct dwarf2_debug *stash)
{
  struct comp_unit *unit;
  stash_copy_local_aranges_data_t copy_data;

  if (stash->arange_set_status != STASH_ARANGE_SET_OFF)
    return TRUE;

  if (stash->comp_unit_count < STASH_ARANGE_SET_TRIGGER)
    return TRUE;

  if (stash->comp_unit_arange_set == NULL)
    {
      stash->comp_unit_arange_set =
	dwarf2_arange_set_with_value_new (abfd);
      if (!stash->comp_unit_arange_set)
	{
	  stash->arange_set_status = STASH_ARANGE_SET_DISABLED;
	  return FALSE;
	}
    }

  copy_data.stash = stash;
  copy_data.set = stash->comp_unit_arange_set;
  for (unit = stash->all_comp_units; unit; unit = unit->next_unit)
    {
      copy_data.unit = unit;
      if (arange_set_foreach (unit->arange_set, stash_copy_local_aranges, 
			      & copy_data))
	{
	  stash->arange_set_status = STASH_ARANGE_SET_DISABLED;
	  return FALSE;
	}
    }
  stash->arange_set_status = STASH_ARANGE_SET_ON;
  return TRUE;
}

/* Find the nearest line to a given address and record filename,
   function name and line number if found.  Return TRUE if a line is
   found or FALSE otherwise.  */

static bfd_boolean ATTRIBUTE_UNUSED
stash_find_nearest_line_fast (struct dwarf2_debug *stash,
			      bfd_vma addr,
			      const char **filename_ptr,
			      const char **functionname_ptr,
			      unsigned int *linenumber_ptr)
{
  arange_value_type value;
  struct comp_unit *unit;

  /* Try looking up global arange set first.  */
  if (stash->arange_set_status == STASH_ARANGE_SET_ON
      && arange_set_lookup_address (stash->comp_unit_arange_set, addr, NULL,
				    NULL, &value))
    {
      if ((unit = (struct comp_unit *) value) != NULL)
	/* There is only one compilation unit containing this address.  */
	return comp_unit_find_nearest_line (unit, addr, filename_ptr,
					    functionname_ptr, linenumber_ptr,
					    stash);
    }

  /* The arange set is not available or there are multiple compilation
     units containing this address.  Search all compilation units.  */
  for (unit = stash->all_comp_units; unit; unit = unit->next_unit)
    {
      if (comp_unit_contains_address (unit, addr)
	  && comp_unit_find_nearest_line (unit, addr, filename_ptr,
					  functionname_ptr,
					  linenumber_ptr, stash))
	  return TRUE;
    }

  return FALSE;
}

d3005 11
a3015 7
      if (stash->arange_set_status == STASH_ARANGE_SET_OFF)
	stash_maybe_enable_arange_set (abfd, stash);

      found = stash_find_nearest_line_fast (stash, addr, filename_ptr,
					    functionname_ptr, linenumber_ptr);
      if (found)
	goto done;
a3088 1
	      stash->comp_unit_count++;
d3091 4
a3094 3
		 compilation units.  If we don't have them, we need to
		 consult the line info table to see if a compilation unit
		 contains the given address.  */
d3097 1
a3097 1
			  || arange_set_empty_p (each->arange_set)
d3104 1
a3104 1
		found = ((arange_set_empty_p (each->arange_set)
@


1.101
log
@bfd/

2007-09-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4986
	* dwarf2.c (new_line_sorts_after): Undo the last change.
	(add_line_info): Only keep the last entry with the same address
	and end sequence.

ld/testsuite/

2007-09-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4986
	* ld-ia64/line.exp: New.
	* ld-ia64/undefined.s: Likewise.

	* ld-x86-64/line.exp: Don't check CC.
@
text
@d39 1
d93 3
d170 16
d188 4
d195 2
d216 2
a217 3
  /* The lowest and highest addresses contained in this compilation
     unit as specified in the compilation unit header.  */
  struct arange arange;
d898 2
a899 2
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
d909 6
a914 6
  struct funcinfo *prev_func;		/* Pointer to previous function in list of all functions */
  struct funcinfo *caller_func;		/* Pointer to function one scope higher */
  char *caller_file;			/* Source location file name where caller_func inlines this func */
  int caller_line;			/* Source location line number where caller_func inlines this func */
  char *file;				/* Source location file name */
  int line;				/* Source location line number */
d918 1
a918 1
  asection *sec;			/* Where the symbol is defined */
d923 1
a923 1
  /* Pointer to previous variable in list of all variables */
d925 1
a925 1
  /* Source location file name */
d927 1
a927 1
  /* Source location line number */
d932 1
a932 1
  /* Where the symbol is defined */
d934 1
a934 1
  /* Is this a stack variable? */
d938 86
d1049 1
a1049 1
  struct line_info* info = bfd_alloc (table->abfd, amt);
d1093 1
a1093 1
      || new_line_sorts_after (info, table->last_line))
d1095 1
a1095 1
      /* Normal case: add 'info' to the beginning of the list */
d1115 1
a1115 1
      struct line_info* li2 = table->last_line; /* always non-NULL */
d1124 1
a1124 1
	  li2 = li1; /* always non-NULL */
d1198 2
a1199 1
arange_add (bfd *abfd, struct arange *first_arange, bfd_vma low_pc, bfd_vma high_pc)
d1203 1
a1203 1
  /* If the first arange is empty, use it. */
d1230 1
a1230 1
     Order isn't significant, so just insert after the first arange. */
d1465 1
a1465 1
		  arange_add (unit->abfd, &unit->arange, low_pc, high_pc);
d1882 17
a1898 1
  return (name);
d1901 14
d1916 4
a1919 1
read_rangelist (struct comp_unit *unit, struct arange *arange, bfd_uint64_t offset)
d1955 3
a1957 1
	arange_add (unit->abfd, arange, base_address + low_pc, base_address + high_pc);
d2090 3
a2092 1
		  read_rangelist (unit, &func->arange, attr.u.val);
d2294 1
d2326 2
a2327 1
	  read_rangelist (unit, &unit->arange, attr.u.val);
d2333 1
d2351 1
d2353 1
a2353 3
    {
      arange_add (unit->abfd, &unit->arange, low_pc, high_pc);
    }
d2368 1
a2368 15
  struct arange *arange;

  if (unit->error)
    return FALSE;

  arange = &unit->arange;
  do
    {
      if (addr >= arange->low && addr < arange->high)
	return TRUE;
      arange = arange->next;
    }
  while (arange);

  return FALSE;
d2940 101
d3243 7
a3249 11
      for (each = stash->all_comp_units; each; each = each->next_unit)
	{
	  found = (comp_unit_contains_address (each, addr)
		   && comp_unit_find_nearest_line (each, addr,
						   filename_ptr,
						   functionname_ptr,
						   linenumber_ptr,
						   stash));
	  if (found)
	    goto done;
	}
d3323 1
d3326 3
a3328 4
		 compilation units.  If we don't have them (i.e.,
		 unit->high == 0), we need to consult the line info
		 table to see if a compilation unit contains the given
		 address.  */
d3331 1
a3331 1
			  || each->arange.high == 0
d3338 1
a3338 1
		found = ((each->arange.high == 0
@


1.100
log
@bfd/

2007-08-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4986
	* dwarf2.c (new_line_sorts_after): Also compare line number.

ld/testsuite/

2007-08-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4986
	* ld-x86-64/line.exp: New
	* ld-x86-64/undefined.s: Likewise.
@
text
@d920 1
a920 2
	      && (new_line->line > line->line
		  || new_line->end_sequence < line->end_sequence)));
d970 12
a981 1
  if (!table->last_line
@


1.99
log
@Speed up bfd_dwarf2_find_line.
* dwarf2.c (struct dwarf2_debug): Add new fields to support function and variable info hash tables. Add last_comp_unit, info_hash_count, funcinfo_hash_table, varinfo_hash_table, hash_units_head.
  (struct comp_unit): Add prev_unit, cached.
  (struct info_list_node, struct info_hash_entry, struct info_hash_table): New.
  (info_hash_table_newfunc, create_info_hash_table, insert_info_hash_table, lookup_info_hash_table): New functions implementing function and variable info hash tables.
  (scan_unit_for_symbols): Add checks to make sure hash tables are consistent with compilation units.
  (comp_unit_maybe_decode_line_info): New function.
  (comp_unit_find_line): Use comp_unit_maybe_decode_line_info.
  (reverse_funcinfo_list, reverse_varinfo_list, comp_unit_hash_info, info_hash_lookup_funcinfo, info_hash_lookup_varinfo, stash_maybe_update_info_hash_table, stash_verify_info_hash_table, stash_maybe_enable_info_hash_tables, stash_find_line_fast): New functions. Make use of info hash tables to speed up bfd_dwarf2_find_line.
  (find_line): Use hash table for faster lookup if it is turned on.
  Also add code to maintain bi-directional link in comp units.
@
text
@d920 2
a921 1
	      && new_line->end_sequence < line->end_sequence));
@


1.98
log
@PR binutils/4797
* dwarf2.c: (find_line) Do not dereference functionname_ptr if do_line is true.
@
text
@d89 3
d145 21
d183 4
d243 3
d272 120
d1864 1
d1886 1
d2281 2
a2282 6
/* If UNIT contains SYM at ADDR, set the output parameters to the
   values for the line containing SYM.  The output parameters,
   FILENAME_PTR, and LINENUMBER_PTR, are pointers to the objects to be
   filled in.

   Return TRUE if UNIT contains SYM, and no errors were encountered;
d2286 2
a2287 6
comp_unit_find_line (struct comp_unit *unit,
		     asymbol *sym,
		     bfd_vma addr,
		     const char **filename_ptr,
		     unsigned int *linenumber_ptr,
		     struct dwarf2_debug *stash)
d2316 22
d2342 99
a2440 4
  else
    return lookup_symbol_in_variable_table (unit, sym, addr,
					    filename_ptr,
					    linenumber_ptr);
d2567 225
d2958 1
a2958 1
  for (each = stash->all_comp_units; each; each = each->next_unit)
d2960 18
a2977 6
      if (do_line)
	found = (((symbol->flags & BSF_FUNCTION) == 0
		  || comp_unit_contains_address (each, addr))
		 && comp_unit_find_line (each, symbol, addr,
					 filename_ptr, linenumber_ptr,
					 stash));
d2979 26
a3004 8
	found = (comp_unit_contains_address (each, addr)
		 && comp_unit_find_nearest_line (each, addr,
						 filename_ptr,
						 functionname_ptr,
						 linenumber_ptr,
						 stash));
      if (found)
	goto done;
d3071 5
@


1.97
log
@Switch sources over to use the GPL version 3
@
text
@d2383 2
a2384 1
  *functionname_ptr = NULL;
@


1.96
log
@* dwarf2.c (find_line): New.  Contains the duplicated code from:
  (_bfd_dwarf2_find_nearest_line): Use it.
  (_bfd_dwarf2_find_line): Use it.
@
text
@d20 1
a20 1
   the Free Software Foundation; either version 2 of the License, or (at
d30 2
a31 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.95
log
@	* configure.in (--with-separate-debug-dir): New option.
	* configure: Regenerate.
	* Makefile.am (dwarf2.lo): Add rule to pass DEBUGDIR.
	* Makefile.in: Regenerate.
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Pass DEBUGDIR to
	bfd_follow_gnu_debuglink.
	(_bfd_dwarf2_find_line): Likewise.
@
text
@d2304 22
a2325 16
/* The DWARF2 version of find_nearest_line.  Return TRUE if the line
   is found without error.  ADDR_SIZE is the number of bytes in the
   initial .debug_info length field and in the abbreviation offset.
   You may use zero to indicate that the default value should be
   used.  */

bfd_boolean
_bfd_dwarf2_find_nearest_line (bfd *abfd,
			       asection *section,
			       asymbol **symbols,
			       bfd_vma offset,
			       const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *linenumber_ptr,
			       unsigned int addr_size,
			       void **pinfo)
d2340 1
d2361 16
a2376 1
  addr = offset;
a2384 7
  /* The DWARF2 spec says that the initial length field, and the
     offset of the abbreviation table, should both be 4-byte values.
     However, some compilers do things differently.  */
  if (addr_size == 0)
    addr_size = 4;
  BFD_ASSERT (addr_size == 4 || addr_size == 8);

d2470 15
a2484 6
    if (comp_unit_contains_address (each, addr)
	&& comp_unit_find_nearest_line (each, addr, filename_ptr,
					functionname_ptr,
					linenumber_ptr, stash))
      {
	found = TRUE;
d2486 8
a2493 1
      }
d2503 2
a2504 2
      /* A 0xffffff length is the DWARF3 way of indicating we use
	 64-bit offsets, instead of 32-bit offsets.  */
d2560 18
a2577 11
	      if ((each->arange.high == 0
		   || comp_unit_contains_address (each, addr))
		  && comp_unit_find_nearest_line (each, addr,
						  filename_ptr,
						  functionname_ptr,
						  linenumber_ptr,
						  stash))
		{
		  found = TRUE;
		  goto done;
		}
d2589 21
a2609 2
/* The DWARF2 version of find_line.  Return TRUE if the line is found
   without error.  */
d2620 3
a2622 230
  /* Read each compilation unit from the section .debug_info, and check
     to see if it contains the address we are searching for.  If yes,
     lookup the address, and return the line number info.  If no, go
     on to the next compilation unit.

     We keep a list of all the previously read compilation units, and
     a pointer to the next un-read compilation unit.  Check the
     previously read units before reading more.  */
  struct dwarf2_debug *stash;
  /* What address are we looking for?  */
  bfd_vma addr;
  struct comp_unit* each;
  asection *section;
  bfd_boolean found = FALSE;

  section = bfd_get_section (symbol);

  stash = *pinfo;

  if (! stash)
    {
      bfd_size_type amt = sizeof (struct dwarf2_debug);

      stash = bfd_zalloc (abfd, amt);
      if (! stash)
	return FALSE;
    }

  /* In a relocatable file, 2 functions may have the same address.
     We change the section vma so that they won't overlap.  */
  if (!stash && (abfd->flags & (EXEC_P | DYNAMIC)) == 0)
    {
      if (! place_sections (abfd, stash))
	return FALSE;
    }

  addr = symbol->value;
  if (section->output_section)
    addr += section->output_section->vma + section->output_offset;
  else
    addr += section->vma;

  *filename_ptr = NULL;
  *filename_ptr = NULL;
  *linenumber_ptr = 0;

  if (! *pinfo)
    {
      bfd *debug_bfd;
      bfd_size_type total_size;
      asection *msec;

      *pinfo = stash;

      msec = find_debug_info (abfd, NULL);
      if (msec == NULL)
	{
	  char * debug_filename = bfd_follow_gnu_debuglink (abfd, DEBUGDIR);

	  if (debug_filename == NULL)
	    /* No dwarf2 info, and no gnu_debuglink to follow.
	       Note that at this point the stash has been allocated, but
	       contains zeros.  This lets future calls to this function
	       fail more quickly.  */
	    goto done;

	  if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
	      || ! bfd_check_format (debug_bfd, bfd_object)
	      || (msec = find_debug_info (debug_bfd, NULL)) == NULL)
	    {
	      if (debug_bfd)
		bfd_close (debug_bfd);
	      /* FIXME: Should we report our failure to follow the debuglink ?  */
	      free (debug_filename);
	      goto done;
	    }
	}
      else
	debug_bfd = abfd;

      /* There can be more than one DWARF2 info section in a BFD these days.
	 Read them all in and produce one large stash.  We do this in two
	 passes - in the first pass we just accumulate the section sizes.
	 In the second pass we read in the section's contents.  The allows
	 us to avoid reallocing the data as we add sections to the stash.  */
      for (total_size = 0; msec; msec = find_debug_info (debug_bfd, msec))
	total_size += msec->size;

      stash->info_ptr = bfd_alloc (debug_bfd, total_size);
      if (stash->info_ptr == NULL)
	goto done;

      stash->info_ptr_end = stash->info_ptr;

      for (msec = find_debug_info (debug_bfd, NULL);
	   msec;
	   msec = find_debug_info (debug_bfd, msec))
	{
	  bfd_size_type size;
	  bfd_size_type start;

	  size = msec->size;
	  if (size == 0)
	    continue;

	  start = stash->info_ptr_end - stash->info_ptr;

	  if ((bfd_simple_get_relocated_section_contents
	       (debug_bfd, msec, stash->info_ptr + start, symbols)) == NULL)
	    continue;

	  stash->info_ptr_end = stash->info_ptr + start + size;
	}

      BFD_ASSERT (stash->info_ptr_end == stash->info_ptr + total_size);

      stash->sec = find_debug_info (debug_bfd, NULL);
      stash->sec_info_ptr = stash->info_ptr;
      stash->syms = symbols;
      stash->bfd = debug_bfd;
    }

  /* A null info_ptr indicates that there is no dwarf2 info
     (or that an error occured while setting up the stash).  */
  if (! stash->info_ptr)
    goto done;

  stash->inliner_chain = NULL;

  /* Check the previously read comp. units first.  */
  for (each = stash->all_comp_units; each; each = each->next_unit)
    if ((symbol->flags & BSF_FUNCTION) == 0
	|| comp_unit_contains_address (each, addr))
      {
	found = comp_unit_find_line (each, symbol, addr, filename_ptr,
				     linenumber_ptr, stash);
	if (found)
	  goto done;
      }

  /* The DWARF2 spec says that the initial length field, and the
     offset of the abbreviation table, should both be 4-byte values.
     However, some compilers do things differently.  */
  if (addr_size == 0)
    addr_size = 4;
  BFD_ASSERT (addr_size == 4 || addr_size == 8);

  /* Read each remaining comp. units checking each as they are read.  */
  while (stash->info_ptr < stash->info_ptr_end)
    {
      bfd_vma length;
      unsigned int offset_size = addr_size;
      bfd_byte *info_ptr_unit = stash->info_ptr;

      length = read_4_bytes (stash->bfd, stash->info_ptr);
      /* A 0xffffff length is the DWARF3 way of indicating we use
	 64-bit offsets, instead of 32-bit offsets.  */
      if (length == 0xffffffff)
	{
	  offset_size = 8;
	  length = read_8_bytes (stash->bfd, stash->info_ptr + 4);
	  stash->info_ptr += 12;
	}
      /* A zero length is the IRIX way of indicating 64-bit offsets,
	 mostly because the 64-bit length will generally fit in 32
	 bits, and the endianness helps.  */
      else if (length == 0)
	{
	  offset_size = 8;
	  length = read_4_bytes (stash->bfd, stash->info_ptr + 4);
	  stash->info_ptr += 8;
	}
      /* In the absence of the hints above, we assume 32-bit DWARF2
	 offsets even for targets with 64-bit addresses, because:
	   a) most of the time these targets will not have generated
	      more than 2Gb of debug info and so will not need 64-bit
	      offsets,
	 and
	   b) if they do use 64-bit offsets but they are not using
	      the size hints that are tested for above then they are
	      not conforming to the DWARF3 standard anyway.  */
      else if (addr_size == 8)
	{
	  offset_size = 4;
          stash->info_ptr += 4;
	}
      else
	stash->info_ptr += 4;

      if (length > 0)
	{
	  each = parse_comp_unit (stash, length, info_ptr_unit,
				  offset_size);
	  stash->info_ptr += length;

	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
	      == stash->sec->size)
	    {
	      stash->sec = find_debug_info (stash->bfd, stash->sec);
	      stash->sec_info_ptr = stash->info_ptr;
	    }

	  if (each)
	    {
	      each->next_unit = stash->all_comp_units;
	      stash->all_comp_units = each;

	      /* DW_AT_low_pc and DW_AT_high_pc are optional for
		 compilation units.  If we don't have them (i.e.,
		 unit->high == 0), we need to consult the line info
		 table to see if a compilation unit contains the given
		 address.  */
	      found = (((symbol->flags & BSF_FUNCTION) == 0
			|| each->arange.high <= 0
			|| comp_unit_contains_address (each, addr))
		       && comp_unit_find_line (each, symbol, addr,
					       filename_ptr,
					       linenumber_ptr,
					       stash));
	      if (found)
		goto done;
	    }
	}
    }

done:
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
    unset_sections (stash);

  return found;
d2638 1
d2645 1
a2645 1
	  return (TRUE);
d2649 1
a2649 1
  return (FALSE);
@


1.94
log
@* dwarf2.c: Add support for reading in debug information via a .gnu_debuglink section:
  (struct dwarf2_debug): Add bfd field to record the bfd containing the debug info.
  (parse_comp_unit): Remove ABFD parameter.  Instead use the bfd field in the dwarf2_debug structure.
  (_bfd_dwarf2_find_nearest_line): If a debug info section could not be found in the current bfd call bfd_follow_gnu_debuglink to see if another file contains the debug information.  If it does, open it and continue.
  (bfd_dwarf2_find_line): Likewise.
@
text
@d2381 1
a2381 1
	  char * debug_filename = bfd_follow_gnu_debuglink (abfd, NULL);
d2620 1
a2620 1
	  char * debug_filename = bfd_follow_gnu_debuglink (abfd, NULL);
@


1.93
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d96 4
a99 2
  /* Pointer to the section and address of the beginning of the
     section.  */
d1893 1
a1893 2
parse_comp_unit (bfd *abfd,
		 struct dwarf2_debug *stash,
d1911 1
d2197 1
a2197 4
  if (after_sec)
    msec = after_sec->next;
  else
    msec = abfd->sections;
a2329 1

a2331 1

a2332 1

d2372 1
d2379 24
a2402 5
      if (! msec)
	/* No dwarf2 info.  Note that at this point the stash
	   has been allocated, but contains zeros, this lets
	   future calls to this function fail quicker.  */
	goto done;
d2409 1
a2409 1
      for (total_size = 0; msec; msec = find_debug_info (abfd, msec))
d2412 1
a2412 1
      stash->info_ptr = bfd_alloc (abfd, total_size);
d2418 1
a2418 1
      for (msec = find_debug_info (abfd, NULL);
d2420 1
a2420 1
	   msec = find_debug_info (abfd, msec))
d2432 1
a2432 1
	       (abfd, msec, stash->info_ptr + start, symbols)) == NULL)
d2440 1
a2440 1
      stash->sec = find_debug_info (abfd, NULL);
d2443 1
d2471 1
a2471 1
      length = read_4_bytes (abfd, stash->info_ptr);
d2477 1
a2477 1
	  length = read_8_bytes (abfd, stash->info_ptr + 4);
d2486 1
a2486 1
	  length = read_4_bytes (abfd, stash->info_ptr + 4);
d2508 1
a2508 1
	  each = parse_comp_unit (abfd, stash, length, info_ptr_unit,
d2515 1
a2515 1
	      stash->sec = find_debug_info (abfd, stash->sec);
a2571 1

a2573 1

a2574 1

a2575 1

d2611 1
d2618 24
a2641 5
      if (! msec)
	/* No dwarf2 info.  Note that at this point the stash
	   has been allocated, but contains zeros, this lets
	   future calls to this function fail quicker.  */
	goto done;
d2648 1
a2648 1
      for (total_size = 0; msec; msec = find_debug_info (abfd, msec))
d2651 1
a2651 1
      stash->info_ptr = bfd_alloc (abfd, total_size);
d2657 1
a2657 1
      for (msec = find_debug_info (abfd, NULL);
d2659 1
a2659 1
	   msec = find_debug_info (abfd, msec))
d2671 1
a2671 1
	       (abfd, msec, stash->info_ptr + start, symbols)) == NULL)
d2679 1
a2679 1
      stash->sec = find_debug_info (abfd, NULL);
d2682 1
d2717 1
a2717 1
      length = read_4_bytes (abfd, stash->info_ptr);
d2723 1
a2723 1
	  length = read_8_bytes (abfd, stash->info_ptr + 4);
d2732 1
a2732 1
	  length = read_4_bytes (abfd, stash->info_ptr + 4);
d2754 1
a2754 1
	  each = parse_comp_unit (abfd, stash, length, info_ptr_unit,
d2761 1
a2761 1
	      stash->sec = find_debug_info (abfd, stash->sec);
@


1.92
log
@bfd/

2007-02-23  Carlos O'Donell  <carlos@@codesourcery.com>

	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Assume 32-bit
	DWARF even with 64-bit addresses.
	(_bfd_dwarf2_find_nearest_line): Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d32 1
a33 1
#include "sysdep.h"
@


1.91
log
@	* dwarf2.c (concat_filename): Apply DW_AT_comp_dir if dir table
	entry isn't absolute.
@
text
@d2472 9
a2480 3
      /* In the absence of the hints above, we assume addr_size-sized
	 offsets, for backward-compatibility with pre-DWARF3 64-bit
	 platforms.  */
d2483 2
a2484 2
	  length = read_8_bytes (abfd, stash->info_ptr);
	  stash->info_ptr += 8;
d2701 9
a2709 3
      /* In the absence of the hints above, we assume addr_size-sized
	 offsets, for backward-compatibility with pre-DWARF3 64-bit
	 platforms.  */
d2712 2
a2713 2
	  length = read_8_bytes (abfd, stash->info_ptr);
	  stash->info_ptr += 8;
@


1.90
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d877 1
a877 1
  if (! IS_ABSOLUTE_PATH (filename))
d879 12
a890 7
      char *dirname = (table->files[file - 1].dir
		       ? table->dirs[table->files[file - 1].dir - 1]
		       : table->comp_dir);

      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.
	 The best we can do is return the filename part.  */
      if (dirname != NULL)
d892 3
a894 2
	  unsigned int len = strlen (dirname) + strlen (filename) + 2;
	  char * name;
d896 14
a912 1
	  return name;
d914 2
@


1.89
log
@	* archive.c (bfd_generic_archive_p): Remove unused local variable
	`fail'.
	* dwarf2.c (decode_line_info): Remove unused local variable
	`basic_block'.
	* elfcode.h (elf_slurp_reloc_table_from_section): Remove unsed
	local varibale `s'.
	* tekhex.c (tekhex_write_object_contents): Remove unused local
	variable `bytes_written'.
	* aout-ns32k.c (MY_swap_std_reloc_out): Remove unused local
	variable `r_addend'.
	* elf32-dlx.c (dlx_rtype_to_howto): Remove breaks after returns.
	* elfxx-mips.c (_bfd_elf_mips_mach): Remove breaks after returns.
	(_bfd_ns32k_relocate_contents): Remove break after return.
	* elf.c (bfd_section_from_shdr): Remove breaks after returns.
@
text
@d2184 1
a2184 1
      if (strncmp (msec->name, GNU_LINKONCE_INFO, strlen (GNU_LINKONCE_INFO)) == 0)
@


1.88
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@a1119 1
      int basic_block = 0;
a1143 1
	      basic_block = 1;
a1214 1
	      basic_block = 0;
a1249 1
	      basic_block = 1;
@


1.87
log
@2006-03-11  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2443
	* dwarf2.c (concat_filename): Don't issue an error if file is
	0.
@
text
@d1628 1
a1628 1
	  arange_add (unit->abfd, arange, base_address + low_pc, base_address + high_pc);
@


1.86
log
@	* dwarf2.c: Formatting.
	(add_line_info): Remove outer loop.
@
text
@d868 4
a871 2
      (*_bfd_error_handler)
	(_("Dwarf Error: mangled line number section (bad file number)."));
@


1.85
log
@2006-03-05  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR binutils/2338
	* dwarf2.c (loadable_section): New struct.
	(dwarf2_debug): Add loadable_section_count and
	loadable_sections.
	(new_line_sorts_after): New.
	(add_line_info): Use new_line_sorts_after to compare line
	addresses.
	(check_function_name): Removed.
	(unset_sections): New.
	(place_sections): New.
	(_bfd_dwarf2_find_nearest_line): Updated. Call place_sections
	and unset_sections on relocatable files.
	(_bfd_dwarf2_find_line): Likewise.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d496 6
a501 2
	        {
	          size_t i;
d503 8
a510 12
	          for (i = 0; i < ABBREV_HASH_SIZE; i++)
	            {
	            struct abbrev_info *abbrev = abbrevs[i];

	            while (abbrev)
	              {
	                free (abbrev->attrs);
	                abbrev = abbrev->next;
	              }
	            }
	          return NULL;
	        }
d536 1
a536 1
	    >= stash->dwarf_abbrev_size)
d816 25
a840 38
  while (1)
    if (!table->last_line
	|| new_line_sorts_after (info, table->last_line))
      {
	/* Normal case: add 'info' to the beginning of the list */
	info->prev_line = table->last_line;
	table->last_line = info;

	/* lcl_head: initialize to head a *possible* sequence at the end.  */
	if (!table->lcl_head)
	  table->lcl_head = info;
	break;
      }
    else if (!table->lcl_head->prev_line
	     && !new_line_sorts_after (info, table->lcl_head))
      {
	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = NULL;
	table->lcl_head->prev_line = info;
	break;
      }
    else if (table->lcl_head->prev_line
	     && !new_line_sorts_after (info, table->lcl_head)
	     && new_line_sorts_after (info, table->lcl_head->prev_line))
      {
	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = table->lcl_head->prev_line;
	table->lcl_head->prev_line = info;
	break;
      }
    else
      {
	/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
	struct line_info* li2 = table->last_line; /* always non-NULL */
	struct line_info* li1 = li2->prev_line;
d842 5
a846 5
	while (li1)
	  {
	    if (!new_line_sorts_after (info, li2)
		&& new_line_sorts_after (info, li1))
	      break;
d848 7
a854 5
	    li2 = li1; /* always non-NULL */
	    li1 = li1->prev_line;
	  }
	table->lcl_head = li2;
      }
d1184 1
a1184 1
		        {
d1189 1
a1189 1
		        }
d1601 1
a1601 1
    
d1818 1
a1818 1
		    
d2776 2
a2777 2
        {
          struct abbrev_info *abbrev = abbrevs[i];
d2779 6
a2784 6
          while (abbrev)
            {
              free (abbrev->attrs);
              abbrev = abbrev->next;
            }
        }
d2787 4
a2790 4
        {
          free (each->line_table->dirs);
          free (each->line_table->files);
        }
@


1.84
log
@2006-02-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2338
	* dwarf2.c (check_function_name): New function.
	(_bfd_dwarf2_find_nearest_line): Use check_function_name to
	check if function is correct.
@
text
@d77 6
d133 6
d759 11
d786 15
d818 1
a818 1
	|| address >= table->last_line->address)
d830 1
a830 1
	     && table->lcl_head->address > address)
d839 2
a840 2
	     && table->lcl_head->address > address
	     && address >= table->lcl_head->prev_line->address)
d857 2
a858 1
	    if (li2->address > address && address >= li1->address)
a865 15

  /* Set member data of 'info'.  */
  info->address = address;
  info->line = line;
  info->column = column;
  info->end_sequence = end_sequence;

  if (filename && filename[0])
    {
      info->filename = bfd_alloc (table->abfd, strlen (filename) + 1);
      if (info->filename)
	strcpy (info->filename, filename);
    }
  else
    info->filename = NULL;
d2206 16
a2221 2
/* Return TRUE if there is no mismatch bewteen function FUNC and
   section SECTION from symbol table SYMBOLS in ABFD.  */
d2224 1
a2224 2
check_function_name (bfd *abfd, asection *section, asymbol **symbols,
		     const char *func)
d2226 65
a2290 15
  /* Mismatch can only happen when we have 2 functions with the same
     address. It can only occur in a relocatable file.  */
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      && func != NULL
      && section != NULL
      && symbols != NULL)
    {
      asymbol **p;

      for (p = symbols; *p != NULL; p++)
	{
	  if (((*p)->flags & BSF_FUNCTION) != 0
	      && (*p)->name != NULL
	      && strcmp ((*p)->name, func) == 0)
	    return (*p)->section == section;
d2329 2
d2332 18
d2366 1
a2366 1
  if (! stash)
a2369 5
      bfd_size_type amt = sizeof (struct dwarf2_debug);

      stash = bfd_zalloc (abfd, amt);
      if (! stash)
	return FALSE;
d2378 1
a2378 1
	 return FALSE;
d2390 1
a2390 1
	return FALSE;
d2424 1
a2424 1
    return FALSE;
d2433 5
a2437 4
					linenumber_ptr, stash)
	&& check_function_name (abfd, section, symbols,
				*functionname_ptr))
      return TRUE;
d2504 5
a2508 4
						  stash)
		  && check_function_name (abfd, section, symbols,
					  *functionname_ptr))
		return TRUE;
d2513 5
a2517 1
  return FALSE;
d2549 1
a2549 1
  bfd_boolean found;
d2553 19
a2578 1
  stash = *pinfo;
d2582 1
a2582 1
  if (! stash)
a2585 5
      bfd_size_type amt = sizeof (struct dwarf2_debug);

      stash = bfd_zalloc (abfd, amt);
      if (! stash)
	return FALSE;
d2594 1
a2594 1
	 return FALSE;
d2606 1
a2606 1
	return FALSE;
d2640 1
a2640 1
    return FALSE;
d2652 1
a2652 1
	  return found;
d2729 1
a2729 1
		return TRUE;
d2734 5
a2738 1
  return FALSE;
@


1.83
log
@2006-01-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2096
	* dwarf2.c (comp_unit_contains_address): Update comment.
	(_bfd_dwarf2_find_nearest_line): Use section's vma, instead of
	lma.  Return TRUE only if both comp_unit_contains_address and
	comp_unit_find_nearest_line return TRUE.
	(_bfd_dwarf2_find_line): Use section's vma, instead of lma.
@
text
@d2182 28
d2331 3
a2333 1
					linenumber_ptr, stash))
d2401 3
a2403 1
						  stash))
@


1.82
log
@(lookup_symbol_in_function_table): Check for a function name before passing
it to strcmp.
@
text
@d2009 5
a2013 1
/* Return TRUE if UNIT contains the address given by ADDR.  */
d2217 1
a2217 1
    addr += section->output_section->lma + section->output_offset;
d2219 1
a2219 1
    addr += section->lma;
d2300 5
a2304 4
    if (comp_unit_contains_address (each, addr))
      return comp_unit_find_nearest_line (each, addr, filename_ptr,
					  functionname_ptr, linenumber_ptr,
					  stash);
a2309 1
      bfd_boolean found;
d2365 8
a2372 19
	      if (each->arange.high > 0)
		{
		  if (comp_unit_contains_address (each, addr))
		    return comp_unit_find_nearest_line (each, addr,
							filename_ptr,
							functionname_ptr,
							linenumber_ptr,
							stash);
		}
	      else
		{
		  found = comp_unit_find_nearest_line (each, addr,
						       filename_ptr,
						       functionname_ptr,
						       linenumber_ptr,
						       stash);
		  if (found)
		    return TRUE;
		}
d2415 1
a2415 1
    addr += section->output_section->lma + section->output_offset;
d2417 1
a2417 1
    addr += section->lma;
@


1.81
log
@Fix addr2line -i problem; reports incorrect function nesting for inline funcs.
* dwarf2.c (struct funcinfo): Delete nesting_level field.
(lookup_address_in_function_table): Delete code to set funcinfo
caller_func field.  Delete local curr_func.
(scan_unit_for_symbols): New locals nested_funcs, nested_funcs_size.
Delete code setting funcinfo nesting_level field.  Add code to set
funcinfo caller_func field.
@
text
@d1470 1
@


1.80
log
@Add mangled names to addr2line -i output.
* dwarf2.c (find_abstract_instance_name): Don't early exit when name
set.  For DW_AT_name case, only set name if not already set.  Handle
DW_AT_MIPS_linkage_name.
@
text
@a724 1
  int nesting_level;
a1432 2
      struct funcinfo* curr_func = best_fit;

a1434 18

      /* If we found a match and it is a function that was inlined,
	 traverse the function list looking for the function at the
	 next higher scope and save a pointer to it for future use.
	 Note that because of the way the DWARF info is generated, and
	 the way we build the function list, the first function at the
	 next higher level is the one we want. */

      for (each_func = best_fit -> prev_func;
	   each_func && (curr_func->tag == DW_TAG_inlined_subroutine);
	   each_func = each_func->prev_func)
	{
	  if (each_func->nesting_level < curr_func->nesting_level)
	    {
	      curr_func->caller_func = each_func;
	      curr_func = each_func;
	    }
	}
d1627 10
d1663 1
a1674 1
	  func->nesting_level = nesting_level;
d1677 9
d1699 3
d1822 20
a1841 1
	nesting_level++;
d1844 1
@


1.79
log
@bfd/

2005-08-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1179
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Use section lma
	instead of vma.
	(_bfd_dwarf2_find_line): Likewise.

binutils/

2005-08-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1179
	* objdump.c (disassemble_bytes): Don't adjust
	adjust_section_vma.
	(adjust_addresses): Don't adjust vma for debugging section.
	Adjust lma only for relocatable files.
	(dump_bfd): Tell adjust_addresses if it is a relocatable file.
@
text
@d1571 1
a1571 1
	  for (i = 0; i < abbrev->num_attrs && !name; ++i)
d1577 3
a1579 1
		  name = attr.u.str;
d1584 3
@


1.78
log
@Fix linker error found when compiling glibc with a mismatched gcc.
* dwarf2.c (scan_unit_for_symbols, case DT_AT_location): Verify that
DW_OP_addr is only opcode in location before using it.
@
text
@d2186 1
a2186 1
    addr += section->output_section->vma + section->output_offset;
d2188 1
a2188 1
    addr += section->vma;
d2395 1
a2395 1
    addr += section->output_section->vma + section->output_offset;
d2397 1
a2397 1
    addr += section->vma;
@


1.77
log
@Reviewed and approved by Nick Clifton  <nickc@@redhat.com>

	2005-08-05  Fred Fish  <fnf@@specifix.com>
	* dwarf2.c (read_rangelist): Use addr_size instead of offset_size
	to determine how many bytes to read from each rangelist entry.
@
text
@d1785 11
a1795 3
			  var->addr = bfd_get ((attr.u.blk->size - 1) * 8,
					       unit->abfd,
					       attr.u.blk->data + 1);
@


1.76
log
@2005-07-08  Paul Koning  <pkoning@@equallogic.com>

	* dwarf2.c (read_address): Check sign_extend_vma to handle targets
	where addresses are sign extended.
@
text
@d1609 1
a1609 1
      if (unit->offset_size == 4)
@


1.75
log
@2005-07-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (varinfo): Add addr.
	(lookup_symbol_in_variable_table): Also check addr.
	(scan_unit_for_symbols): Set addr for variable.
	(comp_unit_find_line): Updated.
@
text
@d350 3
a352 1
  switch (unit->addr_size)
d354 25
a378 8
    case 8:
      return bfd_get_64 (unit->abfd, buf);
    case 4:
      return bfd_get_32 (unit->abfd, buf);
    case 2:
      return bfd_get_16 (unit->abfd, buf);
    default:
      abort ();
@


1.74
log
@	* dwarf2.c (decode_line_info): Revert last change.  Instead set
	initial low_pc to -1 to avoid need to test whether loc_pc has
	been set.
@
text
@d722 1
d1499 1
d1509 3
d1757 1
a1757 1
		  if (var->stack)
d1759 5
a1763 1
		      switch (attr.form)
d1765 4
a1768 10
			case DW_FORM_block:
			case DW_FORM_block1:
			case DW_FORM_block2:
			case DW_FORM_block4:
			  if (*attr.u.blk->data == DW_OP_addr)
			    var->stack = 0;
			  break;

			default:
			  break;
d1770 4
d2083 2
a2084 1
    return lookup_symbol_in_variable_table (unit, sym, filename_ptr,
@


1.73
log
@2005-06-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1000
	* dwarf2.c (lookup_address_in_line_info_table): Restore code
	handling NULL function info, removed with 2005-04-03 change.
@
text
@d1093 1
a1093 1
      bfd_vma low_pc  = 0;
a1094 1
      bfd_boolean low_pc_set = FALSE;
d1112 2
a1113 5
	      if (!low_pc_set || address < low_pc)
		{
		  low_pc_set = TRUE;
		  low_pc = address;
		}
d1131 2
a1132 5
		  if (!low_pc_set || address < low_pc)
		    {
		      low_pc_set = TRUE;
		      low_pc = address;
		    }
d1184 2
a1185 5
	      if (!low_pc_set || address < low_pc)
		{
		  low_pc_set = TRUE;
		  low_pc = address;
		}
@


1.72
log
@bfd/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* bfd.c (bfd_find_line): New.

	* dwarf2.c (comp_unit): Add variable_table.
	(funcinfo): Add file, line, and sec.
	(varinfo): New.
	(lookup_symbol_in_function_table): New.
	(lookup_symbol_in_variable_table): New.
	(scan_unit_for_functions): Renamed to ...
	(scan_unit_for_symbols): This. Handle DW_TAG_entry_point and
	DW_TAG_variable.
	(comp_unit_find_nearest_line): Updated.
	(comp_unit_find_line): New.
	(_bfd_dwarf2_find_line): New.

	* elf-bfd.h (_bfd_elf_find_line): New.
	(_bfd_generic_find_line): New. Defined.

	* elf.c (_bfd_elf_find_line): New.

	* libbfd-in.h (_bfd_dwarf2_find_line): New.
	(_bfd_generic_find_line): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_find_line): New.

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize _bfd_find_line
	with _bfd_generic_find_line.
	(bfd_target): Add _bfd_find_line.

binutils/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* nm.c (print_symbol): Call bfd_find_line before
	bfd_find_nearest_line.
@
text
@d1329 5
@


1.71
log
@2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (decode_line_info): Properly set low_pc.
@
text
@d185 3
d703 2
d709 17
d1449 78
d1616 1
a1616 1
   to the function table.  */
d1619 1
a1619 1
scan_unit_for_functions (struct comp_unit *unit)
d1631 1
d1653 1
d1655 1
d1666 12
a1677 1
	func = NULL;
d1721 54
d2015 1
a2015 1
	  && ! scan_unit_for_functions (unit))
d2033 52
d2330 204
@


1.70
log
@2005-06-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (comp_unit): Fix a typo in comment.
@
text
@d1073 1
d1091 5
a1095 2
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
d1113 5
a1117 2
		  if (low_pc == 0 || address < low_pc)
		    low_pc = address;
d1169 5
a1173 2
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
@


1.69
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d144 1
a144 1
  /* Keep the bdf convenient (for memory allocation).  */
@


1.68
log
@* dwarf2.c (read_abbrevs): If bfd_realloc fails, free currently allocated memory
  before returning.
  (decode_line_info): Likewise.
  (_bfd_dwarf2_cleanup_debug_info): New function:  Frees memory	allocated by
  functions in this file.
* elf-bfd.h (_bfd_dwarf2_cleanup_debug_info): Prototype.
* elf.c (bfd_elf_close_and_cleanup): Call _bfd_dwarf2_cleanup_debug_info.
@
text
@d121 6
d689 5
d696 6
a701 1
  struct funcinfo *prev_func;
d1359 1
a1359 1
lookup_address_in_function_table (struct funcinfo *table,
d1368 1
a1368 1
  for (each_func = table;
d1387 2
d1391 18
d1547 2
d1563 8
d1845 1
a1845 1
  func_p = lookup_address_in_function_table (unit->function_table, addr,
d1847 2
d2005 2
d2100 26
@


1.67
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d450 2
d454 18
a471 3
	      cur_abbrev->attrs = bfd_realloc (cur_abbrev->attrs, amt);
	      if (! cur_abbrev->attrs)
		return 0;
d983 2
d987 8
a994 3
	  table->dirs = bfd_realloc (table->dirs, amt);
	  if (! table->dirs)
	    return 0;
d1009 2
d1013 9
a1021 3
	  table->files = bfd_realloc (table->files, amt);
	  if (! table->files)
	    return 0;
d1108 2
d1112 9
a1120 3
		      table->files = bfd_realloc (table->files, amt);
		      if (! table->files)
			return 0;
d1137 4
a1140 1
		  return 0;
d2049 42
@


1.66
log
@Update the FSF address in the copyright/GPL notice
@
text
@d30 1
a30 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.65
log
@Apply patch for binutils bug 806, approved by nickc@@redhat.com.

	2005-04-03  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add dwarf_ranges_buffer and
	dwarf_ranges_size members.
	(struct comp_unit): Add base_address member.
	(struct funcinfo): Replace low/high members with an arange.
	(arange_add): Replace incoming "unit" parameter with "abfd" and
	"first_arange" pointers.  Reorganize/rewrite function body.
	(decode_line_info): Change arange_add call to pass bfd and arange
	pointers.
	(lookup_address_in_line_info_table): Use arange list instead of
	individual low/high members.  Walk function's arange list to find
	lowest PC in list, to test for overlapping functions.
	(read_debug_ranges): New function, reads the debug_ranges section.
	(lookup_address_in_function_table): Use arange list instead of
	individual low/high members.  Rewrite to find smallest range that
	matches.
	(read_rangelist): Read a given rangelist from debug_ranges.
	(scan_unit_for_functions): Use arange list instead of individual
	low/high members.  Handle a DW_AT_ranges attribute.
	(parse_comp_unit): Use arange list instead of individual low/high
	members.  Save comp unit base address.  Handle a DW_AT_ranges
	attribute.
@
text
@d30 1
a30 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.64
log
@	Approved by nickc@@redhat.com
	2005-03-29  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct comp_unit): Fix typo.
	(scan_unit_for_functions): Remove unused local variable "name"
	and dead code that set it.
@
text
@d115 6
d187 4
d670 1
a670 2
  bfd_vma low;
  bfd_vma high;
d812 1
a812 1
arange_add (struct comp_unit *unit, bfd_vma low_pc, bfd_vma high_pc)
d816 7
a822 2
  /* First see if we can cheaply extend an existing range.  */
  arange = &unit->arange;
d824 2
d842 3
a844 11
  if (unit->arange.high == 0)
    {
      /* This is the first address range: store it in unit->arange.  */
      unit->arange.next = 0;
      unit->arange.low = low_pc;
      unit->arange.high = high_pc;
      return;
    }

  /* Need to allocate a new arange and insert it into the arange list.  */
  arange = bfd_zalloc (unit->abfd, sizeof (*arange));
d847 2
a848 3

  arange->next = unit->arange.next;
  unit->arange.next = arange;
d1065 1
a1065 1
		  arange_add (unit, low_pc, high_pc);
d1201 1
a1201 1
      if (each_line->address <= addr && addr <= next_line->address)
d1209 2
a1210 3
	  if (function != NULL
	      && each_line->address < function->low
	      && next_line->address > function->low)
d1212 25
a1236 7
	      *filename_ptr = next_line->filename;
	      *linenumber_ptr = next_line->line;
	    }
	  else
	    {
	      *filename_ptr = each_line->filename;
	      *linenumber_ptr = each_line->line;
d1263 29
d1294 4
a1297 1
/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.  */
d1306 2
d1313 3
a1315 1
      if (addr >= each_func->low && addr < each_func->high)
d1317 6
a1322 3
	  *functionname_ptr = each_func->name;
	  *function_ptr = each_func;
	  return TRUE;
d1326 10
a1335 1
  return FALSE;
d1383 41
d1442 2
d1497 1
a1497 1
		  func->low = attr.u.val;
d1501 5
a1505 1
		  func->high = attr.u.val;
d1514 5
d1553 2
d1642 5
a1646 1
	  unit->arange.low = attr.u.val;
d1650 5
a1654 1
	  unit->arange.high = attr.u.val;
d1677 4
@


1.63
log
@(read_indirect_string): Fix apparent typo, check dwarf_str_buffer allocation,
not dwarf_abbrev_buffer.
@
text
@d135 1
a135 1
  /* The lowest and higest addresses contained in this compilation
a1328 1
      char *name = 0;
a1371 3

		  name = attr.u.str;

a1392 12
	  else
	    {
	      switch (attr.name)
		{
		case DW_AT_name:
		  name = attr.u.str;
		  break;

		default:
		  break;
		}
	    }
@


1.62
log
@Approved by nickc@@redhat.com:

	2005-02-21  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (find_abstract_instance_name): Call recursively
	to handle a DW_AT_specification.
@
text
@d304 1
a304 1
      if (! stash->dwarf_abbrev_buffer)
@


1.61
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1294 11
a1304 2
	      if (attr.name == DW_AT_name)
		name = attr.u.str;
@


1.60
log
@2005-01-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf2.c (dwarf2_debug): Move info_ptr_unit to ...
	(comp_unit): Here.
	(read_unsigned_leb128): Removed.
	(read_signed_leb128): Removed.
	(find_abstract_instance_name): Updated.
	(parse_comp_unit): Accept info_ptr_unit.
	(_bfd_dwarf2_find_nearest_line): Set info_ptr_unit for each
	comp unit and pass it to parse_comp_unit.

	* elf-eh-frame.c (read_unsigned_leb128): Moved to ...
	(read_signed_leb128): Moved to ...
	* libbfd.c: Here.

	* libbfd-in.h (read_unsigned_leb128): New prototype.
	(read_signed_leb128): Likewise.
	* libbfd.h: Regenerated.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d74 1
a74 1
  char *data;
d80 1
a80 1
  struct comp_unit* all_comp_units;
d85 1
a85 1
  char* info_ptr;
d88 1
a88 1
  char* info_ptr_end;
d92 2
a93 2
  asection* sec;
  char* sec_info_ptr;
d96 1
a96 1
  asymbol** syms;
d99 1
a99 1
  char* dwarf_abbrev_buffer;
d105 1
a105 1
  char *dwarf_line_buffer;
d111 1
a111 1
  char* dwarf_str_buffer;
d130 1
a130 1
  struct comp_unit* next_unit;
d133 1
a133 1
  bfd* abfd;
d140 1
a140 1
  char* name;
d143 1
a143 1
  struct abbrev_info** abbrevs;
d149 1
a149 1
  char* comp_dir;
d156 1
a156 1
  char *info_ptr_unit;
d162 1
a162 1
  char *first_child_die_ptr;
d165 1
a165 1
  char *end_ptr;
d168 1
a168 1
  struct line_info_table* line_table;
d171 1
a171 1
  struct funcinfo* function_table;
d214 1
a214 1
read_1_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d220 1
a220 1
read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d226 1
a226 1
read_2_bytes (bfd *abfd, char *buf)
d232 1
a232 1
read_4_bytes (bfd *abfd, char *buf)
d238 1
a238 1
read_8_bytes (bfd *abfd, char *buf)
d243 1
a243 1
static char *
d245 1
a245 1
	      char *buf,
d256 1
a256 1
	     char *buf,
d260 2
a261 1
  if (*buf == '\0')
d267 2
a268 2
  *bytes_read_ptr = strlen (buf) + 1;
  return buf;
d273 1
a273 1
		      char *buf,
d278 1
d320 2
a321 2
  buf = stash->dwarf_str_buffer + offset;
  if (*buf == '\0')
d323 1
a323 1
  return buf;
d329 1
a329 1
read_address (struct comp_unit *unit, char *buf)
d375 1
a375 1
  char *abbrev_ptr;
d482 1
a482 1
static char *
d486 1
a486 1
		      char *info_ptr)
d610 1
a610 1
static char *
d614 1
a614 1
		char *info_ptr)
d630 1
a630 1
  char* filename;
d649 2
a650 2
  char* comp_dir;
  char** dirs;
d659 1
a659 1
  char* name;
d768 1
a768 1
  char* filename;
d781 1
a781 1
      char* dirname = (table->files[file - 1].dir
d851 2
a852 2
  char *line_ptr;
  char *line_end;
d1270 1
a1270 1
  char *info_ptr;
d1311 1
a1311 1
  char *info_ptr = unit->first_child_die_ptr;
d1320 1
a1320 1
      char* name = 0;
d1422 1
a1422 1
		 char *info_ptr_unit,
d1433 2
a1434 2
  char *info_ptr = stash->info_ptr;
  char *end_ptr = info_ptr + unit_length;
d1532 1
a1532 1
	    char* comp_dir = attr.u.str;
d1796 1
a1796 1
      char *info_ptr_unit = stash->info_ptr;
@


1.59
log
@Approved by nickc@@redhat.com:

	2005-01-05  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add info_ptr_unit member.
	(find_abstract_instance_name): New function.
	(scan_unit_for_functions): Handle DW_TAG_inlined_subroutine.
	(scan_unit_for_functions): Handle DW_AT_abstract_origin.
	(_bfd_dwarf2_find_nearest_line): Initialize info_ptr_unit.
@
text
@a86 4
  /* Preserve the original value of info_ptr for the current
     comp_unit so we can find a given entry by its reference. */
  char* info_ptr_unit;

d154 4
a323 61
static unsigned int
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
{
  unsigned int  result;
  unsigned int  num_read;
  int           shift;
  unsigned char byte;

  result   = 0;
  shift    = 0;
  num_read = 0;

  do
    {
      byte = bfd_get_8 (abfd, buf);
      buf ++;
      num_read ++;
      result |= ((byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);

  * bytes_read_ptr = num_read;

  return result;
}

static int
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
{
  int           result;
  int           shift;
  int           num_read;
  unsigned char byte;

  result = 0;
  shift = 0;
  num_read = 0;

  do
    {
      byte = bfd_get_8 (abfd, buf);
      buf ++;
      num_read ++;
      result |= ((byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);

  if ((shift < 32) && (byte & 0x40))
    result |= -(1 << shift);

  * bytes_read_ptr = num_read;

  return result;
}

d1274 1
a1274 1
  info_ptr = unit->stash->info_ptr_unit + die_ref;
d1420 1
d1501 1
a1746 1
      stash->info_ptr_unit = stash->info_ptr;
d1794 1
d1827 2
a1828 1
	  each = parse_comp_unit (abfd, stash, length, offset_size);
@


1.58
log
@bfd/
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Add output section
	vma and output offset to address.
	* simple.c (simple_save_output_info): Only set output section
	and offset for debug sections, or those not already set up by
	the linker.
	(bfd_simple_get_relocated_section_contents): Update comment.
ld/testsuite/
	* ld-elfvsb/elfvsb.exp: Remove file name from "undefined ref" string.
@
text
@d87 4
d1325 36
d1399 2
a1400 1
      if (abbrev->tag == DW_TAG_subprogram)
d1418 4
d1806 1
@


1.57
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1706 1
a1706 1
  struct dwarf2_debug *stash = *pinfo;
d1709 1
a1709 1
  bfd_vma addr = offset + section->vma;
d1713 6
@


1.56
log
@	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Comment correction.
@
text
@d284 1
d295 3
a297 2
      stash->dwarf_str_size = msec->_raw_size;
      stash->dwarf_str_buffer = bfd_alloc (abfd, msec->_raw_size);
d302 1
a302 1
				      0, msec->_raw_size))
d448 1
a448 1
      stash->dwarf_abbrev_size = msec->_raw_size;
d926 1
a926 1
      stash->dwarf_line_size = msec->_raw_size;
d1749 1
a1749 1
	total_size += msec->_raw_size;
d1764 1
a1764 1
	  size = msec->_raw_size;
d1838 1
a1838 1
	      == stash->sec->_raw_size)
@


1.55
log
@	* dwarf2.c (add_line_info): Also set info->filename to NULL if
	filename argument is null; do not call strlen on a null pointer.
@
text
@d1679 1
a1679 1
/* The DWARF2 version of find_nearest line.  Return TRUE if the line
@


1.54
log
@	* bfd-in.h (bfd_int64_t, bfd_uint64_t): New types.
	(BFD_HOST_64_BIT, BFD_HOST_U_64_BIT): Don't define here.
	(bfd_getb64, bfd_getl64, bfd_get_bits): Return bfd_uint64_t.
	(bfd_getb_signed_64, bfd_getl_signed_64): Return bfd_int64_t.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Accept bfd_uint64_t.
	* configure.in (HOST_U_64BIT_TYPE): Set when sizeof long is 8.
	(BFD_HOST_64_BIT_DEFINED, BFD_HOST_64_BIT, BFD_HOST_U_64_BIT): Set
	when using long.
	* libbfd.c (EIGHT_GAZILLION, COERCE64): Use bfd_int64_t.
	(bfd_getb64): Return bfd_uint64_t.  Enable when BFD_HOST_64_BIT.
	(bfd_getl64, bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_putb64): Accept bfd_uint64_t.  Enable when BFD_HOST_64_BIT.
	(bfd_putl64, bfd_put_bits, bfd_get_bits): Likewise.
	* dwarf2.c (struct attribute): Use bfd_int64_t and bfd_uint64_t.
	(read_8_bytes, read_indirect_string, read_address): Likewise.
	(read_abbrevs, parse_comp_unit): Likewise.
	* targets.c (struct bfd_target): Likewise.
	* aix386-core.c (NO_GET64, NO_PUT64, NO_GETS64): Define and use.
	* hppabsd-core.c: Likewise.  Formatting.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d804 1
a804 2
  amt = strlen (filename);
  if (amt)
d806 1
a806 1
      info->filename = bfd_alloc (table->abfd, amt + 1);
@


1.53
log
@	* dwarf2.c: Convert to C90, remove unneeded casts and prototypes.
@
text
@d64 2
a65 2
    bfd_vma val;
    bfd_signed_vma sval;
d233 1
a233 1
static bfd_vma
d271 1
a271 1
  bfd_vma offset;
d381 1
a381 1
static bfd_vma
d425 1
a425 1
read_abbrevs (bfd *abfd, bfd_vma offset, struct dwarf2_debug *stash)
d1439 1
a1439 1
  bfd_vma abbrev_offset = 0;
@


1.53.8.1
log
@Merge mainline to intercu branch.
@
text
@d64 2
a65 2
    bfd_uint64_t val;
    bfd_int64_t sval;
d233 1
a233 1
static bfd_uint64_t
d271 1
a271 1
  bfd_uint64_t offset;
d381 1
a381 1
static bfd_uint64_t
d425 1
a425 1
read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)
d1439 1
a1439 1
  bfd_uint64_t abbrev_offset = 0;
@


1.53.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a283 1
      bfd_size_type sz;
d294 2
a295 3
      sz = msec->rawsize ? msec->rawsize : msec->size;
      stash->dwarf_str_size = sz;
      stash->dwarf_str_buffer = bfd_alloc (abfd, sz);
d300 1
a300 1
				      0, sz))
d446 1
a446 1
      stash->dwarf_abbrev_size = msec->size;
d804 2
a805 1
  if (filename && filename[0])
d807 1
a807 1
      info->filename = bfd_alloc (table->abfd, strlen (filename) + 1);
d925 1
a925 1
      stash->dwarf_line_size = msec->size;
d1680 1
a1680 1
/* The DWARF2 version of find_nearest_line.  Return TRUE if the line
d1748 1
a1748 1
	total_size += msec->size;
d1763 1
a1763 1
	  size = msec->size;
d1837 1
a1837 1
	      == stash->sec->size)
@


1.53.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d64 2
a65 2
    bfd_uint64_t val;
    bfd_int64_t sval;
d233 1
a233 1
static bfd_uint64_t
d271 1
a271 1
  bfd_uint64_t offset;
d381 1
a381 1
static bfd_uint64_t
d425 1
a425 1
read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)
d1439 1
a1439 1
  bfd_uint64_t abbrev_offset = 0;
@


1.53.6.1
log
@	* bfd-in.h (bfd_int64_t, bfd_uint64_t): New types.
	(BFD_HOST_64_BIT, BFD_HOST_U_64_BIT): Don't define here.
	(bfd_getb64, bfd_getl64, bfd_get_bits): Return bfd_uint64_t.
	(bfd_getb_signed_64, bfd_getl_signed_64): Return bfd_int64_t.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Accept bfd_uint64_t.
	* configure.in (HOST_U_64BIT_TYPE): Set when sizeof long is 8.
	(BFD_HOST_64_BIT_DEFINED, BFD_HOST_64_BIT, BFD_HOST_U_64_BIT): Set
	when using long.
	* libbfd.c (EIGHT_GAZILLION, COERCE64): Use bfd_int64_t.
	(bfd_getb64): Return bfd_uint64_t.  Enable when BFD_HOST_64_BIT.
	(bfd_getl64, bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_putb64): Accept bfd_uint64_t.  Enable when BFD_HOST_64_BIT.
	(bfd_putl64, bfd_put_bits, bfd_get_bits): Likewise.
	* dwarf2.c (struct attribute): Use bfd_int64_t and bfd_uint64_t.
	(read_8_bytes, read_indirect_string, read_address): Likewise.
	(read_abbrevs, parse_comp_unit): Likewise.
	* targets.c (struct bfd_target): Likewise.
	* aix386-core.c (NO_GET64, NO_PUT64, NO_GETS64): Define and use.
	* hppabsd-core.c: Likewise.  Formatting.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d64 2
a65 2
    bfd_uint64_t val;
    bfd_int64_t sval;
d233 1
a233 1
static bfd_uint64_t
d271 1
a271 1
  bfd_uint64_t offset;
d381 1
a381 1
static bfd_uint64_t
d425 1
a425 1
read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)
d1439 1
a1439 1
  bfd_uint64_t abbrev_offset = 0;
@


1.53.6.2
log
@	* dwarf2.c (add_line_info): Also set info->filename to NULL if
	filename argument is null; do not call strlen on a null pointer.
@
text
@d804 2
a805 1
  if (filename && filename[0])
d807 1
a807 1
      info->filename = bfd_alloc (table->abfd, strlen (filename) + 1);
@


1.52
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a202 45
static unsigned int read_1_byte PARAMS ((bfd *, char *));
static int read_1_signed_byte PARAMS ((bfd *, char *));
static unsigned int read_2_bytes PARAMS ((bfd *, char *));
static unsigned int read_4_bytes PARAMS ((bfd *, char *));
static bfd_vma read_8_bytes PARAMS ((bfd *, char *));
static char *read_n_bytes PARAMS ((bfd *, char *, unsigned int));
static char *read_string PARAMS ((bfd *, char *, unsigned int *));
static char *read_indirect_string PARAMS ((struct comp_unit *, char *, unsigned int *));
static unsigned int read_unsigned_leb128
  PARAMS ((bfd *, char *, unsigned int *));
static int read_signed_leb128
  PARAMS ((bfd *, char *, unsigned int *));
static bfd_vma read_address PARAMS ((struct comp_unit *, char *));
static struct abbrev_info *lookup_abbrev
  PARAMS ((unsigned int, struct abbrev_info **));
static struct abbrev_info **read_abbrevs
  PARAMS ((bfd *, bfd_vma, struct dwarf2_debug *));
static char *read_attribute
  PARAMS ((struct attribute *, struct attr_abbrev *,
	   struct comp_unit *, char *));
static char *read_attribute_value
  PARAMS ((struct attribute *, unsigned,
	   struct comp_unit *, char *));
static void add_line_info
  PARAMS ((struct line_info_table *, bfd_vma, char *,
	   unsigned int, unsigned int, int));
static char *concat_filename PARAMS ((struct line_info_table *, unsigned int));
static void arange_add PARAMS ((struct comp_unit *, bfd_vma, bfd_vma));
static struct line_info_table *decode_line_info
  PARAMS ((struct comp_unit *, struct dwarf2_debug *));
static bfd_boolean lookup_address_in_line_info_table
  PARAMS ((struct line_info_table *, bfd_vma, struct funcinfo *,
	   const char **, unsigned int *));
static bfd_boolean lookup_address_in_function_table
  PARAMS ((struct funcinfo *, bfd_vma, struct funcinfo **, const char **));
static bfd_boolean scan_unit_for_functions PARAMS ((struct comp_unit *));
static struct comp_unit *parse_comp_unit
  PARAMS ((bfd *, struct dwarf2_debug *, bfd_vma, unsigned int));
static bfd_boolean comp_unit_contains_address
  PARAMS ((struct comp_unit *, bfd_vma));
static bfd_boolean comp_unit_find_nearest_line
  PARAMS ((struct comp_unit *, bfd_vma, const char **, const char **,
	   unsigned int *, struct dwarf2_debug *));
static asection *find_debug_info PARAMS ((bfd *, asection *));

d210 1
a210 3
read_1_byte (abfd, buf)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
d212 1
a212 1
  return bfd_get_8 (abfd, (bfd_byte *) buf);
d216 1
a216 3
read_1_signed_byte (abfd, buf)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
d218 1
a218 1
  return bfd_get_signed_8 (abfd, (bfd_byte *) buf);
d222 1
a222 13
read_2_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
{
  return bfd_get_16 (abfd, (bfd_byte *) buf);
}

#if 0  /* This is not used.  */

static int
read_2_signed_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d224 1
a224 1
  return bfd_get_signed_16 (abfd, (bfd_byte *) buf);
a226 2
#endif

d228 1
a228 3
read_4_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d230 1
a230 1
  return bfd_get_32 (abfd, (bfd_byte *) buf);
a232 12
#if 0  /* This is not used.  */

static int
read_4_signed_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
{
  return bfd_get_signed_32 (abfd, (bfd_byte *) buf);
}

#endif

d234 1
a234 3
read_8_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d236 1
a236 1
  return bfd_get_64 (abfd, (bfd_byte *) buf);
d240 3
a242 4
read_n_bytes (abfd, buf, size)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int size ATTRIBUTE_UNUSED;
d251 3
a253 4
read_string (abfd, buf, bytes_read_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int *bytes_read_ptr;
d267 3
a269 4
read_indirect_string (unit, buf, bytes_read_ptr)
     struct comp_unit* unit;
     char *buf;
     unsigned int *bytes_read_ptr;
d295 1
a295 1
      stash->dwarf_str_buffer = (char*) bfd_alloc (abfd, msec->_raw_size);
d300 1
a300 1
				      (bfd_vma) 0, msec->_raw_size))
d319 3
a321 4
read_unsigned_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int *bytes_read_ptr;
d334 1
a334 1
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
d348 3
a350 4
read_signed_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     unsigned int * bytes_read_ptr;
d363 1
a363 1
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
d382 1
a382 3
read_address (unit, buf)
     struct comp_unit* unit;
     char *buf;
d387 1
a387 1
      return bfd_get_64 (unit->abfd, (bfd_byte *) buf);
d389 1
a389 1
      return bfd_get_32 (unit->abfd, (bfd_byte *) buf);
d391 1
a391 1
      return bfd_get_16 (unit->abfd, (bfd_byte *) buf);
d400 1
a400 3
lookup_abbrev (number,abbrevs)
     unsigned int number;
     struct abbrev_info **abbrevs;
d425 1
a425 4
read_abbrevs (abfd, offset, stash)
     bfd * abfd;
     bfd_vma offset;
     struct dwarf2_debug *stash;
d463 1
a463 1
  abbrevs = (struct abbrev_info**) bfd_zalloc (abfd, amt);
d473 1
a473 1
      cur_abbrev = (struct abbrev_info *) bfd_zalloc (abfd, amt);
d495 1
a495 2
	      cur_abbrev->attrs = ((struct attr_abbrev *)
				   bfd_realloc (cur_abbrev->attrs, amt));
d536 4
a539 5
read_attribute_value (attr, form, unit, info_ptr)
     struct attribute   *attr;
     unsigned form;
     struct comp_unit   *unit;
     char               *info_ptr;
d558 1
a558 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d567 1
a567 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d596 1
a596 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d605 1
a605 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);
d664 4
a667 5
read_attribute (attr, abbrev, unit, info_ptr)
     struct attribute   *attr;
     struct attr_abbrev *abbrev;
     struct comp_unit   *unit;
     char               *info_ptr;
d723 6
a728 7
add_line_info (table, address, filename, line, column, end_sequence)
     struct line_info_table* table;
     bfd_vma address;
     char* filename;
     unsigned int line;
     unsigned int column;
     int end_sequence;
d731 1
a731 1
  struct line_info* info = (struct line_info*) bfd_alloc (table->abfd, amt);
d820 1
a820 3
concat_filename (table, file)
     struct line_info_table* table;
     unsigned int file;
d857 1
a857 4
arange_add (unit, low_pc, high_pc)
     struct comp_unit *unit;
     bfd_vma low_pc;
     bfd_vma high_pc;
d890 1
a890 2
  arange = (struct arange *)
    bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
d901 1
a901 3
decode_line_info (unit, stash)
     struct comp_unit *unit;
     struct dwarf2_debug *stash;
d944 1
a944 1
  table = (struct line_info_table*) bfd_alloc (abfd, amt);
d996 1
a996 1
  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
d1015 1
a1015 1
	  table->dirs = (char **) bfd_realloc (table->dirs, amt);
d1034 1
a1034 1
	  table->files = (struct fileinfo *) bfd_realloc (table->files, amt);
d1125 1
a1125 2
		      table->files =
			(struct fileinfo *) bfd_realloc (table->files, amt);
d1221 5
a1225 7
lookup_address_in_line_info_table (table, addr, function, filename_ptr,
				   linenumber_ptr)
     struct line_info_table* table;
     bfd_vma addr;
     struct funcinfo *function;
     const char **filename_ptr;
     unsigned int *linenumber_ptr;
d1298 4
a1301 6
lookup_address_in_function_table (table, addr, function_ptr,
				  functionname_ptr)
     struct funcinfo* table;
     bfd_vma addr;
     struct funcinfo** function_ptr;
     const char **functionname_ptr;
d1326 1
a1326 2
scan_unit_for_functions (unit)
     struct comp_unit *unit;
d1361 1
a1361 1
	  func = (struct funcinfo *) bfd_zalloc (abfd, amt);
d1432 4
a1435 5
parse_comp_unit (abfd, stash, unit_length, offset_size)
     bfd* abfd;
     struct dwarf2_debug *stash;
     bfd_vma unit_length;
     unsigned int offset_size;
d1508 1
a1508 1
  unit = (struct comp_unit*) bfd_zalloc (abfd, amt);
d1548 1
a1548 1
		char *cp = (char*) strchr (comp_dir, ':');
d1569 1
a1569 3
comp_unit_contains_address (unit, addr)
     struct comp_unit* unit;
     bfd_vma addr;
d1597 6
a1602 8
comp_unit_find_nearest_line (unit, addr, filename_ptr, functionname_ptr,
			     linenumber_ptr, stash)
     struct comp_unit* unit;
     bfd_vma addr;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *linenumber_ptr;
     struct dwarf2_debug *stash;
d1657 1
a1657 3
find_debug_info (abfd, after_sec)
     bfd * abfd;
     asection * after_sec;
d1687 9
a1695 12
_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
			       filename_ptr, functionname_ptr,
			       linenumber_ptr, addr_size, pinfo)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *linenumber_ptr;
     unsigned int addr_size;
     PTR *pinfo;
d1705 1
a1705 1
  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;
d1729 1
a1729 1
      stash = (struct dwarf2_debug*) bfd_zalloc (abfd, amt);
d1733 1
a1733 1
      *pinfo = (PTR) stash;
d1750 1
a1750 1
      stash->info_ptr = (char *) bfd_alloc (abfd, total_size);
@


1.51
log
@	* dwarf2.c (struct attribute): Delete "unsnd", "snd" and "addr".
	Add "val" and "sval" fields.
	(DW_STRING, DW_UNSND, DW_BLOCK, DW_SND, DW_ADDR): Delete.
	(read_attribute_value): Expand and adjust DW_* occurrences.
	(scan_unit_for_functions, parse_comp_unit): Likewise.
@
text
@d1533 1
a1533 1
   does not include the length field that preceeds each compilation
@


1.50
log
@	* dwarf2.c (decode_line_info): Cope with an initially empty
	filename table.
@
text
@d64 2
a65 3
    unsigned int unsnd;
    int snd;
    bfd_vma addr;
a69 8
/* Get at parts of an attribute structure.  */

#define DW_STRING(attr)    ((attr)->u.str)
#define DW_UNSND(attr)     ((attr)->u.unsnd)
#define DW_BLOCK(attr)     ((attr)->u.blk)
#define DW_SND(attr)       ((attr)->u.snd)
#define DW_ADDR(attr)	   ((attr)->u.addr)

d646 1
a646 1
      DW_ADDR (attr) = read_address (unit, info_ptr);
d656 1
a656 1
      DW_BLOCK (attr) = blk;
d665 1
a665 1
      DW_BLOCK (attr) = blk;
d668 1
a668 1
      DW_UNSND (attr) = read_2_bytes (abfd, info_ptr);
d672 1
a672 1
      DW_UNSND (attr) = read_4_bytes (abfd, info_ptr);
d676 1
a676 1
      DW_UNSND (attr) = read_8_bytes (abfd, info_ptr);
d680 1
a680 1
      DW_STRING (attr) = read_string (abfd, info_ptr, &bytes_read);
d684 1
a684 1
      DW_STRING (attr) = read_indirect_string (unit, info_ptr, &bytes_read);
d694 1
a694 1
      DW_BLOCK (attr) = blk;
d703 1
a703 1
      DW_BLOCK (attr) = blk;
d706 1
a706 1
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
d710 1
a710 1
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
d714 1
a714 1
      DW_SND (attr) = read_signed_leb128 (abfd, info_ptr, &bytes_read);
d718 1
a718 1
      DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d722 1
a722 1
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
d726 1
a726 1
      DW_UNSND (attr) = read_2_bytes (abfd, info_ptr);
d730 1
a730 1
      DW_UNSND (attr) = read_4_bytes (abfd, info_ptr);
d734 1
a734 1
      DW_UNSND (attr) = read_8_bytes (abfd, info_ptr);
d738 1
a738 1
      DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d1487 1
a1487 1
		  name = DW_STRING (&attr);
d1491 1
a1491 1
		    func->name = DW_STRING (&attr);
d1495 1
a1495 1
		  func->name = DW_STRING (&attr);
d1499 1
a1499 1
		  func->low = DW_ADDR (&attr);
d1503 1
a1503 1
		  func->high = DW_ADDR (&attr);
d1515 1
a1515 1
		  name = DW_STRING (&attr);
d1636 1
a1636 1
	  unit->line_offset = DW_UNSND (&attr);
d1640 1
a1640 1
	  unit->name = DW_STRING (&attr);
d1644 1
a1644 1
	  unit->arange.low = DW_ADDR (&attr);
d1648 1
a1648 1
	  unit->arange.high = DW_ADDR (&attr);
d1653 1
a1653 1
	    char* comp_dir = DW_STRING (&attr);
@


1.49
log
@* dwarf2.c (_bfd_dwarf2_find_nearest_line): Fix typo in
2003-04-09's change.
@
text
@d1171 1
a1171 1
      char * filename = concat_filename (table, 1);
@


1.48
log
@* dwarf2.c (_bfd_dwarf2_find_nearest_line): Try DWARF3-standard
and IRIX-specific shift-to-64-bit 4-byte lengths before following
addr_size.
@
text
@d1954 1
a1954 1
	  stash->info_ptr = 8;
@


1.47
log
@	* dwarf2.c (read_attribute_value): Correct typo in comment.
@
text
@d1930 4
a1933 1
      if (addr_size == 4)
d1935 20
a1954 14
	  length = read_4_bytes (abfd, stash->info_ptr);
	  if (length == 0xffffffff)
	    {
	      offset_size = 8;
	      length = read_8_bytes (abfd, stash->info_ptr + 4);
	      stash->info_ptr += 8;
	    }
	  else if (length == 0)
	    {
	      /* Handle (non-standard) 64-bit DWARF2 formats.  */
	      offset_size = 8;
	      length = read_4_bytes (abfd, stash->info_ptr + 4);
	      stash->info_ptr += 4;
	    }
d1957 1
a1957 2
	length = read_8_bytes (abfd, stash->info_ptr);
      stash->info_ptr += addr_size;
@


1.47.2.1
log
@Merge with mainline.
@
text
@d1930 1
a1930 4
      length = read_4_bytes (abfd, stash->info_ptr);
      /* A 0xffffff length is the DWARF3 way of indicating we use
	 64-bit offsets, instead of 32-bit offsets.  */
      if (length == 0xffffffff)
d1932 14
a1945 20
	  offset_size = 8;
	  length = read_8_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 12;
	}
      /* A zero length is the IRIX way of indicating 64-bit offsets,
	 mostly because the 64-bit length will generally fit in 32
	 bits, and the endianness helps.  */
      else if (length == 0)
	{
	  offset_size = 8;
	  length = read_4_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 8;
	}
      /* In the absence of the hints above, we assume addr_size-sized
	 offsets, for backward-compatibility with pre-DWARF3 64-bit
	 platforms.  */
      else if (addr_size == 8)
	{
	  length = read_8_bytes (abfd, stash->info_ptr);
	  stash->info_ptr = 8;
d1948 2
a1949 1
	stash->info_ptr += 4;
@


1.46
log
@Make add_line_info() take a copy of the filename.
@
text
@d653 1
a653 1
      /* FIXME: DWARF3 draft sais DW_FORM_ref_addr is offset_size.  */
@


1.45
log
@Remove use of concat() inside concat_filename()
@
text
@a903 1
  info->filename = filename;
d907 10
@


1.44
log
@	* simple.c (bfd_simple_get_relocated_section_contents): Add
	parameter symbol_table.  Optionally use it instead of the symbol
	table from the bfd.  Save and restore output offsets and output
	sections  around bfd_get_relocated_section_contents.  Fix a memory
	leak.
	(simple_save_output_info, simple_restore_output_info): New
	functions.
	* bfd-in2.h: Regenerate.
	* dwarf2.c (read_abbrevs): Use
	bfd_simple_get_relocated_section_contents instead of
	bfd_get_section_contents.
	(decode_line_info): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.  Don't call
	find_rela_addend.
	(find_rela_addend): Remove.
	* elfxx-ia64.c (elfNN_ia64_reloc): Weaken sanity check for
	debugging sections.
	(elfNN_ia64_hash_table_create): Create the hash table with malloc,
	not bfd_zalloc.
@
text
@d820 5
a824 5
/* add_line_info: adds a new entry to the line_info list in the
   line_info_table, ensuring that the list is sorted.  Note that the
   line_info list is sorted from highest to lowest VMA (with possible
   duplicates); that is, line_info->prev_line always accesses an equal
   or smaller VMA.  */
d911 2
a912 1
   The returned string has been xmalloc'ed.  */
d925 1
a925 1
      return concat ("<unknown>");
d930 1
a930 3
  if (IS_ABSOLUTE_PATH (filename))
    return concat (filename);
  else
d936 12
a947 6
      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.  The
	 best we can do is return the filename part.  */
      if (dirname == NULL)
	return concat (filename);
      else
	return concat (dirname, "/", filename, NULL);
d949 2
d1276 2
a1277 1
		free (filename);
d1313 2
a1314 1
      free (filename);
@


1.43
log
@Fix memory leaks
@
text
@a247 2
static bfd_vma find_rela_addend
  PARAMS ((bfd *, asection *, bfd_size_type, asymbol**));
d547 3
a549 1
      stash->dwarf_abbrev_buffer = (char*) bfd_alloc (abfd, msec->_raw_size);
a551 4

      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_abbrev_buffer,
				      (bfd_vma) 0, msec->_raw_size))
	return 0;
d1022 3
a1024 1
      stash->dwarf_line_buffer = (char *) bfd_alloc (abfd, msec->_raw_size);
a1026 7

      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_line_buffer,
				      (bfd_vma) 0, msec->_raw_size))
	return 0;

      /* FIXME: We ought to apply the relocs against this section before
	 we process it...  */
d1029 2
a1030 3
  /* Since we are using un-relocated data, it is possible to get a bad value
     for the line_offset.  Validate it here so that we won't get a segfault
     below.  */
a1521 54
/* Look for a RELA relocation to be applied on OFFSET of section SEC,
   and return the addend if such a relocation is found.  Since this is
   only used to find relocations referring to the .debug_abbrev
   section, we make sure the relocation refers to this section, but
   this is not strictly necessary, and it can probably be safely
   removed if needed.  However, it is important to note that this
   function only returns the addend, it doesn't serve the purpose of
   applying a generic relocation.

   If no suitable relocation is found, or if it is not a real RELA
   relocation, this function returns 0.  */

static bfd_vma
find_rela_addend (abfd, sec, offset, syms)
     bfd* abfd;
     asection* sec;
     bfd_size_type offset;
     asymbol** syms;
{
  long reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
  arelent **relocs = NULL;
  long reloc_count, relc;

  if (reloc_size <= 0)
    return 0;

  relocs = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
  if (relocs == NULL)
    return 0;

  reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, syms);

  if (reloc_count <= 0)
    {
      free (relocs);
      return 0;
    }

  for (relc = 0; relc < reloc_count; relc++)
    if (relocs[relc]->address == offset
	&& (*relocs[relc]->sym_ptr_ptr)->flags & BSF_SECTION_SYM
	&& strcmp ((*relocs[relc]->sym_ptr_ptr)->name,
		   ".debug_abbrev") == 0)
      {
	bfd_vma addend = (relocs[relc]->howto->partial_inplace
			  ? 0 : relocs[relc]->addend);
	free (relocs);
	return addend;
      }

  free (relocs);
  return 0;
}

a1548 1
  bfd_size_type off;
a1556 6
  /* The abbrev offset is generally a relocation pointing to
     .debug_abbrev+offset.  On RELA targets, we have to find the
     relocation and extract the addend to obtain the actual
     abbrev_offset, so do it here.  */
  off = info_ptr - stash->sec_info_ptr;
  abbrev_offset += find_rela_addend (abfd, stash->sec, off, stash->syms);
d1879 2
a1880 2
	  if (! bfd_get_section_contents (abfd, msec, stash->info_ptr + start,
					  (bfd_vma) 0, size))
a1892 15
  /* FIXME: There is a problem with the contents of the
     .debug_info section.  The 'low' and 'high' addresses of the
     comp_units are computed by relocs against symbols in the
     .text segment.  We need these addresses in order to determine
     the nearest line number, and so we have to resolve the
     relocs.  There is a similar problem when the .debug_line
     section is processed as well (e.g., there may be relocs
     against the operand of the DW_LNE_set_address operator).

     Unfortunately getting hold of the reloc information is hard...

     For now, this means that disassembling object files (as
     opposed to fully executables) does not always work as well as
     we would like.  */

d1959 4
a1962 4
						       filename_ptr,
						       functionname_ptr,
						       linenumber_ptr,
						       stash);
@


1.42
log
@Comment typo fixes.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d914 3
d928 1
a928 1
      return "<unknown>";
d932 3
a934 2
  if (IS_ABSOLUTE_PATH(filename))
    return filename;
d944 1
a944 1
	return filename;
d946 1
a946 1
	return (char*) concat (dirname, "/", filename, NULL);
d1279 1
d1304 1
d1314 2
@


1.41
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1759 1
a1759 1
   Return TRUE of UNIT contains ADDR, and no errors were encountered;
@


1.40
log
@	* dwarf2.c: Revert last change.
@
text
@d160 1
a160 1
  /* True if there is a line number table associated with this comp. unit.  */
d242 1
a242 1
static boolean lookup_address_in_line_info_table
d245 1
a245 1
static boolean lookup_address_in_function_table
d247 1
a247 1
static boolean scan_unit_for_functions PARAMS ((struct comp_unit *));
d252 1
a252 1
static boolean comp_unit_contains_address
d254 1
a254 1
static boolean comp_unit_find_nearest_line
d1313 2
a1314 2
/* If ADDR is within TABLE set the output parameters and return true,
   otherwise return false.  The output parameters, FILENAME_PTR and
d1317 1
a1317 1
static boolean
d1332 1
a1332 1
    return false;
d1346 1
a1346 1
      boolean addr_match = false;
d1349 1
a1349 1
	  addr_match = true;
d1370 1
a1370 1
	return true; /* we have definitely found what we want */
d1386 1
a1386 1
      return true;
d1389 1
a1389 1
  return false;
d1394 1
a1394 1
/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return true.  */
d1396 1
a1396 1
static boolean
d1414 1
a1414 1
	  return true;
d1418 1
a1418 1
  return false;
d1426 1
a1426 1
static boolean
d1457 1
a1457 1
	  return false;
d1521 1
a1521 1
  return true;
d1730 1
a1730 1
/* Return true if UNIT contains the address given by ADDR.  */
d1732 1
a1732 1
static boolean
d1740 1
a1740 1
    return false;
d1746 1
a1746 1
	return true;
d1751 1
a1751 1
  return false;
d1759 2
a1760 2
   Return true of UNIT contains ADDR, and no errors were encountered;
   false otherwise.  */
d1762 1
a1762 1
static boolean
d1772 2
a1773 2
  boolean line_p;
  boolean func_p;
d1777 1
a1777 1
    return false;
d1784 1
a1784 1
	  return false;
d1792 1
a1792 1
	  return false;
d1799 1
a1799 1
	  return false;
d1809 1
a1809 1
  return (boolean) (line_p || func_p);
d1850 1
a1850 1
/* The DWARF2 version of find_nearest line.  Return true if the line
d1856 1
a1856 1
boolean
d1904 1
a1904 1
	return false;
d1913 1
a1913 1
	 return false;
d1925 1
a1925 1
	return false;
d1974 1
a1974 1
    return false;
d1987 1
a1987 1
      boolean found;
d2050 1
a2050 1
		    return true;
d2056 1
a2056 1
  return false;
@


1.39
log
@Use bfd_simple_get_relocated_section_contents() instead of bfd_get_section_contents().
@
text
@d392 2
a393 2
      if (! bfd_simple_get_relocated_section_contents 
	  (abfd, msec, stash->dwarf_str_buffer))
d553 2
a554 2
      if (! bfd_simple_get_relocated_section_contents
	  (abfd, msec, stash->dwarf_abbrev_buffer))
d1026 2
a1027 2
      if (! bfd_simple_get_relocated_section_contents
	  (abfd, msec, stash->dwarf_line_buffer))
d1942 2
a1943 2
	  if (! bfd_simple_get_relocated_section_contents
	      (abfd, msec, stash->info_ptr + start))
@


1.38
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d392 2
a393 2
      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_str_buffer,
				      (bfd_vma) 0, msec->_raw_size))
d553 2
a554 2
      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_abbrev_buffer,
				      (bfd_vma) 0, msec->_raw_size))
d1026 2
a1027 2
      if (! bfd_get_section_contents (abfd, msec, stash->dwarf_line_buffer,
				      (bfd_vma) 0, msec->_raw_size))
d1942 2
a1943 2
	  if (! bfd_get_section_contents (abfd, msec, stash->info_ptr + start,
					  (bfd_vma) 0, size))
@


1.37
log
@	* dwarf2.c (add_line_info): Ensure that the line_info_table is
	sorted even when given an out-of-order line sequence.
	(lookup_address_in_line_info_table): When an exact VMA match is
	not found, return line information with the closest VMA.
@
text
@d581 2
a582 1
      cur_abbrev->tag = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
d605 4
a608 2
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name = abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form = abbrev_form;
d652 1
a652 1
  attr->form = form;
d983 2
a984 1
  arange = bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
d1740 1
a1740 1
    return 0;
d1746 1
a1746 1
	return 1;
d1751 1
a1751 1
  return 0;
d1809 1
a1809 1
  return line_p || func_p;
@


1.36
log
@Fix typo introduced with previous delta.
@
text
@d405 1
a405 1
  buf = stash->dwarf_str_buffer + offset;  
d617 1
a617 1
         Under Irix6 the abbreviations for a compilation unit are not
d809 2
a810 1
  struct line_info* last_line;
d821 5
d838 53
a890 2
  info->prev_line = table->last_line;
  table->last_line = info;
d892 12
d1054 1
d1164 4
a1167 4
         compilers generate address sequences that are wildly out of
         order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
         for ia64-Linux).  Thus, to determine the low and high
         address, we must compare on every DW_LNS_copy, etc.  */
d1322 1
d1324 2
a1325 1
  struct line_info* each_line;
d1332 5
d1339 5
a1343 2
      if (!each_line->end_sequence
	  && addr >= each_line->address && addr < next_line->address)
d1345 2
a1362 1
	  return true;
d1364 4
d1372 7
a1378 4
  /* At this point each_line is NULL but next_line is not.  If we found the
     containing function in this compilation unit, return the first line we
     have a number for.  This is also for compatibility with GCC 2.95.  */
  if (function != NULL)
d1792 1
a1792 1
          && ! scan_unit_for_functions (unit))
d1912 1
a1912 1
         Read them all in and produce one large stash.  We do this in two
d2008 1
a2008 1
        {
@


1.36.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d405 1
a405 1
  buf = stash->dwarf_str_buffer + offset;
d617 1
a617 1
	 Under Irix6 the abbreviations for a compilation unit are not
d809 1
a809 2
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
a819 5
/* add_line_info: adds a new entry to the line_info list in the
   line_info_table, ensuring that the list is sorted.  Note that the
   line_info list is sorted from highest to lowest VMA (with possible
   duplicates); that is, line_info->prev_line always accesses an equal
   or smaller VMA.  */
d832 2
a833 53
  /* Find the correct location for 'info'.  Normally we will receive
     new line_info data 1) in order and 2) with increasing VMAs.
     However some compilers break the rules (cf. decode_line_info) and
     so we include some heuristics for quickly finding the correct
     location for 'info'. In particular, these heuristics optimize for
     the common case in which the VMA sequence that we receive is a
     list of locally sorted VMAs such as
       p...z a...j  (where a < j < p < z)

     Note: table->lcl_head is used to head an *actual* or *possible*
     sequence within the list (such as a...j) that is not directly
     headed by table->last_line

     Note: we may receive duplicate entries from 'decode_line_info'.  */

  while (1)
    if (!table->last_line
	|| address >= table->last_line->address)
      {
	/* Normal case: add 'info' to the beginning of the list */
	info->prev_line = table->last_line;
	table->last_line = info;

	/* lcl_head: initialize to head a *possible* sequence at the end.  */
	if (!table->lcl_head)
	  table->lcl_head = info;
	break;
      }
    else if (!table->lcl_head->prev_line
	     && table->lcl_head->address > address)
      {
	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = NULL;
	table->lcl_head->prev_line = info;
	break;
      }
    else if (table->lcl_head->prev_line
	     && table->lcl_head->address > address
	     && address >= table->lcl_head->prev_line->address)
      {
	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = table->lcl_head->prev_line;
	table->lcl_head->prev_line = info;
	break;
      }
    else
      {
	/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
	struct line_info* li2 = table->last_line; /* always non-NULL */
	struct line_info* li1 = li2->prev_line;
a834 12
	while (li1)
	  {
	    if (li2->address > address && address >= li1->address)
	      break;

	    li2 = li1; /* always non-NULL */
	    li1 = li1->prev_line;
	  }
	table->lcl_head = li2;
      }

  /* Set member data of 'info'.  */
a984 1
  table->lcl_head = NULL;
d1094 4
a1097 4
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
a1251 1
  /* Note: table->last_line should be a descendingly sorted list. */
d1253 1
a1253 2
  struct line_info* each_line = NULL;
  *filename_ptr = NULL;
a1259 5
  /* Check for large addresses */
  if (addr > next_line->address)
    each_line = NULL; /* ensure we skip over the normal case */

  /* Normal case: search the list; save  */
d1262 2
a1263 5
      /* If we have an address match, save this info.  This allows us
	 to return as good as results as possible for strange debugging
	 info.  */
      boolean addr_match = false;
      if (each_line->address <= addr && addr <= next_line->address)
a1264 2
	  addr_match = true;

d1281 1
a1282 4

      if (addr_match && !each_line->end_sequence)
	return true; /* we have definitely found what we want */

d1287 4
a1290 7
  /* At this point each_line is NULL but next_line is not.  If we found
     a candidate end-of-sequence point in the loop above, we can return
     that (compatibility with a bug in the Intel compiler); otherwise,
     assuming that we found the containing function for this address in
     this compilation unit, return the first line we have a number for
     (compatibility with GCC 2.95).  */
  if (*filename_ptr == NULL && function != NULL)
d1704 1
a1704 1
	  && ! scan_unit_for_functions (unit))
d1824 1
a1824 1
	 Read them all in and produce one large stash.  We do this in two
d1920 1
a1920 1
	{
@


1.36.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d64 3
a66 2
    bfd_vma val;
    bfd_signed_vma sval;
d71 8
d160 1
a160 1
  /* TRUE if there is a line number table associated with this comp. unit.  */
d242 1
a242 1
static bfd_boolean lookup_address_in_line_info_table
d245 1
a245 1
static bfd_boolean lookup_address_in_function_table
d247 3
a249 1
static bfd_boolean scan_unit_for_functions PARAMS ((struct comp_unit *));
d252 1
a252 1
static bfd_boolean comp_unit_contains_address
d254 1
a254 1
static bfd_boolean comp_unit_find_nearest_line
d549 1
a549 3
      stash->dwarf_abbrev_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
d552 4
d581 1
a581 2
      cur_abbrev->tag = (enum dwarf_tag)
	read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
d604 2
a605 4
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name
	    = (enum dwarf_attribute) abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form
	    = (enum dwarf_form) abbrev_form;
d649 1
a649 1
  attr->form = (enum dwarf_form) form;
d654 1
a654 1
      /* FIXME: DWARF3 draft says DW_FORM_ref_addr is offset_size.  */
d656 1
a656 1
      attr->u.val = read_address (unit, info_ptr);
d666 1
a666 1
      attr->u.blk = blk;
d675 1
a675 1
      attr->u.blk = blk;
d678 1
a678 1
      attr->u.val = read_2_bytes (abfd, info_ptr);
d682 1
a682 1
      attr->u.val = read_4_bytes (abfd, info_ptr);
d686 1
a686 1
      attr->u.val = read_8_bytes (abfd, info_ptr);
d690 1
a690 1
      attr->u.str = read_string (abfd, info_ptr, &bytes_read);
d694 1
a694 1
      attr->u.str = read_indirect_string (unit, info_ptr, &bytes_read);
d704 1
a704 1
      attr->u.blk = blk;
d713 1
a713 1
      attr->u.blk = blk;
d716 1
a716 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d720 1
a720 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d724 1
a724 1
      attr->u.sval = read_signed_leb128 (abfd, info_ptr, &bytes_read);
d728 1
a728 1
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d732 1
a732 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d736 1
a736 1
      attr->u.val = read_2_bytes (abfd, info_ptr);
d740 1
a740 1
      attr->u.val = read_4_bytes (abfd, info_ptr);
d744 1
a744 1
      attr->u.val = read_8_bytes (abfd, info_ptr);
d748 1
a748 1
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d821 5
a825 5
/* Adds a new entry to the line_info list in the line_info_table, ensuring
   that the list is sorted.  Note that the line_info list is sorted from
   highest to lowest VMA (with possible duplicates); that is,
   line_info->prev_line always accesses an equal or smaller VMA.  */

d905 1
a908 10

  amt = strlen (filename);
  if (amt)
    {
      info->filename = bfd_alloc (table->abfd, amt + 1);
      if (info->filename)
	strcpy (info->filename, filename);
    }
  else
    info->filename = NULL;
a910 4
/* Extract a fully qualified filename from a line info table.
   The returned string has been malloc'ed and it is the caller's
   responsibility to free it.  */

d922 1
a922 1
      return strdup ("<unknown>");
d926 3
a928 2

  if (! IS_ABSOLUTE_PATH (filename))
d934 6
a939 12
      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.
	 The best we can do is return the filename part.  */
      if (dirname != NULL)
	{
	  unsigned int len = strlen (dirname) + strlen (filename) + 2;
	  char * name;

	  name = bfd_malloc (len);
	  if (name)
	    sprintf (name, "%s/%s", dirname, filename);
	  return name;
	}
a940 2

  return strdup (filename);
d980 1
a980 2
  arange = (struct arange *)
    bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
d1018 1
a1018 3
      stash->dwarf_line_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
d1021 7
d1030 3
a1032 2
  /* It is possible to get a bad value for the line_offset.  Validate
     it here so that we won't get a segfault below.  */
d1157 1
a1157 1
      char * filename = table->num_files ? concat_filename (table, 1) : NULL;
a1270 2
		if (filename)
		  free (filename);
a1294 1

a1303 3

      if (filename)
	free (filename);
d1309 2
a1310 2
/* If ADDR is within TABLE set the output parameters and return TRUE,
   otherwise return FALSE.  The output parameters, FILENAME_PTR and
d1313 1
a1313 1
static bfd_boolean
d1328 1
a1328 1
    return FALSE;
d1342 1
a1342 1
      bfd_boolean addr_match = FALSE;
d1345 1
a1345 1
	  addr_match = TRUE;
d1366 1
a1366 1
	return TRUE; /* we have definitely found what we want */
d1382 1
a1382 1
      return TRUE;
d1385 1
a1385 1
  return FALSE;
d1390 1
a1390 1
/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.  */
d1392 1
a1392 1
static bfd_boolean
d1410 1
a1410 1
	  return TRUE;
d1414 1
a1414 1
  return FALSE;
d1422 1
a1422 1
static bfd_boolean
d1453 1
a1453 1
	  return FALSE;
d1476 1
a1476 1
		  name = attr.u.str;
d1480 1
a1480 1
		    func->name = attr.u.str;
d1484 1
a1484 1
		  func->name = attr.u.str;
d1488 1
a1488 1
		  func->low = attr.u.val;
d1492 1
a1492 1
		  func->high = attr.u.val;
d1504 1
a1504 1
		  name = attr.u.str;
d1517 55
a1571 1
  return TRUE;
d1576 1
a1576 1
   does not include the length field that precedes each compilation
d1601 1
d1610 6
d1686 1
a1686 1
	  unit->line_offset = attr.u.val;
d1690 1
a1690 1
	  unit->name = attr.u.str;
d1694 1
a1694 1
	  unit->arange.low = attr.u.val;
d1698 1
a1698 1
	  unit->arange.high = attr.u.val;
d1703 1
a1703 1
	    char* comp_dir = attr.u.str;
d1726 1
a1726 1
/* Return TRUE if UNIT contains the address given by ADDR.  */
d1728 1
a1728 1
static bfd_boolean
d1736 1
a1736 1
    return FALSE;
d1742 1
a1742 1
	return TRUE;
d1747 1
a1747 1
  return FALSE;
d1755 2
a1756 2
   Return TRUE if UNIT contains ADDR, and no errors were encountered;
   FALSE otherwise.  */
d1758 1
a1758 1
static bfd_boolean
d1768 2
a1769 2
  bfd_boolean line_p;
  bfd_boolean func_p;
d1773 1
a1773 1
    return FALSE;
d1780 1
a1780 1
	  return FALSE;
d1788 1
a1788 1
	  return FALSE;
d1795 1
a1795 1
	  return FALSE;
d1846 1
a1846 1
/* The DWARF2 version of find_nearest line.  Return TRUE if the line
d1852 1
a1852 1
bfd_boolean
d1900 1
a1900 1
	return FALSE;
d1909 1
a1909 1
	 return FALSE;
d1921 1
a1921 1
	return FALSE;
d1938 2
a1939 2
	  if ((bfd_simple_get_relocated_section_contents
	       (abfd, msec, stash->info_ptr + start, symbols)) == NULL)
d1952 15
d1970 1
a1970 1
    return FALSE;
d1983 1
a1983 1
      bfd_boolean found;
d1986 1
a1986 22
      length = read_4_bytes (abfd, stash->info_ptr);
      /* A 0xffffff length is the DWARF3 way of indicating we use
	 64-bit offsets, instead of 32-bit offsets.  */
      if (length == 0xffffffff)
	{
	  offset_size = 8;
	  length = read_8_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 12;
	}
      /* A zero length is the IRIX way of indicating 64-bit offsets,
	 mostly because the 64-bit length will generally fit in 32
	 bits, and the endianness helps.  */
      else if (length == 0)
	{
	  offset_size = 8;
	  length = read_4_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 8;
	}
      /* In the absence of the hints above, we assume addr_size-sized
	 offsets, for backward-compatibility with pre-DWARF3 64-bit
	 platforms.  */
      else if (addr_size == 8)
d1988 14
a2001 2
	  length = read_8_bytes (abfd, stash->info_ptr);
	  stash->info_ptr += 8;
d2004 2
a2005 1
	stash->info_ptr += 4;
d2033 4
a2036 4
							filename_ptr,
							functionname_ptr,
							linenumber_ptr,
							stash);
d2046 1
a2046 1
		    return TRUE;
d2052 1
a2052 1
  return FALSE;
@


1.36.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d203 45
d255 3
a257 1
read_1_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d259 1
a259 1
  return bfd_get_8 (abfd, buf);
d263 3
a265 1
read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d267 1
a267 1
  return bfd_get_signed_8 (abfd, buf);
d271 13
a283 1
read_2_bytes (bfd *abfd, char *buf)
d285 1
a285 1
  return bfd_get_16 (abfd, buf);
d288 2
d291 3
a293 1
read_4_bytes (bfd *abfd, char *buf)
d295 1
a295 1
  return bfd_get_32 (abfd, buf);
d298 12
d311 3
a313 1
read_8_bytes (bfd *abfd, char *buf)
d315 1
a315 1
  return bfd_get_64 (abfd, buf);
d319 4
a322 3
read_n_bytes (bfd *abfd ATTRIBUTE_UNUSED,
	      char *buf,
	      unsigned int size ATTRIBUTE_UNUSED)
d331 4
a334 3
read_string (bfd *abfd ATTRIBUTE_UNUSED,
	     char *buf,
	     unsigned int *bytes_read_ptr)
d348 4
a351 3
read_indirect_string (struct comp_unit* unit,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d377 1
a377 1
      stash->dwarf_str_buffer = bfd_alloc (abfd, msec->_raw_size);
d382 1
a382 1
				      0, msec->_raw_size))
d401 4
a404 3
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d417 1
a417 1
      byte = bfd_get_8 (abfd, buf);
d431 4
a434 3
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
d447 1
a447 1
      byte = bfd_get_8 (abfd, buf);
d466 3
a468 1
read_address (struct comp_unit *unit, char *buf)
d473 1
a473 1
      return bfd_get_64 (unit->abfd, buf);
d475 1
a475 1
      return bfd_get_32 (unit->abfd, buf);
d477 1
a477 1
      return bfd_get_16 (unit->abfd, buf);
d486 3
a488 1
lookup_abbrev (unsigned int number, struct abbrev_info **abbrevs)
d513 4
a516 1
read_abbrevs (bfd *abfd, bfd_vma offset, struct dwarf2_debug *stash)
d554 1
a554 1
  abbrevs = bfd_zalloc (abfd, amt);
d564 1
a564 1
      cur_abbrev = bfd_zalloc (abfd, amt);
d586 2
a587 1
	      cur_abbrev->attrs = bfd_realloc (cur_abbrev->attrs, amt);
d628 5
a632 4
read_attribute_value (struct attribute *attr,
		      unsigned form,
		      struct comp_unit *unit,
		      char *info_ptr)
d651 1
a651 1
      blk = bfd_alloc (abfd, amt);
d660 1
a660 1
      blk = bfd_alloc (abfd, amt);
d689 1
a689 1
      blk = bfd_alloc (abfd, amt);
d698 1
a698 1
      blk = bfd_alloc (abfd, amt);
d757 5
a761 4
read_attribute (struct attribute *attr,
		struct attr_abbrev *abbrev,
		struct comp_unit *unit,
		char *info_ptr)
d817 7
a823 6
add_line_info (struct line_info_table *table,
	       bfd_vma address,
	       char *filename,
	       unsigned int line,
	       unsigned int column,
	       int end_sequence)
d826 1
a826 1
  struct line_info* info = bfd_alloc (table->abfd, amt);
d915 3
a917 1
concat_filename (struct line_info_table *table, unsigned int file)
d954 4
a957 1
arange_add (struct comp_unit *unit, bfd_vma low_pc, bfd_vma high_pc)
d990 2
a991 1
  arange = bfd_zalloc (unit->abfd, sizeof (*arange));
d1002 3
a1004 1
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
d1047 1
a1047 1
  table = bfd_alloc (abfd, amt);
d1099 1
a1099 1
  lh.standard_opcode_lengths = bfd_alloc (abfd, amt);
d1118 1
a1118 1
	  table->dirs = bfd_realloc (table->dirs, amt);
d1137 1
a1137 1
	  table->files = bfd_realloc (table->files, amt);
d1228 2
a1229 1
		      table->files = bfd_realloc (table->files, amt);
d1325 7
a1331 5
lookup_address_in_line_info_table (struct line_info_table *table,
				   bfd_vma addr,
				   struct funcinfo *function,
				   const char **filename_ptr,
				   unsigned int *linenumber_ptr)
d1404 6
a1409 4
lookup_address_in_function_table (struct funcinfo *table,
				  bfd_vma addr,
				  struct funcinfo **function_ptr,
				  const char **functionname_ptr)
d1434 2
a1435 1
scan_unit_for_functions (struct comp_unit *unit)
d1470 1
a1470 1
	  func = bfd_zalloc (abfd, amt);
d1541 5
a1545 4
parse_comp_unit (bfd *abfd,
		 struct dwarf2_debug *stash,
		 bfd_vma unit_length,
		 unsigned int offset_size)
d1618 1
a1618 1
  unit = bfd_zalloc (abfd, amt);
d1658 1
a1658 1
		char *cp = strchr (comp_dir, ':');
d1679 3
a1681 1
comp_unit_contains_address (struct comp_unit *unit, bfd_vma addr)
d1709 8
a1716 6
comp_unit_find_nearest_line (struct comp_unit *unit,
			     bfd_vma addr,
			     const char **filename_ptr,
			     const char **functionname_ptr,
			     unsigned int *linenumber_ptr,
			     struct dwarf2_debug *stash)
d1771 3
a1773 1
find_debug_info (bfd *abfd, asection *after_sec)
d1803 12
a1814 9
_bfd_dwarf2_find_nearest_line (bfd *abfd,
			       asection *section,
			       asymbol **symbols,
			       bfd_vma offset,
			       const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *linenumber_ptr,
			       unsigned int addr_size,
			       void **pinfo)
d1824 1
a1824 1
  struct dwarf2_debug *stash = *pinfo;
d1848 1
a1848 1
      stash = bfd_zalloc (abfd, amt);
d1852 1
a1852 1
      *pinfo = stash;
d1869 1
a1869 1
      stash->info_ptr = bfd_alloc (abfd, total_size);
@


1.35
log
@Update to correctly decode (non-standard DWARF2) out-of-order address sequences.
@
text
@a1135 1
		  arange_add (unit, low_pc, high_pc);
d1140 1
a1140 1
		  arange_add (unit, low_pc, address);
@


1.34
log
@(_bfd_dwarf2_find_nearest_line): If address length is zero, set it to 8 for
(non-standard) 64-bit DWARF2 formats (e.g. IRIX64).
@
text
@d16 1
a16 1
This file is part of BFD.
d18 13
a30 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1087 1
a1087 1
      char* filename = concat_filename (table, 1);
d1092 8
a1099 2
      int end_sequence = 0, need_low_pc = 1;
      bfd_vma low_pc = 0;
d1108 2
a1109 1
	    {		/* Special operand.  */
d1117 4
a1120 5
	      if (need_low_pc)
		{
		  need_low_pc = 0;
		  low_pc = address;
		}
d1125 2
a1126 1
	      line_ptr += 1;	/* Ignore length.  */
d1129 1
d1136 5
a1140 5
		  if (need_low_pc)
		    {
		      need_low_pc = 0;
		      low_pc = address;
		    }
d1180 4
a1183 5
	      if (need_low_pc)
		{
		  need_low_pc = 0;
		  low_pc = address;
		}
d1198 2
a1199 2
		/* The file and directory tables are 0 based, the references
		   are 1 based.  */
d1224 1
a1224 1
	      {  /* Unknown standard opcode, ignore it.  */
d1226 1
d1245 1
a1245 4
lookup_address_in_line_info_table (table,
				   addr,
				   function,
				   filename_ptr,
d1306 1
a1306 3
lookup_address_in_function_table (table,
				  addr,
				  function_ptr,
d1672 2
a1673 3
comp_unit_find_nearest_line (unit, addr,
			     filename_ptr, functionname_ptr, linenumber_ptr,
			     stash)
d1713 4
a1716 8
  func_p = lookup_address_in_function_table (unit->function_table,
					     addr,
					     &function,
					     functionname_ptr);
  line_p = lookup_address_in_line_info_table (unit->line_table,
					      addr,
					      function,
					      filename_ptr,
d1721 9
a1729 8
/* Locate a section in a BFD containing debugging info.  The search starts from the
   section after AFTER_SEC, or from the first section in the BFD if AFTER_SEC is
   NULL.  The search works by examining the names of the sections.  There are two
   permissiable names.  The first is .debug_info.  This is the standard DWARF2 name.
   The second is a prefix .gnu.linkonce.wi.  This is a variation on the .debug_info
   section which has a checksum describing the contents appended onto the name.  This
   allows the linker to identify and discard duplicate debugging sections for
   different compilation units.  */
d1768 1
a1768 2
			       linenumber_ptr,
			       addr_size, pinfo)
@


1.34.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d16 1
a16 1
   This file is part of BFD.
d18 13
a30 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1087 1
a1087 1
      char * filename = concat_filename (table, 1);
d1092 2
a1093 8
      int end_sequence = 0;
      /* eraxxon@@alumni.rice.edu: Against the DWARF2 specs, some
         compilers generate address sequences that are wildly out of
         order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
         for ia64-Linux).  Thus, to determine the low and high
         address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = 0;
      bfd_vma high_pc = 0;
d1102 1
a1102 2
	    {
	      /* Special operand.  */
d1110 5
a1114 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1119 1
a1119 2
	      /* Ignore length.  */
	      line_ptr += 1;
a1121 1

d1128 6
a1133 5
		  if (low_pc == 0 || address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
		  arange_add (unit, low_pc, high_pc);
d1172 5
a1176 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1191 2
a1192 2
		/* The file and directory tables are 0
		   based, the references are 1 based.  */
d1217 1
a1217 1
	      {
a1218 1
		/* Unknown standard opcode, ignore it.  */
d1237 4
a1240 1
lookup_address_in_line_info_table (table, addr, function, filename_ptr,
d1301 3
a1303 1
lookup_address_in_function_table (table, addr, function_ptr,
d1669 3
a1671 2
comp_unit_find_nearest_line (unit, addr, filename_ptr, functionname_ptr,
			     linenumber_ptr, stash)
d1711 8
a1718 4
  func_p = lookup_address_in_function_table (unit->function_table, addr,
					     &function, functionname_ptr);
  line_p = lookup_address_in_line_info_table (unit->line_table, addr,
					      function, filename_ptr,
d1723 8
a1730 9
/* Locate a section in a BFD containing debugging info.  The search starts
   from the section after AFTER_SEC, or from the first section in the BFD if
   AFTER_SEC is NULL.  The search works by examining the names of the
   sections.  There are two permissiable names.  The first is .debug_info.
   This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.
   This is a variation on the .debug_info section which has a checksum
   describing the contents appended onto the name.  This allows the linker to
   identify and discard duplicate debugging sections for different
   compilation units.  */
d1769 2
a1770 1
			       linenumber_ptr, addr_size, pinfo)
@


1.34.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d405 1
a405 1
  buf = stash->dwarf_str_buffer + offset;
d581 1
a581 2
      cur_abbrev->tag = (enum dwarf_tag)
	read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
d604 2
a605 4
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name
	    = (enum dwarf_attribute) abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form
	    = (enum dwarf_form) abbrev_form;
d617 1
a617 1
	 Under Irix6 the abbreviations for a compilation unit are not
d649 1
a649 1
  attr->form = (enum dwarf_form) form;
d809 1
a809 2
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
a819 5
/* add_line_info: adds a new entry to the line_info list in the
   line_info_table, ensuring that the list is sorted.  Note that the
   line_info list is sorted from highest to lowest VMA (with possible
   duplicates); that is, line_info->prev_line always accesses an equal
   or smaller VMA.  */
d832 2
a833 53
  /* Find the correct location for 'info'.  Normally we will receive
     new line_info data 1) in order and 2) with increasing VMAs.
     However some compilers break the rules (cf. decode_line_info) and
     so we include some heuristics for quickly finding the correct
     location for 'info'. In particular, these heuristics optimize for
     the common case in which the VMA sequence that we receive is a
     list of locally sorted VMAs such as
       p...z a...j  (where a < j < p < z)

     Note: table->lcl_head is used to head an *actual* or *possible*
     sequence within the list (such as a...j) that is not directly
     headed by table->last_line

     Note: we may receive duplicate entries from 'decode_line_info'.  */

  while (1)
    if (!table->last_line
	|| address >= table->last_line->address)
      {
	/* Normal case: add 'info' to the beginning of the list */
	info->prev_line = table->last_line;
	table->last_line = info;

	/* lcl_head: initialize to head a *possible* sequence at the end.  */
	if (!table->lcl_head)
	  table->lcl_head = info;
	break;
      }
    else if (!table->lcl_head->prev_line
	     && table->lcl_head->address > address)
      {
	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = NULL;
	table->lcl_head->prev_line = info;
	break;
      }
    else if (table->lcl_head->prev_line
	     && table->lcl_head->address > address
	     && address >= table->lcl_head->prev_line->address)
      {
	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = table->lcl_head->prev_line;
	table->lcl_head->prev_line = info;
	break;
      }
    else
      {
	/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
	struct line_info* li2 = table->last_line; /* always non-NULL */
	struct line_info* li1 = li2->prev_line;
a834 12
	while (li1)
	  {
	    if (li2->address > address && address >= li1->address)
	      break;

	    li2 = li1; /* always non-NULL */
	    li1 = li1->prev_line;
	  }
	table->lcl_head = li2;
      }

  /* Set member data of 'info'.  */
d911 1
a911 2
  arange = (struct arange *)
    bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
a984 1
  table->lcl_head = NULL;
d1094 4
a1097 4
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
a1251 1
  /* Note: table->last_line should be a descendingly sorted list. */
d1253 1
a1253 2
  struct line_info* each_line = NULL;
  *filename_ptr = NULL;
a1259 5
  /* Check for large addresses */
  if (addr > next_line->address)
    each_line = NULL; /* ensure we skip over the normal case */

  /* Normal case: search the list; save  */
d1262 2
a1263 5
      /* If we have an address match, save this info.  This allows us
	 to return as good as results as possible for strange debugging
	 info.  */
      boolean addr_match = false;
      if (each_line->address <= addr && addr <= next_line->address)
a1264 2
	  addr_match = true;

d1281 1
a1282 4

      if (addr_match && !each_line->end_sequence)
	return true; /* we have definitely found what we want */

d1287 4
a1290 7
  /* At this point each_line is NULL but next_line is not.  If we found
     a candidate end-of-sequence point in the loop above, we can return
     that (compatibility with a bug in the Intel compiler); otherwise,
     assuming that we found the containing function for this address in
     this compilation unit, return the first line we have a number for
     (compatibility with GCC 2.95).  */
  if (*filename_ptr == NULL && function != NULL)
d1648 1
a1648 1
    return false;
d1654 1
a1654 1
	return true;
d1659 1
a1659 1
  return false;
d1704 1
a1704 1
	  && ! scan_unit_for_functions (unit))
d1717 1
a1717 1
  return (boolean) (line_p || func_p);
d1824 1
a1824 1
	 Read them all in and produce one large stash.  We do this in two
d1920 1
a1920 1
	{
@


1.34.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d160 1
a160 1
  /* TRUE if there is a line number table associated with this comp. unit.  */
d242 1
a242 1
static bfd_boolean lookup_address_in_line_info_table
d245 1
a245 1
static bfd_boolean lookup_address_in_function_table
d247 1
a247 1
static bfd_boolean scan_unit_for_functions PARAMS ((struct comp_unit *));
d252 1
a252 1
static bfd_boolean comp_unit_contains_address
d254 1
a254 1
static bfd_boolean comp_unit_find_nearest_line
d1313 2
a1314 2
/* If ADDR is within TABLE set the output parameters and return TRUE,
   otherwise return FALSE.  The output parameters, FILENAME_PTR and
d1317 1
a1317 1
static bfd_boolean
d1332 1
a1332 1
    return FALSE;
d1346 1
a1346 1
      bfd_boolean addr_match = FALSE;
d1349 1
a1349 1
	  addr_match = TRUE;
d1370 1
a1370 1
	return TRUE; /* we have definitely found what we want */
d1386 1
a1386 1
      return TRUE;
d1389 1
a1389 1
  return FALSE;
d1394 1
a1394 1
/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.  */
d1396 1
a1396 1
static bfd_boolean
d1414 1
a1414 1
	  return TRUE;
d1418 1
a1418 1
  return FALSE;
d1426 1
a1426 1
static bfd_boolean
d1457 1
a1457 1
	  return FALSE;
d1521 1
a1521 1
  return TRUE;
d1730 1
a1730 1
/* Return TRUE if UNIT contains the address given by ADDR.  */
d1732 1
a1732 1
static bfd_boolean
d1740 1
a1740 1
    return FALSE;
d1746 1
a1746 1
	return TRUE;
d1751 1
a1751 1
  return FALSE;
d1759 2
a1760 2
   Return TRUE if UNIT contains ADDR, and no errors were encountered;
   FALSE otherwise.  */
d1762 1
a1762 1
static bfd_boolean
d1772 2
a1773 2
  bfd_boolean line_p;
  bfd_boolean func_p;
d1777 1
a1777 1
    return FALSE;
d1784 1
a1784 1
	  return FALSE;
d1792 1
a1792 1
	  return FALSE;
d1799 1
a1799 1
	  return FALSE;
d1809 1
a1809 1
  return line_p || func_p;
d1850 1
a1850 1
/* The DWARF2 version of find_nearest line.  Return TRUE if the line
d1856 1
a1856 1
bfd_boolean
d1904 1
a1904 1
	return FALSE;
d1913 1
a1913 1
	 return FALSE;
d1925 1
a1925 1
	return FALSE;
d1974 1
a1974 1
    return FALSE;
d1987 1
a1987 1
      bfd_boolean found;
d2050 1
a2050 1
		    return TRUE;
d2056 1
a2056 1
  return FALSE;
@


1.34.2.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d248 2
d549 1
a549 3
      stash->dwarf_abbrev_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
d552 4
d657 1
a657 1
      /* FIXME: DWARF3 draft says DW_FORM_ref_addr is offset_size.  */
d824 5
a828 5
/* Adds a new entry to the line_info list in the line_info_table, ensuring
   that the list is sorted.  Note that the line_info list is sorted from
   highest to lowest VMA (with possible duplicates); that is,
   line_info->prev_line always accesses an equal or smaller VMA.  */

d908 1
a911 10

  amt = strlen (filename);
  if (amt)
    {
      info->filename = bfd_alloc (table->abfd, amt + 1);
      if (info->filename)
	strcpy (info->filename, filename);
    }
  else
    info->filename = NULL;
a913 4
/* Extract a fully qualified filename from a line info table.
   The returned string has been malloc'ed and it is the caller's
   responsibility to free it.  */

d925 1
a925 1
      return strdup ("<unknown>");
d929 3
a931 2

  if (! IS_ABSOLUTE_PATH (filename))
d937 6
a942 12
      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.
	 The best we can do is return the filename part.  */
      if (dirname != NULL)
	{
	  unsigned int len = strlen (dirname) + strlen (filename) + 2;
	  char * name;

	  name = bfd_malloc (len);
	  if (name)
	    sprintf (name, "%s/%s", dirname, filename);
	  return name;
	}
a943 2

  return strdup (filename);
d1022 1
a1022 3
      stash->dwarf_line_buffer
	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
						     stash->syms);
d1025 7
d1034 3
a1036 2
  /* It is possible to get a bad value for the line_offset.  Validate
     it here so that we won't get a segfault below.  */
a1274 2
		if (filename)
		  free (filename);
a1298 1

a1307 3

      if (filename)
	free (filename);
d1524 54
d1605 1
d1614 6
d1942 2
a1943 2
	  if ((bfd_simple_get_relocated_section_contents
	       (abfd, msec, stash->info_ptr + start, symbols)) == NULL)
d1956 15
d1990 1
a1990 22
      length = read_4_bytes (abfd, stash->info_ptr);
      /* A 0xffffff length is the DWARF3 way of indicating we use
	 64-bit offsets, instead of 32-bit offsets.  */
      if (length == 0xffffffff)
	{
	  offset_size = 8;
	  length = read_8_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 12;
	}
      /* A zero length is the IRIX way of indicating 64-bit offsets,
	 mostly because the 64-bit length will generally fit in 32
	 bits, and the endianness helps.  */
      else if (length == 0)
	{
	  offset_size = 8;
	  length = read_4_bytes (abfd, stash->info_ptr + 4);
	  stash->info_ptr += 8;
	}
      /* In the absence of the hints above, we assume addr_size-sized
	 offsets, for backward-compatibility with pre-DWARF3 64-bit
	 platforms.  */
      else if (addr_size == 8)
d1992 14
a2005 2
	  length = read_8_bytes (abfd, stash->info_ptr);
	  stash->info_ptr += 8;
d2008 2
a2009 1
	stash->info_ptr += 4;
d2037 4
a2040 4
							filename_ptr,
							functionname_ptr,
							linenumber_ptr,
							stash);
@


1.34.2.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d64 3
a66 2
    bfd_vma val;
    bfd_signed_vma sval;
d71 8
d655 1
a655 1
      attr->u.val = read_address (unit, info_ptr);
d665 1
a665 1
      attr->u.blk = blk;
d674 1
a674 1
      attr->u.blk = blk;
d677 1
a677 1
      attr->u.val = read_2_bytes (abfd, info_ptr);
d681 1
a681 1
      attr->u.val = read_4_bytes (abfd, info_ptr);
d685 1
a685 1
      attr->u.val = read_8_bytes (abfd, info_ptr);
d689 1
a689 1
      attr->u.str = read_string (abfd, info_ptr, &bytes_read);
d693 1
a693 1
      attr->u.str = read_indirect_string (unit, info_ptr, &bytes_read);
d703 1
a703 1
      attr->u.blk = blk;
d712 1
a712 1
      attr->u.blk = blk;
d715 1
a715 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d719 1
a719 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d723 1
a723 1
      attr->u.sval = read_signed_leb128 (abfd, info_ptr, &bytes_read);
d727 1
a727 1
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d731 1
a731 1
      attr->u.val = read_1_byte (abfd, info_ptr);
d735 1
a735 1
      attr->u.val = read_2_bytes (abfd, info_ptr);
d739 1
a739 1
      attr->u.val = read_4_bytes (abfd, info_ptr);
d743 1
a743 1
      attr->u.val = read_8_bytes (abfd, info_ptr);
d747 1
a747 1
      attr->u.val = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d1171 1
a1171 1
      char * filename = table->num_files ? concat_filename (table, 1) : NULL;
d1496 1
a1496 1
		  name = attr.u.str;
d1500 1
a1500 1
		    func->name = attr.u.str;
d1504 1
a1504 1
		  func->name = attr.u.str;
d1508 1
a1508 1
		  func->low = attr.u.val;
d1512 1
a1512 1
		  func->high = attr.u.val;
d1524 1
a1524 1
		  name = attr.u.str;
d1645 1
a1645 1
	  unit->line_offset = attr.u.val;
d1649 1
a1649 1
	  unit->name = attr.u.str;
d1653 1
a1653 1
	  unit->arange.low = attr.u.val;
d1657 1
a1657 1
	  unit->arange.high = attr.u.val;
d1662 1
a1662 1
	    char* comp_dir = attr.u.str;
@


1.34.2.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1533 1
a1533 1
   does not include the length field that precedes each compilation
@


1.34.2.7
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d203 45
d255 3
a257 1
read_1_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d259 1
a259 1
  return bfd_get_8 (abfd, buf);
d263 3
a265 1
read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, char *buf)
d267 1
a267 1
  return bfd_get_signed_8 (abfd, buf);
d271 13
a283 1
read_2_bytes (bfd *abfd, char *buf)
d285 1
a285 1
  return bfd_get_16 (abfd, buf);
d288 2
d291 3
a293 1
read_4_bytes (bfd *abfd, char *buf)
d295 1
a295 1
  return bfd_get_32 (abfd, buf);
d298 12
d311 3
a313 1
read_8_bytes (bfd *abfd, char *buf)
d315 1
a315 1
  return bfd_get_64 (abfd, buf);
d319 4
a322 3
read_n_bytes (bfd *abfd ATTRIBUTE_UNUSED,
	      char *buf,
	      unsigned int size ATTRIBUTE_UNUSED)
d331 4
a334 3
read_string (bfd *abfd ATTRIBUTE_UNUSED,
	     char *buf,
	     unsigned int *bytes_read_ptr)
d348 4
a351 3
read_indirect_string (struct comp_unit* unit,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d377 1
a377 1
      stash->dwarf_str_buffer = bfd_alloc (abfd, msec->_raw_size);
d382 1
a382 1
				      0, msec->_raw_size))
d401 4
a404 3
read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		      char *buf,
		      unsigned int *bytes_read_ptr)
d417 1
a417 1
      byte = bfd_get_8 (abfd, buf);
d431 4
a434 3
read_signed_leb128 (bfd *abfd ATTRIBUTE_UNUSED,
		    char *buf,
		    unsigned int * bytes_read_ptr)
d447 1
a447 1
      byte = bfd_get_8 (abfd, buf);
d466 3
a468 1
read_address (struct comp_unit *unit, char *buf)
d473 1
a473 1
      return bfd_get_64 (unit->abfd, buf);
d475 1
a475 1
      return bfd_get_32 (unit->abfd, buf);
d477 1
a477 1
      return bfd_get_16 (unit->abfd, buf);
d486 3
a488 1
lookup_abbrev (unsigned int number, struct abbrev_info **abbrevs)
d513 4
a516 1
read_abbrevs (bfd *abfd, bfd_vma offset, struct dwarf2_debug *stash)
d554 1
a554 1
  abbrevs = bfd_zalloc (abfd, amt);
d564 1
a564 1
      cur_abbrev = bfd_zalloc (abfd, amt);
d586 2
a587 1
	      cur_abbrev->attrs = bfd_realloc (cur_abbrev->attrs, amt);
d628 5
a632 4
read_attribute_value (struct attribute *attr,
		      unsigned form,
		      struct comp_unit *unit,
		      char *info_ptr)
d651 1
a651 1
      blk = bfd_alloc (abfd, amt);
d660 1
a660 1
      blk = bfd_alloc (abfd, amt);
d689 1
a689 1
      blk = bfd_alloc (abfd, amt);
d698 1
a698 1
      blk = bfd_alloc (abfd, amt);
d757 5
a761 4
read_attribute (struct attribute *attr,
		struct attr_abbrev *abbrev,
		struct comp_unit *unit,
		char *info_ptr)
d817 7
a823 6
add_line_info (struct line_info_table *table,
	       bfd_vma address,
	       char *filename,
	       unsigned int line,
	       unsigned int column,
	       int end_sequence)
d826 1
a826 1
  struct line_info* info = bfd_alloc (table->abfd, amt);
d915 3
a917 1
concat_filename (struct line_info_table *table, unsigned int file)
d954 4
a957 1
arange_add (struct comp_unit *unit, bfd_vma low_pc, bfd_vma high_pc)
d990 2
a991 1
  arange = bfd_zalloc (unit->abfd, sizeof (*arange));
d1002 3
a1004 1
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
d1047 1
a1047 1
  table = bfd_alloc (abfd, amt);
d1099 1
a1099 1
  lh.standard_opcode_lengths = bfd_alloc (abfd, amt);
d1118 1
a1118 1
	  table->dirs = bfd_realloc (table->dirs, amt);
d1137 1
a1137 1
	  table->files = bfd_realloc (table->files, amt);
d1228 2
a1229 1
		      table->files = bfd_realloc (table->files, amt);
d1325 7
a1331 5
lookup_address_in_line_info_table (struct line_info_table *table,
				   bfd_vma addr,
				   struct funcinfo *function,
				   const char **filename_ptr,
				   unsigned int *linenumber_ptr)
d1404 6
a1409 4
lookup_address_in_function_table (struct funcinfo *table,
				  bfd_vma addr,
				  struct funcinfo **function_ptr,
				  const char **functionname_ptr)
d1434 2
a1435 1
scan_unit_for_functions (struct comp_unit *unit)
d1470 1
a1470 1
	  func = bfd_zalloc (abfd, amt);
d1541 5
a1545 4
parse_comp_unit (bfd *abfd,
		 struct dwarf2_debug *stash,
		 bfd_vma unit_length,
		 unsigned int offset_size)
d1618 1
a1618 1
  unit = bfd_zalloc (abfd, amt);
d1658 1
a1658 1
		char *cp = strchr (comp_dir, ':');
d1679 3
a1681 1
comp_unit_contains_address (struct comp_unit *unit, bfd_vma addr)
d1709 8
a1716 6
comp_unit_find_nearest_line (struct comp_unit *unit,
			     bfd_vma addr,
			     const char **filename_ptr,
			     const char **functionname_ptr,
			     unsigned int *linenumber_ptr,
			     struct dwarf2_debug *stash)
d1771 3
a1773 1
find_debug_info (bfd *abfd, asection *after_sec)
d1803 12
a1814 9
_bfd_dwarf2_find_nearest_line (bfd *abfd,
			       asection *section,
			       asymbol **symbols,
			       bfd_vma offset,
			       const char **filename_ptr,
			       const char **functionname_ptr,
			       unsigned int *linenumber_ptr,
			       unsigned int addr_size,
			       void **pinfo)
d1824 1
a1824 1
  struct dwarf2_debug *stash = *pinfo;
d1848 1
a1848 1
      stash = bfd_zalloc (abfd, amt);
d1852 1
a1852 1
      *pinfo = stash;
d1869 1
a1869 1
      stash->info_ptr = bfd_alloc (abfd, total_size);
@


1.33
log
@From: Ian Rickards  <irickard@@arm.com>
* dwarf2.c (concat_filename): If we can't establish the directory
just return the filename.
@
text
@d1910 7
@


1.32
log
@2002-06-27  Kevin Buettner <kevinb@@redhat.com>

	* dwarf2.c (decode_line_info): Handle older, non-standard, 64-bit
	DWARF2 formats.
@
text
@a858 1

d864 7
a870 1
      return (char*) concat (dirname, "/", filename, NULL);
@


1.32.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d16 1
a16 1
   This file is part of BFD.
d18 13
a30 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d859 1
d865 1
a865 7

      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.  The
	 best we can do is return the filename part.  */
      if (dirname == NULL)
	return filename;
      else
	return (char*) concat (dirname, "/", filename, NULL);
d1082 1
a1082 1
      char * filename = concat_filename (table, 1);
d1087 2
a1088 8
      int end_sequence = 0;
      /* eraxxon@@alumni.rice.edu: Against the DWARF2 specs, some
         compilers generate address sequences that are wildly out of
         order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
         for ia64-Linux).  Thus, to determine the low and high
         address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = 0;
      bfd_vma high_pc = 0;
d1097 1
a1097 2
	    {
	      /* Special operand.  */
d1105 5
a1109 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1114 1
a1114 2
	      /* Ignore length.  */
	      line_ptr += 1;
a1116 1

d1123 5
a1127 5
		  arange_add (unit, low_pc, high_pc);
		  if (low_pc == 0 || address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
d1167 5
a1171 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1186 2
a1187 2
		/* The file and directory tables are 0
		   based, the references are 1 based.  */
d1212 1
a1212 1
	      {
a1213 1
		/* Unknown standard opcode, ignore it.  */
d1232 4
a1235 1
lookup_address_in_line_info_table (table, addr, function, filename_ptr,
d1296 3
a1298 1
lookup_address_in_function_table (table, addr, function_ptr,
d1664 3
a1666 2
comp_unit_find_nearest_line (unit, addr, filename_ptr, functionname_ptr,
			     linenumber_ptr, stash)
d1706 8
a1713 4
  func_p = lookup_address_in_function_table (unit->function_table, addr,
					     &function, functionname_ptr);
  line_p = lookup_address_in_line_info_table (unit->line_table, addr,
					      function, filename_ptr,
d1718 8
a1725 9
/* Locate a section in a BFD containing debugging info.  The search starts
   from the section after AFTER_SEC, or from the first section in the BFD if
   AFTER_SEC is NULL.  The search works by examining the names of the
   sections.  There are two permissiable names.  The first is .debug_info.
   This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.
   This is a variation on the .debug_info section which has a checksum
   describing the contents appended onto the name.  This allows the linker to
   identify and discard duplicate debugging sections for different
   compilation units.  */
d1764 2
a1765 1
			       linenumber_ptr, addr_size, pinfo)
a1903 7
	    }
	  else if (length == 0)
	    {
	      /* Handle (non-standard) 64-bit DWARF2 formats.  */
	      offset_size = 8;
	      length = read_4_bytes (abfd, stash->info_ptr + 4);
	      stash->info_ptr += 4;
@


1.32.2.2
log
@Merge from mainline.
@
text
@d405 1
a405 1
  buf = stash->dwarf_str_buffer + offset;
d581 1
a581 2
      cur_abbrev->tag = (enum dwarf_tag)
	read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
d604 2
a605 4
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name
	    = (enum dwarf_attribute) abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form
	    = (enum dwarf_form) abbrev_form;
d617 1
a617 1
	 Under Irix6 the abbreviations for a compilation unit are not
d649 1
a649 1
  attr->form = (enum dwarf_form) form;
d809 1
a809 2
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
a819 5
/* add_line_info: adds a new entry to the line_info list in the
   line_info_table, ensuring that the list is sorted.  Note that the
   line_info list is sorted from highest to lowest VMA (with possible
   duplicates); that is, line_info->prev_line always accesses an equal
   or smaller VMA.  */
d832 2
a833 53
  /* Find the correct location for 'info'.  Normally we will receive
     new line_info data 1) in order and 2) with increasing VMAs.
     However some compilers break the rules (cf. decode_line_info) and
     so we include some heuristics for quickly finding the correct
     location for 'info'. In particular, these heuristics optimize for
     the common case in which the VMA sequence that we receive is a
     list of locally sorted VMAs such as
       p...z a...j  (where a < j < p < z)

     Note: table->lcl_head is used to head an *actual* or *possible*
     sequence within the list (such as a...j) that is not directly
     headed by table->last_line

     Note: we may receive duplicate entries from 'decode_line_info'.  */

  while (1)
    if (!table->last_line
	|| address >= table->last_line->address)
      {
	/* Normal case: add 'info' to the beginning of the list */
	info->prev_line = table->last_line;
	table->last_line = info;

	/* lcl_head: initialize to head a *possible* sequence at the end.  */
	if (!table->lcl_head)
	  table->lcl_head = info;
	break;
      }
    else if (!table->lcl_head->prev_line
	     && table->lcl_head->address > address)
      {
	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = NULL;
	table->lcl_head->prev_line = info;
	break;
      }
    else if (table->lcl_head->prev_line
	     && table->lcl_head->address > address
	     && address >= table->lcl_head->prev_line->address)
      {
	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = table->lcl_head->prev_line;
	table->lcl_head->prev_line = info;
	break;
      }
    else
      {
	/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
	struct line_info* li2 = table->last_line; /* always non-NULL */
	struct line_info* li1 = li2->prev_line;
a834 12
	while (li1)
	  {
	    if (li2->address > address && address >= li1->address)
	      break;

	    li2 = li1; /* always non-NULL */
	    li1 = li1->prev_line;
	  }
	table->lcl_head = li2;
      }

  /* Set member data of 'info'.  */
d911 1
a911 2
  arange = (struct arange *)
    bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
a984 1
  table->lcl_head = NULL;
d1094 4
a1097 4
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
d1136 1
d1141 1
a1141 1
		  arange_add (unit, low_pc, high_pc);
a1252 1
  /* Note: table->last_line should be a descendingly sorted list. */
d1254 1
a1254 2
  struct line_info* each_line = NULL;
  *filename_ptr = NULL;
a1260 5
  /* Check for large addresses */
  if (addr > next_line->address)
    each_line = NULL; /* ensure we skip over the normal case */

  /* Normal case: search the list; save  */
d1263 2
a1264 5
      /* If we have an address match, save this info.  This allows us
	 to return as good as results as possible for strange debugging
	 info.  */
      boolean addr_match = false;
      if (each_line->address <= addr && addr <= next_line->address)
a1265 2
	  addr_match = true;

d1282 1
a1283 4

      if (addr_match && !each_line->end_sequence)
	return true; /* we have definitely found what we want */

d1288 4
a1291 7
  /* At this point each_line is NULL but next_line is not.  If we found
     a candidate end-of-sequence point in the loop above, we can return
     that (compatibility with a bug in the Intel compiler); otherwise,
     assuming that we found the containing function for this address in
     this compilation unit, return the first line we have a number for
     (compatibility with GCC 2.95).  */
  if (*filename_ptr == NULL && function != NULL)
d1649 1
a1649 1
    return false;
d1655 1
a1655 1
	return true;
d1660 1
a1660 1
  return false;
d1705 1
a1705 1
	  && ! scan_unit_for_functions (unit))
d1718 1
a1718 1
  return (boolean) (line_p || func_p);
d1825 1
a1825 1
	 Read them all in and produce one large stash.  We do this in two
d1921 1
a1921 1
	{
@


1.31
log
@Check unit->addr_size to read in the proper number of prologue bytes.
@
text
@d984 4
a987 7
  if (unit->addr_size == 4)
    {
      lh.total_length = read_4_bytes (abfd, line_ptr);
      line_ptr += 4;
      offset_size = 4;
    }
  else
a988 1
      BFD_ASSERT (unit->addr_size == 8);
d993 1
a993 2

  if (lh.total_length == 0xffffffff)
d995 3
a997 2
      lh.total_length = read_8_bytes (abfd, line_ptr);
      line_ptr += 8;
@


1.30
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Reinstate code
	reloading local sym addend mistakenly removed in 2002-05-01 change.

	* dwarf2.c (struct line_head): Make prologue_length a bfd_vma.
	(read_abbrevs): Change "offset" param to bfd_vma.
	(parse_comp_unit): Change "version" and addr_size to unsigned ints.
	Change "abbrev_offset" to bfd_vma.
	(read_indirect_string): Use correct conversion chars in error
	message format string, cast bfd_vma's to unsigned long.
	(read_abbrevs): Likewise.
	(read_attribute_value): Likewise.
	(decode_line_info): Likewise.
	(scan_unit_for_functions): Likewise.
	(parse_comp_unit): Likewise.
@
text
@d984 14
a997 3
  lh.total_length = read_4_bytes (abfd, line_ptr);
  line_ptr += 4;
  offset_size = 4;
@


1.30.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d859 1
d865 1
a865 7

      /* Not all tools set DW_AT_comp_dir, so dirname may be unknown.  The
	 best we can do is return the filename part.  */
      if (dirname == NULL)
	return filename;
      else
	return (char*) concat (dirname, "/", filename, NULL);
a990 7
      offset_size = 8;
    }
  else if (lh.total_length == 0 && unit->addr_size == 8)
    {
      /* Handle (non-standard) 64-bit DWARF2 formats.  */
      lh.total_length = read_4_bytes (abfd, line_ptr);
      line_ptr += 4;
@


1.30.6.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d16 1
a16 1
   This file is part of BFD.
d18 13
a30 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1087 1
a1087 1
      char * filename = concat_filename (table, 1);
d1092 2
a1093 8
      int end_sequence = 0;
      /* eraxxon@@alumni.rice.edu: Against the DWARF2 specs, some
         compilers generate address sequences that are wildly out of
         order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
         for ia64-Linux).  Thus, to determine the low and high
         address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = 0;
      bfd_vma high_pc = 0;
d1102 1
a1102 2
	    {
	      /* Special operand.  */
d1110 5
a1114 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1119 1
a1119 2
	      /* Ignore length.  */
	      line_ptr += 1;
a1121 1

d1128 6
a1133 5
		  if (low_pc == 0 || address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
		  arange_add (unit, low_pc, high_pc);
d1172 5
a1176 4
	      if (low_pc == 0 || address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
d1191 2
a1192 2
		/* The file and directory tables are 0
		   based, the references are 1 based.  */
d1217 1
a1217 1
	      {
a1218 1
		/* Unknown standard opcode, ignore it.  */
d1237 4
a1240 1
lookup_address_in_line_info_table (table, addr, function, filename_ptr,
d1301 3
a1303 1
lookup_address_in_function_table (table, addr, function_ptr,
d1669 3
a1671 2
comp_unit_find_nearest_line (unit, addr, filename_ptr, functionname_ptr,
			     linenumber_ptr, stash)
d1711 8
a1718 4
  func_p = lookup_address_in_function_table (unit->function_table, addr,
					     &function, functionname_ptr);
  line_p = lookup_address_in_line_info_table (unit->line_table, addr,
					      function, filename_ptr,
d1723 8
a1730 9
/* Locate a section in a BFD containing debugging info.  The search starts
   from the section after AFTER_SEC, or from the first section in the BFD if
   AFTER_SEC is NULL.  The search works by examining the names of the
   sections.  There are two permissiable names.  The first is .debug_info.
   This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.
   This is a variation on the .debug_info section which has a checksum
   describing the contents appended onto the name.  This allows the linker to
   identify and discard duplicate debugging sections for different
   compilation units.  */
d1769 2
a1770 1
			       linenumber_ptr, addr_size, pinfo)
a1908 7
	    }
	  else if (length == 0)
	    {
	      /* Handle (non-standard) 64-bit DWARF2 formats.  */
	      offset_size = 8;
	      length = read_4_bytes (abfd, stash->info_ptr + 4);
	      stash->info_ptr += 4;
@


1.30.6.3
log
@merge from mainline
@
text
@d405 1
a405 1
  buf = stash->dwarf_str_buffer + offset;
d581 1
a581 2
      cur_abbrev->tag = (enum dwarf_tag)
	read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
d604 2
a605 4
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name
	    = (enum dwarf_attribute) abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form
	    = (enum dwarf_form) abbrev_form;
d617 1
a617 1
	 Under Irix6 the abbreviations for a compilation unit are not
d649 1
a649 1
  attr->form = (enum dwarf_form) form;
d809 1
a809 2
  struct line_info* last_line;  /* largest VMA */
  struct line_info* lcl_head;   /* local head; used in 'add_line_info' */
a819 5
/* add_line_info: adds a new entry to the line_info list in the
   line_info_table, ensuring that the list is sorted.  Note that the
   line_info list is sorted from highest to lowest VMA (with possible
   duplicates); that is, line_info->prev_line always accesses an equal
   or smaller VMA.  */
d832 2
a833 53
  /* Find the correct location for 'info'.  Normally we will receive
     new line_info data 1) in order and 2) with increasing VMAs.
     However some compilers break the rules (cf. decode_line_info) and
     so we include some heuristics for quickly finding the correct
     location for 'info'. In particular, these heuristics optimize for
     the common case in which the VMA sequence that we receive is a
     list of locally sorted VMAs such as
       p...z a...j  (where a < j < p < z)

     Note: table->lcl_head is used to head an *actual* or *possible*
     sequence within the list (such as a...j) that is not directly
     headed by table->last_line

     Note: we may receive duplicate entries from 'decode_line_info'.  */

  while (1)
    if (!table->last_line
	|| address >= table->last_line->address)
      {
	/* Normal case: add 'info' to the beginning of the list */
	info->prev_line = table->last_line;
	table->last_line = info;

	/* lcl_head: initialize to head a *possible* sequence at the end.  */
	if (!table->lcl_head)
	  table->lcl_head = info;
	break;
      }
    else if (!table->lcl_head->prev_line
	     && table->lcl_head->address > address)
      {
	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = NULL;
	table->lcl_head->prev_line = info;
	break;
      }
    else if (table->lcl_head->prev_line
	     && table->lcl_head->address > address
	     && address >= table->lcl_head->prev_line->address)
      {
	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
	   list and 2) the head of 'info'.  */
	info->prev_line = table->lcl_head->prev_line;
	table->lcl_head->prev_line = info;
	break;
      }
    else
      {
	/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
	struct line_info* li2 = table->last_line; /* always non-NULL */
	struct line_info* li1 = li2->prev_line;
a834 12
	while (li1)
	  {
	    if (li2->address > address && address >= li1->address)
	      break;

	    li2 = li1; /* always non-NULL */
	    li1 = li1->prev_line;
	  }
	table->lcl_head = li2;
      }

  /* Set member data of 'info'.  */
d911 1
a911 2
  arange = (struct arange *)
    bfd_zalloc (unit->abfd, (bfd_size_type) sizeof (*arange));
a984 1
  table->lcl_head = NULL;
d1094 4
a1097 4
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
a1251 1
  /* Note: table->last_line should be a descendingly sorted list. */
d1253 1
a1253 2
  struct line_info* each_line = NULL;
  *filename_ptr = NULL;
a1259 5
  /* Check for large addresses */
  if (addr > next_line->address)
    each_line = NULL; /* ensure we skip over the normal case */

  /* Normal case: search the list; save  */
d1262 2
a1263 5
      /* If we have an address match, save this info.  This allows us
	 to return as good as results as possible for strange debugging
	 info.  */
      boolean addr_match = false;
      if (each_line->address <= addr && addr <= next_line->address)
a1264 2
	  addr_match = true;

d1281 1
a1282 4

      if (addr_match && !each_line->end_sequence)
	return true; /* we have definitely found what we want */

d1287 4
a1290 7
  /* At this point each_line is NULL but next_line is not.  If we found
     a candidate end-of-sequence point in the loop above, we can return
     that (compatibility with a bug in the Intel compiler); otherwise,
     assuming that we found the containing function for this address in
     this compilation unit, return the first line we have a number for
     (compatibility with GCC 2.95).  */
  if (*filename_ptr == NULL && function != NULL)
d1648 1
a1648 1
    return false;
d1654 1
a1654 1
	return true;
d1659 1
a1659 1
  return false;
d1704 1
a1704 1
	  && ! scan_unit_for_functions (unit))
d1717 1
a1717 1
  return (boolean) (line_p || func_p);
d1824 1
a1824 1
	 Read them all in and produce one large stash.  We do this in two
d1920 1
a1920 1
	{
@


1.29
log
@2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2.c (struct funcinfo): Move up.
        (lookup_address_in_function_table): New argument function_ptr.
        Set it.
        (lookup_address_in_line_table): New argument function.  If function
        is non-NULL, use it to handle ``addr'' before the first line note of
        the function.
        (comp_unit_find_nearest_line): Update and swap calls to
        lookup_address_in_function_table and lookup_address_in_line_table.
        * syms.c (_bfd_stab_section_find_nearest_line): Use the first
        N_SLINE encountered if we see an N_FUN before any N_SLINE.
@
text
@d45 1
a45 1
  unsigned int prologue_length;
d228 1
a228 1
  PARAMS ((bfd *, unsigned int, struct dwarf2_debug *));
d399 2
a400 2
      (*_bfd_error_handler) (_("Dwarf Error: DW_FORM_strp offset (%u) greater than or equal to .debug_str size (%u)."),
			     offset, stash->dwarf_str_size);
d526 1
a526 1
     unsigned int offset;
d560 2
a561 2
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%u) greater than or equal to .debug_abbrev size (%u)."),
			     offset, stash->dwarf_abbrev_size);
d757 1
a757 1
      (*_bfd_error_handler) (_("Dwarf Error: Invalid or unhandled FORM value: %d."),
d961 1
a961 1
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%u) greater than or equal to .debug_line size (%u)."),
d1348 1
a1348 1
	  (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %d."),
d1489 3
a1491 3
  unsigned short version;
  unsigned int abbrev_offset = 0;
  unsigned char addr_size;
d1520 1
a1520 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%hu', this reader only handles version 2 information."), version);
d1529 1
a1529 1
			 sizeof (bfd_vma));
d1550 1
a1550 1
      (*_bfd_error_handler) (_("Dwarf Error: Bad abbrev number: %d."),
d1559 1
a1559 1
      (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %d."),
@


1.28
log
@Use full section name in error messages.
@
text
@d243 2
a244 1
  PARAMS ((struct line_info_table *, bfd_vma, const char **, unsigned int *));
d246 1
a246 1
  PARAMS ((struct funcinfo *, bfd_vma, const char **));
d812 8
d1227 1
d1232 1
d1249 16
a1264 2
	  *filename_ptr = each_line->filename;
	  *linenumber_ptr = each_line->line;
d1271 10
a1285 8
struct funcinfo
{
  struct funcinfo *prev_func;
  char* name;
  bfd_vma low;
  bfd_vma high;
};

d1291 1
d1295 1
d1307 1
d1669 1
d1698 5
d1705 1
a1707 3
  func_p = lookup_address_in_function_table (unit->function_table,
					     addr,
					     functionname_ptr);
@


1.28.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d243 1
a243 2
  PARAMS ((struct line_info_table *, bfd_vma, struct funcinfo *,
	   const char **, unsigned int *));
d245 1
a245 1
  PARAMS ((struct funcinfo *, bfd_vma, struct funcinfo **, const char **));
a810 8
struct funcinfo
{
  struct funcinfo *prev_func;
  char* name;
  bfd_vma low;
  bfd_vma high;
};

a1217 1
				   function,
a1221 1
     struct funcinfo *function;
d1238 2
a1239 16
	  /* If this line appears to span functions, and addr is in the
	     later function, return the first line of that function instead
	     of the last line of the earlier one.  This check is for GCC
	     2.95, which emits the first line number for a function late.  */
	  if (function != NULL
	      && each_line->address < function->low
	      && next_line->address > function->low)
	    {
	      *filename_ptr = next_line->filename;
	      *linenumber_ptr = next_line->line;
	    }
	  else
	    {
	      *filename_ptr = each_line->filename;
	      *linenumber_ptr = each_line->line;
	    }
a1245 10
  /* At this point each_line is NULL but next_line is not.  If we found the
     containing function in this compilation unit, return the first line we
     have a number for.  This is also for compatibility with GCC 2.95.  */
  if (function != NULL)
    {
      *filename_ptr = next_line->filename;
      *linenumber_ptr = next_line->line;
      return true;
    }

d1251 8
a1263 1
				  function_ptr,
a1266 1
     struct funcinfo** function_ptr;
a1277 1
	  *function_ptr = each_func;
a1638 1
  struct funcinfo *function;
a1666 5
  function = NULL;
  func_p = lookup_address_in_function_table (unit->function_table,
					     addr,
					     &function,
					     functionname_ptr);
a1668 1
					      function,
d1671 3
@


1.28.2.2
log
@Merge from mainline
@
text
@d45 1
a45 1
  bfd_vma prologue_length;
d228 1
a228 1
  PARAMS ((bfd *, bfd_vma, struct dwarf2_debug *));
d399 2
a400 2
      (*_bfd_error_handler) (_("Dwarf Error: DW_FORM_strp offset (%lu) greater than or equal to .debug_str size (%lu)."),
			     (unsigned long) offset, stash->dwarf_str_size);
d526 1
a526 1
     bfd_vma offset;
d560 2
a561 2
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%lu) greater than or equal to .debug_abbrev size (%lu)."),
			     (unsigned long) offset, stash->dwarf_abbrev_size);
d757 1
a757 1
      (*_bfd_error_handler) (_("Dwarf Error: Invalid or unhandled FORM value: %u."),
d961 1
a961 1
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%lu) greater than or equal to .debug_line size (%lu)."),
d1348 1
a1348 1
	  (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %u."),
d1489 3
a1491 3
  unsigned int version;
  bfd_vma abbrev_offset = 0;
  unsigned int addr_size;
d1520 1
a1520 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%u', this reader only handles version 2 information."), version);
d1529 1
a1529 1
			 (unsigned int) sizeof (bfd_vma));
d1550 1
a1550 1
      (*_bfd_error_handler) (_("Dwarf Error: Bad abbrev number: %u."),
d1559 1
a1559 1
      (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %u."),
@


1.27
log
@	* dwarf2.c (struct line_head) [total_length]: Change type to
	bfd_vma.
	(struct dwarf2_debug): Add dwarf_str_buffer and dwarf_str_size.
	(struct comp_unit): Add stash and offset_size.
	(read_8_bytes): Return bfd_vma.
	(read_indirect_string): New.
	(read_attribute): Handle DW_FORM_strp.
	(decode_line_info): Support 64-bit DWARF format.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(parse_comp_unit): Set offset_size and stash.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d399 1
a399 1
			     offset, stash->dwarf_str_size );
d559 2
a560 2
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%u) greater than or equal to abbrev size (%u)."),
			     offset, stash->dwarf_abbrev_size );
d952 1
a952 1
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%u) greater than or equal to line size (%u)."),
a1458 1

a1462 1

a1465 1

d1490 1
a1490 1
      (*_bfd_error_handler) (_("Dwarf Error: found dwarf version '%hu', this reader only handles version 2 information."), version );
d1506 1
a1506 1
      (*_bfd_error_handler) ("Dwarf Error: found address size '%u', this reader can only handle address sizes '2', '4' and '8'.", addr_size );
@


1.26
log
@        * dwarf2.c (read_attribute_value): New function to handle
        DW_FORM_indirect.
        (read_attribute): Use it.
@
text
@d43 1
a43 1
  unsigned int total_length;
d118 6
d178 3
d183 3
d216 1
a216 1
static unsigned int read_8_bytes PARAMS ((bfd *, char *));
d219 1
d320 1
a320 1
static unsigned int
d346 1
a346 3
  /* If the size of a host char is 8 bits, we can return a pointer
     to the string, otherwise we have to copy the string to a buffer
     allocated on the temporary obstack.  */
d357 53
d653 1
d692 4
a754 1
    case DW_FORM_strp:
d917 1
a917 1
  unsigned int i, bytes_read;
d977 7
d987 5
a991 2
  lh.prologue_length = read_4_bytes (abfd, line_ptr);
  line_ptr += 4;
d1446 1
a1446 2
   If ABBREV_LENGTH is 0, then the length of the abbreviation offset
   is assumed to be four bytes.  Otherwise, it it is the size given.
d1452 1
a1452 1
parse_comp_unit (abfd, stash, unit_length, abbrev_length)
d1456 1
a1456 1
     unsigned int abbrev_length;
d1476 2
a1477 4
  BFD_ASSERT (abbrev_length == 0
	      || abbrev_length == 4
	      || abbrev_length == 8);
  if (abbrev_length == 0 || abbrev_length == 4)
d1479 1
a1479 1
  else if (abbrev_length == 8)
d1487 1
a1487 1
  info_ptr += abbrev_length;
d1542 1
d1545 1
d1856 1
d1859 9
a1867 1
	length = read_4_bytes (abfd, stash->info_ptr);
d1874 1
a1874 1
	  each = parse_comp_unit (abfd, stash, length, addr_size);
@


1.25
log
@Index: bfd/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* dwarf2.c (decode_line_info): Properly deal with unknown standard
	opcodes.

Index: binutils/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* readelf.c (display_debug_lines): Deal with unknown standard
	opcodes.  Handle DW_LNS_set_prologue_end, DW_LNS_set_epilogue_begin,
	DW_LNS_set_isa.

Index: include/elf/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* dwarf2.h (dwarf_line_number_ops): Add DWARF 3 opcodes.
@
text
@d219 3
d570 1
a570 1
/* Read an attribute described by an abbreviated attribute.  */
d573 1
a573 1
read_attribute (attr, abbrev, unit, info_ptr)
d575 1
a575 1
     struct attr_abbrev *abbrev;
d584 1
a584 2
  attr->name = abbrev->name;
  attr->form = abbrev->form;
d586 1
a586 1
  switch (abbrev->form)
d681 5
a686 1
    case DW_FORM_indirect:
d689 1
a689 1
			     abbrev->form);
d692 14
@


1.24
log
@	* dwarf2.c (comp_unit_find_nearest_line): Check for end of
	compilation unit.
@
text
@d982 16
a997 1
	  switch (op_code)
d1097 9
a1105 13
	    default:		/* Special operand.  */
	      adj_opcode = op_code - lh.opcode_base;
	      address += (adj_opcode / lh.line_range)
		* lh.minimum_instruction_length;
	      line += lh.line_base + (adj_opcode % lh.line_range);
	      /* Append row to matrix using current values.  */
	      add_line_info (table, address, filename, line, column, 0);
	      basic_block = 1;
	      if (need_low_pc)
		{
		  need_low_pc = 0;
		  low_pc = address;
		}
@


1.23
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1554 2
a1555 1
      if (! scan_unit_for_functions (unit))
@


1.22
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d466 1
d481 1
a481 1
      stash->dwarf_abbrev_buffer = (char*) bfd_alloc (abfd, stash->dwarf_abbrev_size);
d485 2
a486 3
      if (! bfd_get_section_contents (abfd, msec,
				      stash->dwarf_abbrev_buffer, 0,
				      stash->dwarf_abbrev_size))
d498 2
a499 1
  abbrevs = (struct abbrev_info**) bfd_zalloc (abfd, sizeof (struct abbrev_info*) * ABBREV_HASH_SIZE);
d508 2
a509 1
      cur_abbrev = (struct abbrev_info*)bfd_zalloc (abfd, sizeof (struct abbrev_info));
d528 4
a531 4
	      cur_abbrev->attrs = (struct attr_abbrev *)
		bfd_realloc (cur_abbrev->attrs,
			     (cur_abbrev->num_attrs + ATTR_ALLOC_CHUNK)
			     * sizeof (struct attr_abbrev));
d579 1
d592 2
a593 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, sizeof (struct dwarf_block));
d601 2
a602 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, sizeof (struct dwarf_block));
d626 2
a627 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, sizeof (struct dwarf_block));
d635 2
a636 1
      blk = (struct dwarf_block *) bfd_alloc (abfd, sizeof (struct dwarf_block));
d732 2
a733 2
  struct line_info* info = (struct line_info*)
    bfd_alloc (table->abfd, sizeof (struct line_info));
d809 1
a809 1
  arange = bfd_zalloc (unit->abfd, sizeof (*arange));
d832 1
d847 1
a847 1
      stash->dwarf_line_buffer = (char *) bfd_alloc (abfd, stash->dwarf_line_size);
d851 2
a852 3
      if (! bfd_get_section_contents (abfd, msec,
				      stash->dwarf_line_buffer, 0,
				      stash->dwarf_line_size))
d870 2
a871 2
  table = (struct line_info_table*) bfd_alloc (abfd,
					       sizeof (struct line_info_table));
d904 2
a905 2
  lh.standard_opcode_lengths = (unsigned char *)
    bfd_alloc (abfd, lh.opcode_base * sizeof (unsigned char));
d922 3
a924 3
	  table->dirs = (char **)
	    bfd_realloc (table->dirs,
			 (table->num_dirs + DIR_ALLOC_CHUNK) * sizeof (char *));
d941 3
a943 4
	  table->files = (struct fileinfo *)
	    bfd_realloc (table->files,
			 (table->num_files + FILE_ALLOC_CHUNK)
			 * sizeof (struct fileinfo));
d1010 4
a1013 4
		      table->files = (struct fileinfo *)
			bfd_realloc (table->files,
				     (table->num_files + FILE_ALLOC_CHUNK)
				     * sizeof (struct fileinfo));
d1217 2
a1218 1
	  func = (struct funcinfo*) bfd_zalloc (abfd, sizeof (struct funcinfo));
d1305 1
a1305 1
  relocs = (arelent **) bfd_malloc ((size_t) reloc_size);
d1328 1
a1328 1
  
d1363 2
d1379 2
a1380 3
  abbrev_offset += find_rela_addend (abfd, stash->sec,
				     info_ptr - stash->sec_info_ptr,
				     stash->syms);
d1432 2
a1433 1
  unit = (struct comp_unit*) bfd_zalloc (abfd, sizeof (struct comp_unit));
d1657 1
a1657 1
      unsigned long total_size;
d1659 1
d1661 1
a1661 2
      stash =
	(struct dwarf2_debug*) bfd_zalloc (abfd, sizeof (struct dwarf2_debug));
d1692 2
a1693 2
	  unsigned long size;
	  unsigned long start;
d1701 2
a1702 1
	  if (! bfd_get_section_contents (abfd, msec, stash->info_ptr + start, 0, size))
a1744 1
      struct comp_unit* each;
@


1.21
log
@* dwarf2.c (struct dwarf2_debug): Add sec, sec_info_ptr and syms.
(find_rela_addend): New function.
(parse_comp_unit): Call it to find the abbrev offset addend.
(_bfd_dwarf2_find_nearest_line): Initialize and maintain the new
members of dwarf2_debug as debugging information is read.
@
text
@d176 66
a424 24

/* This data structure holds the information of an abbrev.  */
struct abbrev_info
{
  unsigned int number;		/* Number identifying abbrev.  */
  enum dwarf_tag tag;		/* DWARF tag.  */
  int has_children;		/* Boolean.  */
  unsigned int num_attrs;	/* Number of attributes.  */
  struct attr_abbrev *attrs;	/* An array of attribute descriptions.  */
  struct abbrev_info *next;	/* Next in chain.  */
};

struct attr_abbrev
{
  enum dwarf_attribute name;
  enum dwarf_form form;
};

#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif
#ifndef ATTR_ALLOC_CHUNK
#define ATTR_ALLOC_CHUNK 4
#endif
@


1.20
log
@	* dwarf2.c (decode_line_info): Fix error message.
	(read_abbrevs): Fix test for offset as suggested by Alan Modra and
	adjust error message.
@
text
@d99 8
d1230 54
d1324 7
d1570 1
a1570 1
     asymbol **symbols ATTRIBUTE_UNUSED;
d1656 5
a1660 1
      BFD_ASSERT (stash->info_ptr_end = stash->info_ptr + total_size);
d1707 7
@


1.19
log
@Update copyright notices
@
text
@d440 1
a440 1
  if (offset > stash->dwarf_abbrev_size)
d442 1
a442 1
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%u) bigger than abbrev size (%u)."),
d807 1
a807 1
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%u) bigger than line size (%u)."),
@


1.18
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd.c: Likewise.
	* bfd-in2.h: Likewise.
	* bfd-in.h: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* dwarf2.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* format.c: Likewise.
	* freebsd.h: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1994, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.18.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.18.2.2
log
@Merge from mainline.
@
text
@d440 1
a440 1
  if (offset >= stash->dwarf_abbrev_size)
d442 1
a442 1
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%u) greater than or equal to abbrev size (%u)."),
d807 1
a807 1
      (*_bfd_error_handler) (_("Dwarf Error: Line offset (%u) greater than or equal to line size (%u)."),
@


1.18.2.3
log
@	* dwarf2.c (comp_unit_find_nearest_line): Check for end of
	compilation unit.
@
text
@d1434 1
a1434 2
      if (unit->first_child_die_ptr < unit->end_ptr
          && ! scan_unit_for_functions (unit))
@


1.17
log
@Generalize DWARF2 and COFF support.
@
text
@d1251 1
a1251 1
  
d1545 1
a1545 1
      
@


1.16
log
@2000-11-16  Kazu Hirata  <kazu@@hxi.com>

	* dwarf1.c: Fix formatting.
	* dwarf2.c: Likewise.
@
text
@d405 1
a405 1
read_abbrevs (abfd, offset)
d408 1
a414 3
  struct dwarf2_debug *stash;

  stash = elf_tdata(abfd)->dwarf2_find_line_info;
d702 1
a702 1
  if (*filename == '/')
d762 1
a762 1
decode_line_info (unit)
d764 1
a766 1
  struct dwarf2_debug *stash;
a774 2
  stash = elf_tdata (abfd)->dwarf2_find_line_info;

d1232 1
a1232 1
parse_comp_unit (abfd, info_ptr, end_ptr, abbrev_length)
d1234 2
a1235 2
     char* info_ptr;
     char* end_ptr;
d1249 3
d1289 1
a1289 1
  abbrevs = read_abbrevs (abfd, abbrev_offset);
d1402 2
a1403 1
			     filename_ptr, functionname_ptr, linenumber_ptr)
d1409 1
d1425 1
a1425 1
      unit->line_table = decode_line_info (unit);
d1497 1
a1497 1
			       addr_size)
d1506 1
d1516 1
a1516 1
  struct dwarf2_debug *stash = elf_tdata (abfd)->dwarf2_find_line_info;
d1539 1
a1539 1
      stash = elf_tdata (abfd)->dwarf2_find_line_info =
d1544 2
d1551 1
a1551 1
	return false;
d1613 2
a1614 1
					  functionname_ptr, linenumber_ptr);
d1631 1
a1631 3
	  each = parse_comp_unit (abfd, stash->info_ptr,
				  stash->info_ptr + length,
				  addr_size);
d1650 2
a1651 1
						       linenumber_ptr);
d1658 2
a1659 1
						       linenumber_ptr);
@


1.15
log
@Find all sections containing debug information and include them in the stash.
@
text
@d78 1
a78 1
/* Blocks are a bunch of untyped bytes. */
d147 1
a147 1
  
d161 1
a161 1
  struct funcinfo* function_table; 
d167 2
a168 2
/* VERBATIM 
   The following function up to the END VERBATIM mark are 
d263 1
a263 1
  
d282 1
a282 1
  
d292 1
a292 1
  
d294 1
a294 1
  
d322 1
a322 1
  
d327 1
a327 1
  
d351 1
a351 1
/* This data structure holds the information of an abbrev. */
d395 1
a395 1
  
d429 1
a429 1
      
d434 2
a435 2
      
      if (! bfd_get_section_contents (abfd, msec, 
d443 1
a443 1
      (*_bfd_error_handler) (_("Dwarf Error: Abbrev offset (%u) bigger than abbrev size (%u)."), 
d449 1
a449 1
  abbrevs = (struct abbrev_info**) bfd_zalloc (abfd, sizeof(struct abbrev_info*) * ABBREV_HASH_SIZE);
d472 1
a472 1
      
d484 1
a484 1
	  
d531 1
a531 1
  
d667 1
a667 1
static void 
d726 1
a726 1
  
d790 1
a790 1
      
d796 1
a796 1
      if (! bfd_get_section_contents (abfd, msec, 
d816 1
a816 1
  table = (struct line_info_table*) bfd_alloc (abfd, 
d854 1
a854 1
  
d865 1
a865 1
      
d874 1
a874 1
      
d877 1
a877 1
  
d884 1
a884 1
      
d894 1
a894 1
      
d907 1
a907 1
  
d928 1
a928 1
	  
d1054 1
a1054 1
lookup_address_in_line_info_table (table, 
d1056 1
a1056 1
				   filename_ptr, 
d1065 1
a1065 1
  
d1083 1
a1083 1
  
d1086 1
a1086 1
  
d1097 1
a1097 1
/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return true. */
d1100 1
a1100 1
lookup_address_in_function_table (table, 
d1119 1
a1119 1
  
d1152 1
a1152 1
      
d1156 1
a1156 1
	  (*_bfd_error_handler) (_("Dwarf Error: Could not find abbrev number %d."), 
d1161 1
a1161 1
      
d1170 1
a1170 1
  
d1174 1
a1174 1
	  
d1180 1
a1180 1
		  
d1187 1
a1187 1
		  
d1211 1
a1211 1
		  
d1312 1
a1312 1
  
d1315 1
a1315 1
  unit->addr_size = addr_size; 
d1389 1
a1389 1
  
d1396 1
a1396 1
   to be filled in.  
d1412 1
a1412 1
  
d1423 1
a1423 1
  
d1431 1
a1431 1
      
d1441 1
a1441 1
					      filename_ptr, 
d1443 1
a1443 1
  func_p = lookup_address_in_function_table (unit->function_table, 
d1509 1
a1509 1
     on to the next compilation unit.  
d1512 1
a1512 1
     a pointer to the next un-read compilation unit.  Check the 
d1520 1
a1520 1
  
d1531 1
a1531 1
    
d1556 1
a1556 1
      
d1593 1
a1593 1
     
d1595 1
a1595 1
     
d1599 2
a1600 2
  
  /* A null info_ptr indicates that there is no dwarf2 info 
d1608 1
a1608 1
      return comp_unit_find_nearest_line (each, addr, filename_ptr, 
d1626 1
a1626 1
	  each = parse_comp_unit (abfd, stash->info_ptr, 
@


1.14
log
@K&R compiler fixes
@
text
@d39 1
d41 13
a53 11
  {
    unsigned int total_length;
    unsigned short version;
    unsigned int prologue_length;
    unsigned char minimum_instruction_length;
    unsigned char default_is_stmt;
    int line_base;
    unsigned char line_range;
    unsigned char opcode_base;
    unsigned char *standard_opcode_lengths;
  };
a54 1
/* Attributes have a name and a value */
d56 4
d61 8
a68 12
    enum dwarf_attribute name;
    enum dwarf_form form;
    union
      {
	char *str;
	struct dwarf_block *blk;
	unsigned int unsnd;
	int snd;
	bfd_vma addr;
      }
    u;
  };
d70 1
a70 1
/* Get at parts of an attribute structure */
d80 4
a83 4
  {
    unsigned int size;
    char *data;
  };
d85 3
a87 4

struct dwarf2_debug {

  /* A list of all previously read comp_units. */
d92 1
a92 1
     into a buffer yet.*/
d95 1
a95 1
  /* Pointer to the end of the .debug_info section memory buffer. */
d98 1
a98 1
  /* Pointer to the .debug_abbrev section loaded into memory. */
d101 1
a101 1
  /* Length of the loaded .debug_abbrev section. */
d111 2
a112 1
struct arange {
a117 1

d119 1
a119 1
   what's needed to get to the line number information. */
d121 3
a123 3
struct comp_unit {

  /* Chain the previously read compilation units. */
d126 1
a126 1
  /* Keep the bdf convenient (for memory allocation). */
d130 1
a130 1
     unit as specified in the compilation unit header. */
d133 1
a133 1
  /* The DW_AT_name attribute (for error messages). */
d136 1
a136 1
  /* The abbrev hash table. */
d139 1
a139 1
  /* Note that an error was found by comp_unit_find_nearest_line. */
d142 1
a142 1
  /* The DW_AT_comp_dir attribute */
d145 1
a145 1
  /* True if there is a line number table associated with this comp. unit. */
d148 1
a148 1
  /* The offset into .debug_line of the line number table. */
d151 1
a151 1
  /* Pointer to the first child die for the comp unit. */
d154 1
a154 1
  /* The end of the comp unit. */
d157 1
a157 1
  /* The decoded line number, NULL if not yet decoded. */
d160 1
a160 1
  /* A list of the functions found in this comp. unit. */
d163 1
a163 1
  /* Address size for this unit - from unit header */
a166 2


d169 1
a169 1
   copied directly from dwarf2read.c. */
d171 1
a171 1
/* read dwarf information from a buffer */
d197 1
a197 3
#if 0

/* This is not used.  */
d217 1
a217 3
#if 0

/* This is not used.  */
d263 1
a350 4




d353 8
a360 8
  {
    unsigned int number;	/* number identifying abbrev */
    enum dwarf_tag tag;		/* dwarf tag */
    int has_children;		/* boolean */
    unsigned int num_attrs;	/* number of attributes */
    struct attr_abbrev *attrs;	/* an array of attribute descriptions */
    struct abbrev_info *next;	/* next in chain */
  };
d363 4
a366 4
  {
    enum dwarf_attribute name;
    enum dwarf_form form;
  };
d395 1
d455 1
a455 1
  /* loop until we reach an abbrev number of 0 */
d460 1
a460 1
      /* read in abbrev header */
d467 1
a467 1
      /* now read in declarations */
d472 1
d484 1
d531 1
d633 1
a633 2

/* Source line information table routines. */
d638 2
a639 1
struct line_info {
a640 1

d645 1
a645 1
  int end_sequence;		/* end of (sequential) code sequence */
d648 2
a649 1
struct fileinfo {
d656 2
a657 1
struct line_info_table {
a658 1

a660 1

d689 1
a689 1
static char* 
d724 1
a724 1
  /* first see if we can cheaply extend an existing range: */
d726 1
d745 1
a745 1
      /* this is the first address range: store it in unit->arange: */
d752 1
a752 1
  /* need to allocate a new arange and insert it into the arange list: */
d761 1
a761 1
/* Decode the line number information for UNIT. */
a767 1

a768 1

a769 1

d802 1
a802 1
	 we process it.... */
d832 1
a832 1
  /* read in the prologue */
d854 1
d861 1
a861 1
  /* Read directory table  */
d865 1
d874 1
d877 1
d880 1
a880 1
  /* Read file name table */
d884 1
d894 1
d907 1
d913 1
a913 1
      /* state machine registers  */
d923 1
a923 1
      /* Decode the table. */
d928 1
d932 1
a932 1
	      line_ptr += 1;	/* ignore length */
d1029 1
a1029 1
	    default:		/* special operand */
d1034 1
a1034 1
	      /* append row to matrix using current values */
a1048 1

d1051 1
a1051 1
   LINENUMBER_PTR, are pointers to the objects to be filled in. */
d1087 1
d1089 2
a1090 5


/* Function table functions. */

struct funcinfo {
a1091 1

a1096 1

d1123 1
a1123 5



/* DWARF2 Compilation unit functions. */

d1126 1
a1126 1
   to the function table. */
a1224 5





d1289 1
a1289 1
  /* Read the abbrevs for this compilation unit into a table */
d1369 1
a1369 5




/* Return true if UNIT contains the address given by ADDR. */
d1389 1
a1392 1

d1449 37
d1513 1
a1513 3
     previously read units before reading more.
     */

d1516 1
a1516 1
  /* What address are we looking for? */
d1534 1
d1536 1
a1536 2
      unsigned long size;
      
a1538 1
      
d1541 2
a1542 2
      
      msec = bfd_get_section_by_name (abfd, ".debug_info");
d1544 4
a1547 6
	{
	  /* No dwarf2 info.  Note that at this point the stash
	     has been allocated, but contains zeros, this lets
	     future calls to this function fail quicker. */
	  return false;
	}
d1549 7
a1555 5
      size = msec->_raw_size;
      if (size == 0)
	return false;
      
      stash->info_ptr = (char *) bfd_alloc (abfd, size);
d1557 2
a1558 1
      if (! stash->info_ptr)
d1561 5
a1565 1
      if (! bfd_get_section_contents (abfd, msec, stash->info_ptr, 0, size))
d1567 2
a1568 3
	  stash->info_ptr = 0;
	  return false;
	}
d1570 29
a1598 17
      stash->info_ptr_end = stash->info_ptr + size;

      /* FIXME: There is a problem with the contents of the
	 .debug_info section.  The 'low' and 'high' addresses of the
	 comp_units are computed by relocs against symbols in the
	 .text segment.  We need these addresses in order to determine
	 the nearest line number, and so we have to resolve the
	 relocs.  There is a similar problem when the .debug_line
	 section is processed as well (e.g., there may be relocs
	 against the operand of the DW_LNE_set_address operator).
	 
	 Unfortunately getting hold of the reloc information is hard...

	 For now, this means that disassembling object files (as
	 opposed to fully executables) does not always work as well as
	 we would like.  */
    }
d1601 1
a1601 2
     (or that an error occured while setting up the stash). */

d1605 1
a1605 2
  /* Check the previously read comp. units first. */

d1611 1
a1611 1
  /* Read each remaining comp. units checking each as they are read. */
d1640 1
a1640 1
		 address. */
a1663 2

/* end of file */
@


1.13
log
@Fix linker segfault that occured when linking ia64-linux kernel.
	* dwarf2.c (struct dwarf2_debug): New field dwarf_line_size.
	(decode_line_info): Set it.  Report error if unit->line_offset is
	equal to or larger than it.
@
text
@d703 2
a704 2
      (*_bfd_error_handler) (_("Dwarf Error: mangled line number "
			       "section (bad file number)."));
@


1.12
log
@	* dwarf2.c (read_abbrevs): Use _raw_size directly rather than
	calling bfd_get_section_size_before_reloc.
	(decode_line_info): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
@
text
@d105 3
a788 1
      unsigned long size;
d798 2
a799 2
      size = msec->_raw_size;
      stash->dwarf_line_buffer = (char *) bfd_alloc (abfd, size);
d805 1
a805 1
				      size))
d810 11
@


1.12.2.1
log
@K&R compiler fixes.
@
text
@d700 2
a701 2
      (*_bfd_error_handler)
	(_("Dwarf Error: mangled line number section (bad file number)."));
@


1.11
log
@fix typo in previous delta
@
text
@d434 1
a434 1
      stash->dwarf_abbrev_size = bfd_get_section_size_before_reloc (msec);
d796 1
a796 1
      size = bfd_get_section_size_before_reloc (msec);
d1521 1
a1521 1
      size = bfd_get_section_size_before_reloc (msec);
@


1.10
log
@Accept 16-bit addresses.
@
text
@d1499 1
a1499 1
  BFD_ASSERT (addr_size == 2 || addr_size == 4 || addr_size == 8);
@


1.9
log
@	* dwarf2.c (read_attribute): Support DW_FORM_ref8.
	* elf32-mips.c (mips_elf_link_hash_entry): Change mips_32_relocs
	to possibly_dynamic_relocs.  Adjust usage throughout code.
	(elf_mips_howto_table): Handle R_MIPS_64 correctly.
	(elf_mips_ctor64_howto): Likewise.
	(mips_elf_calculate_relocation): Handle R_MIPS_64 like R_MIPS_32.
	Adjust indentation.
	(mips_elf_relocate_section): Handle R_MIPS_64 in 32-bit mode.
	(_bfd_mips_elf_check_relocs): Handle R_MIPS_64 like R_MIPS_32.
	Use MIPS_ELF_GOT_SIZE to calculate the size of GOT entries.
	* elf64-mips.c (elf_backend_may_use_rel_p): Define.
@
text
@d2 1
a2 1
   Copyright 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d339 1
a339 3
  bfd_vma retval = 0;

  if (unit->addr_size == 4)
d341 8
a348 3
      retval = bfd_get_32 (unit->abfd, (bfd_byte *) buf);
    } else {
      retval = bfd_get_64 (unit->abfd, (bfd_byte *) buf);
a349 1
  return retval;
d1282 1
a1282 1
  if (addr_size != 4 && addr_size != 8)
d1284 1
a1284 1
      (*_bfd_error_handler) ("Dwarf Error: found address size '%u', this reader can only handle address sizes '4' and '8'.", addr_size );
d1499 1
a1499 1
  BFD_ASSERT (addr_size == 4 || addr_size == 8);
@


1.8
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d614 4
@


1.7
log
@	* dwarf2.c (parse_comp_unit): Add ABBREV_LENGTH parameter.
	(_bfd_dwarf2_find_nearest_line): Add ADDR_SIZE parameter.
	* elf.c (_bfd_elf_find_nearest_line): Pass it.
	* elf32-arm.h (elf32_arm_find_nearest_line): Likewise.
	* elf32-mips.c (ABI_64_P): New macro.
	(IRIX_COMPAT): We are IRIX6-compatible if ABI_64_P.
	(_bfd_mips_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Update prototype.
	* libbfd.h: Regenerated.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d173 1
a173 1
     bfd *abfd;
d181 1
a181 1
     bfd *abfd;
d241 1
a241 1
     bfd * abfd;
d243 1
a243 1
     unsigned int size;
d253 1
a253 1
     bfd *abfd;
d271 1
a271 1
     bfd *abfd;
d301 2
a302 2
     bfd * abfd;
     char * buf;
d1239 1
a1239 1
  unsigned int abbrev_offset;
d1460 1
a1460 1
     asymbol **symbols;
@


1.6
log
@David Mosberger  <davidm@@hpl.hp.com>
        * dwarf2.c (struct arange): New type.
        (struct comp_unit): Replace LOW and HIGH by member ARANGE.
        (arange_add): New function.
        (decode_line_info): Keep track of address ranges that a compilation
        unit covers.
        (comp_unit_contains_address): Return true if address is contained
        in _any_ of the address ranges associated with a compilation unit.
        (_bfd_dwarf2_find_nearest_line): Call comp_unit_find_nearest_line
        on the first comp_unit that contains the address.
@
text
@d1219 6
a1224 4
/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This includes
   the compilation unit header that proceeds the DIE's, but does not
   include the length field that preceeds each compilation unit header.
   END_PTR points one past the end of this comp unit.
d1230 1
a1230 1
parse_comp_unit (abfd, info_ptr, end_ptr)
d1234 1
d1249 8
a1256 2
  abbrev_offset = read_4_bytes (abfd, info_ptr);
  info_ptr += 4;
d1447 5
a1451 2
/* The DWARF2 version of find_nearest line.
   Return true if the line is found without error. */
d1455 3
a1457 1
			  filename_ptr, functionname_ptr, linenumber_ptr)
d1465 1
d1488 7
d1565 1
a1565 1
      unsigned int length;
d1568 5
a1572 2
      length = read_4_bytes (abfd, stash->info_ptr);
      stash->info_ptr += 4;
d1577 2
a1578 1
				  stash->info_ptr + length);
@


1.5
log
@David Mosberger  <davidm@@hpl.hp.com>
        * dwarf2.c (struct dwarf2_debug): Add member dwarf_line_buffer.
        (decode_line_info): Add variable STASH and initialize it to point
        to the per-bfd dwarf2_debug info.  Remove static variable
        dwarf_line_buffer and use stash->dwarf_line_buffer in its place.
@
text
@d107 5
d127 1
a127 2
  bfd_vma low;
  bfd_vma high;
d712 44
a773 6
#if 0
  /* This optimization unfortunately does not work well on programs
     that have multiple sections containing text (such as Linux which
     uses .text, and .text.init, for example.  */
  bfd_vma hi_pc = 0, lo_pc = ~ (bfd_vma) 0;
#endif
d792 1
a792 1
      if (! dwarf_line_buffer)
d796 1
a796 1
				      dwarf_line_buffer, 0,
d901 2
a902 1
      int end_sequence = 0;
d919 8
a926 1
		  add_line_info (table, address, filename, line, column, end_sequence);
d965 5
d1017 5
a1022 9
#if 0
	  if (unit->high == 0)
	    {
	      if (address > hi_pc)
		hi_pc = address;
	      if (address < lo_pc)
		lo_pc = address;
	    }
#endif
a1024 7
#if 0
  if (unit->high == 0 && hi_pc != 0)
    {
      unit->high = hi_pc;
      unit->low = lo_pc;
    }
#endif
d1322 1
a1322 1
	  unit->low = DW_ADDR (&attr);
d1326 1
a1326 1
	  unit->high = DW_ADDR (&attr);
d1365 14
a1378 2
  return ! unit->error
    && (addr >= unit->low && addr <= unit->high);
a1468 2
  boolean found;

d1535 3
a1537 19
    {
      if (each->high > 0)
	{
	  if (comp_unit_contains_address (each, addr))
	    return comp_unit_find_nearest_line (each, addr,
						filename_ptr, 
						functionname_ptr, 
						linenumber_ptr);
	}
      else
	{
	  found = comp_unit_find_nearest_line (each, addr,
						filename_ptr, 
						functionname_ptr, 
						linenumber_ptr);
	  if (found)
	    return true;
	}
    }
d1544 1
d1565 1
a1565 1
	      if (each->high > 0)
@


1.4
log
@	* dwarf2.c (decode_line_info): Remove unused variable first_time.
@
text
@d102 3
d716 1
a716 1
  static char* dwarf_line_buffer = 0;
d733 3
a735 1
  if (! dwarf_line_buffer)
d749 1
a749 1
      dwarf_line_buffer = (char*) bfd_alloc (abfd, size);
d776 1
a776 1
  line_ptr = dwarf_line_buffer + unit->line_offset;
@


1.3
log
@David Mosberger  <davidm@@hpl.hp.com>
        * dwarf2.c (struct line_info): Add member END_SEQUENCE to keep
        track of end_sequence markers.
        (add_line_info): Add END_SEQUENCE arg.
        (decode_line_info): Don't try to infer lo_pc and hi_pc from the
        debug-line info---it doesn't work right if a compilation unit
        consists of multiple discontiguous code-sequences.  It would be
        worthwhile to optimize for the common case where a compilation
        unit results in a contiguous set of code sequences, but this is
        quite tricky to get right for arbitrary DWARF2 files.
        (lookup_address_in_line_info_table): Don't use the last line entry
        for a compilation unit for anything with an address higher than
        this line entry.  Also, check for end_sequence markers to
        correctly handle discontinuities.
        (_bfd_dwarf2_find_nearest_line): When checking previously loaded
        compilation units, check all compilation units with each->high==0
        just like when reading compilation units.
        * dwarf2.c (decode_line_info): Initialize table->files and
        table->last_line to NULL to avoid segfaults due to random
        values in these members.
        (concat_filename): Check for out-of-range file number before
        indexing filename table.  Segfaults suck.
        * dwarf2.c (decode_line_info): Don't truncate address to least
        significant 32 bits (breaks 64 bit targets).
        (lookup_address_in_function_table): Ditto.
        (comp_unit_contains_address): Ditto.
@
text
@a854 1
      boolean first_time = true;
@


1.2
log
@Fred Fish  <fnf@@be.com>
        * dwarf2.c (read_abbrevs): Change cast of dwarf_abbrev_buffer
        assignment from "unsigned char *" to "char *".
        (decode_line_info): Likewise for dwarf_line_buffer assignment.
@
text
@d634 1
d657 1
a657 1
add_line_info (table, address, filename, line, column)
d663 1
d675 1
d683 10
a692 1
  char* filename = table->files[file - 1].name;
d723 6
d768 3
d855 1
d872 1
a872 1
		  add_line_info (table, address, filename, line, column);
d909 1
a909 1
	      add_line_info (table, address, filename, line, column);
d943 2
a944 1
	      address += (255 - lh.opcode_base) / lh.line_range;
d956 1
a956 1
	      add_line_info (table, address, filename, line, column);
d959 9
d970 7
d996 1
a997 1
  struct line_info* next_line;
d999 9
a1007 7
  for (next_line = 0, each_line = table->last_line;
       each_line;
       next_line = each_line, each_line = each_line->prev_line)
    {
      if (addr >= each_line->address
	  && (next_line == 0
	      || addr < next_line->address)) 
d1013 2
d1409 2
d1452 8
a1459 6
      /* FIXME:  There is a problem with the contents of the .debug_info section.
	 The 'low' and 'high' addresses of the comp_units are computed by relocs
	 against symbols in the .text segment.  We need these addresses in
	 order to determine the nearest line number, and so we have to resolve
	 the relocs.  There is a similar problem when the .debug_line section is
	 processed as well.
d1461 5
a1465 1
	 Unfortunately getting hold of the reloc information is hard... */
d1478 17
a1494 5
      if (comp_unit_contains_address (each, addr))
	return comp_unit_find_nearest_line (each, addr,
					    filename_ptr, 
					    functionname_ptr, 
					    linenumber_ptr);
d1517 22
a1538 5
	      if (comp_unit_contains_address (each, addr))
		return comp_unit_find_nearest_line (each, addr,
						    filename_ptr, 
						    functionname_ptr, 
						    linenumber_ptr);
@


1.1
log
@Initial revision
@
text
@d426 1
a426 1
      stash->dwarf_abbrev_buffer = (unsigned char*) bfd_alloc (abfd, stash->dwarf_abbrev_size);
d726 1
a726 1
      dwarf_line_buffer = (unsigned char*) bfd_alloc (abfd, size);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

