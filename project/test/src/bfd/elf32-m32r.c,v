head	1.114;
access;
symbols
	sid-snapshot-20180601:1.114
	sid-snapshot-20180501:1.114
	sid-snapshot-20180401:1.114
	sid-snapshot-20180301:1.114
	sid-snapshot-20180201:1.114
	sid-snapshot-20180101:1.114
	sid-snapshot-20171201:1.114
	sid-snapshot-20171101:1.114
	sid-snapshot-20171001:1.114
	sid-snapshot-20170901:1.114
	sid-snapshot-20170801:1.114
	sid-snapshot-20170701:1.114
	sid-snapshot-20170601:1.114
	sid-snapshot-20170501:1.114
	sid-snapshot-20170401:1.114
	sid-snapshot-20170301:1.114
	sid-snapshot-20170201:1.114
	sid-snapshot-20170101:1.114
	sid-snapshot-20161201:1.114
	sid-snapshot-20161101:1.114
	sid-snapshot-20160901:1.114
	sid-snapshot-20160801:1.114
	sid-snapshot-20160701:1.114
	sid-snapshot-20160601:1.114
	sid-snapshot-20160501:1.114
	sid-snapshot-20160401:1.114
	sid-snapshot-20160301:1.114
	sid-snapshot-20160201:1.114
	sid-snapshot-20160101:1.114
	sid-snapshot-20151201:1.114
	sid-snapshot-20151101:1.114
	sid-snapshot-20151001:1.114
	sid-snapshot-20150901:1.114
	sid-snapshot-20150801:1.114
	sid-snapshot-20150701:1.114
	sid-snapshot-20150601:1.114
	sid-snapshot-20150501:1.114
	sid-snapshot-20150401:1.114
	sid-snapshot-20150301:1.114
	sid-snapshot-20150201:1.114
	sid-snapshot-20150101:1.114
	sid-snapshot-20141201:1.114
	sid-snapshot-20141101:1.114
	sid-snapshot-20141001:1.114
	sid-snapshot-20140901:1.114
	sid-snapshot-20140801:1.114
	sid-snapshot-20140701:1.114
	sid-snapshot-20140601:1.114
	sid-snapshot-20140501:1.114
	sid-snapshot-20140401:1.114
	sid-snapshot-20140301:1.114
	sid-snapshot-20140201:1.114
	sid-snapshot-20140101:1.114
	sid-snapshot-20131201:1.114
	sid-snapshot-20131101:1.114
	sid-snapshot-20131001:1.114
	binutils-2_24-branch:1.114.0.2
	binutils-2_24-branchpoint:1.114
	binutils-2_21_1:1.101
	sid-snapshot-20130901:1.114
	gdb_7_6_1-2013-08-30-release:1.111
	sid-snapshot-20130801:1.114
	sid-snapshot-20130701:1.114
	sid-snapshot-20130601:1.114
	sid-snapshot-20130501:1.114
	gdb_7_6-2013-04-26-release:1.111
	sid-snapshot-20130401:1.113
	binutils-2_23_2:1.109
	gdb_7_6-branch:1.111.0.2
	gdb_7_6-2013-03-12-branchpoint:1.111
	sid-snapshot-20130301:1.111
	sid-snapshot-20130201:1.110
	sid-snapshot-20130101:1.110
	sid-snapshot-20121201:1.110
	gdb_7_5_1-2012-11-29-release:1.109
	binutils-2_23_1:1.109
	sid-snapshot-20121101:1.110
	binutils-2_23:1.109
	sid-snapshot-20121001:1.110
	sid-snapshot-20120901:1.109
	gdb_7_5-2012-08-17-release:1.109
	sid-snapshot-20120801:1.109
	binutils-2_23-branch:1.109.0.4
	binutils-2_23-branchpoint:1.109
	gdb_7_5-branch:1.109.0.2
	gdb_7_5-2012-07-18-branchpoint:1.109
	sid-snapshot-20120701:1.109
	sid-snapshot-20120601:1.107
	sid-snapshot-20120501:1.105
	binutils-2_22_branch:1.102.0.4
	gdb_7_4_1-2012-04-26-release:1.103
	sid-snapshot-20120401:1.104
	sid-snapshot-20120301:1.103
	sid-snapshot-20120201:1.103
	gdb_7_4-2012-01-24-release:1.103
	sid-snapshot-20120101:1.103
	gdb_7_4-branch:1.103.0.2
	gdb_7_4-2011-12-13-branchpoint:1.103
	sid-snapshot-20111201:1.103
	binutils-2_22:1.102
	sid-snapshot-20111101:1.103
	sid-snapshot-20111001:1.102
	binutils-2_22-branch:1.102.0.2
	binutils-2_22-branchpoint:1.102
	gdb_7_3_1-2011-09-04-release:1.101
	sid-snapshot-20110901:1.102
	sid-snapshot-20110801:1.102
	gdb_7_3-2011-07-26-release:1.101
	sid-snapshot-20110701:1.102
	sid-snapshot-20110601:1.101
	sid-snapshot-20110501:1.101
	gdb_7_3-branch:1.101.0.4
	gdb_7_3-2011-04-01-branchpoint:1.101
	sid-snapshot-20110401:1.101
	sid-snapshot-20110301:1.101
	sid-snapshot-20110201:1.101
	sid-snapshot-20110101:1.101
	binutils-2_21:1.101
	sid-snapshot-20101201:1.101
	binutils-2_21-branch:1.101.0.2
	binutils-2_21-branchpoint:1.101
	sid-snapshot-20101101:1.101
	sid-snapshot-20101001:1.99
	binutils-2_20_1:1.95
	gdb_7_2-2010-09-02-release:1.97
	sid-snapshot-20100901:1.98
	sid-snapshot-20100801:1.97
	gdb_7_2-branch:1.97.0.2
	gdb_7_2-2010-07-07-branchpoint:1.97
	sid-snapshot-20100701:1.97
	sid-snapshot-20100601:1.96
	sid-snapshot-20100501:1.96
	sid-snapshot-20100401:1.96
	gdb_7_1-2010-03-18-release:1.96
	sid-snapshot-20100301:1.96
	gdb_7_1-branch:1.96.0.2
	gdb_7_1-2010-02-18-branchpoint:1.96
	sid-snapshot-20100201:1.95
	sid-snapshot-20100101:1.95
	gdb_7_0_1-2009-12-22-release:1.95
	sid-snapshot-20091201:1.95
	sid-snapshot-20091101:1.95
	binutils-2_20:1.95
	gdb_7_0-2009-10-06-release:1.95
	sid-snapshot-20091001:1.95
	gdb_7_0-branch:1.95.0.4
	gdb_7_0-2009-09-16-branchpoint:1.95
	arc-sim-20090309:1.91
	binutils-arc-20081103-branch:1.91.0.20
	binutils-arc-20081103-branchpoint:1.91
	binutils-2_20-branch:1.95.0.2
	binutils-2_20-branchpoint:1.95
	sid-snapshot-20090901:1.94
	sid-snapshot-20090801:1.94
	msnyder-checkpoint-072509-branch:1.94.0.4
	msnyder-checkpoint-072509-branchpoint:1.94
	sid-snapshot-20090701:1.94
	dje-cgen-play1-branch:1.94.0.2
	dje-cgen-play1-branchpoint:1.94
	sid-snapshot-20090601:1.92
	sid-snapshot-20090501:1.92
	sid-snapshot-20090401:1.92
	arc-20081103-branch:1.91.0.18
	arc-20081103-branchpoint:1.91
	arc-insight_6_8-branch:1.91.0.16
	arc-insight_6_8-branchpoint:1.91
	insight_6_8-branch:1.91.0.14
	insight_6_8-branchpoint:1.91
	sid-snapshot-20090301:1.92
	binutils-2_19_1:1.91
	sid-snapshot-20090201:1.92
	sid-snapshot-20090101:1.92
	reverse-20081226-branch:1.92.0.2
	reverse-20081226-branchpoint:1.92
	sid-snapshot-20081201:1.92
	multiprocess-20081120-branch:1.91.0.12
	multiprocess-20081120-branchpoint:1.91
	sid-snapshot-20081101:1.91
	binutils-2_19:1.91
	sid-snapshot-20081001:1.91
	reverse-20080930-branch:1.91.0.10
	reverse-20080930-branchpoint:1.91
	binutils-2_19-branch:1.91.0.8
	binutils-2_19-branchpoint:1.91
	sid-snapshot-20080901:1.91
	sid-snapshot-20080801:1.91
	reverse-20080717-branch:1.91.0.6
	reverse-20080717-branchpoint:1.91
	sid-snapshot-20080701:1.91
	msnyder-reverse-20080609-branch:1.91.0.4
	msnyder-reverse-20080609-branchpoint:1.91
	drow-reverse-20070409-branch:1.85.0.2
	drow-reverse-20070409-branchpoint:1.85
	sid-snapshot-20080601:1.91
	sid-snapshot-20080501:1.91
	sid-snapshot-20080403:1.91
	sid-snapshot-20080401:1.91
	gdb_6_8-2008-03-27-release:1.91
	sid-snapshot-20080301:1.91
	gdb_6_8-branch:1.91.0.2
	gdb_6_8-2008-02-26-branchpoint:1.91
	sid-snapshot-20080201:1.91
	sid-snapshot-20080101:1.90
	sid-snapshot-20071201:1.90
	sid-snapshot-20071101:1.90
	gdb_6_7_1-2007-10-29-release:1.88
	gdb_6_7-2007-10-10-release:1.88
	sid-snapshot-20071001:1.90
	gdb_6_7-branch:1.88.0.4
	gdb_6_7-2007-09-07-branchpoint:1.88
	binutils-2_18:1.88
	binutils-2_18-branch:1.88.0.2
	binutils-2_18-branchpoint:1.88
	insight_6_6-20070208-release:1.83
	binutils-csl-coldfire-4_1-32:1.80
	binutils-csl-sourcerygxx-4_1-32:1.80
	gdb_6_6-2006-12-18-release:1.83
	binutils-csl-innovasic-fido-3_4_4-33:1.80
	binutils-csl-sourcerygxx-3_4_4-32:1.57
	binutils-csl-coldfire-4_1-30:1.80
	binutils-csl-sourcerygxx-4_1-30:1.80
	binutils-csl-coldfire-4_1-28:1.80
	binutils-csl-sourcerygxx-4_1-29:1.80
	binutils-csl-sourcerygxx-4_1-28:1.80
	gdb_6_6-branch:1.83.0.2
	gdb_6_6-2006-11-15-branchpoint:1.83
	binutils-csl-arm-2006q3-27:1.80
	binutils-csl-sourcerygxx-4_1-27:1.80
	binutils-csl-arm-2006q3-26:1.80
	binutils-csl-sourcerygxx-4_1-26:1.80
	binutils-csl-sourcerygxx-4_1-25:1.80
	binutils-csl-sourcerygxx-4_1-24:1.80
	binutils-csl-sourcerygxx-4_1-23:1.80
	insight_6_5-20061003-release:1.80
	gdb-csl-symbian-6_4_50_20060226-12:1.78
	binutils-csl-sourcerygxx-4_1-21:1.80
	binutils-csl-arm-2006q3-21:1.80
	binutils-csl-sourcerygxx-4_1-22:1.80
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.80
	binutils-csl-sourcerygxx-4_1-20:1.80
	binutils-csl-arm-2006q3-19:1.80
	binutils-csl-sourcerygxx-4_1-19:1.80
	binutils-csl-sourcerygxx-4_1-18:1.80
	binutils-csl-renesas-4_1-9:1.80
	gdb-csl-sourcerygxx-3_4_4-25:1.75
	binutils-csl-sourcerygxx-3_4_4-25:1.57
	nickrob-async-20060828-mergepoint:1.80
	gdb-csl-symbian-6_4_50_20060226-11:1.78
	binutils-csl-renesas-4_1-8:1.80
	binutils-csl-renesas-4_1-7:1.80
	binutils-csl-renesas-4_1-6:1.80
	gdb-csl-sourcerygxx-4_1-17:1.78
	binutils-csl-sourcerygxx-4_1-17:1.80
	gdb-csl-20060226-branch-local-2:1.78
	gdb-csl-sourcerygxx-4_1-14:1.78
	binutils-csl-sourcerygxx-4_1-14:1.80
	binutils-csl-sourcerygxx-4_1-15:1.80
	gdb-csl-sourcerygxx-4_1-13:1.78
	binutils-csl-sourcerygxx-4_1-13:1.80
	binutils-2_17:1.80
	gdb-csl-sourcerygxx-4_1-12:1.78
	binutils-csl-sourcerygxx-4_1-12:1.80
	gdb-csl-sourcerygxx-3_4_4-21:1.78
	binutils-csl-sourcerygxx-3_4_4-21:1.80
	gdb_6_5-20060621-release:1.80
	binutils-csl-wrs-linux-3_4_4-24:1.57
	binutils-csl-wrs-linux-3_4_4-23:1.57
	gdb-csl-sourcerygxx-4_1-9:1.78
	binutils-csl-sourcerygxx-4_1-9:1.80
	gdb-csl-sourcerygxx-4_1-8:1.78
	binutils-csl-sourcerygxx-4_1-8:1.80
	gdb-csl-sourcerygxx-4_1-7:1.78
	binutils-csl-sourcerygxx-4_1-7:1.80
	gdb-csl-arm-2006q1-6:1.78
	binutils-csl-arm-2006q1-6:1.80
	gdb-csl-sourcerygxx-4_1-6:1.78
	binutils-csl-sourcerygxx-4_1-6:1.80
	binutils-csl-wrs-linux-3_4_4-22:1.57
	gdb-csl-symbian-6_4_50_20060226-10:1.78
	gdb-csl-symbian-6_4_50_20060226-9:1.78
	gdb-csl-symbian-6_4_50_20060226-8:1.78
	gdb-csl-coldfire-4_1-11:1.78
	binutils-csl-coldfire-4_1-11:1.80
	gdb-csl-sourcerygxx-3_4_4-19:1.78
	binutils-csl-sourcerygxx-3_4_4-19:1.80
	gdb-csl-coldfire-4_1-10:1.78
	gdb_6_5-branch:1.80.0.14
	gdb_6_5-2006-05-14-branchpoint:1.80
	binutils-csl-coldfire-4_1-10:1.80
	gdb-csl-sourcerygxx-4_1-5:1.78
	binutils-csl-sourcerygxx-4_1-5:1.80
	nickrob-async-20060513-branch:1.80.0.12
	nickrob-async-20060513-branchpoint:1.80
	gdb-csl-sourcerygxx-4_1-4:1.78
	binutils-csl-sourcerygxx-4_1-4:1.80
	msnyder-reverse-20060502-branch:1.80.0.10
	msnyder-reverse-20060502-branchpoint:1.80
	binutils-csl-wrs-linux-3_4_4-21:1.57
	gdb-csl-morpho-4_1-4:1.78
	binutils-csl-morpho-4_1-4:1.80
	gdb-csl-sourcerygxx-3_4_4-17:1.78
	binutils-csl-sourcerygxx-3_4_4-17:1.80
	binutils-csl-wrs-linux-3_4_4-20:1.57
	readline_5_1-import-branch:1.80.0.8
	readline_5_1-import-branchpoint:1.80
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.78
	binutils-2_17-branch:1.80.0.6
	binutils-2_17-branchpoint:1.80
	gdb-csl-symbian-20060226-branch:1.78.0.4
	gdb-csl-symbian-20060226-branchpoint:1.78
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.78
	msnyder-reverse-20060331-branch:1.80.0.4
	msnyder-reverse-20060331-branchpoint:1.80
	binutils-csl-2_17-branch:1.80.0.2
	binutils-csl-2_17-branchpoint:1.80
	gdb-csl-available-20060303-branch:1.79.0.2
	gdb-csl-available-20060303-branchpoint:1.79
	gdb-csl-20060226-branch:1.78.0.2
	gdb-csl-20060226-branchpoint:1.78
	gdb_6_4-20051202-release:1.75
	msnyder-fork-checkpoint-branch:1.75.0.6
	msnyder-fork-checkpoint-branchpoint:1.75
	gdb-csl-gxxpro-6_3-branch:1.75.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.75
	gdb_6_4-branch:1.75.0.2
	gdb_6_4-2005-11-01-branchpoint:1.75
	gdb-csl-arm-20051020-branch:1.74.0.2
	gdb-csl-arm-20051020-branchpoint:1.74
	binutils-csl-gxxpro-3_4-branch:1.57.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.57
	binutils-2_16_1:1.57
	msnyder-tracepoint-checkpoint-branch:1.62.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.62
	gdb-csl-arm-20050325-2005-q1b:1.57
	binutils-csl-arm-2005q1b:1.57
	binutils-2_16:1.57
	gdb-csl-arm-20050325-2005-q1a:1.57
	binutils-csl-arm-2005q1a:1.57
	csl-arm-20050325-branch:1.57.0.6
	csl-arm-20050325-branchpoint:1.57
	binutils-csl-arm-2005q1-branch:1.57.0.4
	binutils-csl-arm-2005q1-branchpoint:1.57
	binutils-2_16-branch:1.57.0.2
	binutils-2_16-branchpoint:1.57
	csl-arm-2004-q3d:1.54
	gdb_6_3-20041109-release:1.53
	gdb_6_3-branch:1.53.0.2
	gdb_6_3-20041019-branchpoint:1.53
	csl-arm-2004-q3:1.52
	drow_intercu-merge-20040921:1.52
	drow_intercu-merge-20040915:1.50
	jimb-gdb_6_2-e500-branch:1.47.0.6
	jimb-gdb_6_2-e500-branchpoint:1.47
	gdb_6_2-20040730-release:1.47
	gdb_6_2-branch:1.47.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.47
	gdb_6_1_1-20040616-release:1.39
	binutils-2_15:1.39.6.2
	binutils-2_15-branchpoint:1.39
	csl-arm-2004-q1a:1.44
	csl-arm-2004-q1:1.44
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.44
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.41.0.2
	ezannoni_pie-20040323-branchpoint:1.41
	cagney_tramp-20040321-mergepoint:1.41
	cagney_tramp-20040309-branch:1.39.0.12
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.39.0.8
	drow_intercu-20040221-branchpoint:1.39
	binutils-2_15-branch:1.39.0.6
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	csl-arm-2003-q4:1.39
	drow-cplus-merge-20031224:1.39
	drow-cplus-merge-20031220:1.39
	carlton_dictionary-20031215-merge:1.38
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.36
	gdb_6_0-2003-10-04-release:1.32
	kettenis_sparc-20030918-branch:1.34.0.6
	kettenis_sparc-20030918-branchpoint:1.34
	carlton_dictionary-20030917-merge:1.34
	ezannoni_pie-20030916-branchpoint:1.34
	ezannoni_pie-20030916-branch:1.34.0.4
	cagney_x86i386-20030821-branch:1.34.0.2
	cagney_x86i386-20030821-branchpoint:1.34
	carlton_dictionary-20030805-merge:1.34
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.32.0.14
	gdb_6_0-2003-06-23-branchpoint:1.32
	jimb-ppc64-linux-20030613-branch:1.32.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.32
	binutils-2_14:1.31
	cagney_convert-20030606-branch:1.32.0.10
	cagney_convert-20030606-branchpoint:1.32
	cagney_writestrings-20030508-branch:1.32.0.8
	cagney_writestrings-20030508-branchpoint:1.32
	jimb-ppc64-linux-20030528-branch:1.32.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.32
	carlton_dictionary-20030523-merge:1.32
	cagney_fileio-20030521-branch:1.32.0.4
	cagney_fileio-20030521-branchpoint:1.32
	kettenis_i386newframe-20030517-mergepoint:1.32
	jimb-ppc64-linux-20030509-branch:1.32.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.32
	kettenis_i386newframe-20030504-mergepoint:1.31
	carlton_dictionary-20030430-merge:1.31
	binutils-2_14-branch:1.31.0.22
	binutils-2_14-branchpoint:1.31
	kettenis_i386newframe-20030419-branch:1.31.0.20
	kettenis_i386newframe-20030419-branchpoint:1.31
	carlton_dictionary-20030416-merge:1.31
	cagney_frameaddr-20030409-mergepoint:1.31
	kettenis_i386newframe-20030406-branch:1.31.0.18
	kettenis_i386newframe-20030406-branchpoint:1.31
	cagney_frameaddr-20030403-branchpoint:1.31
	cagney_frameaddr-20030403-branch:1.31.0.16
	cagney_framebase-20030330-mergepoint:1.31
	cagney_framebase-20030326-branch:1.31.0.14
	cagney_framebase-20030326-branchpoint:1.31
	cagney_lazyid-20030317-branch:1.31.0.12
	cagney_lazyid-20030317-branchpoint:1.31
	kettenis-i386newframe-20030316-mergepoint:1.31
	offbyone-20030313-branch:1.31.0.10
	offbyone-20030313-branchpoint:1.31
	kettenis-i386newframe-20030308-branch:1.31.0.8
	kettenis-i386newframe-20030308-branchpoint:1.31
	carlton_dictionary-20030305-merge:1.31
	cagney_offbyone-20030303-branch:1.31.0.6
	cagney_offbyone-20030303-branchpoint:1.31
	carlton_dictionary-20030207-merge:1.31
	interps-20030202-branch:1.31.0.4
	interps-20030202-branchpoint:1.31
	cagney-unwind-20030108-branch:1.31.0.2
	cagney-unwind-20030108-branchpoint:1.31
	binutils-2_13_2_1:1.25.2.1
	binutils-2_13_2:1.25.2.1
	carlton_dictionary-20021223-merge:1.31
	gdb_5_3-2002-12-12-release:1.26
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.25.2.1
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.26.0.12
	drow-cplus-branchpoint:1.26
	kseitz_interps-20020930-merge:1.26
	carlton_dictionary-20020927-merge:1.26
	carlton_dictionary-branch:1.26.0.10
	carlton_dictionary-20020920-branchpoint:1.26
	sid-20020905-branchpoint:1.26
	sid-20020905-branch:1.26.0.8
	gdb_5_3-branch:1.26.0.6
	gdb_5_3-2002-09-04-branchpoint:1.26
	kseitz_interps-20020829-merge:1.26
	cagney_sysregs-20020825-branch:1.26.0.4
	cagney_sysregs-20020825-branchpoint:1.26
	readline_4_3-import-branch:1.26.0.2
	readline_4_3-import-branchpoint:1.26
	binutils-2_13:1.25
	gdb_5_2_1-2002-07-23-release:1.21
	binutils-2_13-branchpoint:1.25
	binutils-2_13-branch:1.25.0.2
	kseitz_interps-20020528-branch:1.23.0.4
	kseitz_interps-20020528-branchpoint:1.23
	cagney_regbuf-20020515-branch:1.23.0.2
	cagney_regbuf-20020515-branchpoint:1.23
	binutils-2_12_1:1.21.2.2
	jimb-macro-020506-branch:1.22.0.2
	jimb-macro-020506-branchpoint:1.22
	gdb_5_2-2002-04-29-release:1.21
	binutils-2_12:1.21
	gdb_5_2-branch:1.21.0.4
	gdb_5_2-2002-03-03-branchpoint:1.21
	binutils-2_12-branch:1.21.0.2
	binutils-2_12-branchpoint:1.21
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.20
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	binutils-2_11_2:1.11.2.1
	binutils-2_11_1:1.11.2.1
	binutils-2_11:1.11
	x86_64versiong3:1.11
	binutils-2_11-branch:1.11.0.2
	insight-precleanup-2001-01-01:1.10
	binutils-2_10_1:1.8
	binutils-2_10:1.8
	gdb-premipsmulti-2000-06-06-branch:1.8.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.8
	gdb_5_0-2000-05-19-release:1.8
	gdb_4_18_2-2000-05-18-release:1.8
	gdb_4_95_1-2000-05-11-snapshot:1.8
	gdb_4_95_0-2000-04-27-snapshot:1.8
	gdb_5_0-2000-04-10-branch:1.8.0.4
	gdb_5_0-2000-04-10-branchpoint:1.8
	binutils-2_10-branch:1.8.0.2
	binutils-2_10-branchpoint:1.8
	binutils_latest_snapshot:1.114
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.114
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2013.02.10.04.36.31;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.109;

1.109
date	2012.06.29.14.45.59;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2012.06.29.07.37.50;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2012.05.16.16.38.28;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.105;

1.105
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2012.03.13.06.04.34;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2011.10.19.07.17.14;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.100;

1.100
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.25.14.53.42;	author hjl;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.18.14.18.28;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.17.18.08.34;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.88;

1.88
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2006.10.17.13.41.46;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.78;

1.78
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.77;

1.77
date	2006.02.21.01.51.59;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.01.04.48.13;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2005.10.06.19.21.13;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2005.08.25.02.32.09;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2005.08.18.01.28.23;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.22.10.27.44;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.20.11.35.01;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.08.06.19.59;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.08.00.26.44;	author hjl;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.04.13.54.36;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.01.11.16.29;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.20.18.12.06;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.07.13.22.48;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.05.14.33.48;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.04.15.53.16;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.04.11.00.12;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.11.17.18.41;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.31.23.13.21;	author bje;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.11.09.32.48;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.21.15.28.23;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.17.07.14.27;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.16.14.52.04;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.25.23.40.55;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.24.08.21.25;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.29.13.46.29;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.25.16.11.07;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.24.04.46.19;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.25.12.48.34;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.20.23.16.39;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.16.01.49.30;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.19.11.43.53;	author nickc;	state Exp;
branches
	1.39.6.1
	1.39.8.1
	1.39.12.1;
next	1.38;

1.38
date	2003.12.03.17.38.48;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.25.14.35.55;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.12.10.26.01;	author amodra;	state Exp;
branches
	1.31.20.1;
next	1.30;

1.30
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.17.02.59.15;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches
	1.26.10.1
	1.26.12.1;
next	1.25;

1.25
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.07.00.16.51;	author amodra;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2002.04.16.04.58.12;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.12.18.17.59.58;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.10.12.08.28;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.12.23.53.31;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.09.47.34;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.08.21.03.59;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.12.21.18.40.21;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.06.18.59.48;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.30.22.16.39;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.14.18.16.05;	author clm;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	99.10.05.00.54.12;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	99.09.14.10.34.02;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.29.22;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.07.35.02;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.102.2.1
date	2012.05.11.12.24.24;	author nickc;	state Exp;
branches;
next	;

1.39.6.1
date	2004.03.16.01.49.52;	author amodra;	state Exp;
branches;
next	1.39.6.2;

1.39.6.2
date	2004.04.08.12.41.41;	author amodra;	state Exp;
branches;
next	;

1.39.8.1
date	2004.03.27.17.37.33;	author drow;	state Exp;
branches;
next	1.39.8.2;

1.39.8.2
date	2004.04.02.16.47.34;	author drow;	state Exp;
branches;
next	1.39.8.3;

1.39.8.3
date	2004.09.16.17.00.23;	author drow;	state Exp;
branches;
next	1.39.8.4;

1.39.8.4
date	2004.09.21.20.44.01;	author drow;	state Exp;
branches;
next	;

1.39.12.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;

1.31.20.1
date	2003.05.18.09.43.41;	author kettenis;	state Exp;
branches;
next	;

1.26.10.1
date	2002.10.11.22.22.47;	author carlton;	state Exp;
branches;
next	1.26.10.2;

1.26.10.2
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.26.10.3;

1.26.10.3
date	2002.12.23.19.37.42;	author carlton;	state Exp;
branches;
next	1.26.10.4;

1.26.10.4
date	2003.05.23.18.40.23;	author carlton;	state Exp;
branches;
next	1.26.10.5;

1.26.10.5
date	2003.06.27.21.49.14;	author carlton;	state Exp;
branches;
next	1.26.10.6;

1.26.10.6
date	2003.08.05.17.12.46;	author carlton;	state Exp;
branches;
next	1.26.10.7;

1.26.10.7
date	2003.11.11.23.50.17;	author carlton;	state Exp;
branches;
next	1.26.10.8;

1.26.10.8
date	2003.12.15.23.59.25;	author carlton;	state Exp;
branches;
next	1.26.10.9;

1.26.10.9
date	2004.01.26.19.11.04;	author carlton;	state Exp;
branches;
next	;

1.26.12.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.26.12.2;

1.26.12.2
date	2003.12.14.20.26.39;	author drow;	state Exp;
branches;
next	1.26.12.3;

1.26.12.3
date	2003.12.20.18.16.46;	author drow;	state Exp;
branches;
next	;

1.25.2.1
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	;

1.23.4.1
date	2002.07.22.21.46.43;	author kseitz;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.21.2.1
date	2002.04.27.08.30.11;	author amodra;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.05.09.11.50.23;	author amodra;	state Exp;
branches;
next	;

1.11.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.114
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@/* M32R-specific support for 32-bit ELF.
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/m32r.h"

#define NOP_INSN		0x7000
#define MAKE_PARALLEL(insn)	((insn) | 0x8000)

/* Use REL instead of RELA to save space.
   This only saves space in libraries and object files, but perhaps
   relocs will be put in ROM?  All in all though, REL relocs are a pain
   to work with.  */
/* #define USE_REL	1

#ifndef USE_REL
#define USE_REL	0
#endif */
/* Use RELA. But use REL to link old objects for backwords compatibility.  */

/* Functions for the M32R ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

/* The nop opcode we use.  */

#define M32R_NOP 0x7000f000

#define PLT_EMPTY   0x10101010  /* RIE  -> RIE */

/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 20
#define PLT_HEADER_SIZE 20

/* The first one entries in a procedure linkage table are reserved,
   and the initial contents are unimportant (we zero them out).
   Subsequent entries look like this. */

#define PLT0_ENTRY_WORD0  0xd6c00000    /* seth r6, #high(.got+4)          */
#define PLT0_ENTRY_WORD1  0x86e60000    /* or3  r6, r6, #low(.got)+4)      */
#define PLT0_ENTRY_WORD2  0x24e626c6    /* ld   r4, @@r6+    -> ld r6, @@r6  */
#define PLT0_ENTRY_WORD3  0x1fc6f000    /* jmp  r6          || pnop        */
#define PLT0_ENTRY_WORD4  PLT_EMPTY     /* RIE             -> RIE          */

#define PLT0_PIC_ENTRY_WORD0  0xa4cc0004 /* ld   r4, @@(4,r12)              */
#define PLT0_PIC_ENTRY_WORD1  0xa6cc0008 /* ld   r6, @@(8,r12)              */
#define PLT0_PIC_ENTRY_WORD2  0x1fc6f000 /* jmp  r6         || nop         */
#define PLT0_PIC_ENTRY_WORD3  PLT_EMPTY  /* RIE             -> RIE         */
#define PLT0_PIC_ENTRY_WORD4  PLT_EMPTY  /* RIE             -> RIE         */

#define PLT_ENTRY_WORD0  0xe6000000 /* ld24 r6, .name_in_GOT                */
#define PLT_ENTRY_WORD1  0x06acf000 /* add  r6, r12          || nop         */
#define PLT_ENTRY_WORD0b 0xd6c00000 /* seth r6, #high(.name_in_GOT)         */
#define PLT_ENTRY_WORD1b 0x86e60000 /* or3  r6, r6, #low(.name_in_GOT)      */
#define PLT_ENTRY_WORD2  0x26c61fc6 /* ld  r6, @@r6           -> jmp r6      */
#define PLT_ENTRY_WORD3  0xe5000000 /* ld24 r5, $offset                     */
#define PLT_ENTRY_WORD4  0xff000000 /* bra  .plt0.                          */


/* Utility to actually perform an R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_do_10_pcrel_reloc (bfd *abfd,
			    reloc_howto_type *howto,
			    asection *input_section,
			    bfd_byte *data,
			    bfd_vma offset,
			    asection *symbol_section ATTRIBUTE_UNUSED,
			    bfd_vma symbol_value,
			    bfd_vma addend)
{
  bfd_signed_vma relocation;
  unsigned long x;
  bfd_reloc_status_type status;

  /* Sanity check the address (offset in section).  */
  if (offset > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  relocation = symbol_value + addend;
  /* Make it pc relative.  */
  relocation -=	(input_section->output_section->vma
		 + input_section->output_offset);
  /* These jumps mask off the lower two bits of the current address
     before doing pcrel calculations.  */
  relocation -= (offset & -(bfd_vma) 4);

  if (relocation < -0x200 || relocation > 0x1ff)
    status = bfd_reloc_overflow;
  else
    status = bfd_reloc_ok;

  x = bfd_get_16 (abfd, data + offset);
  relocation >>= howto->rightshift;
  relocation <<= howto->bitpos;
  x = (x & ~howto->dst_mask) | (((x & howto->src_mask) + relocation) & howto->dst_mask);
  bfd_put_16 (abfd, (bfd_vma) x, data + offset);

  return status;
}

/* Handle the R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_10_pcrel_reloc (bfd * abfd,
			 arelent * reloc_entry,
			 asymbol * symbol,
			 void * data,
			 asection * input_section,
			 bfd * output_bfd,
			 char ** error_message ATTRIBUTE_UNUSED)
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    /* FIXME: See bfd_perform_relocation.  Is this right?  */
    return bfd_reloc_continue;

  return m32r_elf_do_10_pcrel_reloc (abfd, reloc_entry->howto,
				     input_section,
				     data, reloc_entry->address,
				     symbol->section,
				     (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset),
				     reloc_entry->addend);
}

/* Do generic partial_inplace relocation.
   This is a local replacement for bfd_elf_generic_reloc.  */

static bfd_reloc_status_type
m32r_elf_generic_reloc (bfd *input_bfd,
			arelent *reloc_entry,
			asymbol *symbol,
			void * data,
			asection *input_section,
			bfd *output_bfd,
			char **error_message ATTRIBUTE_UNUSED)
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  bfd_byte *inplace_address;

  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Now do the reloc in the usual way.
     ??? It would be nice to call bfd_elf_generic_reloc here,
     but we have partial_inplace set.  bfd_elf_generic_reloc will
     pass the handling back to bfd_install_relocation which will install
     a section relative addend which is wrong.  */

  /* Sanity check the address (offset in section).  */
  if (reloc_entry->address > bfd_get_section_limit (input_bfd, input_section))
    return bfd_reloc_outofrange;

  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == NULL)
    ret = bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section)
      || output_bfd != NULL)
    relocation = 0;
  else
    relocation = symbol->value;

  /* Only do this for a final link.  */
  if (output_bfd == NULL)
    {
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
    }

  relocation += reloc_entry->addend;
  inplace_address = (bfd_byte *) data + reloc_entry->address;

#define DOIT(x) 					\
  x = ( (x & ~reloc_entry->howto->dst_mask) | 		\
  (((x & reloc_entry->howto->src_mask) +  relocation) &	\
  reloc_entry->howto->dst_mask))

  switch (reloc_entry->howto->size)
    {
    case 1:
      {
	short x = bfd_get_16 (input_bfd, inplace_address);
	DOIT (x);
      	bfd_put_16 (input_bfd, (bfd_vma) x, inplace_address);
      }
      break;
    case 2:
      {
	unsigned long x = bfd_get_32 (input_bfd, inplace_address);
	DOIT (x);
      	bfd_put_32 (input_bfd, (bfd_vma)x , inplace_address);
      }
      break;
    default:
      BFD_ASSERT (0);
    }

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Handle the R_M32R_SDA16 reloc.
   This reloc is used to compute the address of objects in the small data area
   and to perform loads and stores from that area.
   The lower 16 bits are sign extended and added to the register specified
   in the instruction, which is assumed to point to _SDA_BASE_.  */

static bfd_reloc_status_type
m32r_elf_sda16_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		      arelent *reloc_entry,
		      asymbol *symbol,
		      void * data ATTRIBUTE_UNUSED,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message ATTRIBUTE_UNUSED)
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    /* FIXME: See bfd_perform_relocation.  Is this right?  */
    return bfd_reloc_continue;

  /* FIXME: not sure what to do here yet.  But then again, the linker
     may never call us.  */
  abort ();
}


/* Handle the R_M32R_HI16_[SU]LO relocs.
   HI16_SLO is for the add3 and load/store with displacement instructions.
   HI16_ULO is for the or3 instruction.
   For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to
   the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then
   we must add one to the high 16 bytes (which will get subtracted off when
   the low 16 bits are added).
   These relocs have to be done in combination with an R_M32R_LO16 reloc
   because there is a carry from the LO16 to the HI16.  Here we just save
   the information we need; we do the actual relocation when we see the LO16.
   This code is copied from the elf32-mips.c.  We also support an arbitrary
   number of HI16 relocs to be associated with a single LO16 reloc.  The
   assembler sorts the relocs to ensure each HI16 immediately precedes its
   LO16.  However if there are multiple copies, the assembler may not find
   the real LO16 so it picks the first one it finds.  */

struct m32r_hi16
{
  struct m32r_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct m32r_hi16 *m32r_hi16_list;

static bfd_reloc_status_type
m32r_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		     arelent *reloc_entry,
		     asymbol *symbol,
		     void * data,
		     asection *input_section,
		     bfd *output_bfd,
		     char **error_message ATTRIBUTE_UNUSED)
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct m32r_hi16 *n;

  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Sanity check the address (offset in section).  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == NULL)
    ret = bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  /* Save the information, and let LO16 do the actual relocation.  */
  n = bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = m32r_hi16_list;
  m32r_hi16_list = n;

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Handle an M32R ELF HI16 reloc.  */

static void
m32r_elf_relocate_hi16 (bfd *input_bfd,
			int type,
			Elf_Internal_Rela *relhi,
			Elf_Internal_Rela *rello,
			bfd_byte *contents,
			bfd_vma addend)
{
  unsigned long insn;
  bfd_vma addlo;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  if (type == R_M32R_HI16_SLO)
    addlo = ((addlo & 0xffff) ^ 0x8000) - 0x8000;
  else
    addlo &= 0xffff;

  addend += ((insn & 0xffff) << 16) + addlo;

  /* Reaccount for sign extension of low part.  */
  if (type == R_M32R_HI16_SLO
      && (addend & 0x8000) != 0)
    addend += 0x10000;

  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | ((addend >> 16) & 0xffff),
	      contents + relhi->r_offset);
}

/* Do an R_M32R_LO16 relocation.  This is a straightforward 16 bit
   inplace relocation; this function exists in order to do the
   R_M32R_HI16_[SU]LO relocation described above.  */

static bfd_reloc_status_type
m32r_elf_lo16_reloc (bfd *input_bfd,
		     arelent *reloc_entry,
		     asymbol *symbol,
		     void * data,
		     asection *input_section,
		     bfd *output_bfd,
		     char **error_message)
{
  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (m32r_hi16_list != NULL)
    {
      struct m32r_hi16 *l;

      l = m32r_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct m32r_hi16 *next;

	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (input_bfd, l->addr);
	  vallo = ((bfd_get_32 (input_bfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* Reaccount for sign extension of low part.  */
	  if ((val & 0x8000) != 0)
	    val += 0x10000;

	  insn = (insn &~ (bfd_vma) 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, l->addr);

	  next = l->next;
	  free (l);
	  l = next;
	}

      m32r_hi16_list = NULL;
    }

  /* Now do the LO16 reloc in the usual way.
     ??? It would be nice to call bfd_elf_generic_reloc here,
     but we have partial_inplace set.  bfd_elf_generic_reloc will
     pass the handling back to bfd_install_relocation which will install
     a section relative addend which is wrong.  */
  return m32r_elf_generic_reloc (input_bfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}


static reloc_howto_type m32r_elf_howto_table[] =
{
  /* This reloc does nothing.  */
  HOWTO (R_M32R_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 24 bit address.  */
  HOWTO (R_M32R_24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_24",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative 10-bit relocation, shifted by 2.
     This reloc is complicated because relocations are relative to pc & -4.
     i.e. branches in the right insn slot use the address of the left insn
     slot for pc.  */
  /* ??? It's not clear whether this should have partial_inplace set or not.
     Branch relaxing in the assembler can store the addend in the insn,
     and if bfd_install_relocation gets called the addend may get added
     again.  */
  HOWTO (R_M32R_10_PCREL,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL",	/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 26 bit relocation, right shifted by 2.  */
  /* ??? It's not clear whether this should have partial_inplace set or not.
     Branch relaxing in the assembler can store the addend in the insn,
     and if bfd_install_relocation gets called the addend may get added
     again.  */
  HOWTO (R_M32R_26_PCREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_hi16_reloc,	/* special_function */
	 "R_M32R_HI16_ULO",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_hi16_reloc,	/* special_function */
	 "R_M32R_HI16_SLO",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_lo16_reloc,	/* special_function */
	 "R_M32R_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_sda16_reloc,	/* special_function */
	 "R_M32R_SDA16",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_M32R_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_M32R_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),
  EMPTY_HOWTO (25),
  EMPTY_HOWTO (26),
  EMPTY_HOWTO (27),
  EMPTY_HOWTO (28),
  EMPTY_HOWTO (29),
  EMPTY_HOWTO (30),
  EMPTY_HOWTO (31),
  EMPTY_HOWTO (32),

  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16_RELA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_32_RELA",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 24 bit address.  */
  HOWTO (R_M32R_24_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_24_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_10_PCREL_RELA,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL_RELA",/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 26 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_26_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_ULO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_SLO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_LO16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_SDA16_RELA",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_M32R_RELA_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_RELA_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_M32R_RELA_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_RELA_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* A 32 bit PC relative relocation.  */
  HOWTO (R_M32R_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_REL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (46),
  EMPTY_HOWTO (47),

  /* Like R_M32R_24, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOT24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_PCREL, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_M32R_26_PLTREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PLTREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_M32R_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_24, but used when setting global offset table
     entries.  */
  HOWTO (R_M32R_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_M32R_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_M32R_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_RELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative 24-bit relocation used when setting PIC offset
     table register. */
  HOWTO (R_M32R_GOTPC24,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTPC24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_HI_ULO",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_HI_SLO",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* Map BFD reloc types to M32R ELF reloc types.  */

struct m32r_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

#ifdef USE_M32R_OLD_RELOC
static const struct m32r_reloc_map m32r_reloc_map_old[] =
{
  { BFD_RELOC_NONE, R_M32R_NONE },
  { BFD_RELOC_16, R_M32R_16 },
  { BFD_RELOC_32, R_M32R_32 },
  { BFD_RELOC_M32R_24, R_M32R_24 },
  { BFD_RELOC_M32R_10_PCREL, R_M32R_10_PCREL },
  { BFD_RELOC_M32R_18_PCREL, R_M32R_18_PCREL },
  { BFD_RELOC_M32R_26_PCREL, R_M32R_26_PCREL },
  { BFD_RELOC_M32R_HI16_ULO, R_M32R_HI16_ULO },
  { BFD_RELOC_M32R_HI16_SLO, R_M32R_HI16_SLO },
  { BFD_RELOC_M32R_LO16, R_M32R_LO16 },
  { BFD_RELOC_M32R_SDA16, R_M32R_SDA16 },
  { BFD_RELOC_VTABLE_INHERIT, R_M32R_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_M32R_GNU_VTENTRY },
};
#else
static const struct m32r_reloc_map m32r_reloc_map[] =
{
  { BFD_RELOC_NONE, R_M32R_NONE },
  { BFD_RELOC_16, R_M32R_16_RELA },
  { BFD_RELOC_32, R_M32R_32_RELA },
  { BFD_RELOC_M32R_24, R_M32R_24_RELA },
  { BFD_RELOC_M32R_10_PCREL, R_M32R_10_PCREL_RELA },
  { BFD_RELOC_M32R_18_PCREL, R_M32R_18_PCREL_RELA },
  { BFD_RELOC_M32R_26_PCREL, R_M32R_26_PCREL_RELA },
  { BFD_RELOC_M32R_HI16_ULO, R_M32R_HI16_ULO_RELA },
  { BFD_RELOC_M32R_HI16_SLO, R_M32R_HI16_SLO_RELA },
  { BFD_RELOC_M32R_LO16, R_M32R_LO16_RELA },
  { BFD_RELOC_M32R_SDA16, R_M32R_SDA16_RELA },
  { BFD_RELOC_VTABLE_INHERIT, R_M32R_RELA_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_M32R_RELA_GNU_VTENTRY },
  { BFD_RELOC_32_PCREL, R_M32R_REL32 },

  { BFD_RELOC_M32R_GOT24, R_M32R_GOT24 },
  { BFD_RELOC_M32R_26_PLTREL, R_M32R_26_PLTREL },
  { BFD_RELOC_M32R_COPY, R_M32R_COPY },
  { BFD_RELOC_M32R_GLOB_DAT, R_M32R_GLOB_DAT },
  { BFD_RELOC_M32R_JMP_SLOT, R_M32R_JMP_SLOT },
  { BFD_RELOC_M32R_RELATIVE, R_M32R_RELATIVE },
  { BFD_RELOC_M32R_GOTOFF, R_M32R_GOTOFF },
  { BFD_RELOC_M32R_GOTPC24, R_M32R_GOTPC24 },
  { BFD_RELOC_M32R_GOT16_HI_ULO, R_M32R_GOT16_HI_ULO },
  { BFD_RELOC_M32R_GOT16_HI_SLO, R_M32R_GOT16_HI_SLO },
  { BFD_RELOC_M32R_GOT16_LO, R_M32R_GOT16_LO },
  { BFD_RELOC_M32R_GOTPC_HI_ULO, R_M32R_GOTPC_HI_ULO },
  { BFD_RELOC_M32R_GOTPC_HI_SLO, R_M32R_GOTPC_HI_SLO },
  { BFD_RELOC_M32R_GOTPC_LO, R_M32R_GOTPC_LO },
  { BFD_RELOC_M32R_GOTOFF_HI_ULO, R_M32R_GOTOFF_HI_ULO },
  { BFD_RELOC_M32R_GOTOFF_HI_SLO, R_M32R_GOTOFF_HI_SLO },
  { BFD_RELOC_M32R_GOTOFF_LO, R_M32R_GOTOFF_LO },
};
#endif

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;

#ifdef USE_M32R_OLD_RELOC
  for (i = 0;
       i < sizeof (m32r_reloc_map_old) / sizeof (struct m32r_reloc_map);
       i++)
    if (m32r_reloc_map_old[i].bfd_reloc_val == code)
      return &m32r_elf_howto_table[m32r_reloc_map_old[i].elf_reloc_val];

#else /* ! USE_M32R_OLD_RELOC */

  for (i = 0;
       i < sizeof (m32r_reloc_map) / sizeof (struct m32r_reloc_map);
       i++)
    if (m32r_reloc_map[i].bfd_reloc_val == code)
      return &m32r_elf_howto_table[m32r_reloc_map[i].elf_reloc_val];
#endif

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (m32r_elf_howto_table) / sizeof (m32r_elf_howto_table[0]);
       i++)
    if (m32r_elf_howto_table[i].name != NULL
	&& strcasecmp (m32r_elf_howto_table[i].name, r_name) == 0)
      return &m32r_elf_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an M32R ELF reloc.  */

static void
m32r_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) <= (unsigned int) R_M32R_GNU_VTENTRY);
  cache_ptr->howto = &m32r_elf_howto_table[r_type];
}

static void
m32r_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		    arelent *cache_ptr,
		    Elf_Internal_Rela *dst)
{
  BFD_ASSERT ((ELF32_R_TYPE(dst->r_info) == (unsigned int) R_M32R_NONE)
              || ((ELF32_R_TYPE(dst->r_info) > (unsigned int) R_M32R_GNU_VTENTRY)
                  && (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_M32R_max)));
  cache_ptr->howto = &m32r_elf_howto_table[ELF32_R_TYPE(dst->r_info)];
}


/* Given a BFD section, try to locate the corresponding ELF section
   index.  */

static bfd_boolean
_bfd_m32r_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					asection *sec,
					int *retval)
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    {
      *retval = SHN_M32R_SCOMMON;
      return TRUE;
    }
  return FALSE;
}

/* M32R ELF uses two common sections.  One is the usual one, and the other
   is for small objects.  All the small objects are kept together, and then
   referenced via one register, which yields faster assembler code.  It is
   up to the compiler to emit an instruction to load the register with
   _SDA_BASE.  This is what we use for the small common section.  This
   approach is copied from elf32-mips.c.  */
static asection m32r_elf_scom_section;
static asymbol m32r_elf_scom_symbol;
static asymbol *m32r_elf_scom_symbol_ptr;

/* Handle the special M32R section numbers that a symbol may use.  */

static void
_bfd_m32r_elf_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED, asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;

  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_M32R_SCOMMON:
      if (m32r_elf_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  m32r_elf_scom_section.name = ".scommon";
	  m32r_elf_scom_section.flags = SEC_IS_COMMON;
	  m32r_elf_scom_section.output_section = &m32r_elf_scom_section;
	  m32r_elf_scom_section.symbol = &m32r_elf_scom_symbol;
	  m32r_elf_scom_section.symbol_ptr_ptr = &m32r_elf_scom_symbol_ptr;
	  m32r_elf_scom_symbol.name = ".scommon";
	  m32r_elf_scom_symbol.flags = BSF_SECTION_SYM;
	  m32r_elf_scom_symbol.section = &m32r_elf_scom_section;
	  m32r_elf_scom_symbol_ptr = &m32r_elf_scom_symbol;
	}
      asym->section = &m32r_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;
    }
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special M32R section numbers here.
   We also keep watching for whether we need to create the sdata special
   linker sections.  */

static bfd_boolean
m32r_elf_add_symbol_hook (bfd *abfd,
			  struct bfd_link_info *info,
			  Elf_Internal_Sym *sym,
			  const char **namep,
			  flagword *flagsp ATTRIBUTE_UNUSED,
			  asection **secp,
			  bfd_vma *valp)
{
  if (! info->relocatable
      && (*namep)[0] == '_' && (*namep)[1] == 'S'
      && strcmp (*namep, "_SDA_BASE_") == 0
      && is_elf_hash_table (info->hash))
    {
      /* This is simpler than using _bfd_elf_create_linker_section
	 (our needs are simpler than ppc's needs).  Also
	 _bfd_elf_create_linker_section currently has a bug where if a .sdata
	 section already exists a new one is created that follows it which
	 screws of _SDA_BASE_ address calcs because output_offset != 0.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;
      asection *s = bfd_get_section_by_name (abfd, ".sdata");

      /* The following code was cobbled from elf32-ppc.c and elflink.c.  */
      if (s == NULL)
	{
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);

	  s = bfd_make_section_anyway_with_flags (abfd, ".sdata",
						  flags);
	  if (s == NULL)
	    return FALSE;
	  if (! bfd_set_section_alignment (abfd, s, 2))
	    return FALSE;
	}

      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol (info,
						 abfd,
						 "_SDA_BASE_",
						 BSF_GLOBAL,
						 s,
						 (bfd_vma) 32768,
						 NULL,
						 FALSE,
						 get_elf_backend_data (abfd)->collect,
						 &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->type = STT_OBJECT;
    }

  switch (sym->st_shndx)
    {
    case SHN_M32R_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

/* We have to figure out the SDA_BASE value, so that we can adjust the
   symbol value correctly.  We look up the symbol _SDA_BASE_ in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
m32r_elf_final_sda_base (bfd *output_bfd,
			 struct bfd_link_info *info,
			 const char **error_message,
			 bfd_vma *psb)
{
  if (elf_gp (output_bfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_defined)
	elf_gp (output_bfd) = (h->u.def.value
			       + h->u.def.section->output_section->vma
			       + h->u.def.section->output_offset);
      else
	{
	  /* Only get the error once.  */
	  *psb = elf_gp (output_bfd) = 4;
	  *error_message =
	    (const char *) _("SDA relocation when _SDA_BASE_ not defined");
	  return bfd_reloc_dangerous;
	}
    }
  *psb = elf_gp (output_bfd);
  return bfd_reloc_ok;
}

/* Return size of a PLT entry.  */
#define elf_m32r_sizeof_plt(info) PLT_ENTRY_SIZE

/* The m32r linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_m32r_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_m32r_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* The sh linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_m32r_dyn_relocs
{
  struct elf_m32r_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};


/* m32r ELF linker hash entry.  */

struct elf_m32r_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_m32r_dyn_relocs *dyn_relocs;
};

/* m32r ELF linker hash table.  */

struct elf_m32r_link_hash_table
{
  struct elf_link_hash_table root;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

/* Traverse an m32r ELF linker hash table.  */

#define m32r_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the m32r ELF linker hash table from a link_info structure.  */

#define m32r_elf_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == M32R_ELF_DATA ? ((struct elf_m32r_link_hash_table *) ((p)->hash)) : NULL)

/* Create an entry in an m32r ELF linker hash table.  */

static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  struct elf_m32r_link_hash_entry *ret =
    (struct elf_m32r_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table,
			     sizeof (struct elf_m32r_link_hash_entry));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_m32r_link_hash_entry *)
         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
                                     table, string));
  if (ret != NULL)
    {
      struct elf_m32r_link_hash_entry *eh;

      eh = (struct elf_m32r_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an m32r ELF linker hash table.  */

static struct bfd_link_hash_table *
m32r_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_m32r_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_m32r_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      m32r_elf_link_hash_newfunc,
				      sizeof (struct elf_m32r_link_hash_entry),
				      M32R_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf_m32r_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  htab->sgot = bfd_get_linker_section (dynobj, ".got");
  htab->sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
  htab->srelgot = bfd_get_linker_section (dynobj, ".rela.got");
  if (! htab->sgot || ! htab->sgotplt || ! htab->srelgot)
    abort ();

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

static bfd_boolean
m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_m32r_link_hash_table *htab;
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign = 2; /* 32bit */

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
           | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  htab->splt = s;
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
         .plt section.  */
      struct bfd_link_hash_entry *bh = NULL;
      struct elf_link_hash_entry *h;

      if (! (_bfd_generic_link_add_one_symbol
             (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
              (bfd_vma) 0, NULL, FALSE,
              get_elf_backend_data (abfd)->collect, &bh)))
        return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      htab->root.hplt = h;

      if (info->shared
          && ! bfd_elf_link_record_dynamic_symbol (info, h))
        return FALSE;
    }

  s = bfd_make_section_anyway_with_flags (abfd,
					  bed->default_use_rela_p
					  ? ".rela.plt" : ".rel.plt",
					  flags | SEC_READONLY);
  htab->srelplt = s;
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (htab->sgot == NULL
      && ! create_got_section (abfd, info))
    return FALSE;

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
         by dynamic objects, are referenced by regular objects, and are
         not functions.  We must allocate space for them in the process
         image and use a R_*_COPY reloc to tell the dynamic linker to
         initialize them at run time.  The linker script puts the .dynbss
         section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      SEC_ALLOC | SEC_LINKER_CREATED);
      htab->sdynbss = s;
      if (s == NULL)
        return FALSE;
      /* The .rel[a].bss section holds copy relocs.  This section is not
         normally needed.  We need to create it here, though, so that the
         linker will map it to an output section.  We can't just create it
         only if we need it, because we will not know whether we need it
         until we have seen all the input files, and the first time the
         main linker code calls BFD after examining all the input files
         (size_dynamic_sections) the input sections have already been
         mapped to the output sections.  If the section turns out not to
         be needed, we can discard it later.  We will never need this
         section when generating a shared object, since they do not use
         copy relocs.  */
      if (! info->shared)
        {
          s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->default_use_rela_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
          htab->srelbss = s;
          if (s == NULL
              || ! bfd_set_section_alignment (abfd, s, ptralign))
            return FALSE;
        }
    }

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
m32r_elf_copy_indirect_symbol (struct bfd_link_info *info,
                               struct elf_link_hash_entry *dir,
                               struct elf_link_hash_entry *ind)
{
  struct elf_m32r_link_hash_entry * edir;
  struct elf_m32r_link_hash_entry * eind;

  edir = (struct elf_m32r_link_hash_entry *) dir;
  eind = (struct elf_m32r_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
        {
          struct elf_m32r_dyn_relocs **pp;
          struct elf_m32r_dyn_relocs *p;

          /* Add reloc counts against the indirect sym to the direct sym
             list.  Merge any entries against the same section.  */
          for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
            {
              struct elf_m32r_dyn_relocs *q;

              for (q = edir->dyn_relocs; q != NULL; q = q->next)
                if (q->sec == p->sec)
                  {
                    q->pc_count += p->pc_count;
                    q->count += p->count;
                    *pp = p->next;
                    break;
                  }
              if (q == NULL)
                pp = &p->next;
            }
          *pp = edir->dyn_relocs;
        }

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}


/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
m32r_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h)
{
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;
  bfd *dynobj;
  asection *s;

#ifdef DEBUG_PIC
  printf ("m32r_elf_adjust_dynamic_symbol()\n");
#endif

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
              && (h->needs_plt
                  || h->u.weakdef != NULL
                  || (h->def_dynamic
                      && h->ref_regular
                      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (! info->shared
          && !h->def_dynamic
          && !h->ref_dynamic
	  && h->root.type != bfd_link_hash_undefweak
	  && h->root.type != bfd_link_hash_undefined)
        {
          /* This case can occur if we saw a PLT reloc in an input
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PCREL
             reloc instead.  */
          h->plt.offset = (bfd_vma) -1;
          h->needs_plt = 0;
        }

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
        break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  s = htab->sdynbss;
  BFD_ASSERT (s != NULL);

  /* We must generate a R_M32R_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = htab->srelbss;
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info;
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  eh = (struct elf_m32r_link_hash_entry *) h;

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && !h->forced_local)
        {
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
            return FALSE;
        }

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
        {
          asection *s = htab->splt;

          /* If this is the first .plt entry, make room for the special
             first entry.  */
          if (s->size == 0)
            s->size += PLT_ENTRY_SIZE;

          h->plt.offset = s->size;

          /* If this symbol is not defined in a regular file, and we are
             not generating a shared library, then set the symbol to this
             location in the .plt.  This is required to make function
             pointers compare as equal between the normal executable and
             the shared library.  */
          if (! info->shared
              && !h->def_regular)
            {
              h->root.u.def.section = s;
              h->root.u.def.value = h->plt.offset;
            }

          /* Make room for this entry.  */
          s->size += PLT_ENTRY_SIZE;

          /* We also need to make an entry in the .got.plt section, which
             will be placed in the .got section by the linker script.  */
          htab->sgotplt->size += 4;

          /* We also need to make an entry in the .rel.plt section.  */
          htab->srelplt->size += sizeof (Elf32_External_Rela);
        }
      else
        {
          h->plt.offset = (bfd_vma) -1;
          h->needs_plt = 0;
        }
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && !h->forced_local)
        {
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
            return FALSE;
        }

      s = htab->sgot;

      h->got.offset = s->size;
      s->size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
        htab->srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if (h->def_regular
          && (h->forced_local
              || info->symbolic))
        {
          struct elf_m32r_dyn_relocs **pp;

          for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
            {
              p->count -= p->pc_count;
              p->pc_count = 0;
              if (p->count == 0)
                *pp = p->next;
              else
                pp = &p->next;
            }
        }

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
         symbols which turn out to need copy relocs or are not
         dynamic.  */

      if (!h->non_got_ref
          && ((h->def_dynamic
               && !h->def_regular)
              || (htab->root.dynamic_sections_created
                  && (h->root.type == bfd_link_hash_undefweak
                      || h->root.type == bfd_link_hash_undefined))))
        {
          /* Make sure this symbol is output as a dynamic symbol.
             Undefined weak syms won't yet be marked as dynamic.  */
          if (h->dynindx == -1
              && !h->forced_local)
            {
              if (! bfd_elf_link_record_dynamic_symbol (info, h))
                return FALSE;
            }

          /* If that succeeded, we know we'll be keeping all the
             relocs.  */
          if (h->dynindx != -1)
            goto keep;
        }

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
        {
          struct bfd_link_info *info = (struct bfd_link_info *) inf;

          info->flags |= DF_TEXTREL;

          /* Not an error, just cut short the traversal.  */
          return FALSE;
        }
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info)
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;

#ifdef DEBUG_PIC
  printf ("m32r_elf_size_dynamic_sections()\n");
#endif

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->root.dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (htab->root.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
        continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
        {
          struct elf_m32r_dyn_relocs *p;

          for (p = ((struct elf_m32r_dyn_relocs *)
                    elf_section_data (s)->local_dynrel);
               p != NULL;
               p = p->next)
            {
              if (! bfd_is_abs_section (p->sec)
                  && bfd_is_abs_section (p->sec->output_section))
                {
                  /* Input section has been discarded, either because
                     it is a copy of a linkonce section or due to
                     linker script /DISCARD/, so we'll be discarding
                     the relocs too.  */
                }
              else if (p->count != 0)
                {
                  srel = elf_section_data (p->sec)->sreloc;
                  srel->size += p->count * sizeof (Elf32_External_Rela);
                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
                    info->flags |= DF_TEXTREL;
                }
            }
        }

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
        continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
        {
          if (*local_got > 0)
            {
              *local_got = s->size;
              s->size += 4;
              if (info->shared)
                srel->size += sizeof (Elf32_External_Rela);
            }
          else
            *local_got = (bfd_vma) -1;
        }
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
        continue;

      if (s == htab->splt
          || s == htab->sgot
          || s == htab->sgotplt
	  || s == htab->sdynbss)
        {
          /* Strip this section if we don't need it; see the
             comment below.  */
        }
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
        {
          if (s->size != 0 && s != htab->srelplt)
            relocs = TRUE;

          /* We use the reloc_count field as a counter if we need
             to copy relocs into the output file.  */
          s->reloc_count = 0;
        }
      else
	/* It's not one of our sections, so don't allocate space.  */
	continue;

      if (s->size == 0)
        {
          /* If we don't need this section, strip it from the
             output file.  This is mostly to handle .rela.bss and
             .rela.plt.  We must create both sections in
             create_dynamic_sections, because they must be created
             before the linker maps input sections to output
             sections.  The linker does that before
             adjust_dynamic_symbol is called, and it is that
             function which decides whether anything needs to go
             into these sections.  */
          s->flags |= SEC_EXCLUDE;
          continue;
        }

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
         here in case unused entries are not reclaimed before the
         section's contents are written out.  This should not happen,
         but this way if it does, we get a R_M32R_NONE reloc instead
         of garbage.  */
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
        return FALSE;
    }

  if (htab->root.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in m32r_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

     if (info->executable)
	{
	  if (! add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->splt->size != 0)
        {
          if (! add_dynamic_entry (DT_PLTGOT, 0)
              || ! add_dynamic_entry (DT_PLTRELSZ, 0)
              || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
              || ! add_dynamic_entry (DT_JMPREL, 0))
            return FALSE;
        }

      if (relocs)
        {
          if (! add_dynamic_entry (DT_RELA, 0)
              || ! add_dynamic_entry (DT_RELASZ, 0)
              || ! add_dynamic_entry (DT_RELAENT,
                                      sizeof (Elf32_External_Rela)))
            return FALSE;

          /* If any dynamic relocs apply to a read-only section,
             then we need a DT_TEXTREL entry.  */
          if ((info->flags & DF_TEXTREL) == 0)
            elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
                                    info);

          if ((info->flags & DF_TEXTREL) != 0)
            {
              if (! add_dynamic_entry (DT_TEXTREL, 0))
                return FALSE;
            }
        }
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Relocate an M32R/D ELF section.
   There is some attempt to make this function usable for many architectures,
   both for RELA and REL type relocs, if only to serve as a learning tool.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjust the section contents as
   necessary, and (if using Rela relocs and generating a
   relocatable output file) adjusting the reloc addend as
   necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
  Elf_Internal_Rela *rel, *relend;
  /* Assume success.  */
  bfd_boolean ret = TRUE;
  struct elf_m32r_link_hash_table *htab = m32r_elf_hash_table (info);
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot, *splt, *sreloc;
  bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);

  if (htab == NULL)
    return FALSE;

  dynobj = htab->root.dynobj;
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = htab->sgot;
  splt = htab->splt;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      /* We can't modify r_addend here as elf_link_input_bfd has an assert to
         ensure it's zero (we use REL relocs, not RELA).  Therefore this
         should be assigning zero to `addend', but for clarity we use
         `r_addend'.  */
      bfd_vma addend = rel->r_addend;
      bfd_vma offset = rel->r_offset;
      bfd_vma relocation;
      Elf_Internal_Sym *sym;
      asection *sec;
      const char *sym_name;
      bfd_reloc_status_type r;
      const char *errmsg = NULL;
      bfd_boolean use_rel = FALSE;

      h = NULL;
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_M32R_max)
	{
	  (*_bfd_error_handler) (_("%B: unknown relocation type %d"),
				 input_bfd,
				 (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	  continue;
	}

      if (   r_type == R_M32R_GNU_VTENTRY
          || r_type == R_M32R_GNU_VTINHERIT
          || r_type == R_M32R_NONE
          || r_type == R_M32R_RELA_GNU_VTENTRY
          || r_type == R_M32R_RELA_GNU_VTINHERIT)
        continue;

      if (r_type <= R_M32R_GNU_VTENTRY)
        use_rel = TRUE;

      howto = m32r_elf_howto_table + r_type;
      r_symndx = ELF32_R_SYM (rel->r_info);

      sym = NULL;
      sec = NULL;
      h = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* Local symbol.  */
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  sym_name = "<local symbol>";

	  if (!use_rel)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	      addend = rel->r_addend;
	    }
	  else
	    {
	      relocation = (sec->output_section->vma
			    + sec->output_offset
			    + sym->st_value);
	    }
	}
      else
	{
	  /* External symbol.  */
	  relocation = 0;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  sym_name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      bfd_boolean dyn;
	      sec = h->root.u.def.section;

	      dyn = htab->root.dynamic_sections_created;
	      sec = h->root.u.def.section;
	      if (r_type == R_M32R_GOTPC24
		  || (r_type == R_M32R_GOTPC_HI_ULO
		      || r_type == R_M32R_GOTPC_HI_SLO
		      || r_type == R_M32R_GOTPC_LO)
		  || (r_type == R_M32R_26_PLTREL
		      && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_M32R_GOT24
		       || r_type == R_M32R_GOT16_HI_ULO
		       || r_type == R_M32R_GOT16_HI_SLO
		       || r_type == R_M32R_GOT16_LO)
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
							  info->shared, h)
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && (((r_type == R_M32R_16_RELA
			    || r_type == R_M32R_32_RELA
			    || r_type == R_M32R_24_RELA
			    || r_type == R_M32R_HI16_ULO_RELA
			    || r_type == R_M32R_HI16_SLO_RELA
			    || r_type == R_M32R_LO16_RELA)
			   && !h->forced_local)
			  || r_type == R_M32R_REL32
			  || r_type == R_M32R_10_PCREL_RELA
			  || r_type == R_M32R_18_PCREL_RELA
			  || r_type == R_M32R_26_PCREL_RELA)
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_M32R_16(24,32) relocations
			     in its sections against symbols defined
			     externally in shared libraries.  We can't do
			     anything with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && h->def_dynamic))))
		{
		  /* In these cases, we don't need the relocation
		     value.  We check specially because in some
		     obscure cases sec->output_section will be NULL.  */
		}
	      else if (sec->output_section != NULL)
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	      else if (!info->relocatable
		       && (_bfd_elf_section_offset (output_bfd, info,
						    input_section,
						    rel->r_offset)
			   != (bfd_vma) -1))
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
		     input_bfd,
		     input_section,
		     (long) rel->r_offset,
		     howto->name,
		     h->root.root.string);
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else if (!info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	    }
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable && !use_rel)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    rel->r_addend += sec->output_offset;
	  continue;
	}

      if (info->relocatable && use_rel)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (sym == NULL || ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	    continue;

	  addend += sec->output_offset;

	  /* If partial_inplace, we need to store any additional addend
	     back in the section.  */
	  if (! howto->partial_inplace)
	    continue;
	  /* ??? Here is a nice place to call a special_function
	     like handler.  */
	  if (r_type != R_M32R_HI16_SLO && r_type != R_M32R_HI16_ULO)
	    r = _bfd_relocate_contents (howto, input_bfd,
					addend, contents + offset);
	  else
	    {
	      Elf_Internal_Rela *lorel;

	      /* We allow an arbitrary number of HI16 relocs before the
		 LO16 reloc.  This permits gcc to emit the HI and LO relocs
		 itself.  */
	      for (lorel = rel + 1;
		   (lorel < relend
		    && (ELF32_R_TYPE (lorel->r_info) == R_M32R_HI16_SLO
			|| ELF32_R_TYPE (lorel->r_info) == R_M32R_HI16_ULO));
		   lorel++)
		continue;
	      if (lorel < relend
		  && ELF32_R_TYPE (lorel->r_info) == R_M32R_LO16)
		{
		  m32r_elf_relocate_hi16 (input_bfd, r_type, rel, lorel,
					  contents, addend);
		  r = bfd_reloc_ok;
		}
	      else
		r = _bfd_relocate_contents (howto, input_bfd,
					    addend, contents + offset);
	    }
	}
      else
	{
	  /* Sanity check the address.  */
	  if (offset > high_address)
	    {
	      r = bfd_reloc_outofrange;
	      goto check_reloc;
	    }

	  switch ((int) r_type)
	    {
            case R_M32R_GOTOFF:
              /* Relocation is relative to the start of the global offset
                 table (for ld24 rx, #uimm24). eg access at label+addend

                 ld24 rx. #label@@GOTOFF + addend
                 sub  rx, r12.  */

              BFD_ASSERT (sgot != NULL);

              relocation = -(relocation - sgot->output_section->vma);
              rel->r_addend = -rel->r_addend;
              break;

            case R_M32R_GOTOFF_HI_ULO:
            case R_M32R_GOTOFF_HI_SLO:
            case R_M32R_GOTOFF_LO:
	      BFD_ASSERT (sgot != NULL);

	      relocation -= sgot->output_section->vma;

	      if ((r_type == R_M32R_GOTOFF_HI_SLO)
		  && ((relocation + rel->r_addend) & 0x8000))
		rel->r_addend += 0x10000;
	      break;

            case R_M32R_GOTPC24:
              /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                 ld24 rx,#_GLOBAL_OFFSET_TABLE_
               */
             relocation = sgot->output_section->vma;
             break;

            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO:
              {
                /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                   bl .+4
                   seth rx,#high(_GLOBAL_OFFSET_TABLE_)
                   or3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                   or
                   bl .+4
                   seth rx,#shigh(_GLOBAL_OFFSET_TABLE_)
                   add3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                 */
                relocation = sgot->output_section->vma;
                relocation -= (input_section->output_section->vma
                               + input_section->output_offset
                               + rel->r_offset);
                if ((r_type == R_M32R_GOTPC_HI_SLO)
                     && ((relocation + rel->r_addend) & 0x8000))
                  rel->r_addend += 0x10000;

                break;
              }
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOT16_LO:
              /* Fall through.  */
            case R_M32R_GOT24:
              /* Relocation is to the entry for this symbol in the global
                 offset table.  */
              BFD_ASSERT (sgot != NULL);

              if (h != NULL)
                {
                  bfd_boolean dyn;
                  bfd_vma off;

                  off = h->got.offset;
                  BFD_ASSERT (off != (bfd_vma) -1);

                  dyn = htab->root.dynamic_sections_created;
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
                      || (info->shared
                          && (info->symbolic
                              || h->dynindx == -1
                              || h->forced_local)
                          && h->def_regular))
                    {
                      /* This is actually a static link, or it is a
                         -Bsymbolic link and the symbol is defined
                         locally, or the symbol was forced to be local
                         because of a version file.  We must initialize
                         this entry in the global offset table.  Since the
                         offset must always be a multiple of 4, we use the
                         least significant bit to record whether we have
                         initialized it already.

                         When doing a dynamic link, we create a .rela.got
                         relocation entry to initialize the value.  This
                         is done in the finish_dynamic_symbol routine.  */
                      if ((off & 1) != 0)
                        off &= ~1;
                      else
                        {
                          bfd_put_32 (output_bfd, relocation,
                                      sgot->contents + off);
                          h->got.offset |= 1;
                        }
                    }

                  relocation = sgot->output_offset + off;
                }
              else
                {
                  bfd_vma off;
                  bfd_byte *loc;

                  BFD_ASSERT (local_got_offsets != NULL
                              && local_got_offsets[r_symndx] != (bfd_vma) -1);

                  off = local_got_offsets[r_symndx];

                  /* The offset must always be a multiple of 4.  We use
                     the least significant bit to record whether we have
                     already processed this entry.  */
                  if ((off & 1) != 0)
                    off &= ~1;
                  else
                    {
                      bfd_put_32 (output_bfd, relocation, sgot->contents + off);

                      if (info->shared)
                        {
                          asection *srelgot;
                          Elf_Internal_Rela outrel;

                          /* We need to generate a R_M32R_RELATIVE reloc
                             for the dynamic linker.  */
                          srelgot = bfd_get_linker_section (dynobj,
							    ".rela.got");
                          BFD_ASSERT (srelgot != NULL);

                          outrel.r_offset = (sgot->output_section->vma
                                             + sgot->output_offset
                                             + off);
                          outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                          outrel.r_addend = relocation;
                          loc = srelgot->contents;
                          loc += srelgot->reloc_count * sizeof (Elf32_External_Rela);
                          bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                          ++srelgot->reloc_count;
                        }

                      local_got_offsets[r_symndx] |= 1;
                    }

                  relocation = sgot->output_offset + off;
                }
              if ((r_type == R_M32R_GOT16_HI_SLO)
                  && ((relocation + rel->r_addend) & 0x8000))
                rel->r_addend += 0x10000;

              break;

            case R_M32R_26_PLTREL:
              /* Relocation is to the entry for this symbol in the
                 procedure linkage table.  */

              /* The native assembler will generate a 26_PLTREL reloc
                 for a local symbol if you assemble a call from one
                 section to another when using -K pic. */
              if (h == NULL)
                break;

              if (h->forced_local)
                break;

              if (h->plt.offset == (bfd_vma) -1)
		/* We didn't make a PLT entry for this symbol.  This
		   happens when statically linking PIC code, or when
		   using -Bsymbolic.  */
		break;

              relocation = (splt->output_section->vma
                            + splt->output_offset
                            + h->plt.offset);
              break;

            case R_M32R_HI16_SLO_RELA:
	      if ((relocation + rel->r_addend) & 0x8000)
		rel->r_addend += 0x10000;
              /* Fall through.  */

            case R_M32R_16_RELA:
            case R_M32R_24_RELA:
            case R_M32R_32_RELA:
            case R_M32R_REL32:
	    case R_M32R_10_PCREL_RELA:
            case R_M32R_18_PCREL_RELA:
            case R_M32R_26_PCREL_RELA:
            case R_M32R_HI16_ULO_RELA:
            case R_M32R_LO16_RELA:
              if (info->shared
                  && r_symndx != STN_UNDEF
                  && (input_section->flags & SEC_ALLOC) != 0
                  && ((   r_type != R_M32R_10_PCREL_RELA
                       && r_type != R_M32R_18_PCREL_RELA
                       && r_type != R_M32R_26_PCREL_RELA
                       && r_type != R_M32R_REL32)
                      || (h != NULL
                          && h->dynindx != -1
                          && (! info->symbolic
                              || !h->def_regular))))
                {
                  Elf_Internal_Rela outrel;
                  bfd_boolean skip, relocate;
                  bfd_byte *loc;

                  /* When generating a shared object, these relocations
                     are copied into the output file to be resolved at run
                     time.  */
                  if (sreloc == NULL)
                    {
		      sreloc = _bfd_elf_get_dynamic_reloc_section
			(input_bfd, input_section, /*rela?*/ TRUE);
		      if (sreloc == NULL)
			return FALSE;
                    }

                  skip = FALSE;
                  relocate = FALSE;

                  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
                                                             info,
                                                             input_section,
                                                             rel->r_offset);
                  if (outrel.r_offset == (bfd_vma) -1)
                    skip = TRUE;
                  else if (outrel.r_offset == (bfd_vma) -2)
                    skip = relocate = TRUE;
                  outrel.r_offset += (input_section->output_section->vma
                                      + input_section->output_offset);

                  if (skip)
                    memset (&outrel, 0, sizeof outrel);
                  else if (   r_type == R_M32R_10_PCREL_RELA
                           || r_type == R_M32R_18_PCREL_RELA
                           || r_type == R_M32R_26_PCREL_RELA
                           || r_type == R_M32R_REL32)
                    {
                      BFD_ASSERT (h != NULL && h->dynindx != -1);
                      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                      outrel.r_addend = rel->r_addend;
                    }
                  else
                    {
                    /* h->dynindx may be -1 if this symbol was marked to
                       become local.  */
                    if (h == NULL
                        || ((info->symbolic || h->dynindx == -1)
                             && h->def_regular))
                      {
                        relocate = TRUE;
                        outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    else
                      {
                        BFD_ASSERT (h->dynindx != -1);
                        outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    }

                  loc = sreloc->contents;
                  loc += sreloc->reloc_count * sizeof (Elf32_External_Rela);
                  bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                  ++sreloc->reloc_count;

                  /* If this reloc is against an external symbol, we do
                     not want to fiddle with the addend.  Otherwise, we
                     need to include the symbol value so that it becomes
                     an addend for the dynamic reloc.  */
                  if (! relocate)
                    continue;
		  break;
                }
	      else if (r_type != R_M32R_10_PCREL_RELA)
		break;
	      /* Fall through.  */

	    case (int) R_M32R_10_PCREL :
	      r = m32r_elf_do_10_pcrel_reloc (input_bfd, howto, input_section,
					      contents, offset,
					      sec, relocation, addend);
              goto check_reloc;

	    case (int) R_M32R_HI16_SLO :
	    case (int) R_M32R_HI16_ULO :
	      {
		Elf_Internal_Rela *lorel;

		/* We allow an arbitrary number of HI16 relocs before the
		   LO16 reloc.  This permits gcc to emit the HI and LO relocs
		   itself.  */
		for (lorel = rel + 1;
		     (lorel < relend
		      && (ELF32_R_TYPE (lorel->r_info) == R_M32R_HI16_SLO
			  || ELF32_R_TYPE (lorel->r_info) == R_M32R_HI16_ULO));
		     lorel++)
		  continue;
		if (lorel < relend
		    && ELF32_R_TYPE (lorel->r_info) == R_M32R_LO16)
		  {
		    m32r_elf_relocate_hi16 (input_bfd, r_type, rel, lorel,
					    contents, relocation + addend);
		    r = bfd_reloc_ok;
		  }
		else
		  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
						contents, offset,
						relocation, addend);
	      }

              goto check_reloc;

            case (int) R_M32R_SDA16_RELA:
	    case (int) R_M32R_SDA16 :
	      {
		const char *name;

		BFD_ASSERT (sec != NULL);
		name = bfd_get_section_name (sec->owner, sec);

		if (   strcmp (name, ".sdata") == 0
		    || strcmp (name, ".sbss") == 0
		    || strcmp (name, ".scommon") == 0)
		  {
		    bfd_vma sda_base;
		    bfd *out_bfd = sec->output_section->owner;

		    r = m32r_elf_final_sda_base (out_bfd, info,
						 &errmsg,
						 &sda_base);
		    if (r != bfd_reloc_ok)
		      {
			ret = FALSE;
			goto check_reloc;
		      }

		    /* At this point `relocation' contains the object's
		       address.  */
		    relocation -= sda_base;
		    /* Now it contains the offset from _SDA_BASE_.  */
		  }
		else
		  {
		    (*_bfd_error_handler)
		      (_("%B: The target (%s) of an %s relocation is in the wrong section (%A)"),
		       input_bfd,
		       sec,
		       sym_name,
		       m32r_elf_howto_table[(int) r_type].name);
		    /*bfd_set_error (bfd_error_bad_value); ??? why? */
		    ret = FALSE;
		    continue;
		  }
	      }
              /* Fall through.  */

	    default : /* OLD_M32R_RELOC */

	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, offset,
					    relocation, addend);
	      goto check_reloc;
	    }

          r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                        contents, rel->r_offset,
                                        relocation, rel->r_addend);

	}

    check_reloc:

      if (r != bfd_reloc_ok)
	{
	  /* FIXME: This should be generic enough to go in a utility.  */
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
	      if (name == NULL || *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (errmsg != NULL)
	    goto common_error;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section, offset)))
		return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, name, input_bfd, input_section,
		      offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      errmsg = _("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      errmsg = _("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      errmsg = _("internal error: dangerous error");
	      goto common_error;

	    default:
	      errmsg = _("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, errmsg, name, input_bfd, input_section,
		     offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return ret;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
m32r_elf_finish_dynamic_symbol (bfd *output_bfd,
				struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				Elf_Internal_Sym *sym)
{
  struct elf_m32r_link_hash_table *htab;
  bfd_byte *loc;

#ifdef DEBUG_PIC
  printf ("m32r_elf_finish_dynamic_symbol()\n");
#endif

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srela;

      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;

      /* This symbol has an entry in the procedure linkage table.  Set
         it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = htab->splt;
      sgot = htab->sgotplt;
      srela = htab->srelplt;
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);

      /* Get the index in the procedure linkage table which
         corresponds to this symbol.  This is the index of this symbol
         in all the symbols for which we are making plt entries.  The
         first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

      /* Get the offset into the .got table of the entry that
        corresponds to this function.  Each .got entry is 4 bytes.
        The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
        {
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD0b
               + (((sgot->output_section->vma
                    + sgot->output_offset
                    + got_offset) >> 16) & 0xffff)),
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD1b
               + ((sgot->output_section->vma
                   + sgot->output_offset
                   + got_offset) & 0xffff)),
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }
      else
        {
          bfd_put_32 (output_bfd,
              PLT_ENTRY_WORD0 + got_offset,
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD1,
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
                  (splt->output_section->vma
                   + splt->output_offset
                   + h->plt.offset
                   + 12), /* same offset */
                  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_JMP_SLOT);
      rela.r_addend = 0;
      loc = srela->contents;
      loc += plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

      if (!h->def_regular)
        {
          /* Mark the symbol as undefined, rather than as defined in
             the .plt section.  Leave the value alone.  */
          sym->st_shndx = SHN_UNDEF;
        }
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;

      /* This symbol has an entry in the global offset table.  Set it
         up.  */

      sgot = htab->sgot;
      srela = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + (h->got.offset &~ 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
         locally, we just want to emit a RELATIVE reloc.  Likewise if
         the symbol was forced to be local because of a version file.
         The entry in the global offset table will already have been
         initialized in the relocate_section function.  */
      if (info->shared
          && (info->symbolic
	      || h->dynindx == -1
	      || h->forced_local)
          && h->def_regular)
        {
          rela.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
          rela.r_addend = (h->root.u.def.value
                           + h->root.u.def.section->output_section->vma
                           + h->root.u.def.section->output_offset);
        }
      else
        {
	  BFD_ASSERT ((h->got.offset & 1) == 0);
          bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
          rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_GLOB_DAT);
          rela.r_addend = 0;
        }

      loc = srela->contents;
      loc += srela->reloc_count * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++srela->reloc_count;
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rela;

      /* This symbols needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
                  && (h->root.type == bfd_link_hash_defined
                      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_linker_section (htab->root.dynobj, ".rela.bss");
      BFD_ASSERT (s != NULL);

      rela.r_offset = (h->root.u.def.value
                       + h->root.u.def.section->output_section->vma
                       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_COPY);
      rela.r_addend = 0;
      loc = s->contents;
      loc += s->reloc_count * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++s->reloc_count;
    }

  /* Mark some specially defined symbols as absolute.  */
  if (h == htab->root.hdynamic || h == htab->root.hgot)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}


/* Finish up the dynamic sections.  */

static bfd_boolean
m32r_elf_finish_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;

#ifdef DEBUG_PIC
  printf ("m32r_elf_finish_dynamic_sections()\n");
#endif

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->root.dynobj;

  sgot = htab->sgotplt;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->root.dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sgot != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
        {
          Elf_Internal_Dyn dyn;
          asection *s;

          bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

          switch (dyn.d_tag)
            {
            default:
              break;

            case DT_PLTGOT:
              s = htab->sgot->output_section;
              goto get_vma;
            case DT_JMPREL:
              s = htab->srelplt->output_section;
            get_vma:
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_ptr = s->vma;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_PLTRELSZ:
              s = htab->srelplt->output_section;
              BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_RELASZ:
              /* My reading of the SVR4 ABI indicates that the
                 procedure linkage table relocs (DT_JMPREL) should be
                 included in the overall relocs (DT_RELA).  This is
                 what Solaris does.  However, UnixWare can not handle
                 that case.  Therefore, we override the DT_RELASZ entry
                 here to make it not include the JMPREL relocs.  Since
                 the linker script arranges for .rela.plt to follow all
                 other relocation sections, we don't have to worry
                 about changing the DT_RELA entry.  */
              if (htab->srelplt != NULL)
                {
                  s = htab->srelplt->output_section;
		  dyn.d_un.d_val -= s->size;
                }
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;
            }
        }

      /* Fill in the first entry in the procedure linkage table.  */
      splt = htab->splt;
      if (splt && splt->size > 0)
        {
          if (info->shared)
            {
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD0, splt->contents);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD1, splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD4, splt->contents + 16);
            }
          else
            {
              unsigned long addr;
              /* addr = .got + 4 */
              addr = sgot->output_section->vma + sgot->output_offset + 4;
              bfd_put_32 (output_bfd,
			  PLT0_ENTRY_WORD0 | ((addr >> 16) & 0xffff),
			  splt->contents);
              bfd_put_32 (output_bfd,
			  PLT0_ENTRY_WORD1 | (addr & 0xffff),
			  splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD4, splt->contents + 16);
            }

          elf_section_data (splt->output_section)->this_hdr.sh_entsize =
            PLT_ENTRY_SIZE;
        }
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot && sgot->size > 0)
    {
      if (sdyn == NULL)
        bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
        bfd_put_32 (output_bfd,
                    sdyn->output_section->vma + sdyn->output_offset,
                    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }

  return TRUE;
}


/* Set the right machine number.  */

static bfd_boolean
m32r_elf_object_p (bfd *abfd)
{
  switch (elf_elfheader (abfd)->e_flags & EF_M32R_ARCH)
    {
    default:
    case E_M32R_ARCH:   (void) bfd_default_set_arch_mach (abfd, bfd_arch_m32r, bfd_mach_m32r);  break;
    case E_M32RX_ARCH:  (void) bfd_default_set_arch_mach (abfd, bfd_arch_m32r, bfd_mach_m32rx); break;
    case E_M32R2_ARCH:  (void) bfd_default_set_arch_mach (abfd, bfd_arch_m32r, bfd_mach_m32r2); break;
    }
  return TRUE;
}

/* Store the machine number in the flags field.  */

static void
m32r_elf_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_m32r:  val = E_M32R_ARCH; break;
    case bfd_mach_m32rx: val = E_M32RX_ARCH; break;
    case bfd_mach_m32r2: val = E_M32R2_ARCH; break;
    }

  elf_elfheader (abfd)->e_flags &=~ EF_M32R_ARCH;
  elf_elfheader (abfd)->e_flags |= val;
}

/* Function to keep M32R specific file flags.  */

static bfd_boolean
m32r_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
m32r_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword out_flags;
  flagword in_flags;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      /* If the input is the default architecture then do not
	 bother setting the flags for the output architecture,
	 instead allow future merges to do this.  If no future
	 merges ever set these flags then they will retain their
	 unitialised values, which surprise surprise, correspond
	 to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				  bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Check flag compatibility.  */
  if (in_flags == out_flags)
    return TRUE;

  if ((in_flags & EF_M32R_ARCH) != (out_flags & EF_M32R_ARCH))
    {
      if (   ((in_flags  & EF_M32R_ARCH) != E_M32R_ARCH)
          || ((out_flags & EF_M32R_ARCH) == E_M32R_ARCH)
          || ((in_flags  & EF_M32R_ARCH) == E_M32R2_ARCH))
	{
	  (*_bfd_error_handler)
	    (_("%B: Instruction set mismatch with previous modules"), ibfd);

	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  return TRUE;
}

/* Display the flags field.  */

static bfd_boolean
m32r_elf_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE * file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  _bfd_elf_print_private_bfd_data (abfd, ptr);

  fprintf (file, _("private flags = %lx"), elf_elfheader (abfd)->e_flags);

  switch (elf_elfheader (abfd)->e_flags & EF_M32R_ARCH)
    {
    default:
    case E_M32R_ARCH:  fprintf (file, _(": m32r instructions"));  break;
    case E_M32RX_ARCH: fprintf (file, _(": m32rx instructions")); break;
    case E_M32R2_ARCH: fprintf (file, _(": m32r2 instructions")); break;
    }

  fputc ('\n', file);

  return TRUE;
}

static asection *
m32r_elf_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_M32R_GNU_VTINHERIT:
      case R_M32R_GNU_VTENTRY:
      case R_M32R_RELA_GNU_VTINHERIT:
      case R_M32R_RELA_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

static bfd_boolean
m32r_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* Update the got entry reference counts for the section being removed.  */
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_M32R_GOT16_HI_ULO:
	case R_M32R_GOT16_HI_SLO:
	case R_M32R_GOT16_LO:
	case R_M32R_GOTOFF:
	case R_M32R_GOTOFF_HI_ULO:
	case R_M32R_GOTOFF_HI_SLO:
	case R_M32R_GOTOFF_LO:
	case R_M32R_GOT24:
	case R_M32R_GOTPC_HI_ULO:
	case R_M32R_GOTPC_HI_SLO:
	case R_M32R_GOTPC_LO:
	case R_M32R_GOTPC24:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else
	    {
	      if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
	  break;

	case R_M32R_16_RELA:
	case R_M32R_24_RELA:
	case R_M32R_32_RELA:
	case R_M32R_REL32:
	case R_M32R_HI16_ULO_RELA:
	case R_M32R_HI16_SLO_RELA:
	case R_M32R_LO16_RELA:
	case R_M32R_SDA16_RELA:
	case R_M32R_10_PCREL_RELA:
	case R_M32R_18_PCREL_RELA:
	case R_M32R_26_PCREL_RELA:
	  if (h != NULL)
	    {
	      struct elf_m32r_link_hash_entry *eh;
	      struct elf_m32r_dyn_relocs **pp;
	      struct elf_m32r_dyn_relocs *p;

	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      eh = (struct elf_m32r_link_hash_entry *) h;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (   ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
			|| ELF32_R_TYPE (rel->r_info) == R_M32R_18_PCREL_RELA
			|| ELF32_R_TYPE (rel->r_info) == R_M32R_10_PCREL_RELA
			|| ELF32_R_TYPE (rel->r_info) == R_M32R_REL32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;

	case R_M32R_26_PLTREL:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
m32r_elf_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;

  sreloc = NULL;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  htab = m32r_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->root.dynobj;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      int r_type;
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      /* Some relocs require a global offset table.  */
      if (htab->sgot == NULL)
        {
          switch (r_type)
            {
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOTOFF:
            case R_M32R_GOTOFF_HI_ULO:
            case R_M32R_GOTOFF_HI_SLO:
            case R_M32R_GOTOFF_LO:
            case R_M32R_GOT16_LO:
            case R_M32R_GOTPC24:
            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO:
            case R_M32R_GOT24:
              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;
              if (! create_got_section (dynobj, info))
                return FALSE;
              break;

            default:
              break;
          }
        }

      switch (r_type)
        {
	case R_M32R_GOT16_HI_ULO:
	case R_M32R_GOT16_HI_SLO:
	case R_M32R_GOT16_LO:
        case R_M32R_GOT24:

          if (h != NULL)
            h->got.refcount += 1;
          else
            {
              bfd_signed_vma *local_got_refcounts;

              /* This is a global offset table entry for a local
                 symbol.  */
              local_got_refcounts = elf_local_got_refcounts (abfd);
              if (local_got_refcounts == NULL)
                {
                  bfd_size_type size;

                  size = symtab_hdr->sh_info;
                  size *= sizeof (bfd_signed_vma);
                  local_got_refcounts = bfd_zalloc (abfd, size);
                  if (local_got_refcounts == NULL)
                    return FALSE;
                  elf_local_got_refcounts (abfd) = local_got_refcounts;
                }
              local_got_refcounts[r_symndx] += 1;
            }
          break;

        case R_M32R_26_PLTREL:
          /* This symbol requires a procedure linkage table entry.  We
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
          if (h == NULL)
            continue;

          if (h->forced_local)
            break;

          h->needs_plt = 1;
	  h->plt.refcount += 1;
          break;

        case R_M32R_16_RELA:
        case R_M32R_24_RELA:
        case R_M32R_32_RELA:
        case R_M32R_REL32:
        case R_M32R_HI16_ULO_RELA:
        case R_M32R_HI16_SLO_RELA:
        case R_M32R_LO16_RELA:
        case R_M32R_SDA16_RELA:
	case R_M32R_10_PCREL_RELA:
        case R_M32R_18_PCREL_RELA:
        case R_M32R_26_PCREL_RELA:

          if (h != NULL && !info->shared)
            {
              h->non_got_ref = 1;
              h->plt.refcount += 1;
            }

          /* If we are creating a shared library, and this is a reloc
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             dyn_relocs field of the hash table entry. A similar
             situation occurs when creating shared libraries and symbol
             visibility changes render the symbol local.

             If on the other hand, we are creating an executable, we
             may need to keep relocations for symbols satisfied by a
             dynamic library if we manage to avoid copy relocs for the
             symbol.  */
          if ((info->shared
               && (sec->flags & SEC_ALLOC) != 0
	       && ((   r_type != R_M32R_26_PCREL_RELA
                    && r_type != R_M32R_18_PCREL_RELA
                    && r_type != R_M32R_10_PCREL_RELA
                    && r_type != R_M32R_REL32)
	           || (h != NULL
		       && (! info->symbolic
		           || h->root.type == bfd_link_hash_defweak
		           || !h->def_regular))))
              || (!info->shared
                  && (sec->flags & SEC_ALLOC) != 0
                  && h != NULL
                  && (h->root.type == bfd_link_hash_defweak
                      || !h->def_regular)))
            {
              struct elf_m32r_dyn_relocs *p;
              struct elf_m32r_dyn_relocs **head;

              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;

              /* When creating a shared object, we must copy these
                 relocs into the output file.  We create a reloc
                 section in dynobj and make room for the reloc.  */
              if (sreloc == NULL)
                {
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
                }

              /* If this is a global symbol, we count the number of
                 relocations we need for this symbol.  */
              if (h != NULL)
                head = &((struct elf_m32r_link_hash_entry *) h)->dyn_relocs;
              else
                {
                  /* Track dynamic relocs needed for local syms too.  */
                  asection *s;
                  void *vpp;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
                  head = (struct elf_m32r_dyn_relocs **) vpp;
                }

              p = *head;
              if (p == NULL || p->sec != sec)
                {
                  bfd_size_type amt = sizeof (*p);

                  p = bfd_alloc (dynobj, amt);
                  if (p == NULL)
                    return FALSE;
                  p->next = *head;
                  *head = p;
                  p->sec = sec;
                  p->count = 0;
                  p->pc_count = 0;
                }

              p->count += 1;
              if (   ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                  || ELF32_R_TYPE (rel->r_info) == R_M32R_18_PCREL_RELA
		  || ELF32_R_TYPE (rel->r_info) == R_M32R_10_PCREL_RELA
		  || ELF32_R_TYPE (rel->r_info) == R_M32R_REL32)
                p->pc_count += 1;
            }
          break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_M32R_RELA_GNU_VTINHERIT:
        case R_M32R_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_M32R_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
        case R_M32R_RELA_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
        }
    }

  return TRUE;
}

static const struct bfd_elf_special_section m32r_elf_special_sections[] =
{
  { STRING_COMMA_LEN (".sbss"),  -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".sdata"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,                     0,  0, 0,            0 }
};

static enum elf_reloc_type_class
m32r_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   const asection *rel_sec ATTRIBUTE_UNUSED,
			   const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_M32R_RELATIVE:  return reloc_class_relative;
    case R_M32R_JMP_SLOT:  return reloc_class_plt;
    case R_M32R_COPY:      return reloc_class_copy;
    default:      	   return reloc_class_normal;
    }
}

#define ELF_ARCH		bfd_arch_m32r
#define ELF_TARGET_ID		M32R_ELF_DATA
#define ELF_MACHINE_CODE	EM_M32R
#define ELF_MACHINE_ALT1	EM_CYGNUS_M32R
#define ELF_MAXPAGESIZE		0x1 /* Explicitly requested by Mitsubishi.  */

#define TARGET_BIG_SYM          bfd_elf32_m32r_vec
#define TARGET_BIG_NAME		"elf32-m32r"
#define TARGET_LITTLE_SYM       bfd_elf32_m32rle_vec
#define TARGET_LITTLE_NAME      "elf32-m32rle"

#define elf_info_to_howto			m32r_info_to_howto
#define elf_info_to_howto_rel			m32r_info_to_howto_rel
#define elf_backend_section_from_bfd_section	_bfd_m32r_elf_section_from_bfd_section
#define elf_backend_symbol_processing		_bfd_m32r_elf_symbol_processing
#define elf_backend_add_symbol_hook		m32r_elf_add_symbol_hook
#define elf_backend_relocate_section		m32r_elf_relocate_section
#define elf_backend_gc_mark_hook                m32r_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook               m32r_elf_gc_sweep_hook
#define elf_backend_check_relocs                m32r_elf_check_relocs

#define elf_backend_create_dynamic_sections     m32r_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create    m32r_elf_link_hash_table_create
#define elf_backend_size_dynamic_sections       m32r_elf_size_dynamic_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_finish_dynamic_sections     m32r_elf_finish_dynamic_sections
#define elf_backend_adjust_dynamic_symbol       m32r_elf_adjust_dynamic_symbol
#define elf_backend_finish_dynamic_symbol       m32r_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class            m32r_elf_reloc_type_class
#define elf_backend_copy_indirect_symbol        m32r_elf_copy_indirect_symbol

#define elf_backend_can_gc_sections             1
/*#if !USE_REL
#define elf_backend_rela_normal			1
#endif*/
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size 12

#define elf_backend_may_use_rel_p       1
#ifdef USE_M32R_OLD_RELOC
#define elf_backend_default_use_rela_p  0
#define elf_backend_may_use_rela_p      0
#else
#define elf_backend_default_use_rela_p  1
#define elf_backend_may_use_rela_p      1
#endif

#define elf_backend_object_p			m32r_elf_object_p
#define elf_backend_final_write_processing 	m32r_elf_final_write_processing
#define bfd_elf32_bfd_merge_private_bfd_data 	m32r_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags		m32r_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data	m32r_elf_print_private_bfd_data
#define elf_backend_special_sections		m32r_elf_special_sections

#include "elf32-target.h"

#undef  ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE         0x1000

#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_m32rlin_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME         "elf32-m32r-linux"
#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM       bfd_elf32_m32rlelin_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME      "elf32-m32rle-linux"
#undef  elf32_bed
#define elf32_bed               elf32_m32r_lin_bed

#include "elf32-target.h"

@


1.113
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d1392 2
a1393 1
	  bfd_set_section_alignment (abfd, s, 2);
@


1.112
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d3749 4
@


1.111
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3984 3
a3986 1
m32r_elf_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.110
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d1588 1
a1588 1
  ret = bfd_malloc (amt);
a1600 9
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_cache.abfd = NULL;

@


1.109
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d3298 1
a3298 2
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || h == htab->root.hgot)
@


1.108
log
@	* elf32-sh.c (sh_elf_create_dynamic_sections): Don't create .rela
	section for bss type sections, except for .rela.bss.
	* elf-m10300.c (_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_create_dynamic_sections): Likewise.
	* elf32-lm32.c (lm32_elf_create_dynamic_sections): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
@
text
@d1628 3
a1630 3
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d1664 1
a1664 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d1692 4
a1695 3
  s = bfd_make_section_with_flags (abfd,
				   bed->default_use_rela_p ? ".rela.plt" : ".rel.plt",
				   flags | SEC_READONLY);
d1713 2
a1714 2
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d1731 4
a1734 4
          s = bfd_make_section_with_flags (abfd,
					   (bed->default_use_rela_p
					    ? ".rela.bss" : ".rel.bss"),
					   flags | SEC_READONLY);
d2180 1
a2180 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d2792 2
a2793 1
                          srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d3283 1
a3283 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
                                   ".rela.bss");
d3328 1
a3328 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.107
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@a1703 26
  {
    const char *secname;
    char *relname;
    flagword secflags;
    asection *sec;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
        secflags = bfd_get_section_flags (abfd, sec);
        if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
            || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
          continue;
        secname = bfd_get_section_name (abfd, sec);
        relname = bfd_malloc ((bfd_size_type) strlen (secname) + 6);
        strcpy (relname, ".rela");
        strcat (relname, secname);
        if (bfd_get_section_by_name (abfd, secname))
          continue;
        s = bfd_make_section_with_flags (abfd, relname,
					 flags | SEC_READONLY);
        if (s == NULL
            || ! bfd_set_section_alignment (abfd, s, ptralign))
          return FALSE;
      }
  }

@


1.106
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d3010 1
a3010 1
		name = bfd_get_section_name (abfd, sec);
@


1.105
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2618 1
a2618 1
					 rel, relend, howto, contents);
@


1.104
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2616 1
a2616 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.103
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
a1924 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d1946 1
a1946 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.102
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2592 5
a2596 1
	      else if (!info->relocatable)
@


1.102.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2619 1
a2619 1
      if (sec != NULL && discarded_section (sec))
@


1.101
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
a1979 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a2165 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.100
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d2629 2
a2630 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.99
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@a4036 33
static bfd_boolean
m32r_elf_fake_sections (bfd *abfd,
			Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED,
			asection *sec)
{
  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.

     This is not necessary for the O32 ABI since that only uses Elf32_Rel
     relocations (cf. System V ABI, MIPS RISC Processor Supplement,
     3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one
     of the resulting empty .rela.<section> sections starts with
     sh_offset == object size, and ld doesn't allow that.  While the check
     is arguably bogus for empty or SHT_NOBITS sections, it can easily be
     avoided by not emitting those useless sections in the first place.  */
  if ((sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;
      bfd_size_type amt = sizeof (Elf_Internal_Shdr);

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 = bfd_zalloc (abfd, amt);
      if (!esd->rel_hdr2)
        return FALSE;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
                                !sec->use_rela_p);
    }

  return TRUE;
}

a4097 1
#define elf_backend_fake_sections       m32r_elf_fake_sections
@


1.98
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2900 1
a2900 1
                  && r_symndx != 0
@


1.97
log
@fix set but unused variable warnings
@
text
@d4083 1
@


1.96
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a3155 1
  bfd *dynobj;
a3165 2
  dynobj = htab->root.dynobj;

a3386 1
          const char *name;
a3396 1
              name = ".got";
a3399 1
              name = ".rela.plt";
d3771 1
a3771 2
  bfd_vma *local_got_offsets;
  asection *sgot, *srelgot, *sreloc;
d3776 1
a3776 2
  sgot = srelgot = sreloc = NULL;

a3784 1
  local_got_offsets = elf_local_got_offsets (abfd);
a4041 4
  const char *name;

  name = bfd_get_section_name (abfd, sec);

@


1.95
log
@update copyright dates
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a1542 1

d1544 2
a1545 1
  ((struct elf_m32r_link_hash_table *) ((p)->hash))
d1594 2
a1595 1
				      sizeof (struct elf_m32r_link_hash_entry)))
d1625 3
d1649 2
d1943 3
d1988 2
d2210 3
a2450 1

d2457 3
d3164 3
d3369 3
d3789 3
@


1.94
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2008  Free Software Foundation, Inc.
@


1.93
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d1529 2
a1530 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d1607 1
a1607 1
  ret->sym_sec.abfd = NULL;
d3944 1
d3947 6
d3954 3
a3956 5
                  /* Track dynamic relocs needed for local syms too.  */
                  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
                                                 sec, r_symndx);
                  if (s == NULL)
                    return FALSE;
@


1.92
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d1626 2
a1627 1
  if (! htab->sgot || ! htab->sgotplt)
a1629 11
  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
					       (SEC_ALLOC
						| SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;

@


1.91
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
d2914 4
a2917 16
                      const char *name;

                      name = (bfd_elf_string_from_elf_section
                              (input_bfd,
                               elf_elfheader (input_bfd)->e_shstrndx,
                               elf_section_data (input_section)->rel_hdr.sh_name));
                      if (name == NULL)
                        return FALSE;

                      BFD_ASSERT (CONST_STRNEQ (name, ".rela")
                                  && strcmp (bfd_get_section_name (input_bfd,
                                                                   input_section),
                                             name + 5) == 0);

                      sreloc = bfd_get_section_by_name (dynobj, name);
                      BFD_ASSERT (sreloc != NULL);
d3941 2
a3942 12
                  const char *name;

                  name = (bfd_elf_string_from_elf_section
                          (abfd,
                           elf_elfheader (abfd)->e_shstrndx,
                           elf_section_data (sec)->rel_hdr.sh_name));
                  if (name == NULL)
                    return FALSE;

                  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
                              && strcmp (bfd_get_section_name (abfd, sec),
                                         name + 5) == 0);
d3944 2
a3945 17
                  sreloc = bfd_get_section_by_name (dynobj, name);
                  if (sreloc == NULL)
                    {
                      flagword flags;

                      flags = (SEC_HAS_CONTENTS | SEC_READONLY
                               | SEC_IN_MEMORY | SEC_LINKER_CREATED);
                      if ((sec->flags & SEC_ALLOC) != 0)
                        flags |= SEC_ALLOC | SEC_LOAD;
                      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
                      if (sreloc == NULL
                          || ! bfd_set_section_alignment (dynobj, sreloc, 2))
                        return FALSE;
                    }
                  elf_section_data (sec)->sreloc = sreloc;
@


1.90
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d3657 3
@


1.89
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d3769 1
a3769 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a3783 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.88
log
@Switch sources over to use the GPL version 3
@
text
@d4039 3
a4041 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d4045 3
a4047 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.87
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.86
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1835 1
  unsigned int power_of_two;
d1963 1
a1963 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
        return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.85
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.84
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d1257 16
@


1.83
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d2480 1
d2513 136
d2655 1
a2655 3
	  sec = NULL;
	  if (r_symndx >= symtab_hdr->sh_info)
	    /* External symbol.  */
d2658 1
a2658 10
	  /* Local symbol.  */
	  sym = local_syms + r_symndx;
	  sym_name = "<local symbol>";
	  /* STT_SECTION: symbol is associated with a section.  */
	  if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	    /* Symbol isn't associated with a section.  Nothing to do.  */
	    continue;

	  sec = local_sections[r_symndx];
	  addend += sec->output_offset + sym->st_value;
a2695 134
	  bfd_vma relocation;

	  /* This is a final link.  */
	  sym = NULL;
	  sec = NULL;
          h = NULL;

	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      /* Local symbol.  */
	      sym = local_syms + r_symndx;
	      sec = local_sections[r_symndx];
	      sym_name = "<local symbol>";

              if (!use_rel)
                {
	          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	          addend = rel->r_addend;

                  if (info->relocatable)
                    {
                      /* This is a relocatable link.  We don't have to change
                         anything, unless the reloc is against a section symbol,
                         in which case we have to adjust according to where the
                         section symbol winds up in the output section.  */
                      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
                        rel->r_addend += sec->output_offset + sym->st_value;

                      continue;
                    }
                }
              else
                {
	          relocation = (sec->output_section->vma
			        + sec->output_offset
			        + sym->st_value);
                }
	    }
	  else
	    {
	      /* External symbol.  */
              if (info->relocatable && !use_rel)
                continue;

	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      sym_name = h->root.root.string;

	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
	          bfd_boolean dyn;
		  sec = h->root.u.def.section;

	          dyn = htab->root.dynamic_sections_created;
                  sec = h->root.u.def.section;
                  if (r_type == R_M32R_GOTPC24
                      || (r_type == R_M32R_GOTPC_HI_ULO
                          || r_type == R_M32R_GOTPC_HI_SLO
                          || r_type == R_M32R_GOTPC_LO)
                      || (r_type == R_M32R_26_PLTREL
                          && h->plt.offset != (bfd_vma) -1)
                      || ((r_type == R_M32R_GOT24
                           || r_type == R_M32R_GOT16_HI_ULO
                           || r_type == R_M32R_GOT16_HI_SLO
                           || r_type == R_M32R_GOT16_LO)
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
							      info->shared, h)
                          && (! info->shared
                              || (! info->symbolic && h->dynindx != -1)
                              || !h->def_regular))
                      || (info->shared
                          && ((! info->symbolic && h->dynindx != -1)
                              || !h->def_regular)
                          && (((r_type == R_M32R_16_RELA
                              || r_type == R_M32R_32_RELA
                              || r_type == R_M32R_24_RELA
                              || r_type == R_M32R_HI16_ULO_RELA
                              || r_type == R_M32R_HI16_SLO_RELA
                              || r_type == R_M32R_LO16_RELA)
			          && !h->forced_local)
                              || r_type == R_M32R_REL32
                              || r_type == R_M32R_10_PCREL_RELA
                              || r_type == R_M32R_18_PCREL_RELA
                              || r_type == R_M32R_26_PCREL_RELA)
                          && ((input_section->flags & SEC_ALLOC) != 0
                              /* DWARF will emit R_M32R_16(24,32) relocations
                                 in its sections against symbols defined
                                 externally in shared libraries.  We can't do
                                 anything with them here.  */
                              || ((input_section->flags & SEC_DEBUGGING) != 0
                                  && h->def_dynamic))))
                    {
                      /* In these cases, we don't need the relocation
                         value.  We check specially because in some
                         obscure cases sec->output_section will be NULL.  */
                      relocation = 0;
                    }
		  else if (sec->output_section == NULL)
                    {
                      (*_bfd_error_handler)
                        (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
			 input_bfd,
			 input_section,
			 (long) rel->r_offset,
			 howto->name,
			 h->root.root.string);

		       relocation = 0;
                    }
		  else
		    relocation = (h->root.u.def.value
				  + sec->output_section->vma
				  + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
              else if (info->unresolved_syms_in_objects == RM_IGNORE
                       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
                relocation = 0;
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd,
			  input_section, offset,
                          (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
                           || ELF_ST_VISIBILITY (h->other)))))
		    return FALSE;
		  relocation = 0;
		}
	    }

@


1.82
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d4144 2
@


1.81
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3640 1
a3640 1
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
d3646 1
a3646 2
    {
      switch (ELF32_R_TYPE (rel->r_info))
d3652 2
a3653 19
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

	  default:
	    break;
          }
       }
     }
   else
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d3655 1
a3655 1
  return NULL;
@


1.80
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2312 1
a2312 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d2936 1
a2936 1
                      BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d3993 1
a3993 1
                  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d4085 3
a4087 3
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
@


1.79
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d1575 3
a1577 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
                                       m32r_elf_link_hash_newfunc))
@


1.78
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3361 1
a3361 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.77
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d1671 1
@


1.76
log
@* elf32-m32r.c (m32r_elf_sweep_hook): Fix an illegal duplicate check.
(m32r_elf_relocate_section): Fix R_M32R_10_PCREL_RELA linkage bug.
(m32r_elf_gc_sweep_hook): Likewise.
(m32r_elf_check_relocs): Likewise.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d2104 18
@


1.75
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2881 1
d2889 2
a2890 1
                  && ((r_type != R_M32R_18_PCREL_RELA
d2941 2
a2942 1
                  else if (r_type == R_M32R_18_PCREL_RELA
d2981 1
d2983 3
a2985 1
              break;
d3723 1
d3740 3
a3742 2
		    if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
			|| ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
d3908 1
d3939 1
a3939 1
	       && ((r_type != R_M32R_26_PCREL_RELA
d3941 1
d4031 4
a4034 3
              if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
		  || ELF32_R_TYPE (rel->r_info) == R_M32R_REL32
                  || ELF32_R_TYPE (rel->r_info) == R_M32R_18_PCREL_RELA)
@


1.74
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d1758 1
a1758 1
m32r_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
d1775 1
a1775 4
          if (ind->root.type == bfd_link_hash_indirect)
            abort ();

          /* Add reloc counts against the weak sym to the strong sym
d1799 1
a1799 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.73
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d3996 1
d4004 2
a4005 2
                  head = ((struct elf_m32r_dyn_relocs **)
                          &elf_section_data (s)->local_dynrel);
@


1.72
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2656 6
a2661 3
                        (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
                         bfd_get_filename (input_bfd), h->root.root.string,
                         bfd_get_section_name (input_bfd, input_section));
@


1.71
log
@(m32r_elf_check_relocs): Fix pc count for R_M32R_REL32.
@
text
@d1914 7
@


1.70
log
@Add support for a 32bit PC relative reloc
@
text
@d4014 1
@


1.69
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d880 15
a894 1
  EMPTY_HOWTO (45),
d1210 1
d2629 1
d2873 1
d2882 2
a2883 1
                       && r_type != R_M32R_26_PCREL_RELA)
d2933 2
a2934 1
                           || r_type == R_M32R_26_PCREL_RELA)
d3705 1
d3727 2
a3728 1
			|| ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA)
d3888 1
d3924 2
a3925 1
                    && r_type != R_M32R_18_PCREL_RELA)
@


1.68
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d2267 2
a2268 1
          || s == htab->sgotplt)
d2301 3
@


1.67
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a4022 18
static const struct bfd_elf_special_section *
m32r_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					m32r_elf_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d4126 1
a4126 1
#define elf_backend_get_sec_type_attr		m32r_elf_get_sec_type_attr
@


1.66
log
@m32r-linux-ld support for position independent executables
@
text
@d4016 1
a4016 1
static struct bfd_elf_special_section const m32r_elf_special_sections[] =
d4026 1
a4026 1
  const struct bfd_elf_special_section const *ssect;
@


1.65
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d2181 1
a2181 1
      if (! info->shared)
d2320 1
a2320 1
      if (! info->shared)
@


1.64
log
@Update function declarations to ISO C90 formatting
@
text
@d4016 1
a4016 2
static struct bfd_elf_special_section const
  m32r_elf_special_sections_s[] =
d4018 1
d4020 1
a4020 2
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,              0,  0, 0,            0 }
d4023 2
a4024 2
static struct bfd_elf_special_section const *
  m32r_elf_special_sections[27] =
d4026 14
a4039 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  m32r_elf_special_sections_s,	/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d4144 1
a4144 1
#define elf_backend_special_sections		m32r_elf_special_sections
@


1.63
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a26 79
static bfd_reloc_status_type m32r_elf_10_pcrel_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type m32r_elf_do_10_pcrel_reloc
  PARAMS ((bfd *, reloc_howto_type *, asection *,
	   bfd_byte *, bfd_vma, asection *, bfd_vma, bfd_vma));
static bfd_reloc_status_type m32r_elf_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void m32r_elf_relocate_hi16
  PARAMS ((bfd *, int, Elf_Internal_Rela *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
bfd_reloc_status_type m32r_elf_lo16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
bfd_reloc_status_type m32r_elf_generic_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type m32r_elf_sda16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void m32r_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static void m32r_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
bfd_boolean _bfd_m32r_elf_section_from_bfd_section
  PARAMS ((bfd *, asection *, int *));
void _bfd_m32r_elf_symbol_processing
  PARAMS ((bfd *, asymbol *));
static bfd_boolean m32r_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static bfd_boolean m32r_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_reloc_status_type m32r_elf_final_sda_base
  PARAMS ((bfd *, struct bfd_link_info *, const char **, bfd_vma *));
static bfd_boolean m32r_elf_object_p
  PARAMS ((bfd *));
static void m32r_elf_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean m32r_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean m32r_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean m32r_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean m32r_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean m32r_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_boolean m32r_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean m32r_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

asection * m32r_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean m32r_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean m32r_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean m32r_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
           Elf_Internal_Sym *));

static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static enum elf_reloc_type_class m32r_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean m32r_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));

d39 1
a39 1
/* Use RELA. But use REL to link old objects for backwords compatibility. */
d84 11
a94 1
static reloc_howto_type m32r_elf_howto_table[] =
d96 20
a115 14
  /* This reloc does nothing.  */
  HOWTO (R_M32R_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d117 5
a121 14
  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d123 2
a124 14
  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d126 1
a126 14
  /* A 24 bit address.  */
  HOWTO (R_M32R_24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 m32r_elf_generic_reloc,/* special_function */
	 "R_M32R_24",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d128 18
a145 21
  /* An PC Relative 10-bit relocation, shifted by 2.
     This reloc is complicated because relocations are relative to pc & -4.
     i.e. branches in the right insn slot use the address of the left insn
     slot for pc.  */
  /* ??? It's not clear whether this should have partial_inplace set or not.
     Branch relaxing in the assembler can store the addend in the insn,
     and if bfd_install_relocation gets called the addend may get added
     again.  */
  HOWTO (R_M32R_10_PCREL,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL",	/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d147 3
a149 14
  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d151 9
a159 18
  /* A relative 26 bit relocation, right shifted by 2.  */
  /* ??? It's not clear whether this should have partial_inplace set or not.
     Branch relaxing in the assembler can store the addend in the insn,
     and if bfd_install_relocation gets called the addend may get added
     again.  */
  HOWTO (R_M32R_26_PCREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d161 2
a162 14
  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_hi16_reloc,	/* special_function */
	 "R_M32R_HI16_ULO",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d164 12
a175 14
  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_hi16_reloc,	/* special_function */
	 "R_M32R_HI16_SLO",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d177 10
a186 14
  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 m32r_elf_lo16_reloc,	/* special_function */
	 "R_M32R_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d188 5
a192 14
  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_sda16_reloc,	/* special_function */
	 "R_M32R_SDA16",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d194 3
a196 14
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M32R_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d198 172
a369 14
  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M32R_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d371 10
a380 20
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),
  EMPTY_HOWTO (25),
  EMPTY_HOWTO (26),
  EMPTY_HOWTO (27),
  EMPTY_HOWTO (28),
  EMPTY_HOWTO (29),
  EMPTY_HOWTO (30),
  EMPTY_HOWTO (31),
  EMPTY_HOWTO (32),
d382 1
a382 14
  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16_RELA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d384 5
a388 14
  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_32_RELA",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d390 1
a390 14
  /* A 24 bit address.  */
  HOWTO (R_M32R_24_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_24_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d392 4
a395 13
  HOWTO (R_M32R_10_PCREL_RELA,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL_RELA",/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d397 4
a400 14
  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d402 3
a404 14
  /* A relative 26 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_26_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d406 19
a424 14
  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_ULO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d426 3
a428 14
  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_SLO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d430 7
a436 14
  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16_RELA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_LO16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d438 8
a445 14
  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_SDA16_RELA",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d447 3
a449 14
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M32R_RELA_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_RELA_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d451 2
a452 14
  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M32R_RELA_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_RELA_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d454 4
a457 3
  EMPTY_HOWTO (45),
  EMPTY_HOWTO (46),
  EMPTY_HOWTO (47),
d459 2
a460 15
  /* Like R_M32R_24, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOT24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d462 8
a469 15
  /* Like R_M32R_PCREL, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_M32R_26_PLTREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PLTREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d471 5
a475 6
  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_M32R_COPY,		/* type */
d482 2
a483 2
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_COPY",		/* name */
d485 2
a486 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d489 2
a490 3
  /* Like R_M32R_24, but used when setting global offset table
     entries.  */
  HOWTO (R_M32R_GLOB_DAT,	/* type */
d492 2
a493 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d497 5
a501 5
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d504 2
a505 2
  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_M32R_JMP_SLOT,	/* type */
d512 3
a514 3
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
d519 2
a520 4
  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_M32R_RELATIVE,	/* type */
d523 1
a523 1
	 32,			/* bitsize */
d526 6
a531 6
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_RELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d534 25
a558 2
  HOWTO (R_M32R_GOTOFF,	/* type */
	 0,			/* rightshift */
d560 2
a561 2
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
d563 3
a565 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTOFF",	/* name */
d567 3
a569 3
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d571 7
a577 4
  /* An PC Relative 24-bit relocation used when setting PIC offset
     table register. */
  HOWTO (R_M32R_GOTPC24,		/* type */
	 0,			/* rightshift */
d579 1
a579 1
	 24,			/* bitsize */
d582 3
a584 3
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTPC24",	/* name */
d590 2
a591 3
  /* Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_ULO,	/* type */
d598 3
a600 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
d605 2
a606 3
  /* Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_SLO,	/* type */
d613 3
a615 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
d620 2
a621 3
  /* Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_LO,	/* type */
d628 3
a630 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
d635 3
a637 5
  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_ULO,	/* type */
	 16,			/* rightshift */
d642 4
a645 4
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
d648 52
a699 1
	 TRUE),			/* pcrel_offset */
d701 4
a704 6
  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d708 1
a708 1
	 complain_overflow_dont, /* complain_on_overflow */
d710 1
a710 1
	 "R_M32R_GOTPC_HI_SLO",	/* name */
d712 3
a714 3
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d716 2
a717 4
  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_LO,	/* type */
d720 1
a720 1
	 16,			/* bitsize */
d723 3
a725 3
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_LO",	/* name */
d727 3
a729 3
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d731 3
a733 2
  HOWTO (R_M32R_GOTOFF_HI_ULO,	/* type */
	 16,			/* rightshift */
d735 1
a735 1
	 16,			/* bitsize */
d738 3
a740 3
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_HI_ULO",/* name */
d742 2
a743 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d746 17
a762 2
  HOWTO (R_M32R_GOTOFF_HI_SLO,	/* type */
	 16,			/* rightshift */
d765 1
a765 1
	 FALSE,			/* pc_relative */
d767 1
a767 1
	 complain_overflow_dont, /* complain_on_overflow */
d769 1
a769 1
	 "R_M32R_GOTOFF_HI_SLO",/* name */
d771 3
a773 3
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d775 3
a777 2
  HOWTO (R_M32R_GOTOFF_LO,	/* type */
	 0,			/* rightshift */
d779 2
a780 2
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
d782 1
a782 1
	 complain_overflow_dont, /* complain_on_overflow */
d784 1
a784 1
	 "R_M32R_GOTOFF_LO",	/* name */
d786 3
a788 233
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* Handle the R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_10_pcrel_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol;
     PTR data;
     asection * input_section;
     bfd * output_bfd;
     char ** error_message ATTRIBUTE_UNUSED;
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    {
      /* FIXME: See bfd_perform_relocation.  Is this right?  */
      return bfd_reloc_continue;
    }

  return m32r_elf_do_10_pcrel_reloc (abfd, reloc_entry->howto,
				     input_section,
				     data, reloc_entry->address,
				     symbol->section,
				     (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset),
				     reloc_entry->addend);
}

/* Utility to actually perform an R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_do_10_pcrel_reloc (abfd, howto, input_section, data, offset,
			    symbol_section, symbol_value, addend)
     bfd *abfd;
     reloc_howto_type *howto;
     asection *input_section;
     bfd_byte *data;
     bfd_vma offset;
     asection *symbol_section ATTRIBUTE_UNUSED;
     bfd_vma symbol_value;
     bfd_vma addend;
{
  bfd_signed_vma relocation;
  unsigned long x;
  bfd_reloc_status_type status;

  /* Sanity check the address (offset in section).  */
  if (offset > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  relocation = symbol_value + addend;
  /* Make it pc relative.  */
  relocation -=	(input_section->output_section->vma
		 + input_section->output_offset);
  /* These jumps mask off the lower two bits of the current address
     before doing pcrel calculations.  */
  relocation -= (offset & -(bfd_vma) 4);

  if (relocation < -0x200 || relocation > 0x1ff)
    status = bfd_reloc_overflow;
  else
    status = bfd_reloc_ok;

  x = bfd_get_16 (abfd, data + offset);
  relocation >>= howto->rightshift;
  relocation <<= howto->bitpos;
  x = (x & ~howto->dst_mask) | (((x & howto->src_mask) + relocation) & howto->dst_mask);
  bfd_put_16 (abfd, (bfd_vma) x, data + offset);

  return status;
}

/* Handle the R_M32R_HI16_[SU]LO relocs.
   HI16_SLO is for the add3 and load/store with displacement instructions.
   HI16_ULO is for the or3 instruction.
   For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to
   the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then
   we must add one to the high 16 bytes (which will get subtracted off when
   the low 16 bits are added).
   These relocs have to be done in combination with an R_M32R_LO16 reloc
   because there is a carry from the LO16 to the HI16.  Here we just save
   the information we need; we do the actual relocation when we see the LO16.
   This code is copied from the elf32-mips.c.  We also support an arbitrary
   number of HI16 relocs to be associated with a single LO16 reloc.  The
   assembler sorts the relocs to ensure each HI16 immediately precedes its
   LO16.  However if there are multiple copies, the assembler may not find
   the real LO16 so it picks the first one it finds.  */

struct m32r_hi16
{
  struct m32r_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct m32r_hi16 *m32r_hi16_list;

static bfd_reloc_status_type
m32r_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
		     input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct m32r_hi16 *n;

  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Sanity check the address (offset in section).  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    ret = bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  /* Save the information, and let LO16 do the actual relocation.  */
  n = (struct m32r_hi16 *) bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = m32r_hi16_list;
  m32r_hi16_list = n;

  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Handle an M32R ELF HI16 reloc.  */

static void
m32r_elf_relocate_hi16 (input_bfd, type, relhi, rello, contents, addend)
     bfd *input_bfd;
     int type;
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
{
  unsigned long insn;
  bfd_vma addlo;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  if (type == R_M32R_HI16_SLO)
    addlo = ((addlo & 0xffff) ^ 0x8000) - 0x8000;
  else
    addlo &= 0xffff;

  addend += ((insn & 0xffff) << 16) + addlo;

  /* Reaccount for sign extension of low part.  */
  if (type == R_M32R_HI16_SLO
      && (addend & 0x8000) != 0)
    addend += 0x10000;

  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | ((addend >> 16) & 0xffff),
	      contents + relhi->r_offset);
}

/* Do an R_M32R_LO16 relocation.  This is a straightforward 16 bit
   inplace relocation; this function exists in order to do the
   R_M32R_HI16_[SU]LO relocation described above.  */

bfd_reloc_status_type
m32r_elf_lo16_reloc (input_bfd, reloc_entry, symbol, data,
		     input_section, output_bfd, error_message)
     bfd *input_bfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d790 14
a803 3
  if (m32r_hi16_list != NULL)
    {
      struct m32r_hi16 *l;
d805 14
a818 7
      l = m32r_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct m32r_hi16 *next;
d820 14
a833 8
	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (input_bfd, l->addr);
	  vallo = ((bfd_get_32 (input_bfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;
d835 14
a848 3
	  /* Reaccount for sign extension of low part.  */
	  if ((val & 0x8000) != 0)
	    val += 0x10000;
d850 14
a863 2
	  insn = (insn &~ (bfd_vma) 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, l->addr);
d865 14
a878 4
	  next = l->next;
	  free (l);
	  l = next;
	}
d880 3
a882 2
      m32r_hi16_list = NULL;
    }
d884 15
a898 8
  /* Now do the LO16 reloc in the usual way.
     ??? It would be nice to call bfd_elf_generic_reloc here,
     but we have partial_inplace set.  bfd_elf_generic_reloc will
     pass the handling back to bfd_install_relocation which will install
     a section relative addend which is wrong.  */
  return m32r_elf_generic_reloc (input_bfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}
d900 15
a914 2
/* Do generic partial_inplace relocation.
   This is a local replacement for bfd_elf_generic_reloc.  */
d916 18
a933 14
bfd_reloc_status_type
m32r_elf_generic_reloc (input_bfd, reloc_entry, symbol, data,
		     input_section, output_bfd, error_message)
     bfd *input_bfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  bfd_byte *inplace_address;
d935 15
a949 10
  /* This part is from bfd_elf_generic_reloc.
     If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d951 14
a964 5
  /* Now do the reloc in the usual way.
     ??? It would be nice to call bfd_elf_generic_reloc here,
     but we have partial_inplace set.  bfd_elf_generic_reloc will
     pass the handling back to bfd_install_relocation which will install
     a section relative addend which is wrong.  */
d966 16
a981 3
  /* Sanity check the address (offset in section).  */
  if (reloc_entry->address > bfd_get_section_limit (input_bfd, input_section))
    return bfd_reloc_outofrange;
d983 13
a995 4
  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    ret = bfd_reloc_undefined;
d997 15
a1011 5
  if (bfd_is_com_section (symbol->section)
      || output_bfd != (bfd *) NULL)
    relocation = 0;
  else
    relocation = symbol->value;
d1013 15
a1027 6
  /* Only do this for a final link.  */
  if (output_bfd == (bfd *) NULL)
    {
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
    }
d1029 15
a1043 2
  relocation += reloc_entry->addend;
  inplace_address = (bfd_byte *) data + reloc_entry->address;
d1045 15
a1059 4
#define DOIT(x) 					\
  x = ( (x & ~reloc_entry->howto->dst_mask) | 		\
  (((x & reloc_entry->howto->src_mask) +  relocation) &	\
  reloc_entry->howto->dst_mask))
d1061 16
a1076 19
  switch (reloc_entry->howto->size)
    {
    case 1:
      {
	short x = bfd_get_16 (input_bfd, inplace_address);
	DOIT (x);
      	bfd_put_16 (input_bfd, (bfd_vma) x, inplace_address);
      }
      break;
    case 2:
      {
	unsigned long x = bfd_get_32 (input_bfd, inplace_address);
	DOIT (x);
      	bfd_put_32 (input_bfd, (bfd_vma)x , inplace_address);
      }
      break;
    default:
      BFD_ASSERT (0);
    }
d1078 16
a1093 2
  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;
d1095 16
a1110 2
  return ret;
}
d1112 13
a1124 5
/* Handle the R_M32R_SDA16 reloc.
   This reloc is used to compute the address of objects in the small data area
   and to perform loads and stores from that area.
   The lower 16 bits are sign extended and added to the register specified
   in the instruction, which is assumed to point to _SDA_BASE_.  */
d1126 13
a1138 20
static bfd_reloc_status_type
m32r_elf_sda16_reloc (abfd, reloc_entry, symbol, data,
		      input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d1140 14
a1153 5
  if (output_bfd != NULL)
    {
      /* FIXME: See bfd_perform_relocation.  Is this right?  */
      return bfd_reloc_continue;
    }
a1154 5
  /* FIXME: not sure what to do here yet.  But then again, the linker
     may never call us.  */
  abort ();
}

d1218 2
a1219 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1227 3
a1229 4
    {
      if (m32r_reloc_map_old[i].bfd_reloc_val == code)
	return &m32r_elf_howto_table[m32r_reloc_map_old[i].elf_reloc_val];
    }
d1235 2
a1236 4
    {
      if (m32r_reloc_map[i].bfd_reloc_val == code)
	return &m32r_elf_howto_table[m32r_reloc_map[i].elf_reloc_val];
    }
d1245 3
a1247 4
m32r_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1257 3
a1259 4
m32r_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1271 4
a1274 5
bfd_boolean
_bfd_m32r_elf_section_from_bfd_section (abfd, sec, retval)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
d1296 2
a1297 4
void
_bfd_m32r_elf_symbol_processing (abfd, asym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *asym;
d1299 1
a1299 3
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
d1329 7
a1335 8
m32r_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
a1351 1

d1374 1
a1374 1
						 (const char *) NULL,
d1402 4
a1405 5
m32r_elf_final_sda_base (output_bfd, info, error_message, psb)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char **error_message;
     bfd_vma *psb;
d1412 1
a1412 2
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
a1479 5

//  bfd_signed_vma gotplt_refcount;

  /* Number of PC relative relocs copied for this symbol.  */
  /* struct elf_m32r_pcrel_relocs_copied *pcrel_relocs_copied;  FIXME */
d1506 1
a1506 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
a1515 3
static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (struct bfd_hash_entry *, struct bfd_hash_table *,
                            const char * );
d1518 3
a1520 4
m32r_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d1527 5
a1531 6
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    ret = ((struct elf_m32r_link_hash_entry *)
           bfd_hash_allocate (table,
                              sizeof (struct elf_m32r_link_hash_entry)));
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d1537 1
a1537 1
  if (ret != (struct elf_m32r_link_hash_entry *) NULL)
a1542 2
//      eh->gotplt_refcount = 0;
      /* eh->pcrel_relocs_copied = NULL; FIXME */
a1548 1
static struct bfd_link_hash_table *m32r_elf_link_hash_table_create (bfd *);
d1551 1
a1551 2
m32r_elf_link_hash_table_create (abfd)
     bfd *abfd;
d1556 2
a1557 2
  ret = (struct elf_m32r_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_m32r_link_hash_table *) NULL)
a1580 1
static bfd_boolean create_got_section (bfd *, struct bfd_link_info *);
d1583 1
a1583 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d1613 1
a1613 3
m32r_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1617 1
a1617 1
  register asection *s;
a1624 1

d1647 1
d1650 1
a1650 1
              (bfd_vma) 0, (const char *) NULL, FALSE,
d1687 1
a1687 1
        relname = (char *) bfd_malloc ((bfd_size_type) strlen (secname) + 6);
a1740 3
static void m32r_elf_copy_indirect_symbol (const struct elf_backend_data *,
                                           struct elf_link_hash_entry *,
                                           struct elf_link_hash_entry *);
d1747 2
a1748 1
  struct elf_m32r_link_hash_entry *edir, *eind;
d1765 1
a1765 1
          for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
a1786 6
//  if (ind->root.type == bfd_link_hash_indirect
//      && dir->got.refcount <= 0)
//    {
//      edir->tls_type = eind->tls_type;
//      eind->tls_type = GOT_UNKNOWN;
//    }
d1798 2
a1799 3
m32r_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d1809 1
a1809 1
printf("m32r_elf_adjust_dynamic_symbol()\n");
a1821 1

d1955 1
a1955 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
a1974 10
//  if ((h->got.refcount > 0
//      || h->forced_local)
//      && eh->gotplt_refcount > 0)
//    {
//      /* The symbol has been forced local, or we have some direct got refs,
//         so treat all the gotplt refs as got refs. */
//      h->got.refcount += eh->gotplt_refcount;
//      if (h->plt.refcount >= eh->gotplt_refcount)
//        h->plt.refcount -= eh->gotplt_refcount;
//    }
d2074 2
a2075 1
          for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
d2128 1
d2132 1
a2132 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d2161 2
a2162 3
m32r_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d2171 1
a2171 1
printf("m32r_elf_size_dynamic_sections()\n");
d2255 1
a2255 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d2282 2
a2283 4
        {
          /* It's not one of our sections, so don't allocate space.  */
          continue;
        }
d2305 1
a2305 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d2347 1
a2347 1
                                    (PTR) info);
d2360 1
d2395 8
a2402 10
m32r_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d2456 1
a2456 1
      if (r_type == R_M32R_GNU_VTENTRY
d2477 2
a2478 4
	    {
	      /* External symbol.  */
	      continue;
	    }
d2485 2
a2486 4
	    {
	      /* Symbol isn't associated with a section.  Nothing to do.  */
	      continue;
	    }
d2805 1
a2805 1
                          loc += srelgot->reloc_count * sizeof(Elf32_External_Rela);
a2830 3
              //if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
              //    || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
              //  break;
d2835 4
a2838 6
                {
                  /* We didn't make a PLT entry for this symbol.  This
                     happens when statically linking PIC code, or when
                     using -Bsymbolic.  */
                  break;
                }
d2846 2
a2847 6
              {
                 if ((relocation + rel->r_addend) & 0x8000)
                   {
                     rel->r_addend += 0x10000;
                   }
              }
d2849 1
a2873 1

d2904 1
a2904 1
                    skip = TRUE, relocate = TRUE;
d2938 1
a2938 1
                  loc += sreloc->reloc_count * sizeof(Elf32_External_Rela);
d2994 1
a2994 1
		if (strcmp (name, ".sdata") == 0
d3028 1
a3028 1
              /* fall through */
d3111 1
d3113 4
a3116 5
m32r_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3123 1
a3123 1
printf("m32r_elf_finish_dynamic_symbol()\n");
d3220 1
a3220 1
      loc += plt_index * sizeof(Elf32_External_Rela);
d3266 1
a3266 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
d3273 1
a3273 1
      loc += srela->reloc_count * sizeof(Elf32_External_Rela);
d3299 1
a3299 1
      loc += s->reloc_count * sizeof(Elf32_External_Rela);
d3316 2
a3317 3
m32r_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d3325 1
a3325 1
printf("m32r_elf_finish_dynamic_sections()\n");
d3450 1
d3452 1
a3452 2
m32r_elf_object_p (abfd)
     bfd *abfd;
d3465 1
d3467 2
a3468 3
m32r_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d3485 1
d3487 1
a3487 3
m32r_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d3499 1
d3501 1
a3501 3
m32r_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d3529 2
a3530 3
	{
	  return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
d3556 2
a3557 1
/* Display the flags field */
d3559 1
a3559 3
m32r_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d3582 6
a3587 7
asection *
m32r_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3621 4
a3624 5
m32r_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d3734 4
a3737 5
m32r_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3832 1
a3832 2
                  local_got_refcounts = ((bfd_signed_vma *)
                                         bfd_zalloc (abfd, size));
d3974 2
a3975 1
                  p = ((struct elf_m32r_dyn_relocs *) bfd_alloc (dynobj, amt));
d4057 3
a4059 4
m32r_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
d4061 1
a4061 1
  register const char *name;
d4083 1
a4083 1
      esd->rel_hdr2 = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d4094 1
a4094 2
m32r_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d4098 4
a4101 8
    case R_M32R_RELATIVE:
      return reloc_class_relative;
    case R_M32R_JMP_SLOT:
      return reloc_class_plt;
    case R_M32R_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
d4163 1
a4163 1
#undef ELF_MAXPAGESIZE
d4166 1
a4166 1
#undef TARGET_BIG_SYM
d4168 1
a4168 1
#undef TARGET_BIG_NAME
d4170 1
a4170 1
#undef TARGET_LITTLE_SYM
d4172 1
a4172 1
#undef TARGET_LITTLE_NAME
d4174 1
a4174 1
#undef elf32_bed
@


1.62
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d3950 6
a3955 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.61
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d4186 2
a4187 1
static struct bfd_elf_special_section const m32r_elf_special_sections[]=
d4191 33
a4223 1
  { NULL,       0,  0, 0,            0 }
@


1.60
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1464 2
a1465 1
	  s = bfd_make_section_anyway (abfd, ".sdata");
a1467 1
	  bfd_set_section_flags (abfd, s, flags);
d1722 7
a1728 1
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
a1729 7
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
                                  (SEC_ALLOC
                                   | SEC_LOAD
                                   | SEC_HAS_CONTENTS
                                   | SEC_IN_MEMORY
                                   | SEC_LINKER_CREATED
                                   | SEC_READONLY))
d1764 1
a1764 1
  s = bfd_make_section (abfd, ".plt");
a1766 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d1790 3
a1792 2
  s = bfd_make_section (abfd,
                        bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
a1794 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d1820 2
a1821 1
        s = bfd_make_section (abfd, relname);
a1822 1
            || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d1836 2
a1837 1
      s = bfd_make_section (abfd, ".dynbss");
d1839 1
a1839 2
      if (s == NULL
          || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
d1854 4
a1857 3
          s = bfd_make_section (abfd,
                                (bed->default_use_rela_p
                                 ? ".rela.bss" : ".rel.bss"));
a1859 1
              || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
a4108 1
                      sreloc = bfd_make_section (dynobj, name);
d4113 3
a4116 1
                          || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.59
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.58
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2451 1
a2451 1
          _bfd_strip_section_from_output (info, s);
@


1.57
log
@(m32r_reloc_map_old): Use #ifdef USE_M32R_OLD_RELOC to protect the declaration of this array.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.56
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d1257 1
d1274 1
a1274 1

d1309 1
@


1.55
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@a58 4
#if 0 /* not yet */
static bfd_boolean m32r_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
#endif
a3616 535
#if 0 /* relaxing not supported yet */

/* This function handles relaxing for the m32r.
   Relaxing on the m32r is tricky because of instruction alignment
   requirements (4 byte instructions must be aligned on 4 byte boundaries).

   The following relaxing opportunities are handled:

   seth/add3/jl -> bl24 or bl8
   seth/add3 -> ld24

   It would be nice to handle bl24 -> bl8 but given:

   - 4 byte insns must be on 4 byte boundaries
   - branch instructions only branch to insns on 4 byte boundaries

   this isn't much of a win because the insn in the 2 "deleted" bytes
   must become a nop.  With some complexity some real relaxation could be
   done but the frequency just wouldn't make it worth it; it's better to
   try to do all the code compaction one can elsewhere.
   When the chip supports parallel 16 bit insns, things may change.
*/

static bfd_boolean
m32r_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  /* The Rela structures are used here because that's what
     _bfd_elf_link_read_relocs uses [for convenience - it sets the addend
     field to 0].  */
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0
      || 0 /* FIXME: check SHF_M32R_CAN_RELAX */)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      /* If this isn't something that can be relaxed, then ignore
	 this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_M32R_HI16_SLO)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + ELF32_R_SYM (irel->r_info),
	  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */

      /* Try to change a seth/add3/jl subroutine call to bl24 or bl8.
	 This sequence is generated by the compiler when compiling in
	 32 bit mode.  Also look for seth/add3 -> ld24.  */

      if (ELF32_R_TYPE (irel->r_info) == (int) R_M32R_HI16_SLO)
	{
	  Elf_Internal_Rela *nrel;
	  bfd_vma pc = (sec->output_section->vma + sec->output_offset
			+ irel->r_offset);
	  bfd_signed_vma pcrel_value = symval - pc;
	  unsigned int code,reg;
	  int addend,nop_p,bl8_p,to_delete;

	  /* The tests are ordered so that we get out as quickly as possible
	     if this isn't something we can relax, taking into account that
	     we are looking for two separate possibilities (jl/ld24).  */

	  /* Do nothing if no room in the section for this to be what we're
	     looking for.  */
	  if (irel->r_offset > sec->size - 8)
	    continue;

	  /* Make sure the next relocation applies to the next
	     instruction and that it's the add3's reloc.  */
	  nrel = irel + 1;
	  if (nrel == irelend
	      || irel->r_offset + 4 != nrel->r_offset
	      || ELF32_R_TYPE (nrel->r_info) != (int) R_M32R_LO16)
	    continue;

	  /* See if the instructions are seth/add3.  */
	  /* FIXME: This is where macros from cgen can come in.  */
	  code = bfd_get_16 (abfd, contents + irel->r_offset + 0);
	  if ((code & 0xf0ff) != 0xd0c0)
	    continue; /* not seth rN,foo */
	  reg = (code & 0x0f00) >> 8;
	  code = bfd_get_16 (abfd, contents + irel->r_offset + 4);
	  if (code != (0x80a0 | reg | (reg << 8)))
	    continue; /* not add3 rN,rN,foo */

	  /* At this point we've confirmed we have seth/add3.  Now check
	     whether the next insn is a jl, in which case try to change this
	     to bl24 or bl8.  */

	  /* Ensure the branch target is in range.
	     The bl24 instruction has a 24 bit operand which is the target
	     address right shifted by 2, giving a signed range of 26 bits.
	     Note that 4 bytes are added to the high value because the target
	     will be at least 4 bytes closer if we can relax.  It'll actually
	     be 4 or 8 bytes closer, but we don't know which just yet and
	     the difference isn't significant enough to worry about.  */
#if !USE_REL /* put in for learning purposes */
	  pcrel_value += irel->r_addend;
#else
	  addend = bfd_get_signed_16 (abfd, contents + irel->r_offset + 2);
	  pcrel_value += addend;
#endif

	  if (pcrel_value >= -(1 << 25) && pcrel_value < (1 << 25) + 4
	      /* Do nothing if no room in the section for this to be what we're
		 looking for.  */
	      && (irel->r_offset <= sec->size - 12)
	      /* Ensure the next insn is "jl rN".  */
	      && ((code = bfd_get_16 (abfd, contents + irel->r_offset + 8)),
		  code != (0x1ec0 | reg)))
	    {
	      /* We can relax to bl24/bl8.  */

	      /* See if there's a nop following the jl.
		 Also see if we can use a bl8 insn.  */
	      code = bfd_get_16 (abfd, contents + irel->r_offset + 10);
	      nop_p = (code & 0x7fff) == NOP_INSN;
	      bl8_p = pcrel_value >= -0x200 && pcrel_value < 0x200;

	      if (bl8_p)
		{
		  /* Change "seth rN,foo" to "bl8 foo || nop".
		     We OR in CODE just in case it's not a nop (technically,
		     CODE currently must be a nop, but for cleanness we
		     allow it to be anything).  */
#if !USE_REL /* put in for learning purposes */
		  code = 0x7e000000 | MAKE_PARALLEL (code);
#else
		  code = (0x7e000000 + (((addend >> 2) & 0xff) << 16)) | MAKE_PARALLEL (code);
#endif
		  to_delete = 8;
		}
	      else
		{
		  /* Change the seth rN,foo to a bl24 foo.  */
#if !USE_REL /* put in for learning purposes */
		  code = 0xfe000000;
#else
		  code = 0xfe000000 + ((addend >> 2) & 0xffffff);
#endif
		  to_delete = nop_p ? 8 : 4;
		}

	      bfd_put_32 (abfd, code, contents + irel->r_offset);

	      /* Set the new reloc type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (nrel->r_info),
					   bl8_p ? R_M32R_10_PCREL : R_M32R_26_PCREL);

	      /* Delete the add3 reloc by making it a null reloc.  */
	      nrel->r_info = ELF32_R_INFO (ELF32_R_SYM (nrel->r_info),
					   R_M32R_NONE);
	    }
	  else if (addend >= 0
		   && symval + addend <= 0xffffff)
	    {
	      /* We can relax to ld24.  */

	      code = 0xe0000000 | (reg << 24) | (addend & 0xffffff);
	      bfd_put_32 (abfd, code, contents + irel->r_offset);
	      to_delete = 4;
	      /* Tell the following code a nop filler isn't needed.  */
	      nop_p = 1;
	    }
	  else
	    {
	      /* Can't do anything here.  */
	      continue;
	    }

	  /* Note that we've changed the relocs, section contents, etc.  */
	  elf_section_data (sec)->relocs = internal_relocs;
	  elf_section_data (sec)->this_hdr.contents = contents;
	  symtab_hdr->contents = (unsigned char *) isymbuf;

	  /* Delete TO_DELETE bytes of data.  */
	  if (!m32r_elf_relax_delete_bytes (abfd, sec,
					    irel->r_offset + 4, to_delete))
	    goto error_return;

	  /* Now that the following bytes have been moved into place, see if
	     we need to replace the jl with a nop.  This happens when we had
	     to use a bl24 insn and the insn following the jl isn't a nop.
	     Technically, this situation can't happen (since the insn can
	     never be executed) but to be clean we do this.  When the chip
	     supports parallel 16 bit insns things may change.
	     We don't need to do this in the case of relaxing to ld24,
	     and the above code sets nop_p so this isn't done.  */
	  if (! nop_p && to_delete == 4)
	    bfd_put_16 (abfd, NOP_INSN, contents + irel->r_offset + 4);

	  /* That will change things, so we should relax again.
	     Note that this is not required, and it may be slow.  */
	  *again = TRUE;

	  continue;
	}

      /* loop to try the next reloc */
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
m32r_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
{
  Elf_Internal_Shdr *symtab_hdr;
  int shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Rela *irelalign;
  bfd_vma toaddr;
  Elf_Internal_Sym *isym, *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr))
	irel->r_offset -= count;
    }

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    {
      if (isym->st_shndx == shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	{
	  sym_hash->root.u.def.value -= count;
	}
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses m32r_elf_relocate_section.  */

static bfd_byte *
m32r_elf_get_relocated_section_contents (output_bfd, link_info, link_order,
					 data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_size_type amt;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      Elf_Internal_Sym *isymp;
      asection **secpp;
      Elf32_External_Sym *esym, *esymend;

      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, (PTR) NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
      if (internal_relocs == NULL)
	goto error_return;

      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL && symtab_hdr->sh_info > 0)
	goto error_return;

      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
	{
	  asection *isec;

	  if (isym->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else if (isym->st_shndx == SHN_M32R_SCOMMON)
	    isec = &m32r_elf_scom_section;
	  else
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);

	  *secpp = isec;
	}

      if (! m32r_elf_relocate_section (output_bfd, link_info, input_bfd,
				       input_section, data, internal_relocs,
				       isymbuf, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
	free (internal_relocs);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
  return NULL;
}

#endif /* #if 0 */

a4295 7
#if 0 /* not yet */
/* relax support */
#define bfd_elf32_bfd_relax_section		m32r_elf_relax_section
#define bfd_elf32_bfd_get_relocated_section_contents \
					m32r_elf_get_relocated_section_contents
#endif

@


1.54
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a4343 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
d4353 12
a4364 27
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_M32R_GOT16_HI_ULO:
      case R_M32R_GOT16_HI_SLO:
      case R_M32R_GOT16_LO:
      case R_M32R_GOTOFF:
      case R_M32R_GOTOFF_HI_ULO:
      case R_M32R_GOTOFF_HI_SLO:
      case R_M32R_GOTOFF_LO:
      case R_M32R_GOT24:
      case R_M32R_GOTPC_HI_ULO:
      case R_M32R_GOTPC_HI_SLO:
      case R_M32R_GOTPC_LO:
      case R_M32R_GOTPC24:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount--;
	  }
	else
	  {
	    if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx]--;
	  }
        break;
d4366 25
a4390 15
      case R_M32R_16_RELA:
      case R_M32R_24_RELA:
      case R_M32R_32_RELA:
      case R_M32R_HI16_ULO_RELA:
      case R_M32R_HI16_SLO_RELA:
      case R_M32R_LO16_RELA:
      case R_M32R_SDA16_RELA:
      case R_M32R_18_PCREL_RELA:
      case R_M32R_26_PCREL_RELA:
        r_symndx = ELF32_R_SYM (rel->r_info);
        if (r_symndx >= symtab_hdr->sh_info)
          {
            struct elf_m32r_link_hash_entry *eh;
            struct elf_m32r_dyn_relocs **pp;
            struct elf_m32r_dyn_relocs *p;
d4392 14
a4405 1
            h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d4407 2
a4408 2
            if (!info->shared && h->plt.refcount > 0)
              h->plt.refcount -= 1;
d4410 1
a4410 1
            eh = (struct elf_m32r_link_hash_entry *) h;
d4412 13
a4424 13
            for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
              if (p->sec == sec)
                {
                  if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                      || ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA)
                    p->pc_count -= 1;
                  p->count -= 1;
                  if (p->count == 0)
                    *pp = p->next;
                  break;
                }
          }
        break;
d4426 7
a4432 9
      case R_M32R_26_PLTREL:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount--;
	  }
	break;
d4434 4
a4437 3
      default:
	break;
      }
@


1.53
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d3239 2
a3240 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, offset)))
@


1.52
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d1353 1
a1353 1
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) <= (unsigned int) R_M32R_GNU_VTENTRY)
d2831 1
a2831 1
		 
d4274 1
a4274 1
  BFD_ASSERT (abfd != NULL && ptr != NULL)
@


1.51
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1958 1
a1958 1
                  || h->weakdef != NULL
d1993 1
a1993 1
  if (h->weakdef != NULL)
d1995 4
a1998 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
                  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.50
log
@bfd/
	* elf32-m32r.c (m32r_elf_relocate_section): Don't compare with
	TRUE or FALSE.
ld/
	* ldlang.c (lang_init): Don't compare with TRUE.
@
text
@d1786 1
a1786 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d1957 1
a1957 1
              && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d1959 3
a1961 6
                  || ((h->elf_link_hash_flags
                       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_REF_REGULAR) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d1968 1
a1968 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1971 2
a1972 2
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
          && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
d1982 1
a1982 1
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d2014 1
a2014 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d2020 1
a2020 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d2037 1
a2037 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d2066 1
a2066 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d2120 1
a2120 1
//      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d2136 1
a2136 1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2159 1
a2159 1
              && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2178 1
a2178 1
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d2184 1
a2184 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d2195 1
a2195 1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2223 2
a2224 2
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
          && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
d2245 3
a2247 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
          && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
               && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2255 1
a2255 1
              && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2761 1
a2761 2
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2764 1
a2764 2
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2771 1
a2771 2
			          && (h->elf_link_hash_flags
				      & ELF_LINK_FORCED_LOCAL) == 0)
d2781 1
a2781 2
                                  && (h->elf_link_hash_flags
                                      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
d2905 2
a2906 2
                              || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
                          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2996 1
a2996 1
              if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d3035 1
a3035 2
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d3094 1
a3094 2
                             && (h->elf_link_hash_flags
                                 & ELF_LINK_HASH_DEF_REGULAR) != 0))
d3394 1
a3394 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3427 2
a3428 2
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3449 1
a3449 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
d4558 1
a4558 1
          if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d4561 1
a4561 1
          h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d4577 1
a4577 1
              h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d4607 1
a4607 2
		           || (h->elf_link_hash_flags
		               & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d4612 1
a4612 2
                      || (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)))
@


1.49
log
@(m32r_elf_relocate_section): Handle R_M32R_SDA16_RELA in the same way as
R_M32R_SDA16.
@
text
@d2630 1
a2630 1
      if (info->relocatable && (use_rel == TRUE))
d2706 1
a2706 1
              if (use_rel == FALSE)
d2733 1
a2733 1
              if (info->relocatable && (use_rel == FALSE))
@


1.48
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@a3033 1
            case R_M32R_SDA16_RELA:
d3166 1
@


1.47
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2609 2
a2610 2
	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
				 bfd_archive_filename (input_bfd),
d3198 3
a3200 2
		      (_("%s: The target (%s) of an %s relocation is in the wrong section (%s)"),
		       bfd_archive_filename (input_bfd),
d3202 1
a3202 2
		       m32r_elf_howto_table[(int) r_type].name,
		       bfd_get_section_name (abfd, sec));
d4265 1
a4265 2
	    (_("%s: Instruction set mismatch with previous modules"),
	     bfd_archive_filename (ibfd));
@


1.46
log
@Add support for M32R GOT relocs
@
text
@a903 1
  bfd_size_type sz;
d908 1
a908 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (offset > sz)
a972 1
  bfd_size_type sz;
d987 1
a987 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a1139 1
  bfd_size_type sz;
d1160 1
a1160 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
d2575 1
a2692 1
	  bfd_size_type sz;
d2827 1
a2827 4
	  sz = (input_section->rawsize
		? input_section->rawsize
		: input_section->size);
	  if (offset > input_section->size)
@


1.45
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d672 1
a672 1
	 "R_M32R_RELATIVE",		/* name */
d681 1
a681 1
	 32,			/* bitsize */
d686 1
a686 1
	 "R_M32R_GOTOFF",		/* name */
d688 2
a689 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d806 42
d1314 3
d2844 25
d4379 4
d4512 4
@


1.44
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d862 1
d867 2
a868 1
  if (offset > input_section->_cooked_size)
d933 1
d948 2
a949 1
  if (reloc_entry->address > input_section->_cooked_size)
d1102 1
d1123 2
a1124 1
  if (reloc_entry->address > input_section->_cooked_size)
d2029 1
a2029 1
      srel->_raw_size += sizeof (Elf32_External_Rela);
d2040 1
a2040 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
                            (bfd_size_type) (1 << power_of_two));
d2049 1
a2049 1
  h->root.u.def.value = s->_raw_size;
d2052 1
a2052 1
  s->_raw_size += h->size;
d2112 2
a2113 2
          if (s->_raw_size == 0)
            s->_raw_size += PLT_ENTRY_SIZE;
d2115 1
a2115 1
          h->plt.offset = s->_raw_size;
d2130 1
a2130 1
          s->_raw_size += PLT_ENTRY_SIZE;
d2134 1
a2134 1
          htab->sgotplt->_raw_size += 4;
d2137 1
a2137 1
          htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
d2167 2
a2168 2
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
d2171 1
a2171 1
        htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d2240 1
a2240 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2304 1
a2304 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d2342 1
a2342 1
                  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2362 2
a2363 2
              *local_got = s->_raw_size;
              s->_raw_size += 4;
d2365 1
a2365 1
                srel->_raw_size += sizeof (Elf32_External_Rela);
d2393 1
a2393 1
          if (s->_raw_size != 0 && s != htab->srelplt)
d2406 1
a2406 1
      if (s->_raw_size == 0)
d2426 1
a2426 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2447 1
a2447 1
      if (htab->splt->_raw_size != 0)
d2653 1
d2788 4
a2791 1
	  if (offset > input_section->_raw_size)
d3462 1
a3462 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d3493 1
a3493 4
              if (s->_cooked_size != 0)
                dyn.d_un.d_val = s->_cooked_size;
              else
                dyn.d_un.d_val = s->_raw_size;
d3510 1
a3510 4
                  if (s->_cooked_size != 0)
                    dyn.d_un.d_val -= s->_cooked_size;
                  else
                    dyn.d_un.d_val -= s->_raw_size;
d3519 1
a3519 1
      if (splt && splt->_raw_size > 0)
d3551 1
a3551 1
  if (sgot && sgot->_raw_size > 0)
a3620 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d3650 1
a3650 6
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d3730 1
a3730 1
	  if (irel->r_offset > sec->_cooked_size - 8)
d3772 1
a3772 1
	      && (irel->r_offset <= sec->_cooked_size - 12)
d3939 1
a3939 1
  toaddr = sec->_cooked_size;
d3946 1
a3946 1
  sec->_cooked_size -= count;
d4023 1
a4023 1
	  input_section->_raw_size);
@


1.43
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d1745 1
a1745 1
          && ! _bfd_elf_link_record_dynamic_symbol (info, h))
a2051 11
/* This is the condition under which finish_dynamic_symbol will be called
   from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol
   routine, we'll need to do something about initializing any .plt and .got
   entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H)			\
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d2097 1
a2097 1
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d2101 1
a2101 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2156 1
a2156 1
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d2165 1
a2165 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d2216 1
a2216 1
              if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d2715 2
a2716 1
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d2838 1
a2838 1
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4649 1
a4649 1
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d4656 1
a4656 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d4660 1
a4660 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.42
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d54 1
a54 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d1394 1
a1394 1
     const Elf_Internal_Sym *sym;
@


1.41
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2445 1
a2445 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.40
log
@	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Fix pointer
	aliasing warning.  Remove trailing whitespace throughout file.
@
text
@d2776 1
a2776 2
              else if (info->shared
                       && (!info->symbolic)
d2784 1
a2784 1
                          (!info->shared
@


1.39
log
@Add support for m32r-linux target, including a RELA ABI and PIC.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d96 1
a96 1
                                                                                
d100 1
a100 1
                                                                                
d125 1
a125 1
                                                                                
d128 1
a128 1
                                                                                
d130 1
a130 1
                                                                                
d132 1
a132 1
                                                                                
d134 1
a134 1
                                                                                
d136 1
a136 1
                                                                                
d141 1
a141 1
                                                                                
d145 1
a145 1
                                                                                
d151 1
a151 1
                                                                                
d157 1
a157 1
                                                                                
d1251 1
a1251 1
                                                                                
d1599 1
a1599 1
    
d1608 1
a1608 1
   
d1616 1
a1616 1
  
d1622 1
a1622 1
                                                                                                 
d1635 1
a1635 1
                                                                                                 
d1639 1
a1639 1
              
d1646 1
a1646 1
               
d1655 1
a1655 1
                
d1733 2
a1734 1
      struct elf_link_hash_entry *h = NULL;
d1738 1
a1738 2
              get_elf_backend_data (abfd)->collect,
              (struct bfd_link_hash_entry **) &h)))
d1740 1
d1831 1
a1831 1
                                                                                
d1838 1
a1838 1
                                                                                
d1841 1
a1841 1
                                                                                
d1848 1
a1848 1
                                                                                
d1851 1
a1851 1
                                                                                
d1857 1
a1857 1
                                                                                
d1871 1
a1871 1
                                                                                
d1875 1
a1875 1
                                                                                
d1891 1
a1891 1
 
d1907 1
a1907 1
 
d1909 1
a1909 1
 
d1921 1
a1921 1
 
d1947 1
a1947 1
 
d1959 1
a1959 1
 
d1962 1
a1962 1
 
d1969 1
a1969 1
 
d2008 1
a2008 1
 
d2012 1
a2012 1
 
d2020 1
a2020 1
 
d2026 1
a2026 1
 
d2032 1
a2032 1
 
d2041 1
a2041 1
 
d2045 1
a2045 1
 
d2048 1
a2048 1
 
d2065 1
a2065 1
                  
d2075 1
a2075 1
                 
d2078 1
a2078 1
                
d2084 1
a2084 1
               
d2087 1
a2087 1
              
d2099 1
a2099 1
             
d2111 1
a2111 1
            
d2115 1
a2115 1
           
d2120 1
a2120 1
          
d2122 1
a2122 1
         
d2134 1
a2134 1
        
d2137 1
a2137 1
       
d2141 1
a2141 1
      
d2156 1
a2156 1
     
d2161 1
a2161 1
    
d2170 1
a2170 1
   
d2181 1
a2181 1
  
d2184 1
a2184 1
 
d2214 1
a2214 1
                                                                      
d2230 1
a2230 1
                                                                       
d2236 1
a2236 1
                                                                        
d2238 1
a2238 1
                                                                         
d2241 1
a2241 1
                                                                          
d2248 1
a2248 1
                                                                           
d2252 1
a2252 1
                                                                            
d2283 1
a2283 1
 
d2545 1
a2545 1
                                                                                
d2685 1
a2685 1
                                                                                
d2748 1
a2748 1
                                 in its sections against symbols defined 
d2785 1
a2785 1
                          (!info->shared 
d2810 1
a2810 1
            case R_M32R_GOTPC_LO: 
d2825 1
a2825 1
                if ((r_type == R_M32R_GOTPC_HI_SLO) 
d2833 1
a2833 1
            case R_M32R_GOT16_LO: 
d2839 1
a2839 1
 
d2844 1
a2844 1
 
d2864 1
a2864 1
 
d2877 1
a2877 1
 
d2884 1
a2884 1
 
d2887 1
a2887 1
 
d2889 1
a2889 1
 
d2898 1
a2898 1
 
d2903 1
a2903 1
 
d2908 1
a2908 1
 
d2919 1
a2919 1
 
d2922 1
a2922 1
 
d2930 1
a2930 1
 
d2934 1
a2934 1
 
d2954 1
a2954 1
 
d2959 1
a2959 1
 
d2990 1
a2990 1
 
d2994 1
a2994 1
 
d2998 1
a2998 1
 
d3005 1
a3005 1
 
d3010 1
a3010 1
 
d3014 1
a3014 1
 
d3017 1
a3017 1
 
d3028 1
a3028 1
 
d3072 1
a3072 1
 
d3242 1
a3242 1
 
d3246 1
a3246 1
  
d3259 1
a3259 1
 
d3262 1
a3262 1
 
d3264 1
a3264 1
 
d3325 1
a3325 1
 
d3343 1
a3343 1
 
d3357 1
a3357 1
 
d3360 1
a3360 1
 
d3364 1
a3364 1
 
d3368 1
a3368 1
 
d3392 1
a3392 1
 
d3398 1
a3398 1
 
d3403 1
a3403 1
 
d3405 1
a3405 1
 
d3409 1
a3409 1
 
d3413 1
a3413 1
 
d3424 1
a3424 1
 
d3429 1
a3429 1
 
d3435 1
a3435 1
 
d3449 1
a3449 1
 
d3455 1
a3455 1
 
d3460 1
a3460 1
 
d3462 1
a3462 1
 
d3471 1
a3471 1
 
d3473 1
a3473 1
 
d3481 1
a3481 1
              s = htab->sgot->output_section; 
d3524 1
a3524 1
 
d3545 1
a3545 1
              bfd_put_32 (output_bfd, 
d3572 1
a3572 1
 
d4477 1
a4477 1
	case R_M32R_GOT16_LO: 
d4511 1
a4511 1
 
d4587 1
a4587 1
 
d4594 1
a4594 1
 
d4598 1
a4598 1
 
d4603 1
a4603 1
 
d4616 1
a4616 1
 
@


1.39.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d54 1
a54 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d96 1
a96 1

d100 1
a100 1

d125 1
a125 1

d128 1
a128 1

d130 1
a130 1

d132 1
a132 1

d134 1
a134 1

d136 1
a136 1

d141 1
a141 1

d145 1
a145 1

d151 1
a151 1

d157 1
a157 1

d1251 1
a1251 1

d1394 1
a1394 1
     Elf_Internal_Sym *sym;
d1599 1
a1599 1

d1608 1
a1608 1

d1616 1
a1616 1

d1622 1
a1622 1

d1635 1
a1635 1

d1639 1
a1639 1

d1646 1
a1646 1

d1655 1
a1655 1

d1733 1
a1733 2
      struct bfd_link_hash_entry *bh = NULL;
      struct elf_link_hash_entry *h;
d1737 2
a1738 1
              get_elf_backend_data (abfd)->collect, &bh)))
a1739 1
      h = (struct elf_link_hash_entry *) bh;
d1830 1
a1830 1

d1837 1
a1837 1

d1840 1
a1840 1

d1847 1
a1847 1

d1850 1
a1850 1

d1856 1
a1856 1

d1870 1
a1870 1

d1874 1
a1874 1

d1890 1
a1890 1

d1906 1
a1906 1

d1908 1
a1908 1

d1920 1
a1920 1

d1946 1
a1946 1

d1958 1
a1958 1

d1961 1
a1961 1

d1968 1
a1968 1

d2007 1
a2007 1

d2011 1
a2011 1

d2019 1
a2019 1

d2025 1
a2025 1

d2031 1
a2031 1

d2040 1
a2040 1

d2044 1
a2044 1

d2047 1
a2047 1

d2064 1
a2064 1

d2074 1
a2074 1

d2077 1
a2077 1

d2083 1
a2083 1

d2086 1
a2086 1

d2098 1
a2098 1

d2110 1
a2110 1

d2114 1
a2114 1

d2119 1
a2119 1

d2121 1
a2121 1

d2133 1
a2133 1

d2136 1
a2136 1

d2140 1
a2140 1

d2155 1
a2155 1

d2160 1
a2160 1

d2169 1
a2169 1

d2180 1
a2180 1

d2183 1
a2183 1

d2213 1
a2213 1

d2229 1
a2229 1

d2235 1
a2235 1

d2237 1
a2237 1

d2240 1
a2240 1

d2247 1
a2247 1

d2251 1
a2251 1

d2282 1
a2282 1

d2444 1
a2444 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2544 1
a2544 1

d2684 1
a2684 1

d2747 1
a2747 1
                                 in its sections against symbols defined
d2775 2
a2776 1
              else if (info->unresolved_syms_in_objects == RM_IGNORE
d2784 1
a2784 1
                          (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
d2809 1
a2809 1
            case R_M32R_GOTPC_LO:
d2824 1
a2824 1
                if ((r_type == R_M32R_GOTPC_HI_SLO)
d2832 1
a2832 1
            case R_M32R_GOT16_LO:
d2838 1
a2838 1

d2843 1
a2843 1

d2863 1
a2863 1

d2876 1
a2876 1

d2883 1
a2883 1

d2886 1
a2886 1

d2888 1
a2888 1

d2897 1
a2897 1

d2902 1
a2902 1

d2907 1
a2907 1

d2918 1
a2918 1

d2921 1
a2921 1

d2929 1
a2929 1

d2933 1
a2933 1

d2953 1
a2953 1

d2958 1
a2958 1

d2989 1
a2989 1

d2993 1
a2993 1

d2997 1
a2997 1

d3004 1
a3004 1

d3009 1
a3009 1

d3013 1
a3013 1

d3016 1
a3016 1

d3027 1
a3027 1

d3071 1
a3071 1

d3241 1
a3241 1

d3245 1
a3245 1

d3258 1
a3258 1

d3261 1
a3261 1

d3263 1
a3263 1

d3324 1
a3324 1

d3342 1
a3342 1

d3356 1
a3356 1

d3359 1
a3359 1

d3363 1
a3363 1

d3367 1
a3367 1

d3391 1
a3391 1

d3397 1
a3397 1

d3402 1
a3402 1

d3404 1
a3404 1

d3408 1
a3408 1

d3412 1
a3412 1

d3423 1
a3423 1

d3428 1
a3428 1

d3434 1
a3434 1

d3448 1
a3448 1

d3454 1
a3454 1

d3459 1
a3459 1

d3461 1
a3461 1

d3470 1
a3470 1

d3472 1
a3472 1

d3480 1
a3480 1
              s = htab->sgot->output_section;
d3523 1
a3523 1

d3544 1
a3544 1
              bfd_put_32 (output_bfd,
d3571 1
a3571 1

d4476 1
a4476 1
	case R_M32R_GOT16_LO:
d4510 1
a4510 1

d4586 1
a4586 1

d4593 1
a4593 1

d4597 1
a4597 1

d4602 1
a4602 1

d4615 1
a4615 1

@


1.39.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1745 1
a1745 1
          && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2052 11
d2108 1
a2108 1
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2112 1
a2112 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d2167 1
a2167 1
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2176 1
a2176 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
d2227 1
a2227 1
              if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2726 1
a2726 2
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
							      info->shared, h)
d2848 1
a2848 1
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d4659 1
a4659 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d4666 1
a4666 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d4670 1
a4670 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.39.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d672 1
a672 1
	 "R_M32R_RELATIVE",	/* name */
d681 1
a681 1
	 24,			/* bitsize */
d686 1
a686 1
	 "R_M32R_GOTOFF",	/* name */
d688 2
a689 2
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
a805 42

  HOWTO (R_M32R_GOTOFF_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_HI_ULO",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_HI_SLO",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTOFF_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d866 1
a866 1
  if (offset > bfd_get_section_limit (abfd, input_section))
d945 1
a945 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1118 1
a1118 1
  if (reloc_entry->address > bfd_get_section_limit (input_bfd, input_section))
a1265 3
  { BFD_RELOC_M32R_GOTOFF_HI_ULO, R_M32R_GOTOFF_HI_ULO },
  { BFD_RELOC_M32R_GOTOFF_HI_SLO, R_M32R_GOTOFF_HI_SLO },
  { BFD_RELOC_M32R_GOTOFF_LO, R_M32R_GOTOFF_LO },
d2023 1
a2023 1
      srel->size += sizeof (Elf32_External_Rela);
d2034 2
a2035 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d2044 1
a2044 1
  h->root.u.def.value = s->size;
d2047 1
a2047 1
  s->size += h->size;
d2107 2
a2108 2
          if (s->size == 0)
            s->size += PLT_ENTRY_SIZE;
d2110 1
a2110 1
          h->plt.offset = s->size;
d2125 1
a2125 1
          s->size += PLT_ENTRY_SIZE;
d2129 1
a2129 1
          htab->sgotplt->size += 4;
d2132 1
a2132 1
          htab->srelplt->size += sizeof (Elf32_External_Rela);
d2162 2
a2163 2
      h->got.offset = s->size;
      s->size += 4;
d2166 1
a2166 1
        htab->srelgot->size += sizeof (Elf32_External_Rela);
d2235 1
a2235 1
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d2299 1
a2299 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d2337 1
a2337 1
                  srel->size += p->count * sizeof (Elf32_External_Rela);
d2357 2
a2358 2
              *local_got = s->size;
              s->size += 4;
d2360 1
a2360 1
                srel->size += sizeof (Elf32_External_Rela);
d2388 1
a2388 1
          if (s->size != 0 && s != htab->srelplt)
d2401 1
a2401 1
      if (s->size == 0)
d2421 1
a2421 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d2442 1
a2442 1
      if (htab->splt->size != 0)
a2530 1
  bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);
d2564 2
a2565 2
	  (*_bfd_error_handler) (_("%B: unknown relocation type %d"),
				 input_bfd,
d2585 1
a2585 1
      if (info->relocatable && use_rel)
d2661 1
a2661 1
              if (!use_rel)
d2688 1
a2688 1
              if (info->relocatable && !use_rel)
d2782 1
a2782 1
	  if (offset > high_address)
a2789 25
            case R_M32R_GOTOFF:
              /* Relocation is relative to the start of the global offset
                 table (for ld24 rx, #uimm24). eg access at label+addend
		 
                 ld24 rx. #label@@GOTOFF + addend
                 sub  rx, r12.  */

              BFD_ASSERT (sgot != NULL);

              relocation = -(relocation - sgot->output_section->vma);
              rel->r_addend = -rel->r_addend;
              break;

            case R_M32R_GOTOFF_HI_ULO:
            case R_M32R_GOTOFF_HI_SLO:
            case R_M32R_GOTOFF_LO:
	      BFD_ASSERT (sgot != NULL);

	      relocation -= sgot->output_section->vma;

	      if ((r_type == R_M32R_GOTOFF_HI_SLO)
		  && ((relocation + rel->r_addend) & 0x8000))
		rel->r_addend += 0x10000;
	      break;

d2964 1
a3096 1
            case (int) R_M32R_SDA16_RELA:
d3128 2
a3129 3
		      (_("%B: The target (%s) of an %s relocation is in the wrong section (%A)"),
		       input_bfd,
		       sec,
d3131 2
a3132 1
		       m32r_elf_howto_table[(int) r_type].name);
d3453 1
a3453 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d3484 4
a3487 1
	      dyn.d_un.d_val = s->size;
d3504 4
a3507 1
		  dyn.d_un.d_val -= s->size;
d3516 1
a3516 1
      if (splt && splt->size > 0)
d3548 1
a3548 1
  if (sgot && sgot->size > 0)
d3618 5
d3652 6
a3657 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d3737 1
a3737 1
	  if (irel->r_offset > sec->size - 8)
d3779 1
a3779 1
	      && (irel->r_offset <= sec->size - 12)
d3946 1
a3946 1
  toaddr = sec->size;
d3953 1
a3953 1
  sec->size -= count;
d4030 1
a4030 1
	  input_section->size);
d4211 2
a4212 1
	    (_("%B: Instruction set mismatch with previous modules"), ibfd);
a4315 4
      case R_M32R_GOTOFF:
      case R_M32R_GOTOFF_HI_ULO:
      case R_M32R_GOTOFF_HI_SLO:
      case R_M32R_GOTOFF_LO:
a4444 4
            case R_M32R_GOTOFF:
            case R_M32R_GOTOFF_HI_ULO:
            case R_M32R_GOTOFF_HI_SLO:
            case R_M32R_GOTOFF_LO:
@


1.39.8.4
log
@Merge from mainline.
@
text
@d1786 1
a1786 1
      h->def_regular = 1;
d1957 8
a1964 5
              && (h->needs_plt
                  || h->u.weakdef != NULL
                  || (h->def_dynamic
                      && h->ref_regular
                      && !h->def_regular)));
d1971 1
a1971 1
      || h->needs_plt)
d1974 2
a1975 2
          && !h->def_dynamic
          && !h->ref_dynamic
d1985 1
a1985 1
          h->needs_plt = 0;
d1996 1
a1996 1
  if (h->u.weakdef != NULL)
d1998 4
a2001 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d2017 1
a2017 1
  if (!h->non_got_ref)
d2023 1
a2023 1
      h->non_got_ref = 0;
d2040 1
a2040 1
      h->non_got_ref = 0;
d2069 1
a2069 1
      h->needs_copy = 1;
d2123 1
a2123 1
//      || h->forced_local)
d2139 1
a2139 1
          && !h->forced_local)
d2162 1
a2162 1
              && !h->def_regular)
d2181 1
a2181 1
          h->needs_plt = 0;
d2187 1
a2187 1
      h->needs_plt = 0;
d2198 1
a2198 1
          && !h->forced_local)
d2226 2
a2227 2
      if (h->def_regular
          && (h->forced_local
d2248 3
a2250 3
      if (!h->non_got_ref
          && ((h->def_dynamic
               && !h->def_regular)
d2258 1
a2258 1
              && !h->forced_local)
d2764 2
a2765 1
                              || !h->def_regular))
d2768 2
a2769 1
                              || !h->def_regular)
d2776 2
a2777 1
			          && !h->forced_local)
d2787 2
a2788 1
                                  && h->def_dynamic))))
d2912 2
a2913 2
                              || h->forced_local)
                          && h->def_regular))
d3003 1
a3003 1
              if (h->forced_local)
d3042 2
a3043 1
                              || !h->def_regular))))
d3102 2
a3103 1
                             && h->def_regular))
d3403 1
a3403 1
      if (!h->def_regular)
d3436 2
a3437 2
	      || h->forced_local)
          && h->def_regular)
d3458 1
a3458 1
  if (h->needs_copy)
d4567 1
a4567 1
          if (h->forced_local)
d4570 1
a4570 1
          h->needs_plt = 1;
d4586 1
a4586 1
              h->non_got_ref = 1;
d4616 2
a4617 1
		           || !h->def_regular))))
d4622 2
a4623 1
                      || !h->def_regular)))
@


1.39.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d96 1
a96 1

d100 1
a100 1

d125 1
a125 1

d128 1
a128 1

d130 1
a130 1

d132 1
a132 1

d134 1
a134 1

d136 1
a136 1

d141 1
a141 1

d145 1
a145 1

d151 1
a151 1

d157 1
a157 1

d1251 1
a1251 1

d1599 1
a1599 1

d1608 1
a1608 1

d1616 1
a1616 1

d1622 1
a1622 1

d1635 1
a1635 1

d1639 1
a1639 1

d1646 1
a1646 1

d1655 1
a1655 1

d1733 1
a1733 2
      struct bfd_link_hash_entry *bh = NULL;
      struct elf_link_hash_entry *h;
d1737 2
a1738 1
              get_elf_backend_data (abfd)->collect, &bh)))
a1739 1
      h = (struct elf_link_hash_entry *) bh;
d1830 1
a1830 1

d1837 1
a1837 1

d1840 1
a1840 1

d1847 1
a1847 1

d1850 1
a1850 1

d1856 1
a1856 1

d1870 1
a1870 1

d1874 1
a1874 1

d1890 1
a1890 1

d1906 1
a1906 1

d1908 1
a1908 1

d1920 1
a1920 1

d1946 1
a1946 1

d1958 1
a1958 1

d1961 1
a1961 1

d1968 1
a1968 1

d2007 1
a2007 1

d2011 1
a2011 1

d2019 1
a2019 1

d2025 1
a2025 1

d2031 1
a2031 1

d2040 1
a2040 1

d2044 1
a2044 1

d2047 1
a2047 1

d2064 1
a2064 1

d2074 1
a2074 1

d2077 1
a2077 1

d2083 1
a2083 1

d2086 1
a2086 1

d2098 1
a2098 1

d2110 1
a2110 1

d2114 1
a2114 1

d2119 1
a2119 1

d2121 1
a2121 1

d2133 1
a2133 1

d2136 1
a2136 1

d2140 1
a2140 1

d2155 1
a2155 1

d2160 1
a2160 1

d2169 1
a2169 1

d2180 1
a2180 1

d2183 1
a2183 1

d2213 1
a2213 1

d2229 1
a2229 1

d2235 1
a2235 1

d2237 1
a2237 1

d2240 1
a2240 1

d2247 1
a2247 1

d2251 1
a2251 1

d2282 1
a2282 1

d2544 1
a2544 1

d2684 1
a2684 1

d2747 1
a2747 1
                                 in its sections against symbols defined
d2775 2
a2776 1
              else if (info->unresolved_syms_in_objects == RM_IGNORE
d2784 1
a2784 1
                          (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
d2809 1
a2809 1
            case R_M32R_GOTPC_LO:
d2824 1
a2824 1
                if ((r_type == R_M32R_GOTPC_HI_SLO)
d2832 1
a2832 1
            case R_M32R_GOT16_LO:
d2838 1
a2838 1

d2843 1
a2843 1

d2863 1
a2863 1

d2876 1
a2876 1

d2883 1
a2883 1

d2886 1
a2886 1

d2888 1
a2888 1

d2897 1
a2897 1

d2902 1
a2902 1

d2907 1
a2907 1

d2918 1
a2918 1

d2921 1
a2921 1

d2929 1
a2929 1

d2933 1
a2933 1

d2953 1
a2953 1

d2958 1
a2958 1

d2989 1
a2989 1

d2993 1
a2993 1

d2997 1
a2997 1

d3004 1
a3004 1

d3009 1
a3009 1

d3013 1
a3013 1

d3016 1
a3016 1

d3027 1
a3027 1

d3071 1
a3071 1

d3241 1
a3241 1

d3245 1
a3245 1

d3258 1
a3258 1

d3261 1
a3261 1

d3263 1
a3263 1

d3324 1
a3324 1

d3342 1
a3342 1

d3356 1
a3356 1

d3359 1
a3359 1

d3363 1
a3363 1

d3367 1
a3367 1

d3391 1
a3391 1

d3397 1
a3397 1

d3402 1
a3402 1

d3404 1
a3404 1

d3408 1
a3408 1

d3412 1
a3412 1

d3423 1
a3423 1

d3428 1
a3428 1

d3434 1
a3434 1

d3448 1
a3448 1

d3454 1
a3454 1

d3459 1
a3459 1

d3461 1
a3461 1

d3470 1
a3470 1

d3472 1
a3472 1

d3480 1
a3480 1
              s = htab->sgot->output_section;
d3523 1
a3523 1

d3544 1
a3544 1
              bfd_put_32 (output_bfd,
d3571 1
a3571 1

d4476 1
a4476 1
	case R_M32R_GOT16_LO:
d4510 1
a4510 1

d4586 1
a4586 1

d4593 1
a4593 1

d4597 1
a4597 1

d4602 1
a4602 1

d4615 1
a4615 1

@


1.39.6.1
log
@	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Fix pointer
	aliasing warning.  Remove trailing whitespace throughout file.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d96 1
a96 1

d100 1
a100 1

d125 1
a125 1

d128 1
a128 1

d130 1
a130 1

d132 1
a132 1

d134 1
a134 1

d136 1
a136 1

d141 1
a141 1

d145 1
a145 1

d151 1
a151 1

d157 1
a157 1

d1251 1
a1251 1

d1599 1
a1599 1

d1608 1
a1608 1

d1616 1
a1616 1

d1622 1
a1622 1

d1635 1
a1635 1

d1639 1
a1639 1

d1646 1
a1646 1

d1655 1
a1655 1

d1733 1
a1733 2
      struct bfd_link_hash_entry *bh = NULL;
      struct elf_link_hash_entry *h;
d1737 2
a1738 1
              get_elf_backend_data (abfd)->collect, &bh)))
a1739 1
      h = (struct elf_link_hash_entry *) bh;
d1830 1
a1830 1

d1837 1
a1837 1

d1840 1
a1840 1

d1847 1
a1847 1

d1850 1
a1850 1

d1856 1
a1856 1

d1870 1
a1870 1

d1874 1
a1874 1

d1890 1
a1890 1

d1906 1
a1906 1

d1908 1
a1908 1

d1920 1
a1920 1

d1946 1
a1946 1

d1958 1
a1958 1

d1961 1
a1961 1

d1968 1
a1968 1

d2007 1
a2007 1

d2011 1
a2011 1

d2019 1
a2019 1

d2025 1
a2025 1

d2031 1
a2031 1

d2040 1
a2040 1

d2044 1
a2044 1

d2047 1
a2047 1

d2064 1
a2064 1

d2074 1
a2074 1

d2077 1
a2077 1

d2083 1
a2083 1

d2086 1
a2086 1

d2098 1
a2098 1

d2110 1
a2110 1

d2114 1
a2114 1

d2119 1
a2119 1

d2121 1
a2121 1

d2133 1
a2133 1

d2136 1
a2136 1

d2140 1
a2140 1

d2155 1
a2155 1

d2160 1
a2160 1

d2169 1
a2169 1

d2180 1
a2180 1

d2183 1
a2183 1

d2213 1
a2213 1

d2229 1
a2229 1

d2235 1
a2235 1

d2237 1
a2237 1

d2240 1
a2240 1

d2247 1
a2247 1

d2251 1
a2251 1

d2282 1
a2282 1

d2544 1
a2544 1

d2684 1
a2684 1

d2747 1
a2747 1
                                 in its sections against symbols defined
d2784 1
a2784 1
                          (!info->shared
d2809 1
a2809 1
            case R_M32R_GOTPC_LO:
d2824 1
a2824 1
                if ((r_type == R_M32R_GOTPC_HI_SLO)
d2832 1
a2832 1
            case R_M32R_GOT16_LO:
d2838 1
a2838 1

d2843 1
a2843 1

d2863 1
a2863 1

d2876 1
a2876 1

d2883 1
a2883 1

d2886 1
a2886 1

d2888 1
a2888 1

d2897 1
a2897 1

d2902 1
a2902 1

d2907 1
a2907 1

d2918 1
a2918 1

d2921 1
a2921 1

d2929 1
a2929 1

d2933 1
a2933 1

d2953 1
a2953 1

d2958 1
a2958 1

d2989 1
a2989 1

d2993 1
a2993 1

d2997 1
a2997 1

d3004 1
a3004 1

d3009 1
a3009 1

d3013 1
a3013 1

d3016 1
a3016 1

d3027 1
a3027 1

d3071 1
a3071 1

d3241 1
a3241 1

d3245 1
a3245 1

d3258 1
a3258 1

d3261 1
a3261 1

d3263 1
a3263 1

d3324 1
a3324 1

d3342 1
a3342 1

d3356 1
a3356 1

d3359 1
a3359 1

d3363 1
a3363 1

d3367 1
a3367 1

d3391 1
a3391 1

d3397 1
a3397 1

d3402 1
a3402 1

d3404 1
a3404 1

d3408 1
a3408 1

d3412 1
a3412 1

d3423 1
a3423 1

d3428 1
a3428 1

d3434 1
a3434 1

d3448 1
a3448 1

d3454 1
a3454 1

d3459 1
a3459 1

d3461 1
a3461 1

d3470 1
a3470 1

d3472 1
a3472 1

d3480 1
a3480 1
              s = htab->sgot->output_section;
d3523 1
a3523 1

d3544 1
a3544 1
              bfd_put_32 (output_bfd,
d3571 1
a3571 1

d4476 1
a4476 1
	case R_M32R_GOT16_LO:
d4510 1
a4510 1

d4586 1
a4586 1

d4593 1
a4593 1

d4597 1
a4597 1

d4602 1
a4602 1

d4615 1
a4615 1

@


1.39.6.2
log
@Merge from mainline
@
text
@d54 1
a54 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1394 1
a1394 1
     Elf_Internal_Sym *sym;
d1745 1
a1745 1
          && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2052 11
d2108 1
a2108 1
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2112 1
a2112 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d2167 1
a2167 1
          if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2176 1
a2176 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
d2227 1
a2227 1
              if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2445 1
a2445 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2726 1
a2726 2
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
							      info->shared, h)
d2776 2
a2777 1
              else if (info->unresolved_syms_in_objects == RM_IGNORE
d2785 1
a2785 1
                          (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
d2849 1
a2849 1
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d4660 1
a4660 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d4667 1
a4667 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d4671 1
a4671 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.38
log
@Add support for the M32R2 processor.
@
text
@d47 2
d82 5
d91 19
d117 1
a117 1
#define USE_REL	1
d121 45
a165 1
#endif
d375 20
a394 3
};

/* Handle the R_M32R_10_PCREL reloc.  */
d396 14
a409 20
static bfd_reloc_status_type
m32r_elf_10_pcrel_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol;
     PTR data;
     asection * input_section;
     bfd * output_bfd;
     char ** error_message ATTRIBUTE_UNUSED;
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d411 14
a424 5
  if (output_bfd != NULL)
    {
      /* FIXME: See bfd_perform_relocation.  Is this right?  */
      return bfd_reloc_continue;
    }
d426 14
a439 9
  return m32r_elf_do_10_pcrel_reloc (abfd, reloc_entry->howto,
				     input_section,
				     data, reloc_entry->address,
				     symbol->section,
				     (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset),
				     reloc_entry->addend);
}
d441 13
a453 1
/* Utility to actually perform an R_M32R_10_PCREL reloc.  */
d455 14
a468 15
static bfd_reloc_status_type
m32r_elf_do_10_pcrel_reloc (abfd, howto, input_section, data, offset,
			    symbol_section, symbol_value, addend)
     bfd *abfd;
     reloc_howto_type *howto;
     asection *input_section;
     bfd_byte *data;
     bfd_vma offset;
     asection *symbol_section ATTRIBUTE_UNUSED;
     bfd_vma symbol_value;
     bfd_vma addend;
{
  bfd_signed_vma relocation;
  unsigned long x;
  bfd_reloc_status_type status;
d470 14
a483 3
  /* Sanity check the address (offset in section).  */
  if (offset > input_section->_cooked_size)
    return bfd_reloc_outofrange;
d485 14
a498 7
  relocation = symbol_value + addend;
  /* Make it pc relative.  */
  relocation -=	(input_section->output_section->vma
		 + input_section->output_offset);
  /* These jumps mask off the lower two bits of the current address
     before doing pcrel calculations.  */
  relocation -= (offset & -(bfd_vma) 4);
d500 14
a513 4
  if (relocation < -0x200 || relocation > 0x1ff)
    status = bfd_reloc_overflow;
  else
    status = bfd_reloc_ok;
d515 14
a528 5
  x = bfd_get_16 (abfd, data + offset);
  relocation >>= howto->rightshift;
  relocation <<= howto->bitpos;
  x = (x & ~howto->dst_mask) | (((x & howto->src_mask) + relocation) & howto->dst_mask);
  bfd_put_16 (abfd, (bfd_vma) x, data + offset);
d530 14
a543 2
  return status;
}
d545 14
a558 15
/* Handle the R_M32R_HI16_[SU]LO relocs.
   HI16_SLO is for the add3 and load/store with displacement instructions.
   HI16_ULO is for the or3 instruction.
   For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to
   the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then
   we must add one to the high 16 bytes (which will get subtracted off when
   the low 16 bits are added).
   These relocs have to be done in combination with an R_M32R_LO16 reloc
   because there is a carry from the LO16 to the HI16.  Here we just save
   the information we need; we do the actual relocation when we see the LO16.
   This code is copied from the elf32-mips.c.  We also support an arbitrary
   number of HI16 relocs to be associated with a single LO16 reloc.  The
   assembler sorts the relocs to ensure each HI16 immediately precedes its
   LO16.  However if there are multiple copies, the assembler may not find
   the real LO16 so it picks the first one it finds.  */
d560 14
a573 6
struct m32r_hi16
{
  struct m32r_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};
d575 340
a914 1
/* FIXME: This should not be a static variable.  */
d1219 1
a1219 1
static const struct m32r_reloc_map m32r_reloc_map[] =
d1236 32
d1275 10
d1292 1
d1308 1
a1308 1
  BFD_ASSERT (r_type < (unsigned int) R_M32R_max);
d1311 13
d1393 924
a2316 11
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (! info->relocatable
      && (*namep)[0] == '_' && (*namep)[1] == 'S'
      && strcmp (*namep, "_SDA_BASE_") == 0
      && is_elf_hash_table (info->hash))
d2318 5
a2322 8
      /* This is simpler than using _bfd_elf_create_linker_section
	 (our needs are simpler than ppc's needs).  Also
	 _bfd_elf_create_linker_section currently has a bug where if a .sdata
	 section already exists a new one is created that follows it which
	 screws of _SDA_BASE_ address calcs because output_offset != 0.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;
      asection *s = bfd_get_section_by_name (abfd, ".sdata");
d2324 2
a2325 1
      /* The following code was cobbled from elf32-ppc.c and elflink.c.  */
d2327 3
a2329 4
      if (s == NULL)
	{
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d2331 22
a2352 6
	  s = bfd_make_section_anyway (abfd, ".sdata");
	  if (s == NULL)
	    return FALSE;
	  bfd_set_section_flags (abfd, s, flags);
	  bfd_set_section_alignment (abfd, s, 2);
	}
d2354 3
a2356 2
      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 FALSE, FALSE, FALSE);
d2358 17
a2374 14
      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol (info,
						 abfd,
						 "_SDA_BASE_",
						 BSF_GLOBAL,
						 s,
						 (bfd_vma) 32768,
						 (const char *) NULL,
						 FALSE,
						 get_elf_backend_data (abfd)->collect,
						 &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->type = STT_OBJECT;
d2377 8
a2384 1
  switch (sym->st_shndx)
d2386 24
a2409 6
    case SHN_M32R_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }
d2411 14
a2424 2
  return TRUE;
}
d2426 9
a2434 5
/* We have to figure out the SDA_BASE value, so that we can adjust the
   symbol value correctly.  We look up the symbol _SDA_BASE_ in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */
d2436 1
a2436 8
static bfd_reloc_status_type
m32r_elf_final_sda_base (output_bfd, info, error_message, psb)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char **error_message;
     bfd_vma *psb;
{
  if (elf_gp (output_bfd) == 0)
d2438 7
a2444 1
      struct bfd_link_hash_entry *h;
d2446 1
a2446 7
      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (output_bfd) = (h->u.def.value
			       + h->u.def.section->output_section->vma
			       + h->u.def.section->output_offset);
      else
d2448 2
a2449 5
	  /* Only get the error once.  */
	  *psb = elf_gp (output_bfd) = 4;
	  *error_message =
	    (const char *) _("SDA relocation when _SDA_BASE_ not defined");
	  return bfd_reloc_dangerous;
d2451 30
d2482 3
a2484 2
  *psb = elf_gp (output_bfd);
  return bfd_reloc_ok;
a2485 1

d2537 11
a2547 4
#if !USE_REL
  if (info->relocatable)
    return TRUE;
#endif
d2556 1
d2558 3
a2560 3
	 ensure it's zero (we use REL relocs, not RELA).  Therefore this
	 should be assigning zero to `addend', but for clarity we use
	 `r_addend'.  */
a2562 1
      struct elf_link_hash_entry *h;
d2568 1
d2583 4
a2586 1
          || r_type == R_M32R_GNU_VTINHERIT)
d2589 3
d2595 1
a2595 2
#if USE_REL
      if (info->relocatable)
a2655 1
#endif /* USE_REL */
d2662 1
d2670 24
a2693 10
#if !USE_REL
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	      addend = rel->r_addend;
#else
	      /* FIXME: This won't handle local relocations against SEC_MERGE
		 symbols.  See elf32-i386.c for how to do this.  */
	      relocation = (sec->output_section->vma
			    + sec->output_offset
			    + sym->st_value);
#endif
d2698 3
d2710 1
d2712 56
a2767 2
		  if (sec->output_section == NULL)
		    relocation = 0;
d2775 4
d2783 3
a2785 1
			  input_section, offset, TRUE)))
d2800 272
d3076 1
a3076 1
	      break;
d3104 2
a3105 1
	      break;
d3148 3
a3150 1
	      /* fall through */
a3151 1
	    default :
d3155 1
a3155 1
	      break;
d3157 5
d3228 347
d4273 2
d4305 91
a4395 1
  /* we don't use got and plt entries for m32r */
d4414 4
d4422 2
d4430 4
d4437 1
d4442 1
d4448 25
a4472 1
      switch (ELF32_R_TYPE (rel->r_info))
d4474 181
d4657 1
d4669 4
d4685 55
d4748 2
d4751 1
a4751 1
#define elf_info_to_howto			0
d4761 9
d4771 1
a4771 1
#if !USE_REL
d4773 15
d4789 1
d4805 17
@


1.37
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1866 1
d1884 1
d1951 3
a1953 1
      if ((in_flags & EF_M32R_ARCH) != E_M32R_ARCH)
d1986 1
@


1.36
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d846 1
a846 1
      && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.35
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d1110 1
a1110 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.34
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d2097 3
a2099 6
  { ".sdata",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { NULL,	0,	NULL,	0,
    0,		0 }
@


1.33
log
@Correct spelling of "relocatable".
@
text
@d2094 10
d2139 1
@


1.32
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d843 1
a843 1
  if (! info->relocateable
d906 1
a906 1
   external symbol if we are producing relocateable output.  */
d951 1
a951 1
   relocateable output file) adjusting the reloc addend as
d965 1
a965 1
   When generating relocateable output, this function must handle
d990 1
a990 1
  if (info->relocateable)
d1034 1
a1034 1
      if (info->relocateable)
d1036 1
a1036 1
	  /* This is a relocateable link.  We don't have to change
d1353 1
a1353 1
  /* We don't have to do anything for a relocateable link, if
d1356 1
a1356 1
  if (link_info->relocateable
d1747 1
a1747 1
					 data, relocateable, symbols)
d1752 1
a1752 1
     bfd_boolean relocateable;
d1765 1
a1765 1
  if (relocateable
d1769 1
a1769 1
						       relocateable,
d2053 1
a2053 1
  if (info->relocateable)
@


1.31
log
@Comment typo fixes.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1343 1
a1343 1
     _bfd_elf32_link_read_relocs uses [for convenience - it sets the addend
d1371 1
a1371 1
  internal_relocs = (_bfd_elf32_link_read_relocs
d1784 1
a1784 1
      internal_relocs = (_bfd_elf32_link_read_relocs
@


1.31.20.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1343 1
a1343 1
     _bfd_elf_link_read_relocs uses [for convenience - it sets the addend
d1371 1
a1371 1
  internal_relocs = (_bfd_elf_link_read_relocs
d1784 1
a1784 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d574 1
a574 1
     but we have partial_inplace == TRUE.  bfd_elf_generic_reloc will
d612 1
a612 1
     but we have partial_inplace == TRUE.  bfd_elf_generic_reloc will
@


1.29
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d47 1
a47 1
boolean _bfd_m32r_elf_section_from_bfd_section
d51 1
a51 1
static boolean m32r_elf_add_symbol_hook
d54 1
a54 1
static boolean m32r_elf_relocate_section
d58 1
a58 1
static boolean m32r_elf_relax_delete_bytes
d63 1
a63 1
static boolean m32r_elf_object_p
d66 2
a67 2
  PARAMS ((bfd *, boolean));
static boolean m32r_elf_set_private_flags
d69 1
a69 1
static boolean m32r_elf_merge_private_bfd_data
d71 1
a71 1
static boolean m32r_elf_print_private_bfd_data
d73 1
a73 1
static boolean m32r_elf_gc_sweep_hook
d76 1
a76 1
static boolean m32r_elf_check_relocs
d104 1
a104 1
	 false,			/* pc_relative */
d109 1
a109 1
	 false,			/* partial_inplace */
d112 1
a112 1
	 false),		/* pcrel_offset */
d119 1
a119 1
	 false,			/* pc_relative */
d124 1
a124 1
	 true,			/* partial_inplace */
d127 1
a127 1
	 false),		/* pcrel_offset */
d134 1
a134 1
	 false,			/* pc_relative */
d139 1
a139 1
	 true,			/* partial_inplace */
d142 1
a142 1
	 false),		/* pcrel_offset */
d149 1
a149 1
	 false,			/* pc_relative */
d154 1
a154 1
	 true,			/* partial_inplace */
d157 1
a157 1
	 false),		/* pcrel_offset */
d171 1
a171 1
	 true,	                /* pc_relative */
d176 1
a176 1
	 false,	                /* partial_inplace */
d179 1
a179 1
	 true),			/* pcrel_offset */
d186 1
a186 1
	 true,			/* pc_relative */
d191 1
a191 1
	 false,			/* partial_inplace */
d194 1
a194 1
	 true),			/* pcrel_offset */
d205 1
a205 1
	 true,			/* pc_relative */
d210 1
a210 1
	 false,			/* partial_inplace */
d213 1
a213 1
	 true),			/* pcrel_offset */
d220 1
a220 1
	 false,			/* pc_relative */
d225 1
a225 1
	 true,			/* partial_inplace */
d228 1
a228 1
	 false),		/* pcrel_offset */
d235 1
a235 1
	 false,			/* pc_relative */
d240 1
a240 1
	 true,			/* partial_inplace */
d243 1
a243 1
	 false),		/* pcrel_offset */
d250 1
a250 1
	 false,			/* pc_relative */
d255 1
a255 1
	 true,			/* partial_inplace */
d258 1
a258 1
	 false),		/* pcrel_offset */
d265 1
a265 1
	 false,			/* pc_relative */
d270 1
a270 1
	 true,			/* partial_inplace */  /* FIXME: correct? */
d273 1
a273 1
	 false),		/* pcrel_offset */
d280 1
a280 1
         false,                 /* pc_relative */
d285 1
a285 1
         false,                 /* partial_inplace */
d288 1
a288 1
         false),                /* pcrel_offset */
d295 1
a295 1
         false,                 /* pc_relative */
d300 1
a300 1
         false,                 /* partial_inplace */
d303 1
a303 1
         false),                /* pcrel_offset */
d771 1
a771 1
boolean
d780 1
a780 1
      return true;
d782 1
a782 1
  return false;
d833 1
a833 1
static boolean
d866 1
a866 1
	    return false;
d872 1
a872 1
				 false, false, false);
d882 1
a882 1
						 false,
d885 1
a885 1
	return false;
d899 1
a899 1
  return true;
d919 1
a919 1
      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", false, false, true);
d971 1
a971 1
static boolean
d987 1
a987 1
  boolean ret = true;
d991 1
a991 1
    return true;
d1022 1
a1022 1
	  ret = false;
d1146 2
a1147 2
			  input_section, offset, true)))
		    return false;
d1214 1
a1214 1
			ret = false;
d1232 1
a1232 1
		    ret = false;
d1272 1
a1272 1
		return false;
d1278 2
a1279 2
		      offset, true)))
		return false;
d1302 1
a1302 1
		return false;
d1334 1
a1334 1
static boolean
d1339 1
a1339 1
     boolean *again;
d1351 1
a1351 1
  *again = false;
d1361 1
a1361 1
    return true;
d1611 1
a1611 1
	  *again = true;
d1647 1
a1647 1
  return true;
d1660 1
a1660 1
  return false;
d1665 1
a1665 1
static boolean
d1739 1
a1739 1
  return true;
d1752 1
a1752 1
     boolean relocateable;
d1786 1
a1786 1
			  (Elf_Internal_Rela *) NULL, false));
d1857 1
a1857 1
static boolean
d1867 1
a1867 1
  return true;
d1873 2
a1874 2
     bfd *   abfd;
     boolean linker ATTRIBUTE_UNUSED;
d1890 1
a1890 1
static boolean
d1892 1
a1892 1
     bfd *    abfd;
d1899 2
a1900 2
  elf_flags_init (abfd) = true;
  return true;
d1905 1
a1905 1
static boolean
d1907 2
a1908 2
     bfd * ibfd;
     bfd * obfd;
d1915 1
a1915 1
    return true;
d1929 1
a1929 1
	return true;
d1931 1
a1931 1
      elf_flags_init (obfd) = true;
d1940 1
a1940 1
      return true;
d1945 1
a1945 1
    return true;
d1956 1
a1956 1
	  return false;
d1960 1
a1960 1
  return true;
d1964 1
a1964 1
static boolean
d1966 2
a1967 2
     bfd *   abfd;
     PTR     ptr;
d1986 1
a1986 1
  return true;
d2026 1
a2026 1
static boolean
d2034 1
a2034 1
  return true;
d2041 1
a2041 1
static boolean
d2054 1
a2054 1
    return true;
d2080 1
a2080 1
            return false;
d2087 1
a2087 1
            return false;
d2092 1
a2092 1
  return true;
@


1.28
log
@	* elfxx-target.h (USE_REL): Don't define as 1.
	* elf32-arm.h (USE_REL): Provide a default define of 0.
	Use #if rather than #ifdef when testing USE_REL.
	* elf32-m32r.c: Likewise.

	* elf32-arc.c (USE_REL): Define as 1.
	* elf32-d10v.c (USE_REL): Likewise.
	* elf32-m32r.c (USE_REL): Likewise.
	* elf32-m68hc11.c (USE_REL): Likewise.
	* elf32-m68hc12.c (USE_REL): Likewise.
	* elf32-or32.c (USE_REL): Likewise.
	* elfarm-nabi.c (USE_REL): Likewise.
@
text
@d46 1
a46 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d759 1
a759 1
     Elf32_Internal_Rel *dst;
@


1.27
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d91 5
a95 1
#define USE_REL
d989 1
a989 1
#ifndef USE_REL
d1033 1
a1033 1
#ifdef USE_REL
d1109 1
a1109 1
#ifndef USE_REL
d1514 1
a1514 1
#ifndef USE_REL /* put in for learning purposes */
d1543 1
a1543 1
#ifndef USE_REL /* put in for learning purposes */
d1553 1
a1553 1
#ifndef USE_REL /* put in for learning purposes */
d2114 1
a2114 1
#ifndef USE_REL
@


1.26
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d850 1
d867 2
a868 2
      h = (struct elf_link_hash_entry *)
	bfd_link_hash_lookup (info->hash, "_SDA_BASE_", false, false, false);
d870 1
a870 1
      if ((h == NULL || h->root.type == bfd_link_hash_undefined)
d880 1
a880 1
						 (struct bfd_link_hash_entry **) &h)))
d882 1
@


1.26.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d91 1
a91 5
#define USE_REL	1

#ifndef USE_REL
#define USE_REL	0
#endif
a849 1
      struct bfd_link_hash_entry *bh;
d866 2
a867 2
      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 false, false, false);
d869 1
a869 1
      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
d879 1
a879 1
						 &bh)))
a880 1
      h = (struct elf_link_hash_entry *) bh;
d983 1
a983 1
#if !USE_REL
d1027 1
a1027 1
#if USE_REL
d1103 1
a1103 1
#if !USE_REL
d1508 1
a1508 1
#if !USE_REL /* put in for learning purposes */
d1537 1
a1537 1
#if !USE_REL /* put in for learning purposes */
d1547 1
a1547 1
#if !USE_REL /* put in for learning purposes */
d2108 1
a2108 1
#if !USE_REL
@


1.26.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d46 2
a47 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
bfd_boolean _bfd_m32r_elf_section_from_bfd_section
d51 1
a51 1
static bfd_boolean m32r_elf_add_symbol_hook
d54 1
a54 1
static bfd_boolean m32r_elf_relocate_section
d58 1
a58 1
static bfd_boolean m32r_elf_relax_delete_bytes
d63 1
a63 1
static bfd_boolean m32r_elf_object_p
d66 2
a67 2
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean m32r_elf_set_private_flags
d69 1
a69 1
static bfd_boolean m32r_elf_merge_private_bfd_data
d71 1
a71 1
static bfd_boolean m32r_elf_print_private_bfd_data
d73 1
a73 1
static bfd_boolean m32r_elf_gc_sweep_hook
d76 1
a76 1
static bfd_boolean m32r_elf_check_relocs
d104 1
a104 1
	 FALSE,			/* pc_relative */
d109 1
a109 1
	 FALSE,			/* partial_inplace */
d112 1
a112 1
	 FALSE),		/* pcrel_offset */
d119 1
a119 1
	 FALSE,			/* pc_relative */
d124 1
a124 1
	 TRUE,			/* partial_inplace */
d127 1
a127 1
	 FALSE),		/* pcrel_offset */
d134 1
a134 1
	 FALSE,			/* pc_relative */
d139 1
a139 1
	 TRUE,			/* partial_inplace */
d142 1
a142 1
	 FALSE),		/* pcrel_offset */
d149 1
a149 1
	 FALSE,			/* pc_relative */
d154 1
a154 1
	 TRUE,			/* partial_inplace */
d157 1
a157 1
	 FALSE),		/* pcrel_offset */
d171 1
a171 1
	 TRUE,	                /* pc_relative */
d176 1
a176 1
	 FALSE,	                /* partial_inplace */
d179 1
a179 1
	 TRUE),			/* pcrel_offset */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 TRUE),			/* pcrel_offset */
d205 1
a205 1
	 TRUE,			/* pc_relative */
d210 1
a210 1
	 FALSE,			/* partial_inplace */
d213 1
a213 1
	 TRUE),			/* pcrel_offset */
d220 1
a220 1
	 FALSE,			/* pc_relative */
d225 1
a225 1
	 TRUE,			/* partial_inplace */
d228 1
a228 1
	 FALSE),		/* pcrel_offset */
d235 1
a235 1
	 FALSE,			/* pc_relative */
d240 1
a240 1
	 TRUE,			/* partial_inplace */
d243 1
a243 1
	 FALSE),		/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 TRUE,			/* partial_inplace */
d258 1
a258 1
	 FALSE),		/* pcrel_offset */
d265 1
a265 1
	 FALSE,			/* pc_relative */
d270 1
a270 1
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
d273 1
a273 1
	 FALSE),		/* pcrel_offset */
d280 1
a280 1
         FALSE,                 /* pc_relative */
d285 1
a285 1
         FALSE,                 /* partial_inplace */
d288 1
a288 1
         FALSE),                /* pcrel_offset */
d295 1
a295 1
         FALSE,                 /* pc_relative */
d300 1
a300 1
         FALSE,                 /* partial_inplace */
d303 1
a303 1
         FALSE),                /* pcrel_offset */
d574 1
a574 1
     but we have partial_inplace set.  bfd_elf_generic_reloc will
d612 1
a612 1
     but we have partial_inplace set.  bfd_elf_generic_reloc will
d759 1
a759 1
     Elf_Internal_Rela *dst;
d771 1
a771 1
bfd_boolean
d780 1
a780 1
      return TRUE;
d782 1
a782 1
  return FALSE;
d833 1
a833 1
static bfd_boolean
d843 1
a843 1
  if (! info->relocatable
d846 1
a846 1
      && is_elf_hash_table (info->hash))
d866 1
a866 1
	    return FALSE;
d872 1
a872 1
				 FALSE, FALSE, FALSE);
d882 1
a882 1
						 FALSE,
d885 1
a885 1
	return FALSE;
d899 1
a899 1
  return TRUE;
d906 1
a906 1
   external symbol if we are producing relocatable output.  */
d919 1
a919 1
      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
d951 1
a951 1
   relocatable output file) adjusting the reloc addend as
d965 1
a965 1
   When generating relocatable output, this function must handle
d971 1
a971 1
static bfd_boolean
d987 1
a987 1
  bfd_boolean ret = TRUE;
d990 2
a991 2
  if (info->relocatable)
    return TRUE;
d1022 1
a1022 1
	  ret = FALSE;
d1034 1
a1034 1
      if (info->relocatable)
d1036 1
a1036 1
	  /* This is a relocatable link.  We don't have to change
d1110 1
a1110 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1146 2
a1147 2
			  input_section, offset, TRUE)))
		    return FALSE;
d1214 1
a1214 1
			ret = FALSE;
d1232 1
a1232 1
		    ret = FALSE;
d1272 1
a1272 1
		return FALSE;
d1278 2
a1279 2
		      offset, TRUE)))
		return FALSE;
d1302 1
a1302 1
		return FALSE;
d1334 1
a1334 1
static bfd_boolean
d1339 1
a1339 1
     bfd_boolean *again;
d1343 1
a1343 1
     _bfd_elf_link_read_relocs uses [for convenience - it sets the addend
d1351 1
a1351 1
  *again = FALSE;
d1353 1
a1353 1
  /* We don't have to do anything for a relocatable link, if
d1356 1
a1356 1
  if (link_info->relocatable
d1361 1
a1361 1
    return TRUE;
d1371 1
a1371 1
  internal_relocs = (_bfd_elf_link_read_relocs
d1611 1
a1611 1
	  *again = TRUE;
d1647 1
a1647 1
  return TRUE;
d1660 1
a1660 1
  return FALSE;
d1665 1
a1665 1
static bfd_boolean
d1739 1
a1739 1
  return TRUE;
d1747 1
a1747 1
					 data, relocatable, symbols)
d1752 1
a1752 1
     bfd_boolean relocatable;
d1765 1
a1765 1
  if (relocatable
d1769 1
a1769 1
						       relocatable,
d1784 1
a1784 1
      internal_relocs = (_bfd_elf_link_read_relocs
d1786 1
a1786 1
			  (Elf_Internal_Rela *) NULL, FALSE));
d1857 1
a1857 1
static bfd_boolean
a1865 1
    case E_M32R2_ARCH:  (void) bfd_default_set_arch_mach (abfd, bfd_arch_m32r, bfd_mach_m32r2); break;
d1867 1
a1867 1
  return TRUE;
d1873 2
a1874 2
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
a1882 1
    case bfd_mach_m32r2: val = E_M32R2_ARCH; break;
d1890 1
a1890 1
static bfd_boolean
d1892 1
a1892 1
     bfd *abfd;
d1899 2
a1900 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1905 1
a1905 1
static bfd_boolean
d1907 2
a1908 2
     bfd *ibfd;
     bfd *obfd;
d1915 1
a1915 1
    return TRUE;
d1929 1
a1929 1
	return TRUE;
d1931 1
a1931 1
      elf_flags_init (obfd) = TRUE;
d1940 1
a1940 1
      return TRUE;
d1945 1
a1945 1
    return TRUE;
d1949 1
a1949 3
      if (   ((in_flags  & EF_M32R_ARCH) != E_M32R_ARCH)
          || ((out_flags & EF_M32R_ARCH) == E_M32R_ARCH)
          || ((in_flags  & EF_M32R_ARCH) == E_M32R2_ARCH))
d1956 1
a1956 1
	  return FALSE;
d1960 1
a1960 1
  return TRUE;
d1964 1
a1964 1
static bfd_boolean
d1966 2
a1967 2
     bfd *abfd;
     PTR ptr;
a1981 1
    case E_M32R2_ARCH: fprintf (file, _(": m32r2 instructions")); break;
d1986 1
a1986 1
  return TRUE;
d2026 1
a2026 1
static bfd_boolean
d2034 1
a2034 1
  return TRUE;
d2041 1
a2041 1
static bfd_boolean
d2053 2
a2054 2
  if (info->relocatable)
    return TRUE;
d2080 1
a2080 1
            return FALSE;
d2087 1
a2087 1
            return FALSE;
d2092 1
a2092 1
  return TRUE;
a2093 7

static struct bfd_elf_special_section const m32r_elf_special_sections[]=
{
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
};
a2128 1
#define elf_backend_special_sections		m32r_elf_special_sections
@


1.26.12.3
log
@Merge from mainline.
@
text
@a46 2
static void m32r_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
a79 5
static bfd_boolean m32r_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean m32r_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

a83 19
static bfd_boolean m32r_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean m32r_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
                                                                                
static bfd_boolean m32r_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
           Elf_Internal_Sym *));
                                                                                
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static enum elf_reloc_type_class m32r_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean m32r_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));

d91 1
a91 1
/* #define USE_REL	1
d95 1
a95 45
#endif */
/* Use RELA. But use REL to link old objects for backwords compatibility. */

/* Functions for the M32R ELF linker.  */
                                                                                
/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
                                                                                
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
                                                                                
/* The nop opcode we use.  */
                                                                                
#define M32R_NOP 0x7000f000
                                                                                
#define PLT_EMPTY   0x10101010  /* RIE  -> RIE */
                                                                                
/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 20
#define PLT_HEADER_SIZE 20
                                                                                
/* The first one entries in a procedure linkage table are reserved,
   and the initial contents are unimportant (we zero them out).
   Subsequent entries look like this. */
                                                                                
#define PLT0_ENTRY_WORD0  0xd6c00000    /* seth r6, #high(.got+4)          */
#define PLT0_ENTRY_WORD1  0x86e60000    /* or3  r6, r6, #low(.got)+4)      */
#define PLT0_ENTRY_WORD2  0x24e626c6    /* ld   r4, @@r6+    -> ld r6, @@r6  */
#define PLT0_ENTRY_WORD3  0x1fc6f000    /* jmp  r6          || pnop        */
#define PLT0_ENTRY_WORD4  PLT_EMPTY     /* RIE             -> RIE          */
                                                                                
#define PLT0_PIC_ENTRY_WORD0  0xa4cc0004 /* ld   r4, @@(4,r12)              */
#define PLT0_PIC_ENTRY_WORD1  0xa6cc0008 /* ld   r6, @@(8,r12)              */
#define PLT0_PIC_ENTRY_WORD2  0x1fc6f000 /* jmp  r6         || nop         */
#define PLT0_PIC_ENTRY_WORD3  PLT_EMPTY  /* RIE             -> RIE         */
#define PLT0_PIC_ENTRY_WORD4  PLT_EMPTY  /* RIE             -> RIE         */
                                                                                
#define PLT_ENTRY_WORD0  0xe6000000 /* ld24 r6, .name_in_GOT                */
#define PLT_ENTRY_WORD1  0x06acf000 /* add  r6, r12          || nop         */
#define PLT_ENTRY_WORD0b 0xd6c00000 /* seth r6, #high(.name_in_GOT)         */
#define PLT_ENTRY_WORD1b 0x86e60000 /* or3  r6, r6, #low(.name_in_GOT)      */
#define PLT_ENTRY_WORD2  0x26c61fc6 /* ld  r6, @@r6           -> jmp r6      */
#define PLT_ENTRY_WORD3  0xe5000000 /* ld24 r5, $offset                     */
#define PLT_ENTRY_WORD4  0xff000000 /* bra  .plt0.                          */

d305 24
a328 20
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),
  EMPTY_HOWTO (25),
  EMPTY_HOWTO (26),
  EMPTY_HOWTO (27),
  EMPTY_HOWTO (28),
  EMPTY_HOWTO (29),
  EMPTY_HOWTO (30),
  EMPTY_HOWTO (31),
  EMPTY_HOWTO (32),
d330 5
a334 14
  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16_RELA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d336 9
a344 14
  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_32_RELA",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d346 1
a346 14
  /* A 24 bit address.  */
  HOWTO (R_M32R_24_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_24_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d348 15
a362 13
  HOWTO (R_M32R_10_PCREL_RELA,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL_RELA",/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d364 3
a366 14
  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d368 7
a374 14
  /* A relative 26 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_26_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d376 4
a379 14
  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_ULO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d381 5
a385 14
  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_SLO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d387 2
a388 14
  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16_RELA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_LO16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d390 15
a404 14
  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_SDA16_RELA",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d406 6
a411 14
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M32R_RELA_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_RELA_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d413 1
a413 14
  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M32R_RELA_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_RELA_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d415 1
a415 19
  EMPTY_HOWTO (45),
  EMPTY_HOWTO (46),
  EMPTY_HOWTO (47),

  /* Like R_M32R_24, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOT24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d417 1
a417 324
  /* Like R_M32R_PCREL, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_M32R_26_PLTREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PLTREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_M32R_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_24, but used when setting global offset table
     entries.  */
  HOWTO (R_M32R_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_M32R_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_M32R_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_RELATIVE",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTOFF",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative 24-bit relocation used when setting PIC offset
     table register. */
  HOWTO (R_M32R_GOTPC24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTPC24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
};

/* Handle the R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_10_pcrel_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol;
     PTR data;
     asection * input_section;
     bfd * output_bfd;
     char ** error_message ATTRIBUTE_UNUSED;
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    {
      /* FIXME: See bfd_perform_relocation.  Is this right?  */
      return bfd_reloc_continue;
    }

  return m32r_elf_do_10_pcrel_reloc (abfd, reloc_entry->howto,
				     input_section,
				     data, reloc_entry->address,
				     symbol->section,
				     (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset),
				     reloc_entry->addend);
}

/* Utility to actually perform an R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_do_10_pcrel_reloc (abfd, howto, input_section, data, offset,
			    symbol_section, symbol_value, addend)
     bfd *abfd;
     reloc_howto_type *howto;
     asection *input_section;
     bfd_byte *data;
     bfd_vma offset;
     asection *symbol_section ATTRIBUTE_UNUSED;
     bfd_vma symbol_value;
     bfd_vma addend;
{
  bfd_signed_vma relocation;
  unsigned long x;
  bfd_reloc_status_type status;

  /* Sanity check the address (offset in section).  */
  if (offset > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  relocation = symbol_value + addend;
  /* Make it pc relative.  */
  relocation -=	(input_section->output_section->vma
		 + input_section->output_offset);
  /* These jumps mask off the lower two bits of the current address
     before doing pcrel calculations.  */
  relocation -= (offset & -(bfd_vma) 4);

  if (relocation < -0x200 || relocation > 0x1ff)
    status = bfd_reloc_overflow;
  else
    status = bfd_reloc_ok;

  x = bfd_get_16 (abfd, data + offset);
  relocation >>= howto->rightshift;
  relocation <<= howto->bitpos;
  x = (x & ~howto->dst_mask) | (((x & howto->src_mask) + relocation) & howto->dst_mask);
  bfd_put_16 (abfd, (bfd_vma) x, data + offset);

  return status;
}

/* Handle the R_M32R_HI16_[SU]LO relocs.
   HI16_SLO is for the add3 and load/store with displacement instructions.
   HI16_ULO is for the or3 instruction.
   For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to
   the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then
   we must add one to the high 16 bytes (which will get subtracted off when
   the low 16 bits are added).
   These relocs have to be done in combination with an R_M32R_LO16 reloc
   because there is a carry from the LO16 to the HI16.  Here we just save
   the information we need; we do the actual relocation when we see the LO16.
   This code is copied from the elf32-mips.c.  We also support an arbitrary
   number of HI16 relocs to be associated with a single LO16 reloc.  The
   assembler sorts the relocs to ensure each HI16 immediately precedes its
   LO16.  However if there are multiple copies, the assembler may not find
   the real LO16 so it picks the first one it finds.  */

struct m32r_hi16
{
  struct m32r_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct m32r_hi16 *m32r_hi16_list;

static bfd_reloc_status_type
d718 1
a718 1
static const struct m32r_reloc_map m32r_reloc_map_old[] =
a734 32
static const struct m32r_reloc_map m32r_reloc_map[] =
{
  { BFD_RELOC_NONE, R_M32R_NONE },
  { BFD_RELOC_16, R_M32R_16_RELA },
  { BFD_RELOC_32, R_M32R_32_RELA },
  { BFD_RELOC_M32R_24, R_M32R_24_RELA },
  { BFD_RELOC_M32R_10_PCREL, R_M32R_10_PCREL_RELA },
  { BFD_RELOC_M32R_18_PCREL, R_M32R_18_PCREL_RELA },
  { BFD_RELOC_M32R_26_PCREL, R_M32R_26_PCREL_RELA },
  { BFD_RELOC_M32R_HI16_ULO, R_M32R_HI16_ULO_RELA },
  { BFD_RELOC_M32R_HI16_SLO, R_M32R_HI16_SLO_RELA },
  { BFD_RELOC_M32R_LO16, R_M32R_LO16_RELA },
  { BFD_RELOC_M32R_SDA16, R_M32R_SDA16_RELA },
  { BFD_RELOC_VTABLE_INHERIT, R_M32R_RELA_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_M32R_RELA_GNU_VTENTRY },
                                                                                
  { BFD_RELOC_M32R_GOT24, R_M32R_GOT24 },
  { BFD_RELOC_M32R_26_PLTREL, R_M32R_26_PLTREL },
  { BFD_RELOC_M32R_COPY, R_M32R_COPY },
  { BFD_RELOC_M32R_GLOB_DAT, R_M32R_GLOB_DAT },
  { BFD_RELOC_M32R_JMP_SLOT, R_M32R_JMP_SLOT },
  { BFD_RELOC_M32R_RELATIVE, R_M32R_RELATIVE },
  { BFD_RELOC_M32R_GOTOFF, R_M32R_GOTOFF },
  { BFD_RELOC_M32R_GOTPC24, R_M32R_GOTPC24 },
  { BFD_RELOC_M32R_GOT16_HI_ULO, R_M32R_GOT16_HI_ULO },
  { BFD_RELOC_M32R_GOT16_HI_SLO, R_M32R_GOT16_HI_SLO },
  { BFD_RELOC_M32R_GOT16_LO, R_M32R_GOT16_LO },
  { BFD_RELOC_M32R_GOTPC_HI_ULO, R_M32R_GOTPC_HI_ULO },
  { BFD_RELOC_M32R_GOTPC_HI_SLO, R_M32R_GOTPC_HI_SLO },
  { BFD_RELOC_M32R_GOTPC_LO, R_M32R_GOTPC_LO },
};

a741 10
#ifdef USE_M32R_OLD_RELOC
  for (i = 0;
       i < sizeof (m32r_reloc_map_old) / sizeof (struct m32r_reloc_map);
       i++)
    {
      if (m32r_reloc_map_old[i].bfd_reloc_val == code)
	return &m32r_elf_howto_table[m32r_reloc_map_old[i].elf_reloc_val];
    }
#else /* ! USE_M32R_OLD_RELOC */

a748 1
#endif
d756 1
a756 14
m32r_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) <= (unsigned int) R_M32R_GNU_VTENTRY)
  cache_ptr->howto = &m32r_elf_howto_table[r_type];
}

static void
m32r_info_to_howto (abfd, cache_ptr, dst)
d761 5
a765 4
  BFD_ASSERT ((ELF32_R_TYPE(dst->r_info) == (unsigned int) R_M32R_NONE)
              || ((ELF32_R_TYPE(dst->r_info) > (unsigned int) R_M32R_GNU_VTENTRY)
                  && (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_M32R_max)));
  cache_ptr->howto = &m32r_elf_howto_table[ELF32_R_TYPE(dst->r_info)];
a766 1

d857 1
a857 859
      /* The following code was cobbled from elf32-ppc.c and elflink.c.  */

      if (s == NULL)
	{
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);

	  s = bfd_make_section_anyway (abfd, ".sdata");
	  if (s == NULL)
	    return FALSE;
	  bfd_set_section_flags (abfd, s, flags);
	  bfd_set_section_alignment (abfd, s, 2);
	}

      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol (info,
						 abfd,
						 "_SDA_BASE_",
						 BSF_GLOBAL,
						 s,
						 (bfd_vma) 32768,
						 (const char *) NULL,
						 FALSE,
						 get_elf_backend_data (abfd)->collect,
						 &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->type = STT_OBJECT;
    }

  switch (sym->st_shndx)
    {
    case SHN_M32R_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

/* We have to figure out the SDA_BASE value, so that we can adjust the
   symbol value correctly.  We look up the symbol _SDA_BASE_ in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
m32r_elf_final_sda_base (output_bfd, info, error_message, psb)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char **error_message;
     bfd_vma *psb;
{
  if (elf_gp (output_bfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (output_bfd) = (h->u.def.value
			       + h->u.def.section->output_section->vma
			       + h->u.def.section->output_offset);
      else
	{
	  /* Only get the error once.  */
	  *psb = elf_gp (output_bfd) = 4;
	  *error_message =
	    (const char *) _("SDA relocation when _SDA_BASE_ not defined");
	  return bfd_reloc_dangerous;
	}
    }
  *psb = elf_gp (output_bfd);
  return bfd_reloc_ok;
}

/* Return size of a PLT entry.  */
#define elf_m32r_sizeof_plt(info) PLT_ENTRY_SIZE

/* The m32r linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_m32r_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_m32r_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* The sh linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_m32r_dyn_relocs
{
  struct elf_m32r_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};


/* m32r ELF linker hash entry.  */

struct elf_m32r_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_m32r_dyn_relocs *dyn_relocs;

//  bfd_signed_vma gotplt_refcount;

  /* Number of PC relative relocs copied for this symbol.  */
  /* struct elf_m32r_pcrel_relocs_copied *pcrel_relocs_copied;  FIXME */
};

/* m32r ELF linker hash table.  */

struct elf_m32r_link_hash_table
{
  struct elf_link_hash_table root;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Traverse an m32r ELF linker hash table.  */

#define m32r_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the m32r ELF linker hash table from a link_info structure.  */


#define m32r_elf_hash_table(p) \
  ((struct elf_m32r_link_hash_table *) ((p)->hash))

/* Create an entry in an m32r ELF linker hash table.  */
static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (struct bfd_hash_entry *, struct bfd_hash_table *,
                            const char * );

static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elf_m32r_link_hash_entry *ret =
    (struct elf_m32r_link_hash_entry *) entry;
    
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    ret = ((struct elf_m32r_link_hash_entry *)
           bfd_hash_allocate (table,
                              sizeof (struct elf_m32r_link_hash_entry)));
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
   
  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_m32r_link_hash_entry *)
         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
                                     table, string));
  if (ret != (struct elf_m32r_link_hash_entry *) NULL)
    {
      struct elf_m32r_link_hash_entry *eh;
  
      eh = (struct elf_m32r_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
//      eh->gotplt_refcount = 0;
      /* eh->pcrel_relocs_copied = NULL; FIXME */
    }
                                                                                                 
  return (struct bfd_hash_entry *) ret;
}

/* Create an m32r ELF linker hash table.  */
static struct bfd_link_hash_table *m32r_elf_link_hash_table_create (bfd *);

static struct bfd_link_hash_table *
m32r_elf_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct elf_m32r_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_m32r_link_hash_table);
                                                                                                 
  ret = (struct elf_m32r_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_m32r_link_hash_table *) NULL)
    return NULL;
              
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
                                       m32r_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }
               
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_sec.abfd = NULL;
                
  return &ret->root.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */
static bfd_boolean create_got_section (bfd *, struct bfd_link_info *);

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = m32r_elf_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (! htab->sgot || ! htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
                                  (SEC_ALLOC
                                   | SEC_LOAD
                                   | SEC_HAS_CONTENTS
                                   | SEC_IN_MEMORY
                                   | SEC_LINKER_CREATED
                                   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

static bfd_boolean
m32r_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  flagword flags, pltflags;
  register asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign = 2; /* 32bit */

  htab = m32r_elf_hash_table (info);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
           | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section (abfd, ".plt");
  htab->splt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
         .plt section.  */
      struct elf_link_hash_entry *h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
             (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
              (bfd_vma) 0, (const char *) NULL, FALSE,
              get_elf_backend_data (abfd)->collect,
              (struct bfd_link_hash_entry **) &h)))
        return FALSE;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (info->shared
          && ! _bfd_elf_link_record_dynamic_symbol (info, h))
        return FALSE;
    }

  s = bfd_make_section (abfd,
                        bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
  htab->srelplt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (htab->sgot == NULL
      && ! create_got_section (abfd, info))
    return FALSE;

  {
    const char *secname;
    char *relname;
    flagword secflags;
    asection *sec;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
        secflags = bfd_get_section_flags (abfd, sec);
        if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
            || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
          continue;
        secname = bfd_get_section_name (abfd, sec);
        relname = (char *) bfd_malloc ((bfd_size_type) strlen (secname) + 6);
        strcpy (relname, ".rela");
        strcat (relname, secname);
        if (bfd_get_section_by_name (abfd, secname))
          continue;
        s = bfd_make_section (abfd, relname);
        if (s == NULL
            || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
            || ! bfd_set_section_alignment (abfd, s, ptralign))
          return FALSE;
      }
  }

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
         by dynamic objects, are referenced by regular objects, and are
         not functions.  We must allocate space for them in the process
         image and use a R_*_COPY reloc to tell the dynamic linker to
         initialize them at run time.  The linker script puts the .dynbss
         section into the .bss section of the final image.  */
      s = bfd_make_section (abfd, ".dynbss");
      htab->sdynbss = s;
      if (s == NULL
          || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
        return FALSE;
      /* The .rel[a].bss section holds copy relocs.  This section is not
         normally needed.  We need to create it here, though, so that the
         linker will map it to an output section.  We can't just create it
         only if we need it, because we will not know whether we need it
         until we have seen all the input files, and the first time the
         main linker code calls BFD after examining all the input files
         (size_dynamic_sections) the input sections have already been
         mapped to the output sections.  If the section turns out not to
         be needed, we can discard it later.  We will never need this
         section when generating a shared object, since they do not use
         copy relocs.  */
      if (! info->shared)
        {
          s = bfd_make_section (abfd,
                                (bed->default_use_rela_p
                                 ? ".rela.bss" : ".rel.bss"));
          htab->srelbss = s;
          if (s == NULL
              || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
              || ! bfd_set_section_alignment (abfd, s, ptralign))
            return FALSE;
        }
    }

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */
static void m32r_elf_copy_indirect_symbol (const struct elf_backend_data *,
                                           struct elf_link_hash_entry *,
                                           struct elf_link_hash_entry *);
                                                                                
static void
m32r_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
                               struct elf_link_hash_entry *dir,
                               struct elf_link_hash_entry *ind)
{
  struct elf_m32r_link_hash_entry *edir, *eind;
                                                                                
  edir = (struct elf_m32r_link_hash_entry *) dir;
  eind = (struct elf_m32r_link_hash_entry *) ind;
                                                                                
  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
        {
          struct elf_m32r_dyn_relocs **pp;
          struct elf_m32r_dyn_relocs *p;
                                                                                
          if (ind->root.type == bfd_link_hash_indirect)
            abort ();
                                                                                
          /* Add reloc counts against the weak sym to the strong sym
             list.  Merge any entries against the same section.  */
          for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
            {
              struct elf_m32r_dyn_relocs *q;
                                                                                
              for (q = edir->dyn_relocs; q != NULL; q = q->next)
                if (q->sec == p->sec)
                  {
                    q->pc_count += p->pc_count;
                    q->count += p->count;
                    *pp = p->next;
                    break;
                  }
              if (q == NULL)
                pp = &p->next;
            }
          *pp = edir->dyn_relocs;
        }
                                                                                
      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }
                                                                                
//  if (ind->root.type == bfd_link_hash_indirect
//      && dir->got.refcount <= 0)
//    {
//      edir->tls_type = eind->tls_type;
//      eind->tls_type = GOT_UNKNOWN;
//    }
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}


/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */
 
static bfd_boolean
m32r_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;
  bfd *dynobj;
  asection *s;
  unsigned int power_of_two;

#ifdef DEBUG_PIC
printf("m32r_elf_adjust_dynamic_symbol()\n");
#endif
 
  dynobj = elf_hash_table (info)->dynobj;
 
  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
              && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
                  || h->weakdef != NULL
                  || ((h->elf_link_hash_flags
                       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_REF_REGULAR) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)));

 
  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (! info->shared
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
          && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	  && h->root.type != bfd_link_hash_undefweak
	  && h->root.type != bfd_link_hash_undefined)
        {
          /* This case can occur if we saw a PLT reloc in an input
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PCREL
             reloc instead.  */
          h->plt.offset = (bfd_vma) -1;
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
        }

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;
 
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
                  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return TRUE;
    }
 
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
 
  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;
 
  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
    }

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
        break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */
 
  htab = m32r_elf_hash_table (info);
  s = htab->sdynbss;
  BFD_ASSERT (s != NULL);
 
  /* We must generate a R_M32R_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;
 
      srel = htab->srelbss;
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
    }
 
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;
 
  /* Apply the required alignment.  */
  s->_raw_size = BFD_ALIGN (s->_raw_size,
                            (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
        return FALSE;
    }
 
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->_raw_size;
 
  /* Increment the section size to make room for the symbol.  */
  s->_raw_size += h->size;
 
  return TRUE;
}

/* This is the condition under which finish_dynamic_symbol will be called
   from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol
   routine, we'll need to do something about initializing any .plt and .got
   entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H)			\
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */
                  
static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;
                 
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
                
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
               
  info = (struct bfd_link_info *) inf;
  htab = m32r_elf_hash_table (info);
              
  eh = (struct elf_m32r_link_hash_entry *) h;
//  if ((h->got.refcount > 0
//      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
//      && eh->gotplt_refcount > 0)
//    {
//      /* The symbol has been forced local, or we have some direct got refs,
//         so treat all the gotplt refs as got refs. */
//      h->got.refcount += eh->gotplt_refcount;
//      if (h->plt.refcount >= eh->gotplt_refcount)
//        h->plt.refcount -= eh->gotplt_refcount;
//    }
             
  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
        {
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
            return FALSE;
        }
            
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
        {
          asection *s = htab->splt;
           
          /* If this is the first .plt entry, make room for the special
             first entry.  */
          if (s->_raw_size == 0)
            s->_raw_size += PLT_ENTRY_SIZE;
          
          h->plt.offset = s->_raw_size;
         
          /* If this symbol is not defined in a regular file, and we are
             not generating a shared library, then set the symbol to this
             location in the .plt.  This is required to make function
             pointers compare as equal between the normal executable and
             the shared library.  */
          if (! info->shared
              && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
            {
              h->root.u.def.section = s;
              h->root.u.def.value = h->plt.offset;
            }
        
          /* Make room for this entry.  */
          s->_raw_size += PLT_ENTRY_SIZE;
       
          /* We also need to make an entry in the .got.plt section, which
             will be placed in the .got section by the linker script.  */
          htab->sgotplt->_raw_size += 4;
      
          /* We also need to make an entry in the .rel.plt section.  */
          htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
        }
      else
        {
          h->plt.offset = (bfd_vma) -1;
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
        }
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }
     
  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
    
      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
        {
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
            return FALSE;
        }
   
      s = htab->sgot;

      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
        htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;
  
  if (eh->dyn_relocs == NULL)
    return TRUE;
 
  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
          && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
              || info->symbolic))
        {
          struct elf_m32r_dyn_relocs **pp;
          for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
            {
              p->count -= p->pc_count;
              p->pc_count = 0;
              if (p->count == 0)
                *pp = p->next;
              else
                pp = &p->next;
            }
        }
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
         symbols which turn out to need copy relocs or are not
         dynamic.  */
                                                                      
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
          && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
               && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
              || (htab->root.dynamic_sections_created
                  && (h->root.type == bfd_link_hash_undefweak
                      || h->root.type == bfd_link_hash_undefined))))
        {
          /* Make sure this symbol is output as a dynamic symbol.
             Undefined weak syms won't yet be marked as dynamic.  */
          if (h->dynindx == -1
              && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
            {
              if (! bfd_elf32_link_record_dynamic_symbol (info, h))
                return FALSE;
            }
                                                                       
          /* If that succeeded, we know we'll be keeping all the
             relocs.  */
          if (h->dynindx != -1)
            goto keep;
        }
                                                                        
      eh->dyn_relocs = NULL;
                                                                         
    keep: ;
    }
                                                                          
  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }
                                                                           
  return TRUE;
}
/* Find any dynamic relocs that apply to read-only sections.  */
                                                                            
static bfd_boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
        {
          struct bfd_link_info *info = (struct bfd_link_info *) inf;

          info->flags |= DF_TEXTREL;
d859 4
a862 6
          /* Not an error, just cut short the traversal.  */
          return FALSE;
        }
    }
  return TRUE;
}
d864 6
a869 12
/* Set the sizes of the dynamic sections.  */
 
static bfd_boolean
m32r_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;
d871 2
a872 3
#ifdef DEBUG_PIC
printf("m32r_elf_size_dynamic_sections()\n");
#endif
d874 15
a888 3
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;
  BFD_ASSERT (dynobj != NULL);
d890 1
a890 1
  if (htab->root.dynamic_sections_created)
d892 5
a896 8
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
d899 2
a900 9
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d902 5
a906 2
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
        continue;
d908 8
a915 58
      for (s = ibfd->sections; s != NULL; s = s->next)
        {
          struct elf_m32r_dyn_relocs *p;

          for (p = ((struct elf_m32r_dyn_relocs *)
                    elf_section_data (s)->local_dynrel);
               p != NULL;
               p = p->next)
            {
              if (! bfd_is_abs_section (p->sec)
                  && bfd_is_abs_section (p->sec->output_section))
                {
                  /* Input section has been discarded, either because
                     it is a copy of a linkonce section or due to
                     linker script /DISCARD/, so we'll be discarding
                     the relocs too.  */
                }
              else if (p->count != 0)
                {
                  srel = elf_section_data (p->sec)->sreloc;
                  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
                    info->flags |= DF_TEXTREL;
                }
            }
        }

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
        continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
        {
          if (*local_got > 0)
            {
              *local_got = s->_raw_size;
              s->_raw_size += 4;
              if (info->shared)
                srel->_raw_size += sizeof (Elf32_External_Rela);
            }
          else
            *local_got = (bfd_vma) -1;
        }
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
d917 1
a917 2
      if ((s->flags & SEC_LINKER_CREATED) == 0)
        continue;
d919 6
a924 16
      if (s == htab->splt
          || s == htab->sgot
          || s == htab->sgotplt)
        {
          /* Strip this section if we don't need it; see the
             comment below.  */
        }
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
        {
          if (s->_raw_size != 0 && s != htab->srelplt)
            relocs = TRUE;

          /* We use the reloc_count field as a counter if we need
             to copy relocs into the output file.  */
          s->reloc_count = 0;
        }
a925 41
        {
          /* It's not one of our sections, so don't allocate space.  */
          continue;
        }

      if (s->_raw_size == 0)
        {
          /* If we don't need this section, strip it from the
             output file.  This is mostly to handle .rela.bss and
             .rela.plt.  We must create both sections in
             create_dynamic_sections, because they must be created
             before the linker maps input sections to output
             sections.  The linker does that before
             adjust_dynamic_symbol is called, and it is that
             function which decides whether anything needs to go
             into these sections.  */
          _bfd_strip_section_from_output (info, s);
          continue;
        }

      /* Allocate memory for the section contents.  We use bfd_zalloc
         here in case unused entries are not reclaimed before the
         section's contents are written out.  This should not happen,
         but this way if it does, we get a R_M32R_NONE reloc instead
         of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
        return FALSE;
    }

  if (htab->root.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in m32r_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))

      if (! info->shared)
d927 5
a931 2
	  if (! add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
a932 30

      if (htab->splt->_raw_size != 0)
        {
          if (! add_dynamic_entry (DT_PLTGOT, 0)
              || ! add_dynamic_entry (DT_PLTRELSZ, 0)
              || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
              || ! add_dynamic_entry (DT_JMPREL, 0))
            return FALSE;
        }

      if (relocs)
        {
          if (! add_dynamic_entry (DT_RELA, 0)
              || ! add_dynamic_entry (DT_RELASZ, 0)
              || ! add_dynamic_entry (DT_RELAENT,
                                      sizeof (Elf32_External_Rela)))
            return FALSE;

          /* If any dynamic relocs apply to a read-only section,
             then we need a DT_TEXTREL entry.  */
          if ((info->flags & DF_TEXTREL) == 0)
            elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
                                    (PTR) info);

          if ((info->flags & DF_TEXTREL) != 0)
            {
              if (! add_dynamic_entry (DT_TEXTREL, 0))
                return FALSE;
            }
        }
d934 2
a935 3
#undef add_dynamic_entry

  return TRUE;
d937 1
d989 4
a992 11
  struct elf_m32r_link_hash_table *htab = m32r_elf_hash_table (info);
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot, *splt, *sreloc;

  dynobj = htab->root.dynobj;
  local_got_offsets = elf_local_got_offsets (input_bfd);
                                                                                
  sgot = htab->sgot;
  splt = htab->splt;
  sreloc = NULL;
a1000 1
      struct elf_link_hash_entry *h;
d1002 3
a1004 3
         ensure it's zero (we use REL relocs, not RELA).  Therefore this
         should be assigning zero to `addend', but for clarity we use
         `r_addend'.  */
d1007 1
a1012 1
      bfd_boolean use_rel = FALSE;
d1027 1
a1027 4
          || r_type == R_M32R_GNU_VTINHERIT
          || r_type == R_M32R_NONE
          || r_type == R_M32R_RELA_GNU_VTENTRY
          || r_type == R_M32R_RELA_GNU_VTINHERIT)
a1029 3
      if (r_type <= R_M32R_GNU_VTENTRY)
        use_rel = TRUE;

d1033 2
a1034 1
      if (info->relocatable && (use_rel == TRUE))
d1095 1
a1101 1
          h = NULL;
d1109 10
a1118 24

              if (use_rel == FALSE)
                {
	          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	          addend = rel->r_addend;

                  if (info->relocatable)
                    {
                      /* This is a relocatable link.  We don't have to change
                         anything, unless the reloc is against a section symbol,
                         in which case we have to adjust according to where the
                         section symbol winds up in the output section.  */
                      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
                        rel->r_addend += sec->output_offset + sym->st_value;
                                                                                
                      continue;
                    }
                }
              else
                {
	          relocation = (sec->output_section->vma
			        + sec->output_offset
			        + sym->st_value);
                }
a1122 3
              if (info->relocatable && (use_rel == FALSE))
                continue;

a1131 1
	          bfd_boolean dyn;
d1133 2
a1134 56

	          dyn = htab->root.dynamic_sections_created;
                  sec = h->root.u.def.section;
                  if (r_type == R_M32R_GOTPC24
                      || (r_type == R_M32R_GOTPC_HI_ULO
                          || r_type == R_M32R_GOTPC_HI_SLO
                          || r_type == R_M32R_GOTPC_LO)
                      || (r_type == R_M32R_26_PLTREL
                          && h->plt.offset != (bfd_vma) -1)
                      || ((r_type == R_M32R_GOT24
                           || r_type == R_M32R_GOT16_HI_ULO
                           || r_type == R_M32R_GOT16_HI_SLO
                           || r_type == R_M32R_GOT16_LO)
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                          && (! info->shared
                              || (! info->symbolic && h->dynindx != -1)
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))
                      || (info->shared
                          && ((! info->symbolic && h->dynindx != -1)
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0)
                          && (((r_type == R_M32R_16_RELA
                              || r_type == R_M32R_32_RELA
                              || r_type == R_M32R_24_RELA
                              || r_type == R_M32R_HI16_ULO_RELA
                              || r_type == R_M32R_HI16_SLO_RELA
                              || r_type == R_M32R_LO16_RELA)
			          && (h->elf_link_hash_flags
				      & ELF_LINK_FORCED_LOCAL) == 0)
                              || r_type == R_M32R_10_PCREL_RELA
                              || r_type == R_M32R_18_PCREL_RELA
                              || r_type == R_M32R_26_PCREL_RELA)
                          && ((input_section->flags & SEC_ALLOC) != 0
                              /* DWARF will emit R_M32R_16(24,32) relocations
                                 in its sections against symbols defined 
                                 externally in shared libraries.  We can't do
                                 anything with them here.  */
                              || ((input_section->flags & SEC_DEBUGGING) != 0
                                  && (h->elf_link_hash_flags
                                      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
                    {
                      /* In these cases, we don't need the relocation
                         value.  We check specially because in some
                         obscure cases sec->output_section will be NULL.  */
                      relocation = 0;
                    }
		  else if (sec->output_section == NULL)
                    {
                      (*_bfd_error_handler)
                        (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
                         bfd_get_filename (input_bfd), h->root.root.string,
                         bfd_get_section_name (input_bfd, input_section));

		       relocation = 0;
                    }
a1141 4
              else if (info->shared
                       && (!info->symbolic)
                       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
                relocation = 0;
d1146 1
a1146 3
			  input_section, offset,
                          (!info->shared 
                           || ELF_ST_VISIBILITY (h->other)))))
a1160 272
            case R_M32R_GOTPC24:
              /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                 ld24 rx,#_GLOBAL_OFFSET_TABLE_
               */
             relocation = sgot->output_section->vma;
             break;

            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO: 
              {
                /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                   bl .+4
                   seth rx,#high(_GLOBAL_OFFSET_TABLE_)
                   or3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                   or
                   bl .+4
                   seth rx,#shigh(_GLOBAL_OFFSET_TABLE_)
                   add3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                 */
                relocation = sgot->output_section->vma;
                relocation -= (input_section->output_section->vma
                               + input_section->output_offset
                               + rel->r_offset);
                if ((r_type == R_M32R_GOTPC_HI_SLO) 
                     && ((relocation + rel->r_addend) & 0x8000))
                  rel->r_addend += 0x10000;

                break;
              }
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOT16_LO: 
              /* Fall through.  */
            case R_M32R_GOT24:
              /* Relocation is to the entry for this symbol in the global
                 offset table.  */
              BFD_ASSERT (sgot != NULL);
 
              if (h != NULL)
                {
                  bfd_boolean dyn;
                  bfd_vma off;
 
                  off = h->got.offset;
                  BFD_ASSERT (off != (bfd_vma) -1);

                  dyn = htab->root.dynamic_sections_created;
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                      || (info->shared
                          && (info->symbolic
                              || h->dynindx == -1
                              || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
                          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
                    {
                      /* This is actually a static link, or it is a
                         -Bsymbolic link and the symbol is defined
                         locally, or the symbol was forced to be local
                         because of a version file.  We must initialize
                         this entry in the global offset table.  Since the
                         offset must always be a multiple of 4, we use the
                         least significant bit to record whether we have
                         initialized it already.
 
                         When doing a dynamic link, we create a .rela.got
                         relocation entry to initialize the value.  This
                         is done in the finish_dynamic_symbol routine.  */
                      if ((off & 1) != 0)
                        off &= ~1;
                      else
                        {
                          bfd_put_32 (output_bfd, relocation,
                                      sgot->contents + off);
                          h->got.offset |= 1;
                        }
                    }
 
                  relocation = sgot->output_offset + off;
                }
              else
                {
                  bfd_vma off;
                  bfd_byte *loc;
 
                  BFD_ASSERT (local_got_offsets != NULL
                              && local_got_offsets[r_symndx] != (bfd_vma) -1);
 
                  off = local_got_offsets[r_symndx];
 
                  /* The offset must always be a multiple of 4.  We use
                     the least significant bit to record whether we have
                     already processed this entry.  */
                  if ((off & 1) != 0)
                    off &= ~1;
                  else
                    {
                      bfd_put_32 (output_bfd, relocation, sgot->contents + off);
 
                      if (info->shared)
                        {
                          asection *srelgot;
                          Elf_Internal_Rela outrel;
 
                          /* We need to generate a R_M32R_RELATIVE reloc
                             for the dynamic linker.  */
                          srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
                          BFD_ASSERT (srelgot != NULL);
 
                          outrel.r_offset = (sgot->output_section->vma
                                             + sgot->output_offset
                                             + off);
                          outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                          outrel.r_addend = relocation;
                          loc = srelgot->contents;
                          loc += srelgot->reloc_count * sizeof(Elf32_External_Rela);
                          bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                          ++srelgot->reloc_count;
                        }
 
                      local_got_offsets[r_symndx] |= 1;
                    }
 
                  relocation = sgot->output_offset + off;
                }
              if ((r_type == R_M32R_GOT16_HI_SLO)
                  && ((relocation + rel->r_addend) & 0x8000))
                rel->r_addend += 0x10000;

              break;
 
            case R_M32R_26_PLTREL:
              /* Relocation is to the entry for this symbol in the
                 procedure linkage table.  */
 
              /* The native assembler will generate a 26_PLTREL reloc
                 for a local symbol if you assemble a call from one
                 section to another when using -K pic. */
              if (h == NULL)
                break;

              //if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
              //    || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
              //  break;
              if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
                break;

              if (h->plt.offset == (bfd_vma) -1)
                {
                  /* We didn't make a PLT entry for this symbol.  This
                     happens when statically linking PIC code, or when
                     using -Bsymbolic.  */
                  break;
                }
 
              relocation = (splt->output_section->vma
                            + splt->output_offset
                            + h->plt.offset);
              break;
 
            case R_M32R_HI16_SLO_RELA:
              {
                 if ((relocation + rel->r_addend) & 0x8000)
                   {
                     rel->r_addend += 0x10000;
                   }
              }
              /* Fall through.  */
            case R_M32R_16_RELA:
            case R_M32R_24_RELA:
            case R_M32R_32_RELA:
            case R_M32R_18_PCREL_RELA:
            case R_M32R_26_PCREL_RELA:
            case R_M32R_HI16_ULO_RELA:
            case R_M32R_LO16_RELA:
            case R_M32R_SDA16_RELA:
              if (info->shared
                  && r_symndx != 0
                  && (input_section->flags & SEC_ALLOC) != 0
                  && ((r_type != R_M32R_18_PCREL_RELA
                       && r_type != R_M32R_26_PCREL_RELA)
                      || (h != NULL
                          && h->dynindx != -1
                          && (! info->symbolic
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))))
                {
                  Elf_Internal_Rela outrel;
                  bfd_boolean skip, relocate;
                  bfd_byte *loc;
 
                  /* When generating a shared object, these relocations
                     are copied into the output file to be resolved at run
                     time.  */
 
                  if (sreloc == NULL)
                    {
                      const char *name;
 
                      name = (bfd_elf_string_from_elf_section
                              (input_bfd,
                               elf_elfheader (input_bfd)->e_shstrndx,
                               elf_section_data (input_section)->rel_hdr.sh_name));
                      if (name == NULL)
                        return FALSE;
 
                      BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                                  && strcmp (bfd_get_section_name (input_bfd,
                                                                   input_section),
                                             name + 5) == 0);
 
                      sreloc = bfd_get_section_by_name (dynobj, name);
                      BFD_ASSERT (sreloc != NULL);
                    }
 
                  skip = FALSE;
                  relocate = FALSE;
 
                  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
                                                             info,
                                                             input_section,
                                                             rel->r_offset);
                  if (outrel.r_offset == (bfd_vma) -1)
                    skip = TRUE;
                  else if (outrel.r_offset == (bfd_vma) -2)
                    skip = TRUE, relocate = TRUE;
                  outrel.r_offset += (input_section->output_section->vma
                                      + input_section->output_offset);
 
                  if (skip)
                    memset (&outrel, 0, sizeof outrel);
                  else if (r_type == R_M32R_18_PCREL_RELA
                           || r_type == R_M32R_26_PCREL_RELA)
                    {
                      BFD_ASSERT (h != NULL && h->dynindx != -1);
                      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                      outrel.r_addend = rel->r_addend;
                    }
                  else
                    {
                    /* h->dynindx may be -1 if this symbol was marked to
                       become local.  */
                    if (h == NULL
                        || ((info->symbolic || h->dynindx == -1)
                             && (h->elf_link_hash_flags
                                 & ELF_LINK_HASH_DEF_REGULAR) != 0))
                      {
                        relocate = TRUE;
                        outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    else
                      {
                        BFD_ASSERT (h->dynindx != -1);
                        outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    }

                  loc = sreloc->contents;
                  loc += sreloc->reloc_count * sizeof(Elf32_External_Rela);
                  bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                  ++sreloc->reloc_count;

                  /* If this reloc is against an external symbol, we do
                     not want to fiddle with the addend.  Otherwise, we
                     need to include the symbol value so that it becomes
                     an addend for the dynamic reloc.  */
                  if (! relocate)
                    continue;
                }
              break;
 
d1165 1
a1165 1
              goto check_reloc;
d1193 1
a1193 2

              goto check_reloc;
d1236 1
a1236 3
              /* fall through */

	    default : /* OLD_M32R_RELOC */
d1238 1
d1242 1
a1242 1
	      goto check_reloc;
a1243 5

          r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                        contents, rel->r_offset,
                                        relocation, rel->r_addend);

a1309 347

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */
static bfd_boolean
m32r_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  bfd_byte *loc;
 
#ifdef DEBUG_PIC
printf("m32r_elf_finish_dynamic_symbol()\n");
#endif
  
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srela;

      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
 
      /* This symbol has an entry in the procedure linkage table.  Set
         it up.  */
 
      BFD_ASSERT (h->dynindx != -1);
 
      splt = htab->splt;
      sgot = htab->sgotplt;
      srela = htab->srelplt;
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);

      /* Get the index in the procedure linkage table which
         corresponds to this symbol.  This is the index of this symbol
         in all the symbols for which we are making plt entries.  The
         first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

      /* Get the offset into the .got table of the entry that
        corresponds to this function.  Each .got entry is 4 bytes.
        The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
        {
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD0b
               + (((sgot->output_section->vma
                    + sgot->output_offset
                    + got_offset) >> 16) & 0xffff)),
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD1b
               + ((sgot->output_section->vma
                   + sgot->output_offset
                   + got_offset) & 0xffff)),
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }
      else
        {
          bfd_put_32 (output_bfd,
              PLT_ENTRY_WORD0 + got_offset,
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD1,
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }
 
      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
                  (splt->output_section->vma
                   + splt->output_offset
                   + h->plt.offset
                   + 12), /* same offset */
                  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_JMP_SLOT);
      rela.r_addend = 0;
      loc = srela->contents;
      loc += plt_index * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
 
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
        {
          /* Mark the symbol as undefined, rather than as defined in
             the .plt section.  Leave the value alone.  */
          sym->st_shndx = SHN_UNDEF;
        }
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
 
      /* This symbol has an entry in the global offset table.  Set it
         up.  */
 
      sgot = htab->sgot;
      srela = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srela != NULL);
 
      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + (h->got.offset &~ 1));
 
      /* If this is a -Bsymbolic link, and the symbol is defined
         locally, we just want to emit a RELATIVE reloc.  Likewise if
         the symbol was forced to be local because of a version file.
         The entry in the global offset table will already have been
         initialized in the relocate_section function.  */
      if (info->shared
          && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
        {
          rela.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
          rela.r_addend = (h->root.u.def.value
                           + h->root.u.def.section->output_section->vma
                           + h->root.u.def.section->output_offset);
        }
      else
        {
	  BFD_ASSERT((h->got.offset & 1) == 0);
          bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
          rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_GLOB_DAT);
          rela.r_addend = 0;
        }
 
      loc = srela->contents;
      loc += srela->reloc_count * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++srela->reloc_count;
    }
 
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
    {
      asection *s;
      Elf_Internal_Rela rela;
 
      /* This symbols needs a copy reloc.  Set it up.  */
 
      BFD_ASSERT (h->dynindx != -1
                  && (h->root.type == bfd_link_hash_defined
                      || h->root.type == bfd_link_hash_defweak));
 
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
                                   ".rela.bss");
      BFD_ASSERT (s != NULL);
 
      rela.r_offset = (h->root.u.def.value
                       + h->root.u.def.section->output_section->vma
                       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_COPY);
      rela.r_addend = 0;
      loc = s->contents;
      loc += s->reloc_count * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++s->reloc_count;
    }
 
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
 
  return TRUE;
}


/* Finish up the dynamic sections.  */
 
static bfd_boolean
m32r_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;

#ifdef DEBUG_PIC
printf("m32r_elf_finish_dynamic_sections()\n");
#endif
 
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;

  sgot = htab->sgotplt;
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
 
  if (htab->root.dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;
 
      BFD_ASSERT (sgot != NULL && sdyn != NULL);
 
      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);

      for (; dyncon < dynconend; dyncon++)
        {
          Elf_Internal_Dyn dyn;
          const char *name;
          asection *s;
 
          bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
 
          switch (dyn.d_tag)
            {
            default:
              break;

            case DT_PLTGOT:
              name = ".got";
              s = htab->sgot->output_section; 
              goto get_vma;
            case DT_JMPREL:
              name = ".rela.plt";
              s = htab->srelplt->output_section;
            get_vma:
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_ptr = s->vma;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_PLTRELSZ:
              s = htab->srelplt->output_section;
              BFD_ASSERT (s != NULL);
              if (s->_cooked_size != 0)
                dyn.d_un.d_val = s->_cooked_size;
              else
                dyn.d_un.d_val = s->_raw_size;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_RELASZ:
              /* My reading of the SVR4 ABI indicates that the
                 procedure linkage table relocs (DT_JMPREL) should be
                 included in the overall relocs (DT_RELA).  This is
                 what Solaris does.  However, UnixWare can not handle
                 that case.  Therefore, we override the DT_RELASZ entry
                 here to make it not include the JMPREL relocs.  Since
                 the linker script arranges for .rela.plt to follow all
                 other relocation sections, we don't have to worry
                 about changing the DT_RELA entry.  */
              if (htab->srelplt != NULL)
                {
                  s = htab->srelplt->output_section;
                  if (s->_cooked_size != 0)
                    dyn.d_un.d_val -= s->_cooked_size;
                  else
                    dyn.d_un.d_val -= s->_raw_size;
                }
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;
            }
        }
 
      /* Fill in the first entry in the procedure linkage table.  */
      splt = htab->splt;
      if (splt && splt->_raw_size > 0)
        {
          if (info->shared)
            {
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD0, splt->contents);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD1, splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD4, splt->contents + 16);
            }
          else
            {
              unsigned long addr;
              /* addr = .got + 4 */
              addr = sgot->output_section->vma + sgot->output_offset + 4;
              bfd_put_32 (output_bfd,
			  PLT0_ENTRY_WORD0 | ((addr >> 16) & 0xffff),
			  splt->contents);
              bfd_put_32 (output_bfd, 
			  PLT0_ENTRY_WORD1 | (addr & 0xffff),
			  splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD4, splt->contents + 16);
            }

          elf_section_data (splt->output_section)->this_hdr.sh_entsize =
            PLT_ENTRY_SIZE;
        }
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot && sgot->_raw_size > 0)
    {
      if (sdyn == NULL)
        bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
        bfd_put_32 (output_bfd,
                    sdyn->output_section->vma + sdyn->output_offset,
                    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }
 
  return TRUE;
}

a2007 2
      case R_M32R_RELA_GNU_VTINHERIT:
      case R_M32R_RELA_GNU_VTENTRY:
d2038 1
a2038 91
  /* Update the got entry reference counts for the section being removed.  */
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_M32R_GOT16_HI_ULO:
      case R_M32R_GOT16_HI_SLO:
      case R_M32R_GOT16_LO:
      case R_M32R_GOT24:
      case R_M32R_GOTPC_HI_ULO:
      case R_M32R_GOTPC_HI_SLO:
      case R_M32R_GOTPC_LO:
      case R_M32R_GOTPC24:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount--;
	  }
	else
	  {
	    if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx]--;
	  }
        break;

      case R_M32R_16_RELA:
      case R_M32R_24_RELA:
      case R_M32R_32_RELA:
      case R_M32R_HI16_ULO_RELA:
      case R_M32R_HI16_SLO_RELA:
      case R_M32R_LO16_RELA:
      case R_M32R_SDA16_RELA:
      case R_M32R_18_PCREL_RELA:
      case R_M32R_26_PCREL_RELA:
        r_symndx = ELF32_R_SYM (rel->r_info);
        if (r_symndx >= symtab_hdr->sh_info)
          {
            struct elf_m32r_link_hash_entry *eh;
            struct elf_m32r_dyn_relocs **pp;
            struct elf_m32r_dyn_relocs *p;

            h = sym_hashes[r_symndx - symtab_hdr->sh_info];

            if (!info->shared && h->plt.refcount > 0)
              h->plt.refcount -= 1;

            eh = (struct elf_m32r_link_hash_entry *) h;

            for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
              if (p->sec == sec)
                {
                  if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                      || ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA)
                    p->pc_count -= 1;
                  p->count -= 1;
                  if (p->count == 0)
                    *pp = p->next;
                  break;
                }
          }
        break;

      case R_M32R_26_PLTREL:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount--;
	  }
	break;

      default:
	break;
      }

a2056 4
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot, *srelgot, *sreloc;
a2060 2
  sgot = srelgot = sreloc = NULL;

a2066 4
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;
  local_got_offsets = elf_local_got_offsets (abfd);

a2069 1
      int r_type;
a2073 1
      r_type = ELF32_R_TYPE (rel->r_info);
d2079 1
a2079 25
      /* Some relocs require a global offset table.  */
      if (htab->sgot == NULL)
        {
          switch (r_type)
            {
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOT16_LO:
            case R_M32R_GOTPC24:
            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO:
            case R_M32R_GOT24:
              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;
              if (! create_got_section (dynobj, info))
                return FALSE;
              break;

            default:
              break;
          }
        }

      switch (r_type)
a2080 181
	case R_M32R_GOT16_HI_ULO:
	case R_M32R_GOT16_HI_SLO:
	case R_M32R_GOT16_LO: 
        case R_M32R_GOT24:

          if (h != NULL)
            h->got.refcount += 1;
          else
            {
              bfd_signed_vma *local_got_refcounts;

              /* This is a global offset table entry for a local
                 symbol.  */
              local_got_refcounts = elf_local_got_refcounts (abfd);
              if (local_got_refcounts == NULL)
                {
                  bfd_size_type size;

                  size = symtab_hdr->sh_info;
                  size *= sizeof (bfd_signed_vma);
                  local_got_refcounts = ((bfd_signed_vma *)
                                         bfd_zalloc (abfd, size));
                  if (local_got_refcounts == NULL)
                    return FALSE;
                  elf_local_got_refcounts (abfd) = local_got_refcounts;
                }
              local_got_refcounts[r_symndx] += 1;
            }
          break;

        case R_M32R_26_PLTREL:
          /* This symbol requires a procedure linkage table entry.  We
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */
 
	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
          if (h == NULL)
            continue;

          if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
            break;

          h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->plt.refcount += 1;
          break;

        case R_M32R_16_RELA:
        case R_M32R_24_RELA:
        case R_M32R_32_RELA:
        case R_M32R_HI16_ULO_RELA:
        case R_M32R_HI16_SLO_RELA:
        case R_M32R_LO16_RELA:
        case R_M32R_SDA16_RELA:
        case R_M32R_18_PCREL_RELA:
        case R_M32R_26_PCREL_RELA:

          if (h != NULL && !info->shared)
            {
              h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
              h->plt.refcount += 1;
            }

          /* If we are creating a shared library, and this is a reloc
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             dyn_relocs field of the hash table entry. A similar
             situation occurs when creating shared libraries and symbol
             visibility changes render the symbol local.

             If on the other hand, we are creating an executable, we
             may need to keep relocations for symbols satisfied by a
             dynamic library if we manage to avoid copy relocs for the
             symbol.  */
          if ((info->shared
               && (sec->flags & SEC_ALLOC) != 0
	       && ((r_type != R_M32R_26_PCREL_RELA
                    && r_type != R_M32R_18_PCREL_RELA)
	           || (h != NULL
		       && (! info->symbolic
		           || h->root.type == bfd_link_hash_defweak
		           || (h->elf_link_hash_flags
		               & ELF_LINK_HASH_DEF_REGULAR) == 0))))
              || (!info->shared
                  && (sec->flags & SEC_ALLOC) != 0
                  && h != NULL
                  && (h->root.type == bfd_link_hash_defweak
                      || (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)))
            {
              struct elf_m32r_dyn_relocs *p;
              struct elf_m32r_dyn_relocs **head;

              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;

              /* When creating a shared object, we must copy these
                 relocs into the output file.  We create a reloc
                 section in dynobj and make room for the reloc.  */
              if (sreloc == NULL)
                {
                  const char *name;
 
                  name = (bfd_elf_string_from_elf_section
                          (abfd,
                           elf_elfheader (abfd)->e_shstrndx,
                           elf_section_data (sec)->rel_hdr.sh_name));
                  if (name == NULL)
                    return FALSE;
 
                  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                              && strcmp (bfd_get_section_name (abfd, sec),
                                         name + 5) == 0);
 
                  sreloc = bfd_get_section_by_name (dynobj, name);
                  if (sreloc == NULL)
                    {
                      flagword flags;
 
                      sreloc = bfd_make_section (dynobj, name);
                      flags = (SEC_HAS_CONTENTS | SEC_READONLY
                               | SEC_IN_MEMORY | SEC_LINKER_CREATED);
                      if ((sec->flags & SEC_ALLOC) != 0)
                        flags |= SEC_ALLOC | SEC_LOAD;
                      if (sreloc == NULL
                          || ! bfd_set_section_flags (dynobj, sreloc, flags)
                          || ! bfd_set_section_alignment (dynobj, sreloc, 2))
                        return FALSE;
                    }
                  elf_section_data (sec)->sreloc = sreloc;
                }
 
              /* If this is a global symbol, we count the number of
                 relocations we need for this symbol.  */
              if (h != NULL)
                head = &((struct elf_m32r_link_hash_entry *) h)->dyn_relocs;
              else
                {
                  asection *s;

                  /* Track dynamic relocs needed for local syms too.  */
                  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
                                                 sec, r_symndx);
                  if (s == NULL)
                    return FALSE;

                  head = ((struct elf_m32r_dyn_relocs **)
                          &elf_section_data (s)->local_dynrel);
                }

              p = *head;
              if (p == NULL || p->sec != sec)
                {
                  bfd_size_type amt = sizeof (*p);
                  p = ((struct elf_m32r_dyn_relocs *) bfd_alloc (dynobj, amt));
                  if (p == NULL)
                    return FALSE;
                  p->next = *head;
                  *head = p;
                  p->sec = sec;
                  p->count = 0;
                  p->pc_count = 0;
                }

              p->count += 1;
              if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                  || ELF32_R_TYPE (rel->r_info) == R_M32R_18_PCREL_RELA)
                p->pc_count += 1;
            }
          break;

a2082 1
        case R_M32R_RELA_GNU_VTINHERIT:
a2093 4
        case R_M32R_RELA_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
a2105 55

static bfd_boolean
m32r_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.

     This is not necessary for the O32 ABI since that only uses Elf32_Rel
     relocations (cf. System V ABI, MIPS RISC Processor Supplement,
     3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one
     of the resulting empty .rela.<section> sections starts with
     sh_offset == object size, and ld doesn't allow that.  While the check
     is arguably bogus for empty or SHT_NOBITS sections, it can easily be
     avoided by not emitting those useless sections in the first place.  */
  if ((sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;
      bfd_size_type amt = sizeof (Elf_Internal_Shdr);

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
      if (!esd->rel_hdr2)
        return FALSE;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
                                !sec->use_rela_p);
    }

  return TRUE;
}

static enum elf_reloc_type_class
m32r_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_M32R_RELATIVE:
      return reloc_class_relative;
    case R_M32R_JMP_SLOT:
      return reloc_class_plt;
    case R_M32R_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}
a2113 2
#define TARGET_LITTLE_SYM       bfd_elf32_m32rle_vec
#define TARGET_LITTLE_NAME      "elf32-m32rle"
d2115 1
a2115 1
#define elf_info_to_howto			m32r_info_to_howto
a2124 9
#define elf_backend_create_dynamic_sections     m32r_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create    m32r_elf_link_hash_table_create
#define elf_backend_size_dynamic_sections       m32r_elf_size_dynamic_sections
#define elf_backend_finish_dynamic_sections     m32r_elf_finish_dynamic_sections
#define elf_backend_adjust_dynamic_symbol       m32r_elf_adjust_dynamic_symbol
#define elf_backend_finish_dynamic_symbol       m32r_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class            m32r_elf_reloc_type_class
#define elf_backend_copy_indirect_symbol        m32r_elf_copy_indirect_symbol

d2126 1
a2126 1
/*#if !USE_REL
a2127 15
#endif*/
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size 12

#define elf_backend_may_use_rel_p       1
#ifdef USE_M32R_OLD_RELOC
#define elf_backend_default_use_rela_p  0
#define elf_backend_may_use_rela_p      0
#else
#define elf_backend_default_use_rela_p  1
#define elf_backend_may_use_rela_p      1
#define elf_backend_fake_sections       m32r_elf_fake_sections
a2128 1

a2143 17

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE         0x1000

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_m32rlin_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME         "elf32-m32r-linux"
#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM       bfd_elf32_m32rlelin_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME      "elf32-m32rle-linux"
#undef elf32_bed
#define elf32_bed               elf32_m32r_lin_bed

#include "elf32-target.h"

@


1.26.10.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a849 1
      struct bfd_link_hash_entry *bh;
d866 2
a867 2
      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 false, false, false);
d869 1
a869 1
      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
d879 1
a879 1
						 &bh)))
a880 1
      h = (struct elf_link_hash_entry *) bh;
@


1.26.10.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d91 1
a91 5
#define USE_REL	1

#ifndef USE_REL
#define USE_REL	0
#endif
d985 1
a985 1
#if !USE_REL
d1029 1
a1029 1
#if USE_REL
d1105 1
a1105 1
#if !USE_REL
d1510 1
a1510 1
#if !USE_REL /* put in for learning purposes */
d1539 1
a1539 1
#if !USE_REL /* put in for learning purposes */
d1549 1
a1549 1
#if !USE_REL /* put in for learning purposes */
d2110 1
a2110 1
#if !USE_REL
@


1.26.10.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d46 2
a47 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
bfd_boolean _bfd_m32r_elf_section_from_bfd_section
d51 1
a51 1
static bfd_boolean m32r_elf_add_symbol_hook
d54 1
a54 1
static bfd_boolean m32r_elf_relocate_section
d58 1
a58 1
static bfd_boolean m32r_elf_relax_delete_bytes
d63 1
a63 1
static bfd_boolean m32r_elf_object_p
d66 2
a67 2
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean m32r_elf_set_private_flags
d69 1
a69 1
static bfd_boolean m32r_elf_merge_private_bfd_data
d71 1
a71 1
static bfd_boolean m32r_elf_print_private_bfd_data
d73 1
a73 1
static bfd_boolean m32r_elf_gc_sweep_hook
d76 1
a76 1
static bfd_boolean m32r_elf_check_relocs
d104 1
a104 1
	 FALSE,			/* pc_relative */
d109 1
a109 1
	 FALSE,			/* partial_inplace */
d112 1
a112 1
	 FALSE),		/* pcrel_offset */
d119 1
a119 1
	 FALSE,			/* pc_relative */
d124 1
a124 1
	 TRUE,			/* partial_inplace */
d127 1
a127 1
	 FALSE),		/* pcrel_offset */
d134 1
a134 1
	 FALSE,			/* pc_relative */
d139 1
a139 1
	 TRUE,			/* partial_inplace */
d142 1
a142 1
	 FALSE),		/* pcrel_offset */
d149 1
a149 1
	 FALSE,			/* pc_relative */
d154 1
a154 1
	 TRUE,			/* partial_inplace */
d157 1
a157 1
	 FALSE),		/* pcrel_offset */
d171 1
a171 1
	 TRUE,	                /* pc_relative */
d176 1
a176 1
	 FALSE,	                /* partial_inplace */
d179 1
a179 1
	 TRUE),			/* pcrel_offset */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 TRUE),			/* pcrel_offset */
d205 1
a205 1
	 TRUE,			/* pc_relative */
d210 1
a210 1
	 FALSE,			/* partial_inplace */
d213 1
a213 1
	 TRUE),			/* pcrel_offset */
d220 1
a220 1
	 FALSE,			/* pc_relative */
d225 1
a225 1
	 TRUE,			/* partial_inplace */
d228 1
a228 1
	 FALSE),		/* pcrel_offset */
d235 1
a235 1
	 FALSE,			/* pc_relative */
d240 1
a240 1
	 TRUE,			/* partial_inplace */
d243 1
a243 1
	 FALSE),		/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 TRUE,			/* partial_inplace */
d258 1
a258 1
	 FALSE),		/* pcrel_offset */
d265 1
a265 1
	 FALSE,			/* pc_relative */
d270 1
a270 1
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
d273 1
a273 1
	 FALSE),		/* pcrel_offset */
d280 1
a280 1
         FALSE,                 /* pc_relative */
d285 1
a285 1
         FALSE,                 /* partial_inplace */
d288 1
a288 1
         FALSE),                /* pcrel_offset */
d295 1
a295 1
         FALSE,                 /* pc_relative */
d300 1
a300 1
         FALSE,                 /* partial_inplace */
d303 1
a303 1
         FALSE),                /* pcrel_offset */
d574 1
a574 1
     but we have partial_inplace set.  bfd_elf_generic_reloc will
d612 1
a612 1
     but we have partial_inplace set.  bfd_elf_generic_reloc will
d759 1
a759 1
     Elf_Internal_Rela *dst;
d771 1
a771 1
bfd_boolean
d780 1
a780 1
      return TRUE;
d782 1
a782 1
  return FALSE;
d833 1
a833 1
static bfd_boolean
d866 1
a866 1
	    return FALSE;
d872 1
a872 1
				 FALSE, FALSE, FALSE);
d882 1
a882 1
						 FALSE,
d885 1
a885 1
	return FALSE;
d899 1
a899 1
  return TRUE;
d919 1
a919 1
      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
d971 1
a971 1
static bfd_boolean
d987 1
a987 1
  bfd_boolean ret = TRUE;
d991 1
a991 1
    return TRUE;
d1022 1
a1022 1
	  ret = FALSE;
d1146 2
a1147 2
			  input_section, offset, TRUE)))
		    return FALSE;
d1214 1
a1214 1
			ret = FALSE;
d1232 1
a1232 1
		    ret = FALSE;
d1272 1
a1272 1
		return FALSE;
d1278 2
a1279 2
		      offset, TRUE)))
		return FALSE;
d1302 1
a1302 1
		return FALSE;
d1334 1
a1334 1
static bfd_boolean
d1339 1
a1339 1
     bfd_boolean *again;
d1351 1
a1351 1
  *again = FALSE;
d1361 1
a1361 1
    return TRUE;
d1611 1
a1611 1
	  *again = TRUE;
d1647 1
a1647 1
  return TRUE;
d1660 1
a1660 1
  return FALSE;
d1665 1
a1665 1
static bfd_boolean
d1739 1
a1739 1
  return TRUE;
d1752 1
a1752 1
     bfd_boolean relocateable;
d1786 1
a1786 1
			  (Elf_Internal_Rela *) NULL, FALSE));
d1857 1
a1857 1
static bfd_boolean
d1867 1
a1867 1
  return TRUE;
d1873 2
a1874 2
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1890 1
a1890 1
static bfd_boolean
d1892 1
a1892 1
     bfd *abfd;
d1899 2
a1900 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1905 1
a1905 1
static bfd_boolean
d1907 2
a1908 2
     bfd *ibfd;
     bfd *obfd;
d1915 1
a1915 1
    return TRUE;
d1929 1
a1929 1
	return TRUE;
d1931 1
a1931 1
      elf_flags_init (obfd) = TRUE;
d1940 1
a1940 1
      return TRUE;
d1945 1
a1945 1
    return TRUE;
d1956 1
a1956 1
	  return FALSE;
d1960 1
a1960 1
  return TRUE;
d1964 1
a1964 1
static bfd_boolean
d1966 2
a1967 2
     bfd *abfd;
     PTR ptr;
d1986 1
a1986 1
  return TRUE;
d2026 1
a2026 1
static bfd_boolean
d2034 1
a2034 1
  return TRUE;
d2041 1
a2041 1
static bfd_boolean
d2054 1
a2054 1
    return TRUE;
d2080 1
a2080 1
            return FALSE;
d2087 1
a2087 1
            return FALSE;
d2092 1
a2092 1
  return TRUE;
@


1.26.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1343 1
a1343 1
     _bfd_elf_link_read_relocs uses [for convenience - it sets the addend
d1371 1
a1371 1
  internal_relocs = (_bfd_elf_link_read_relocs
d1784 1
a1784 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.26.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d843 1
a843 1
  if (! info->relocatable
d906 1
a906 1
   external symbol if we are producing relocatable output.  */
d951 1
a951 1
   relocatable output file) adjusting the reloc addend as
d965 1
a965 1
   When generating relocatable output, this function must handle
d990 1
a990 1
  if (info->relocatable)
d1034 1
a1034 1
      if (info->relocatable)
d1036 1
a1036 1
	  /* This is a relocatable link.  We don't have to change
d1353 1
a1353 1
  /* We don't have to do anything for a relocatable link, if
d1356 1
a1356 1
  if (link_info->relocatable
d1747 1
a1747 1
					 data, relocatable, symbols)
d1752 1
a1752 1
     bfd_boolean relocatable;
d1765 1
a1765 1
  if (relocatable
d1769 1
a1769 1
						       relocatable,
d2053 1
a2053 1
  if (info->relocatable)
@


1.26.10.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a2093 10

static struct bfd_elf_special_section const m32r_elf_special_sections[]=
{
  { ".sdata",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { NULL,	0,	NULL,	0,
    0,		0 }
};
a2128 1
#define elf_backend_special_sections		m32r_elf_special_sections
@


1.26.10.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1110 1
a1110 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2097 6
a2102 3
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
@


1.26.10.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d846 1
a846 1
      && is_elf_hash_table (info->hash))
a1865 1
    case E_M32R2_ARCH:  (void) bfd_default_set_arch_mach (abfd, bfd_arch_m32r, bfd_mach_m32r2); break;
a1882 1
    case bfd_mach_m32r2: val = E_M32R2_ARCH; break;
d1949 1
a1949 3
      if (   ((in_flags  & EF_M32R_ARCH) != E_M32R_ARCH)
          || ((out_flags & EF_M32R_ARCH) == E_M32R_ARCH)
          || ((in_flags  & EF_M32R_ARCH) == E_M32R2_ARCH))
a1981 1
    case E_M32R2_ARCH: fprintf (file, _(": m32r2 instructions")); break;
@


1.26.10.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a46 2
static void m32r_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
a79 5
static bfd_boolean m32r_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean m32r_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

a83 19
static bfd_boolean m32r_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean m32r_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
                                                                                
static bfd_boolean m32r_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
           Elf_Internal_Sym *));
                                                                                
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static enum elf_reloc_type_class m32r_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean m32r_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));

d91 1
a91 1
/* #define USE_REL	1
d95 1
a95 45
#endif */
/* Use RELA. But use REL to link old objects for backwords compatibility. */

/* Functions for the M32R ELF linker.  */
                                                                                
/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
                                                                                
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
                                                                                
/* The nop opcode we use.  */
                                                                                
#define M32R_NOP 0x7000f000
                                                                                
#define PLT_EMPTY   0x10101010  /* RIE  -> RIE */
                                                                                
/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 20
#define PLT_HEADER_SIZE 20
                                                                                
/* The first one entries in a procedure linkage table are reserved,
   and the initial contents are unimportant (we zero them out).
   Subsequent entries look like this. */
                                                                                
#define PLT0_ENTRY_WORD0  0xd6c00000    /* seth r6, #high(.got+4)          */
#define PLT0_ENTRY_WORD1  0x86e60000    /* or3  r6, r6, #low(.got)+4)      */
#define PLT0_ENTRY_WORD2  0x24e626c6    /* ld   r4, @@r6+    -> ld r6, @@r6  */
#define PLT0_ENTRY_WORD3  0x1fc6f000    /* jmp  r6          || pnop        */
#define PLT0_ENTRY_WORD4  PLT_EMPTY     /* RIE             -> RIE          */
                                                                                
#define PLT0_PIC_ENTRY_WORD0  0xa4cc0004 /* ld   r4, @@(4,r12)              */
#define PLT0_PIC_ENTRY_WORD1  0xa6cc0008 /* ld   r6, @@(8,r12)              */
#define PLT0_PIC_ENTRY_WORD2  0x1fc6f000 /* jmp  r6         || nop         */
#define PLT0_PIC_ENTRY_WORD3  PLT_EMPTY  /* RIE             -> RIE         */
#define PLT0_PIC_ENTRY_WORD4  PLT_EMPTY  /* RIE             -> RIE         */
                                                                                
#define PLT_ENTRY_WORD0  0xe6000000 /* ld24 r6, .name_in_GOT                */
#define PLT_ENTRY_WORD1  0x06acf000 /* add  r6, r12          || nop         */
#define PLT_ENTRY_WORD0b 0xd6c00000 /* seth r6, #high(.name_in_GOT)         */
#define PLT_ENTRY_WORD1b 0x86e60000 /* or3  r6, r6, #low(.name_in_GOT)      */
#define PLT_ENTRY_WORD2  0x26c61fc6 /* ld  r6, @@r6           -> jmp r6      */
#define PLT_ENTRY_WORD3  0xe5000000 /* ld24 r5, $offset                     */
#define PLT_ENTRY_WORD4  0xff000000 /* bra  .plt0.                          */

d305 24
a328 20
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),
  EMPTY_HOWTO (25),
  EMPTY_HOWTO (26),
  EMPTY_HOWTO (27),
  EMPTY_HOWTO (28),
  EMPTY_HOWTO (29),
  EMPTY_HOWTO (30),
  EMPTY_HOWTO (31),
  EMPTY_HOWTO (32),
d330 5
a334 14
  /* A 16 bit absolute relocation.  */
  HOWTO (R_M32R_16_RELA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d336 9
a344 14
  /* A 32 bit absolute relocation.  */
  HOWTO (R_M32R_32_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_32_RELA",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d346 1
a346 14
  /* A 24 bit address.  */
  HOWTO (R_M32R_24_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_M32R_24_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d348 15
a362 13
  HOWTO (R_M32R_10_PCREL_RELA,	/* type */
	 2,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 10,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 m32r_elf_10_pcrel_reloc, /* special_function */
	 "R_M32R_10_PCREL_RELA",/* name */
	 FALSE,	                /* partial_inplace */
	 0xff,		        /* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d364 3
a366 14
  /* A relative 18 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_18_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_18_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d368 7
a374 14
  /* A relative 26 bit relocation, right shifted by 2.  */
  HOWTO (R_M32R_26_PCREL_RELA,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PCREL_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d376 4
a379 14
  /* High 16 bits of address when lower 16 is or'd in.  */
  HOWTO (R_M32R_HI16_ULO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_ULO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d381 5
a385 14
  /* High 16 bits of address when lower 16 is added in.  */
  HOWTO (R_M32R_HI16_SLO_RELA,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_HI16_SLO_RELA",/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d387 2
a388 14
  /* Lower 16 bits of address.  */
  HOWTO (R_M32R_LO16_RELA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_LO16_RELA",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d390 15
a404 14
  /* Small data area 16 bits offset.  */
  HOWTO (R_M32R_SDA16_RELA,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_SDA16_RELA",	/* name */
	 TRUE,			/* partial_inplace */  /* FIXME: correct? */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d406 6
a411 14
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M32R_RELA_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_M32R_RELA_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d413 1
a413 14
  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M32R_RELA_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_M32R_RELA_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d415 1
a415 19
  EMPTY_HOWTO (45),
  EMPTY_HOWTO (46),
  EMPTY_HOWTO (47),

  /* Like R_M32R_24, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOT24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d417 1
a417 324
  /* Like R_M32R_PCREL, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_M32R_26_PLTREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_26_PLTREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_M32R_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_24, but used when setting global offset table
     entries.  */
  HOWTO (R_M32R_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_M32R_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_M32R_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_RELATIVE",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32R_GOTOFF,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTOFF",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative 24-bit relocation used when setting PIC offset
     table register. */
  HOWTO (R_M32R_GOTPC24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_M32R_GOTPC24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_ULO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_ULO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_ULO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_HI16_SLO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_HI_SLO,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_HI_SLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An PC Relative relocation used when setting PIC offset table register.
     Like R_M32R_LO16, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_M32R_GOTPC_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32R_GOTPC_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
};

/* Handle the R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_10_pcrel_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol;
     PTR data;
     asection * input_section;
     bfd * output_bfd;
     char ** error_message ATTRIBUTE_UNUSED;
{
  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    {
      /* FIXME: See bfd_perform_relocation.  Is this right?  */
      return bfd_reloc_continue;
    }

  return m32r_elf_do_10_pcrel_reloc (abfd, reloc_entry->howto,
				     input_section,
				     data, reloc_entry->address,
				     symbol->section,
				     (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset),
				     reloc_entry->addend);
}

/* Utility to actually perform an R_M32R_10_PCREL reloc.  */

static bfd_reloc_status_type
m32r_elf_do_10_pcrel_reloc (abfd, howto, input_section, data, offset,
			    symbol_section, symbol_value, addend)
     bfd *abfd;
     reloc_howto_type *howto;
     asection *input_section;
     bfd_byte *data;
     bfd_vma offset;
     asection *symbol_section ATTRIBUTE_UNUSED;
     bfd_vma symbol_value;
     bfd_vma addend;
{
  bfd_signed_vma relocation;
  unsigned long x;
  bfd_reloc_status_type status;

  /* Sanity check the address (offset in section).  */
  if (offset > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  relocation = symbol_value + addend;
  /* Make it pc relative.  */
  relocation -=	(input_section->output_section->vma
		 + input_section->output_offset);
  /* These jumps mask off the lower two bits of the current address
     before doing pcrel calculations.  */
  relocation -= (offset & -(bfd_vma) 4);

  if (relocation < -0x200 || relocation > 0x1ff)
    status = bfd_reloc_overflow;
  else
    status = bfd_reloc_ok;

  x = bfd_get_16 (abfd, data + offset);
  relocation >>= howto->rightshift;
  relocation <<= howto->bitpos;
  x = (x & ~howto->dst_mask) | (((x & howto->src_mask) + relocation) & howto->dst_mask);
  bfd_put_16 (abfd, (bfd_vma) x, data + offset);

  return status;
}

/* Handle the R_M32R_HI16_[SU]LO relocs.
   HI16_SLO is for the add3 and load/store with displacement instructions.
   HI16_ULO is for the or3 instruction.
   For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to
   the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then
   we must add one to the high 16 bytes (which will get subtracted off when
   the low 16 bits are added).
   These relocs have to be done in combination with an R_M32R_LO16 reloc
   because there is a carry from the LO16 to the HI16.  Here we just save
   the information we need; we do the actual relocation when we see the LO16.
   This code is copied from the elf32-mips.c.  We also support an arbitrary
   number of HI16 relocs to be associated with a single LO16 reloc.  The
   assembler sorts the relocs to ensure each HI16 immediately precedes its
   LO16.  However if there are multiple copies, the assembler may not find
   the real LO16 so it picks the first one it finds.  */

struct m32r_hi16
{
  struct m32r_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct m32r_hi16 *m32r_hi16_list;

static bfd_reloc_status_type
d718 1
a718 1
static const struct m32r_reloc_map m32r_reloc_map_old[] =
a734 32
static const struct m32r_reloc_map m32r_reloc_map[] =
{
  { BFD_RELOC_NONE, R_M32R_NONE },
  { BFD_RELOC_16, R_M32R_16_RELA },
  { BFD_RELOC_32, R_M32R_32_RELA },
  { BFD_RELOC_M32R_24, R_M32R_24_RELA },
  { BFD_RELOC_M32R_10_PCREL, R_M32R_10_PCREL_RELA },
  { BFD_RELOC_M32R_18_PCREL, R_M32R_18_PCREL_RELA },
  { BFD_RELOC_M32R_26_PCREL, R_M32R_26_PCREL_RELA },
  { BFD_RELOC_M32R_HI16_ULO, R_M32R_HI16_ULO_RELA },
  { BFD_RELOC_M32R_HI16_SLO, R_M32R_HI16_SLO_RELA },
  { BFD_RELOC_M32R_LO16, R_M32R_LO16_RELA },
  { BFD_RELOC_M32R_SDA16, R_M32R_SDA16_RELA },
  { BFD_RELOC_VTABLE_INHERIT, R_M32R_RELA_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_M32R_RELA_GNU_VTENTRY },
                                                                                
  { BFD_RELOC_M32R_GOT24, R_M32R_GOT24 },
  { BFD_RELOC_M32R_26_PLTREL, R_M32R_26_PLTREL },
  { BFD_RELOC_M32R_COPY, R_M32R_COPY },
  { BFD_RELOC_M32R_GLOB_DAT, R_M32R_GLOB_DAT },
  { BFD_RELOC_M32R_JMP_SLOT, R_M32R_JMP_SLOT },
  { BFD_RELOC_M32R_RELATIVE, R_M32R_RELATIVE },
  { BFD_RELOC_M32R_GOTOFF, R_M32R_GOTOFF },
  { BFD_RELOC_M32R_GOTPC24, R_M32R_GOTPC24 },
  { BFD_RELOC_M32R_GOT16_HI_ULO, R_M32R_GOT16_HI_ULO },
  { BFD_RELOC_M32R_GOT16_HI_SLO, R_M32R_GOT16_HI_SLO },
  { BFD_RELOC_M32R_GOT16_LO, R_M32R_GOT16_LO },
  { BFD_RELOC_M32R_GOTPC_HI_ULO, R_M32R_GOTPC_HI_ULO },
  { BFD_RELOC_M32R_GOTPC_HI_SLO, R_M32R_GOTPC_HI_SLO },
  { BFD_RELOC_M32R_GOTPC_LO, R_M32R_GOTPC_LO },
};

a741 10
#ifdef USE_M32R_OLD_RELOC
  for (i = 0;
       i < sizeof (m32r_reloc_map_old) / sizeof (struct m32r_reloc_map);
       i++)
    {
      if (m32r_reloc_map_old[i].bfd_reloc_val == code)
	return &m32r_elf_howto_table[m32r_reloc_map_old[i].elf_reloc_val];
    }
#else /* ! USE_M32R_OLD_RELOC */

a748 1
#endif
d756 1
a756 14
m32r_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) <= (unsigned int) R_M32R_GNU_VTENTRY)
  cache_ptr->howto = &m32r_elf_howto_table[r_type];
}

static void
m32r_info_to_howto (abfd, cache_ptr, dst)
d761 5
a765 4
  BFD_ASSERT ((ELF32_R_TYPE(dst->r_info) == (unsigned int) R_M32R_NONE)
              || ((ELF32_R_TYPE(dst->r_info) > (unsigned int) R_M32R_GNU_VTENTRY)
                  && (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_M32R_max)));
  cache_ptr->howto = &m32r_elf_howto_table[ELF32_R_TYPE(dst->r_info)];
a766 1

d857 1
a857 859
      /* The following code was cobbled from elf32-ppc.c and elflink.c.  */

      if (s == NULL)
	{
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);

	  s = bfd_make_section_anyway (abfd, ".sdata");
	  if (s == NULL)
	    return FALSE;
	  bfd_set_section_flags (abfd, s, flags);
	  bfd_set_section_alignment (abfd, s, 2);
	}

      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol (info,
						 abfd,
						 "_SDA_BASE_",
						 BSF_GLOBAL,
						 s,
						 (bfd_vma) 32768,
						 (const char *) NULL,
						 FALSE,
						 get_elf_backend_data (abfd)->collect,
						 &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->type = STT_OBJECT;
    }

  switch (sym->st_shndx)
    {
    case SHN_M32R_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

/* We have to figure out the SDA_BASE value, so that we can adjust the
   symbol value correctly.  We look up the symbol _SDA_BASE_ in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
m32r_elf_final_sda_base (output_bfd, info, error_message, psb)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char **error_message;
     bfd_vma *psb;
{
  if (elf_gp (output_bfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (output_bfd) = (h->u.def.value
			       + h->u.def.section->output_section->vma
			       + h->u.def.section->output_offset);
      else
	{
	  /* Only get the error once.  */
	  *psb = elf_gp (output_bfd) = 4;
	  *error_message =
	    (const char *) _("SDA relocation when _SDA_BASE_ not defined");
	  return bfd_reloc_dangerous;
	}
    }
  *psb = elf_gp (output_bfd);
  return bfd_reloc_ok;
}

/* Return size of a PLT entry.  */
#define elf_m32r_sizeof_plt(info) PLT_ENTRY_SIZE

/* The m32r linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_m32r_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_m32r_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* The sh linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_m32r_dyn_relocs
{
  struct elf_m32r_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};


/* m32r ELF linker hash entry.  */

struct elf_m32r_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_m32r_dyn_relocs *dyn_relocs;

//  bfd_signed_vma gotplt_refcount;

  /* Number of PC relative relocs copied for this symbol.  */
  /* struct elf_m32r_pcrel_relocs_copied *pcrel_relocs_copied;  FIXME */
};

/* m32r ELF linker hash table.  */

struct elf_m32r_link_hash_table
{
  struct elf_link_hash_table root;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Traverse an m32r ELF linker hash table.  */

#define m32r_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the m32r ELF linker hash table from a link_info structure.  */


#define m32r_elf_hash_table(p) \
  ((struct elf_m32r_link_hash_table *) ((p)->hash))

/* Create an entry in an m32r ELF linker hash table.  */
static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (struct bfd_hash_entry *, struct bfd_hash_table *,
                            const char * );

static struct bfd_hash_entry *
m32r_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elf_m32r_link_hash_entry *ret =
    (struct elf_m32r_link_hash_entry *) entry;
    
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    ret = ((struct elf_m32r_link_hash_entry *)
           bfd_hash_allocate (table,
                              sizeof (struct elf_m32r_link_hash_entry)));
  if (ret == (struct elf_m32r_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
   
  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_m32r_link_hash_entry *)
         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
                                     table, string));
  if (ret != (struct elf_m32r_link_hash_entry *) NULL)
    {
      struct elf_m32r_link_hash_entry *eh;
  
      eh = (struct elf_m32r_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
//      eh->gotplt_refcount = 0;
      /* eh->pcrel_relocs_copied = NULL; FIXME */
    }
                                                                                                 
  return (struct bfd_hash_entry *) ret;
}

/* Create an m32r ELF linker hash table.  */
static struct bfd_link_hash_table *m32r_elf_link_hash_table_create (bfd *);

static struct bfd_link_hash_table *
m32r_elf_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct elf_m32r_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_m32r_link_hash_table);
                                                                                                 
  ret = (struct elf_m32r_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_m32r_link_hash_table *) NULL)
    return NULL;
              
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
                                       m32r_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }
               
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_sec.abfd = NULL;
                
  return &ret->root.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */
static bfd_boolean create_got_section (bfd *, struct bfd_link_info *);

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = m32r_elf_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (! htab->sgot || ! htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
                                  (SEC_ALLOC
                                   | SEC_LOAD
                                   | SEC_HAS_CONTENTS
                                   | SEC_IN_MEMORY
                                   | SEC_LINKER_CREATED
                                   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

static bfd_boolean
m32r_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  flagword flags, pltflags;
  register asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign = 2; /* 32bit */

  htab = m32r_elf_hash_table (info);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
           | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section (abfd, ".plt");
  htab->splt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
         .plt section.  */
      struct elf_link_hash_entry *h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
             (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
              (bfd_vma) 0, (const char *) NULL, FALSE,
              get_elf_backend_data (abfd)->collect,
              (struct bfd_link_hash_entry **) &h)))
        return FALSE;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (info->shared
          && ! _bfd_elf_link_record_dynamic_symbol (info, h))
        return FALSE;
    }

  s = bfd_make_section (abfd,
                        bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
  htab->srelplt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (htab->sgot == NULL
      && ! create_got_section (abfd, info))
    return FALSE;

  {
    const char *secname;
    char *relname;
    flagword secflags;
    asection *sec;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
        secflags = bfd_get_section_flags (abfd, sec);
        if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
            || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
          continue;
        secname = bfd_get_section_name (abfd, sec);
        relname = (char *) bfd_malloc ((bfd_size_type) strlen (secname) + 6);
        strcpy (relname, ".rela");
        strcat (relname, secname);
        if (bfd_get_section_by_name (abfd, secname))
          continue;
        s = bfd_make_section (abfd, relname);
        if (s == NULL
            || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
            || ! bfd_set_section_alignment (abfd, s, ptralign))
          return FALSE;
      }
  }

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
         by dynamic objects, are referenced by regular objects, and are
         not functions.  We must allocate space for them in the process
         image and use a R_*_COPY reloc to tell the dynamic linker to
         initialize them at run time.  The linker script puts the .dynbss
         section into the .bss section of the final image.  */
      s = bfd_make_section (abfd, ".dynbss");
      htab->sdynbss = s;
      if (s == NULL
          || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
        return FALSE;
      /* The .rel[a].bss section holds copy relocs.  This section is not
         normally needed.  We need to create it here, though, so that the
         linker will map it to an output section.  We can't just create it
         only if we need it, because we will not know whether we need it
         until we have seen all the input files, and the first time the
         main linker code calls BFD after examining all the input files
         (size_dynamic_sections) the input sections have already been
         mapped to the output sections.  If the section turns out not to
         be needed, we can discard it later.  We will never need this
         section when generating a shared object, since they do not use
         copy relocs.  */
      if (! info->shared)
        {
          s = bfd_make_section (abfd,
                                (bed->default_use_rela_p
                                 ? ".rela.bss" : ".rel.bss"));
          htab->srelbss = s;
          if (s == NULL
              || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
              || ! bfd_set_section_alignment (abfd, s, ptralign))
            return FALSE;
        }
    }

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */
static void m32r_elf_copy_indirect_symbol (const struct elf_backend_data *,
                                           struct elf_link_hash_entry *,
                                           struct elf_link_hash_entry *);
                                                                                
static void
m32r_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
                               struct elf_link_hash_entry *dir,
                               struct elf_link_hash_entry *ind)
{
  struct elf_m32r_link_hash_entry *edir, *eind;
                                                                                
  edir = (struct elf_m32r_link_hash_entry *) dir;
  eind = (struct elf_m32r_link_hash_entry *) ind;
                                                                                
  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
        {
          struct elf_m32r_dyn_relocs **pp;
          struct elf_m32r_dyn_relocs *p;
                                                                                
          if (ind->root.type == bfd_link_hash_indirect)
            abort ();
                                                                                
          /* Add reloc counts against the weak sym to the strong sym
             list.  Merge any entries against the same section.  */
          for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
            {
              struct elf_m32r_dyn_relocs *q;
                                                                                
              for (q = edir->dyn_relocs; q != NULL; q = q->next)
                if (q->sec == p->sec)
                  {
                    q->pc_count += p->pc_count;
                    q->count += p->count;
                    *pp = p->next;
                    break;
                  }
              if (q == NULL)
                pp = &p->next;
            }
          *pp = edir->dyn_relocs;
        }
                                                                                
      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }
                                                                                
//  if (ind->root.type == bfd_link_hash_indirect
//      && dir->got.refcount <= 0)
//    {
//      edir->tls_type = eind->tls_type;
//      eind->tls_type = GOT_UNKNOWN;
//    }
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}


/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */
 
static bfd_boolean
m32r_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;
  bfd *dynobj;
  asection *s;
  unsigned int power_of_two;

#ifdef DEBUG_PIC
printf("m32r_elf_adjust_dynamic_symbol()\n");
#endif
 
  dynobj = elf_hash_table (info)->dynobj;
 
  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
              && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
                  || h->weakdef != NULL
                  || ((h->elf_link_hash_flags
                       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_REF_REGULAR) != 0
                      && (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)));

 
  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (! info->shared
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
          && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	  && h->root.type != bfd_link_hash_undefweak
	  && h->root.type != bfd_link_hash_undefined)
        {
          /* This case can occur if we saw a PLT reloc in an input
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PCREL
             reloc instead.  */
          h->plt.offset = (bfd_vma) -1;
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
        }

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;
 
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
                  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return TRUE;
    }
 
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
 
  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;
 
  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
    }

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
        break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */
 
  htab = m32r_elf_hash_table (info);
  s = htab->sdynbss;
  BFD_ASSERT (s != NULL);
 
  /* We must generate a R_M32R_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;
 
      srel = htab->srelbss;
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
    }
 
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;
 
  /* Apply the required alignment.  */
  s->_raw_size = BFD_ALIGN (s->_raw_size,
                            (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
        return FALSE;
    }
 
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->_raw_size;
 
  /* Increment the section size to make room for the symbol.  */
  s->_raw_size += h->size;
 
  return TRUE;
}

/* This is the condition under which finish_dynamic_symbol will be called
   from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol
   routine, we'll need to do something about initializing any .plt and .got
   entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H)			\
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */
                  
static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf_m32r_link_hash_table *htab;
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;
                 
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
                
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
               
  info = (struct bfd_link_info *) inf;
  htab = m32r_elf_hash_table (info);
              
  eh = (struct elf_m32r_link_hash_entry *) h;
//  if ((h->got.refcount > 0
//      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
//      && eh->gotplt_refcount > 0)
//    {
//      /* The symbol has been forced local, or we have some direct got refs,
//         so treat all the gotplt refs as got refs. */
//      h->got.refcount += eh->gotplt_refcount;
//      if (h->plt.refcount >= eh->gotplt_refcount)
//        h->plt.refcount -= eh->gotplt_refcount;
//    }
             
  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
        {
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
            return FALSE;
        }
            
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
        {
          asection *s = htab->splt;
           
          /* If this is the first .plt entry, make room for the special
             first entry.  */
          if (s->_raw_size == 0)
            s->_raw_size += PLT_ENTRY_SIZE;
          
          h->plt.offset = s->_raw_size;
         
          /* If this symbol is not defined in a regular file, and we are
             not generating a shared library, then set the symbol to this
             location in the .plt.  This is required to make function
             pointers compare as equal between the normal executable and
             the shared library.  */
          if (! info->shared
              && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
            {
              h->root.u.def.section = s;
              h->root.u.def.value = h->plt.offset;
            }
        
          /* Make room for this entry.  */
          s->_raw_size += PLT_ENTRY_SIZE;
       
          /* We also need to make an entry in the .got.plt section, which
             will be placed in the .got section by the linker script.  */
          htab->sgotplt->_raw_size += 4;
      
          /* We also need to make an entry in the .rel.plt section.  */
          htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
        }
      else
        {
          h->plt.offset = (bfd_vma) -1;
          h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
        }
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }
     
  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
    
      /* Make sure this symbol is output as a dynamic symbol.
         Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
          && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
        {
          if (! bfd_elf32_link_record_dynamic_symbol (info, h))
            return FALSE;
        }
   
      s = htab->sgot;

      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
        htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;
  
  if (eh->dyn_relocs == NULL)
    return TRUE;
 
  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
          && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
              || info->symbolic))
        {
          struct elf_m32r_dyn_relocs **pp;
          for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
            {
              p->count -= p->pc_count;
              p->pc_count = 0;
              if (p->count == 0)
                *pp = p->next;
              else
                pp = &p->next;
            }
        }
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
         symbols which turn out to need copy relocs or are not
         dynamic.  */
                                                                      
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
          && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
               && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
              || (htab->root.dynamic_sections_created
                  && (h->root.type == bfd_link_hash_undefweak
                      || h->root.type == bfd_link_hash_undefined))))
        {
          /* Make sure this symbol is output as a dynamic symbol.
             Undefined weak syms won't yet be marked as dynamic.  */
          if (h->dynindx == -1
              && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
            {
              if (! bfd_elf32_link_record_dynamic_symbol (info, h))
                return FALSE;
            }
                                                                       
          /* If that succeeded, we know we'll be keeping all the
             relocs.  */
          if (h->dynindx != -1)
            goto keep;
        }
                                                                        
      eh->dyn_relocs = NULL;
                                                                         
    keep: ;
    }
                                                                          
  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }
                                                                           
  return TRUE;
}
/* Find any dynamic relocs that apply to read-only sections.  */
                                                                            
static bfd_boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf_m32r_link_hash_entry *eh;
  struct elf_m32r_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf_m32r_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
        {
          struct bfd_link_info *info = (struct bfd_link_info *) inf;

          info->flags |= DF_TEXTREL;
d859 4
a862 6
          /* Not an error, just cut short the traversal.  */
          return FALSE;
        }
    }
  return TRUE;
}
d864 6
a869 12
/* Set the sizes of the dynamic sections.  */
 
static bfd_boolean
m32r_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;
d871 2
a872 3
#ifdef DEBUG_PIC
printf("m32r_elf_size_dynamic_sections()\n");
#endif
d874 15
a888 3
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;
  BFD_ASSERT (dynobj != NULL);
d890 1
a890 1
  if (htab->root.dynamic_sections_created)
d892 5
a896 8
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
d899 2
a900 9
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d902 5
a906 2
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
        continue;
d908 8
a915 58
      for (s = ibfd->sections; s != NULL; s = s->next)
        {
          struct elf_m32r_dyn_relocs *p;

          for (p = ((struct elf_m32r_dyn_relocs *)
                    elf_section_data (s)->local_dynrel);
               p != NULL;
               p = p->next)
            {
              if (! bfd_is_abs_section (p->sec)
                  && bfd_is_abs_section (p->sec->output_section))
                {
                  /* Input section has been discarded, either because
                     it is a copy of a linkonce section or due to
                     linker script /DISCARD/, so we'll be discarding
                     the relocs too.  */
                }
              else if (p->count != 0)
                {
                  srel = elf_section_data (p->sec)->sreloc;
                  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
                    info->flags |= DF_TEXTREL;
                }
            }
        }

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
        continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
        {
          if (*local_got > 0)
            {
              *local_got = s->_raw_size;
              s->_raw_size += 4;
              if (info->shared)
                srel->_raw_size += sizeof (Elf32_External_Rela);
            }
          else
            *local_got = (bfd_vma) -1;
        }
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
d917 1
a917 2
      if ((s->flags & SEC_LINKER_CREATED) == 0)
        continue;
d919 6
a924 16
      if (s == htab->splt
          || s == htab->sgot
          || s == htab->sgotplt)
        {
          /* Strip this section if we don't need it; see the
             comment below.  */
        }
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
        {
          if (s->_raw_size != 0 && s != htab->srelplt)
            relocs = TRUE;

          /* We use the reloc_count field as a counter if we need
             to copy relocs into the output file.  */
          s->reloc_count = 0;
        }
a925 41
        {
          /* It's not one of our sections, so don't allocate space.  */
          continue;
        }

      if (s->_raw_size == 0)
        {
          /* If we don't need this section, strip it from the
             output file.  This is mostly to handle .rela.bss and
             .rela.plt.  We must create both sections in
             create_dynamic_sections, because they must be created
             before the linker maps input sections to output
             sections.  The linker does that before
             adjust_dynamic_symbol is called, and it is that
             function which decides whether anything needs to go
             into these sections.  */
          _bfd_strip_section_from_output (info, s);
          continue;
        }

      /* Allocate memory for the section contents.  We use bfd_zalloc
         here in case unused entries are not reclaimed before the
         section's contents are written out.  This should not happen,
         but this way if it does, we get a R_M32R_NONE reloc instead
         of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
        return FALSE;
    }

  if (htab->root.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in m32r_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))

      if (! info->shared)
d927 5
a931 2
	  if (! add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
a932 30

      if (htab->splt->_raw_size != 0)
        {
          if (! add_dynamic_entry (DT_PLTGOT, 0)
              || ! add_dynamic_entry (DT_PLTRELSZ, 0)
              || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
              || ! add_dynamic_entry (DT_JMPREL, 0))
            return FALSE;
        }

      if (relocs)
        {
          if (! add_dynamic_entry (DT_RELA, 0)
              || ! add_dynamic_entry (DT_RELASZ, 0)
              || ! add_dynamic_entry (DT_RELAENT,
                                      sizeof (Elf32_External_Rela)))
            return FALSE;

          /* If any dynamic relocs apply to a read-only section,
             then we need a DT_TEXTREL entry.  */
          if ((info->flags & DF_TEXTREL) == 0)
            elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
                                    (PTR) info);

          if ((info->flags & DF_TEXTREL) != 0)
            {
              if (! add_dynamic_entry (DT_TEXTREL, 0))
                return FALSE;
            }
        }
d934 2
a935 3
#undef add_dynamic_entry

  return TRUE;
d937 1
d989 4
a992 11
  struct elf_m32r_link_hash_table *htab = m32r_elf_hash_table (info);
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot, *splt, *sreloc;

  dynobj = htab->root.dynobj;
  local_got_offsets = elf_local_got_offsets (input_bfd);
                                                                                
  sgot = htab->sgot;
  splt = htab->splt;
  sreloc = NULL;
a1000 1
      struct elf_link_hash_entry *h;
d1002 3
a1004 3
         ensure it's zero (we use REL relocs, not RELA).  Therefore this
         should be assigning zero to `addend', but for clarity we use
         `r_addend'.  */
d1007 1
a1012 1
      bfd_boolean use_rel = FALSE;
d1027 1
a1027 4
          || r_type == R_M32R_GNU_VTINHERIT
          || r_type == R_M32R_NONE
          || r_type == R_M32R_RELA_GNU_VTENTRY
          || r_type == R_M32R_RELA_GNU_VTINHERIT)
a1029 3
      if (r_type <= R_M32R_GNU_VTENTRY)
        use_rel = TRUE;

d1033 2
a1034 1
      if (info->relocatable && (use_rel == TRUE))
d1095 1
a1101 1
          h = NULL;
d1109 10
a1118 24

              if (use_rel == FALSE)
                {
	          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	          addend = rel->r_addend;

                  if (info->relocatable)
                    {
                      /* This is a relocatable link.  We don't have to change
                         anything, unless the reloc is against a section symbol,
                         in which case we have to adjust according to where the
                         section symbol winds up in the output section.  */
                      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
                        rel->r_addend += sec->output_offset + sym->st_value;
                                                                                
                      continue;
                    }
                }
              else
                {
	          relocation = (sec->output_section->vma
			        + sec->output_offset
			        + sym->st_value);
                }
a1122 3
              if (info->relocatable && (use_rel == FALSE))
                continue;

a1131 1
	          bfd_boolean dyn;
d1133 2
a1134 56

	          dyn = htab->root.dynamic_sections_created;
                  sec = h->root.u.def.section;
                  if (r_type == R_M32R_GOTPC24
                      || (r_type == R_M32R_GOTPC_HI_ULO
                          || r_type == R_M32R_GOTPC_HI_SLO
                          || r_type == R_M32R_GOTPC_LO)
                      || (r_type == R_M32R_26_PLTREL
                          && h->plt.offset != (bfd_vma) -1)
                      || ((r_type == R_M32R_GOT24
                           || r_type == R_M32R_GOT16_HI_ULO
                           || r_type == R_M32R_GOT16_HI_SLO
                           || r_type == R_M32R_GOT16_LO)
                          && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                          && (! info->shared
                              || (! info->symbolic && h->dynindx != -1)
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))
                      || (info->shared
                          && ((! info->symbolic && h->dynindx != -1)
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0)
                          && (((r_type == R_M32R_16_RELA
                              || r_type == R_M32R_32_RELA
                              || r_type == R_M32R_24_RELA
                              || r_type == R_M32R_HI16_ULO_RELA
                              || r_type == R_M32R_HI16_SLO_RELA
                              || r_type == R_M32R_LO16_RELA)
			          && (h->elf_link_hash_flags
				      & ELF_LINK_FORCED_LOCAL) == 0)
                              || r_type == R_M32R_10_PCREL_RELA
                              || r_type == R_M32R_18_PCREL_RELA
                              || r_type == R_M32R_26_PCREL_RELA)
                          && ((input_section->flags & SEC_ALLOC) != 0
                              /* DWARF will emit R_M32R_16(24,32) relocations
                                 in its sections against symbols defined 
                                 externally in shared libraries.  We can't do
                                 anything with them here.  */
                              || ((input_section->flags & SEC_DEBUGGING) != 0
                                  && (h->elf_link_hash_flags
                                      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
                    {
                      /* In these cases, we don't need the relocation
                         value.  We check specially because in some
                         obscure cases sec->output_section will be NULL.  */
                      relocation = 0;
                    }
		  else if (sec->output_section == NULL)
                    {
                      (*_bfd_error_handler)
                        (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
                         bfd_get_filename (input_bfd), h->root.root.string,
                         bfd_get_section_name (input_bfd, input_section));

		       relocation = 0;
                    }
a1141 4
              else if (info->shared
                       && (!info->symbolic)
                       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
                relocation = 0;
d1146 1
a1146 3
			  input_section, offset,
                          (!info->shared 
                           || ELF_ST_VISIBILITY (h->other)))))
a1160 272
            case R_M32R_GOTPC24:
              /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                 ld24 rx,#_GLOBAL_OFFSET_TABLE_
               */
             relocation = sgot->output_section->vma;
             break;

            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO: 
              {
                /* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation
                   bl .+4
                   seth rx,#high(_GLOBAL_OFFSET_TABLE_)
                   or3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                   or
                   bl .+4
                   seth rx,#shigh(_GLOBAL_OFFSET_TABLE_)
                   add3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)
                 */
                relocation = sgot->output_section->vma;
                relocation -= (input_section->output_section->vma
                               + input_section->output_offset
                               + rel->r_offset);
                if ((r_type == R_M32R_GOTPC_HI_SLO) 
                     && ((relocation + rel->r_addend) & 0x8000))
                  rel->r_addend += 0x10000;

                break;
              }
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOT16_LO: 
              /* Fall through.  */
            case R_M32R_GOT24:
              /* Relocation is to the entry for this symbol in the global
                 offset table.  */
              BFD_ASSERT (sgot != NULL);
 
              if (h != NULL)
                {
                  bfd_boolean dyn;
                  bfd_vma off;
 
                  off = h->got.offset;
                  BFD_ASSERT (off != (bfd_vma) -1);

                  dyn = htab->root.dynamic_sections_created;
                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                      || (info->shared
                          && (info->symbolic
                              || h->dynindx == -1
                              || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
                          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
                    {
                      /* This is actually a static link, or it is a
                         -Bsymbolic link and the symbol is defined
                         locally, or the symbol was forced to be local
                         because of a version file.  We must initialize
                         this entry in the global offset table.  Since the
                         offset must always be a multiple of 4, we use the
                         least significant bit to record whether we have
                         initialized it already.
 
                         When doing a dynamic link, we create a .rela.got
                         relocation entry to initialize the value.  This
                         is done in the finish_dynamic_symbol routine.  */
                      if ((off & 1) != 0)
                        off &= ~1;
                      else
                        {
                          bfd_put_32 (output_bfd, relocation,
                                      sgot->contents + off);
                          h->got.offset |= 1;
                        }
                    }
 
                  relocation = sgot->output_offset + off;
                }
              else
                {
                  bfd_vma off;
                  bfd_byte *loc;
 
                  BFD_ASSERT (local_got_offsets != NULL
                              && local_got_offsets[r_symndx] != (bfd_vma) -1);
 
                  off = local_got_offsets[r_symndx];
 
                  /* The offset must always be a multiple of 4.  We use
                     the least significant bit to record whether we have
                     already processed this entry.  */
                  if ((off & 1) != 0)
                    off &= ~1;
                  else
                    {
                      bfd_put_32 (output_bfd, relocation, sgot->contents + off);
 
                      if (info->shared)
                        {
                          asection *srelgot;
                          Elf_Internal_Rela outrel;
 
                          /* We need to generate a R_M32R_RELATIVE reloc
                             for the dynamic linker.  */
                          srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
                          BFD_ASSERT (srelgot != NULL);
 
                          outrel.r_offset = (sgot->output_section->vma
                                             + sgot->output_offset
                                             + off);
                          outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                          outrel.r_addend = relocation;
                          loc = srelgot->contents;
                          loc += srelgot->reloc_count * sizeof(Elf32_External_Rela);
                          bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                          ++srelgot->reloc_count;
                        }
 
                      local_got_offsets[r_symndx] |= 1;
                    }
 
                  relocation = sgot->output_offset + off;
                }
              if ((r_type == R_M32R_GOT16_HI_SLO)
                  && ((relocation + rel->r_addend) & 0x8000))
                rel->r_addend += 0x10000;

              break;
 
            case R_M32R_26_PLTREL:
              /* Relocation is to the entry for this symbol in the
                 procedure linkage table.  */
 
              /* The native assembler will generate a 26_PLTREL reloc
                 for a local symbol if you assemble a call from one
                 section to another when using -K pic. */
              if (h == NULL)
                break;

              //if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
              //    || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
              //  break;
              if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
                break;

              if (h->plt.offset == (bfd_vma) -1)
                {
                  /* We didn't make a PLT entry for this symbol.  This
                     happens when statically linking PIC code, or when
                     using -Bsymbolic.  */
                  break;
                }
 
              relocation = (splt->output_section->vma
                            + splt->output_offset
                            + h->plt.offset);
              break;
 
            case R_M32R_HI16_SLO_RELA:
              {
                 if ((relocation + rel->r_addend) & 0x8000)
                   {
                     rel->r_addend += 0x10000;
                   }
              }
              /* Fall through.  */
            case R_M32R_16_RELA:
            case R_M32R_24_RELA:
            case R_M32R_32_RELA:
            case R_M32R_18_PCREL_RELA:
            case R_M32R_26_PCREL_RELA:
            case R_M32R_HI16_ULO_RELA:
            case R_M32R_LO16_RELA:
            case R_M32R_SDA16_RELA:
              if (info->shared
                  && r_symndx != 0
                  && (input_section->flags & SEC_ALLOC) != 0
                  && ((r_type != R_M32R_18_PCREL_RELA
                       && r_type != R_M32R_26_PCREL_RELA)
                      || (h != NULL
                          && h->dynindx != -1
                          && (! info->symbolic
                              || (h->elf_link_hash_flags
                                  & ELF_LINK_HASH_DEF_REGULAR) == 0))))
                {
                  Elf_Internal_Rela outrel;
                  bfd_boolean skip, relocate;
                  bfd_byte *loc;
 
                  /* When generating a shared object, these relocations
                     are copied into the output file to be resolved at run
                     time.  */
 
                  if (sreloc == NULL)
                    {
                      const char *name;
 
                      name = (bfd_elf_string_from_elf_section
                              (input_bfd,
                               elf_elfheader (input_bfd)->e_shstrndx,
                               elf_section_data (input_section)->rel_hdr.sh_name));
                      if (name == NULL)
                        return FALSE;
 
                      BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                                  && strcmp (bfd_get_section_name (input_bfd,
                                                                   input_section),
                                             name + 5) == 0);
 
                      sreloc = bfd_get_section_by_name (dynobj, name);
                      BFD_ASSERT (sreloc != NULL);
                    }
 
                  skip = FALSE;
                  relocate = FALSE;
 
                  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
                                                             info,
                                                             input_section,
                                                             rel->r_offset);
                  if (outrel.r_offset == (bfd_vma) -1)
                    skip = TRUE;
                  else if (outrel.r_offset == (bfd_vma) -2)
                    skip = TRUE, relocate = TRUE;
                  outrel.r_offset += (input_section->output_section->vma
                                      + input_section->output_offset);
 
                  if (skip)
                    memset (&outrel, 0, sizeof outrel);
                  else if (r_type == R_M32R_18_PCREL_RELA
                           || r_type == R_M32R_26_PCREL_RELA)
                    {
                      BFD_ASSERT (h != NULL && h->dynindx != -1);
                      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                      outrel.r_addend = rel->r_addend;
                    }
                  else
                    {
                    /* h->dynindx may be -1 if this symbol was marked to
                       become local.  */
                    if (h == NULL
                        || ((info->symbolic || h->dynindx == -1)
                             && (h->elf_link_hash_flags
                                 & ELF_LINK_HASH_DEF_REGULAR) != 0))
                      {
                        relocate = TRUE;
                        outrel.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    else
                      {
                        BFD_ASSERT (h->dynindx != -1);
                        outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
                        outrel.r_addend = relocation + rel->r_addend;
                      }
                    }

                  loc = sreloc->contents;
                  loc += sreloc->reloc_count * sizeof(Elf32_External_Rela);
                  bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
                  ++sreloc->reloc_count;

                  /* If this reloc is against an external symbol, we do
                     not want to fiddle with the addend.  Otherwise, we
                     need to include the symbol value so that it becomes
                     an addend for the dynamic reloc.  */
                  if (! relocate)
                    continue;
                }
              break;
 
d1165 1
a1165 1
              goto check_reloc;
d1193 1
a1193 2

              goto check_reloc;
d1236 1
a1236 3
              /* fall through */

	    default : /* OLD_M32R_RELOC */
d1238 1
d1242 1
a1242 1
	      goto check_reloc;
a1243 5

          r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                        contents, rel->r_offset,
                                        relocation, rel->r_addend);

a1309 347

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */
static bfd_boolean
m32r_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  bfd_byte *loc;
 
#ifdef DEBUG_PIC
printf("m32r_elf_finish_dynamic_symbol()\n");
#endif
  
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srela;

      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
 
      /* This symbol has an entry in the procedure linkage table.  Set
         it up.  */
 
      BFD_ASSERT (h->dynindx != -1);
 
      splt = htab->splt;
      sgot = htab->sgotplt;
      srela = htab->srelplt;
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);

      /* Get the index in the procedure linkage table which
         corresponds to this symbol.  This is the index of this symbol
         in all the symbols for which we are making plt entries.  The
         first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

      /* Get the offset into the .got table of the entry that
        corresponds to this function.  Each .got entry is 4 bytes.
        The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
        {
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD0b
               + (((sgot->output_section->vma
                    + sgot->output_offset
                    + got_offset) >> 16) & 0xffff)),
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD1b
               + ((sgot->output_section->vma
                   + sgot->output_offset
                   + got_offset) & 0xffff)),
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }
      else
        {
          bfd_put_32 (output_bfd,
              PLT_ENTRY_WORD0 + got_offset,
              splt->contents + h->plt.offset);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD1,
              splt->contents + h->plt.offset + 4);
          bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
              splt->contents + h->plt.offset + 8);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD3
               + plt_index * sizeof (Elf32_External_Rela)),
              splt->contents + h->plt.offset + 12);
          bfd_put_32 (output_bfd,
              (PLT_ENTRY_WORD4
               + (((unsigned int) ((- (h->plt.offset + 16)) >> 2)) & 0xffffff)),
              splt->contents + h->plt.offset + 16);
        }
 
      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
                  (splt->output_section->vma
                   + splt->output_offset
                   + h->plt.offset
                   + 12), /* same offset */
                  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_JMP_SLOT);
      rela.r_addend = 0;
      loc = srela->contents;
      loc += plt_index * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
 
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
        {
          /* Mark the symbol as undefined, rather than as defined in
             the .plt section.  Leave the value alone.  */
          sym->st_shndx = SHN_UNDEF;
        }
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
 
      /* This symbol has an entry in the global offset table.  Set it
         up.  */
 
      sgot = htab->sgot;
      srela = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srela != NULL);
 
      rela.r_offset = (sgot->output_section->vma
                       + sgot->output_offset
                       + (h->got.offset &~ 1));
 
      /* If this is a -Bsymbolic link, and the symbol is defined
         locally, we just want to emit a RELATIVE reloc.  Likewise if
         the symbol was forced to be local because of a version file.
         The entry in the global offset table will already have been
         initialized in the relocate_section function.  */
      if (info->shared
          && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
          && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
        {
          rela.r_info = ELF32_R_INFO (0, R_M32R_RELATIVE);
          rela.r_addend = (h->root.u.def.value
                           + h->root.u.def.section->output_section->vma
                           + h->root.u.def.section->output_offset);
        }
      else
        {
	  BFD_ASSERT((h->got.offset & 1) == 0);
          bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
          rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_GLOB_DAT);
          rela.r_addend = 0;
        }
 
      loc = srela->contents;
      loc += srela->reloc_count * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++srela->reloc_count;
    }
 
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
    {
      asection *s;
      Elf_Internal_Rela rela;
 
      /* This symbols needs a copy reloc.  Set it up.  */
 
      BFD_ASSERT (h->dynindx != -1
                  && (h->root.type == bfd_link_hash_defined
                      || h->root.type == bfd_link_hash_defweak));
 
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
                                   ".rela.bss");
      BFD_ASSERT (s != NULL);
 
      rela.r_offset = (h->root.u.def.value
                       + h->root.u.def.section->output_section->vma
                       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_M32R_COPY);
      rela.r_addend = 0;
      loc = s->contents;
      loc += s->reloc_count * sizeof(Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
      ++s->reloc_count;
    }
 
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
 
  return TRUE;
}


/* Finish up the dynamic sections.  */
 
static bfd_boolean
m32r_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;

#ifdef DEBUG_PIC
printf("m32r_elf_finish_dynamic_sections()\n");
#endif
 
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;

  sgot = htab->sgotplt;
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
 
  if (htab->root.dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;
 
      BFD_ASSERT (sgot != NULL && sdyn != NULL);
 
      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);

      for (; dyncon < dynconend; dyncon++)
        {
          Elf_Internal_Dyn dyn;
          const char *name;
          asection *s;
 
          bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
 
          switch (dyn.d_tag)
            {
            default:
              break;

            case DT_PLTGOT:
              name = ".got";
              s = htab->sgot->output_section; 
              goto get_vma;
            case DT_JMPREL:
              name = ".rela.plt";
              s = htab->srelplt->output_section;
            get_vma:
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_ptr = s->vma;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_PLTRELSZ:
              s = htab->srelplt->output_section;
              BFD_ASSERT (s != NULL);
              if (s->_cooked_size != 0)
                dyn.d_un.d_val = s->_cooked_size;
              else
                dyn.d_un.d_val = s->_raw_size;
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;

            case DT_RELASZ:
              /* My reading of the SVR4 ABI indicates that the
                 procedure linkage table relocs (DT_JMPREL) should be
                 included in the overall relocs (DT_RELA).  This is
                 what Solaris does.  However, UnixWare can not handle
                 that case.  Therefore, we override the DT_RELASZ entry
                 here to make it not include the JMPREL relocs.  Since
                 the linker script arranges for .rela.plt to follow all
                 other relocation sections, we don't have to worry
                 about changing the DT_RELA entry.  */
              if (htab->srelplt != NULL)
                {
                  s = htab->srelplt->output_section;
                  if (s->_cooked_size != 0)
                    dyn.d_un.d_val -= s->_cooked_size;
                  else
                    dyn.d_un.d_val -= s->_raw_size;
                }
              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
              break;
            }
        }
 
      /* Fill in the first entry in the procedure linkage table.  */
      splt = htab->splt;
      if (splt && splt->_raw_size > 0)
        {
          if (info->shared)
            {
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD0, splt->contents);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD1, splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD4, splt->contents + 16);
            }
          else
            {
              unsigned long addr;
              /* addr = .got + 4 */
              addr = sgot->output_section->vma + sgot->output_offset + 4;
              bfd_put_32 (output_bfd,
			  PLT0_ENTRY_WORD0 | ((addr >> 16) & 0xffff),
			  splt->contents);
              bfd_put_32 (output_bfd, 
			  PLT0_ENTRY_WORD1 | (addr & 0xffff),
			  splt->contents + 4);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD2, splt->contents + 8);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD3, splt->contents + 12);
              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD4, splt->contents + 16);
            }

          elf_section_data (splt->output_section)->this_hdr.sh_entsize =
            PLT_ENTRY_SIZE;
        }
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot && sgot->_raw_size > 0)
    {
      if (sdyn == NULL)
        bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
        bfd_put_32 (output_bfd,
                    sdyn->output_section->vma + sdyn->output_offset,
                    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }
 
  return TRUE;
}

a2007 2
      case R_M32R_RELA_GNU_VTINHERIT:
      case R_M32R_RELA_GNU_VTENTRY:
d2038 1
a2038 91
  /* Update the got entry reference counts for the section being removed.  */
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_M32R_GOT16_HI_ULO:
      case R_M32R_GOT16_HI_SLO:
      case R_M32R_GOT16_LO:
      case R_M32R_GOT24:
      case R_M32R_GOTPC_HI_ULO:
      case R_M32R_GOTPC_HI_SLO:
      case R_M32R_GOTPC_LO:
      case R_M32R_GOTPC24:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount--;
	  }
	else
	  {
	    if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx]--;
	  }
        break;

      case R_M32R_16_RELA:
      case R_M32R_24_RELA:
      case R_M32R_32_RELA:
      case R_M32R_HI16_ULO_RELA:
      case R_M32R_HI16_SLO_RELA:
      case R_M32R_LO16_RELA:
      case R_M32R_SDA16_RELA:
      case R_M32R_18_PCREL_RELA:
      case R_M32R_26_PCREL_RELA:
        r_symndx = ELF32_R_SYM (rel->r_info);
        if (r_symndx >= symtab_hdr->sh_info)
          {
            struct elf_m32r_link_hash_entry *eh;
            struct elf_m32r_dyn_relocs **pp;
            struct elf_m32r_dyn_relocs *p;

            h = sym_hashes[r_symndx - symtab_hdr->sh_info];

            if (!info->shared && h->plt.refcount > 0)
              h->plt.refcount -= 1;

            eh = (struct elf_m32r_link_hash_entry *) h;

            for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
              if (p->sec == sec)
                {
                  if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                      || ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA)
                    p->pc_count -= 1;
                  p->count -= 1;
                  if (p->count == 0)
                    *pp = p->next;
                  break;
                }
          }
        break;

      case R_M32R_26_PLTREL:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount--;
	  }
	break;

      default:
	break;
      }

a2056 4
  struct elf_m32r_link_hash_table *htab;
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot, *srelgot, *sreloc;
a2060 2
  sgot = srelgot = sreloc = NULL;

a2066 4
  htab = m32r_elf_hash_table (info);
  dynobj = htab->root.dynobj;
  local_got_offsets = elf_local_got_offsets (abfd);

a2069 1
      int r_type;
a2073 1
      r_type = ELF32_R_TYPE (rel->r_info);
d2079 1
a2079 25
      /* Some relocs require a global offset table.  */
      if (htab->sgot == NULL)
        {
          switch (r_type)
            {
            case R_M32R_GOT16_HI_ULO:
            case R_M32R_GOT16_HI_SLO:
            case R_M32R_GOT16_LO:
            case R_M32R_GOTPC24:
            case R_M32R_GOTPC_HI_ULO:
            case R_M32R_GOTPC_HI_SLO:
            case R_M32R_GOTPC_LO:
            case R_M32R_GOT24:
              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;
              if (! create_got_section (dynobj, info))
                return FALSE;
              break;

            default:
              break;
          }
        }

      switch (r_type)
a2080 181
	case R_M32R_GOT16_HI_ULO:
	case R_M32R_GOT16_HI_SLO:
	case R_M32R_GOT16_LO: 
        case R_M32R_GOT24:

          if (h != NULL)
            h->got.refcount += 1;
          else
            {
              bfd_signed_vma *local_got_refcounts;

              /* This is a global offset table entry for a local
                 symbol.  */
              local_got_refcounts = elf_local_got_refcounts (abfd);
              if (local_got_refcounts == NULL)
                {
                  bfd_size_type size;

                  size = symtab_hdr->sh_info;
                  size *= sizeof (bfd_signed_vma);
                  local_got_refcounts = ((bfd_signed_vma *)
                                         bfd_zalloc (abfd, size));
                  if (local_got_refcounts == NULL)
                    return FALSE;
                  elf_local_got_refcounts (abfd) = local_got_refcounts;
                }
              local_got_refcounts[r_symndx] += 1;
            }
          break;

        case R_M32R_26_PLTREL:
          /* This symbol requires a procedure linkage table entry.  We
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */
 
	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
          if (h == NULL)
            continue;

          if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
            break;

          h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->plt.refcount += 1;
          break;

        case R_M32R_16_RELA:
        case R_M32R_24_RELA:
        case R_M32R_32_RELA:
        case R_M32R_HI16_ULO_RELA:
        case R_M32R_HI16_SLO_RELA:
        case R_M32R_LO16_RELA:
        case R_M32R_SDA16_RELA:
        case R_M32R_18_PCREL_RELA:
        case R_M32R_26_PCREL_RELA:

          if (h != NULL && !info->shared)
            {
              h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
              h->plt.refcount += 1;
            }

          /* If we are creating a shared library, and this is a reloc
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             dyn_relocs field of the hash table entry. A similar
             situation occurs when creating shared libraries and symbol
             visibility changes render the symbol local.

             If on the other hand, we are creating an executable, we
             may need to keep relocations for symbols satisfied by a
             dynamic library if we manage to avoid copy relocs for the
             symbol.  */
          if ((info->shared
               && (sec->flags & SEC_ALLOC) != 0
	       && ((r_type != R_M32R_26_PCREL_RELA
                    && r_type != R_M32R_18_PCREL_RELA)
	           || (h != NULL
		       && (! info->symbolic
		           || h->root.type == bfd_link_hash_defweak
		           || (h->elf_link_hash_flags
		               & ELF_LINK_HASH_DEF_REGULAR) == 0))))
              || (!info->shared
                  && (sec->flags & SEC_ALLOC) != 0
                  && h != NULL
                  && (h->root.type == bfd_link_hash_defweak
                      || (h->elf_link_hash_flags
                          & ELF_LINK_HASH_DEF_REGULAR) == 0)))
            {
              struct elf_m32r_dyn_relocs *p;
              struct elf_m32r_dyn_relocs **head;

              if (dynobj == NULL)
                htab->root.dynobj = dynobj = abfd;

              /* When creating a shared object, we must copy these
                 relocs into the output file.  We create a reloc
                 section in dynobj and make room for the reloc.  */
              if (sreloc == NULL)
                {
                  const char *name;
 
                  name = (bfd_elf_string_from_elf_section
                          (abfd,
                           elf_elfheader (abfd)->e_shstrndx,
                           elf_section_data (sec)->rel_hdr.sh_name));
                  if (name == NULL)
                    return FALSE;
 
                  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                              && strcmp (bfd_get_section_name (abfd, sec),
                                         name + 5) == 0);
 
                  sreloc = bfd_get_section_by_name (dynobj, name);
                  if (sreloc == NULL)
                    {
                      flagword flags;
 
                      sreloc = bfd_make_section (dynobj, name);
                      flags = (SEC_HAS_CONTENTS | SEC_READONLY
                               | SEC_IN_MEMORY | SEC_LINKER_CREATED);
                      if ((sec->flags & SEC_ALLOC) != 0)
                        flags |= SEC_ALLOC | SEC_LOAD;
                      if (sreloc == NULL
                          || ! bfd_set_section_flags (dynobj, sreloc, flags)
                          || ! bfd_set_section_alignment (dynobj, sreloc, 2))
                        return FALSE;
                    }
                  elf_section_data (sec)->sreloc = sreloc;
                }
 
              /* If this is a global symbol, we count the number of
                 relocations we need for this symbol.  */
              if (h != NULL)
                head = &((struct elf_m32r_link_hash_entry *) h)->dyn_relocs;
              else
                {
                  asection *s;

                  /* Track dynamic relocs needed for local syms too.  */
                  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
                                                 sec, r_symndx);
                  if (s == NULL)
                    return FALSE;

                  head = ((struct elf_m32r_dyn_relocs **)
                          &elf_section_data (s)->local_dynrel);
                }

              p = *head;
              if (p == NULL || p->sec != sec)
                {
                  bfd_size_type amt = sizeof (*p);
                  p = ((struct elf_m32r_dyn_relocs *) bfd_alloc (dynobj, amt));
                  if (p == NULL)
                    return FALSE;
                  p->next = *head;
                  *head = p;
                  p->sec = sec;
                  p->count = 0;
                  p->pc_count = 0;
                }

              p->count += 1;
              if (ELF32_R_TYPE (rel->r_info) == R_M32R_26_PCREL_RELA
                  || ELF32_R_TYPE (rel->r_info) == R_M32R_18_PCREL_RELA)
                p->pc_count += 1;
            }
          break;

a2082 1
        case R_M32R_RELA_GNU_VTINHERIT:
a2093 4
        case R_M32R_RELA_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
a2105 55

static bfd_boolean
m32r_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.

     This is not necessary for the O32 ABI since that only uses Elf32_Rel
     relocations (cf. System V ABI, MIPS RISC Processor Supplement,
     3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one
     of the resulting empty .rela.<section> sections starts with
     sh_offset == object size, and ld doesn't allow that.  While the check
     is arguably bogus for empty or SHT_NOBITS sections, it can easily be
     avoided by not emitting those useless sections in the first place.  */
  if ((sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;
      bfd_size_type amt = sizeof (Elf_Internal_Shdr);

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
      if (!esd->rel_hdr2)
        return FALSE;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
                                !sec->use_rela_p);
    }

  return TRUE;
}

static enum elf_reloc_type_class
m32r_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_M32R_RELATIVE:
      return reloc_class_relative;
    case R_M32R_JMP_SLOT:
      return reloc_class_plt;
    case R_M32R_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}
a2113 2
#define TARGET_LITTLE_SYM       bfd_elf32_m32rle_vec
#define TARGET_LITTLE_NAME      "elf32-m32rle"
d2115 1
a2115 1
#define elf_info_to_howto			m32r_info_to_howto
a2124 9
#define elf_backend_create_dynamic_sections     m32r_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create    m32r_elf_link_hash_table_create
#define elf_backend_size_dynamic_sections       m32r_elf_size_dynamic_sections
#define elf_backend_finish_dynamic_sections     m32r_elf_finish_dynamic_sections
#define elf_backend_adjust_dynamic_symbol       m32r_elf_adjust_dynamic_symbol
#define elf_backend_finish_dynamic_symbol       m32r_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class            m32r_elf_reloc_type_class
#define elf_backend_copy_indirect_symbol        m32r_elf_copy_indirect_symbol

d2126 1
a2126 1
/*#if !USE_REL
a2127 15
#endif*/
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size 12

#define elf_backend_may_use_rel_p       1
#ifdef USE_M32R_OLD_RELOC
#define elf_backend_default_use_rela_p  0
#define elf_backend_may_use_rela_p      0
#else
#define elf_backend_default_use_rela_p  1
#define elf_backend_may_use_rela_p      1
#define elf_backend_fake_sections       m32r_elf_fake_sections
a2128 1

a2143 17

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE         0x1000

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_m32rlin_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME         "elf32-m32r-linux"
#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM       bfd_elf32_m32rlelin_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME      "elf32-m32rle-linux"
#undef elf32_bed
#define elf32_bed               elf32_m32r_lin_bed

#include "elf32-target.h"

@


1.25
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d934 1
a934 2
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.
@


1.25.2.1
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a849 1
      struct bfd_link_hash_entry *bh;
d866 2
a867 2
      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 false, false, false);
d869 1
a869 1
      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
d879 1
a879 1
						 &bh)))
a880 1
      h = (struct elf_link_hash_entry *) bh;
@


1.24
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d1340 1
a1340 2
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
d1343 1
a1343 3
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
a1370 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a1394 1
	      free_contents = contents;
d1402 2
a1403 2
      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
d1405 7
a1411 15
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      bfd_size_type amt = symtab_hdr->sh_size;
	      /* Go get them off disk.  */
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread (extsyms, amt, abfd) != amt)
		goto error_return;
	    }
d1417 2
a1418 1
	  Elf_Internal_Sym isym;
d1421 3
a1423 7
	  /* A local symbol.  */
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irel->r_info),
				    &isym);

	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
a1584 2
	  free_relocs = NULL;

d1586 1
a1586 4
	  free_contents = NULL;

	  symtab_hdr->contents = (bfd_byte *) extsyms;
	  free_extsyms = NULL;
d1614 2
a1615 7
  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
d1618 1
a1618 1
	free (free_contents);
d1621 2
a1622 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
a1623 1
      free_contents = NULL;
d1626 2
a1627 1
  if (free_extsyms != NULL)
d1630 1
a1630 1
	free (free_extsyms);
d1633 2
a1634 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = extsyms;
a1635 1
      free_extsyms = NULL;
d1638 4
d1645 10
a1654 6
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
d1668 1
a1668 2
  Elf32_External_Sym *extsyms;
  int shndx, index;
d1673 4
a1676 5
  Elf32_External_Sym *esym, *esymend;
  struct elf_link_hash_entry *sym_hash;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
d1705 3
a1707 3
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++)
d1709 4
a1712 11
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);

      if (isym.st_shndx == shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym);
	}
d1716 5
a1720 3
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
  for (index = 0; esym < esymend; esym++, index++)
d1722 1
a1722 1
      Elf_Internal_Sym isym;
d1724 5
a1728 8
      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
      sym_hash = elf_sym_hashes (abfd)[index];
      if (isym.st_shndx == shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value > addr
	  && (sym_hash)->root.u.def.value < toaddr)
d1730 1
a1730 1
	  (sym_hash)->root.u.def.value -= count;
d1755 1
a1755 2
  Elf32_External_Sym *external_syms = NULL;
  Elf_Internal_Sym *internal_syms = NULL;
a1778 14
      if (symtab_hdr->contents != NULL)
	external_syms = (Elf32_External_Sym *) symtab_hdr->contents;
      else
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf32_External_Sym);
	  external_syms = (Elf32_External_Sym *) bfd_malloc (amt);
	  if (external_syms == NULL && symtab_hdr->sh_info > 0)
	    goto error_return;
	  if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (external_syms, amt, input_bfd) != amt)
	    goto error_return;
	}

d1785 10
a1794 5
      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf_Internal_Sym);
      internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (internal_syms == NULL && symtab_hdr->sh_info > 0)
	goto error_return;
d1802 2
a1803 5
      isymp = internal_syms;
      secpp = sections;
      esym = external_syms;
      esymend = esym + symtab_hdr->sh_info;
      for (; esym < esymend; ++esym, ++isymp, ++secpp)
d1807 1
a1807 3
	  bfd_elf32_swap_symbol_in (input_bfd, esym, isymp);

	  if (isymp->st_shndx == SHN_UNDEF)
d1809 1
a1809 1
	  else if (isymp->st_shndx == SHN_ABS)
d1811 1
a1811 1
	  else if (isymp->st_shndx == SHN_COMMON)
d1813 1
a1813 1
	  else if (isymp->st_shndx == SHN_M32R_SCOMMON)
d1816 1
a1816 1
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d1823 1
a1823 1
				       internal_syms, sections))
d1828 4
a1831 8
      sections = NULL;
      if (internal_syms != NULL)
	free (internal_syms);
      internal_syms = NULL;
      if (external_syms != NULL && symtab_hdr->contents == NULL)
	free (external_syms);
      external_syms = NULL;
      if (internal_relocs != elf_section_data (input_section)->relocs)
a1832 1
      internal_relocs = NULL;
d1838 5
d1844 1
a1844 1
      && internal_relocs != elf_section_data (input_section)->relocs)
a1845 6
  if (external_syms != NULL && symtab_hdr->contents == NULL)
    free (external_syms);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
@


1.23
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d81 1
a81 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d2036 6
a2041 6
m32r_elf_gc_mark_hook (abfd, info, rel, h, sym)
       bfd *abfd;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
d2067 2
a2068 3
     {
       return bfd_section_from_elf_index (abfd, sym->st_shndx);
     }
@


1.23.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d81 1
a81 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d1340 2
a1341 1
  Elf_Internal_Rela *internal_relocs = NULL;
d1344 3
a1346 1
  Elf_Internal_Sym *isymbuf = NULL;
d1374 2
d1400 1
d1408 2
a1409 2
      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d1411 15
a1425 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d1431 3
d1435 3
a1437 2
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;
d1439 2
a1440 3
	  isym = isymbuf + ELF32_R_SYM (irel->r_info),
	  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
d1602 2
d1605 4
a1608 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1636 7
a1642 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1645 1
a1645 1
	free (isymbuf);
d1648 2
a1649 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1651 1
d1654 1
a1654 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d1657 1
a1657 1
	free (contents);
d1660 2
a1661 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
d1663 1
a1665 4
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

d1669 6
a1674 10
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

d1688 2
a1689 1
  int shndx;
d1694 5
a1698 4
  Elf_Internal_Sym *isym, *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
d1727 3
a1729 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
d1731 11
a1741 4
      if (isym->st_shndx == shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
d1745 14
a1758 13
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
d1760 1
a1760 1
	  sym_hash->root.u.def.value -= count;
d1785 2
a1786 1
  Elf_Internal_Sym *isymbuf = NULL;
d1810 14
d1830 5
a1834 10
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}
d1842 5
a1846 2
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
d1850 3
a1852 1
	  if (isym->st_shndx == SHN_UNDEF)
d1854 1
a1854 1
	  else if (isym->st_shndx == SHN_ABS)
d1856 1
a1856 1
	  else if (isym->st_shndx == SHN_COMMON)
d1858 1
a1858 1
	  else if (isym->st_shndx == SHN_M32R_SCOMMON)
d1861 1
a1861 1
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
d1868 1
a1868 1
				       isymbuf, sections))
d1873 8
a1880 4
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
d1882 1
d1888 7
a1896 6
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
d2036 6
a2041 6
m32r_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2067 3
a2069 2
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

@


1.23.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d934 2
a935 1
   both for RELA and REL type relocs, if only to serve as a learning tool.
@


1.23.4.3
log
@merge from mainline
@
text
@d91 1
a91 5
#define USE_REL	1

#ifndef USE_REL
#define USE_REL	0
#endif
a849 1
      struct bfd_link_hash_entry *bh;
d866 2
a867 2
      bh = bfd_link_hash_lookup (info->hash, "_SDA_BASE_",
				 false, false, false);
d869 1
a869 1
      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
d879 1
a879 1
						 &bh)))
a880 1
      h = (struct elf_link_hash_entry *) bh;
d983 1
a983 1
#if !USE_REL
d1027 1
a1027 1
#if USE_REL
d1103 1
a1103 1
#if !USE_REL
d1508 1
a1508 1
#if !USE_REL /* put in for learning purposes */
d1537 1
a1537 1
#if !USE_REL /* put in for learning purposes */
d1547 1
a1547 1
#if !USE_REL /* put in for learning purposes */
d2108 1
a2108 1
#if !USE_REL
@


1.22
log
@	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.
@
text
@d984 5
d1028 1
a1053 5
#ifndef USE_REL
	  /* This can't be done for USE_REL because it doesn't mean anything
	     and elf_link_input_bfd asserts this stays zero.  */
	  rel->r_addend = addend;
#endif
a1054 4
#ifndef USE_REL
	  /* Addends are stored with relocs.  We're done.  */
	  continue;
#else /* USE_REL */
a1087 1
#endif /* USE_REL */
d1090 1
d2161 3
@


1.21
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d841 2
a842 1
      && strcmp (*namep, "_SDA_BASE_") == 0)
@


1.21.2.1
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d841 1
a841 2
      && strcmp (*namep, "_SDA_BASE_") == 0
      && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.21.2.2
log
@Merge from mainline
@
text
@a983 5
#ifndef USE_REL
  if (info->relocateable)
    return true;
#endif

a1022 1
#ifdef USE_REL
d1048 5
d1054 4
d1091 1
a1093 1
#endif /* USE_REL */
a2163 3
#ifndef USE_REL
#define elf_backend_rela_normal			1
#endif
@


1.20
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d48 1
a48 1
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *, int *));
d768 1
a768 1
_bfd_m32r_elf_section_from_bfd_section (abfd, hdr, sec, retval)
a769 1
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
@


1.19
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a68 2
static boolean m32r_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
a1951 20
/* Copy backend specific data from one object module to another */
static boolean
m32r_elf_copy_private_bfd_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
{
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a2172 1
#define bfd_elf32_bfd_copy_private_bfd_data 	m32r_elf_copy_private_bfd_data
@


1.18
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@a1858 2
	  else if (isymp->st_shndx > 0 && isymp->st_shndx < SHN_LORESERVE)
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d1866 1
a1866 4
	    {
	      /* Who knows?  */
	      isec = NULL;
	    }
d2093 2
a2094 8
       if (!(elf_bad_symtab (abfd)
           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
                && sym->st_shndx != SHN_COMMON))
          {
            return bfd_section_from_elf_index (abfd, sym->st_shndx);
          }
      }
@


1.17
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d1109 6
d1118 1
@


1.16
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d608 1
a608 1
  /* Now do the the reloc in the usual way.
@


1.15
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1011 1
a1011 1
				 bfd_get_filename (input_bfd),
d1218 6
a1223 5
		    (*_bfd_error_handler) (_("%s: The target (%s) of an %s relocation is in the wrong section (%s)"),
					   bfd_get_filename (input_bfd),
					   sym_name,
					   m32r_elf_howto_table[(int) r_type].name,
					   bfd_get_section_name (abfd, sec));
d2020 3
a2022 2
	  _bfd_error_handler (_("%s: Instruction set mismatch with previous modules"),
			      bfd_get_filename (ibfd));
@


1.14
log
@* elf.c (prep_headers): Get the machine code from the elf
backend data.
* elf-m10200.c (ELF_MACHINE_CODE): Redefine to EM_MN10200.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10200.
* elf-m10300.c (ELF_MACHINE_CODE): Redefine to EM_MN10300.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10300.
* elf-arc.c (arc_elf_final_write_processing): Don't override
e_machine, it's now properly set in prep_headers.
* elf32-avr.c (elf32_avr_object_p): Accept both EM_AVR and
EM_AVR_OLD.
(ELF_MACHINE_ALT1): Define to EM_AVR_OLD.
* elf-d10v.c (ELF_MACHINE_CODE): Redefine to EM_D10V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D10V.
* elf-d30v.c (ELF_MACHINE_CODE): Redefine to EM_D30V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D30V.
* elf-fr30.c (ELF_MACHINE_CODE): Redefine to EM_FR30.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_FR30.
* elf-m32r.c (ELF_MACHINE_CODE): Redefine to EM_M32R.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_M32R.
* elf32-pj.c (ELF_MACHINE_ALT1): DEfine to EM_PJ_OLD.
* elf-v850.c (ELF_MACHINE_CODE): Redefine to EM_V850.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_V850.
@
text
@d372 1
a372 1
  relocation -= (offset & -4L);
d383 1
a383 1
  bfd_put_16 (abfd, x, data + offset);
d460 1
a460 1
  n = (struct m32r_hi16 *) bfd_malloc (sizeof *n);
d559 2
a560 2
	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (input_bfd, insn, l->addr);
d650 1
a650 1
      	bfd_put_16 (input_bfd, x, inplace_address);
d657 1
a657 1
      	bfd_put_32 (input_bfd, x, inplace_address);
d858 2
a859 2
	  int flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
		       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d877 1
a877 1
						 32768,
d1413 1
d1415 1
a1415 2
	      extsyms = ((Elf32_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
d1420 1
a1420 2
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
d1784 1
d1811 3
a1813 3
	  external_syms = ((Elf32_External_Sym *)
			   bfd_malloc (symtab_hdr->sh_info
				       * sizeof (Elf32_External_Sym)));
d1817 1
a1817 3
	      || (bfd_read (external_syms, sizeof (Elf32_External_Sym),
			    symtab_hdr->sh_info, input_bfd)
		  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
d1827 3
a1829 3
      internal_syms = ((Elf_Internal_Sym *)
		       bfd_malloc (symtab_hdr->sh_info
				   * sizeof (Elf_Internal_Sym)));
d1833 3
a1835 2
      sections = (asection **) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (asection *));
@


1.13
log
@Add missing prototypes
@
text
@d2171 2
a2172 1
#define ELF_MACHINE_CODE	EM_CYGNUS_M32R
@


1.12
log
@Update copyright notices
@
text
@a60 1

d75 10
@


1.11
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.11.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.10
log
@Fixes to allow sources to compile under Solaris 2.8
@
text
@a2158 1

a2159 1

@


1.9
log
@2000-12-06  Kazu Hirata  <kazu@@hxi.com>

	* elf32-m32r.c: Fix formatting.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
@
text
@d581 1
a581 1
     char **error_message;
d627 1
a627 1
  inplace_address = data + reloc_entry->address;
@


1.8
log
@	* elf32-m32r.c (m32r_elf_generic_reloc): new function.  All
	HOWTO references to bfd_elf_generic_reloc, that have
	partial_inplace == true, now use the new function.  The function
	is based on the recent rewrite of m32r_elf_lo16_reloc(), and
	extends its fixes to the R_M32R_{16,24,32} relocs.
	The new logic in m32r_elf_lo16_reloc() has been removed, and
	it instead calls the new routine to obtain that functionality.
@
text
@d569 2
a570 2
/* Do generic partial_inplace relocation.  
   This is a local replacement for bfd_elf_generic_reloc. */
d1316 1
a1316 1
static boolean 
d1928 1
a1928 1
/* Function to keep M32R specific file flags. */
d1989 1
a1989 1
      
d2028 1
a2028 1
  
d2030 1
a2030 1
  
d2032 1
a2032 1
  
d2034 1
a2034 1
  
d2041 1
a2041 1
  
d2043 1
a2043 1
  
d2062 1
a2062 1
 
d2069 1
a2069 1
 
a2101 1

d2105 1
a2105 1
 
d2117 1
a2117 1
 
d2120 1
a2120 1
 
d2123 1
a2123 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d2126 1
a2126 1
 
d2132 1
a2132 1
 
d2138 1
a2138 1
 
d2147 1
a2147 1
 
d2156 1
a2156 1
 
a2159 1

d2193 1
a2193 1
					
@


1.7
log
@        * elf32-m32r.c (m32r_elf_lo16_reloc): Rewrite.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d38 2
d110 1
a110 1
	 bfd_elf_generic_reloc,	/* special_function */
d125 1
a125 1
	 bfd_elf_generic_reloc,	/* special_function */
d140 1
a140 1
	 bfd_elf_generic_reloc,	/* special_function */
a512 4
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  unsigned long insn;

d565 38
d627 6
d634 19
a652 3
  insn = bfd_get_32 (input_bfd, data + reloc_entry->address);
  insn = (insn & 0xffff0000) | (relocation & 0xffff);
  bfd_put_32 (input_bfd, insn, data + reloc_entry->address);
@


1.6
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d501 1
a501 1
m32r_elf_lo16_reloc (abfd, reloc_entry, symbol, data,
d503 1
a503 1
     bfd *abfd;
d511 15
d541 2
a542 2
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = ((bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
d552 1
a552 1
	  bfd_put_32 (abfd, insn, l->addr);
d562 38
a599 3
  /* Now do the LO16 reloc in the usual way.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
@


1.5
log
@	* cpu-m32r.c (arch_info_struct): New static global.
	(bfd_m32r_arch): Refer to it.
	* elf32-m32r.c (m32r_elf_object_p): Recognize E_M32RX_ARCH.
	(m32r_elf_print_private_bfd_data): Ditto.
	(m32r_elf_final_write_processing): Handle bfd_mach_m32rx.
@
text
@d1021 1
a1021 1
			  input_section, offset)))
d1152 1
a1152 1
		      offset)))
@


1.4
log
@Change ELF_MAXPAGESIZE to 0x1
@
text
@d1796 1
d1813 1
d1931 1
d2058 1
a2058 1
#define ELF_MAXPAGESIZE		0x1   /* Explicitly requested by Mitsubishi */
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2055 1
a2055 1
#define ELF_MAXPAGESIZE		0x1000
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d304 1
a304 1
     char ** error_message;
d342 1
a342 1
     asection *symbol_section;
d406 1
a406 1
     bfd *abfd;
d412 1
a412 1
     char **error_message;
d561 1
a561 1
     bfd *abfd;
d564 1
a564 1
     PTR data;
d567 1
a567 1
     char **error_message;
d617 1
a617 1
     bfd *abfd;
d637 1
a637 1
     bfd *abfd;
d653 2
a654 2
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
d680 1
a680 1
     bfd *abfd;
d720 1
a720 1
     flagword *flagsp;
d853 1
a853 1
     bfd *output_bfd;
d1804 1
a1804 1
     boolean linker;
d1939 1
a1939 1
       struct bfd_link_info *info;
d1982 4
a1985 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
@


1.1
log
@Initial revision
@
text
@d1961 3
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

