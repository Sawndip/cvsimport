head	1.45;
access;
symbols
	sid-snapshot-20180601:1.45
	sid-snapshot-20180501:1.45
	sid-snapshot-20180401:1.45
	sid-snapshot-20180301:1.45
	sid-snapshot-20180201:1.45
	sid-snapshot-20180101:1.45
	sid-snapshot-20171201:1.45
	sid-snapshot-20171101:1.45
	sid-snapshot-20171001:1.45
	sid-snapshot-20170901:1.45
	sid-snapshot-20170801:1.45
	sid-snapshot-20170701:1.45
	sid-snapshot-20170601:1.45
	sid-snapshot-20170501:1.45
	sid-snapshot-20170401:1.45
	sid-snapshot-20170301:1.45
	sid-snapshot-20170201:1.45
	sid-snapshot-20170101:1.45
	sid-snapshot-20161201:1.45
	sid-snapshot-20161101:1.45
	sid-snapshot-20160901:1.45
	sid-snapshot-20160801:1.45
	sid-snapshot-20160701:1.45
	sid-snapshot-20160601:1.45
	sid-snapshot-20160501:1.45
	sid-snapshot-20160401:1.45
	sid-snapshot-20160301:1.45
	sid-snapshot-20160201:1.45
	sid-snapshot-20160101:1.45
	sid-snapshot-20151201:1.45
	sid-snapshot-20151101:1.45
	sid-snapshot-20151001:1.45
	sid-snapshot-20150901:1.45
	sid-snapshot-20150801:1.45
	sid-snapshot-20150701:1.45
	sid-snapshot-20150601:1.45
	sid-snapshot-20150501:1.45
	sid-snapshot-20150401:1.45
	sid-snapshot-20150301:1.45
	sid-snapshot-20150201:1.45
	sid-snapshot-20150101:1.45
	sid-snapshot-20141201:1.45
	sid-snapshot-20141101:1.45
	sid-snapshot-20141001:1.45
	sid-snapshot-20140901:1.45
	sid-snapshot-20140801:1.45
	sid-snapshot-20140701:1.45
	sid-snapshot-20140601:1.45
	sid-snapshot-20140501:1.45
	sid-snapshot-20140401:1.45
	sid-snapshot-20140301:1.45
	sid-snapshot-20140201:1.45
	sid-snapshot-20140101:1.45
	sid-snapshot-20131201:1.45
	sid-snapshot-20131101:1.45
	sid-snapshot-20131001:1.45
	binutils-2_24-branch:1.45.0.4
	binutils-2_24-branchpoint:1.45
	binutils-2_21_1:1.43
	sid-snapshot-20130901:1.45
	gdb_7_6_1-2013-08-30-release:1.45
	sid-snapshot-20130801:1.45
	sid-snapshot-20130701:1.45
	sid-snapshot-20130601:1.45
	sid-snapshot-20130501:1.45
	gdb_7_6-2013-04-26-release:1.45
	sid-snapshot-20130401:1.45
	binutils-2_23_2:1.44
	gdb_7_6-branch:1.45.0.2
	gdb_7_6-2013-03-12-branchpoint:1.45
	sid-snapshot-20130301:1.45
	sid-snapshot-20130201:1.44
	sid-snapshot-20130101:1.44
	sid-snapshot-20121201:1.44
	gdb_7_5_1-2012-11-29-release:1.44
	binutils-2_23_1:1.44
	sid-snapshot-20121101:1.44
	binutils-2_23:1.44
	sid-snapshot-20121001:1.44
	sid-snapshot-20120901:1.44
	gdb_7_5-2012-08-17-release:1.44
	sid-snapshot-20120801:1.44
	binutils-2_23-branch:1.44.0.4
	binutils-2_23-branchpoint:1.44
	gdb_7_5-branch:1.44.0.2
	gdb_7_5-2012-07-18-branchpoint:1.44
	sid-snapshot-20120701:1.43
	sid-snapshot-20120601:1.43
	sid-snapshot-20120501:1.43
	binutils-2_22_branch:1.43.0.34
	gdb_7_4_1-2012-04-26-release:1.43
	sid-snapshot-20120401:1.43
	sid-snapshot-20120301:1.43
	sid-snapshot-20120201:1.43
	gdb_7_4-2012-01-24-release:1.43
	sid-snapshot-20120101:1.43
	gdb_7_4-branch:1.43.0.32
	gdb_7_4-2011-12-13-branchpoint:1.43
	sid-snapshot-20111201:1.43
	binutils-2_22:1.43
	sid-snapshot-20111101:1.43
	sid-snapshot-20111001:1.43
	binutils-2_22-branch:1.43.0.30
	binutils-2_22-branchpoint:1.43
	gdb_7_3_1-2011-09-04-release:1.43
	sid-snapshot-20110901:1.43
	sid-snapshot-20110801:1.43
	gdb_7_3-2011-07-26-release:1.43
	sid-snapshot-20110701:1.43
	sid-snapshot-20110601:1.43
	sid-snapshot-20110501:1.43
	gdb_7_3-branch:1.43.0.28
	gdb_7_3-2011-04-01-branchpoint:1.43
	sid-snapshot-20110401:1.43
	sid-snapshot-20110301:1.43
	sid-snapshot-20110201:1.43
	sid-snapshot-20110101:1.43
	binutils-2_21:1.43
	sid-snapshot-20101201:1.43
	binutils-2_21-branch:1.43.0.26
	binutils-2_21-branchpoint:1.43
	sid-snapshot-20101101:1.43
	sid-snapshot-20101001:1.43
	binutils-2_20_1:1.43
	gdb_7_2-2010-09-02-release:1.43
	sid-snapshot-20100901:1.43
	sid-snapshot-20100801:1.43
	gdb_7_2-branch:1.43.0.24
	gdb_7_2-2010-07-07-branchpoint:1.43
	sid-snapshot-20100701:1.43
	sid-snapshot-20100601:1.43
	sid-snapshot-20100501:1.43
	sid-snapshot-20100401:1.43
	gdb_7_1-2010-03-18-release:1.43
	sid-snapshot-20100301:1.43
	gdb_7_1-branch:1.43.0.22
	gdb_7_1-2010-02-18-branchpoint:1.43
	sid-snapshot-20100201:1.43
	sid-snapshot-20100101:1.43
	gdb_7_0_1-2009-12-22-release:1.43
	sid-snapshot-20091201:1.43
	sid-snapshot-20091101:1.43
	binutils-2_20:1.43
	gdb_7_0-2009-10-06-release:1.43
	sid-snapshot-20091001:1.43
	gdb_7_0-branch:1.43.0.20
	gdb_7_0-2009-09-16-branchpoint:1.43
	arc-sim-20090309:1.42
	binutils-arc-20081103-branch:1.43.0.18
	binutils-arc-20081103-branchpoint:1.43
	binutils-2_20-branch:1.43.0.16
	binutils-2_20-branchpoint:1.43
	sid-snapshot-20090901:1.43
	sid-snapshot-20090801:1.43
	msnyder-checkpoint-072509-branch:1.43.0.14
	msnyder-checkpoint-072509-branchpoint:1.43
	sid-snapshot-20090701:1.43
	dje-cgen-play1-branch:1.43.0.12
	dje-cgen-play1-branchpoint:1.43
	sid-snapshot-20090601:1.43
	sid-snapshot-20090501:1.43
	sid-snapshot-20090401:1.43
	arc-20081103-branch:1.43.0.10
	arc-20081103-branchpoint:1.43
	arc-insight_6_8-branch:1.42.0.10
	arc-insight_6_8-branchpoint:1.42
	insight_6_8-branch:1.42.0.8
	insight_6_8-branchpoint:1.42
	sid-snapshot-20090301:1.43
	binutils-2_19_1:1.43
	sid-snapshot-20090201:1.43
	sid-snapshot-20090101:1.43
	reverse-20081226-branch:1.43.0.8
	reverse-20081226-branchpoint:1.43
	sid-snapshot-20081201:1.43
	multiprocess-20081120-branch:1.43.0.6
	multiprocess-20081120-branchpoint:1.43
	sid-snapshot-20081101:1.43
	binutils-2_19:1.43
	sid-snapshot-20081001:1.43
	reverse-20080930-branch:1.43.0.4
	reverse-20080930-branchpoint:1.43
	binutils-2_19-branch:1.43.0.2
	binutils-2_19-branchpoint:1.43
	sid-snapshot-20080901:1.43
	sid-snapshot-20080801:1.43
	reverse-20080717-branch:1.42.0.6
	reverse-20080717-branchpoint:1.42
	sid-snapshot-20080701:1.42
	msnyder-reverse-20080609-branch:1.42.0.4
	msnyder-reverse-20080609-branchpoint:1.42
	drow-reverse-20070409-branch:1.39.0.4
	drow-reverse-20070409-branchpoint:1.39
	sid-snapshot-20080601:1.42
	sid-snapshot-20080501:1.42
	sid-snapshot-20080403:1.42
	sid-snapshot-20080401:1.42
	gdb_6_8-2008-03-27-release:1.42
	sid-snapshot-20080301:1.42
	gdb_6_8-branch:1.42.0.2
	gdb_6_8-2008-02-26-branchpoint:1.42
	sid-snapshot-20080201:1.41
	sid-snapshot-20080101:1.41
	sid-snapshot-20071201:1.41
	sid-snapshot-20071101:1.41
	gdb_6_7_1-2007-10-29-release:1.41
	gdb_6_7-2007-10-10-release:1.41
	sid-snapshot-20071001:1.41
	gdb_6_7-branch:1.41.0.4
	gdb_6_7-2007-09-07-branchpoint:1.41
	binutils-2_18:1.41
	binutils-2_18-branch:1.41.0.2
	binutils-2_18-branchpoint:1.41
	insight_6_6-20070208-release:1.39
	binutils-csl-coldfire-4_1-32:1.38
	binutils-csl-sourcerygxx-4_1-32:1.38
	gdb_6_6-2006-12-18-release:1.39
	binutils-csl-innovasic-fido-3_4_4-33:1.38
	binutils-csl-sourcerygxx-3_4_4-32:1.34
	binutils-csl-coldfire-4_1-30:1.38
	binutils-csl-sourcerygxx-4_1-30:1.38
	binutils-csl-coldfire-4_1-28:1.38
	binutils-csl-sourcerygxx-4_1-29:1.38
	binutils-csl-sourcerygxx-4_1-28:1.38
	gdb_6_6-branch:1.39.0.2
	gdb_6_6-2006-11-15-branchpoint:1.39
	binutils-csl-arm-2006q3-27:1.38
	binutils-csl-sourcerygxx-4_1-27:1.38
	binutils-csl-arm-2006q3-26:1.38
	binutils-csl-sourcerygxx-4_1-26:1.38
	binutils-csl-sourcerygxx-4_1-25:1.38
	binutils-csl-sourcerygxx-4_1-24:1.38
	binutils-csl-sourcerygxx-4_1-23:1.38
	insight_6_5-20061003-release:1.38
	gdb-csl-symbian-6_4_50_20060226-12:1.37
	binutils-csl-sourcerygxx-4_1-21:1.38
	binutils-csl-arm-2006q3-21:1.38
	binutils-csl-sourcerygxx-4_1-22:1.38
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.38
	binutils-csl-sourcerygxx-4_1-20:1.38
	binutils-csl-arm-2006q3-19:1.38
	binutils-csl-sourcerygxx-4_1-19:1.38
	binutils-csl-sourcerygxx-4_1-18:1.38
	binutils-csl-renesas-4_1-9:1.38
	gdb-csl-sourcerygxx-3_4_4-25:1.36
	binutils-csl-sourcerygxx-3_4_4-25:1.34
	nickrob-async-20060828-mergepoint:1.39
	gdb-csl-symbian-6_4_50_20060226-11:1.37
	binutils-csl-renesas-4_1-8:1.38
	binutils-csl-renesas-4_1-7:1.38
	binutils-csl-renesas-4_1-6:1.38
	gdb-csl-sourcerygxx-4_1-17:1.37
	binutils-csl-sourcerygxx-4_1-17:1.38
	gdb-csl-20060226-branch-local-2:1.37
	gdb-csl-sourcerygxx-4_1-14:1.37
	binutils-csl-sourcerygxx-4_1-14:1.38
	binutils-csl-sourcerygxx-4_1-15:1.38
	gdb-csl-sourcerygxx-4_1-13:1.37
	binutils-csl-sourcerygxx-4_1-13:1.38
	binutils-2_17:1.38
	gdb-csl-sourcerygxx-4_1-12:1.37
	binutils-csl-sourcerygxx-4_1-12:1.38
	gdb-csl-sourcerygxx-3_4_4-21:1.37
	binutils-csl-sourcerygxx-3_4_4-21:1.38
	gdb_6_5-20060621-release:1.38
	binutils-csl-wrs-linux-3_4_4-24:1.34
	binutils-csl-wrs-linux-3_4_4-23:1.34
	gdb-csl-sourcerygxx-4_1-9:1.37
	binutils-csl-sourcerygxx-4_1-9:1.38
	gdb-csl-sourcerygxx-4_1-8:1.37
	binutils-csl-sourcerygxx-4_1-8:1.38
	gdb-csl-sourcerygxx-4_1-7:1.37
	binutils-csl-sourcerygxx-4_1-7:1.38
	gdb-csl-arm-2006q1-6:1.37
	binutils-csl-arm-2006q1-6:1.38
	gdb-csl-sourcerygxx-4_1-6:1.37
	binutils-csl-sourcerygxx-4_1-6:1.38
	binutils-csl-wrs-linux-3_4_4-22:1.34
	gdb-csl-symbian-6_4_50_20060226-10:1.37
	gdb-csl-symbian-6_4_50_20060226-9:1.37
	gdb-csl-symbian-6_4_50_20060226-8:1.37
	gdb-csl-coldfire-4_1-11:1.37
	binutils-csl-coldfire-4_1-11:1.38
	gdb-csl-sourcerygxx-3_4_4-19:1.37
	binutils-csl-sourcerygxx-3_4_4-19:1.38
	gdb-csl-coldfire-4_1-10:1.37
	gdb_6_5-branch:1.38.0.14
	gdb_6_5-2006-05-14-branchpoint:1.38
	binutils-csl-coldfire-4_1-10:1.38
	gdb-csl-sourcerygxx-4_1-5:1.37
	binutils-csl-sourcerygxx-4_1-5:1.38
	nickrob-async-20060513-branch:1.38.0.12
	nickrob-async-20060513-branchpoint:1.38
	gdb-csl-sourcerygxx-4_1-4:1.37
	binutils-csl-sourcerygxx-4_1-4:1.38
	msnyder-reverse-20060502-branch:1.38.0.10
	msnyder-reverse-20060502-branchpoint:1.38
	binutils-csl-wrs-linux-3_4_4-21:1.34
	gdb-csl-morpho-4_1-4:1.37
	binutils-csl-morpho-4_1-4:1.38
	gdb-csl-sourcerygxx-3_4_4-17:1.37
	binutils-csl-sourcerygxx-3_4_4-17:1.38
	binutils-csl-wrs-linux-3_4_4-20:1.34
	readline_5_1-import-branch:1.38.0.8
	readline_5_1-import-branchpoint:1.38
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.37
	binutils-2_17-branch:1.38.0.6
	binutils-2_17-branchpoint:1.38
	gdb-csl-symbian-20060226-branch:1.37.0.6
	gdb-csl-symbian-20060226-branchpoint:1.37
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.37
	msnyder-reverse-20060331-branch:1.38.0.4
	msnyder-reverse-20060331-branchpoint:1.38
	binutils-csl-2_17-branch:1.38.0.2
	binutils-csl-2_17-branchpoint:1.38
	gdb-csl-available-20060303-branch:1.37.0.4
	gdb-csl-available-20060303-branchpoint:1.37
	gdb-csl-20060226-branch:1.37.0.2
	gdb-csl-20060226-branchpoint:1.37
	gdb_6_4-20051202-release:1.36
	msnyder-fork-checkpoint-branch:1.36.0.10
	msnyder-fork-checkpoint-branchpoint:1.36
	gdb-csl-gxxpro-6_3-branch:1.36.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.36
	gdb_6_4-branch:1.36.0.6
	gdb_6_4-2005-11-01-branchpoint:1.36
	gdb-csl-arm-20051020-branch:1.36.0.4
	gdb-csl-arm-20051020-branchpoint:1.36
	binutils-csl-gxxpro-3_4-branch:1.34.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.34
	binutils-2_16_1:1.34
	msnyder-tracepoint-checkpoint-branch:1.36.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.36
	gdb-csl-arm-20050325-2005-q1b:1.34
	binutils-csl-arm-2005q1b:1.34
	binutils-2_16:1.34
	gdb-csl-arm-20050325-2005-q1a:1.34
	binutils-csl-arm-2005q1a:1.34
	csl-arm-20050325-branch:1.34.0.6
	csl-arm-20050325-branchpoint:1.34
	binutils-csl-arm-2005q1-branch:1.34.0.4
	binutils-csl-arm-2005q1-branchpoint:1.34
	binutils-2_16-branch:1.34.0.2
	binutils-2_16-branchpoint:1.34
	csl-arm-2004-q3d:1.32
	gdb_6_3-20041109-release:1.31
	gdb_6_3-branch:1.31.0.4
	gdb_6_3-20041019-branchpoint:1.31
	csl-arm-2004-q3:1.31
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.30
	binutils-2_15:1.30
	binutils-2_15-branchpoint:1.30
	csl-arm-2004-q1a:1.30
	csl-arm-2004-q1:1.30
	gdb_6_1-2004-04-05-release:1.30
	drow_intercu-merge-20040402:1.30
	drow_intercu-merge-20040327:1.30
	ezannoni_pie-20040323-branch:1.30.0.12
	ezannoni_pie-20040323-branchpoint:1.30
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.30.0.10
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.30.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.30
	drow_intercu-20040221-branch:1.30.0.6
	drow_intercu-20040221-branchpoint:1.30
	binutils-2_15-branch:1.30.0.4
	cagney_bfdfile-20040213-branch:1.30.0.2
	cagney_bfdfile-20040213-branchpoint:1.30
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.29
	cagney_bigcore-20040122-branch:1.29.0.2
	cagney_bigcore-20040122-branchpoint:1.29
	drow-cplus-merge-20040113:1.26
	csl-arm-2003-q4:1.25
	drow-cplus-merge-20031224:1.25
	drow-cplus-merge-20031220:1.25
	carlton_dictionary-20031215-merge:1.25
	drow-cplus-merge-20031214:1.25
	carlton-dictionary-20031111-merge:1.24
	gdb_6_0-2003-10-04-release:1.21
	kettenis_sparc-20030918-branch:1.23.0.6
	kettenis_sparc-20030918-branchpoint:1.23
	carlton_dictionary-20030917-merge:1.23
	ezannoni_pie-20030916-branchpoint:1.23
	ezannoni_pie-20030916-branch:1.23.0.4
	cagney_x86i386-20030821-branch:1.23.0.2
	cagney_x86i386-20030821-branchpoint:1.23
	carlton_dictionary-20030805-merge:1.23
	carlton_dictionary-20030627-merge:1.21
	gdb_6_0-branch:1.21.0.6
	gdb_6_0-2003-06-23-branchpoint:1.21
	jimb-ppc64-linux-20030613-branch:1.21.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.21
	binutils-2_14:1.20
	cagney_convert-20030606-branch:1.21.0.2
	cagney_convert-20030606-branchpoint:1.21
	cagney_writestrings-20030508-branch:1.20.0.10
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.6
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	binutils-2_14-branch:1.20.0.2
	binutils-2_14-branchpoint:1.20
	kettenis_i386newframe-20030419-branch:1.19.0.2
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.14
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.12
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.10
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.8
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.6
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.4
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.2
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.17
	interps-20030202-branch:1.17.0.4
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.17.0.2
	cagney-unwind-20030108-branchpoint:1.17
	binutils-2_13_2_1:1.12.8.2
	binutils-2_13_2:1.12.8.2
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.14
	binutils-2_13_1:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.20
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.18
	carlton_dictionary-20020920-branchpoint:1.12
	sid-20020905-branchpoint:1.12
	sid-20020905-branch:1.12.0.16
	gdb_5_3-branch:1.12.0.14
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.12
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	binutils-2_13:1.12
	gdb_5_2_1-2002-07-23-release:1.11
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.8
	kseitz_interps-20020528-branch:1.12.0.6
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.4
	cagney_regbuf-20020515-branchpoint:1.12
	binutils-2_12_1:1.11
	jimb-macro-020506-branch:1.12.0.2
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.11
	binutils-2_12:1.11
	gdb_5_2-branch:1.11.0.4
	gdb_5_2-2002-03-03-branchpoint:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.4.2.1
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.45
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.13.14.22.43;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.27.03.06.27;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.04.15.53.02;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2005.01.31.23.13.16;	author bje;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.21.15.28.16;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.09.12.15.57;	author nickc;	state Exp;
branches
	1.30.6.1;
next	1.29;

1.29
date	2004.01.19.17.02.44;	author kazu;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.16.23.50.19;	author kazu;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.16.23.35.49;	author kazu;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.12.15.02.18;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.24.18.06.39;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.17.10.23.33;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.11.14.59.40;	author rsandifo;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.11.11.08.30;	author rsandifo;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.04.10.47.30;	author sveinse;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.24.12.36.06;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.02.20.18.59.32;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.19.01.58.53;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.15.11.18.47;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.05.05.22;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches
	1.12.8.1
	1.12.18.1
	1.12.20.1;
next	1.11;

1.11
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.23.17.05.52;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.10.20.55.44;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.11.07.05.04.04;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.27.01.31.59;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.03.06.55.06;	author law;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.13.23.57.25;	author law;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.31;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.30.6.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.19.2.1
date	2003.05.04.11.37.35;	author kettenis;	state Exp;
branches;
next	;

1.12.8.1
date	2002.12.16.03.52.32;	author kazu;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2002.12.20.19.32.13;	author drow;	state Exp;
branches;
next	;

1.12.18.1
date	2002.11.15.19.18.23;	author carlton;	state Exp;
branches;
next	1.12.18.2;

1.12.18.2
date	2002.12.23.19.37.26;	author carlton;	state Exp;
branches;
next	1.12.18.3;

1.12.18.3
date	2003.03.06.00.56.13;	author carlton;	state Exp;
branches;
next	1.12.18.4;

1.12.18.4
date	2003.04.16.19.56.41;	author carlton;	state Exp;
branches;
next	1.12.18.5;

1.12.18.5
date	2003.05.01.00.46.39;	author carlton;	state Exp;
branches;
next	1.12.18.6;

1.12.18.6
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	1.12.18.7;

1.12.18.7
date	2003.08.05.17.12.44;	author carlton;	state Exp;
branches;
next	1.12.18.8;

1.12.18.8
date	2003.11.11.23.50.07;	author carlton;	state Exp;
branches;
next	1.12.18.9;

1.12.18.9
date	2003.12.15.23.59.12;	author carlton;	state Exp;
branches;
next	1.12.18.10;

1.12.18.10
date	2004.01.26.19.11.03;	author carlton;	state Exp;
branches;
next	;

1.12.20.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	1.12.20.2;

1.12.20.2
date	2004.01.13.16.11.36;	author drow;	state Exp;
branches;
next	1.12.20.3;

1.12.20.3
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2000.11.07.05.49.30;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.45
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@/* BFD back-end for Renesas H8/300 COFF binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2012
   Free Software Foundation, Inc.
   Written by Steve Chamberlain, <sac@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"
#include "coff/h8300.h"
#include "coff/internal.h"
#include "libcoff.h"
#include "libiberty.h"

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (1)

/* We derive a hash table from the basic BFD hash table to
   hold entries in the function vector.  Aside from the
   info stored by the basic hash table, we need the offset
   of a particular entry within the hash table as well as
   the offset where we'll add the next entry.  */

struct funcvec_hash_entry
  {
    /* The basic hash table entry.  */
    struct bfd_hash_entry root;

    /* The offset within the vectors section where
       this entry lives.  */
    bfd_vma offset;
  };

struct funcvec_hash_table
  {
    /* The basic hash table.  */
    struct bfd_hash_table root;

    bfd *abfd;

    /* Offset at which we'll add the next entry.  */
    unsigned int offset;
  };


/* To lookup a value in the function vector hash table.  */
#define funcvec_hash_lookup(table, string, create, copy) \
  ((struct funcvec_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

/* The derived h8300 COFF linker table.  Note it's derived from
   the generic linker hash table, not the COFF backend linker hash
   table!  We use this to attach additional data structures we
   need while linking on the h8300.  */
struct h8300_coff_link_hash_table {
  /* The main hash table.  */
  struct generic_link_hash_table root;

  /* Section for the vectors table.  This gets attached to a
     random input bfd, we keep it here for easy access.  */
  asection *vectors_sec;

  /* Hash table of the functions we need to enter into the function
     vector.  */
  struct funcvec_hash_table *funcvec_hash_table;
};

static struct bfd_link_hash_table *h8300_coff_link_hash_table_create (bfd *);

/* Get the H8/300 COFF linker hash table from a link_info structure.  */

#define h8300_coff_hash_table(p) \
  ((struct h8300_coff_link_hash_table *) ((coff_hash_table (p))))

/* Initialize fields within a funcvec hash table entry.  Called whenever
   a new entry is added to the funcvec hash table.  */

static struct bfd_hash_entry *
funcvec_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *gen_table,
		      const char *string)
{
  struct funcvec_hash_entry *ret;
  struct funcvec_hash_table *table;

  ret = (struct funcvec_hash_entry *) entry;
  table = (struct funcvec_hash_table *) gen_table;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct funcvec_hash_entry *)
	   bfd_hash_allocate (gen_table,
			      sizeof (struct funcvec_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct funcvec_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));

  if (ret == NULL)
    return NULL;

  /* Note where this entry will reside in the function vector table.  */
  ret->offset = table->offset;

  /* Bump the offset at which we store entries in the function
     vector.  We'd like to bump up the size of the vectors section,
     but it's not easily available here.  */
 switch (bfd_get_mach (table->abfd))
   {
   case bfd_mach_h8300:
   case bfd_mach_h8300hn:
   case bfd_mach_h8300sn:
     table->offset += 2;
     break;
   case bfd_mach_h8300h:
   case bfd_mach_h8300s:
     table->offset += 4;
     break;
   default:
     return NULL;
   }

  /* Everything went OK.  */
  return (struct bfd_hash_entry *) ret;
}

/* Initialize the function vector hash table.  */

static bfd_boolean
funcvec_hash_table_init (struct funcvec_hash_table *table,
			 bfd *abfd,
			 struct bfd_hash_entry *(*newfunc)
			   (struct bfd_hash_entry *,
			    struct bfd_hash_table *,
			    const char *),
			 unsigned int entsize)
{
  /* Initialize our local fields, then call the generic initialization
     routine.  */
  table->offset = 0;
  table->abfd = abfd;
  return (bfd_hash_table_init (&table->root, newfunc, entsize));
}

/* Create the derived linker hash table.  We use a derived hash table
   basically to hold "static" information during an H8/300 coff link
   without using static variables.  */

static struct bfd_link_hash_table *
h8300_coff_link_hash_table_create (bfd *abfd)
{
  struct h8300_coff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct h8300_coff_link_hash_table);

  ret = (struct h8300_coff_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd,
				  _bfd_generic_link_hash_newfunc,
				  sizeof (struct generic_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Special handling for H8/300 relocs.
   We only come here for pcrel stuff and return normally if not an -r link.
   When doing -r, we can't do any arithmetic for the pcrel stuff, because
   the code in reloc.c assumes that we can manipulate the targets of
   the pcrel branches.  This isn't so, since the H8/300 can do relaxing,
   which means that the gap after the instruction may not be enough to
   contain the offset required for the branch, so we have to use only
   the addend until the final link.  */

static bfd_reloc_status_type
special (bfd *      abfd ATTRIBUTE_UNUSED,
	 arelent *  reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *  symbol ATTRIBUTE_UNUSED,
	 void *     data ATTRIBUTE_UNUSED,
	 asection * input_section ATTRIBUTE_UNUSED,
	 bfd *      output_bfd,
	 char **    error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  /* Adjust the reloc address to that in the output section.  */
  reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

static reloc_howto_type howto_table[] =
{
  HOWTO (R_RELBYTE, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_RELWORD, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_RELLONG, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "32", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_PCRBYTE, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8", FALSE, 0x000000ff, 0x000000ff, TRUE),
  HOWTO (R_PCRWORD, 0, 1, 16, TRUE, 0, complain_overflow_signed, special, "DISP16", FALSE, 0x0000ffff, 0x0000ffff, TRUE),
  HOWTO (R_PCRLONG, 0, 2, 32, TRUE, 0, complain_overflow_signed, special, "DISP32", FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO (R_MOV16B1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_MOV16B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMP1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16/pcrel", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_JMP2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pcrecl/16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMPL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "24/pcrell", FALSE, 0x00ffffff, 0x00ffffff, FALSE),
  HOWTO (R_JMPL2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pc8/24", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_MOV24B1, 0, 1, 32, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_MOV24B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", FALSE, 0x0000ffff, 0x0000ffff, FALSE),

  /* An indirect reference to a function.  This causes the function's address
     to be added to the function vector in lo-mem and puts the address of
     the function vector's entry in the jsr instruction.  */
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8/indirect", FALSE, 0x000000ff, 0x000000ff, FALSE),

  /* Internal reloc for relaxing.  This is created when a 16-bit pc-relative
     branch is turned into an 8-bit pc-relative branch.  */
  HOWTO (R_PCRWORD_B, 0, 0, 8, TRUE, 0, complain_overflow_bitfield, special, "relaxed bCC:16", FALSE, 0x000000ff, 0x000000ff, FALSE),

  HOWTO (R_MOVL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,special, "32/24 relaxable move", FALSE, 0xffffffff, 0xffffffff, FALSE),

  HOWTO (R_MOVL2, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "32/24 relaxed move", FALSE, 0x0000ffff, 0x0000ffff, FALSE),

  HOWTO (R_BCC_INV, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8 inverted", FALSE, 0x000000ff, 0x000000ff, TRUE),

  HOWTO (R_JMP_DEL, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "Deleted jump", FALSE, 0x000000ff, 0x000000ff, TRUE),
};

/* Turn a howto into a reloc number.  */

#define SELECT_RELOC(x,howto) \
  { x.r_type = select_reloc (howto); }

#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
#define __A_MAGIC_SET__

/* Code to swap in the reloc.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
#define SWAP_OUT_RELOC_EXTRA(abfd, src, dst) \
  dst->r_stuff[0] = 'S'; \
  dst->r_stuff[1] = 'C';

static int
select_reloc (reloc_howto_type *howto)
{
  return howto->type;
}

/* Code to turn a r_type into a howto ptr, uses the above howto table.  */

static void
rtype2howto (arelent *internal, struct internal_reloc *dst)
{
  switch (dst->r_type)
    {
    case R_RELBYTE:
      internal->howto = howto_table + 0;
      break;
    case R_RELWORD:
      internal->howto = howto_table + 1;
      break;
    case R_RELLONG:
      internal->howto = howto_table + 2;
      break;
    case R_PCRBYTE:
      internal->howto = howto_table + 3;
      break;
    case R_PCRWORD:
      internal->howto = howto_table + 4;
      break;
    case R_PCRLONG:
      internal->howto = howto_table + 5;
      break;
    case R_MOV16B1:
      internal->howto = howto_table + 6;
      break;
    case R_MOV16B2:
      internal->howto = howto_table + 7;
      break;
    case R_JMP1:
      internal->howto = howto_table + 8;
      break;
    case R_JMP2:
      internal->howto = howto_table + 9;
      break;
    case R_JMPL1:
      internal->howto = howto_table + 10;
      break;
    case R_JMPL2:
      internal->howto = howto_table + 11;
      break;
    case R_MOV24B1:
      internal->howto = howto_table + 12;
      break;
    case R_MOV24B2:
      internal->howto = howto_table + 13;
      break;
    case R_MEM_INDIRECT:
      internal->howto = howto_table + 14;
      break;
    case R_PCRWORD_B:
      internal->howto = howto_table + 15;
      break;
    case R_MOVL1:
      internal->howto = howto_table + 16;
      break;
    case R_MOVL2:
      internal->howto = howto_table + 17;
      break;
    case R_BCC_INV:
      internal->howto = howto_table + 18;
      break;
    case R_JMP_DEL:
      internal->howto = howto_table + 19;
      break;
    default:
      abort ();
      break;
    }
}

#define RTYPE2HOWTO(internal, relocentry) rtype2howto (internal, relocentry)

/* Perform any necessary magic to the addend in a reloc entry.  */

#define CALC_ADDEND(abfd, symbol, ext_reloc, cache_ptr) \
 cache_ptr->addend = ext_reloc.r_offset;

#define RELOC_PROCESSING(relent,reloc,symbols,abfd,section) \
 reloc_processing (relent, reloc, symbols, abfd, section)

static void
reloc_processing (arelent *relent, struct internal_reloc *reloc,
		  asymbol **symbols, bfd *abfd, asection *section)
{
  relent->address = reloc->r_vaddr;
  rtype2howto (relent, reloc);

  if (((int) reloc->r_symndx) > 0)
    relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
  else
    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;

  relent->addend = reloc->r_offset;
  relent->address -= section->vma;
}

static bfd_boolean
h8300_symbol_address_p (bfd *abfd, asection *input_section, bfd_vma address)
{
  asymbol **s;

  s = _bfd_generic_link_get_symbols (abfd);
  BFD_ASSERT (s != (asymbol **) NULL);

  /* Search all the symbols for one in INPUT_SECTION with
     address ADDRESS.  */
  while (*s)
    {
      asymbol *p = *s;

      if (p->section == input_section
	  && (input_section->output_section->vma
	      + input_section->output_offset
	      + p->value) == address)
	return TRUE;
      s++;
    }
  return FALSE;
}

/* If RELOC represents a relaxable instruction/reloc, change it into
   the relaxed reloc, notify the linker that symbol addresses
   have changed (bfd_perform_slip) and return how much the current
   section has shrunk by.

   FIXME: Much of this code has knowledge of the ordering of entries
   in the howto table.  This needs to be fixed.  */

static int
h8300_reloc16_estimate (bfd *abfd, asection *input_section, arelent *reloc,
			unsigned int shrink, struct bfd_link_info *link_info)
{
  bfd_vma value;
  bfd_vma dot;
  bfd_vma gap;
  static asection *last_input_section = NULL;
  static arelent *last_reloc = NULL;

  /* The address of the thing to be relocated will have moved back by
     the size of the shrink - but we don't change reloc->address here,
     since we need it to know where the relocation lives in the source
     uncooked section.  */
  bfd_vma address = reloc->address - shrink;

  if (input_section != last_input_section)
    last_reloc = NULL;

  /* Only examine the relocs which might be relaxable.  */
  switch (reloc->howto->type)
    {
      /* This is the 16-/24-bit absolute branch which could become an
	 8-bit pc-relative branch.  */
    case R_JMP1:
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the next instruction (not the reloc).  */
      dot = (input_section->output_section->vma
	     + input_section->output_offset + address);

      /* Adjust for R_JMP1 vs R_JMPL1.  */
      dot += (reloc->howto->type == R_JMP1 ? 1 : 2);

      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;

      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int) gap >= -128 && (int) gap <= 128)
	{
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

	  /* It's possible we may be able to eliminate this branch entirely;
	     if the previous instruction is a branch around this instruction,
	     and there's no label at this instruction, then we can reverse
	     the condition on the previous branch and eliminate this jump.

	       original:			new:
		 bCC lab1			bCC' lab2
		 jmp lab2
		lab1:				lab1:

	     This saves 4 bytes instead of two, and should be relatively
	     common.

	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:

			     mov.w   r0,r0
			     beq     .L1
			     jsr     @@_bar
		      .L1:   rts
		      _bar:  rts
	     into:
			     mov.w   r0,r0
			     bne     _bar
			     rts
		      _bar:  rts

	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
	      && last_reloc
	      && last_reloc->howto->type == R_PCRBYTE)
	    {
	      bfd_vma last_value;
	      last_value = bfd_coff_reloc16_get_value (last_reloc, link_info,
						       input_section) + 1;

	      if (last_value == dot + 2
		  && last_reloc->address + 1 == reloc->address
		  && !h8300_symbol_address_p (abfd, input_section, dot - 2))
		{
		  reloc->howto = howto_table + 19;
		  last_reloc->howto = howto_table + 18;
		  last_reloc->sym_ptr_ptr = reloc->sym_ptr_ptr;
		  last_reloc->addend = reloc->addend;
		  shrink += 4;
		  bfd_perform_slip (abfd, 4, input_section, address);
		  break;
		}
	    }

	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* This is the 16-bit pc-relative branch which could become an 8-bit
       pc-relative branch.  */
    case R_PCRWORD:
      /* Get the address of the target of this branch, add one to the value
	 because the addend field in PCrel jumps is off by -1.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section) + 1;

      /* Get the address of the next instruction if we were to relax.  */
      dot = input_section->output_section->vma +
	input_section->output_offset + address;

      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;

      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int) gap >= -128 && (int) gap <= 128)
	{
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 15;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* This is a 16-bit absolute address in a mov.b insn, which can
       become an 8-bit absolute address if it's in the right range.  */
    case R_MOV16B1:
      /* Get the address of the data referenced by this mov.b insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* If the address is in the top 256 bytes of the address space
	 then we can relax this instruction.  */
      if (value >= 0xffffff00u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* Similarly for a 24-bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8-bit absolute, we'll fall through
       and try to relax it into a 16-bit absolute.  */
    case R_MOV24B1:
      /* Get the address of the data referenced by this mov.b insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      if (value >= 0xffffff00u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by four bytes.  */
	  shrink += 4;
	  bfd_perform_slip (abfd, 4, input_section, address);

	  /* Done with this reloc.  */
	  break;
	}

      /* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit
	 reloc.  */

    /* This is a 24-/32-bit absolute address in a mov insn, which can
       become an 16-bit absolute address if it's in the right range.  */
    case R_MOVL1:
      /* Get the address of the data referenced by this mov insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* If the address is a sign-extended 16-bit value then we can
         relax this instruction.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 17;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

      /* No other reloc types represent relaxing opportunities.  */
    default:
      break;
    }

  last_reloc = reloc;
  last_input_section = input_section;
  return shrink;
}

/* Handle relocations for the H8/300, including relocs for relaxed
   instructions.

   FIXME: Not all relocations check for overflow!  */

static void
h8300_reloc16_extra_cases (bfd *abfd, struct bfd_link_info *link_info,
			   struct bfd_link_order *link_order, arelent *reloc,
			   bfd_byte *data, unsigned int *src_ptr,
			   unsigned int *dst_ptr)
{
  unsigned int src_address = *src_ptr;
  unsigned int dst_address = *dst_ptr;
  asection *input_section = link_order->u.indirect.section;
  bfd_vma value;
  bfd_vma dot;
  int gap, tmp;
  unsigned char temp_code;

  switch (reloc->howto->type)
    {
    /* Generic 8-bit pc-relative relocation.  */
    case R_PCRBYTE:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */
      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    /* Generic 16-bit pc-relative relocation.  */
    case R_PCRWORD:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap > 32766 || gap < -32768)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */
      bfd_put_16 (abfd, (bfd_vma) gap, data + dst_address);
      dst_address += 2;
      src_address += 2;

      /* All done.  */
      break;

    /* Generic 8-bit absolute relocation.  */
    case R_RELBYTE:
      /* Get the address of the object referenced by this insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      bfd_put_8 (abfd, value & 0xff, data + dst_address);
      dst_address += 1;
      src_address += 1;

      /* All done.  */
      break;

    /* Various simple 16-bit absolute relocations.  */
    case R_MOV16B1:
    case R_JMP1:
    case R_RELWORD:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      bfd_put_16 (abfd, value, data + dst_address);
      dst_address += 2;
      src_address += 2;
      break;

    /* Various simple 24-/32-bit absolute relocations.  */
    case R_MOV24B1:
    case R_MOVL1:
    case R_RELLONG:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      bfd_put_32 (abfd, value, data + dst_address);
      dst_address += 4;
      src_address += 4;
      break;

    /* Another 24-/32-bit absolute relocation.  */
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      value = ((value & 0x00ffffff)
	       | (bfd_get_32 (abfd, data + src_address) & 0xff000000));
      bfd_put_32 (abfd, value, data + dst_address);
      dst_address += 4;
      src_address += 4;
      break;

      /* This is a 24-/32-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", "ldc.w",
	   "stc.w" and "mov.[bwl]"

	 We may relax this into an 16-bit absolute address if it's in
	 the right range.  */
    case R_MOVL2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* Sanity check.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
	{
	  /* Insert the 16-bit value into the proper location.  */
	  bfd_put_16 (abfd, value, data + dst_address);

	  /* Fix the opcode.  For all the instructions that belong to
	     this relaxation, we simply need to turn off bit 0x20 in
	     the previous byte.  */
	  data[dst_address - 1] &= ~0x20;
	  dst_address += 2;
	  src_address += 4;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}
      break;

    /* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
    case R_JMP2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the next instruction.  */
      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction itself.  */
      switch (data[dst_address - 1])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 1);
	  break;
	case 0x5a:
	  /* jmp -> bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address - 1);
	  break;

	default:
	  abort ();
	}

      /* Write out the 8-bit value.  */
      bfd_put_8 (abfd, gap, data + dst_address);

      dst_address += 1;
      src_address += 3;

      break;

    /* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
    case R_PCRWORD_B:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma - 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction.  */
      switch (data[dst_address - 2])
	{
	case 0x58:
	  /* bCC:16 -> bCC:8 */
	  /* Get the second byte of the original insn, which contains
	     the condition code.  */
	  tmp = data[dst_address - 1];

	  /* Compute the fisrt byte of the relaxed instruction.  The
	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X
	     represents the condition code.  */
	  tmp &= 0xf0;
	  tmp >>= 4;
	  tmp |= 0x40;

	  /* Write it.  */
	  bfd_put_8 (abfd, tmp, data + dst_address - 2);
	  break;

	case 0x5c:
	  /* bsr:16 -> bsr:8 */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 2);
	  break;

	default:
	  abort ();
	}

      /* Output the target.  */
      bfd_put_8 (abfd, gap, data + dst_address - 1);

      /* We don't advance dst_address -- the 8-bit reloc is applied at
	 dst_address - 1, so the next insn should begin at dst_address.  */
      src_address += 2;

      break;

    /* Similarly for a 24-bit absolute that is now 8 bits.  */
    case R_JMPL2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 2);

      gap = value - dot;

      /* Fix the instruction.  */
      switch (data[src_address])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address);
	  break;
	case 0x5a:
	  /* jmp ->bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address);
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, gap, data + dst_address + 1);
      dst_address += 2;
      src_address += 4;

      break;

      /* This is a 16-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
    case R_MOV16B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* All instructions with R_H8_DIR16B2 start with 0x6a.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x10) != 0x10)
	temp_code &= 0xf0;

      /* Fix up the opcode.  */
      switch (temp_code)
	{
	case 0x00:
	  /* This is mov.b @@aa:16,Rd.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
	  break;
	case 0x80:
	  /* This is mov.b Rs,@@aa:16.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
	  break;
	case 0x18:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x10:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 2;
      break;

      /* This is a 24-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
    case R_MOV24B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* All instructions with R_MOV24B2 start with 0x6a.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x30) != 0x30)
	temp_code &= 0xf0;

      /* Fix up the opcode.  */
      switch (temp_code)
	{
	case 0x20:
	  /* This is mov.b @@aa:24/32,Rd.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
	  break;
	case 0xa0:
	  /* This is mov.b Rs,@@aa:24/32.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
	  break;
	case 0x38:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x30:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 4;
      break;

    case R_BCC_INV:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      dot = (input_section->output_offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma) + 1;

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, NULL,
		  bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Fix the condition in the instruction, apply
	 the relocation, and update the src/dst address appropriately.  */

      bfd_put_8 (abfd, bfd_get_8 (abfd, data + dst_address - 1) ^ 1,
		 data + dst_address - 1);
      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    case R_JMP_DEL:
      src_address += 4;
      break;

    /* An 8-bit memory indirect instruction (jmp/jsr).

       There's several things that need to be done to handle
       this relocation.

       If this is a reloc against the absolute symbol, then
       we should handle it just R_RELBYTE.  Likewise if it's
       for a symbol with a value ge 0 and le 0xff.

       Otherwise it's a jump/call through the function vector,
       and the linker is expected to set up the function vector
       and put the right value into the jump/call instruction.  */
    case R_MEM_INDIRECT:
      {
	/* We need to find the symbol so we can determine it's
	   address in the function vector table.  */
	asymbol *symbol;
	const char *name;
	struct funcvec_hash_table *ftab;
	struct funcvec_hash_entry *h;
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->output_bfd->xvec != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->output_bfd->xvec->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;

	/* First see if this is a reloc against the absolute symbol
	   or against a symbol with a nonnegative value <= 0xff.  */
	symbol = *(reloc->sym_ptr_ptr);
	value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
	if (symbol == bfd_abs_section_ptr->symbol
	    || value <= 0xff)
	  {
	    /* This should be handled in a manner very similar to
	       R_RELBYTES.   If the value is in range, then just slam
	       the value into the right location.  Else trigger a
	       reloc overflow callback.  */
	    if (value <= 0xff)
	      {
		bfd_put_8 (abfd, value, data + dst_address);
		dst_address += 1;
		src_address += 1;
	      }
	    else
	      {
		if (! ((*link_info->callbacks->reloc_overflow)
		       (link_info, NULL,
			bfd_asymbol_name (*reloc->sym_ptr_ptr),
			reloc->howto->name, reloc->addend, input_section->owner,
			input_section, reloc->address)))
		  abort ();
	      }
	    break;
	  }

	/* This is a jump/call through a function vector, and we're
	   expected to create the function vector ourselves.

	   First look up this symbol in the linker hash table -- we need
	   the derived linker symbol which holds this symbol's index
	   in the function vector.  */
	name = symbol->name;
	if (symbol->flags & BSF_LOCAL)
	  {
	    char *new_name = bfd_malloc ((bfd_size_type) strlen (name) + 10);

	    if (new_name == NULL)
	      abort ();

	    sprintf (new_name, "%s_%08x", name, symbol->section->id);
	    name = new_name;
	  }

	ftab = htab->funcvec_hash_table;
	h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);

	/* This shouldn't ever happen.  If it does that means we've got
	   data corruption of some kind.  Aborting seems like a reasonable
	   thing to do here.  */
	if (h == NULL || vectors_sec == NULL)
	  abort ();

	/* Place the address of the function vector entry into the
	   reloc's address.  */
	bfd_put_8 (abfd,
		   vectors_sec->output_offset + h->offset,
		   data + dst_address);

	dst_address++;
	src_address++;

	/* Now create an entry in the function vector itself.  */
	switch (bfd_get_mach (input_section->owner))
	  {
	  case bfd_mach_h8300:
	  case bfd_mach_h8300hn:
	  case bfd_mach_h8300sn:
	    bfd_put_16 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  case bfd_mach_h8300h:
	  case bfd_mach_h8300s:
	    bfd_put_32 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  default:
	    abort ();
	  }

	/* Gross.  We've already written the contents of the vector section
	   before we get here...  So we write it again with the new data.  */
	bfd_set_section_contents (vectors_sec->output_section->owner,
				  vectors_sec->output_section,
				  vectors_sec->contents,
				  (file_ptr) vectors_sec->output_offset,
				  vectors_sec->size);
	break;
      }

    default:
      abort ();
      break;

    }

  *src_ptr = src_address;
  *dst_ptr = dst_address;
}

/* Routine for the h8300 linker.

   This routine is necessary to handle the special R_MEM_INDIRECT
   relocs on the h8300.  It's responsible for generating a vectors
   section and attaching it to an input bfd as well as sizing
   the vectors section.  It also creates our vectors hash table.

   It uses the generic linker routines to actually add the symbols.
   from this BFD to the bfd linker hash table.  It may add a few
   selected static symbols to the bfd linker hash table.  */

static bfd_boolean
h8300_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  asection *sec;
  struct funcvec_hash_table *funcvec_hash_table;
  bfd_size_type amt;
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->output_bfd->xvec != abfd->xvec)
    return TRUE;

  htab = h8300_coff_hash_table (info);

  /* If we haven't created a vectors section, do so now.  */
  if (!htab->vectors_sec)
    {
      flagword flags;

      /* Make sure the appropriate flags are set, including SEC_IN_MEMORY.  */
      flags = (SEC_ALLOC | SEC_LOAD
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY);
      htab->vectors_sec = bfd_make_section_with_flags (abfd, ".vectors",
						       flags);

      /* If the section wasn't created, or we couldn't set the flags,
	 quit quickly now, rather than dying a painful death later.  */
      if (!htab->vectors_sec)
	return FALSE;

      /* Also create the vector hash table.  */
      amt = sizeof (struct funcvec_hash_table);
      funcvec_hash_table = (struct funcvec_hash_table *) bfd_alloc (abfd, amt);

      if (!funcvec_hash_table)
	return FALSE;

      /* And initialize the funcvec hash table.  */
      if (!funcvec_hash_table_init (funcvec_hash_table, abfd,
				    funcvec_hash_newfunc,
				    sizeof (struct funcvec_hash_entry)))
	{
	  bfd_release (abfd, funcvec_hash_table);
	  return FALSE;
	}

      /* Store away a pointer to the funcvec hash table.  */
      htab->funcvec_hash_table = funcvec_hash_table;
    }

  /* Load up the function vector hash table.  */
  funcvec_hash_table = htab->funcvec_hash_table;

  /* Now scan the relocs for all the sections in this bfd; create
     additional space in the .vectors section as needed.  */
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      long reloc_size, reloc_count, i;
      asymbol **symbols;
      arelent **relocs;

      /* Suck in the relocs, symbols & canonicalize them.  */
      reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
      if (reloc_size <= 0)
	continue;

      relocs = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
      if (!relocs)
	return FALSE;

      /* The symbols should have been read in by _bfd_generic link_add_symbols
	 call abovec, so we can cheat and use the pointer to them that was
	 saved in the above call.  */
      symbols = _bfd_generic_link_get_symbols(abfd);
      reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, symbols);
      if (reloc_count <= 0)
	{
	  free (relocs);
	  continue;
	}

      /* Now walk through all the relocations in this section.  */
      for (i = 0; i < reloc_count; i++)
	{
	  arelent *reloc = relocs[i];
	  asymbol *symbol = *(reloc->sym_ptr_ptr);
	  const char *name;

	  /* We've got an indirect reloc.  See if we need to add it
	     to the function vector table.   At this point, we have
	     to add a new entry for each unique symbol referenced
	     by an R_MEM_INDIRECT relocation except for a reloc
	     against the absolute section symbol.  */
	  if (reloc->howto->type == R_MEM_INDIRECT
	      && symbol != bfd_abs_section_ptr->symbol)

	    {
	      struct funcvec_hash_table *ftab;
	      struct funcvec_hash_entry *h;

	      name = symbol->name;
	      if (symbol->flags & BSF_LOCAL)
		{
		  char *new_name;

		  new_name = bfd_malloc ((bfd_size_type) strlen (name) + 10);
		  if (new_name == NULL)
		    abort ();

		  sprintf (new_name, "%s_%08x", name, symbol->section->id);
		  name = new_name;
		}

	      /* Look this symbol up in the function vector hash table.  */
	      ftab = htab->funcvec_hash_table;
	      h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);

	      /* If this symbol isn't already in the hash table, add
		 it and bump up the size of the hash table.  */
	      if (h == NULL)
		{
		  h = funcvec_hash_lookup (ftab, name, TRUE, TRUE);
		  if (h == NULL)
		    {
		      free (relocs);
		      return FALSE;
		    }

		  /* Bump the size of the vectors section.  Each vector
		     takes 2 bytes on the h8300 and 4 bytes on the h8300h.  */
		  switch (bfd_get_mach (abfd))
		    {
		    case bfd_mach_h8300:
		    case bfd_mach_h8300hn:
		    case bfd_mach_h8300sn:
		      htab->vectors_sec->size += 2;
		      break;
		    case bfd_mach_h8300h:
		    case bfd_mach_h8300s:
		      htab->vectors_sec->size += 4;
		      break;
		    default:
		      abort ();
		    }
		}
	    }
	}

      /* We're done with the relocations, release them.  */
      free (relocs);
    }

  /* Now actually allocate some space for the function vector.  It's
     wasteful to do this more than once, but this is easier.  */
  sec = htab->vectors_sec;
  if (sec->size != 0)
    {
      /* Free the old contents.  */
      if (sec->contents)
	free (sec->contents);

      /* Allocate new contents.  */
      sec->contents = bfd_malloc (sec->size);
    }

  return TRUE;
}

#define coff_reloc16_extra_cases h8300_reloc16_extra_cases
#define coff_reloc16_estimate h8300_reloc16_estimate
#define coff_bfd_link_add_symbols h8300_bfd_link_add_symbols
#define coff_bfd_link_hash_table_create h8300_coff_link_hash_table_create

#define COFF_LONG_FILENAMES

#ifndef bfd_pe_print_pdata
#define bfd_pe_print_pdata	NULL
#endif

#include "coffcode.h"

#undef coff_bfd_get_relocated_section_contents
#undef coff_bfd_relax_section
#define coff_bfd_get_relocated_section_contents \
  bfd_coff_reloc16_get_relocated_section_contents
#define coff_bfd_relax_section bfd_coff_reloc16_relax_section

CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
@


1.44
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d176 1
a176 1
  ret = (struct h8300_coff_link_hash_table *) bfd_malloc (amt);
a186 5
  /* Initialize our data.  */
  ret->vectors_sec = NULL;
  ret->funcvec_hash_table = NULL;

  /* OK.  Everything's initialized, return the base pointer.  */
@


1.43
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
a62 22
static struct bfd_hash_entry *
funcvec_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

static bfd_reloc_status_type special
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
static int select_reloc
  (reloc_howto_type *);
static void rtype2howto
  (arelent *, struct internal_reloc *);
static void reloc_processing
  (arelent *, struct internal_reloc *, asymbol **, bfd *, asection *);
static bfd_boolean h8300_symbol_address_p
  (bfd *, asection *, bfd_vma);
static int h8300_reloc16_estimate
  (bfd *, asection *, arelent *, unsigned int,
   struct bfd_link_info *);
static void h8300_reloc16_extra_cases
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
   bfd_byte *, unsigned int *, unsigned int *);
static bfd_boolean h8300_bfd_link_add_symbols
  (bfd *, struct bfd_link_info *);
d205 7
a211 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d221 2
a222 1
static reloc_howto_type howto_table[] = {
@


1.42
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d1432 5
@


1.41
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d1119 1
a1119 1
	if (link_info->hash->creator != abfd->xvec)
d1123 1
a1123 1
	       link_info->hash->creator->name);
d1267 1
a1267 1
  if (info->hash->creator != abfd->xvec)
@


1.40
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.39
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d23 1
a24 1
#include "sysdep.h"
@


1.38
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1279 2
a1280 1
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");
d1284 1
a1284 2
      if (!htab->vectors_sec
	  || !bfd_set_section_flags (abfd, htab->vectors_sec, flags))
@


1.37
log
@	* coff-h8300.c (h8300_reloc16_extra_cases): Use input section
	"output_offset" instead of link order "offset".
	* coff-h8500.c (extra_case): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z80.c (extra_case): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* linker.c (default_indirect_link_order): Likewise, "size" too.
	* ecoff.c (ecoff_indirect_link_order): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
a65 7
static bfd_boolean
funcvec_hash_table_init
  (struct funcvec_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));

d177 2
a178 1
			    const char *))
d184 1
a184 1
  return (bfd_hash_table_init (&table->root, newfunc));
d201 2
a202 1
				  _bfd_generic_link_hash_newfunc))
d1296 2
a1297 1
				    funcvec_hash_newfunc))
@


1.36
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d674 1
a674 1
      dot = (link_order->offset
d706 1
a706 1
      dot = (link_order->offset
d820 1
a820 1
      dot = (link_order->offset
d867 1
a867 1
      dot = (link_order->offset
d928 1
a928 1
      dot = (link_order->offset
d1067 1
a1067 1
      dot = (link_order->offset
@


1.35
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.34
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.33
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d1178 1
a1178 1
	    char *new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);
d1183 1
a1183 3
	    strcpy (new_name, name);
	    sprintf (new_name + strlen (name), "_%08x",
		     (int) symbol->section);
d1366 1
a1366 1
		  new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);
d1370 1
a1370 3
		  strcpy (new_name, name);
		  sprintf (new_name + strlen (name), "_%08x",
			   (int) symbol->section);
@


1.32
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a399 1

a400 3
#if 0
  relent->section = 0;
#endif
@


1.31
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d688 2
a689 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d720 2
a721 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d810 2
a811 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d834 2
a835 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d881 2
a882 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d1081 2
a1082 1
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
d1164 2
a1165 1
		       (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
@


1.30
log
@Add support for relaxing the 32bit ldc/stc instructions.
@
text
@d1234 1
a1234 1
				  vectors_sec->_raw_size);
d1397 1
a1397 1
		      htab->vectors_sec->_raw_size += 2;
d1401 1
a1401 1
		      htab->vectors_sec->_raw_size += 4;
d1417 1
a1417 1
  if (sec->_raw_size != 0)
d1424 1
a1424 1
      sec->contents = bfd_malloc (sec->_raw_size);
@


1.30.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1234 1
a1234 1
				  vectors_sec->size);
d1397 1
a1397 1
		      htab->vectors_sec->size += 2;
d1401 1
a1401 1
		      htab->vectors_sec->size += 4;
d1417 1
a1417 1
  if (sec->size != 0)
d1424 1
a1424 1
      sec->contents = bfd_malloc (sec->size);
@


1.29
log
@	* coff-h8300.c: Add and adjust comments about relaxation.
	* elf32-h8300.c: Likewise.
@
text
@d783 2
a784 2
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.[bwl]"
@


1.28
log
@	* coff-h8300.c: Fix comment typos.
	* elf32-h8300.c: Likewise.
@
text
@d779 9
a787 2
    /* A 16-bit absolute relocation that was formerly a 24-/32-bit
       absolute relocation.  */
d798 3
a800 2
	  /* Fix the opcode.  For all the move insns, we simply
	     need to turn off bit 0x20 in the previous byte.  */
d845 1
a845 1
	  /* jmp ->bra */
d888 2
a889 1
	  /* Get the condition code from the original insn.  */
d891 4
a896 2

	  /* Now or in the high nibble of the opcode.  */
@


1.27
log
@	* coff-h8300.c: Add comments about relaxation.
	* elf32-h8300.c: Likewise.
@
text
@d268 2
a269 2
  /* Internal reloc for relaxing.  This is created when a 16bit pc-relative
     branch is turned into an 8bit pc-relative branch.  */
d461 2
a462 2
      /* This is the 16/24 bit absolute branch which could become an 8 bit
	 pc-relative branch.  */
d550 1
a550 1
    /* This is the 16 bit pc-relative branch which could become an 8 bit
d578 2
a579 2
    /* This is a 16 bit absolute address in a mov.b insn, which can
       become an 8 bit absolute address if it's in the right range.  */
d598 3
a600 3
    /* Similarly for a 24 bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8 bit absolute, we'll fall through
       and try to relax it into a 16bit absolute.  */
d619 1
a619 1
      /* FALLTHROUGH and try to turn the 32/24 bit reloc into a 16 bit
d622 2
a623 2
    /* This is a 24/32 bit absolute address in a mov insn, which can
       become an 16 bit absolute address if it's in the right range.  */
d673 1
a673 1
    /* Generic 8bit pc-relative relocation.  */
d703 1
a703 1
    /* Generic 16bit pc-relative relocation.  */
d734 1
a734 1
    /* Generic 8bit absolute relocation.  */
d746 1
a746 1
    /* Various simple 16bit absolute relocations.  */
d756 1
a756 1
    /* Various simple 24/32bit absolute relocations.  */
d767 1
a767 1
    /* Another 24/32bit absolute relocation.  */
d779 1
a779 1
    /* A 16bit absolute relocation that was formerly a 24/32bit
d788 1
a788 1
	  /* Insert the 16bit value into the proper location.  */
d807 1
a807 1
    /* A 16bit absolute branch that is now an 8-bit pc-relative branch.  */
d845 1
a845 1
      /* Write out the 8bit value.  */
d853 1
a853 1
    /* A 16bit pc-relative branch that is now an 8-bit pc-relative branch.  */
d904 1
a904 1
      /* We don't advance dst_address -- the 8bit reloc is applied at
d910 1
a910 1
    /* Similarly for a 24bit absolute that is now 8 bits.  */
d1087 1
a1087 1
    /* An 8bit memory indirect instruction (jmp/jsr).
@


1.26
log
@Add support for relaxation of bit manipulation instructions.
@
text
@d943 9
a951 1
    /* A 16bit absolute mov.b that is now an 8bit absolute mov.b.  */
d955 1
a955 1
      /* Sanity check.  */
d960 3
d970 1
d974 1
d978 3
d984 3
d997 9
a1005 1
    /* Similarly for a 24bit mov.b  */
d1009 1
a1009 1
      /* Sanity check.  */
d1014 3
d1024 1
d1028 1
d1032 3
d1038 3
@


1.25
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d669 1
d951 4
d956 1
a956 1
      switch (data[src_address - 1] & 0xf0)
d964 6
d986 4
d991 1
a991 1
      switch (data[src_address - 1] & 0xf0)
d998 6
@


1.24
log
@Fix normal operation for h8300-coff target
@
text
@d778 1
a778 1
    /* A 16bit abolute relocation that was formerlly a 24/32bit
@


1.23
log
@bfd/
	* bfd-in.h (bfd_h8300_pad_address): Declare.
	* bfd-in2.h: Regenerate.
	* cpu-h8300.c (bfd_h8300_pad_address): New function.
	* coff-h8300.c (h8300_reloc16_estimate): Use it to canonicalize
	addresses before checking whether they can be relaxed.
	(h8300_reloc16_extra_cases): Likewise for the R_MOVL2 sanity check.
	Don't complain about overflows in general 8-bit relocations.
	* elf32-h8300.c (elf32_h8_relax_section): Use bfd_h8300_pad_address.
	Fix handling of R_H8_DIR24A8.

ld/testsuite/
	* ld-h8300/relax-3{.s,.d,-coff.d}: New test.
	* ld-h8300/h8300.exp: Run it.
@
text
@d157 14
a170 7
  if (bfd_get_mach (table->abfd) == bfd_mach_h8300)
    table->offset += 2;
  else if (bfd_get_mach (table->abfd) == bfd_mach_h8300h
	   || bfd_get_mach (table->abfd) == bfd_mach_h8300s)
    table->offset += 4;
  else
    return NULL;
d1106 1
d1135 22
a1156 15
	if (bfd_get_mach (input_section->owner) == bfd_mach_h8300)
	  bfd_put_16 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else if (bfd_get_mach (input_section->owner) == bfd_mach_h8300h
		 || bfd_get_mach (input_section->owner) == bfd_mach_h8300s)
	  bfd_put_32 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else
	  abort ();
d1322 14
a1335 5
		  if (bfd_get_mach (abfd) == bfd_mach_h8300)
		    htab->vectors_sec->_raw_size += 2;
		  else if (bfd_get_mach (abfd) == bfd_mach_h8300h
			   || bfd_get_mach (abfd) == bfd_mach_h8300s)
		    htab->vectors_sec->_raw_size += 4;
@


1.22
log
@	* elf32-h8300.c: Convert function prototypes and definitions
	to C90 syntax.
	* coff-h8300.c: Likewise.
	* cpu-h8300.c: Likewise.
@
text
@d576 1
d578 3
a580 10
      /* The address is in 0xff00..0xffff inclusive on the h8300 or
	 0xffff00..0xffffff inclusive on the h8300h, then we can
	 relax this mov.b  */
      if ((bfd_get_mach (abfd) == bfd_mach_h8300
	   && value >= 0xff00
	   && value <= 0xffff)
	  || ((bfd_get_mach (abfd) == bfd_mach_h8300h
	       || bfd_get_mach (abfd) == bfd_mach_h8300s)
	      && value >= 0xffff00
	      && value <= 0xffffff))
d597 1
d599 1
a599 6
      /* The address is in 0xffff00..0xffffff inclusive on the h8300h,
	 then we can relax this mov.b  */
      if ((bfd_get_mach (abfd) == bfd_mach_h8300h
	   || bfd_get_mach (abfd) == bfd_mach_h8300s)
	  && value >= 0xffff00
	  && value <= 0xffffff)
d620 1
d622 3
a624 3
      /* If this address is in 0x0000..0x7fff inclusive or
	 0xff8000..0xffffff inclusive, then it can be relaxed.  */
      if (value <= 0x7fff || value >= 0xff8000)
d731 3
a733 20
      /* Sanity check.  */
      if (value <= 0xff
	  || (value >= 0x0000ff00 && value <= 0x0000ffff)
	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
	  || (value >= 0xffffff00 && value <= 0xffffffff))
	{
	  /* Everything looks OK.  Apply the relocation and update the
	     src/dst address appropriately.  */
	  bfd_put_8 (abfd, value & 0xff, data + dst_address);
	  dst_address += 1;
	  src_address += 1;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}
d775 1
d778 1
a778 1
      if (value <= 0x7fff || value >= 0xff8000)
@


1.21
log
@Altered the CREATE_xxx_COFF_TARGET_VEC macro arguments
@
text
@d64 1
a64 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d68 4
a71 4
  PARAMS ((struct funcvec_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d74 1
a74 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d76 1
a76 1
  PARAMS ((reloc_howto_type *));
d78 1
a78 1
  PARAMS ((arelent *, struct internal_reloc *));
d80 1
a80 1
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d82 1
a82 1
  PARAMS ((bfd *, asection *, bfd_vma));
d84 2
a85 2
  PARAMS ((bfd *, asection *, arelent *, unsigned int,
    struct bfd_link_info *));
d87 2
a88 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
    bfd_byte *, unsigned int *, unsigned int *));
d90 1
a90 1
  PARAMS ((bfd *, struct bfd_link_info *));
d114 1
a114 2
static struct bfd_link_hash_table *h8300_coff_link_hash_table_create
  PARAMS ((bfd *));
d125 3
a127 4
funcvec_hash_newfunc (entry, gen_table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *gen_table;
     const char *string;
d172 6
a177 6
funcvec_hash_table_init (table, abfd, newfunc)
     struct funcvec_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d191 1
a191 2
h8300_coff_link_hash_table_create (abfd)
     bfd *abfd;
d224 7
a230 9
special (abfd, reloc_entry, symbol, data, input_section, output_bfd,
	 error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d292 1
a292 2
select_reloc (howto)
     reloc_howto_type *howto;
d300 1
a300 3
rtype2howto (internal, dst)
     arelent *internal;
     struct internal_reloc *dst;
d381 2
a382 6
reloc_processing (relent, reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
d401 1
a401 4
h8300_symbol_address_p (abfd, input_section, address)
     bfd *abfd;
     asection *input_section;
     bfd_vma address;
d433 2
a434 6
h8300_reloc16_estimate (abfd, input_section, reloc, shrink, link_info)
     bfd *abfd;
     asection *input_section;
     arelent *reloc;
     unsigned int shrink;
     struct bfd_link_info *link_info;
d660 4
a663 9
h8300_reloc16_extra_cases (abfd, link_info, link_order, reloc, data, src_ptr,
			   dst_ptr)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     arelent *reloc;
     bfd_byte *data;
     unsigned int *src_ptr;
     unsigned int *dst_ptr;
d1200 1
a1200 3
h8300_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
@


1.20
log
@Add support for h8300hn and h8300sn
@
text
@d1401 1
a1401 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL)
@


1.19
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d284 3
a286 2
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x))
#define H8300 1			/* Customize coffcode.h */
@


1.19.2.1
log
@Merge from mainline.
@
text
@d284 2
a285 3
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
@


1.18
log
@Fix typo: intial -> initial.
@
text
@d1 1
a1 1
/* BFD back-end for Hitachi H8/300 COFF binaries.
@


1.17
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d213 1
a213 1
  /* OK.  Everything's intialized, return the base pointer.  */
d399 1
a399 3
    {
      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
    }
d401 1
a401 3
    {
      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
    }
d427 1
d472 2
a473 2
    /* This is the 16/24 bit absolute branch which could become an 8 bit
       pc-relative branch.  */
a719 1

a750 1

a770 1

@


1.16
log
@	* coff-h8300.c: Include libiberty.h.
	(h8300_reloc16_extra_cases): Check the hash table creator before
	referencing h8300 specific fields.  Stash the hash table pointer
	in a local var.  Comment typo fixes.
	(h8300_bfd_link_add_symbols): Likewise.
@
text
@d189 1
a189 1
   basically to hold "static" information during an h8/300 coff link
@


1.15
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d31 1
d69 1
a69 1
           struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
d141 2
a142 2
           bfd_hash_allocate (gen_table,
                              sizeof (struct funcvec_hash_entry)));
d520 5
a524 5
	     	             mov.w   r0,r0
	     	             beq     .L1
	           	     jsr     @@_bar
	              .L1:   rts
	              _bar:  rts
d526 4
a529 4
	     	             mov.w   r0,r0
	     	             bne     _bar
	     	             rts
	     	      _bar:  rts
d568 1
a568 1
         because the addend field in PCrel jumps is off by -1.  */
d653 1
a653 1
         0xff8000..0xffffff inclusive, then it can be relaxed.  */
d1095 19
a1113 1
	asection *vectors_sec = h8300_coff_hash_table (link_info)->vectors_sec;
d1162 1
a1162 1
	ftab = h8300_coff_hash_table (link_info)->funcvec_hash_table;
d1167 1
a1167 1
	   think to do here.  */
d1236 9
d1247 1
a1247 1
  if (!h8300_coff_hash_table (info)->vectors_sec)
d1254 1
a1254 2
      h8300_coff_hash_table (info)->vectors_sec = bfd_make_section (abfd,
								    ".vectors");
d1257 3
a1259 5
	 quit quickly now, rather than dieing a painful death later.  */
      if (! h8300_coff_hash_table (info)->vectors_sec
	  || ! bfd_set_section_flags (abfd,
				      h8300_coff_hash_table(info)->vectors_sec,
				      flags))
d1278 1
a1278 1
      h8300_coff_hash_table (info)->funcvec_hash_table = funcvec_hash_table;
d1282 1
a1282 4
  funcvec_hash_table = h8300_coff_hash_table (info)->funcvec_hash_table;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);
d1347 1
a1347 1
	      ftab = h8300_coff_hash_table (info)->funcvec_hash_table;
d1364 1
a1364 1
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 2;
d1367 1
a1367 1
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 4;
d1378 1
a1378 1
  sec = h8300_coff_hash_table (info)->vectors_sec;
@


1.14
log
@Fix h8300 relaxation.
@
text
@d65 1
a65 1
static boolean
d68 22
a89 12
           struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *,
                                               struct bfd_hash_table *,
                                               const char *))));

static bfd_reloc_status_type special PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static int select_reloc PARAMS ((reloc_howto_type *));
static void rtype2howto PARAMS ((arelent *, struct internal_reloc *));
static void reloc_processing PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
static boolean h8300_symbol_address_p PARAMS ((bfd *, asection *, bfd_vma));
static int h8300_reloc16_estimate PARAMS ((bfd *, asection *, arelent *, unsigned int, struct bfd_link_info *));
static void h8300_reloc16_extra_cases PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *, bfd_byte *, unsigned int *, unsigned int *));
static boolean h8300_bfd_link_add_symbols PARAMS ((bfd *, struct bfd_link_info *));
d172 1
a172 1
static boolean
d176 3
a178 3
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d245 14
a258 14
  HOWTO (R_RELBYTE, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "8", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_RELWORD, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "16", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_RELLONG, 0, 2, 32, false, 0, complain_overflow_bitfield, special, "32", false, 0xffffffff, 0xffffffff, false),
  HOWTO (R_PCRBYTE, 0, 0, 8, true, 0, complain_overflow_signed, special, "DISP8", false, 0x000000ff, 0x000000ff, true),
  HOWTO (R_PCRWORD, 0, 1, 16, true, 0, complain_overflow_signed, special, "DISP16", false, 0x0000ffff, 0x0000ffff, true),
  HOWTO (R_PCRLONG, 0, 2, 32, true, 0, complain_overflow_signed, special, "DISP32", false, 0xffffffff, 0xffffffff, true),
  HOWTO (R_MOV16B1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_MOV16B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_JMP1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "16/pcrel", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_JMP2, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pcrecl/16", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_JMPL1, 0, 2, 32, false, 0, complain_overflow_bitfield, special, "24/pcrell", false, 0x00ffffff, 0x00ffffff, false),
  HOWTO (R_JMPL2, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pc8/24", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_MOV24B1, 0, 1, 32, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", false, 0xffffffff, 0xffffffff, false),
  HOWTO (R_MOV24B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", false, 0x0000ffff, 0x0000ffff, false),
d263 1
a263 1
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "8/indirect", false, 0x000000ff, 0x000000ff, false),
d267 1
a267 1
  HOWTO (R_PCRWORD_B, 0, 0, 8, true, 0, complain_overflow_bitfield, special, "relaxed bCC:16", false, 0x000000ff, 0x000000ff, false),
d269 1
a269 1
  HOWTO (R_MOVL1, 0, 2, 32, false, 0, complain_overflow_bitfield,special, "32/24 relaxable move", false, 0xffffffff, 0xffffffff, false),
d271 1
a271 1
  HOWTO (R_MOVL2, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "32/24 relaxed move", false, 0x0000ffff, 0x0000ffff, false),
d273 1
a273 1
  HOWTO (R_BCC_INV, 0, 0, 8, true, 0, complain_overflow_signed, special, "DISP8 inverted", false, 0x000000ff, 0x000000ff, true),
d275 1
a275 1
  HOWTO (R_JMP_DEL, 0, 0, 8, true, 0, complain_overflow_signed, special, "Deleted jump", false, 0x000000ff, 0x000000ff, true),
d414 1
a414 1
static boolean
d434 1
a434 1
	return true;
d437 1
a437 1
  return false;
d518 1
a518 1
	     
d529 1
a529 1
	     
d1144 1
a1144 1
	h = funcvec_hash_lookup (ftab, name, false, false);
d1209 1
a1209 1
static boolean
d1235 1
a1235 1
	return false;
d1242 1
a1242 1
	return false;
d1249 1
a1249 1
	  return false;
d1277 1
a1277 1
	return false;
d1326 1
a1326 1
	      h = funcvec_hash_lookup (ftab, name, false, false);
d1332 1
a1332 1
		  h = funcvec_hash_lookup (ftab, name, true, true);
d1336 1
a1336 1
		      return false;
d1367 1
a1367 1
  return true;
@


1.13
log
@	* coff-h8300.c: Fix formatting.
	* elf32-h8300.c: Likewise.
	* reloc16.c: Likewise.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d486 7
d504 1
a504 1
	     common.  */
d506 17
a522 1
	  if (gap <= 126
@


1.12
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d90 1
a90 2
struct h8300_coff_link_hash_table
{
d137 1
a137 1
         bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));
d167 2
a168 2
                                                struct bfd_hash_table *,
                                                const char *));
d234 1
a234 2
static reloc_howto_type howto_table[] =
{
d271 1
a271 1
  { x.r_type = select_reloc(howto); }
d273 1
a273 1
#define BADMAG(x) (H8300BADMAG(x) && H8300HBADMAG(x) && H8300SBADMAG(x))
d366 1
a366 1
#define RTYPE2HOWTO(internal, relocentry) rtype2howto(internal,relocentry)
d371 1
a371 1
 cache_ptr->addend =  ext_reloc.r_offset;
d374 1
a374 1
 reloc_processing(relent, reloc, symbols, abfd, section)
d484 1
a484 1
      if ((int)gap >= -128 && (int)gap <= 128 )
d547 1
a547 1
      if ((int)gap >= -128 && (int)gap <= 128 )
d737 1
a737 1
  	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
d805 1
a805 1
          data[dst_address - 1] &= ~0x20;
d816 1
a816 1
        }
d913 2
a914 2
	/* Output the target.  */
	bfd_put_8 (abfd, gap, data + dst_address - 1);
d916 3
a918 3
	/* We don't advance dst_address -- the 8bit reloc is applied at
	   dst_address - 1, so the next insn should begin at dst_address.  */
	src_address += 2;
d920 1
a920 1
	break;
@


1.12.20.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* BFD back-end for Renesas H8/300 COFF binaries.
d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a30 1
#include "libiberty.h"
d63 1
a63 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d65 1
a65 1
static bfd_boolean
d67 13
a79 23
  (struct funcvec_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));

static bfd_reloc_status_type special
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
static int select_reloc
  (reloc_howto_type *);
static void rtype2howto
  (arelent *, struct internal_reloc *);
static void reloc_processing
  (arelent *, struct internal_reloc *, asymbol **, bfd *, asection *);
static bfd_boolean h8300_symbol_address_p
  (bfd *, asection *, bfd_vma);
static int h8300_reloc16_estimate
  (bfd *, asection *, arelent *, unsigned int,
   struct bfd_link_info *);
static void h8300_reloc16_extra_cases
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
   bfd_byte *, unsigned int *, unsigned int *);
static bfd_boolean h8300_bfd_link_add_symbols
  (bfd *, struct bfd_link_info *);
d90 2
a91 1
struct h8300_coff_link_hash_table {
d104 2
a105 1
static struct bfd_link_hash_table *h8300_coff_link_hash_table_create (bfd *);
d116 4
a119 3
funcvec_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *gen_table,
		      const char *string)
d131 2
a132 2
	   bfd_hash_allocate (gen_table,
			      sizeof (struct funcvec_hash_entry)));
d138 1
a138 1
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));
d149 7
a155 14
 switch (bfd_get_mach (table->abfd))
   {
   case bfd_mach_h8300:
   case bfd_mach_h8300hn:
   case bfd_mach_h8300sn:
     table->offset += 2;
     break;
   case bfd_mach_h8300h:
   case bfd_mach_h8300s:
     table->offset += 4;
     break;
   default:
     return NULL;
   }
d163 7
a169 7
static bfd_boolean
funcvec_hash_table_init (struct funcvec_hash_table *table,
			 bfd *abfd,
			 struct bfd_hash_entry *(*newfunc)
			   (struct bfd_hash_entry *,
			    struct bfd_hash_table *,
			    const char *))
d179 1
a179 1
   basically to hold "static" information during an H8/300 coff link
d183 2
a184 1
h8300_coff_link_hash_table_create (bfd *abfd)
d203 1
a203 1
  /* OK.  Everything's initialized, return the base pointer.  */
d217 9
a225 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d235 16
a250 15
static reloc_howto_type howto_table[] = {
  HOWTO (R_RELBYTE, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_RELWORD, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_RELLONG, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "32", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_PCRBYTE, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8", FALSE, 0x000000ff, 0x000000ff, TRUE),
  HOWTO (R_PCRWORD, 0, 1, 16, TRUE, 0, complain_overflow_signed, special, "DISP16", FALSE, 0x0000ffff, 0x0000ffff, TRUE),
  HOWTO (R_PCRLONG, 0, 2, 32, TRUE, 0, complain_overflow_signed, special, "DISP32", FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO (R_MOV16B1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_MOV16B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMP1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16/pcrel", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_JMP2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pcrecl/16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMPL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "24/pcrell", FALSE, 0x00ffffff, 0x00ffffff, FALSE),
  HOWTO (R_JMPL2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pc8/24", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_MOV24B1, 0, 1, 32, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_MOV24B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d255 1
a255 1
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8/indirect", FALSE, 0x000000ff, 0x000000ff, FALSE),
d259 1
a259 1
  HOWTO (R_PCRWORD_B, 0, 0, 8, TRUE, 0, complain_overflow_bitfield, special, "relaxed bCC:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
d261 1
a261 1
  HOWTO (R_MOVL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,special, "32/24 relaxable move", FALSE, 0xffffffff, 0xffffffff, FALSE),
d263 1
a263 1
  HOWTO (R_MOVL2, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "32/24 relaxed move", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d265 1
a265 1
  HOWTO (R_BCC_INV, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8 inverted", FALSE, 0x000000ff, 0x000000ff, TRUE),
d267 1
a267 1
  HOWTO (R_JMP_DEL, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "Deleted jump", FALSE, 0x000000ff, 0x000000ff, TRUE),
d273 1
a273 1
  { x.r_type = select_reloc (howto); }
d275 2
a276 3
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
d287 2
a288 1
select_reloc (reloc_howto_type *howto)
d296 3
a298 1
rtype2howto (arelent *internal, struct internal_reloc *dst)
d368 1
a368 1
#define RTYPE2HOWTO(internal, relocentry) rtype2howto (internal, relocentry)
d373 1
a373 1
 cache_ptr->addend = ext_reloc.r_offset;
d376 1
a376 1
 reloc_processing (relent, reloc, symbols, abfd, section)
d379 6
a384 2
reloc_processing (arelent *relent, struct internal_reloc *reloc,
		  asymbol **symbols, bfd *abfd, asection *section)
d390 3
a392 1
    relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
d394 3
a396 1
    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
d406 5
a410 2
static bfd_boolean
h8300_symbol_address_p (bfd *abfd, asection *input_section, bfd_vma address)
a421 1

d426 1
a426 1
	return TRUE;
d429 1
a429 1
  return FALSE;
d441 6
a446 2
h8300_reloc16_estimate (bfd *abfd, asection *input_section, arelent *reloc,
			unsigned int shrink, struct bfd_link_info *link_info)
d466 2
a467 2
      /* This is the 16/24 bit absolute branch which could become an 8 bit
	 pc-relative branch.  */
d486 1
a486 1
      if ((int) gap >= -128 && (int) gap <= 128)
a487 7
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

d499 1
a499 4
	     common.

	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:
d501 1
a501 14
			     mov.w   r0,r0
			     beq     .L1
			     jsr     @@_bar
		      .L1:   rts
		      _bar:  rts
	     into:
			     mov.w   r0,r0
			     bne     _bar
			     rts
		      _bar:  rts

	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
d536 1
a536 1
	 because the addend field in PCrel jumps is off by -1.  */
d549 1
a549 1
      if ((int) gap >= -128 && (int) gap <= 128)
a564 1
      value = bfd_h8300_pad_address (abfd, value);
d566 10
a575 3
      /* If the address is in the top 256 bytes of the address space
	 then we can relax this instruction.  */
      if (value >= 0xffffff00u)
a591 1
      value = bfd_h8300_pad_address (abfd, value);
d593 6
a598 1
      if (value >= 0xffffff00u)
a618 1
      value = bfd_h8300_pad_address (abfd, value);
d620 3
a622 3
      /* If the address is a sign-extended 16-bit value then we can
         relax this instruction.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
d649 9
a657 4
h8300_reloc16_extra_cases (bfd *abfd, struct bfd_link_info *link_info,
			   struct bfd_link_order *link_order, arelent *reloc,
			   bfd_byte *data, unsigned int *src_ptr,
			   unsigned int *dst_ptr)
d691 1
d723 1
d736 21
a756 3
      bfd_put_8 (abfd, value & 0xff, data + dst_address);
      dst_address += 1;
      src_address += 1;
d794 1
a794 1
    /* A 16bit absolute relocation that was formerly a 24/32bit
a797 1
      value = bfd_h8300_pad_address (abfd, value);
d800 1
a800 1
      if (value <= 0x7fff || value >= 0xffff8000u)
d807 1
a807 1
	  data[dst_address - 1] &= ~0x20;
d818 1
a818 1
	}
d915 2
a916 2
      /* Output the target.  */
      bfd_put_8 (abfd, gap, data + dst_address - 1);
d918 3
a920 3
      /* We don't advance dst_address -- the 8bit reloc is applied at
	 dst_address - 1, so the next insn should begin at dst_address.  */
      src_address += 2;
d922 1
a922 1
      break;
d1063 1
a1063 19
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->hash->creator != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->hash->creator->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;
a1102 1

d1112 2
a1113 2
	ftab = htab->funcvec_hash_table;
	h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1117 1
a1117 1
	   thing to do here.  */
d1131 15
a1145 22
	switch (bfd_get_mach (input_section->owner))
	  {
	  case bfd_mach_h8300:
	  case bfd_mach_h8300hn:
	  case bfd_mach_h8300sn:
	    bfd_put_16 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  case bfd_mach_h8300h:
	  case bfd_mach_h8300s:
	    bfd_put_32 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  default:
	    abort ();
	  }
d1178 4
a1181 2
static bfd_boolean
h8300_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
a1185 9
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->hash->creator != abfd->xvec)
    return TRUE;

  htab = h8300_coff_hash_table (info);
d1188 1
a1188 1
  if (!htab->vectors_sec)
d1195 2
a1196 1
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");
d1199 6
a1204 4
	 quit quickly now, rather than dying a painful death later.  */
      if (!htab->vectors_sec
	  || !bfd_set_section_flags (abfd, htab->vectors_sec, flags))
	return FALSE;
d1211 1
a1211 1
	return FALSE;
d1218 1
a1218 1
	  return FALSE;
d1222 1
a1222 1
      htab->funcvec_hash_table = funcvec_hash_table;
d1226 4
a1229 1
  funcvec_hash_table = htab->funcvec_hash_table;
d1246 1
a1246 1
	return FALSE;
d1294 2
a1295 2
	      ftab = htab->funcvec_hash_table;
	      h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1301 1
a1301 1
		  h = funcvec_hash_lookup (ftab, name, TRUE, TRUE);
d1305 1
a1305 1
		      return FALSE;
d1310 5
a1314 14
		  switch (bfd_get_mach (abfd))
		    {
		    case bfd_mach_h8300:
		    case bfd_mach_h8300hn:
		    case bfd_mach_h8300sn:
		      htab->vectors_sec->_raw_size += 2;
		      break;
		    case bfd_mach_h8300h:
		    case bfd_mach_h8300s:
		      htab->vectors_sec->_raw_size += 4;
		      break;
		    default:
		      abort ();
		    }
d1325 1
a1325 1
  sec = htab->vectors_sec;
d1336 1
a1336 1
  return TRUE;
d1353 1
a1353 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
@


1.12.20.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
a668 1
  unsigned char temp_code;
a949 4
      temp_code = data[src_address - 1];
      if ((temp_code & 0x10) != 0x10)
	temp_code &= 0xf0;

d951 1
a951 1
      switch (temp_code)
a958 6
	case 0x18:
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x10:
	  data[dst_address - 2] = 0x7e;
	  break;
a974 4
      temp_code = data[src_address - 1];
      if ((temp_code & 0x30) != 0x30)
	temp_code &= 0xf0;

d976 1
a976 1
      switch (temp_code)
a982 6
	  break;
	case 0x38:
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x30:
	  data[dst_address - 2] = 0x7e;
@


1.12.20.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d268 2
a269 2
  /* Internal reloc for relaxing.  This is created when a 16-bit pc-relative
     branch is turned into an 8-bit pc-relative branch.  */
d461 2
a462 2
      /* This is the 16-/24-bit absolute branch which could become an
	 8-bit pc-relative branch.  */
d550 1
a550 1
    /* This is the 16-bit pc-relative branch which could become an 8-bit
d578 2
a579 2
    /* This is a 16-bit absolute address in a mov.b insn, which can
       become an 8-bit absolute address if it's in the right range.  */
d598 3
a600 3
    /* Similarly for a 24-bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8-bit absolute, we'll fall through
       and try to relax it into a 16-bit absolute.  */
d619 1
a619 1
      /* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit
d622 2
a623 2
    /* This is a 24-/32-bit absolute address in a mov insn, which can
       become an 16-bit absolute address if it's in the right range.  */
d673 1
a673 1
    /* Generic 8-bit pc-relative relocation.  */
d703 1
a703 1
    /* Generic 16-bit pc-relative relocation.  */
d734 1
a734 1
    /* Generic 8-bit absolute relocation.  */
d746 1
a746 1
    /* Various simple 16-bit absolute relocations.  */
d756 1
a756 1
    /* Various simple 24-/32-bit absolute relocations.  */
d767 1
a767 1
    /* Another 24-/32-bit absolute relocation.  */
d779 2
a780 9
      /* This is a 24-/32-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.[bwl]"

	 We may relax this into an 16-bit absolute address if it's in
	 the right range.  */
d788 1
a788 1
	  /* Insert the 16-bit value into the proper location.  */
d791 2
a792 3
	  /* Fix the opcode.  For all the instructions that belong to
	     this relaxation, we simply need to turn off bit 0x20 in
	     the previous byte.  */
d807 1
a807 1
    /* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
d837 1
a837 1
	  /* jmp -> bra */
d845 1
a845 1
      /* Write out the 8-bit value.  */
d853 1
a853 1
    /* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
d880 1
a880 2
	  /* Get the second byte of the original insn, which contains
	     the condition code.  */
a881 4

	  /* Compute the fisrt byte of the relaxed instruction.  The
	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X
	     represents the condition code.  */
d884 2
d904 1
a904 1
      /* We don't advance dst_address -- the 8-bit reloc is applied at
d910 1
a910 1
    /* Similarly for a 24-bit absolute that is now 8 bits.  */
d943 1
a943 9
      /* This is a 16-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d947 1
a947 1
      /* All instructions with R_H8_DIR16B2 start with 0x6a.  */
a951 3

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
a958 1
	  /* This is mov.b @@aa:16,Rd.  */
a961 1
	  /* This is mov.b Rs,@@aa:16.  */
a964 3
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
a967 3
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
d978 1
a978 9
      /* This is a 24-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d982 1
a982 1
      /* All instructions with R_MOV24B2 start with 0x6a.  */
a986 3

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
a993 1
	  /* This is mov.b @@aa:24/32,Rd.  */
a996 1
	  /* This is mov.b Rs,@@aa:24/32.  */
a999 3
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
a1002 3
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
d1049 1
a1049 1
    /* An 8-bit memory indirect instruction (jmp/jsr).
@


1.12.8.1
log
@	Merge from mainline:
	2002-11-15  Kazu Hirata  <kazu@@cs.umass.edu>
	* coff-h8300.c (h8300_reloc16_estimate): Do not optimize away
	jsr after a short jump.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
@
text
@a487 7
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

d499 1
a499 15
	     common.

	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:

	     	             mov.w   r0,r0
	     	             beq     .L1
	           	     jsr     @@_bar
	              .L1:   rts
	              _bar:  rts
	     into:
	     	             mov.w   r0,r0
	     	             bne     _bar
	     	             rts
	     	      _bar:  rts
d501 1
a501 3
	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
@


1.12.8.2
log
@	* coff-h8300.c: Include libiberty.h.
	(h8300_reloc16_extra_cases): Check the hash table creator before
	referencing h8300 specific fields.  Stash the hash table pointer
	in a local var.  Comment typo fixes.
	(h8300_bfd_link_add_symbols): Likewise.
@
text
@a30 1
#include "libiberty.h"
d1086 1
a1086 19
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->hash->creator != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->hash->creator->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;
d1135 1
a1135 1
	ftab = htab->funcvec_hash_table;
d1140 1
a1140 1
	   thing to do here.  */
a1208 9
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->hash->creator != abfd->xvec)
    return true;

  htab = h8300_coff_hash_table (info);
d1211 1
a1211 1
  if (!htab->vectors_sec)
d1218 2
a1219 1
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");
d1222 5
a1226 3
	 quit quickly now, rather than dying a painful death later.  */
      if (! htab->vectors_sec
	  || ! bfd_set_section_flags (abfd, htab->vectors_sec, flags))
d1245 1
a1245 1
      htab->funcvec_hash_table = funcvec_hash_table;
d1249 4
a1252 1
  funcvec_hash_table = htab->funcvec_hash_table;
d1317 1
a1317 1
	      ftab = htab->funcvec_hash_table;
d1334 1
a1334 1
		    htab->vectors_sec->_raw_size += 2;
d1337 1
a1337 1
		    htab->vectors_sec->_raw_size += 4;
d1348 1
a1348 1
  sec = htab->vectors_sec;
@


1.12.18.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d90 2
a91 1
struct h8300_coff_link_hash_table {
d138 1
a138 1
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));
d168 2
a169 2
						struct bfd_hash_table *,
						const char *));
d235 2
a236 1
static reloc_howto_type howto_table[] = {
d273 1
a273 1
  { x.r_type = select_reloc (howto); }
d275 1
a275 1
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x))
d368 1
a368 1
#define RTYPE2HOWTO(internal, relocentry) rtype2howto (internal, relocentry)
d373 1
a373 1
 cache_ptr->addend = ext_reloc.r_offset;
d376 1
a376 1
 reloc_processing (relent, reloc, symbols, abfd, section)
d486 1
a486 1
      if ((int) gap >= -128 && (int) gap <= 128)
a487 7
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

d499 1
a499 1
	     common.
d501 1
a501 17
	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:
	     
	     	             mov.w   r0,r0
	     	             beq     .L1
	           	     jsr     @@_bar
	              .L1:   rts
	              _bar:  rts
	     into:
	     	             mov.w   r0,r0
	     	             bne     _bar
	     	             rts
	     	      _bar:  rts
	     
	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
d549 1
a549 1
      if ((int) gap >= -128 && (int) gap <= 128)
d739 1
a739 1
	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
d807 1
a807 1
	  data[dst_address - 1] &= ~0x20;
d818 1
a818 1
	}
d915 2
a916 2
      /* Output the target.  */
      bfd_put_8 (abfd, gap, data + dst_address - 1);
d918 3
a920 3
      /* We don't advance dst_address -- the 8bit reloc is applied at
	 dst_address - 1, so the next insn should begin at dst_address.  */
      src_address += 2;
d922 1
a922 1
      break;
@


1.12.18.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a30 1
#include "libiberty.h"
d65 1
a65 1
static bfd_boolean
d68 12
a79 22
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

static bfd_reloc_status_type special
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static int select_reloc
  PARAMS ((reloc_howto_type *));
static void rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
static bfd_boolean h8300_symbol_address_p
  PARAMS ((bfd *, asection *, bfd_vma));
static int h8300_reloc16_estimate
  PARAMS ((bfd *, asection *, arelent *, unsigned int,
    struct bfd_link_info *));
static void h8300_reloc16_extra_cases
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
    bfd_byte *, unsigned int *, unsigned int *));
static bfd_boolean h8300_bfd_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
d130 2
a131 2
	   bfd_hash_allocate (gen_table,
			      sizeof (struct funcvec_hash_entry)));
d162 1
a162 1
static bfd_boolean
d166 3
a168 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d178 1
a178 1
   basically to hold "static" information during an H8/300 coff link
d235 14
a248 14
  HOWTO (R_RELBYTE, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_RELWORD, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_RELLONG, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "32", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_PCRBYTE, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8", FALSE, 0x000000ff, 0x000000ff, TRUE),
  HOWTO (R_PCRWORD, 0, 1, 16, TRUE, 0, complain_overflow_signed, special, "DISP16", FALSE, 0x0000ffff, 0x0000ffff, TRUE),
  HOWTO (R_PCRLONG, 0, 2, 32, TRUE, 0, complain_overflow_signed, special, "DISP32", FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO (R_MOV16B1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_MOV16B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMP1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16/pcrel", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_JMP2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pcrecl/16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMPL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "24/pcrell", FALSE, 0x00ffffff, 0x00ffffff, FALSE),
  HOWTO (R_JMPL2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pc8/24", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_MOV24B1, 0, 1, 32, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_MOV24B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d253 1
a253 1
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8/indirect", FALSE, 0x000000ff, 0x000000ff, FALSE),
d257 1
a257 1
  HOWTO (R_PCRWORD_B, 0, 0, 8, TRUE, 0, complain_overflow_bitfield, special, "relaxed bCC:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
d259 1
a259 1
  HOWTO (R_MOVL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,special, "32/24 relaxable move", FALSE, 0xffffffff, 0xffffffff, FALSE),
d261 1
a261 1
  HOWTO (R_MOVL2, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "32/24 relaxed move", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d263 1
a263 1
  HOWTO (R_BCC_INV, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8 inverted", FALSE, 0x000000ff, 0x000000ff, TRUE),
d265 1
a265 1
  HOWTO (R_JMP_DEL, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "Deleted jump", FALSE, 0x000000ff, 0x000000ff, TRUE),
d404 1
a404 1
static bfd_boolean
d424 1
a424 1
	return TRUE;
d427 1
a427 1
  return FALSE;
d508 6
a513 6

			     mov.w   r0,r0
			     beq     .L1
			     jsr     @@_bar
		      .L1:   rts
		      _bar:  rts
d515 5
a519 5
			     mov.w   r0,r0
			     bne     _bar
			     rts
		      _bar:  rts

d557 1
a557 1
	 because the addend field in PCrel jumps is off by -1.  */
d642 1
a642 1
	 0xff8000..0xffffff inclusive, then it can be relaxed.  */
d1084 1
a1084 19
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->hash->creator != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->hash->creator->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;
d1133 2
a1134 2
	ftab = htab->funcvec_hash_table;
	h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1138 1
a1138 1
	   thing to do here.  */
d1199 1
a1199 1
static bfd_boolean
a1206 9
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->hash->creator != abfd->xvec)
    return TRUE;

  htab = h8300_coff_hash_table (info);
d1209 1
a1209 1
  if (!htab->vectors_sec)
d1216 2
a1217 1
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");
d1220 6
a1225 4
	 quit quickly now, rather than dying a painful death later.  */
      if (!htab->vectors_sec
	  || !bfd_set_section_flags (abfd, htab->vectors_sec, flags))
	return FALSE;
d1232 1
a1232 1
	return FALSE;
d1239 1
a1239 1
	  return FALSE;
d1243 1
a1243 1
      htab->funcvec_hash_table = funcvec_hash_table;
d1247 4
a1250 1
  funcvec_hash_table = htab->funcvec_hash_table;
d1267 1
a1267 1
	return FALSE;
d1315 2
a1316 2
	      ftab = htab->funcvec_hash_table;
	      h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1322 1
a1322 1
		  h = funcvec_hash_lookup (ftab, name, TRUE, TRUE);
d1326 1
a1326 1
		      return FALSE;
d1332 1
a1332 1
		    htab->vectors_sec->_raw_size += 2;
d1335 1
a1335 1
		    htab->vectors_sec->_raw_size += 4;
d1346 1
a1346 1
  sec = htab->vectors_sec;
d1357 1
a1357 1
  return TRUE;
@


1.12.18.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d213 1
a213 1
  /* OK.  Everything's initialized, return the base pointer.  */
d399 3
a401 1
    relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
d403 3
a405 1
    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
a430 1

d475 2
a476 2
      /* This is the 16/24 bit absolute branch which could become an 8 bit
	 pc-relative branch.  */
d723 1
d755 1
d776 1
@


1.12.18.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 1
a1 1
/* BFD back-end for Renesas H8/300 COFF binaries.
@


1.12.18.5
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d284 2
a285 3
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
@


1.12.18.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1401 1
a1401 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
@


1.12.18.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d64 1
a64 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d68 4
a71 4
  (struct funcvec_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));
d74 1
a74 1
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
d76 1
a76 1
  (reloc_howto_type *);
d78 1
a78 1
  (arelent *, struct internal_reloc *);
d80 1
a80 1
  (arelent *, struct internal_reloc *, asymbol **, bfd *, asection *);
d82 1
a82 1
  (bfd *, asection *, bfd_vma);
d84 2
a85 2
  (bfd *, asection *, arelent *, unsigned int,
   struct bfd_link_info *);
d87 2
a88 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
   bfd_byte *, unsigned int *, unsigned int *);
d90 1
a90 1
  (bfd *, struct bfd_link_info *);
d114 2
a115 1
static struct bfd_link_hash_table *h8300_coff_link_hash_table_create (bfd *);
d126 4
a129 3
funcvec_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *gen_table,
		      const char *string)
d174 6
a179 6
funcvec_hash_table_init (struct funcvec_hash_table *table,
			 bfd *abfd,
			 struct bfd_hash_entry *(*newfunc)
			   (struct bfd_hash_entry *,
			    struct bfd_hash_table *,
			    const char *))
d193 2
a194 1
h8300_coff_link_hash_table_create (bfd *abfd)
d227 9
a235 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d297 2
a298 1
select_reloc (reloc_howto_type *howto)
d306 3
a308 1
rtype2howto (arelent *internal, struct internal_reloc *dst)
d389 6
a394 2
reloc_processing (arelent *relent, struct internal_reloc *reloc,
		  asymbol **symbols, bfd *abfd, asection *section)
d413 4
a416 1
h8300_symbol_address_p (bfd *abfd, asection *input_section, bfd_vma address)
d448 6
a453 2
h8300_reloc16_estimate (bfd *abfd, asection *input_section, arelent *reloc,
			unsigned int shrink, struct bfd_link_info *link_info)
a594 1
      value = bfd_h8300_pad_address (abfd, value);
d596 10
a605 3
      /* If the address is in the top 256 bytes of the address space
	 then we can relax this instruction.  */
      if (value >= 0xffffff00u)
a621 1
      value = bfd_h8300_pad_address (abfd, value);
d623 6
a628 1
      if (value >= 0xffffff00u)
a648 1
      value = bfd_h8300_pad_address (abfd, value);
d650 3
a652 3
      /* If the address is a sign-extended 16-bit value then we can
         relax this instruction.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
d679 9
a687 4
h8300_reloc16_extra_cases (bfd *abfd, struct bfd_link_info *link_info,
			   struct bfd_link_order *link_order, arelent *reloc,
			   bfd_byte *data, unsigned int *src_ptr,
			   unsigned int *dst_ptr)
d764 20
a783 3
      bfd_put_8 (abfd, value & 0xff, data + dst_address);
      dst_address += 1;
      src_address += 1;
a824 1
      value = bfd_h8300_pad_address (abfd, value);
d827 1
a827 1
      if (value <= 0x7fff || value >= 0xffff8000u)
d1224 3
a1226 1
h8300_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
@


1.12.18.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d157 7
a163 14
 switch (bfd_get_mach (table->abfd))
   {
   case bfd_mach_h8300:
   case bfd_mach_h8300hn:
   case bfd_mach_h8300sn:
     table->offset += 2;
     break;
   case bfd_mach_h8300h:
   case bfd_mach_h8300s:
     table->offset += 4;
     break;
   default:
     return NULL;
   }
a1098 1

d1127 15
a1141 22
	switch (bfd_get_mach (input_section->owner))
	  {
	  case bfd_mach_h8300:
	  case bfd_mach_h8300hn:
	  case bfd_mach_h8300sn:
	    bfd_put_16 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  case bfd_mach_h8300h:
	  case bfd_mach_h8300s:
	    bfd_put_32 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  default:
	    abort ();
	  }
d1307 5
a1311 14
		  switch (bfd_get_mach (abfd))
		    {
		    case bfd_mach_h8300:
		    case bfd_mach_h8300hn:
		    case bfd_mach_h8300sn:
		      htab->vectors_sec->_raw_size += 2;
		      break;
		    case bfd_mach_h8300h:
		    case bfd_mach_h8300s:
		      htab->vectors_sec->_raw_size += 4;
		      break;
		    default:
		      abort ();
		    }
@


1.12.18.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d778 1
a778 1
    /* A 16bit absolute relocation that was formerly a 24/32bit
@


1.12.18.10
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d268 2
a269 2
  /* Internal reloc for relaxing.  This is created when a 16-bit pc-relative
     branch is turned into an 8-bit pc-relative branch.  */
d461 2
a462 2
      /* This is the 16-/24-bit absolute branch which could become an
	 8-bit pc-relative branch.  */
d550 1
a550 1
    /* This is the 16-bit pc-relative branch which could become an 8-bit
d578 2
a579 2
    /* This is a 16-bit absolute address in a mov.b insn, which can
       become an 8-bit absolute address if it's in the right range.  */
d598 3
a600 3
    /* Similarly for a 24-bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8-bit absolute, we'll fall through
       and try to relax it into a 16-bit absolute.  */
d619 1
a619 1
      /* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit
d622 2
a623 2
    /* This is a 24-/32-bit absolute address in a mov insn, which can
       become an 16-bit absolute address if it's in the right range.  */
a668 1
  unsigned char temp_code;
d672 1
a672 1
    /* Generic 8-bit pc-relative relocation.  */
d702 1
a702 1
    /* Generic 16-bit pc-relative relocation.  */
d733 1
a733 1
    /* Generic 8-bit absolute relocation.  */
d745 1
a745 1
    /* Various simple 16-bit absolute relocations.  */
d755 1
a755 1
    /* Various simple 24-/32-bit absolute relocations.  */
d766 1
a766 1
    /* Another 24-/32-bit absolute relocation.  */
d778 2
a779 9
      /* This is a 24-/32-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.[bwl]"

	 We may relax this into an 16-bit absolute address if it's in
	 the right range.  */
d787 1
a787 1
	  /* Insert the 16-bit value into the proper location.  */
d790 2
a791 3
	  /* Fix the opcode.  For all the instructions that belong to
	     this relaxation, we simply need to turn off bit 0x20 in
	     the previous byte.  */
d806 1
a806 1
    /* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
d836 1
a836 1
	  /* jmp -> bra */
d844 1
a844 1
      /* Write out the 8-bit value.  */
d852 1
a852 1
    /* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
d879 1
a879 2
	  /* Get the second byte of the original insn, which contains
	     the condition code.  */
a880 4

	  /* Compute the fisrt byte of the relaxed instruction.  The
	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X
	     represents the condition code.  */
d883 2
d903 1
a903 1
      /* We don't advance dst_address -- the 8-bit reloc is applied at
d909 1
a909 1
    /* Similarly for a 24-bit absolute that is now 8 bits.  */
d942 1
a942 9
      /* This is a 16-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d946 1
a946 1
      /* All instructions with R_H8_DIR16B2 start with 0x6a.  */
a949 7
      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x10) != 0x10)
	temp_code &= 0xf0;

d951 1
a951 1
      switch (temp_code)
a953 1
	  /* This is mov.b @@aa:16,Rd.  */
a956 1
	  /* This is mov.b Rs,@@aa:16.  */
a958 12
	case 0x18:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x10:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
d967 1
a967 9
      /* This is a 24-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d971 1
a971 1
      /* All instructions with R_MOV24B2 start with 0x6a.  */
a974 7
      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x30) != 0x30)
	temp_code &= 0xf0;

d976 1
a976 1
      switch (temp_code)
a978 1
	  /* This is mov.b @@aa:24/32,Rd.  */
a981 1
	  /* This is mov.b Rs,@@aa:24/32.  */
a983 12
	case 0x38:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x30:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
d1028 1
a1028 1
    /* An 8-bit memory indirect instruction (jmp/jsr).
@


1.11
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3 1
a3 1
   2000, 2001
d189 1
a189 1
  ret = (struct h8300_coff_link_hash_table *) bfd_alloc (abfd, amt);
d195 1
a195 1
      bfd_release (abfd, ret);
@


1.10
log
@Add more missing prototypes
@
text
@d187 3
a189 2
  ret = ((struct h8300_coff_link_hash_table *)
         bfd_alloc (abfd, sizeof (struct h8300_coff_link_hash_table)));
d192 2
a193 1
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd, _bfd_generic_link_hash_newfunc))
d280 2
a281 2
#define SWAP_IN_RELOC_OFFSET   bfd_h_get_32
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_32
d724 1
a724 1
      bfd_put_16 (abfd, gap, data + dst_address);
a1059 1
	bfd_vma value;
d1061 1
d1102 1
a1102 1
	    char *new_name = bfd_malloc (strlen (name) + 9);
d1112 2
a1113 2
	h = funcvec_hash_lookup (h8300_coff_hash_table (link_info)->funcvec_hash_table,
				 name, false, false);
d1152 1
a1152 1
				  vectors_sec->output_offset,
d1185 1
d1207 2
a1208 2
      funcvec_hash_table = ((struct funcvec_hash_table *)
	bfd_alloc (abfd, sizeof (struct funcvec_hash_table)));
d1244 1
a1244 1
      relocs = (arelent **) bfd_malloc ((size_t) reloc_size);
d1275 1
d1281 1
a1281 1
		  char *new_name = bfd_malloc (strlen (name) + 9);
d1283 1
d1294 2
a1295 2
	      h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
				       name, false, false);
d1301 1
a1301 2
		  h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
					   name, true, true);
d1325 2
a1326 1
  if (h8300_coff_hash_table (info)->vectors_sec->_raw_size != 0)
d1329 2
a1330 2
      if (h8300_coff_hash_table (info)->vectors_sec->contents)
	free (h8300_coff_hash_table (info)->vectors_sec->contents);
d1333 1
a1333 2
      h8300_coff_hash_table (info)->vectors_sec->contents
	= bfd_malloc (h8300_coff_hash_table (info)->vectors_sec->_raw_size);
@


1.9
log
@Update copyright notices
@
text
@d3 1
a3 1
   2000
d41 8
a48 8
{
  /* The basic hash table entry.  */
  struct bfd_hash_entry root;

  /* The offset within the vectors section where
     this entry lives.  */
  bfd_vma offset;
};
d51 9
a59 9
{
  /* The basic hash table.  */
  struct bfd_hash_table root;

  bfd *abfd;

  /* Offset at which we'll add the next entry.  */
  unsigned int offset;
};
d71 9
@


1.8
log
@2000-11-10  Kazu Hirata  <kazu@@hxi.com>

	* coff-h8300.c: Fix formatting.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
@


1.7
log
@Fix for H8 ld problem.
@
text
@d34 1
a34 1
   hold entries in the function vector.  Aside from the 
d199 1
a199 1
   the pcrel branches.  This isn't so, since the H8/300 can do relaxing, 
d442 1
a442 1
  /* The address of the thing to be relocated will have moved back by 
d453 1
a453 1
    {     
d475 1
a475 1
	{ 
d485 1
a485 1
	
d538 1
a538 1
	{ 
d693 2
a694 2
      dot = (link_order->offset 
	     + dst_address 
d911 1
a911 1
      
d1082 1
a1082 1
	   expected to create the function vector ourselves. 
a1280 1

@


1.6
log
@Fix formatting.
@
text
@d201 1
a201 1
   contain the offset required for the branch, so we have to use the only
d218 2
d893 1
@


1.5
log
@        * coff-h8300.c (h8300_reloc16_extra_cases): Add bsr:16 -> bsr:8 to
        the R_PCRWORD_B case.
@
text
@d195 1
a195 1
/* special handling for H8/300 relocs.
d202 1
a202 1
   the addend until the final link */
d206 1
a206 1
		 error_message)
d256 1
a256 2

/* Turn a howto into a reloc number */
d265 1
a265 3


/* Code to swap in the reloc */
a271 1

d279 1
a279 2
/* Code to turn a r_type into a howto ptr, uses the above howto table
   */
d356 1
a356 3

/* Perform any necessary magic to the addend in a reloc entry */

a360 1

d366 1
a366 1
     arelent * relent;
d368 3
a370 3
     asymbol ** symbols;
     bfd * abfd;
     asection * section;
a383 2


d387 3
a389 1
  /*  relent->section = 0;*/
d405 1
a405 1
  while (*s) 
d414 1
a414 1
    }    
a417 1

d427 1
a427 1
h8300_reloc16_estimate(abfd, input_section, reloc, shrink, link_info)
d434 1
a434 1
  bfd_vma value;  
a451 1

d457 1
a457 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d468 1
a468 1
  
a473 1

d497 1
a497 1
		  && ! h8300_symbol_address_p (abfd, input_section, dot - 2))
d510 1
a510 1
	  reloc->howto = reloc->howto + 1;	  
d514 1
a514 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d523 2
a524 2
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section) + 1;
	
d528 1
a528 1
  
d542 1
a542 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d550 1
a550 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d568 1
a568 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d577 1
a577 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d591 1
a591 1
	  bfd_perform_slip(abfd, 4, input_section, address);
d604 1
a604 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d615 1
a615 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d620 2
a621 2
      default:
	break;
a628 1

d650 1
a650 1
  int gap,tmp;
a653 1

d657 1
a657 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d659 2
a660 2
      dot = (link_order->offset 
	     + dst_address 
d688 1
a688 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d751 1
a751 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d762 1
a762 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section),
d951 1
a951 1
      switch (data[src_address-1] & 0xf0)
d954 1
a954 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
d957 1
a957 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
d976 1
a976 1
      switch (data[src_address-1] & 0xf0)
d979 1
a979 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
d982 1
a982 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
d994 1
a994 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d996 2
a997 2
      dot = (link_order->offset 
	     + dst_address 
d1093 1
a1093 1
		     (int)symbol->section);
a1151 1

d1164 1
a1164 1
h8300_bfd_link_add_symbols(abfd, info)
d1228 1
a1228 1
      relocs = (arelent **)bfd_malloc ((size_t)reloc_size);
d1271 1
a1271 1
			   (int)symbol->section);
a1330 1

a1335 1

@


1.4
log
@        * coff-h8300.c (h8300_reloc16_extra_cases): Fix the sanity
        check for R_MOVL2.
@
text
@d904 4
@


1.4.2.1
log
@H8 ld -r fix, and trunk 2000-04-03 patch.
@
text
@d195 1
a195 1
/* Special handling for H8/300 relocs.
d201 2
a202 2
   contain the offset required for the branch, so we have to use only
   the addend until the final link.  */
d206 1
a206 1
	 error_message)
a217 2
  /* Adjust the reloc address to that in the output section.  */
  reloc_entry->address += input_section->output_offset;
a902 5
	  break;

	case 0x5c:
	  /* bsr:16 -> bsr:8 */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 2);
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d799 1
a799 1
      if (value < 0x8000 || value > 0xff8000)
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d1349 1
a1349 41

const bfd_target h8300coff_vec =
{
  "coff-h8300",			/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE ),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  '_',				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {_bfd_dummy_target, coff_object_p,	/* bfd_check_format */
   bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive,	/* bfd_set_format */
   bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE,
};
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d207 5
a211 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d213 1
a213 1
     char **error_message;
d1064 1
a1064 1
	    || (value >= 0 && value <= 0xff))
d1070 1
a1070 1
	    if (value >= 0 && value <= 0xff)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

