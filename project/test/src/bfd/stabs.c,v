head	1.33;
access;
symbols
	sid-snapshot-20180601:1.33
	sid-snapshot-20180501:1.33
	sid-snapshot-20180401:1.33
	sid-snapshot-20180301:1.33
	sid-snapshot-20180201:1.33
	sid-snapshot-20180101:1.33
	sid-snapshot-20171201:1.33
	sid-snapshot-20171101:1.33
	sid-snapshot-20171001:1.33
	sid-snapshot-20170901:1.33
	sid-snapshot-20170801:1.33
	sid-snapshot-20170701:1.33
	sid-snapshot-20170601:1.33
	sid-snapshot-20170501:1.33
	sid-snapshot-20170401:1.33
	sid-snapshot-20170301:1.33
	sid-snapshot-20170201:1.33
	sid-snapshot-20170101:1.33
	sid-snapshot-20161201:1.33
	sid-snapshot-20161101:1.33
	sid-snapshot-20160901:1.33
	sid-snapshot-20160801:1.33
	sid-snapshot-20160701:1.33
	sid-snapshot-20160601:1.33
	sid-snapshot-20160501:1.33
	sid-snapshot-20160401:1.33
	sid-snapshot-20160301:1.33
	sid-snapshot-20160201:1.33
	sid-snapshot-20160101:1.33
	sid-snapshot-20151201:1.33
	sid-snapshot-20151101:1.33
	sid-snapshot-20151001:1.33
	sid-snapshot-20150901:1.33
	sid-snapshot-20150801:1.33
	sid-snapshot-20150701:1.33
	sid-snapshot-20150601:1.33
	sid-snapshot-20150501:1.33
	sid-snapshot-20150401:1.33
	sid-snapshot-20150301:1.33
	sid-snapshot-20150201:1.33
	sid-snapshot-20150101:1.33
	sid-snapshot-20141201:1.33
	sid-snapshot-20141101:1.33
	sid-snapshot-20141001:1.33
	sid-snapshot-20140901:1.33
	sid-snapshot-20140801:1.33
	sid-snapshot-20140701:1.33
	sid-snapshot-20140601:1.33
	sid-snapshot-20140501:1.33
	sid-snapshot-20140401:1.33
	sid-snapshot-20140301:1.33
	sid-snapshot-20140201:1.33
	sid-snapshot-20140101:1.33
	sid-snapshot-20131201:1.33
	sid-snapshot-20131101:1.33
	sid-snapshot-20131001:1.33
	binutils-2_24-branch:1.33.0.24
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.33
	sid-snapshot-20130901:1.33
	gdb_7_6_1-2013-08-30-release:1.33
	sid-snapshot-20130801:1.33
	sid-snapshot-20130701:1.33
	sid-snapshot-20130601:1.33
	sid-snapshot-20130501:1.33
	gdb_7_6-2013-04-26-release:1.33
	sid-snapshot-20130401:1.33
	binutils-2_23_2:1.33
	gdb_7_6-branch:1.33.0.22
	gdb_7_6-2013-03-12-branchpoint:1.33
	sid-snapshot-20130301:1.33
	sid-snapshot-20130201:1.33
	sid-snapshot-20130101:1.33
	sid-snapshot-20121201:1.33
	gdb_7_5_1-2012-11-29-release:1.33
	binutils-2_23_1:1.33
	sid-snapshot-20121101:1.33
	binutils-2_23:1.33
	sid-snapshot-20121001:1.33
	sid-snapshot-20120901:1.33
	gdb_7_5-2012-08-17-release:1.33
	sid-snapshot-20120801:1.33
	binutils-2_23-branch:1.33.0.20
	binutils-2_23-branchpoint:1.33
	gdb_7_5-branch:1.33.0.18
	gdb_7_5-2012-07-18-branchpoint:1.33
	sid-snapshot-20120701:1.33
	sid-snapshot-20120601:1.33
	sid-snapshot-20120501:1.33
	binutils-2_22_branch:1.33.0.16
	gdb_7_4_1-2012-04-26-release:1.33
	sid-snapshot-20120401:1.33
	sid-snapshot-20120301:1.33
	sid-snapshot-20120201:1.33
	gdb_7_4-2012-01-24-release:1.33
	sid-snapshot-20120101:1.33
	gdb_7_4-branch:1.33.0.14
	gdb_7_4-2011-12-13-branchpoint:1.33
	sid-snapshot-20111201:1.33
	binutils-2_22:1.33
	sid-snapshot-20111101:1.33
	sid-snapshot-20111001:1.33
	binutils-2_22-branch:1.33.0.12
	binutils-2_22-branchpoint:1.33
	gdb_7_3_1-2011-09-04-release:1.33
	sid-snapshot-20110901:1.33
	sid-snapshot-20110801:1.33
	gdb_7_3-2011-07-26-release:1.33
	sid-snapshot-20110701:1.33
	sid-snapshot-20110601:1.33
	sid-snapshot-20110501:1.33
	gdb_7_3-branch:1.33.0.10
	gdb_7_3-2011-04-01-branchpoint:1.33
	sid-snapshot-20110401:1.33
	sid-snapshot-20110301:1.33
	sid-snapshot-20110201:1.33
	sid-snapshot-20110101:1.33
	binutils-2_21:1.33
	sid-snapshot-20101201:1.33
	binutils-2_21-branch:1.33.0.8
	binutils-2_21-branchpoint:1.33
	sid-snapshot-20101101:1.33
	sid-snapshot-20101001:1.33
	binutils-2_20_1:1.32.2.1
	gdb_7_2-2010-09-02-release:1.33
	sid-snapshot-20100901:1.33
	sid-snapshot-20100801:1.33
	gdb_7_2-branch:1.33.0.6
	gdb_7_2-2010-07-07-branchpoint:1.33
	sid-snapshot-20100701:1.33
	sid-snapshot-20100601:1.33
	sid-snapshot-20100501:1.33
	sid-snapshot-20100401:1.33
	gdb_7_1-2010-03-18-release:1.33
	sid-snapshot-20100301:1.33
	gdb_7_1-branch:1.33.0.4
	gdb_7_1-2010-02-18-branchpoint:1.33
	sid-snapshot-20100201:1.33
	sid-snapshot-20100101:1.33
	gdb_7_0_1-2009-12-22-release:1.33
	sid-snapshot-20091201:1.33
	sid-snapshot-20091101:1.33
	binutils-2_20:1.32.2.1
	gdb_7_0-2009-10-06-release:1.33
	sid-snapshot-20091001:1.33
	gdb_7_0-branch:1.33.0.2
	gdb_7_0-2009-09-16-branchpoint:1.33
	arc-sim-20090309:1.31
	binutils-arc-20081103-branch:1.31.0.26
	binutils-arc-20081103-branchpoint:1.31
	binutils-2_20-branch:1.32.0.2
	binutils-2_20-branchpoint:1.32
	sid-snapshot-20090901:1.31
	sid-snapshot-20090801:1.31
	msnyder-checkpoint-072509-branch:1.31.0.24
	msnyder-checkpoint-072509-branchpoint:1.31
	sid-snapshot-20090701:1.31
	dje-cgen-play1-branch:1.31.0.22
	dje-cgen-play1-branchpoint:1.31
	sid-snapshot-20090601:1.31
	sid-snapshot-20090501:1.31
	sid-snapshot-20090401:1.31
	arc-20081103-branch:1.31.0.20
	arc-20081103-branchpoint:1.31
	arc-insight_6_8-branch:1.31.0.18
	arc-insight_6_8-branchpoint:1.31
	insight_6_8-branch:1.31.0.16
	insight_6_8-branchpoint:1.31
	sid-snapshot-20090301:1.31
	binutils-2_19_1:1.31
	sid-snapshot-20090201:1.31
	sid-snapshot-20090101:1.31
	reverse-20081226-branch:1.31.0.14
	reverse-20081226-branchpoint:1.31
	sid-snapshot-20081201:1.31
	multiprocess-20081120-branch:1.31.0.12
	multiprocess-20081120-branchpoint:1.31
	sid-snapshot-20081101:1.31
	binutils-2_19:1.31
	sid-snapshot-20081001:1.31
	reverse-20080930-branch:1.31.0.10
	reverse-20080930-branchpoint:1.31
	binutils-2_19-branch:1.31.0.8
	binutils-2_19-branchpoint:1.31
	sid-snapshot-20080901:1.31
	sid-snapshot-20080801:1.31
	reverse-20080717-branch:1.31.0.6
	reverse-20080717-branchpoint:1.31
	sid-snapshot-20080701:1.31
	msnyder-reverse-20080609-branch:1.31.0.4
	msnyder-reverse-20080609-branchpoint:1.31
	drow-reverse-20070409-branch:1.28.0.4
	drow-reverse-20070409-branchpoint:1.28
	sid-snapshot-20080601:1.31
	sid-snapshot-20080501:1.31
	sid-snapshot-20080403:1.31
	sid-snapshot-20080401:1.31
	gdb_6_8-2008-03-27-release:1.31
	sid-snapshot-20080301:1.31
	gdb_6_8-branch:1.31.0.2
	gdb_6_8-2008-02-26-branchpoint:1.31
	sid-snapshot-20080201:1.30
	sid-snapshot-20080101:1.30
	sid-snapshot-20071201:1.30
	sid-snapshot-20071101:1.30
	gdb_6_7_1-2007-10-29-release:1.30
	gdb_6_7-2007-10-10-release:1.30
	sid-snapshot-20071001:1.30
	gdb_6_7-branch:1.30.0.4
	gdb_6_7-2007-09-07-branchpoint:1.30
	binutils-2_18:1.30
	binutils-2_18-branch:1.30.0.2
	binutils-2_18-branchpoint:1.30
	insight_6_6-20070208-release:1.28
	binutils-csl-coldfire-4_1-32:1.26
	binutils-csl-sourcerygxx-4_1-32:1.26
	gdb_6_6-2006-12-18-release:1.28
	binutils-csl-innovasic-fido-3_4_4-33:1.26
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.26
	binutils-csl-sourcerygxx-4_1-30:1.26
	binutils-csl-coldfire-4_1-28:1.26
	binutils-csl-sourcerygxx-4_1-29:1.26
	binutils-csl-sourcerygxx-4_1-28:1.26
	gdb_6_6-branch:1.28.0.2
	gdb_6_6-2006-11-15-branchpoint:1.28
	binutils-csl-arm-2006q3-27:1.26
	binutils-csl-sourcerygxx-4_1-27:1.26
	binutils-csl-arm-2006q3-26:1.26
	binutils-csl-sourcerygxx-4_1-26:1.26
	binutils-csl-sourcerygxx-4_1-25:1.26
	binutils-csl-sourcerygxx-4_1-24:1.26
	binutils-csl-sourcerygxx-4_1-23:1.26
	insight_6_5-20061003-release:1.26
	gdb-csl-symbian-6_4_50_20060226-12:1.25
	binutils-csl-sourcerygxx-4_1-21:1.26
	binutils-csl-arm-2006q3-21:1.26
	binutils-csl-sourcerygxx-4_1-22:1.26
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.26
	binutils-csl-sourcerygxx-4_1-20:1.26
	binutils-csl-arm-2006q3-19:1.26
	binutils-csl-sourcerygxx-4_1-19:1.26
	binutils-csl-sourcerygxx-4_1-18:1.26
	binutils-csl-renesas-4_1-9:1.26
	gdb-csl-sourcerygxx-3_4_4-25:1.24
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	nickrob-async-20060828-mergepoint:1.27
	gdb-csl-symbian-6_4_50_20060226-11:1.25
	binutils-csl-renesas-4_1-8:1.26
	binutils-csl-renesas-4_1-7:1.26
	binutils-csl-renesas-4_1-6:1.26
	gdb-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-17:1.26
	gdb-csl-20060226-branch-local-2:1.25
	gdb-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-14:1.26
	binutils-csl-sourcerygxx-4_1-15:1.26
	gdb-csl-sourcerygxx-4_1-13:1.25
	binutils-csl-sourcerygxx-4_1-13:1.26
	binutils-2_17:1.26
	gdb-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-4_1-12:1.26
	gdb-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.26
	gdb_6_5-20060621-release:1.26
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	gdb-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-9:1.26
	gdb-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-8:1.26
	gdb-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-sourcerygxx-4_1-7:1.26
	gdb-csl-arm-2006q1-6:1.25
	binutils-csl-arm-2006q1-6:1.26
	gdb-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.26
	binutils-csl-wrs-linux-3_4_4-22:1.21
	gdb-csl-symbian-6_4_50_20060226-10:1.25
	gdb-csl-symbian-6_4_50_20060226-9:1.25
	gdb-csl-symbian-6_4_50_20060226-8:1.25
	gdb-csl-coldfire-4_1-11:1.25
	binutils-csl-coldfire-4_1-11:1.26
	gdb-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.26
	gdb-csl-coldfire-4_1-10:1.25
	gdb_6_5-branch:1.26.0.14
	gdb_6_5-2006-05-14-branchpoint:1.26
	binutils-csl-coldfire-4_1-10:1.26
	gdb-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-5:1.26
	nickrob-async-20060513-branch:1.26.0.12
	nickrob-async-20060513-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-sourcerygxx-4_1-4:1.26
	msnyder-reverse-20060502-branch:1.26.0.10
	msnyder-reverse-20060502-branchpoint:1.26
	binutils-csl-wrs-linux-3_4_4-21:1.21
	gdb-csl-morpho-4_1-4:1.25
	binutils-csl-morpho-4_1-4:1.26
	gdb-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.26
	binutils-csl-wrs-linux-3_4_4-20:1.21
	readline_5_1-import-branch:1.26.0.8
	readline_5_1-import-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.25
	binutils-2_17-branch:1.26.0.6
	binutils-2_17-branchpoint:1.26
	gdb-csl-symbian-20060226-branch:1.25.0.6
	gdb-csl-symbian-20060226-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.25
	msnyder-reverse-20060331-branch:1.26.0.4
	msnyder-reverse-20060331-branchpoint:1.26
	binutils-csl-2_17-branch:1.26.0.2
	binutils-csl-2_17-branchpoint:1.26
	gdb-csl-available-20060303-branch:1.25.0.4
	gdb-csl-available-20060303-branchpoint:1.25
	gdb-csl-20060226-branch:1.25.0.2
	gdb-csl-20060226-branchpoint:1.25
	gdb_6_4-20051202-release:1.24
	msnyder-fork-checkpoint-branch:1.24.0.10
	msnyder-fork-checkpoint-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.24.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.24
	gdb_6_4-branch:1.24.0.6
	gdb_6_4-2005-11-01-branchpoint:1.24
	gdb-csl-arm-20051020-branch:1.24.0.4
	gdb-csl-arm-20051020-branchpoint:1.24
	binutils-csl-gxxpro-3_4-branch:1.21.0.10
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	msnyder-tracepoint-checkpoint-branch:1.24.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	gdb-csl-arm-20050325-2005-q1a:1.21
	binutils-csl-arm-2005q1a:1.21
	csl-arm-20050325-branch:1.21.0.8
	csl-arm-20050325-branchpoint:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.6
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.4
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.21
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.2
	gdb_6_3-20041019-branchpoint:1.21
	csl-arm-2004-q3:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.20.0.6
	jimb-gdb_6_2-e500-branchpoint:1.20
	gdb_6_2-20040730-release:1.20
	gdb_6_2-branch:1.20.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.20
	gdb_6_1_1-20040616-release:1.15
	binutils-2_15:1.15.6.1
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.18
	csl-arm-2004-q1:1.18
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.14
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.12
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.8
	drow_intercu-20040221-branchpoint:1.15
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	csl-arm-2003-q4:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.14
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.42
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.40
	cagney_x86i386-20030821-branch:1.12.0.38
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.36
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.12
	binutils-2_14:1.12
	cagney_convert-20030606-branch:1.12.0.32
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.30
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.26
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.12
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.22
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.20
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.18
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.16
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.14
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.12
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.10
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.8
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.6
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10.2.1
	binutils-2_13_2:1.10.2.1
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10.2.1
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.33
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2008.02.20.17.42.36;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.27.03.22.08;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.29.10.29.23;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.04.15.53.39;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.04.07.19.36;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.11.08.23.04;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.13.03.16.00;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.28.13.57.58;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.01.08.40.05;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.31.09.27.40;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.31.08.45.00;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.25.11.59.57;	author nickc;	state Exp;
branches
	1.15.6.1
	1.15.8.1;
next	1.14;

1.14
date	2003.11.04.11.30.54;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.07.08.53.41;	author nathan;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.06.09.24.56;	author rsandifo;	state Exp;
branches
	1.10.2.1
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2001.11.26.19.31.27;	author law;	state Exp;
branches
	1.9.8.1
	1.9.10.1;
next	1.8;

1.8
date	2001.11.15.01.34.11;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.05.33.13;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.20.00.21.57;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.10.28.03.52.01;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.19.49.45;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.32.2.1
date	2009.09.09.21.40.20;	author nickc;	state Exp;
branches;
next	;

1.15.6.1
date	2004.04.09.18.28.03;	author drow;	state Exp;
branches;
next	;

1.15.8.1
date	2004.04.02.16.47.38;	author drow;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2004.09.16.17.00.37;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2002.10.28.18.45.46;	author drow;	state Exp;
branches;
next	;

1.10.12.1
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2002.12.23.19.38.00;	author carlton;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.11.11.23.50.29;	author carlton;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2003.12.15.23.59.53;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2003.12.14.20.26.52;	author drow;	state Exp;
branches;
next	;

1.9.8.1
date	2002.06.15.16.42.41;	author cagney;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.20.01.31.11;	author kseitz;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.33
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@/* Stabs in sections linking support.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file contains support for linking stabs in sections, as used
   on COFF and ELF.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "aout/stab_gnu.h"
#include "safe-ctype.h"

/* Stabs entries use a 12 byte format:
     4 byte string table index
     1 byte stab type
     1 byte stab other field
     2 byte stab desc field
     4 byte stab value
   FIXME: This will have to change for a 64 bit object format.

   The stabs symbols are divided into compilation units.  For the
   first entry in each unit, the type of 0, the value is the length of
   the string table for this unit, and the desc field is the number of
   stabs symbols for this unit.  */

#define STRDXOFF  0
#define TYPEOFF   4
#define OTHEROFF  5
#define DESCOFF   6
#define VALOFF    8
#define STABSIZE  12

/* A linked list of totals that we have found for a particular header
   file.  A total is a unique identifier for a particular BINCL...EINCL
   sequence of STABs that can be used to identify duplicate sequences.
   It consists of three fields, 'sum_chars' which is the sum of all the
   STABS characters; 'num_chars' which is the number of these charactes
   and 'symb' which is a buffer of all the symbols in the sequence.  This
   buffer is only checked as a last resort.  */

struct stab_link_includes_totals
{
  struct stab_link_includes_totals *next;
  bfd_vma sum_chars;  /* Accumulated sum of STABS characters.  */
  bfd_vma num_chars;  /* Number of STABS characters.  */
  const char* symb;   /* The STABS characters themselves.  */
};

/* An entry in the header file hash table.  */

struct stab_link_includes_entry
{
  struct bfd_hash_entry root;
  /* List of totals we have found for this file.  */
  struct stab_link_includes_totals *totals;
};

/* This structure is used to hold a list of N_BINCL symbols, some of
   which might be converted into N_EXCL symbols.  */

struct stab_excl_list
{
  /* The next symbol to convert.  */
  struct stab_excl_list *next;
  /* The offset to this symbol in the section contents.  */
  bfd_size_type offset;
  /* The value to use for the symbol.  */
  bfd_vma val;
  /* The type of this symbol (N_BINCL or N_EXCL).  */
  int type;
};

/* This structure is stored with each .stab section.  */

struct stab_section_info
{
  /* This is a linked list of N_BINCL symbols which should be
     converted into N_EXCL symbols.  */
  struct stab_excl_list *excls;

  /* This is used to map input stab offsets within their sections
     to output stab offsets, to take into account stabs that have
     been deleted.  If it is NULL, the output offsets are the same
     as the input offsets, because no stabs have been deleted from
     this section.  Otherwise the i'th entry is the number of
     bytes of stabs that have been deleted prior to the i'th
     stab.  */
  bfd_size_type *cumulative_skips;

  /* This is an array of string indices.  For each stab symbol, we
     store the string index here.  If a stab symbol should not be
     included in the final output, the string index is -1.  */
  bfd_size_type stridxs[1];
};


/* The function to create a new entry in the header file hash table.  */

static struct bfd_hash_entry *
stab_link_includes_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  struct stab_link_includes_entry *ret =
    (struct stab_link_includes_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct stab_link_includes_entry *)
        bfd_hash_allocate (table, sizeof (struct stab_link_includes_entry));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct stab_link_includes_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
  if (ret)
    /* Set local fields.  */
    ret->totals = NULL;

  return (struct bfd_hash_entry *) ret;
}

/* This function is called for each input file from the add_symbols
   pass of the linker.  */

bfd_boolean
_bfd_link_section_stabs (bfd *abfd,
			 struct stab_info *sinfo,
			 asection *stabsec,
			 asection *stabstrsec,
			 void * *psecinfo,
			 bfd_size_type *pstring_offset)
{
  bfd_boolean first;
  bfd_size_type count, amt;
  struct stab_section_info *secinfo;
  bfd_byte *stabbuf = NULL;
  bfd_byte *stabstrbuf = NULL;
  bfd_byte *sym, *symend;
  bfd_size_type stroff, next_stroff, skip;
  bfd_size_type *pstridx;

  if (stabsec->size == 0
      || stabstrsec->size == 0)
    /* This file does not contain stabs debugging information.  */
    return TRUE;

  if (stabsec->size % STABSIZE != 0)
    /* Something is wrong with the format of these stab symbols.
       Don't try to optimize them.  */
    return TRUE;

  if ((stabstrsec->flags & SEC_RELOC) != 0)
    /* We shouldn't see relocations in the strings, and we aren't
       prepared to handle them.  */
    return TRUE;

  if (bfd_is_abs_section (stabsec->output_section)
      || bfd_is_abs_section (stabstrsec->output_section))
    /* At least one of the sections is being discarded from the
       link, so we should just ignore them.  */
    return TRUE;

  first = FALSE;

  if (sinfo->stabstr == NULL)
    {
      flagword flags;

      /* Initialize the stabs information we need to keep track of.  */
      first = TRUE;
      sinfo->strings = _bfd_stringtab_init ();
      if (sinfo->strings == NULL)
	goto error_return;
      /* Make sure the first byte is zero.  */
      (void) _bfd_stringtab_add (sinfo->strings, "", TRUE, TRUE);
      if (! bfd_hash_table_init (&sinfo->includes,
				 stab_link_includes_newfunc,
				 sizeof (struct stab_link_includes_entry)))
	goto error_return;
      flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING
	       | SEC_LINKER_CREATED);
      sinfo->stabstr = bfd_make_section_anyway_with_flags (abfd, ".stabstr",
							   flags);
      if (sinfo->stabstr == NULL)
	goto error_return;
    }

  /* Initialize the information we are going to store for this .stab
     section.  */
  count = stabsec->size / STABSIZE;

  amt = sizeof (struct stab_section_info);
  amt += (count - 1) * sizeof (bfd_size_type);
  *psecinfo = bfd_alloc (abfd, amt);
  if (*psecinfo == NULL)
    goto error_return;

  secinfo = (struct stab_section_info *) *psecinfo;
  secinfo->excls = NULL;
  stabsec->rawsize = stabsec->size;
  secinfo->cumulative_skips = NULL;
  memset (secinfo->stridxs, 0, (size_t) count * sizeof (bfd_size_type));

  /* Read the stabs information from abfd.  */
  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf)
      || !bfd_malloc_and_get_section (abfd, stabstrsec, &stabstrbuf))
    goto error_return;

  /* Look through the stabs symbols, work out the new string indices,
     and identify N_BINCL symbols which can be eliminated.  */
  stroff = 0;
  /* The stabs sections can be split when
     -split-by-reloc/-split-by-file is used.  We must keep track of
     each stab section's place in the single concatenated string
     table.  */
  next_stroff = pstring_offset ? *pstring_offset : 0;
  skip = 0;

  symend = stabbuf + stabsec->size;
  for (sym = stabbuf, pstridx = secinfo->stridxs;
       sym < symend;
       sym += STABSIZE, ++pstridx)
    {
      bfd_size_type symstroff;
      int type;
      const char *string;

      if (*pstridx != 0)
	/* This symbol has already been handled by an N_BINCL pass.  */
	continue;

      type = sym[TYPEOFF];

      if (type == 0)
	{
	  /* Special type 0 stabs indicate the offset to the next
	     string table.  We only copy the very first one.  */
	  stroff = next_stroff;
	  next_stroff += bfd_get_32 (abfd, sym + 8);
	  if (pstring_offset)
	    *pstring_offset = next_stroff;
	  if (! first)
	    {
	      *pstridx = (bfd_size_type) -1;
	      ++skip;
	      continue;
	    }
	  first = FALSE;
	}

      /* Store the string in the hash table, and record the index.  */
      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);
      if (symstroff >= stabstrsec->size)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): Stabs entry has invalid string index."),
	     abfd, stabsec, (long) (sym - stabbuf));
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      string = (char *) stabstrbuf + symstroff;
      *pstridx = _bfd_stringtab_add (sinfo->strings, string, TRUE, TRUE);

      /* An N_BINCL symbol indicates the start of the stabs entries
	 for a header file.  We need to scan ahead to the next N_EINCL
	 symbol, ignoring nesting, adding up all the characters in the
	 symbol names, not including the file numbers in types (the
	 first number after an open parenthesis).  */
      if (type == (int) N_BINCL)
	{
	  bfd_vma sum_chars;
	  bfd_vma num_chars;
	  bfd_vma buf_len = 0;
	  char * symb;
	  char * symb_rover;
	  int nest;
	  bfd_byte * incl_sym;
	  struct stab_link_includes_entry * incl_entry;
	  struct stab_link_includes_totals * t;
	  struct stab_excl_list * ne;

	  symb = symb_rover = NULL;
	  sum_chars = num_chars = 0;
	  nest = 0;

	  for (incl_sym = sym + STABSIZE;
	       incl_sym < symend;
	       incl_sym += STABSIZE)
	    {
	      int incl_type;

	      incl_type = incl_sym[TYPEOFF];
	      if (incl_type == 0)
		break;
	      else if (incl_type == (int) N_EXCL)
		continue;
	      else if (incl_type == (int) N_EINCL)
		{
		  if (nest == 0)
		    break;
		  --nest;
		}
	      else if (incl_type == (int) N_BINCL)
		++nest;
	      else if (nest == 0)
		{
		  const char *str;

		  str = ((char *) stabstrbuf
			 + stroff
			 + bfd_get_32 (abfd, incl_sym + STRDXOFF));
		  for (; *str != '\0'; str++)
		    {
		      if (num_chars >= buf_len)
			{
			  buf_len += 32 * 1024;
			  symb = (char *) bfd_realloc_or_free (symb, buf_len);
			  if (symb == NULL)
			    goto error_return;
			  symb_rover = symb + num_chars;
			}
		      * symb_rover ++ = * str;
		      sum_chars += *str;
		      num_chars ++;
		      if (*str == '(')
			{
			  /* Skip the file number.  */
			  ++str;
			  while (ISDIGIT (*str))
			    ++str;
			  --str;
			}
		    }
		}
	    }

	  BFD_ASSERT (num_chars == (bfd_vma) (symb_rover - symb));

	  /* If we have already included a header file with the same
	     value, then replaced this one with an N_EXCL symbol.  */
	  incl_entry = (struct stab_link_includes_entry * )
	    bfd_hash_lookup (&sinfo->includes, string, TRUE, TRUE);
	  if (incl_entry == NULL)
	    goto error_return;

	  for (t = incl_entry->totals; t != NULL; t = t->next)
	    if (t->sum_chars == sum_chars
		&& t->num_chars == num_chars
		&& memcmp (t->symb, symb, num_chars) == 0)
	      break;

	  /* Record this symbol, so that we can set the value
	     correctly.  */
	  amt = sizeof *ne;
	  ne = (struct stab_excl_list *) bfd_alloc (abfd, amt);
	  if (ne == NULL)
	    goto error_return;
	  ne->offset = sym - stabbuf;
	  ne->val = sum_chars;
	  ne->type = (int) N_BINCL;
	  ne->next = secinfo->excls;
	  secinfo->excls = ne;

	  if (t == NULL)
	    {
	      /* This is the first time we have seen this header file
		 with this set of stabs strings.  */
	      t = (struct stab_link_includes_totals *)
                  bfd_hash_allocate (&sinfo->includes, sizeof *t);
	      if (t == NULL)
		goto error_return;
	      t->sum_chars = sum_chars;
	      t->num_chars = num_chars;
              /* Trim data down.  */
	      t->symb = symb = (char *) bfd_realloc_or_free (symb, num_chars);
	      t->next = incl_entry->totals;
	      incl_entry->totals = t;
	    }
	  else
	    {
	      bfd_size_type *incl_pstridx;

	      /* We have seen this header file before.  Tell the final
		 pass to change the type to N_EXCL.  */
	      ne->type = (int) N_EXCL;

	      /* Free off superfluous symbols.  */
	      free (symb);

	      /* Mark the skipped symbols.  */

	      nest = 0;
	      for (incl_sym = sym + STABSIZE, incl_pstridx = pstridx + 1;
		   incl_sym < symend;
		   incl_sym += STABSIZE, ++incl_pstridx)
		{
		  int incl_type;

		  incl_type = incl_sym[TYPEOFF];

		  if (incl_type == (int) N_EINCL)
		    {
		      if (nest == 0)
			{
			  *incl_pstridx = (bfd_size_type) -1;
			  ++skip;
			  break;
			}
		      --nest;
		    }
		  else if (incl_type == (int) N_BINCL)
		    ++nest;
		  else if (incl_type == (int) N_EXCL)
		    /* Keep existing exclusion marks.  */
		    continue;
		  else if (nest == 0)
		    {
		      *incl_pstridx = (bfd_size_type) -1;
		      ++skip;
		    }
		}
	    }
	}
    }

  free (stabbuf);
  stabbuf = NULL;
  free (stabstrbuf);
  stabstrbuf = NULL;

  /* We need to set the section sizes such that the linker will
     compute the output section sizes correctly.  We set the .stab
     size to not include the entries we don't want.  We set
     SEC_EXCLUDE for the .stabstr section, so that it will be dropped
     from the link.  We record the size of the strtab in the first
     .stabstr section we saw, and make sure we don't set SEC_EXCLUDE
     for that section.  */
  stabsec->size = (count - skip) * STABSIZE;
  if (stabsec->size == 0)
    stabsec->flags |= SEC_EXCLUDE | SEC_KEEP;
  stabstrsec->flags |= SEC_EXCLUDE | SEC_KEEP;
  sinfo->stabstr->size = _bfd_stringtab_size (sinfo->strings);

  /* Calculate the `cumulative_skips' array now that stabs have been
     deleted for this section.  */

  if (skip != 0)
    {
      bfd_size_type i, offset;
      bfd_size_type *pskips;

      amt = count * sizeof (bfd_size_type);
      secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
      if (secinfo->cumulative_skips == NULL)
	goto error_return;

      pskips = secinfo->cumulative_skips;
      pstridx = secinfo->stridxs;
      offset = 0;

      for (i = 0; i < count; i++, pskips++, pstridx++)
	{
	  *pskips = offset;
	  if (*pstridx == (bfd_size_type) -1)
	    offset += STABSIZE;
	}

      BFD_ASSERT (offset != 0);
    }

  return TRUE;

 error_return:
  if (stabbuf != NULL)
    free (stabbuf);
  if (stabstrbuf != NULL)
    free (stabstrbuf);
  return FALSE;
}

/* This function is called for each input file before the stab
   section is relocated.  It discards stab entries for discarded
   functions and variables.  The function returns TRUE iff
   any entries have been deleted.
*/

bfd_boolean
_bfd_discard_section_stabs (bfd *abfd,
			    asection *stabsec,
			    void * psecinfo,
			    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),
			    void * cookie)
{
  bfd_size_type count, amt;
  struct stab_section_info *secinfo;
  bfd_byte *stabbuf = NULL;
  bfd_byte *sym, *symend;
  bfd_size_type skip;
  bfd_size_type *pstridx;
  int deleting;

  if (stabsec->size == 0)
    /* This file does not contain stabs debugging information.  */
    return FALSE;

  if (stabsec->size % STABSIZE != 0)
    /* Something is wrong with the format of these stab symbols.
       Don't try to optimize them.  */
    return FALSE;

  if ((stabsec->output_section != NULL
       && bfd_is_abs_section (stabsec->output_section)))
    /* At least one of the sections is being discarded from the
       link, so we should just ignore them.  */
    return FALSE;

  /* We should have initialized our data in _bfd_link_stab_sections.
     If there was some bizarre error reading the string sections, though,
     we might not have.  Bail rather than asserting.  */
  if (psecinfo == NULL)
    return FALSE;

  count = stabsec->rawsize / STABSIZE;
  secinfo = (struct stab_section_info *) psecinfo;

  /* Read the stabs information from abfd.  */
  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf))
    goto error_return;

  /* Look through the stabs symbols and discard any information for
     discarded functions.  */
  skip = 0;
  deleting = -1;

  symend = stabbuf + stabsec->rawsize;
  for (sym = stabbuf, pstridx = secinfo->stridxs;
       sym < symend;
       sym += STABSIZE, ++pstridx)
    {
      int type;

      if (*pstridx == (bfd_size_type) -1)
	/* This stab was deleted in a previous pass.  */
	continue;

      type = sym[TYPEOFF];

      if (type == (int) N_FUN)
	{
	  int strx = bfd_get_32 (abfd, sym + STRDXOFF);

	  if (strx == 0)
	    {
	      if (deleting)
		{
		  skip++;
		  *pstridx = -1;
		}
	      deleting = -1;
	      continue;
	    }
	  deleting = 0;
	  if ((*reloc_symbol_deleted_p) (sym + VALOFF - stabbuf, cookie))
	    deleting = 1;
	}

      if (deleting == 1)
	{
	  *pstridx = -1;
	  skip++;
	}
      else if (deleting == -1)
	{
	  /* Outside of a function.  Check for deleted variables.  */
	  if (type == (int) N_STSYM || type == (int) N_LCSYM)
	    if ((*reloc_symbol_deleted_p) (sym + VALOFF - stabbuf, cookie))
	      {
		*pstridx = -1;
		skip ++;
	      }
	  /* We should also check for N_GSYM entries which reference a
	     deleted global, but those are less harmful to debuggers
	     and would require parsing the stab strings.  */
	}
    }

  free (stabbuf);
  stabbuf = NULL;

  /* Shrink the stabsec as needed.  */
  stabsec->size -= skip * STABSIZE;
  if (stabsec->size == 0)
    stabsec->flags |= SEC_EXCLUDE | SEC_KEEP;

  /* Recalculate the `cumulative_skips' array now that stabs have been
     deleted for this section.  */

  if (skip != 0)
    {
      bfd_size_type i, offset;
      bfd_size_type *pskips;

      if (secinfo->cumulative_skips == NULL)
	{
	  amt = count * sizeof (bfd_size_type);
	  secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
	  if (secinfo->cumulative_skips == NULL)
	    goto error_return;
	}

      pskips = secinfo->cumulative_skips;
      pstridx = secinfo->stridxs;
      offset = 0;

      for (i = 0; i < count; i++, pskips++, pstridx++)
	{
	  *pskips = offset;
	  if (*pstridx == (bfd_size_type) -1)
	    offset += STABSIZE;
	}

      BFD_ASSERT (offset != 0);
    }

  return skip > 0;

 error_return:
  if (stabbuf != NULL)
    free (stabbuf);
  return FALSE;
}

/* Write out the stab section.  This is called with the relocated
   contents.  */

bfd_boolean
_bfd_write_section_stabs (bfd *output_bfd,
			  struct stab_info *sinfo,
			  asection *stabsec,
			  void * *psecinfo,
			  bfd_byte *contents)
{
  struct stab_section_info *secinfo;
  struct stab_excl_list *e;
  bfd_byte *sym, *tosym, *symend;
  bfd_size_type *pstridx;

  secinfo = (struct stab_section_info *) *psecinfo;

  if (secinfo == NULL)
    return bfd_set_section_contents (output_bfd, stabsec->output_section,
				     contents, stabsec->output_offset,
				     stabsec->size);

  /* Handle each N_BINCL entry.  */
  for (e = secinfo->excls; e != NULL; e = e->next)
    {
      bfd_byte *excl_sym;

      BFD_ASSERT (e->offset < stabsec->rawsize);
      excl_sym = contents + e->offset;
      bfd_put_32 (output_bfd, e->val, excl_sym + VALOFF);
      excl_sym[TYPEOFF] = e->type;
    }

  /* Copy over all the stabs symbols, omitting the ones we don't want,
     and correcting the string indices for those we do want.  */
  tosym = contents;
  symend = contents + stabsec->rawsize;
  for (sym = contents, pstridx = secinfo->stridxs;
       sym < symend;
       sym += STABSIZE, ++pstridx)
    {
      if (*pstridx != (bfd_size_type) -1)
	{
	  if (tosym != sym)
	    memcpy (tosym, sym, STABSIZE);
	  bfd_put_32 (output_bfd, *pstridx, tosym + STRDXOFF);

	  if (sym[TYPEOFF] == 0)
	    {
	      /* This is the header symbol for the stabs section.  We
		 don't really need one, since we have merged all the
		 input stabs sections into one, but we generate one
		 for the benefit of readers which expect to see one.  */
	      BFD_ASSERT (sym == contents);
	      bfd_put_32 (output_bfd, _bfd_stringtab_size (sinfo->strings),
			  tosym + VALOFF);
	      bfd_put_16 (output_bfd,
			  stabsec->output_section->size / STABSIZE - 1,
			  tosym + DESCOFF);
	    }

	  tosym += STABSIZE;
	}
    }

  BFD_ASSERT ((bfd_size_type) (tosym - contents) == stabsec->size);

  return bfd_set_section_contents (output_bfd, stabsec->output_section,
				   contents, (file_ptr) stabsec->output_offset,
				   stabsec->size);
}

/* Write out the .stabstr section.  */

bfd_boolean
_bfd_write_stab_strings (bfd *output_bfd, struct stab_info *sinfo)
{
  if (bfd_is_abs_section (sinfo->stabstr->output_section))
    /* The section was discarded from the link.  */
    return TRUE;

  BFD_ASSERT ((sinfo->stabstr->output_offset
	       + _bfd_stringtab_size (sinfo->strings))
	      <= sinfo->stabstr->output_section->size);

  if (bfd_seek (output_bfd,
		(file_ptr) (sinfo->stabstr->output_section->filepos
			    + sinfo->stabstr->output_offset),
		SEEK_SET) != 0)
    return FALSE;

  if (! _bfd_stringtab_emit (output_bfd, sinfo->strings))
    return FALSE;

  /* We no longer need the stabs information.  */
  _bfd_stringtab_free (sinfo->strings);
  bfd_hash_table_free (&sinfo->includes);

  return TRUE;
}

/* Adjust an address in the .stab section.  Given OFFSET within
   STABSEC, this returns the new offset in the adjusted stab section,
   or -1 if the address refers to a stab which has been removed.  */

bfd_vma
_bfd_stab_section_offset (asection *stabsec,
			  void * psecinfo,
			  bfd_vma offset)
{
  struct stab_section_info *secinfo;

  secinfo = (struct stab_section_info *) psecinfo;

  if (secinfo == NULL)
    return offset;

  if (offset >= stabsec->rawsize)
    return offset - stabsec->rawsize + stabsec->size;

  if (secinfo->cumulative_skips)
    {
      bfd_vma i;

      i = offset / STABSIZE;

      if (secinfo->stridxs [i] == (bfd_size_type) -1)
	return (bfd_vma) -1;

      return offset - secinfo->cumulative_skips [i];
    }

  return offset;
}
@


1.32
log
@update copyright dates
@
text
@d130 2
a131 2
    ret = bfd_hash_allocate (table,
			     sizeof (struct stab_link_includes_entry));
d340 1
a340 1
			  symb = bfd_realloc_or_free (symb, buf_len);
d378 1
a378 1
	  ne = bfd_alloc (abfd, amt);
d391 2
a392 1
	      t = bfd_hash_allocate (&sinfo->includes, sizeof *t);
d397 2
a398 1
	      t->symb = symb = bfd_realloc_or_free (symb, num_chars); /* Trim data down.  */
d476 1
a476 1
      secinfo->cumulative_skips = bfd_alloc (abfd, amt);
d629 1
a629 1
	  secinfo->cumulative_skips = bfd_alloc (abfd, amt);
@


1.32.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d130 2
a131 2
    ret = (struct stab_link_includes_entry *)
        bfd_hash_allocate (table, sizeof (struct stab_link_includes_entry));
d340 1
a340 1
			  symb = (char *) bfd_realloc_or_free (symb, buf_len);
d378 1
a378 1
	  ne = (struct stab_excl_list *) bfd_alloc (abfd, amt);
d391 1
a391 2
	      t = (struct stab_link_includes_totals *)
                  bfd_hash_allocate (&sinfo->includes, sizeof *t);
d396 1
a396 2
              /* Trim data down.  */
	      t->symb = symb = (char *) bfd_realloc_or_free (symb, num_chars);
d474 1
a474 1
      secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
d627 1
a627 1
	  secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
@


1.31
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
@


1.30
log
@Switch sources over to use the GPL version 3
@
text
@d340 1
a340 1
			  symb = bfd_realloc (symb, buf_len);
d396 1
a396 1
	      t->symb = bfd_realloc (symb, num_chars); /* Trim data down.  */
@


1.29
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.28
log
@bfd/
	* section.c (SEC_KEEP): Update comment.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Ignore SEC_EXCLUDE sections.
	* merge.c (_bfd_merge_sections): Set SEC_KEEP on excluded sections.
	* stabs.c (_bfd_discard_section_stabs): Likewise.
	(_bfd_link_section_stabs): Likewise.  Simplify abs_section check.
ld/
	* ldlang.c (lang_map): Don't say SEC_LINKER_CREATED and SEC_KEEP
	sections have been discarded.
	(lang_do_version_exports_section): Set SEC_KEEP on export section.
	* emultempl/elf32.em (before_allocation): Set SEC_KEEP on warning
	sections.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d25 1
a26 1
#include "sysdep.h"
@


1.27
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d178 2
a179 4
  if ((stabsec->output_section != NULL
       && bfd_is_abs_section (stabsec->output_section))
      || (stabstrsec->output_section != NULL
	  && bfd_is_abs_section (stabstrsec->output_section)))
d434 1
a434 1
		    continue;   
d459 2
a460 2
    stabsec->flags |= SEC_EXCLUDE;
  stabstrsec->flags |= SEC_EXCLUDE;
d612 1
a612 1
    stabsec->flags |= SEC_EXCLUDE;
@


1.26
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d190 2
d203 4
a206 1
      sinfo->stabstr = bfd_make_section_anyway (abfd, ".stabstr");
a208 2
      sinfo->stabstr->flags |= (SEC_HAS_CONTENTS | SEC_READONLY
				| SEC_DEBUGGING | SEC_LINKER_CREATED);
@


1.25
log
@(_bfd_link_section_stabs): Use bfd_hash_table_init rather than
bfd_hash_table_init_n(...,251) so that the size of the hash table can be
controlled by the user.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d198 2
a199 1
				 stab_link_includes_newfunc))
@


1.24
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d197 2
a198 3
      if (! bfd_hash_table_init_n (&sinfo->includes,
				   stab_link_includes_newfunc,
				   251))
@


1.23
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.22
log
@Convert to ISO C90 formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.21
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d44 6
a49 6
#define STRDXOFF (0)
#define TYPEOFF (4)
#define OTHEROFF (5)
#define DESCOFF (6)
#define VALOFF (8)
#define STABSIZE (12)
a113 2
static struct bfd_hash_entry *stab_link_includes_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d118 3
a120 4
stab_link_includes_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d127 5
a131 6
  if (ret == (struct stab_link_includes_entry *) NULL)
    ret = ((struct stab_link_includes_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct stab_link_includes_entry)));
  if (ret == (struct stab_link_includes_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d137 2
a138 4
    {
      /* Set local fields.  */
      ret->totals = NULL;
    }
d147 6
a152 7
_bfd_link_section_stabs (abfd, sinfo, stabsec, stabstrsec, psecinfo, pstring_offset)
     bfd *abfd;
     struct stab_info *sinfo;
     asection *stabsec;
     asection *stabstrsec;
     PTR *psecinfo;
     bfd_size_type *pstring_offset;
d165 2
a166 4
    {
      /* This file does not contain stabs debugging information.  */
      return TRUE;
    }
d169 3
a171 5
    {
      /* Something is wrong with the format of these stab symbols.
	 Don't try to optimize them.  */
      return TRUE;
    }
d174 3
a176 5
    {
      /* We shouldn't see relocations in the strings, and we aren't
	 prepared to handle them.  */
      return TRUE;
    }
d182 3
a184 5
    {
      /* At least one of the sections is being discarded from the
	 link, so we should just ignore them.  */
      return TRUE;
    }
a209 1

a224 1

a230 1

d249 2
a250 4
	{
	  /* This symbol has already been handled by an N_BINCL pass.  */
	  continue;
	}
d375 1
a375 1
	  ne = (struct stab_excl_list *) bfd_alloc (abfd, amt);
d388 1
a388 2
	      t = ((struct stab_link_includes_totals *)
		   bfd_hash_allocate (&sinfo->includes, sizeof *t));
d471 1
a471 1
      secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
d506 5
a510 7
_bfd_discard_section_stabs (abfd, stabsec, psecinfo,
			    reloc_symbol_deleted_p, cookie)
     bfd *abfd;
     asection *stabsec;
     PTR psecinfo;
     bfd_boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
     PTR cookie;
d521 2
a522 4
    {
      /* This file does not contain stabs debugging information.  */
      return FALSE;
    }
d525 3
a527 5
    {
      /* Something is wrong with the format of these stab symbols.
	 Don't try to optimize them.  */
      return FALSE;
    }
d531 3
a533 5
    {
      /* At least one of the sections is being discarded from the
	 link, so we should just ignore them.  */
      return FALSE;
    }
a544 1

a549 1

d561 2
a562 4
	{
	  /* This stab was deleted in a previous pass.  */
	  continue;
	}
d624 1
a624 1
	  secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);
d655 5
a659 6
_bfd_write_section_stabs (output_bfd, sinfo, stabsec, psecinfo, contents)
     bfd *output_bfd;
     struct stab_info *sinfo;
     asection *stabsec;
     PTR *psecinfo;
     bfd_byte *contents;
d726 1
a726 3
_bfd_write_stab_strings (output_bfd, sinfo)
     bfd *output_bfd;
     struct stab_info *sinfo;
d729 2
a730 4
    {
      /* The section was discarded from the link.  */
      return TRUE;
    }
d757 3
a759 4
_bfd_stab_section_offset (stabsec, psecinfo, offset)
     asection *stabsec;
     PTR psecinfo;
     bfd_vma offset;
@


1.20
log
@	* bfd-in.h (struct stab_info): Move from stabs.c.
	* stabs.c (struct stab_link_includes_table): Delete.
	(stab_link_includes_lookup): Delete.
	(_bfd_write_section_stabs, _bfd_write_stab_strings): Remove one
	level of indirection from sinfo parm.
	(_bfd_link_section_stabs): Likewise.  Set SEC_LINKER_CREATED on
	stabstr section.  Adjust hash table accesses.
	* coff-ppc.c (ppc_bfd_coff_final_link): Do include rawsize in contents
	alloc.  Adjust stab_info test.
	* cofflink.c (_bfd_coff_link_hash_table_init): Clear stab_info.
	(_bfd_coff_final_link): Adjust stab_info test.
	(_bfd_coff_link_input_bfd): Ignore SEC_LINKER_CREATED sections.
	* elf-bfd.h (struct elf_link_hash_table): Include struct stab_info
	in place.
	* libcoff-in.h (struct coff_link_hash_table): Likewise.
	* elf.c (_bfd_elf_link_hash_table_init): Clear stab_info.
	* elflink.c (bfd_elf_final_link): Don't attempt to link linker created
	stabstr section.  Adjust stab_info test.
	* libbfd-in.h (_bfd_link_section_stabs, _bfd_write_section_stabs)
	(_bfd_write_stab_strings): Adjust prototypes.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d296 2
a297 4
	    (_("%s(%s+0x%lx): Stabs entry has invalid string index."),
	     bfd_archive_filename (abfd),
	     bfd_get_section_name (abfd, stabsec),
	     (long) (sym - stabbuf));
@


1.19
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a50 7
/* A hash table used for header files with N_BINCL entries.  */

struct stab_link_includes_table
{
  struct bfd_hash_table root;
};

a75 6
/* Look up an entry in an the header file hash table.  */

#define stab_link_includes_lookup(table, string, create, copy) \
  ((struct stab_link_includes_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

a113 13
/* This structure is used to keep track of stabs in sections
   information while linking.  */

struct stab_info
{
  /* A hash table used to hold stabs strings.  */
  struct bfd_strtab_hash *strings;
  /* The header file hash table.  */
  struct stab_link_includes_table includes;
  /* The first .stabstr section.  */
  asection *stabstr;
};

d153 1
a153 1
_bfd_link_section_stabs (abfd, psinfo, stabsec, stabstrsec, psecinfo, pstring_offset)
d155 1
a155 1
     PTR *psinfo;
a161 1
  struct stab_info *sinfo;
d203 1
a203 1
  if (*psinfo == NULL)
a206 5
      amt = sizeof (struct stab_info);
      *psinfo = (PTR) bfd_alloc (abfd, amt);
      if (*psinfo == NULL)
	goto error_return;
      sinfo = (struct stab_info *) *psinfo;
d212 1
a212 1
      if (! bfd_hash_table_init_n (&sinfo->includes.root,
d217 4
a220 1
      sinfo->stabstr->flags |= SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING;
a222 2
  sinfo = (struct stab_info *) *psinfo;

d383 2
a384 2
	  incl_entry = stab_link_includes_lookup (&sinfo->includes, string,
						  TRUE, TRUE);
d411 1
a411 1
		   bfd_hash_allocate (&sinfo->includes.root, sizeof *t));
d690 1
a690 1
_bfd_write_section_stabs (output_bfd, psinfo, stabsec, psecinfo, contents)
d692 1
a692 1
     PTR *psinfo;
a696 1
  struct stab_info *sinfo;
a701 1
  sinfo = (struct stab_info *) *psinfo;
d762 1
a762 1
_bfd_write_stab_strings (output_bfd, psinfo)
d764 1
a764 1
     PTR *psinfo;
a765 7
  struct stab_info *sinfo;

  sinfo = (struct stab_info *) *psinfo;

  if (sinfo == NULL)
    return TRUE;

d787 1
a787 1
  bfd_hash_table_free (&sinfo->includes.root);
@


1.18
log
@(struct stab_link_includes_totals): Add field 'symb' that keeps the characters
in a B_INCL..B_EINCL range.
(_bfd_link_section_stabs): When computing the sum of the characters in a
B_INCL..B_EINCL range also keep a copy of those	characters.  Use this
information to distinguish between include sections that have the same sum
and the same length but which are nevertheless unique.
@
text
@d197 2
a198 2
  if (stabsec->_raw_size == 0
      || stabstrsec->_raw_size == 0)
d204 1
a204 1
  if (stabsec->_raw_size % STABSIZE != 0)
d257 1
a257 1
  count = stabsec->_raw_size / STABSIZE;
d267 1
d273 2
a274 9
  stabbuf = (bfd_byte *) bfd_malloc (stabsec->_raw_size);
  stabstrbuf = (bfd_byte *) bfd_malloc (stabstrsec->_raw_size);
  if (stabbuf == NULL || stabstrbuf == NULL)
    goto error_return;

  if (! bfd_get_section_contents (abfd, stabsec, stabbuf, (bfd_vma) 0,
				  stabsec->_raw_size)
      || ! bfd_get_section_contents (abfd, stabstrsec, stabstrbuf, (bfd_vma) 0,
				     stabstrsec->_raw_size))
d288 1
a288 1
  symend = stabbuf + stabsec->_raw_size;
d324 1
a324 1
      if (symstroff >= stabstrsec->_raw_size)
d510 2
a511 2
  stabsec->_cooked_size = (count - skip) * STABSIZE;
  if (stabsec->_cooked_size == 0)
d514 1
a514 1
  sinfo->stabstr->_cooked_size = _bfd_stringtab_size (sinfo->strings);
a551 1

d576 1
a576 1
  if (stabsec->_raw_size == 0)
d582 1
a582 1
  if (stabsec->_raw_size % STABSIZE != 0)
d603 1
a603 1
  count = stabsec->_raw_size / STABSIZE;
d608 1
a608 6
  stabbuf = (bfd_byte *) bfd_malloc (stabsec->_raw_size);
  if (stabbuf == NULL)
    goto error_return;

  if (! bfd_get_section_contents (abfd, stabsec, stabbuf, (bfd_vma) 0,
				  stabsec->_raw_size))
d617 1
a617 1
  symend = stabbuf + stabsec->_raw_size;
d675 2
a676 2
  stabsec->_cooked_size -= skip * STABSIZE;
  if (stabsec->_cooked_size == 0)
d739 2
a740 3
				     contents,
				     (file_ptr) stabsec->output_offset,
				     stabsec->_raw_size);
d747 1
a747 1
      BFD_ASSERT (e->offset < stabsec->_raw_size);
d756 1
a756 1
  symend = contents + stabsec->_raw_size;
d777 1
a777 1
			  stabsec->output_section->_raw_size / STABSIZE - 1,
d785 1
a785 1
  BFD_ASSERT ((bfd_size_type) (tosym - contents) == stabsec->_cooked_size);
d789 1
a789 1
				   stabsec->_cooked_size);
d814 1
a814 1
	      <= sinfo->stabstr->output_section->_raw_size);
d837 1
a837 3
_bfd_stab_section_offset (output_bfd, psinfo, stabsec, psecinfo, offset)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     PTR *psinfo ATTRIBUTE_UNUSED;
d839 1
a839 1
     PTR *psecinfo;
d844 1
a844 1
  secinfo = (struct stab_section_info *) *psecinfo;
d849 2
a850 2
  if (offset >= stabsec->_raw_size)
    return offset - (stabsec->_cooked_size - stabsec->_raw_size);
@


1.17
log
@(struct stab_link_includes_totals): Rename field 'total' to 'sum_chars'
and add field 'num_chars'.
(_bfd_link_section_stabs): When computing the sum of the characters in a
B_INCL..B_EINCL range also keep a count of the number of characters.  Use
this information to help distinguish between include sections when have
the same sum but which nevertheless are still unique.
@
text
@d59 6
a64 5
   file.  A total is the sum of all the STABS characters for a particular
   file and the number of these charactes.  It is used to identify
   duplicate files which can be excluded.  XXX: A better method would be to
   compute an MD5 checksum, but that is coding left for another day.
   The bfd_vma type is used because it is a very large unsigned type.  */
d71 1
d352 3
d356 4
a359 4
	  bfd_byte *incl_sym;
	  struct stab_link_includes_entry *incl_entry;
	  struct stab_link_includes_totals *t;
	  struct stab_excl_list *ne;
d361 1
d364 1
d393 9
d416 2
d426 3
a428 1
	    if (t->sum_chars == sum_chars && t->num_chars == num_chars)
d453 1
d464 3
@


1.16
log
@(_bfd_link_section_stabs): Do not skip N_EXCL stabs.
@
text
@d59 5
a63 1
   file.  */
d68 2
a69 1
  bfd_vma total;
d348 2
a349 1
	  bfd_vma val;
d356 1
a356 1
	  val = 0;
d386 2
a387 1
		      val += *str;
d408 1
a408 1
	    if (t->total == val)
d418 1
a418 1
	  ne->val = val;
d431 2
a432 1
	      t->total = val;
@


1.15
log
@Skip N_EXCL stabs when procesing N_BINCL stabs.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d459 3
@


1.15.6.1
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d59 1
a59 6
   file.  A total is a unique identifier for a particular BINCL...EINCL
   sequence of STABs that can be used to identify duplicate sequences.
   It consists of three fields, 'sum_chars' which is the sum of all the
   STABS characters; 'num_chars' which is the number of these charactes
   and 'symb' which is a buffer of all the symbols in the sequence.  This
   buffer is only checked as a last resort.  */
d64 1
a64 3
  bfd_vma sum_chars;  /* Accumulated sum of STABS characters.  */
  bfd_vma num_chars;  /* Number of STABS characters.  */
  const char* symb;   /* The STABS characters themselves.  */
d343 1
a343 5
	  bfd_vma sum_chars;
	  bfd_vma num_chars;
	  bfd_vma buf_len = 0;
	  char * symb;
	  char * symb_rover;
d345 4
a348 4
	  bfd_byte * incl_sym;
	  struct stab_link_includes_entry * incl_entry;
	  struct stab_link_includes_totals * t;
	  struct stab_excl_list * ne;
d350 1
a350 2
	  symb = symb_rover = NULL;
	  sum_chars = num_chars = 0;
a351 1

d380 1
a380 11
		      if (num_chars >= buf_len)
			{
			  buf_len += 32 * 1024;
			  symb = bfd_realloc (symb, buf_len);
			  if (symb == NULL)
			    goto error_return;
			  symb_rover = symb + num_chars;
			}
		      * symb_rover ++ = * str;
		      sum_chars += *str;
		      num_chars ++;
a392 2
	  BFD_ASSERT (num_chars == (bfd_vma) (symb_rover - symb));

d401 1
a401 3
	    if (t->sum_chars == sum_chars
		&& t->num_chars == num_chars
		&& memcmp (t->symb, symb, num_chars) == 0)
d411 1
a411 1
	  ne->val = sum_chars;
d424 1
a424 3
	      t->sum_chars = sum_chars;
	      t->num_chars = num_chars;
	      t->symb = bfd_realloc (symb, num_chars); /* Trim data down.  */
a435 3
	      /* Free off superfluous symbols.  */
	      free (symb);

a458 3
		  else if (incl_type == (int) N_EXCL)
		    /* Keep existing exclusion marks.  */
		    continue;   
@


1.15.8.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d59 1
a59 6
   file.  A total is a unique identifier for a particular BINCL...EINCL
   sequence of STABs that can be used to identify duplicate sequences.
   It consists of three fields, 'sum_chars' which is the sum of all the
   STABS characters; 'num_chars' which is the number of these charactes
   and 'symb' which is a buffer of all the symbols in the sequence.  This
   buffer is only checked as a last resort.  */
d64 1
a64 3
  bfd_vma sum_chars;  /* Accumulated sum of STABS characters.  */
  bfd_vma num_chars;  /* Number of STABS characters.  */
  const char* symb;   /* The STABS characters themselves.  */
d343 1
a343 5
	  bfd_vma sum_chars;
	  bfd_vma num_chars;
	  bfd_vma buf_len = 0;
	  char * symb;
	  char * symb_rover;
d345 4
a348 4
	  bfd_byte * incl_sym;
	  struct stab_link_includes_entry * incl_entry;
	  struct stab_link_includes_totals * t;
	  struct stab_excl_list * ne;
d350 1
a350 2
	  symb = symb_rover = NULL;
	  sum_chars = num_chars = 0;
a351 1

d380 1
a380 11
		      if (num_chars >= buf_len)
			{
			  buf_len += 32 * 1024;
			  symb = bfd_realloc (symb, buf_len);
			  if (symb == NULL)
			    goto error_return;
			  symb_rover = symb + num_chars;
			}
		      * symb_rover ++ = * str;
		      sum_chars += *str;
		      num_chars ++;
a392 2
	  BFD_ASSERT (num_chars == (bfd_vma) (symb_rover - symb));

d401 1
a401 3
	    if (t->sum_chars == sum_chars
		&& t->num_chars == num_chars
		&& memcmp (t->symb, symb, num_chars) == 0)
d411 1
a411 1
	  ne->val = sum_chars;
d424 1
a424 3
	      t->sum_chars = sum_chars;
	      t->num_chars = num_chars;
	      t->symb = bfd_realloc (symb, num_chars); /* Trim data down.  */
a435 3
	      /* Free off superfluous symbols.  */
	      free (symb);

a458 3
		  else if (incl_type == (int) N_EXCL)
		    /* Keep existing exclusion marks.  */
		    continue;   
@


1.15.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d51 7
d83 6
d127 13
d179 1
a179 1
_bfd_link_section_stabs (abfd, sinfo, stabsec, stabstrsec, psecinfo, pstring_offset)
d181 1
a181 1
     struct stab_info *sinfo;
d188 1
d197 2
a198 2
  if (stabsec->size == 0
      || stabstrsec->size == 0)
d204 1
a204 1
  if (stabsec->size % STABSIZE != 0)
d230 1
a230 1
  if (sinfo->stabstr == NULL)
d234 5
d244 1
a244 1
      if (! bfd_hash_table_init_n (&sinfo->includes,
d249 1
a249 4
      if (sinfo->stabstr == NULL)
	goto error_return;
      sinfo->stabstr->flags |= (SEC_HAS_CONTENTS | SEC_READONLY
				| SEC_DEBUGGING | SEC_LINKER_CREATED);
d252 2
d257 1
a257 1
  count = stabsec->size / STABSIZE;
a266 1
  stabsec->rawsize = stabsec->size;
d272 9
a280 2
  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf)
      || !bfd_malloc_and_get_section (abfd, stabstrsec, &stabstrbuf))
d294 1
a294 1
  symend = stabbuf + stabsec->size;
d330 1
a330 1
      if (symstroff >= stabstrsec->size)
d333 4
a336 2
	    (_("%B(%A+0x%lx): Stabs entry has invalid string index."),
	     abfd, stabsec, (long) (sym - stabbuf));
d420 2
a421 2
	  incl_entry = (struct stab_link_includes_entry * )
	    bfd_hash_lookup (&sinfo->includes, string, TRUE, TRUE);
d448 1
a448 1
		   bfd_hash_allocate (&sinfo->includes, sizeof *t));
d516 2
a517 2
  stabsec->size = (count - skip) * STABSIZE;
  if (stabsec->size == 0)
d520 1
a520 1
  sinfo->stabstr->size = _bfd_stringtab_size (sinfo->strings);
d558 1
d583 1
a583 1
  if (stabsec->size == 0)
d589 1
a589 1
  if (stabsec->size % STABSIZE != 0)
d610 1
a610 1
  count = stabsec->rawsize / STABSIZE;
d615 6
a620 1
  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf))
d629 1
a629 1
  symend = stabbuf + stabsec->rawsize;
d687 2
a688 2
  stabsec->size -= skip * STABSIZE;
  if (stabsec->size == 0)
d733 1
a733 1
_bfd_write_section_stabs (output_bfd, sinfo, stabsec, psecinfo, contents)
d735 1
a735 1
     struct stab_info *sinfo;
d740 1
d746 1
d751 3
a753 2
				     contents, stabsec->output_offset,
				     stabsec->size);
d760 1
a760 1
      BFD_ASSERT (e->offset < stabsec->rawsize);
d769 1
a769 1
  symend = contents + stabsec->rawsize;
d790 1
a790 1
			  stabsec->output_section->size / STABSIZE - 1,
d798 1
a798 1
  BFD_ASSERT ((bfd_size_type) (tosym - contents) == stabsec->size);
d802 1
a802 1
				   stabsec->size);
d808 1
a808 1
_bfd_write_stab_strings (output_bfd, sinfo)
d810 1
a810 1
     struct stab_info *sinfo;
d812 7
d827 1
a827 1
	      <= sinfo->stabstr->output_section->size);
d840 1
a840 1
  bfd_hash_table_free (&sinfo->includes);
d850 3
a852 1
_bfd_stab_section_offset (stabsec, psecinfo, offset)
d854 1
a854 1
     PTR psecinfo;
d859 1
a859 1
  secinfo = (struct stab_section_info *) psecinfo;
d864 2
a865 2
  if (offset >= stabsec->rawsize)
    return offset - stabsec->rawsize + stabsec->size;
@


1.14
log
@	* aout-target.h, aoutf1.h, bfdio.c, bfdwin.c: Update copyright date.
	* coff-apollo.c, coff-sparc.c, coff-w65.c, coff-we32k.c: Ditto.
	* coff-z8k.c, coffgen.c, cpu-frv.c, cpu-h8500.c, cpu-hppa.c: Ditto.
	* cpu-ia64-opc.c, cpu-m10300.c, cpu-mips.c, cpu-msp430.c: Ditto.
	* cpu-rs6000.c, cpu-z8k.c, efi-app-ia32.c, elf32-am33lin.c: Ditto.
	* gen-aout.c, hash.c, hp300hpux.c, init.c, mach-o.c: Ditto.
	* nlm-target.h, nlm.c, som.h, stabs.c, sysdep.h, xsym.h: Ditto.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d361 2
@


1.13
log
@bfd/Changelog:
	* libbfd-in.h (_bfd_link_section_stabs): Add string offset
	parameter.
	* cofflink.c (coff_link_add_symbols): Deal with split stab
	sections.
	* elflink.h (elf_link_add_object_symbols): Deal with split stab
	sections.
	* stabs.c (_bfd_link_section_stabs): Add string offset parameter.
	* libbfd.h: Regenerated.
ld/ChangeLog:
	* ldwrite.c (unsplittable_name): New.
	(clone_section): Strip existing numeric suffix. Only truncate names
	for coff targets.
	(split_sections): Use unsplittable_name.
binutils/ChangeLog:
	* objdump.c (read_section_stabs): Just read one section, return
	pointer to it. Add size parameter.
	(print_section_stabs): Add string offset parameter. Adjust.
	(struct stab_section_names): Add string offset member.
	(find_stabs_sections): Correct check for split section suffix,
	adjust read_section_stabs and print_section_stabs calls.
	(dump_stabs_section): Clear string_offset, free string table.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d172 1
a172 1
_bfd_link_section_stabs (abfd, psinfo, stabsec, stabstrsec, psecinfo)
d178 1
d280 5
a284 1
  next_stroff = 0;
d310 2
@


1.11
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d171 1
a171 1
boolean
d179 1
a179 1
  boolean first;
d193 1
a193 1
      return true;
d199 2
a200 2
         Don't try to optimize them.  */
      return true;
d206 2
a207 2
         prepared to handle them.  */
      return true;
d216 2
a217 2
         link, so we should just ignore them.  */
      return true;
d220 1
a220 1
  first = false;
d225 1
a225 1
      first = true;
d235 1
a235 1
      (void) _bfd_stringtab_add (sinfo->strings, "", true, true);
d302 1
a302 1
             string table.  We only copy the very first one.  */
d311 1
a311 1
	  first = false;
d327 1
a327 1
      *pstridx = _bfd_stringtab_add (sinfo->strings, string, true, true);
d387 1
a387 1
						  true, true);
d396 1
a396 1
             correctly.  */
d505 1
a505 1
  return true;
d512 1
a512 1
  return false;
d518 1
a518 1
   functions and variables.  The function returns true iff
d522 1
a522 1
boolean
d528 1
a528 1
     boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
d542 1
a542 1
      return false;
d548 2
a549 2
         Don't try to optimize them.  */
      return false;
d556 2
a557 2
         link, so we should just ignore them.  */
      return false;
d564 1
a564 1
    return false;
d677 1
a677 1
  return (boolean) (skip > 0);
d682 1
a682 1
  return false;
d688 1
a688 1
boolean
d739 3
a741 3
                 don't really need one, since we have merged all the
                 input stabs sections into one, but we generate one
                 for the benefit of readers which expect to see one.  */
d763 1
a763 1
boolean
d773 1
a773 1
    return true;
d778 1
a778 1
      return true;
d789 1
a789 1
    return false;
d792 1
a792 1
    return false;
d798 1
a798 1
  return true;
@


1.10
log
@	* stabs.c (_bfd_link_section_stabs): Check that the symbol offset
	is within the .stabstr section.
@
text
@d334 1
a334 1
      if (type == N_BINCL)
d354 1
a354 1
	      else if (incl_type == N_EINCL)
d360 1
a360 1
	      else if (incl_type == N_BINCL)
d403 1
a403 1
	  ne->type = N_BINCL;
d425 1
a425 1
	      ne->type = N_EXCL;
d438 1
a438 1
		  if (incl_type == N_EINCL)
d448 1
a448 1
		  else if (incl_type == N_BINCL)
d600 1
a600 1
      if (type == N_FUN)
d627 1
a627 1
	  if (type == N_STSYM || type == N_LCSYM)
d677 1
a677 1
  return (skip > 0);
@


1.10.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d171 2
a172 2
bfd_boolean
_bfd_link_section_stabs (abfd, psinfo, stabsec, stabstrsec, psecinfo, pstring_offset)
a177 1
     bfd_size_type *pstring_offset;
d179 1
a179 1
  bfd_boolean first;
d193 1
a193 1
      return TRUE;
d199 2
a200 2
	 Don't try to optimize them.  */
      return TRUE;
d206 2
a207 2
	 prepared to handle them.  */
      return TRUE;
d216 2
a217 2
	 link, so we should just ignore them.  */
      return TRUE;
d220 1
a220 1
  first = FALSE;
d225 1
a225 1
      first = TRUE;
d235 1
a235 1
      (void) _bfd_stringtab_add (sinfo->strings, "", TRUE, TRUE);
d279 1
a279 5
  /* The stabs sections can be split when
     -split-by-reloc/-split-by-file is used.  We must keep track of
     each stab section's place in the single concatenated string
     table.  */
  next_stroff = pstring_offset ? *pstring_offset : 0;
d302 1
a302 1
	     string table.  We only copy the very first one.  */
a304 2
	  if (pstring_offset)
	    *pstring_offset = next_stroff;
d311 1
a311 1
	  first = FALSE;
d327 1
a327 1
      *pstridx = _bfd_stringtab_add (sinfo->strings, string, TRUE, TRUE);
d334 1
a334 1
      if (type == (int) N_BINCL)
d354 1
a354 3
	      else if (incl_type == (int) N_EXCL)
		continue;
	      else if (incl_type == (int) N_EINCL)
d360 1
a360 1
	      else if (incl_type == (int) N_BINCL)
d387 1
a387 1
						  TRUE, TRUE);
d396 1
a396 1
	     correctly.  */
d403 1
a403 1
	  ne->type = (int) N_BINCL;
d425 1
a425 1
	      ne->type = (int) N_EXCL;
d438 1
a438 1
		  if (incl_type == (int) N_EINCL)
d448 1
a448 1
		  else if (incl_type == (int) N_BINCL)
d505 1
a505 1
  return TRUE;
d512 1
a512 1
  return FALSE;
d518 1
a518 1
   functions and variables.  The function returns TRUE iff
d522 1
a522 1
bfd_boolean
d528 1
a528 1
     bfd_boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
d542 1
a542 1
      return FALSE;
d548 2
a549 2
	 Don't try to optimize them.  */
      return FALSE;
d556 2
a557 2
	 link, so we should just ignore them.  */
      return FALSE;
d564 1
a564 1
    return FALSE;
d600 1
a600 1
      if (type == (int) N_FUN)
d627 1
a627 1
	  if (type == (int) N_STSYM || type == (int) N_LCSYM)
d677 1
a677 1
  return skip > 0;
d682 1
a682 1
  return FALSE;
d688 1
a688 1
bfd_boolean
d739 3
a741 3
		 don't really need one, since we have merged all the
		 input stabs sections into one, but we generate one
		 for the benefit of readers which expect to see one.  */
d763 1
a763 1
bfd_boolean
d773 1
a773 1
    return TRUE;
d778 1
a778 1
      return TRUE;
d789 1
a789 1
    return FALSE;
d792 1
a792 1
    return FALSE;
d798 1
a798 1
  return TRUE;
@


1.10.2.1
log
@Merge from mainline.
@
text
@d334 1
a334 1
      if (type == (int) N_BINCL)
d354 1
a354 1
	      else if (incl_type == (int) N_EINCL)
d360 1
a360 1
	      else if (incl_type == (int) N_BINCL)
d403 1
a403 1
	  ne->type = (int) N_BINCL;
d425 1
a425 1
	      ne->type = (int) N_EXCL;
d438 1
a438 1
		  if (incl_type == (int) N_EINCL)
d448 1
a448 1
		  else if (incl_type == (int) N_BINCL)
d600 1
a600 1
      if (type == (int) N_FUN)
d627 1
a627 1
	  if (type == (int) N_STSYM || type == (int) N_LCSYM)
d677 1
a677 1
  return (boolean) (skip > 0);
@


1.10.12.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d334 1
a334 1
      if (type == (int) N_BINCL)
d354 1
a354 1
	      else if (incl_type == (int) N_EINCL)
d360 1
a360 1
	      else if (incl_type == (int) N_BINCL)
d403 1
a403 1
	  ne->type = (int) N_BINCL;
d425 1
a425 1
	      ne->type = (int) N_EXCL;
d438 1
a438 1
		  if (incl_type == (int) N_EINCL)
d448 1
a448 1
		  else if (incl_type == (int) N_BINCL)
d600 1
a600 1
      if (type == (int) N_FUN)
d627 1
a627 1
	  if (type == (int) N_STSYM || type == (int) N_LCSYM)
d677 1
a677 1
  return (boolean) (skip > 0);
@


1.10.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d171 1
a171 1
bfd_boolean
d179 1
a179 1
  bfd_boolean first;
d193 1
a193 1
      return TRUE;
d199 2
a200 2
	 Don't try to optimize them.  */
      return TRUE;
d206 2
a207 2
	 prepared to handle them.  */
      return TRUE;
d216 2
a217 2
	 link, so we should just ignore them.  */
      return TRUE;
d220 1
a220 1
  first = FALSE;
d225 1
a225 1
      first = TRUE;
d235 1
a235 1
      (void) _bfd_stringtab_add (sinfo->strings, "", TRUE, TRUE);
d302 1
a302 1
	     string table.  We only copy the very first one.  */
d311 1
a311 1
	  first = FALSE;
d327 1
a327 1
      *pstridx = _bfd_stringtab_add (sinfo->strings, string, TRUE, TRUE);
d387 1
a387 1
						  TRUE, TRUE);
d396 1
a396 1
	     correctly.  */
d505 1
a505 1
  return TRUE;
d512 1
a512 1
  return FALSE;
d518 1
a518 1
   functions and variables.  The function returns TRUE iff
d522 1
a522 1
bfd_boolean
d528 1
a528 1
     bfd_boolean (*reloc_symbol_deleted_p) PARAMS ((bfd_vma, PTR));
d542 1
a542 1
      return FALSE;
d548 2
a549 2
	 Don't try to optimize them.  */
      return FALSE;
d556 2
a557 2
	 link, so we should just ignore them.  */
      return FALSE;
d564 1
a564 1
    return FALSE;
d677 1
a677 1
  return skip > 0;
d682 1
a682 1
  return FALSE;
d688 1
a688 1
bfd_boolean
d739 3
a741 3
		 don't really need one, since we have merged all the
		 input stabs sections into one, but we generate one
		 for the benefit of readers which expect to see one.  */
d763 1
a763 1
bfd_boolean
d773 1
a773 1
    return TRUE;
d778 1
a778 1
      return TRUE;
d789 1
a789 1
    return FALSE;
d792 1
a792 1
    return FALSE;
d798 1
a798 1
  return TRUE;
@


1.10.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d172 1
a172 1
_bfd_link_section_stabs (abfd, psinfo, stabsec, stabstrsec, psecinfo, pstring_offset)
a177 1
     bfd_size_type *pstring_offset;
d279 1
a279 5
  /* The stabs sections can be split when
     -split-by-reloc/-split-by-file is used.  We must keep track of
     each stab section's place in the single concatenated string
     table.  */
  next_stroff = pstring_offset ? *pstring_offset : 0;
a304 2
	  if (pstring_offset)
	    *pstring_offset = next_stroff;
@


1.10.12.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a360 2
	      else if (incl_type == (int) N_EXCL)
		continue;
@


1.9
log
@
        * stabs.c (_bfd_discard_section_stabs): Use PARAMS in function
        prototypes.
@
text
@d287 1
d315 12
a326 3
      string = ((char *) stabstrbuf
		+ stroff
		+ bfd_get_32 (abfd, sym + STRDXOFF));
@


1.9.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a286 1
      bfd_size_type symstroff;
d314 3
a316 12
      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);
      if (symstroff >= stabstrsec->_raw_size)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): Stabs entry has invalid string index."),
	     bfd_archive_filename (abfd),
	     bfd_get_section_name (abfd, stabsec),
	     (long) (sym - stabbuf));
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      string = (char *) stabstrbuf + symstroff;
@


1.9.10.2
log
@merge from mainline
@
text
@d334 1
a334 1
      if (type == (int) N_BINCL)
d354 1
a354 1
	      else if (incl_type == (int) N_EINCL)
d360 1
a360 1
	      else if (incl_type == (int) N_BINCL)
d403 1
a403 1
	  ne->type = (int) N_BINCL;
d425 1
a425 1
	      ne->type = (int) N_EXCL;
d438 1
a438 1
		  if (incl_type == (int) N_EINCL)
d448 1
a448 1
		  else if (incl_type == (int) N_BINCL)
d600 1
a600 1
      if (type == (int) N_FUN)
d627 1
a627 1
	  if (type == (int) N_STSYM || type == (int) N_LCSYM)
d677 1
a677 1
  return (boolean) (skip > 0);
@


1.9.8.1
log
@merge from trunk
@
text
@a286 1
      bfd_size_type symstroff;
d314 3
a316 12
      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);
      if (symstroff >= stabstrsec->_raw_size)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): Stabs entry has invalid string index."),
	     bfd_archive_filename (abfd),
	     bfd_get_section_name (abfd, stabsec),
	     (long) (sym - stabbuf));
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      string = (char *) stabstrbuf + symstroff;
@


1.8
log
@2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* bfd-in.h (bfd_elf32_discard_info): Add prototype.
	(bfd_elf64_discard_info): Likewise.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_reloc_cookie): New.
	(struct elf_backend_data): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and elf_backend_write_section.
	(_bfd_elf32_reloc_symbol_deleted_p): Add prototype.
	(_bfd_elf64_reloc_symbol_deleted_p): Likewise.
	* elf32-mips.c (_bfd_elf32_mips_discard_info): New.
	(_bfd_elf32_mips_ignore_discarded_relocs): New.
	(_bfd_elf32_mips_write_section): New.
	(elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	* elfcode.h (elf_bfd_discard_info): Define.
	(elf_reloc_symbol_deleted_p): Define.
	* elflink.h (elf_link_input_bfd): Check
	elf_section_ignore_discarded_relocs.  Call
	bed->elf_backend_write_section if available.
	(elf_reloc_symbol_deleted_p): New.
	(elf_bfd_discard_info): New.
	(elf_section_ignore_discarded_relocs): New.
	* elfxx-target.h (elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	(elfNN_bed): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and
	elf_backend_write_section.
	* libbfd-in.h (_bfd_discard_section_stabs): Add prototype.
	* libbfd.h: Regenerate.
	* stabs.c (_bfd_discard_section_stabs): New.

2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(struct ld_emulation_xfer_struct): Use it.
@
text
@d518 1
a518 1
     boolean (*reloc_symbol_deleted_p) (bfd_vma, PTR);
@


1.7
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d505 170
@


1.6
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d29 1
a29 2

#include <ctype.h>
d366 1
a366 1
			  while (isdigit ((unsigned char) *str))
@


1.5
log
@Update copyright notices
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d182 1
a182 1
  bfd_size_type count;
d227 2
a228 1
      *psinfo = (PTR) bfd_alloc (abfd, sizeof (struct stab_info));
d252 3
a254 3
  *psecinfo = bfd_alloc (abfd,
			 (sizeof (struct stab_section_info)
			  + (count - 1) * sizeof (bfd_size_type)));
d261 1
a261 1
  memset (secinfo->stridxs, 0, count * sizeof (bfd_size_type));
d270 1
a270 1
  if (! bfd_get_section_contents (abfd, stabsec, stabbuf, 0,
d272 1
a272 1
      || ! bfd_get_section_contents (abfd, stabstrsec, stabstrbuf, 0,
d388 2
a389 1
	  ne = (struct stab_excl_list *) bfd_alloc (abfd, sizeof *ne);
d477 2
a478 2
      secinfo->cumulative_skips =
	(bfd_size_type *) bfd_alloc (abfd, count * sizeof (bfd_size_type));
d528 2
a529 1
				     contents, stabsec->output_offset,
d578 1
a578 1
				   contents, stabsec->output_offset,
d607 2
a608 2
		(sinfo->stabstr->output_section->filepos
		 + sinfo->stabstr->output_offset),
@


1.4
log
@2000-12-19  Kazu Hirata  <kazu@@hxi.com>

	* sco5-core.c: Fix formatting.
	* section.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* srec.c: Likewise.
	* stabs.c: Likewise.
	* stab-syms.c: Likewise.
	* sunos.c: Likewise.
	* syms.c: Likewise.
	* sysdep.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@	* stabs.c (_bfd_link_section_stabs): Make sure .stabstr section
	starts with a zero.
@
text
@d111 1
a111 1
     stab. */
d467 1
a467 1
     deleted for this section. */
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d233 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
d622 2
a623 2
     bfd *output_bfd;
     PTR *psinfo;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

