head	1.261;
access;
symbols
	gdb_6_1_1-20040616-release:1.254
	binutils-2_15-branchpoint:1.251
	gdb_6_1-2004-04-05-release:1.254
	drow_intercu-merge-20040327:1.259
	ezannoni_pie-20040323-branch:1.257.0.2
	ezannoni_pie-20040323-branchpoint:1.257
	cagney_tramp-20040321-mergepoint:1.257
	cagney_tramp-20040309-branch:1.254.0.4
	cagney_tramp-20040309-branchpoint:1.254
	gdb_6_1-branch:1.254.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.254
	drow_intercu-20040221-branch:1.251.0.8
	drow_intercu-20040221-branchpoint:1.251
	binutils-2_15-branch:1.251.0.6
	cagney_bfdfile-20040213-branch:1.251.0.4
	cagney_bfdfile-20040213-branchpoint:1.251
	drow-cplus-merge-20040208:1.251
	carlton_dictionary-20040126-merge:1.251
	cagney_bigcore-20040122-branch:1.251.0.2
	cagney_bigcore-20040122-branchpoint:1.251
	drow-cplus-merge-20040113:1.251
	csl-arm-2003-q4:1.250
	drow-cplus-merge-20031224:1.250
	drow-cplus-merge-20031220:1.250
	carlton_dictionary-20031215-merge:1.250
	drow-cplus-merge-20031214:1.250
	carlton-dictionary-20031111-merge:1.247
	gdb_6_0-2003-10-04-release:1.231
	kettenis_sparc-20030918-branch:1.240.0.4
	kettenis_sparc-20030918-branchpoint:1.240
	carlton_dictionary-20030917-merge:1.240
	ezannoni_pie-20030916-branchpoint:1.240
	ezannoni_pie-20030916-branch:1.240.0.2
	cagney_x86i386-20030821-branch:1.239.0.2
	cagney_x86i386-20030821-branchpoint:1.239
	carlton_dictionary-20030805-merge:1.237
	carlton_dictionary-20030627-merge:1.233
	gdb_6_0-branch:1.231.0.2
	gdb_6_0-2003-06-23-branchpoint:1.231
	jimb-ppc64-linux-20030613-branch:1.228.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.228
	binutils-2_14:1.214.2.4
	cagney_convert-20030606-branch:1.228.0.2
	cagney_convert-20030606-branchpoint:1.228
	cagney_writestrings-20030508-branch:1.222.0.4
	cagney_writestrings-20030508-branchpoint:1.222
	jimb-ppc64-linux-20030528-branch:1.225.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.225
	carlton_dictionary-20030523-merge:1.225
	cagney_fileio-20030521-branch:1.225.0.2
	cagney_fileio-20030521-branchpoint:1.225
	kettenis_i386newframe-20030517-mergepoint:1.224
	jimb-ppc64-linux-20030509-branch:1.222.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.222
	kettenis_i386newframe-20030504-mergepoint:1.216
	carlton_dictionary-20030430-merge:1.216
	binutils-2_14-branch:1.214.0.2
	binutils-2_14-branchpoint:1.214
	kettenis_i386newframe-20030419-branch:1.213.0.2
	kettenis_i386newframe-20030419-branchpoint:1.213
	carlton_dictionary-20030416-merge:1.213
	cagney_frameaddr-20030409-mergepoint:1.211
	kettenis_i386newframe-20030406-branch:1.211.0.4
	kettenis_i386newframe-20030406-branchpoint:1.211
	cagney_frameaddr-20030403-branchpoint:1.211
	cagney_frameaddr-20030403-branch:1.211.0.2
	cagney_framebase-20030330-mergepoint:1.210
	cagney_framebase-20030326-branch:1.209.0.8
	cagney_framebase-20030326-branchpoint:1.209
	cagney_lazyid-20030317-branch:1.209.0.6
	cagney_lazyid-20030317-branchpoint:1.209
	kettenis-i386newframe-20030316-mergepoint:1.209
	offbyone-20030313-branch:1.209.0.4
	offbyone-20030313-branchpoint:1.209
	kettenis-i386newframe-20030308-branch:1.209.0.2
	kettenis-i386newframe-20030308-branchpoint:1.209
	carlton_dictionary-20030305-merge:1.208
	cagney_offbyone-20030303-branch:1.208.0.2
	cagney_offbyone-20030303-branchpoint:1.208
	carlton_dictionary-20030207-merge:1.204
	interps-20030202-branch:1.202.0.4
	interps-20030202-branchpoint:1.202
	cagney-unwind-20030108-branch:1.202.0.2
	cagney-unwind-20030108-branchpoint:1.202
	binutils-2_13_2_1:1.174.2.10
	binutils-2_13_2:1.174.2.10
	carlton_dictionary-20021223-merge:1.202
	gdb_5_3-2002-12-12-release:1.185
	carlton_dictionary-20021115-merge:1.196
	binutils-2_13_1:1.174.2.8
	kseitz_interps-20021105-merge:1.193
	kseitz_interps-20021103-merge:1.192
	drow-cplus-merge-20021020:1.191
	drow-cplus-merge-20021025:1.192
	carlton_dictionary-20021025-merge:1.192
	carlton_dictionary-20021011-merge:1.189
	drow-cplus-branch:1.187.0.2
	drow-cplus-branchpoint:1.187
	kseitz_interps-20020930-merge:1.187
	carlton_dictionary-20020927-merge:1.187
	carlton_dictionary-branch:1.186.0.2
	carlton_dictionary-20020920-branchpoint:1.186
	sid-20020905-branchpoint:1.185
	sid-20020905-branch:1.185.0.8
	gdb_5_3-branch:1.185.0.6
	gdb_5_3-2002-09-04-branchpoint:1.185
	kseitz_interps-20020829-merge:1.185
	cagney_sysregs-20020825-branch:1.185.0.4
	cagney_sysregs-20020825-branchpoint:1.185
	readline_4_3-import-branch:1.185.0.2
	readline_4_3-import-branchpoint:1.185
	binutils-2_13:1.174.2.3
	gdb_5_2_1-2002-07-23-release:1.143
	binutils-2_13-branchpoint:1.174
	binutils-2_13-branch:1.174.0.2
	kseitz_interps-20020528-branch:1.162.0.2
	kseitz_interps-20020528-branchpoint:1.162
	cagney_regbuf-20020515-branch:1.159.0.2
	cagney_regbuf-20020515-branchpoint:1.159
	binutils-2_12_1:1.141.2.5
	jimb-macro-020506-branch:1.158.0.2
	jimb-macro-020506-branchpoint:1.158
	gdb_5_2-2002-04-29-release:1.143
	binutils-2_12:1.141.2.1
	gdb_5_2-branch:1.143.0.2
	gdb_5_2-2002-03-03-branchpoint:1.143
	binutils-2_12-branch:1.141.0.2
	binutils-2_12-branchpoint:1.141
	gdb_5_1_1-2002-01-24-release:1.99
	gdb_5_1_0_1-2002-01-03-release:1.99
	cygnus_cvs_20020108_pre:1.138
	gdb_5_1_0_1-2002-01-03-branch:1.99.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.99
	gdb_5_1-2001-11-21-release:1.99
	gdb_s390-2001-09-26-branch:1.99.0.4
	gdb_s390-2001-09-26-branchpoint:1.99
	gdb_5_1-2001-07-29-branch:1.99.0.2
	gdb_5_1-2001-07-29-branchpoint:1.99
	binutils-2_11_2:1.78.2.2
	binutils-2_11_1:1.78.2.2
	binutils-2_11:1.78
	x86_64versiong3:1.81
	binutils-2_11-branch:1.78.0.2
	insight-precleanup-2001-01-01:1.76
	binutils-2_10_1:1.51.2.1
	binutils-2_10:1.51
	gdb-premipsmulti-2000-06-06-branch:1.60.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.60
	gdb_5_0-2000-05-19-release:1.51
	gdb_4_18_2-2000-05-18-release:1.51
	gdb_4_95_1-2000-05-11-snapshot:1.51
	gdb_4_95_0-2000-04-27-snapshot:1.51
	gdb_5_0-2000-04-10-branch:1.51.0.4
	gdb_5_0-2000-04-10-branchpoint:1.51
	binutils-2_10-branch:1.51.0.2
	binutils-2_10-branchpoint:1.51
	binutils_latest_snapshot:1.259
	repo-unification-2000-02-06:1.43
	binu_ss_19990721:1.20
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.261
date	2004.03.27.10.58.08;	author amodra;	state dead;
branches;
next	1.260;

1.260
date	2004.03.27.10.08.59;	author amodra;	state Exp;
branches;
next	1.259;

1.259
date	2004.03.26.05.55.15;	author amodra;	state Exp;
branches;
next	1.258;

1.258
date	2004.03.25.12.48.42;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2004.03.19.01.36.45;	author amodra;	state Exp;
branches;
next	1.256;

1.256
date	2004.03.18.12.50.19;	author amodra;	state Exp;
branches;
next	1.255;

1.255
date	2004.03.18.04.32.17;	author amodra;	state Exp;
branches;
next	1.254;

1.254
date	2004.02.29.06.11.52;	author hjl;	state Exp;
branches
	1.254.4.1;
next	1.253;

1.253
date	2004.02.27.17.02.48;	author hjl;	state Exp;
branches;
next	1.252;

1.252
date	2004.02.23.09.01.58;	author jakub;	state Exp;
branches;
next	1.251;

1.251
date	2004.01.01.10.01.45;	author amodra;	state Exp;
branches
	1.251.6.1
	1.251.8.1;
next	1.250;

1.250
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches;
next	1.249;

1.249
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches;
next	1.248;

1.248
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.247;

1.247
date	2003.11.11.13.32.38;	author nickc;	state Exp;
branches;
next	1.246;

1.246
date	2003.11.04.06.16.34;	author amodra;	state Exp;
branches;
next	1.245;

1.245
date	2003.10.24.14.55.14;	author hjl;	state Exp;
branches;
next	1.244;

1.244
date	2003.10.22.06.58.16;	author jakub;	state Exp;
branches;
next	1.243;

1.243
date	2003.10.16.21.05.32;	author hjl;	state Exp;
branches;
next	1.242;

1.242
date	2003.10.14.22.43.10;	author kkojima;	state Exp;
branches;
next	1.241;

1.241
date	2003.10.07.08.53.41;	author nathan;	state Exp;
branches;
next	1.240;

1.240
date	2003.08.23.04.10.34;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2003.08.20.08.37.19;	author nickc;	state Exp;
branches;
next	1.238;

1.238
date	2003.08.07.08.38.10;	author amodra;	state Exp;
branches;
next	1.237;

1.237
date	2003.08.04.11.32.51;	author nickc;	state Exp;
branches;
next	1.236;

1.236
date	2003.08.04.09.39.46;	author amodra;	state Exp;
branches;
next	1.235;

1.235
date	2003.07.10.00.37.27;	author amodra;	state Exp;
branches;
next	1.234;

1.234
date	2003.07.04.01.50.11;	author amodra;	state Exp;
branches;
next	1.233;

1.233
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.232;

1.232
date	2003.06.23.23.39.39;	author hjl;	state Exp;
branches;
next	1.231;

1.231
date	2003.06.18.05.18.06;	author amodra;	state Exp;
branches;
next	1.230;

1.230
date	2003.06.18.00.30.03;	author hjl;	state Exp;
branches;
next	1.229;

1.229
date	2003.06.17.09.57.18;	author nickc;	state Exp;
branches;
next	1.228;

1.228
date	2003.06.03.22.27.22;	author jakub;	state Exp;
branches;
next	1.227;

1.227
date	2003.06.03.18.15.04;	author hjl;	state Exp;
branches;
next	1.226;

1.226
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.225;

1.225
date	2003.05.20.14.35.00;	author hjl;	state Exp;
branches;
next	1.224;

1.224
date	2003.05.17.06.16.03;	author amodra;	state Exp;
branches;
next	1.223;

1.223
date	2003.05.15.13.48.53;	author hjl;	state Exp;
branches;
next	1.222;

1.222
date	2003.05.09.02.26.52;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2003.05.08.19.54.33;	author hjl;	state Exp;
branches;
next	1.220;

1.220
date	2003.05.08.05.11.57;	author hjl;	state Exp;
branches;
next	1.219;

1.219
date	2003.05.05.05.46.52;	author hjl;	state Exp;
branches;
next	1.218;

1.218
date	2003.05.05.03.33.08;	author hjl;	state Exp;
branches;
next	1.217;

1.217
date	2003.05.05.00.37.02;	author hjl;	state Exp;
branches;
next	1.216;

1.216
date	2003.04.28.16.58.01;	author hjl;	state Exp;
branches;
next	1.215;

1.215
date	2003.04.28.03.31.36;	author hjl;	state Exp;
branches;
next	1.214;

1.214
date	2003.04.25.15.17.51;	author hjl;	state Exp;
branches
	1.214.2.1;
next	1.213;

1.213
date	2003.04.15.09.38.11;	author nickc;	state Exp;
branches
	1.213.2.1;
next	1.212;

1.212
date	2003.04.14.11.06.25;	author nickc;	state Exp;
branches;
next	1.211;

1.211
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.210;

1.210
date	2003.03.29.01.26.33;	author hjl;	state Exp;
branches;
next	1.209;

1.209
date	2003.03.06.15.47.23;	author aph;	state Exp;
branches
	1.209.8.1;
next	1.208;

1.208
date	2003.02.25.04.39.32;	author amodra;	state Exp;
branches;
next	1.207;

1.207
date	2003.02.25.04.14.38;	author amodra;	state Exp;
branches;
next	1.206;

1.206
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.205;

1.205
date	2003.02.13.22.14.10;	author jakub;	state Exp;
branches;
next	1.204;

1.204
date	2003.02.04.12.49.57;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.202;

1.202
date	2002.12.23.11.53.59;	author amodra;	state Exp;
branches;
next	1.201;

1.201
date	2002.12.12.10.26.01;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.199;

1.199
date	2002.11.28.11.55.43;	author amodra;	state Exp;
branches;
next	1.198;

1.198
date	2002.11.26.11.53.59;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2002.11.21.18.52.36;	author rth;	state Exp;
branches;
next	1.196;

1.196
date	2002.11.12.07.55.43;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2002.11.12.07.35.26;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2002.11.12.06.21.05;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2002.11.04.13.20.56;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2002.10.22.21.00.10;	author aoliva;	state Exp;
branches;
next	1.191;

1.191
date	2002.10.19.17.13.58;	author hjl;	state Exp;
branches;
next	1.190;

1.190
date	2002.10.16.00.57.39;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2002.10.07.00.14.28;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2002.09.23.10.52.03;	author amodra;	state Exp;
branches
	1.187.2.1;
next	1.186;

1.186
date	2002.09.19.16.34.14;	author nickc;	state Exp;
branches
	1.186.2.1;
next	1.185;

1.185
date	2002.08.22.01.27.19;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2002.08.14.03.25.48;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2002.08.12.19.23.33;	author hjl;	state Exp;
branches;
next	1.182;

1.182
date	2002.08.09.04.40.29;	author hjl;	state Exp;
branches;
next	1.181;

1.181
date	2002.08.08.03.50.16;	author hjl;	state Exp;
branches;
next	1.180;

1.180
date	2002.08.08.00.20.16;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2002.07.25.06.54.51;	author amodra;	state Exp;
branches;
next	1.178;

1.178
date	2002.07.23.04.38.17;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2002.07.16.12.31.35;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2002.07.16.09.00.42;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2002.07.15.02.23.26;	author hjl;	state Exp;
branches;
next	1.174;

1.174
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches
	1.174.2.1;
next	1.173;

1.173
date	2002.07.04.13.26.30;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2002.07.01.08.06.46;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2002.06.25.09.40.43;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2002.06.23.12.44.31;	author amodra;	state Exp;
branches;
next	1.168;

1.168
date	2002.06.23.02.04.28;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2002.06.19.10.07.36;	author nickc;	state Exp;
branches;
next	1.166;

1.166
date	2002.06.12.18.14.05;	author law;	state Exp;
branches;
next	1.165;

1.165
date	2002.06.07.14.57.11;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2002.06.06.00.29.20;	author amodra;	state Exp;
branches;
next	1.163;

1.163
date	2002.06.05.13.31.57;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2002.05.23.13.12.46;	author jakub;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2002.05.21.16.03.46;	author ths;	state Exp;
branches;
next	1.160;

1.160
date	2002.05.15.00.18.56;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2002.05.07.00.16.52;	author amodra;	state Exp;
branches
	1.159.2.1;
next	1.158;

1.158
date	2002.05.06.08.54.44;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2002.04.26.12.59.23;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2002.03.26.18.13.54;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2002.03.26.16.01.04;	author hjl;	state Exp;
branches;
next	1.153;

1.153
date	2002.03.26.11.54.11;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2002.03.19.20.21.54;	author hp;	state Exp;
branches;
next	1.151;

1.151
date	2002.03.14.19.06.16;	author hjl;	state Exp;
branches;
next	1.150;

1.150
date	2002.03.14.10.38.31;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2002.03.13.07.26.24;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2002.03.13.04.04.49;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2002.03.13.03.42.39;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2002.03.13.02.56.08;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2002.03.05.05.18.41;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2002.03.04.20.41.55;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2002.03.02.01.24.50;	author rth;	state Exp;
branches;
next	1.142;

1.142
date	2002.02.25.23.31.22;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2002.01.21.10.29.07;	author amodra;	state Exp;
branches
	1.141.2.1;
next	1.140;

1.140
date	2002.01.16.05.37.10;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2002.01.15.12.52.14;	author jakub;	state Exp;
branches;
next	1.138;

1.138
date	2002.01.07.17.55.37;	author geoffk;	state Exp;
branches;
next	1.137;

1.137
date	2001.12.31.11.49.09;	author jakub;	state Exp;
branches;
next	1.136;

1.136
date	2001.12.18.12.15.34;	author jakub;	state Exp;
branches;
next	1.135;

1.135
date	2001.12.17.22.44.12;	author jakub;	state Exp;
branches;
next	1.134;

1.134
date	2001.12.17.00.52.34;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2001.12.15.08.54.13;	author jakub;	state Exp;
branches;
next	1.132;

1.132
date	2001.12.14.01.52.27;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	1.130;

1.130
date	2001.11.30.15.50.56;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2001.11.27.19.03.27;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2001.11.23.12.17.15;	author jakub;	state Exp;
branches;
next	1.127;

1.127
date	2001.11.20.00.54.51;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2001.11.16.02.56.08;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2001.11.15.09.31.25;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2001.11.15.01.34.10;	author drow;	state Exp;
branches;
next	1.123;

1.123
date	2001.11.10.00.23.35;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2001.11.07.16.50.36;	author jakub;	state Exp;
branches;
next	1.121;

1.121
date	2001.11.07.04.07.09;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2001.11.06.17.49.38;	author hjl;	state Exp;
branches;
next	1.119;

1.119
date	2001.10.31.16.42.48;	author hjl;	state Exp;
branches;
next	1.118;

1.118
date	2001.10.23.03.55.24;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2001.10.17.01.44.10;	author jeffh;	state Exp;
branches;
next	1.115;

1.115
date	2001.10.16.06.33.52;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2001.10.10.19.32.02;	author jakub;	state Exp;
branches;
next	1.113;

1.113
date	2001.10.09.06.05.15;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2001.10.06.07.25.40;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2001.10.03.08.33.18;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2001.09.29.12.07.00;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2001.09.29.06.21.58;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2001.09.18.07.55.39;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2001.08.31.16.16.14;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2001.08.24.16.36.04;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2001.08.24.11.17.28;	author jakub;	state Exp;
branches;
next	1.101;

1.101
date	2001.08.23.15.14.15;	author jakub;	state Exp;
branches;
next	1.100;

1.100
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2001.06.29.07.00.33;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2001.06.20.20.34.10;	author clm;	state Exp;
branches;
next	1.97;

1.97
date	2001.06.18.22.05.10;	author hp;	state Exp;
branches;
next	1.96;

1.96
date	2001.06.18.18.57.06;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2001.06.12.17.44.37;	author clm;	state Exp;
branches;
next	1.94;

1.94
date	2001.06.10.05.20.59;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2001.05.28.11.57.54;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2001.05.18.16.06.43;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2001.05.18.01.20.02;	author hjl;	state Exp;
branches;
next	1.89;

1.89
date	2001.05.17.19.08.46;	author hjl;	state Exp;
branches;
next	1.88;

1.88
date	2001.05.09.22.34.30;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2001.05.03.06.18.09;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2001.04.30.16.13.26;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2001.04.13.00.34.35;	author jakub;	state Exp;
branches;
next	1.84;

1.84
date	2001.04.09.03.24.32;	author hp;	state Exp;
branches;
next	1.83;

1.83
date	2001.04.04.00.31.37;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2001.02.18.22.04.08;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2001.02.12.00.23.37;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2001.02.07.23.42.15;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2001.01.03.22.53.38;	author kazu;	state Exp;
branches;
next	1.76;

1.76
date	2000.12.12.20.53.01;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2000.11.13.22.49.54;	author hjl;	state Exp;
branches;
next	1.74;

1.74
date	2000.10.12.03.44.50;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2000.10.07.13.40.33;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2000.09.29.13.15.03;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2000.08.24.17.41.40;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2000.08.22.19.33.16;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2000.07.28.00.49.07;	author hjl;	state Exp;
branches;
next	1.68;

1.68
date	2000.07.27.22.35.08;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2000.07.21.03.58.32;	author hjl;	state Exp;
branches;
next	1.66;

1.66
date	2000.07.21.02.16.31;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2000.07.20.21.16.58;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2000.07.20.03.16.18;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2000.06.19.00.18.58;	author ulfc;	state Exp;
branches;
next	1.61;

1.61
date	2000.06.16.23.01.00;	author ulfc;	state Exp;
branches;
next	1.60;

1.60
date	2000.06.05.18.15.35;	author hjl;	state Exp;
branches;
next	1.59;

1.59
date	2000.06.05.17.21.32;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2000.05.30.20.51.36;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2000.05.22.07.26.58;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2000.05.18.17.12.31;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.17.19.55.14;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2000.05.17.19.38.53;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.04.06.38.33;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2000.04.27.00.31.16;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2000.02.22.08.06.01;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2000.02.22.05.51.02;	author ian;	state Exp;
branches;
next	1.47;

1.47
date	2000.02.21.12.01.25;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2000.02.18.09.23.06;	author rth;	state Exp;
branches;
next	1.45;

1.45
date	2000.02.13.23.11.32;	author rth;	state Exp;
branches;
next	1.44;

1.44
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.43;

1.43
date	2000.01.03.18.32.21;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	99.12.29.19.50.13;	author rth;	state Exp;
branches;
next	1.41;

1.41
date	99.12.14.23.35.43;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	99.12.14.02.20.57;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	99.12.10.20.17.28;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	99.12.10.18.51.34;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	99.12.10.01.41.21;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	99.10.28.04.08.57;	author ian;	state Exp;
branches;
next	1.35;

1.35
date	99.10.08.15.21.56;	author ian;	state Exp;
branches;
next	1.34;

1.34
date	99.09.10.04.22.23;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	99.09.06.10.56.08;	author schwab;	state Exp;
branches;
next	1.32;

1.32
date	99.09.06.08.57.49;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	99.09.04.16.26.08;	author ian;	state Exp;
branches;
next	1.30;

1.30
date	99.09.03.18.34.02;	author ian;	state Exp;
branches;
next	1.29;

1.29
date	99.09.02.23.44.54;	author law;	state Exp;
branches;
next	1.28;

1.28
date	99.09.02.17.56.51;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	99.08.31.14.07.27;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	99.08.17.07.50.30;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	99.08.10.06.22.57;	author mmitchel;	state Exp;
branches;
next	1.24;

1.24
date	99.08.10.03.36.28;	author mmitchel;	state Exp;
branches;
next	1.23;

1.23
date	99.08.09.05.42.31;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	99.08.02.22.31.18;	author rth;	state Exp;
branches;
next	1.21;

1.21
date	99.07.30.21.34.44;	author rth;	state Exp;
branches;
next	1.20;

1.20
date	99.07.19.19.08.33;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	99.07.19.09.11.14;	author schwab;	state Exp;
branches;
next	1.18;

1.18
date	99.07.18.06.31.28;	author mmitchel;	state Exp;
branches;
next	1.17;

1.17
date	99.07.16.08.10.27;	author schwab;	state Exp;
branches;
next	1.16;

1.16
date	99.07.13.18.21.29;	author rth;	state Exp;
branches;
next	1.15;

1.15
date	99.07.11.19.49.35;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	99.07.11.17.13.36;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.07.11.00.12.14;	author mmitchel;	state Exp;
branches;
next	1.12;

1.12
date	99.07.07.17.50.48;	author mmitchel;	state Exp;
branches;
next	1.11;

1.11
date	99.07.07.15.29.06;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.07.07.11.39.43;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.01.23.20.07;	author mmitchel;	state Exp;
branches;
next	1.8;

1.8
date	99.06.26.09.00.19;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.23.11.06.56;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	99.06.22.13.57.15;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	99.06.19.14.10.28;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.13.18.35.29;	author mmitchel;	state Exp;
branches;
next	1.3;

1.3
date	99.06.13.14.49.48;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	99.06.13.01.13.24;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;

1.51.2.1
date	2000.10.16.17.57.08;	author pb;	state Exp;
branches;
next	;

1.78.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.78.2.2;

1.78.2.2
date	2001.06.11.10.04.15;	author amodra;	state Exp;
branches;
next	;

1.141.2.1
date	2002.02.25.23.35.03;	author amodra;	state Exp;
branches;
next	1.141.2.2;

1.141.2.2
date	2002.03.28.06.20.03;	author amodra;	state Exp;
branches;
next	1.141.2.3;

1.141.2.3
date	2002.04.04.14.53.00;	author amodra;	state Exp;
branches;
next	1.141.2.4;

1.141.2.4
date	2002.04.27.08.30.13;	author amodra;	state Exp;
branches;
next	1.141.2.5;

1.141.2.5
date	2002.05.09.11.50.29;	author amodra;	state Exp;
branches;
next	;

1.159.2.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	1.159.2.2;

1.159.2.2
date	2002.06.21.15.56.25;	author cagney;	state Exp;
branches;
next	;

1.162.2.1
date	2002.06.20.01.30.46;	author kseitz;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.162.2.3;

1.162.2.3
date	2002.08.09.18.34.16;	author kseitz;	state Exp;
branches;
next	1.162.2.4;

1.162.2.4
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	1.162.2.5;

1.162.2.5
date	2002.10.01.00.45.48;	author kseitz;	state Exp;
branches;
next	1.162.2.6;

1.162.2.6
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	1.162.2.7;

1.162.2.7
date	2002.11.05.20.33.25;	author ezannoni;	state Exp;
branches;
next	;

1.174.2.1
date	2002.07.16.09.03.12;	author amodra;	state Exp;
branches;
next	1.174.2.2;

1.174.2.2
date	2002.07.23.04.42.39;	author amodra;	state Exp;
branches;
next	1.174.2.3;

1.174.2.3
date	2002.07.30.18.19.42;	author drow;	state Exp;
branches;
next	1.174.2.4;

1.174.2.4
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	1.174.2.5;

1.174.2.5
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	1.174.2.6;

1.174.2.6
date	2002.10.07.00.15.53;	author amodra;	state Exp;
branches;
next	1.174.2.7;

1.174.2.7
date	2002.10.11.08.56.14;	author amodra;	state Exp;
branches;
next	1.174.2.8;

1.174.2.8
date	2002.10.28.18.45.44;	author drow;	state Exp;
branches;
next	1.174.2.9;

1.174.2.9
date	2002.11.11.15.35.43;	author nickc;	state Exp;
branches;
next	1.174.2.10;

1.174.2.10
date	2002.11.21.18.54.24;	author rth;	state Exp;
branches;
next	;

1.186.2.1
date	2002.09.27.20.02.55;	author carlton;	state Exp;
branches;
next	1.186.2.2;

1.186.2.2
date	2002.10.11.22.22.49;	author carlton;	state Exp;
branches;
next	1.186.2.3;

1.186.2.3
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.186.2.4;

1.186.2.4
date	2002.11.15.19.18.28;	author carlton;	state Exp;
branches;
next	1.186.2.5;

1.186.2.5
date	2002.12.23.19.37.50;	author carlton;	state Exp;
branches;
next	1.186.2.6;

1.186.2.6
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.186.2.7;

1.186.2.7
date	2003.03.06.00.56.17;	author carlton;	state Exp;
branches;
next	1.186.2.8;

1.186.2.8
date	2003.04.16.19.56.45;	author carlton;	state Exp;
branches;
next	1.186.2.9;

1.186.2.9
date	2003.05.01.00.46.42;	author carlton;	state Exp;
branches;
next	1.186.2.10;

1.186.2.10
date	2003.05.23.18.40.28;	author carlton;	state Exp;
branches;
next	1.186.2.11;

1.186.2.11
date	2003.06.27.21.49.24;	author carlton;	state Exp;
branches;
next	1.186.2.12;

1.186.2.12
date	2003.08.05.17.12.53;	author carlton;	state Exp;
branches;
next	1.186.2.13;

1.186.2.13
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.186.2.14;

1.186.2.14
date	2003.11.11.23.50.25;	author carlton;	state Exp;
branches;
next	1.186.2.15;

1.186.2.15
date	2003.12.15.23.59.42;	author carlton;	state Exp;
branches;
next	1.186.2.16;

1.186.2.16
date	2004.01.26.19.11.06;	author carlton;	state Exp;
branches;
next	;

1.187.2.1
date	2002.10.26.17.11.59;	author drow;	state Exp;
branches;
next	1.187.2.2;

1.187.2.2
date	2003.12.14.20.26.45;	author drow;	state Exp;
branches;
next	1.187.2.3;

1.187.2.3
date	2004.01.13.16.11.38;	author drow;	state Exp;
branches;
next	;

1.209.8.1
date	2003.03.30.16.35.17;	author cagney;	state Exp;
branches;
next	;

1.213.2.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.213.2.2;

1.213.2.2
date	2003.05.18.09.43.48;	author kettenis;	state Exp;
branches;
next	;

1.214.2.1
date	2003.05.03.16.01.00;	author drow;	state Exp;
branches;
next	1.214.2.2;

1.214.2.2
date	2003.05.06.01.16.46;	author drow;	state Exp;
branches;
next	1.214.2.3;

1.214.2.3
date	2003.05.15.19.20.23;	author drow;	state Exp;
branches;
next	1.214.2.4;

1.214.2.4
date	2003.06.02.18.07.44;	author drow;	state Exp;
branches;
next	1.214.2.5;

1.214.2.5
date	2003.06.17.09.56.14;	author nickc;	state Exp;
branches;
next	1.214.2.6;

1.214.2.6
date	2003.06.18.05.18.35;	author amodra;	state Exp;
branches;
next	;

1.251.6.1
date	2004.04.09.18.28.01;	author drow;	state Exp;
branches;
next	1.251.6.2;

1.251.6.2
date	2004.04.13.12.17.11;	author amodra;	state dead;
branches;
next	;

1.251.8.1
date	2004.03.27.17.37.36;	author drow;	state Exp;
branches;
next	1.251.8.2;

1.251.8.2
date	2004.04.02.16.47.37;	author drow;	state dead;
branches;
next	;

1.254.4.1
date	2004.03.21.23.57.28;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.261
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@/* ELF linker support.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* ELF linker code.  */

static bfd_boolean elf_section_ignore_discarded_relocs (asection *);

/* Final phase of ELF linker.  */

/* A structure we use to avoid passing large numbers of arguments.  */

struct elf_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Symbol string table.  */
  struct bfd_strtab_hash *symstrtab;
  /* .dynsym section.  */
  asection *dynsym_sec;
  /* .hash section.  */
  asection *hash_sec;
  /* symbol version section (.gnu.version).  */
  asection *symver_sec;
  /* Buffer large enough to hold contents of any section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any section.  */
  void *external_relocs;
  /* Buffer large enough to hold internal relocs of any section.  */
  Elf_Internal_Rela *internal_relocs;
  /* Buffer large enough to hold external local symbols of any input
     BFD.  */
  bfd_byte *external_syms;
  /* And a buffer for symbol section indices.  */
  Elf_External_Sym_Shndx *locsym_shndx;
  /* Buffer large enough to hold internal local symbols of any input
     BFD.  */
  Elf_Internal_Sym *internal_syms;
  /* Array large enough to hold a symbol index for each local symbol
     of any input BFD.  */
  long *indices;
  /* Array large enough to hold a section pointer for each local
     symbol of any input BFD.  */
  asection **sections;
  /* Buffer to hold swapped out symbols.  */
  bfd_byte *symbuf;
  /* And one for symbol section indices.  */
  Elf_External_Sym_Shndx *symshndxbuf;
  /* Number of swapped out symbols in buffer.  */
  size_t symbuf_count;
  /* Number of symbols which fit in symbuf.  */
  size_t symbuf_size;
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
};

static bfd_boolean elf_link_output_sym
  (struct elf_final_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
static bfd_boolean elf_link_flush_output_syms
  (struct elf_final_link_info *, const struct elf_backend_data *);
static bfd_boolean elf_link_output_extsym
  (struct elf_link_hash_entry *, void *);
static bfd_boolean elf_link_input_bfd
  (struct elf_final_link_info *, bfd *);
static bfd_boolean elf_reloc_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);

/* This struct is used to pass information to elf_link_output_extsym.  */

struct elf_outext_info
{
  bfd_boolean failed;
  bfd_boolean localsyms;
  struct elf_final_link_info *finfo;
};

/* When performing a relocatable link, the input relocations are
   preserved.  But, if they reference global symbols, the indices
   referenced must be updated.  Update all the relocations in
   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */

static void
elf_link_adjust_relocs (bfd *abfd,
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
{
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  bfd_vma r_type_mask;
  int r_sym_shift;

  if (rel_hdr->sh_entsize == bed->s->sizeof_rel)
    {
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (rel_hdr->sh_entsize == bed->s->sizeof_rela)
    {
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    abort ();

  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
    }

  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
    {
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

      if (*rel_hash == NULL)
	continue;

      BFD_ASSERT ((*rel_hash)->indx >= 0);

      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ((bfd_vma) (*rel_hash)->indx << r_sym_shift
			   | (irela[j].r_info & r_type_mask));
      (*swap_out) (abfd, irela, erela);
    }
}

struct elf_link_sort_rela
{
  union {
    bfd_vma offset;
    bfd_vma sym_mask;
  } u;
  enum elf_reloc_type_class type;
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
};

static int
elf_link_sort_cmp1 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int relativea, relativeb;

  relativea = a->type == reloc_class_relative;
  relativeb = b->type == reloc_class_relative;

  if (relativea < relativeb)
    return 1;
  if (relativea > relativeb)
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static int
elf_link_sort_cmp2 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int copya, copyb;

  if (a->u.offset < b->u.offset)
    return -1;
  if (a->u.offset > b->u.offset)
    return 1;
  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
  if (copya < copyb)
    return -1;
  if (copya > copyb)
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static size_t
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
{
  asection *reldyn;
  bfd_size_type count, size;
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int i2e = bed->s->int_rels_per_ext_rel;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
  bfd_vma r_sym_mask;

  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  if (reldyn == NULL || reldyn->_raw_size == 0)
    {
      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
      if (reldyn == NULL || reldyn->_raw_size == 0)
	return 0;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else
    {
      ext_size = bed->s->sizeof_rela;
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  count = reldyn->_raw_size / ext_size;

  size = 0;
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	asection *o = lo->u.indirect.section;
	size += o->_raw_size;
      }

  if (size != reldyn->_raw_size)
    return 0;

  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
  sort = bfd_zmalloc (sort_elt * count);
  if (sort == NULL)
    {
      (*info->callbacks->warning)
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
      return 0;
    }

  if (bed->s->arch_size == 32)
    r_sym_mask = ~(bfd_vma) 0xff;
  else
    r_sym_mask = ~(bfd_vma) 0xffffffff;

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
	    s->u.sym_mask = r_sym_mask;
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  qsort (sort, count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (((sp->rela->r_info ^ sq->rela->r_info) & r_sym_mask) != 0)
	sq = sp;
      sp->u.offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  free (sort);
  *psec = reldyn;
  return ret;
}

/* Do the final step of an ELF link.  */

bfd_boolean
elf_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
  bfd *dynobj;
  struct elf_final_link_info finfo;
  register asection *o;
  register struct bfd_link_order *p;
  register bfd *sub;
  bfd_size_type max_contents_size;
  bfd_size_type max_external_reloc_size;
  bfd_size_type max_internal_reloc_count;
  bfd_size_type max_sym_count;
  bfd_size_type max_sym_shndx_count;
  file_ptr off;
  Elf_Internal_Sym elfsym;
  unsigned int i;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_outext_info eoinfo;
  bfd_boolean merged;
  size_t relativecount = 0;
  asection *reldyn = 0;
  bfd_size_type amt;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  dynamic = elf_hash_table (info)->dynamic_sections_created;
  dynobj = elf_hash_table (info)->dynobj;

  emit_relocs = (info->relocatable
		 || info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.symstrtab = _bfd_elf_stringtab_init ();
  if (finfo.symstrtab == NULL)
    return FALSE;

  if (! dynamic)
    {
      finfo.dynsym_sec = NULL;
      finfo.hash_sec = NULL;
      finfo.symver_sec = NULL;
    }
  else
    {
      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
      /* Note that it is OK if symver_sec is NULL.  */
    }

  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  finfo.external_syms = NULL;
  finfo.locsym_shndx = NULL;
  finfo.internal_syms = NULL;
  finfo.indices = NULL;
  finfo.sections = NULL;
  finfo.symbuf = NULL;
  finfo.symshndxbuf = NULL;
  finfo.symbuf_count = 0;
  finfo.shndxbuf_size = 0;

  /* Count up the number of relocations we will output for each output
     section, so that we know the sizes of the reloc sections.  We
     also figure out some maximum sizes.  */
  max_contents_size = 0;
  max_external_reloc_size = 0;
  max_internal_reloc_count = 0;
  max_sym_count = 0;
  max_sym_shndx_count = 0;
  merged = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      o->reloc_count = 0;

      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;
	  unsigned int *rel_count1;

	  if (p->type == bfd_section_reloc_link_order
	      || p->type == bfd_symbol_reloc_link_order)
	    reloc_count = 1;
	  else if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;
	      esdi = elf_section_data (sec);

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (sec->flags & SEC_MERGE)
		merged = TRUE;

	      if (info->relocatable || info->emitrelocations)
		reloc_count = sec->reloc_count;
	      else if (bed->elf_backend_count_relocs)
		{
		  Elf_Internal_Rela * relocs;

		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						      info->keep_memory);

		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);

		  if (elf_section_data (o)->relocs != relocs)
		    free (relocs);
		}

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->_cooked_size > max_contents_size)
		max_contents_size = sec->_cooked_size;

	      /* We are interested in just local symbols, not all
		 symbols.  */
	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
		  && (sec->owner->flags & DYNAMIC) == 0)
		{
		  size_t sym_count;

		  if (elf_bad_symtab (sec->owner))
		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
				 / bed->s->sizeof_sym);
		  else
		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;

		  if (sym_count > max_sym_count)
		    max_sym_count = sym_count;

		  if (sym_count > max_sym_shndx_count
		      && elf_symtab_shndx (sec->owner) != 0)
		    max_sym_shndx_count = sym_count;

		  if ((sec->flags & SEC_RELOC) != 0)
		    {
		      size_t ext_size;

		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
		      if (ext_size > max_external_reloc_size)
			max_external_reloc_size = ext_size;
		      if (sec->reloc_count > max_internal_reloc_count)
			max_internal_reloc_count = sec->reloc_count;
		    }
		}
	    }

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      BFD_ASSERT (entsize1 == bed->s->sizeof_rel
			  || entsize1 == bed->s->sizeof_rela);
	      same_size = !o->use_rela_p == (entsize1 == bed->s->sizeof_rel);

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == bed->s->sizeof_rel
				  || entsize2 == bed->s->sizeof_rela));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
	    }
	  *rel_count1 += reloc_count;
	}

      if (o->reloc_count > 0)
	o->flags |= SEC_RELOC;
      else
	{
	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
	     set it (this is probably a bug) and if it is set
	     assign_section_numbers will create a reloc section.  */
	  o->flags &=~ SEC_RELOC;
	}

      /* If the SEC_ALLOC flag is not set, force the section VMA to
	 zero.  This is done in elf_fake_sections as well, but forcing
	 the VMA to 0 here will ensure that relocs against these
	 sections are handled correctly.  */
      if ((o->flags & SEC_ALLOC) == 0
	  && ! o->user_set_vma)
	o->vma = 0;
    }

  if (! info->relocatable && merged)
    elf_link_hash_traverse (elf_hash_table (info),
			    _bfd_elf_link_sec_merge_syms, abfd);

  /* Figure out the file positions for everything but the symbol table
     and the relocs.  We set symcount to force assign_section_numbers
     to create a symbol table.  */
  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
  BFD_ASSERT (! abfd->output_has_begun);
  if (! _bfd_elf_compute_section_file_positions (abfd, info))
    goto error_return;

  /* That created the reloc sections.  Set their sizes, and assign
     them file positions, and allocate some buffers.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0)
	{
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
	    goto error_return;

	  if (elf_section_data (o)->rel_hdr2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
	    goto error_return;
	}

      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
	 to count upwards while actually outputting the relocations.  */
      elf_section_data (o)->rel_count = 0;
      elf_section_data (o)->rel_count2 = 0;
    }

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* We have now assigned file positions for all the sections except
     .symtab and .strtab.  We start the .symtab section at the current
     file position, and write directly to it.  We build the .strtab
     section in memory.  */
  bfd_get_symcount (abfd) = 0;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  /* sh_name is set in prep_headers.  */
  symtab_hdr->sh_type = SHT_SYMTAB;
  /* sh_flags, sh_addr and sh_size all start off zero.  */
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  /* sh_link is set in assign_section_numbers.  */
  /* sh_info is set below.  */
  /* sh_offset is set just below.  */
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;

  off = elf_tdata (abfd)->next_file_pos;
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);

  /* Note that at this point elf_tdata (abfd)->next_file_pos is
     incorrect.  We do not yet know the size of the .symtab section.
     We correct next_file_pos below, after we do know the size.  */

  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
     continuously seeking to the right position in the file.  */
  if (! info->keep_memory || max_sym_count < 20)
    finfo.symbuf_size = 20;
  else
    finfo.symbuf_size = max_sym_count;
  amt = finfo.symbuf_size;
  amt *= bed->s->sizeof_sym;
  finfo.symbuf = bfd_malloc (amt);
  if (finfo.symbuf == NULL)
    goto error_return;
  if (elf_numsections (abfd) > SHN_LORESERVE)
    {
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
      amt *= sizeof (Elf_External_Sym_Shndx);
      finfo.symshndxbuf = bfd_zmalloc (amt);
      if (finfo.symshndxbuf == NULL)
	goto error_return;
    }

  /* Start writing out the symbol table.  The first symbol is always a
     dummy symbol.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_value = 0;
      elfsym.st_size = 0;
      elfsym.st_info = 0;
      elfsym.st_other = 0;
      elfsym.st_shndx = SHN_UNDEF;
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
	goto error_return;
    }

#if 0
  /* Some standard ELF linkers do this, but we don't because it causes
     bootstrap comparison failures.  */
  /* Output a file symbol for the output file as the second symbol.
     We output this even if we are discarding local symbols, although
     I'm not sure if this is correct.  */
  elfsym.st_value = 0;
  elfsym.st_size = 0;
  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
  elfsym.st_other = 0;
  elfsym.st_shndx = SHN_ABS;
  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
			     &elfsym, bfd_abs_section_ptr, NULL))
    goto error_return;
#endif

  /* Output a symbol for each section.  We output these even if we are
     discarding local symbols, since they are used for relocs.  These
     symbols have no names.  We store the index of each one in the
     index field of the section, so that we can find it again when
     outputting relocs.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_size = 0;
      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      elfsym.st_other = 0;
      for (i = 1; i < elf_numsections (abfd); i++)
	{
	  o = bfd_section_from_elf_index (abfd, i);
	  if (o != NULL)
	    o->target_index = bfd_get_symcount (abfd);
	  elfsym.st_shndx = i;
	  if (info->relocatable || o == NULL)
	    elfsym.st_value = 0;
	  else
	    elfsym.st_value = o->vma;
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
	    goto error_return;
	  if (i == SHN_LORESERVE - 1)
	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
    }

  /* Allocate some memory to hold information read in from the input
     files.  */
  if (max_contents_size != 0)
    {
      finfo.contents = bfd_malloc (max_contents_size);
      if (finfo.contents == NULL)
	goto error_return;
    }

  if (max_external_reloc_size != 0)
    {
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (finfo.external_relocs == NULL)
	goto error_return;
    }

  if (max_internal_reloc_count != 0)
    {
      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
      amt *= sizeof (Elf_Internal_Rela);
      finfo.internal_relocs = bfd_malloc (amt);
      if (finfo.internal_relocs == NULL)
	goto error_return;
    }

  if (max_sym_count != 0)
    {
      amt = max_sym_count * bed->s->sizeof_sym;
      finfo.external_syms = bfd_malloc (amt);
      if (finfo.external_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (Elf_Internal_Sym);
      finfo.internal_syms = bfd_malloc (amt);
      if (finfo.internal_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (long);
      finfo.indices = bfd_malloc (amt);
      if (finfo.indices == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (asection *);
      finfo.sections = bfd_malloc (amt);
      if (finfo.sections == NULL)
	goto error_return;
    }

  if (max_sym_shndx_count != 0)
    {
      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
      finfo.locsym_shndx = bfd_malloc (amt);
      if (finfo.locsym_shndx == NULL)
	goto error_return;
    }

  if (elf_hash_table (info)->tls_sec)
    {
      bfd_vma base, end = 0;
      asection *sec;

      for (sec = elf_hash_table (info)->tls_sec;
	   sec && (sec->flags & SEC_THREAD_LOCAL);
	   sec = sec->next)
	{
	  bfd_vma size = sec->_raw_size;

	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      struct bfd_link_order *o;

	      for (o = sec->link_order_head; o != NULL; o = o->next)
		if (size < o->offset + o->size)
		  size = o->offset + o->size;
	    }
	  end = sec->vma + size;
	}
      base = elf_hash_table (info)->tls_sec->vma;
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
    }

  /* Since ELF permits relocations to be against local symbols, we
     must have the local symbols available when we do the relocations.
     Since we would rather only read the local symbols once, and we
     would rather not keep them in memory, we handle all the
     relocations for a single input file at the same time.

     Unfortunately, there is no way to know the total number of local
     symbols until we have seen all of them, and the local symbol
     indices precede the global symbol indices.  This means that when
     we are generating relocatable output, and we see a reloc against
     a global symbol, we can not know the symbol index until we have
     finished examining all the local symbols to see which ones we are
     going to output.  To deal with this, we keep the relocations in
     memory, and don't output them until the end of the link.  This is
     an unfortunate waste of memory, but I don't see a good way around
     it.  Fortunately, it only happens when performing a relocatable
     link, which is not the common case.  FIXME: If keep_memory is set
     we could write the relocs out and then read them again; I don't
     know how bad the memory loss will be.  */

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
		  == bfd_target_elf_flavour)
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
	    {
	      if (! sub->output_has_begun)
		{
		  if (! elf_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! elf_reloc_link_order (abfd, info, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  /* Output any global symbols that got converted to local in a
     version script or due to symbol visibility.  We do this in a
     separate step since ELF requires all local symbols to appear
     prior to any global symbols.  FIXME: We should only do this if
     some global symbols were, in fact, converted to become local.
     FIXME: Will this work correctly with the Irix 5 linker?  */
  eoinfo.failed = FALSE;
  eoinfo.finfo = &finfo;
  eoinfo.localsyms = TRUE;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* That wrote out all the local symbols.  Finish up the symbol table
     with the global symbols. Even if we want to strip everything we
     can, we still need to deal with those global symbols that got
     converted to local in a version script.  */

  /* The sh_info field records the index of the first non local symbol.  */
  symtab_hdr->sh_info = bfd_get_symcount (abfd);

  if (dynamic
      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
    {
      Elf_Internal_Sym sym;
      bfd_byte *dynsym = finfo.dynsym_sec->contents;
      long last_local = 0;

      /* Write out the section symbols for the output sections.  */
      if (info->shared)
	{
	  asection *s;

	  sym.st_size = 0;
	  sym.st_name = 0;
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	  sym.st_other = 0;

	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      int indx;
	      bfd_byte *dest;
	      long dynindx;

	      indx = elf_section_data (s)->this_idx;
	      dynindx = elf_section_data (s)->dynindx;
	      BFD_ASSERT (indx > 0);
	      sym.st_shndx = indx;
	      sym.st_value = s->vma;
	      dest = dynsym + dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }

	  last_local = bfd_count_sections (abfd);
	}

      /* Write out the local dynsyms.  */
      if (elf_hash_table (info)->dynlocal)
	{
	  struct elf_link_local_dynamic_entry *e;
	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	    {
	      asection *s;
	      bfd_byte *dest;

	      sym.st_size = e->isym.st_size;
	      sym.st_other = e->isym.st_other;

	      /* Copy the internal symbol as is.
		 Note that we saved a word of storage and overwrote
		 the original st_name with the dynstr_index.  */
	      sym = e->isym;

	      if (e->isym.st_shndx != SHN_UNDEF
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
		{
		  s = bfd_section_from_elf_index (e->input_bfd,
						  e->isym.st_shndx);

		  sym.st_shndx =
		    elf_section_data (s->output_section)->this_idx;
		  sym.st_value = (s->output_section->vma
				  + s->output_offset
				  + e->isym.st_value);
		}

	      if (last_local < e->dynindx)
		last_local = e->dynindx;

	      dest = dynsym + e->dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }
	}

      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
	last_local + 1;
    }

  /* We get the global symbols from the hash table.  */
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
  eoinfo.finfo = &finfo;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* If backend needs to output some symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_syms)
    {
      typedef bfd_boolean (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_syms)
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

  /* Flush all symbols to the file.  */
  if (! elf_link_flush_output_syms (&finfo, bed))
    return FALSE;

  /* Now we know the size of the symtab section.  */
  off += symtab_hdr->sh_size;

  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, TRUE);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
	return FALSE;
    }


  /* Finish up and write out the symbol string table (.strtab)
     section.  */
  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  /* sh_name was set in prep_headers.  */
  symstrtab_hdr->sh_type = SHT_STRTAB;
  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  /* sh_offset is set just below.  */
  symstrtab_hdr->sh_addralign = 1;

  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
  elf_tdata (abfd)->next_file_pos = off;

  if (bfd_get_symcount (abfd) > 0)
    {
      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
	return FALSE;
    }

  /* Adjust the relocs to have the correct symbol indices.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) == 0)
	continue;

      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
			      elf_section_data (o)->rel_count,
			      elf_section_data (o)->rel_hashes);
      if (elf_section_data (o)->rel_hdr2 != NULL)
	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
				elf_section_data (o)->rel_count2,
				(elf_section_data (o)->rel_hashes
				 + elf_section_data (o)->rel_count));

      /* Set the reloc_count field to 0 to prevent write_relocs from
	 trying to swap the relocs out itself.  */
      o->reloc_count = 0;
    }

  if (dynamic && info->combreloc && dynobj != NULL)
    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);

  /* If we are linking against a dynamic object, or generating a
     shared library, finish up the dynamic linking information.  */
  if (dynamic)
    {
      bfd_byte *dyncon, *dynconend;

      /* Fix up .dynamic entries.  */
      o = bfd_get_section_by_name (dynobj, ".dynamic");
      BFD_ASSERT (o != NULL);

      dyncon = o->contents;
      dynconend = o->contents + o->_raw_size;
      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  unsigned int type;

	  bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;
	    case DT_NULL:
	      if (relativecount > 0 && dyncon + bed->s->sizeof_dyn < dynconend)
		{
		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
		    {
		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
		    default: continue;
		    }
		  dyn.d_un.d_val = relativecount;
		  relativecount = 0;
		  break;
		}
	      continue;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_val = h->root.u.def.value;
		    o = h->root.u.def.section;
		    if (o->output_section != NULL)
		      dyn.d_un.d_val += (o->output_section->vma
					 + o->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_val = 0;
		      }
		    break;
		  }
	      }
	      continue;

	    case DT_PREINIT_ARRAYSZ:
	      name = ".preinit_array";
	      goto get_size;
	    case DT_INIT_ARRAYSZ:
	      name = ".init_array";
	      goto get_size;
	    case DT_FINI_ARRAYSZ:
	      name = ".fini_array";
	    get_size:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      if (o->_raw_size == 0)
		(*_bfd_error_handler)
		  (_("warning: %s section has zero size"), name);
	      dyn.d_un.d_val = o->_raw_size;
	      break;

	    case DT_PREINIT_ARRAY:
	      name = ".preinit_array";
	      goto get_vma;
	    case DT_INIT_ARRAY:
	      name = ".init_array";
	      goto get_vma;
	    case DT_FINI_ARRAY:
	      name = ".fini_array";
	      goto get_vma;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma;
	    case DT_VERSYM:
	      name = ".gnu.version";
	    get_vma:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      dyn.d_un.d_ptr = o->vma;
	      break;

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELSZ:
	    case DT_RELASZ:
	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
		type = SHT_REL;
	      else
		type = SHT_RELA;
	      dyn.d_un.d_val = 0;
	      for (i = 1; i < elf_numsections (abfd); i++)
		{
		  Elf_Internal_Shdr *hdr;

		  hdr = elf_elfsections (abfd)[i];
		  if (hdr->sh_type == type
		      && (hdr->sh_flags & SHF_ALLOC) != 0)
		    {
		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
			dyn.d_un.d_val += hdr->sh_size;
		      else
			{
			  if (dyn.d_un.d_val == 0
			      || hdr->sh_addr < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_addr;
			}
		    }
		}
	      break;
	    }
	  bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
	}
    }

  /* If we have created any dynamic sections, then output them.  */
  if (dynobj != NULL)
    {
      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
	goto error_return;

      for (o = dynobj->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_HAS_CONTENTS) == 0
	      || o->_raw_size == 0
	      || o->output_section == bfd_abs_section_ptr)
	    continue;
	  if ((o->flags & SEC_LINKER_CREATED) == 0)
	    {
	      /* At this point, we are only interested in sections
		 created by _bfd_elf_link_create_dynamic_sections.  */
	      continue;
	    }
	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
	       != SHT_STRTAB)
	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
	    {
	      if (! bfd_set_section_contents (abfd, o->output_section,
					      o->contents,
					      (file_ptr) o->output_offset,
					      o->_raw_size))
		goto error_return;
	    }
	  else
	    {
	      /* The contents of the .dynstr section are actually in a
		 stringtab.  */
	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
	      if (bfd_seek (abfd, off, SEEK_SET) != 0
		  || ! _bfd_elf_strtab_emit (abfd,
					     elf_hash_table (info)->dynstr))
		goto error_return;
	    }
	}
    }

  if (info->relocatable)
    {
      bfd_boolean failed = FALSE;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

  /* If we have optimized stabs strings, output them.  */
  if (elf_hash_table (info)->stab_info != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
	goto error_return;
    }

  if (info->eh_frame_hdr)
    {
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
    }

  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  elf_tdata (abfd)->linker = TRUE;

  return TRUE;

 error_return:
  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  return FALSE;
}

/* Add a symbol to the output symbol table.  */

static bfd_boolean
elf_link_output_sym (struct elf_final_link_info *finfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
{
  bfd_byte *dest;
  Elf_External_Sym_Shndx *destshndx;
  bfd_boolean (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (finfo->output_bfd);
  output_symbol_hook = bed->elf_backend_link_output_symbol_hook;
  if (output_symbol_hook != NULL)
    {
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
	return FALSE;
    }

  if (name == NULL || *name == '\0')
    elfsym->st_name = 0;
  else if (input_sec->flags & SEC_EXCLUDE)
    elfsym->st_name = 0;
  else
    {
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
							    name, TRUE, FALSE);
      if (elfsym->st_name == (unsigned long) -1)
	return FALSE;
    }

  if (finfo->symbuf_count >= finfo->symbuf_size)
    {
      if (! elf_link_flush_output_syms (finfo, bed))
	return FALSE;
    }

  dest = finfo->symbuf + finfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = finfo->symshndxbuf;
  if (destshndx != NULL)
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;

	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return FALSE;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }

  bed->s->swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;

  return TRUE;
}

/* Flush the output symbols to the file.  */

static bfd_boolean
elf_link_flush_output_syms (struct elf_final_link_info *finfo,
			    const struct elf_backend_data *bed)
{
  if (finfo->symbuf_count > 0)
    {
      Elf_Internal_Shdr *hdr;
      file_ptr pos;
      bfd_size_type amt;

      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
      pos = hdr->sh_offset + hdr->sh_size;
      amt = finfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
	return FALSE;

      hdr->sh_size += amt;
      finfo->symbuf_count = 0;
    }

  return TRUE;
}

/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */

static bfd_boolean
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *h)
{
  bfd *abfd;
  struct elf_link_loaded_list *loaded;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

  for (loaded = elf_hash_table (info)->loaded;
       loaded != NULL;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      bfd_size_type symcount;
      bfd_size_type extsymcount;
      bfd_size_type extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;

      /* We check each DSO for a possible hidden versioned definition.  */
      if (input == abfd
	  || (input->flags & DYNAMIC) == 0
	  || elf_dynversym (input) == 0)
	continue;

      hdr = &elf_tdata (input)->dynsymtab_hdr;

      symcount = hdr->sh_size / bed->s->sizeof_sym;
      if (elf_bad_symtab (input))
	{
	  extsymcount = symcount;
	  extsymoff = 0;
	}
      else
	{
	  extsymcount = symcount - hdr->sh_info;
	  extsymoff = hdr->sh_info;
	}

      if (extsymcount == 0)
	continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return FALSE;

      /* Read in any version definitions.  */
      versymhdr = &elf_tdata (input)->dynversym_hdr;
      extversym = bfd_malloc (versymhdr->sh_size);
      if (extversym == NULL)
	goto error_ret;

      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
	      != versymhdr->sh_size))
	{
	  free (extversym);
	error_ret:
	  free (isymbuf);
	  return FALSE;
	}

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
	{
	  const char *name;
	  Elf_Internal_Versym iver;
	  unsigned short version_index;

	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
	      || isym->st_shndx == SHN_UNDEF)
	    continue;

	  name = bfd_elf_string_from_elf_section (input,
						  hdr->sh_link,
						  isym->st_name);
	  if (strcmp (name, h->root.root.string) != 0)
	    continue;

	  _bfd_elf_swap_versym_in (input, ever, &iver);

	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
	    {
	      /* If we have a non-hidden versioned sym, then it should
		 have provided a definition for the undefined sym.  */
	      abort ();
	    }

	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
	    {
	      /* This is the base or first version.  We can use it.  */
	      free (extversym);
	      free (isymbuf);
	      return TRUE;
	    }
	}

      free (extversym);
      free (isymbuf);
    }

  return FALSE;
}

/* Add an external symbol to the symbol table.  This is called from
   the hash table traversal routine.  When generating a shared object,
   we go through the symbol table twice.  The first time we output
   anything that might have been forced to local scope in a version
   script.  The second time we output the symbols that are still
   global symbols.  */

static bfd_boolean
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
{
  struct elf_outext_info *eoinfo = data;
  struct elf_final_link_info *finfo = eoinfo->finfo;
  bfd_boolean strip;
  Elf_Internal_Sym sym;
  asection *input_sec;
  const struct elf_backend_data *bed;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* Decide whether to output this symbol in this pass.  */
  if (eoinfo->localsyms)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	return TRUE;
    }
  else
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return TRUE;
    }

  bed = get_elf_backend_data (finfo->output_bfd);

  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
    {
      if (! ((*finfo->info->callbacks->undefined_symbol)
	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocatable
      && (! finfo->info->shared)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* We don't want to output symbols that have never been mentioned by
     a regular file, or that we have been told to strip.  However, if
     h->indx is set to -2, the symbol is used by a reloc and we must
     output it.  */
  if (h->indx == -2)
    strip = FALSE;
  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = TRUE;
  else if (finfo->info->strip == strip_all)
    strip = TRUE;
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
    strip = TRUE;
  else
    strip = FALSE;

  /* If we're stripping it, and it's not a dynamic symbol, there's
     nothing else to do unless it is a forced local symbol.  */
  if (strip
      && h->dynindx == -1
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
    return TRUE;

  sym.st_value = 0;
  sym.st_size = h->size;
  sym.st_other = h->other;
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
  else if (h->root.type == bfd_link_hash_undefweak
	   || h->root.type == bfd_link_hash_defweak)
    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
  else
    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      abort ();
      return FALSE;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      input_sec = bfd_und_section_ptr;
      sym.st_shndx = SHN_UNDEF;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	input_sec = h->root.u.def.section;
	if (input_sec->output_section != NULL)
	  {
	    sym.st_shndx =
	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
						 input_sec->output_section);
	    if (sym.st_shndx == SHN_BAD)
	      {
		(*_bfd_error_handler)
		  (_("%s: could not find output section %s for input section %s"),
		   bfd_get_filename (finfo->output_bfd),
		   input_sec->output_section->name,
		   input_sec->name);
		eoinfo->failed = TRUE;
		return FALSE;
	      }

	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
	       addresses.  */
	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
	    if (! finfo->info->relocatable)
	      {
		sym.st_value += input_sec->output_section->vma;
		if (h->type == STT_TLS)
		  {
		    /* STT_TLS symbols are relative to PT_TLS segment
		       base.  */
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
		  }
	      }
	  }
	else
	  {
	    BFD_ASSERT (input_sec->owner == NULL
			|| (input_sec->owner->flags & DYNAMIC) != 0);
	    sym.st_shndx = SHN_UNDEF;
	    input_sec = bfd_und_section_ptr;
	  }
      }
      break;

    case bfd_link_hash_common:
      input_sec = h->root.u.c.p->section;
      sym.st_shndx = SHN_COMMON;
      sym.st_value = 1 << h->root.u.c.p->alignment_power;
      break;

    case bfd_link_hash_indirect:
      /* These symbols are created by symbol versioning.  They point
	 to the decorated version of the name.  For example, if the
	 symbol foo@@@@GNU_1.2 is the default, which should be used when
	 foo is used with no version, then we add an indirect symbol
	 foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
	 since the indirected symbol is already in the hash table.  */
      return TRUE;
    }

  /* Give the processor backend a chance to tweak the symbol value,
     and also to finish up anything that needs to be done for this
     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
     forced local syms when non-shared is due to a historical quirk.  */
  if ((h->dynindx != -1
       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      if (! ((*bed->elf_backend_finish_dynamic_symbol)
	     (finfo->output_bfd, finfo->info, h, &sym)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* If we are marking the symbol as undefined, and there are no
     non-weak references to this symbol from a regular object, then
     mark the symbol as weak undefined; if there are non-weak
     references, mark the symbol as strong.  We can't do this earlier,
     because it might not be marked as undefined until the
     finish_dynamic_symbol routine gets through with it.  */
  if (sym.st_shndx == SHN_UNDEF
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
    {
      int bindtype;

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
	bindtype = STB_GLOBAL;
      else
	bindtype = STB_WEAK;
      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
    }

  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
  if (! finfo->info->relocatable
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* If this symbol should be put in the .dynsym section, then put it
     there now.  We already know the symbol index.  We also fill in
     the entry in the .hash section.  */
  if (h->dynindx != -1
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      size_t bucketcount;
      size_t bucket;
      size_t hash_entry_size;
      bfd_byte *bucketpos;
      bfd_vma chain;
      bfd_byte *esym;

      sym.st_name = h->dynstr_index;
      esym = finfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      bed->s->swap_symbol_out (finfo->output_bfd, &sym, esym, 0);

      bucketcount = elf_hash_table (finfo->info)->bucketcount;
      bucket = h->elf_hash_value % bucketcount;
      hash_entry_size
	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
		   + (bucket + 2) * hash_entry_size);
      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
	       ((bfd_byte *) finfo->hash_sec->contents
		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));

      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
	{
	  Elf_Internal_Versym iversym;
	  Elf_External_Versym *eversym;

	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      if (h->verinfo.verdef == NULL)
		iversym.vs_vers = 0;
	      else
		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
	    }
	  else
	    {
	      if (h->verinfo.vertree == NULL)
		iversym.vs_vers = 1;
	      else
		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
	    }

	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
	    iversym.vs_vers |= VERSYM_HIDDEN;

	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
	  eversym += h->dynindx;
	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
	}
    }

  /* If we're stripping it, then it was just a dynamic symbol, and
     there's nothing else to do.  */
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
    return TRUE;

  h->indx = bfd_get_symcount (finfo->output_bfd);

  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
    {
      eoinfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.
   This is so that we only have to read the local symbols once, and
   don't have to keep them in memory.  */

static bfd_boolean
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
{
  bfd_boolean (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
  bfd *output_bfd;
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  long *pindex;
  asection **ppsection;
  asection *o;
  const struct elf_backend_data *bed;
  bfd_boolean emit_relocs;
  struct elf_link_hash_entry **sym_hashes;

  output_bfd = finfo->output_bfd;
  bed = get_elf_backend_data (output_bfd);
  relocate_section = bed->elf_backend_relocate_section;

  /* If this is a dynamic object, we don't want to do anything here:
     we don't want the local symbols, and we don't want the section
     contents.  */
  if ((input_bfd->flags & DYNAMIC) != 0)
    return TRUE;

  emit_relocs = (finfo->info->relocatable
		 || finfo->info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  /* Read the local symbols.  */
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				      finfo->internal_syms,
				      finfo->external_syms,
				      finfo->locsym_shndx);
      if (isymbuf == NULL)
	return FALSE;
    }

  /* Find local symbol sections and adjust values of symbols in
     SEC_MERGE sections.  Write out those local symbols we know are
     going into the output file.  */
  isymend = isymbuf + locsymcount;
  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
    {
      asection *isec;
      const char *name;
      Elf_Internal_Sym osym;

      *pindex = -1;

      if (elf_bad_symtab (input_bfd))
	{
	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
	    {
	      *ppsection = NULL;
	      continue;
	    }
	}

      if (isym->st_shndx == SHN_UNDEF)
	isec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE
	       || isym->st_shndx > SHN_HIRESERVE)
	{
	  isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
	  if (isec
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
	    isym->st_value =
	      _bfd_merged_section_offset (output_bfd, &isec,
					  elf_section_data (isec)->sec_info,
					  isym->st_value, 0);
	}
      else if (isym->st_shndx == SHN_ABS)
	isec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	isec = bfd_com_section_ptr;
      else
	{
	  /* Who knows?  */
	  isec = NULL;
	}

      *ppsection = isec;

      /* Don't output the first, undefined, symbol.  */
      if (ppsection == finfo->sections)
	continue;

      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	{
	  /* We never output section symbols.  Instead, we use the
	     section symbol of the corresponding section in the output
	     file.  */
	  continue;
	}

      /* If we are stripping all symbols, we don't want to output this
	 one.  */
      if (finfo->info->strip == strip_all)
	continue;

      /* If we are discarding all local symbols, we don't want to
	 output this one.  If we are generating a relocatable output
	 file, then some of the local symbols may be required by
	 relocs; we output them below as we discover that they are
	 needed.  */
      if (finfo->info->discard == discard_all)
	continue;

      /* If this symbol is defined in a section which we are
	 discarding, we don't need to keep it, but note that
	 linker_mark is only reliable for sections that have contents.
	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
	 as well as linker_mark.  */
      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	  && isec != NULL
	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
	      || (! finfo->info->relocatable
		  && (isec->flags & SEC_EXCLUDE) != 0)))
	continue;

      /* Get the name of the symbol.  */
      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	return FALSE;

      /* See if we are discarding symbols with this name.  */
      if ((finfo->info->strip == strip_some
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
	       == NULL))
	  || (((finfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
	       || finfo->info->discard == discard_l)
	      && bfd_is_local_label_name (input_bfd, name)))
	continue;

      /* If we get here, we are going to output this symbol.  */

      osym = *isym;

      /* Adjust the section index for the output file.  */
      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
							 isec->output_section);
      if (osym.st_shndx == SHN_BAD)
	return FALSE;

      *pindex = bfd_get_symcount (output_bfd);

      /* ELF symbols in relocatable files are section relative, but
	 in executable files they are virtual addresses.  Note that
	 this code assumes that all ELF sections have an associated
	 BFD section with a reasonable value for output_offset; below
	 we assume that they also have a reasonable value for
	 output_section.  Any special sections must be set up to meet
	 these requirements.  */
      osym.st_value += isec->output_offset;
      if (! finfo->info->relocatable)
	{
	  osym.st_value += isec->output_section->vma;
	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
	    {
	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
	    }
	}

      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
	return FALSE;
    }

  /* Relocate the contents of each section.  */
  sym_hashes = elf_sym_hashes (input_bfd);
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
	continue;

      if ((o->flags & SEC_LINKER_CREATED) != 0)
	{
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
	     or somesuch.  */
	  continue;
	}

      /* Get the contents of the section.  They have been cached by a
	 relaxation routine.  Note that o is a section in an input
	 file, so the contents field will not have been set by any of
	 the routines which work on output files.  */
      if (elf_section_data (o)->this_hdr.contents != NULL)
	contents = elf_section_data (o)->this_hdr.contents;
      else
	{
	  contents = finfo->contents;
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
	    return FALSE;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_vma r_type_mask;
	  int r_sym_shift;

	  /* Get the swapped relocs.  */
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
	  if (internal_relocs == NULL
	      && o->reloc_count > 0)
	    return FALSE;

	  if (bed->s->arch_size == 32)
	    {
	      r_type_mask = 0xff;
	      r_sym_shift = 8;
	    }
	  else
	    {
	      r_type_mask = 0xffffffff;
	      r_sym_shift = 32;
	    }

	  /* Run through the relocs looking for any against symbols
	     from discarded sections and section symbols from
	     removed link-once sections.  Complain about relocs
	     against discarded sections.  Zero relocs against removed
	     link-once sections.  Preserve debug information as much
	     as we can.  */
	  if (!elf_section_ignore_discarded_relocs (o))
	    {
	      Elf_Internal_Rela *rel, *relend;

	      rel = internal_relocs;
	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      for ( ; rel < relend; rel++)
		{
		  unsigned long r_symndx = rel->r_info >> r_sym_shift;
		  asection *sec;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *h;

		      h = sym_hashes[r_symndx - extsymoff];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;

		      /* Complain if the definition comes from a
			 discarded section.  */
		      sec = h->root.u.def.section;
		      if ((h->root.type == bfd_link_hash_defined
			   || h->root.type == bfd_link_hash_defweak)
			  && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
			    }
			  else
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
			}
		    }
		  else
		    {
		      sec = finfo->sections[r_symndx];

		      if (sec != NULL && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0
			      || (sec->flags & SEC_LINK_ONCE) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info &= r_type_mask;
				  rel->r_addend = 0;
				}
			    }
			  else
			    {
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
				free (buf);
			    }
			}
		    }
		}
	    }

	  /* Relocate the section by invoking a back end routine.

	     The back end routine is responsible for adjusting the
	     section contents as necessary, and (if using Rela relocs
	     and generating a relocatable output file) adjusting the
	     reloc addend as necessary.

	     The back end routine does not have to worry about setting
	     the reloc address or the reloc symbol index.

	     The back end routine is given a pointer to the swapped in
	     internal symbols, and can access the hash table entries
	     for the external symbols via elf_sym_hashes (input_bfd).

	     When generating relocatable output, the back end routine
	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
	     output symbol is going to be a section symbol
	     corresponding to the output section, which will require
	     the addend to be adjusted.  */

	  if (! (*relocate_section) (output_bfd, finfo->info,
				     input_bfd, o, contents,
				     internal_relocs,
				     isymbuf,
				     finfo->sections))
	    return FALSE;

	  if (emit_relocs)
	    {
	      Elf_Internal_Rela *irela;
	      Elf_Internal_Rela *irelaend;
	      bfd_vma last_offset;
	      struct elf_link_hash_entry **rel_hash;
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
	      unsigned int next_erel;
	      bfd_boolean (*reloc_emitter)
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
	      bfd_boolean rela_normal;

	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
	      rela_normal = (bed->rela_normal
			     && (input_rel_hdr->sh_entsize
				 == bed->s->sizeof_rela));

	      /* Adjust the reloc addresses and symbol indices.  */

	      irela = internal_relocs;
	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
			  + elf_section_data (o->output_section)->rel_count
			  + elf_section_data (o->output_section)->rel_count2);
	      last_offset = o->output_offset;
	      if (!finfo->info->relocatable)
		last_offset += o->output_section->vma;
	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
		{
		  unsigned long r_symndx;
		  asection *sec;
		  Elf_Internal_Sym sym;

		  if (next_erel == bed->s->int_rels_per_ext_rel)
		    {
		      rel_hash++;
		      next_erel = 0;
		    }

		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     finfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 elf_bfd_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
		      continue;
		    }

		  irela->r_offset += o->output_offset;

		  /* Relocs in an executable have to be virtual addresses.  */
		  if (!finfo->info->relocatable)
		    irela->r_offset += o->output_section->vma;

		  last_offset = irela->r_offset;

		  r_symndx = irela->r_info >> r_sym_shift;
		  if (r_symndx == STN_UNDEF)
		    continue;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *rh;
		      unsigned long indx;

		      /* This is a reloc against a global symbol.  We
			 have not yet output all the local symbols, so
			 we do not know the symbol index of any global
			 symbol.  We set the rel_hash entry for this
			 reloc to point to the global hash table entry
			 for this symbol.  The symbol index is then
			 set at the end of elf_bfd_final_link.  */
		      indx = r_symndx - extsymoff;
		      rh = elf_sym_hashes (input_bfd)[indx];
		      while (rh->root.type == bfd_link_hash_indirect
			     || rh->root.type == bfd_link_hash_warning)
			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;

		      /* Setting the index to -2 tells
			 elf_link_output_extsym that this symbol is
			 used by a reloc.  */
		      BFD_ASSERT (rh->indx < 0);
		      rh->indx = -2;

		      *rel_hash = rh;

		      continue;
		    }

		  /* This is a reloc against a local symbol.  */

		  *rel_hash = NULL;
		  sym = isymbuf[r_symndx];
		  sec = finfo->sections[r_symndx];
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
		    {
		      /* I suppose the backend ought to fill in the
			 section of any STT_SECTION symbol against a
			 processor specific section.  If we have
			 discarded a section, the output_section will
			 be the absolute section.  */
		      if (bfd_is_abs_section (sec)
			  || (sec != NULL
			      && bfd_is_abs_section (sec->output_section)))
			r_symndx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  r_symndx = sec->output_section->target_index;
			  BFD_ASSERT (r_symndx != 0);
			}

		      /* Adjust the addend according to where the
			 section winds up in the output section.  */
		      if (rela_normal)
			irela->r_addend += sec->output_offset;
		    }
		  else
		    {
		      if (finfo->indices[r_symndx] == -1)
			{
			  unsigned long shlink;
			  const char *name;
			  asection *osec;

			  if (finfo->info->strip == strip_all)
			    {
			      /* You can't do ld -r -s.  */
			      bfd_set_error (bfd_error_invalid_operation);
			      return FALSE;
			    }

			  /* This symbol was skipped earlier, but
			     since it is needed by a reloc, we
			     must output it now.  */
			  shlink = symtab_hdr->sh_link;
			  name = (bfd_elf_string_from_elf_section
				  (input_bfd, shlink, sym.st_name));
			  if (name == NULL)
			    return FALSE;

			  osec = sec->output_section;
			  sym.st_shndx =
			    _bfd_elf_section_from_bfd_section (output_bfd,
							       osec);
			  if (sym.st_shndx == SHN_BAD)
			    return FALSE;

			  sym.st_value += sec->output_offset;
			  if (! finfo->info->relocatable)
			    {
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
				{
				  /* STT_TLS symbols are relative to PT_TLS
				     segment base.  */
				  BFD_ASSERT (elf_hash_table (finfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (finfo->info)
						   ->tls_sec->vma);
				}
			    }

			  finfo->indices[r_symndx]
			    = bfd_get_symcount (output_bfd);

			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
			    return FALSE;
			}

		      r_symndx = finfo->indices[r_symndx];
		    }

		  irela->r_info = ((bfd_vma) r_symndx << r_sym_shift
				   | (irela->r_info & r_type_mask));
		}

	      /* Swap out the relocs.  */
	      if (bed->elf_backend_emit_relocs
		  && !(finfo->info->relocatable
		       || finfo->info->emitrelocations))
		reloc_emitter = bed->elf_backend_emit_relocs;
	      else
		reloc_emitter = _bfd_elf_link_output_relocs;

	      if (input_rel_hdr->sh_size != 0
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
		return FALSE;

	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
		{
		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
				      * bed->s->int_rels_per_ext_rel);
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
					  internal_relocs))
		    return FALSE;
		}
	    }
	}

      /* Write out the modified section contents.  */
      if (bed->elf_backend_write_section
	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
	{
	  /* Section written out.  */
	}
      else switch (o->sec_info_type)
	{
	case ELF_INFO_TYPE_STABS:
	  if (! (_bfd_write_section_stabs
		 (output_bfd,
		  &elf_hash_table (finfo->info)->stab_info,
		  o, &elf_section_data (o)->sec_info, contents)))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_MERGE:
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_EH_FRAME:
	  {
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
						   o, contents))
	      return FALSE;
	  }
	  break;
	default:
	  {
	    bfd_size_type sec_size;

	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
	    if (! (o->flags & SEC_EXCLUDE)
		&& ! bfd_set_section_contents (output_bfd, o->output_section,
					       contents,
					       (file_ptr) o->output_offset,
					       sec_size))
	      return FALSE;
	  }
	  break;
	}
    }

  return TRUE;
}

/* Generate a reloc when linking an ELF file.  This is a reloc
   requested by the linker, and does come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */

static bfd_boolean
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  long indx;
  bfd_vma offset;
  bfd_vma addend;
  struct elf_link_hash_entry **rel_hash_ptr;
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  addend = link_order->u.reloc.p->addend;

  /* Figure out the symbol index.  */
  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
		  + elf_section_data (output_section)->rel_count
		  + elf_section_data (output_section)->rel_count2);
  if (link_order->type == bfd_section_reloc_link_order)
    {
      indx = link_order->u.reloc.p->u.section->target_index;
      BFD_ASSERT (indx != 0);
      *rel_hash_ptr = NULL;
    }
  else
    {
      struct elf_link_hash_entry *h;

      /* Treat a reloc against a defined symbol as though it were
	 actually against the section.  */
      h = ((struct elf_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  asection *section;

	  section = h->root.u.def.section;
	  indx = section->output_section->target_index;
	  *rel_hash_ptr = NULL;
	  /* It seems that we ought to add the symbol value to the
	     addend here, but in practice it has already been added
	     because it was passed to constructor_callback.  */
	  addend += section->output_section->vma + section->output_offset;
	}
      else if (h != NULL)
	{
	  /* Setting the index to -2 tells elf_link_output_extsym that
	     this symbol is used by a reloc.  */
	  h->indx = -2;
	  *rel_hash_ptr = h;
	  indx = 0;
	}
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
	  indx = 0;
	}
    }

  /* If this is an inplace reloc, we must write the addend into the
     object file.  */
  if (howto->partial_inplace && addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      bfd_boolean ok;
      const char *sym_name;

      size = bfd_get_reloc_size (howto);
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();

	case bfd_reloc_overflow:
	  if (link_order->type == bfd_section_reloc_link_order)
	    sym_name = bfd_section_name (output_bfd,
					 link_order->u.reloc.p->u.section);
	  else
	    sym_name = link_order->u.reloc.p->u.name;
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* The address of a reloc is relative to the section in a
     relocatable file, and is a virtual address in an executable
     file.  */
  offset = link_order->offset;
  if (! info->relocatable)
    offset += output_section->vma;

  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  if (bed->s->arch_size == 32)
    irel[0].r_info = ELF32_R_INFO (indx, howto->type);
  else
    irel[0].r_info = ELF64_R_INFO (indx, howto->type);

  rel_hdr = &elf_section_data (output_section)->rel_hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == SHT_REL)
    {
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rel);
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
    }
  else
    {
      irel[0].r_addend = addend;
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rela);
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
    }

  ++elf_section_data (output_section)->rel_count;

  return TRUE;
}

/* Garbage collect unused sections.  */

static bfd_boolean elf_gc_sweep_symbol
  (struct elf_link_hash_entry *, void *);

static bfd_boolean elf_gc_allocate_got_offsets
  (struct elf_link_hash_entry *, void *);

/* The mark phase of garbage collection.  For a given section, mark
   it and any sections in this section's group, and all the sections
   which define symbols to which it refers.  */

typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

static bfd_boolean
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
{
  bfd_boolean ret;
  asection *group_sec;

  sec->gc_mark = 1;

  /* Mark all the sections in the group.  */
  group_sec = elf_section_data (sec)->next_in_group;
  if (group_sec && !group_sec->gc_mark)
    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
      return FALSE;

  /* Look through the section relocs.  */
  ret = TRUE;
  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
    {
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      struct elf_link_hash_entry **sym_hashes;
      size_t nlocsyms;
      size_t extsymoff;
      bfd *input_bfd = sec->owner;
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
      Elf_Internal_Sym *isym = NULL;
      int r_sym_shift;

      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      sym_hashes = elf_sym_hashes (input_bfd);

      /* Read the local symbols.  */
      if (elf_bad_symtab (input_bfd))
	{
	  nlocsyms = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  extsymoff = 0;
	}
      else
	extsymoff = nlocsyms = symtab_hdr->sh_info;

      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isym == NULL && nlocsyms != 0)
	{
	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
				       NULL, NULL, NULL);
	  if (isym == NULL)
	    return FALSE;
	}

      /* Read the relocations.  */
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	{
	  ret = FALSE;
	  goto out1;
	}
      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

      if (bed->s->arch_size == 32)
	r_sym_shift = 8;
      else
	r_sym_shift = 32;

      for (rel = relstart; rel < relend; rel++)
	{
	  unsigned long r_symndx;
	  asection *rsec;
	  struct elf_link_hash_entry *h;

	  r_symndx = rel->r_info >> r_sym_shift;
	  if (r_symndx == 0)
	    continue;

	  if (r_symndx >= nlocsyms
	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
	    {
	      h = sym_hashes[r_symndx - extsymoff];
	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
	    }
	  else
	    {
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
	    }

	  if (rsec && !rsec->gc_mark)
	    {
	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
		rsec->gc_mark = 1;
	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
		{
		  ret = FALSE;
		  goto out2;
		}
	    }
	}

    out2:
      if (elf_section_data (sec)->relocs != relstart)
	free (relstart);
    out1:
      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
	{
	  if (! info->keep_memory)
	    free (isym);
	  else
	    symtab_hdr->contents = (unsigned char *) isym;
	}
    }

  return ret;
}

/* The sweep phase of garbage collection.  Remove all garbage sections.  */

typedef bfd_boolean (*gc_sweep_hook_fn)
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);

static bfd_boolean
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
{
  bfd *sub;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  /* Keep special sections.  Keep .debug sections.  */
	  if ((o->flags & SEC_LINKER_CREATED)
	      || (o->flags & SEC_DEBUGGING))
	    o->gc_mark = 1;

	  if (o->gc_mark)
	    continue;

	  /* Skip sweeping sections already excluded.  */
	  if (o->flags & SEC_EXCLUDE)
	    continue;

	  /* Since this is early in the link process, it is simple
	     to remove a section from the output.  */
	  o->flags |= SEC_EXCLUDE;

	  /* But we also have to update some of the relocation
	     info we collected before.  */
	  if (gc_sweep_hook
	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
	    {
	      Elf_Internal_Rela *internal_relocs;
	      bfd_boolean r;

	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		return FALSE;

	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);

	      if (elf_section_data (o)->relocs != internal_relocs)
		free (internal_relocs);

	      if (!r)
		return FALSE;
	    }
	}
    }

  /* Remove the symbols that were in the swept sections from the dynamic
     symbol table.  GCFIXME: Anyone know how to get them out of the
     static symbol table as well?  */
  {
    int i = 0;

    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);

    elf_hash_table (info)->dynsymcount = i;
  }

  return TRUE;
}

/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
{
  int *idx = idxptr;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1
      && ((h->root.type != bfd_link_hash_defined
	   && h->root.type != bfd_link_hash_defweak)
	  || h->root.u.def.section->gc_mark))
    h->dynindx = (*idx)++;

  return TRUE;
}

/* Propagate collected vtable information.  This is called through
   elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Those that are not vtables.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  /* Those vtables that do not have parents, we cannot merge.  */
  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
    return TRUE;

  /* If we've already been done, exit.  */
  if (h->vtable_entries_used && h->vtable_entries_used[-1])
    return TRUE;

  /* Make sure the parent's table is up to date.  */
  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);

  if (h->vtable_entries_used == NULL)
    {
      /* None of this table's entries were referenced.  Re-use the
	 parent's table.  */
      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
    }
  else
    {
      size_t n;
      bfd_boolean *cu, *pu;

      /* Or the parent's entries into ours.  */
      cu = h->vtable_entries_used;
      cu[-1] = TRUE;
      pu = h->vtable_parent->vtable_entries_used;
      if (pu != NULL)
	{
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;

	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
	  while (n--)
	    {
	      if (*pu)
		*cu = TRUE;
	      pu++;
	      cu++;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
{
  asection *sec;
  bfd_vma hstart, hend;
  Elf_Internal_Rela *relstart, *relend, *rel;
  const struct elf_backend_data *bed;
  unsigned int log_file_align;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Take care of both those symbols that do not describe vtables as
     well as those that are not loaded.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  BFD_ASSERT (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak);

  sec = h->root.u.def.section;
  hstart = h->root.u.def.value;
  hend = hstart + h->size;

  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
  if (!relstart)
    return *(bfd_boolean *) okp = FALSE;
  bed = get_elf_backend_data (sec->owner);
  log_file_align = bed->s->log_file_align;

  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

  for (rel = relstart; rel < relend; ++rel)
    if (rel->r_offset >= hstart && rel->r_offset < hend)
      {
	/* If the entry is in use, do nothing.  */
	if (h->vtable_entries_used
	    && (rel->r_offset - hstart) < h->vtable_entries_size)
	  {
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
	    if (h->vtable_entries_used[entry])
	      continue;
	  }
	/* Otherwise, kill it.  */
	rel->r_offset = rel->r_info = rel->r_addend = 0;
      }

  return TRUE;
}

/* Do mark and sweep of unused sections.  */

bfd_boolean
elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean ok = TRUE;
  bfd *sub;
  asection * (*gc_mark_hook)
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);

  if (!get_elf_backend_data (abfd)->can_gc_sections
      || info->relocatable
      || info->emitrelocations
      || !is_elf_hash_table (info->hash)
      || elf_hash_table (info)->dynamic_sections_created)
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }

  /* Apply transitive closure to the vtable entry usage info.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_propagate_vtable_entries_used,
			  &ok);
  if (!ok)
    return FALSE;

  /* Kill the vtable relocations that were not used.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_smash_unused_vtentry_relocs,
			  &ok);
  if (!ok)
    return FALSE;

  /* Grovel through relocs to find out who stays ...  */

  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  if (o->flags & SEC_KEEP)
	    if (!elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
	}
    }

  /* ... and mark SEC_EXCLUDE for those that go.  */
  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
    return FALSE;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */

bfd_boolean
elf_gc_record_vtinherit (bfd *abfd,
			 asection *sec,
			 struct elf_link_hash_entry *h,
			 bfd_vma offset)
{
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  struct elf_link_hash_entry **search, *child;
  bfd_size_type extsymcount;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size / bed->s->sizeof_sym;
  if (!elf_bad_symtab (abfd))
    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;

  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + extsymcount;

  /* Hunt down the child symbol, which is in this section at the same
     offset as the relocation.  */
  for (search = sym_hashes; search != sym_hashes_end; ++search)
    {
      if ((child = *search) != NULL
	  && (child->root.type == bfd_link_hash_defined
	      || child->root.type == bfd_link_hash_defweak)
	  && child->root.u.def.section == sec
	  && child->root.u.def.value == offset)
	goto win;
    }

  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
			 bfd_archive_filename (abfd), sec->name,
			 (unsigned long) offset);
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;

 win:
  if (!h)
    {
      /* This *should* only be the absolute section.  It could potentially
	 be that someone has defined a non-global vtable though, which
	 would be bad.  It isn't worth paging in the local symbols to be
	 sure though; that case should simply be handled by the assembler.  */

      child->vtable_parent = (struct elf_link_hash_entry *) -1;
    }
  else
    child->vtable_parent = h;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTENTRY reloc.  */

bfd_boolean
elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *sec ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       bfd_vma addend)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int log_file_align = bed->s->log_file_align;

  if (addend >= h->vtable_entries_size)
    {
      size_t size, bytes, file_align;
      bfd_boolean *ptr = h->vtable_entries_used;

      /* While the symbol is undefined, we have to be prepared to handle
	 a zero size.  */
      file_align = 1 << log_file_align;
      if (h->root.type == bfd_link_hash_undefined)
	size = addend + file_align;
      else
	{
	  size = h->size;
	  if (addend >= size)
	    {
	      /* Oops!  We've got a reference past the defined end of
		 the table.  This is probably a bug -- shall we warn?  */
	      size = addend + file_align;
	    }
	}
      size = (size + file_align - 1) & -file_align;

      /* Allocate one extra entry for use as a "done" flag for the
	 consolidation pass.  */
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);

      if (ptr)
	{
	  ptr = bfd_realloc (ptr - 1, bytes);

	  if (ptr != NULL)
	    {
	      size_t oldbytes;

	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
			  * sizeof (bfd_boolean));
	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
	    }
	}
      else
	ptr = bfd_zmalloc (bytes);

      if (ptr == NULL)
	return FALSE;

      /* And arrange for that done flag to be at index -1.  */
      h->vtable_entries_used = ptr + 1;
      h->vtable_entries_size = size;
    }

  h->vtable_entries_used[addend >> log_file_align] = TRUE;

  return TRUE;
}

struct alloc_got_off_arg {
  bfd_vma gotoff;
  unsigned int got_elt_size;
};

/* And an accompanying bit to work out final got entry offsets once
   we're done.  Should be called from final_link.  */

bfd_boolean
elf_gc_common_finalize_got_offsets (bfd *abfd,
				    struct bfd_link_info *info)
{
  bfd *i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_vma gotoff;
  unsigned int got_elt_size = bed->s->arch_size / 8;
  struct alloc_got_off_arg gofarg;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  /* The GOT offset is relative to the .got section, but the GOT header is
     put into the .got.plt section, if the backend uses it.  */
  if (bed->want_got_plt)
    gotoff = 0;
  else
    gotoff = bed->got_header_size;

  /* Do the local .got entries first.  */
  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_size_type j, locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	continue;

      local_got = elf_local_got_refcounts (i);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      if (elf_bad_symtab (i))
	locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      else
	locsymcount = symtab_hdr->sh_info;

      for (j = 0; j < locsymcount; ++j)
	{
	  if (local_got[j] > 0)
	    {
	      local_got[j] = gotoff;
	      gotoff += got_elt_size;
	    }
	  else
	    local_got[j] = (bfd_vma) -1;
	}
    }

  /* Then the global .got entries.  .plt refcounts are handled by
     adjust_dynamic_symbol  */
  gofarg.gotoff = gotoff;
  gofarg.got_elt_size = got_elt_size;
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_allocate_got_offsets,
			  &gofarg);
  return TRUE;
}

/* We need a special top-level link routine to convert got reference counts
   to real got offsets.  */

static bfd_boolean
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *arg)
{
  struct alloc_got_off_arg *gofarg = arg;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->got.refcount > 0)
    {
      h->got.offset = gofarg->gotoff;
      gofarg->gotoff += gofarg->got_elt_size;
    }
  else
    h->got.offset = (bfd_vma) -1;

  return TRUE;
}

/* Many folk need no more in the way of final link than this, once
   got entry reference counting is enabled.  */

bfd_boolean
elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
{
  if (!elf_gc_common_finalize_got_offsets (abfd, info))
    return FALSE;

  /* Invoke the regular ELF backend linker to do all the work.  */
  return elf_bfd_final_link (abfd, info);
}

bfd_boolean
elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
{
  struct elf_reloc_cookie *rcookie = cookie;

  if (rcookie->bad_symtab)
    rcookie->rel = rcookie->rels;

  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
    {
      unsigned long r_symndx;

      if (! rcookie->bad_symtab)
	if (rcookie->rel->r_offset > offset)
	  return FALSE;
      if (rcookie->rel->r_offset != offset)
	continue;

      r_symndx = rcookie->rel->r_info >> rcookie->r_sym_shift;
      if (r_symndx == SHN_UNDEF)
	return TRUE;

      if (r_symndx >= rcookie->locsymcount
	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
	{
	  struct elf_link_hash_entry *h;

	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && elf_discarded_section (h->root.u.def.section))
	    return TRUE;
	  else
	    return FALSE;
	}
      else
	{
	  /* It's not a relocation against a global symbol,
	     but it could be a relocation against a local
	     symbol for a discarded section.  */
	  asection *isec;
	  Elf_Internal_Sym *isym;

	  /* Need to: get the symbol; get the section.  */
	  isym = &rcookie->locsyms[r_symndx];
	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	    {
	      isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
	      if (isec != NULL && elf_discarded_section (isec))
		return TRUE;
	    }
	}
      return FALSE;
    }
  return FALSE;
}

/* Discard unneeded references to discarded sections.
   Returns TRUE if any section's size was changed.  */
/* This function assumes that the relocations are in sorted order,
   which is true for all known assemblers.  */

bfd_boolean
elf_bfd_discard_info (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_reloc_cookie cookie;
  asection *stab, *eh;
  Elf_Internal_Shdr *symtab_hdr;
  const struct elf_backend_data *bed;
  bfd *abfd;
  unsigned int count;
  bfd_boolean ret = FALSE;

  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return FALSE;

  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    {
      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	continue;

      bed = get_elf_backend_data (abfd);

      if ((abfd->flags & DYNAMIC) != 0)
	continue;

      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (info->relocatable
	  || (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section))))
	eh = NULL;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->_raw_size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
	continue;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
      cookie.abfd = abfd;
      cookie.sym_hashes = elf_sym_hashes (abfd);
      cookie.bad_symtab = elf_bad_symtab (abfd);
      if (cookie.bad_symtab)
	{
	  cookie.locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  cookie.extsymoff = 0;
	}
      else
	{
	  cookie.locsymcount = symtab_hdr->sh_info;
	  cookie.extsymoff = symtab_hdr->sh_info;
	}

      if (bed->s->arch_size == 32)
	cookie.r_sym_shift = 8;
      else
	cookie.r_sym_shift = 32;

      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
	{
	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						 cookie.locsymcount, 0,
						 NULL, NULL, NULL);
	  if (cookie.locsyms == NULL)
	    return FALSE;
	}

      if (stab != NULL)
	{
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
	  if (cookie.rels != NULL)
	    {
	      cookie.rel = cookie.rels;
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
	      if (_bfd_discard_section_stabs (abfd, stab,
					      elf_section_data (stab)->sec_info,
					      elf_reloc_symbol_deleted_p,
					      &cookie))
		ret = TRUE;
	      if (elf_section_data (stab)->relocs != cookie.rels)
		free (cookie.rels);
	    }
	}

      if (eh != NULL)
	{
	  cookie.rels = NULL;
	  count = eh->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
						 elf_reloc_symbol_deleted_p,
						 &cookie))
	    ret = TRUE;

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
	    free (cookie.rels);
	}

      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = TRUE;

      if (cookie.locsyms != NULL
	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
	{
	  if (! info->keep_memory)
	    free (cookie.locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
	}
    }

  if (info->eh_frame_hdr
      && !info->relocatable
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
    ret = TRUE;

  return ret;
}

static bfd_boolean
elf_section_ignore_discarded_relocs (asection *sec)
{
  const struct elf_backend_data *bed;

  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
    case ELF_INFO_TYPE_EH_FRAME:
      return TRUE;
    default:
      break;
    }

  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return TRUE;

  return FALSE;
}
@


1.260
log
@	* elf-bfd.h (struct elf_reloc_cookie): Add r_sym_shift field.
	* elflink.h: Replace all occurrences of sizeof (Elf_External_*)
	where Elf_External_* is different for 64 and 32 bit, with
	corresponding elf_size_info field.
	(struct elf_final_link_info): Use "bfd_byte *" instead
	of "Elf_External_Sym *" for external_syms and symbuf.
	(elf_link_adjust_relocs): Set up r_type_mask and r_sym_shift local
	vars and use instead of ELF_R_INFO and ELF_R_TYPE macros.
	(struct elf_link_sort_rela): Add "sym_mask" alias for "offset".
	(elf_link_sort_cmp1): Use sym_mask field instead of ELF_R_SYM.
	(elf_link_sort_cmp2): Adjust.
	(elf_link_sort_relocs): Set up r_sym_mask local var instead of
	using ELF_R_SYM macro.  Set u.sym_mask.
	(elf_bfd_final_link): Call _bfd_elf_stringtab_init instead of macro
	version, elf_stringtab_init.  Ditto for bfd_section_from_elf_index
	vs. section_from_elf_index.  Adjust Elf_External_Sym pointer
	arithmetic.  Pass bed to elf_link_flush_output_syms.  Adjust
	Elf_External_Dyn pointer arithmentic.  Use bed swap_dyn_in and
	swap_syn_out functions.  Rearrange dyn swap in/out switch.
	(elf_link_output_sym): Adjust Elf_External_Sym pointer arithmentic.
	Pass bed to elf_link_flush_output_syms.  Use bed swap_symbol_out.
	(elf_link_flush_output_syms): Add elf_backend_data arg.
	(elf_link_check_versioned_symbol): Likewise.
	(elf_link_output_extsym): Pass bed to elf_link_check_versioned_symbol.
	Adjust Elf_External_Sym pointer arithmetic.  Use bed swap_symbol_out.
	(elf_link_input_bfd): Use bfd_section_from_elf_index.  Set up
	r_type_mask and r_sym_shift local vars and use instead of ELF_R_SYM,
	ELF_R_TYPE and ELF_R_INFO macros.
	(elf_reloc_link_order): Select ELF32_R_INFO or ELF64_R_INFO invocation
	based on size rather than using ELF_R_INFO.
	(elf_gc_mark): Set up r_sym_shift local var and use instead of
	ELF_R_SYM macro.
	(struct alloc_got_off_arg): New.
	(elf_gc_common_finalize_got_offsets): Use elf_size_info instead of
	ARCH_SIZE.  Pass get entry size down to elf_gc_allocate_got_offsets.
	(elf_gc_allocate_got_offsets): Adjust.
	(elf_reloc_symbol_deleted_p): Usee cookie.r_sym_shift instead of
	ELF_R_SYM.  Use bfd_section_from_elf_index.
	(elf_bfd_discard_info): Set cookie.r_sym_shift.
	* elfcode.h (elf_stringtab_init, section_from_elf_index): Delete.
	(elf_slurp_symbol_table): Use bfd_section_from_elf_index.
@
text
@@


1.259
log
@	* elfxx-target.h (bfd_elfNN_bfd_link_add_symbols): Define.
	* elf-bfd.h (_bfd_elf_link_add_archive_symbols): Delete.
	(_bfd_elf_sort_symbol, _bfd_elf_add_dt_needed_tag): Delete.
	(_bfd_elf_finalize_dynstr, bfd_elf32_bfd_link_add_symbols): Delete.
	(bfd_elf64_bfd_link_add_symbols): Delete.
	(bfd_elf_link_add_symbols): Declare.
	* elfcode.h (elf_bfd_link_add_symbols): Delete.
	* elflink.c: Include safe-ctype.h.
	(elf_add_dt_needed_tag): Rename from _bfd_elf_add_dt_needed_tag,
	make static.
	(elf_sort_symbol): Rename from _bfd_elf_sort_symbol, make static.
	(elf_finalize_dynstr): Rename from _bfd_elf_finalize_dynstr, make
	static.
	(elf_link_add_archive_symbols): Rename from
	_bfd_elf_link_add_archive_symbols, make static.
	(elf_link_add_object_symbols): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(bfd_elf_link_add_symbols): Likewise.
	(bfd_elf_size_dynamic_sections): Adjust.
	* elflink.h (elf_bfd_link_add_symbols): Delete.
	(elf_link_add_object_symbols): Delete.
	* elf32-gen.c (elf32_generic_link_add_symbols): Call
	bfd_elf_link_add_symbols.
	* elf64-gen.c (elf64_generic_link_add_symbols): Likewise.
@
text
@d51 1
a51 1
  Elf_External_Sym *external_syms;
d64 1
a64 1
  Elf_External_Sym *symbuf;
d79 1
a79 1
  (struct elf_final_link_info *);
d112 2
d115 1
a115 1
  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
d120 1
a120 1
  else if (rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
d131 11
d155 2
a156 2
	irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
				      ELF_R_TYPE (irela[j].r_info));
d163 4
a166 1
  bfd_vma offset;
d186 1
a186 1
  if (ELF_R_SYM (a->rela->r_info) < ELF_R_SYM (b->rela->r_info))
d188 1
a188 1
  if (ELF_R_SYM (a->rela->r_info) > ELF_R_SYM (b->rela->r_info))
d204 1
a204 1
  if (a->offset < b->offset)
d206 1
a206 1
  if (a->offset > b->offset)
d234 1
d242 1
a242 1
      ext_size = sizeof (Elf_External_Rel);
d248 1
a248 1
      ext_size = sizeof (Elf_External_Rela);
d275 5
d294 1
d315 1
a315 1
      if (ELF_R_SYM (sp->rela->r_info) != ELF_R_SYM (sq->rela->r_info))
d317 1
a317 1
      sp->offset = sq->rela->r_offset;
d390 1
a390 1
  finfo.symstrtab = elf_stringtab_init ();
d490 1
a490 1
				 / sizeof (Elf_External_Sym));
d532 3
a534 4
	      BFD_ASSERT (entsize1 == sizeof (Elf_External_Rel)
			  || entsize1 == sizeof (Elf_External_Rela));
	      same_size = (!o->use_rela_p
			   == (entsize1 == sizeof (Elf_External_Rel)));
d546 2
a547 2
			      && (entsize2 == sizeof (Elf_External_Rel)
				  || entsize2 == sizeof (Elf_External_Rela)));
d628 1
a628 1
  symtab_hdr->sh_entsize = sizeof (Elf_External_Sym);
d648 1
a648 1
  amt *= sizeof (Elf_External_Sym);
d707 1
a707 1
	  o = section_from_elf_index (abfd, i);
d749 1
a749 1
      amt = max_sym_count * sizeof (Elf_External_Sym);
d882 1
a882 2
      Elf_External_Sym *dynsym =
	(Elf_External_Sym *) finfo.dynsym_sec->contents;
d898 2
a899 1
	      Elf_External_Sym *dest;
d902 1
d906 2
a907 2
	      dest = dynsym + elf_section_data (s)->dynindx;
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d920 1
a920 1
	      Elf_External_Sym *dest;
d947 2
a948 2
	      dest = dynsym + e->dynindx;
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d979 1
a979 1
  if (! elf_link_flush_output_syms (&finfo))
d1054 1
a1054 1
      Elf_External_Dyn *dyncon, *dynconend;
d1060 3
a1062 3
      dyncon = (Elf_External_Dyn *) o->contents;
      dynconend = (Elf_External_Dyn *) (o->contents + o->_raw_size);
      for (; dyncon < dynconend; dyncon++)
d1068 1
a1068 1
	  elf_swap_dyn_in (dynobj, dyncon, &dyn);
d1073 1
a1073 1
	      break;
d1075 1
a1075 1
	      if (relativecount > 0 && dyncon + 1 < dynconend)
d1081 1
a1081 7
		    default: break;
		    }
		  if (dyn.d_tag != DT_NULL)
		    {
		      dyn.d_un.d_val = relativecount;
		      elf_swap_dyn_out (dynobj, &dyn, dyncon);
		      relativecount = 0;
d1083 3
d1087 2
a1088 1
	      break;
d1115 1
a1115 2

		    elf_swap_dyn_out (dynobj, &dyn, dyncon);
d1118 1
a1118 1
	      break;
a1140 1
	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
a1179 1
	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
a1208 1
	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
d1211 1
d1353 1
a1353 1
  Elf_External_Sym *dest;
d1358 1
d1360 2
a1361 2
  output_symbol_hook = get_elf_backend_data (finfo->output_bfd)->
    elf_backend_link_output_symbol_hook;
d1382 1
a1382 1
      if (! elf_link_flush_output_syms (finfo))
d1386 1
a1386 1
  dest = finfo->symbuf + finfo->symbuf_count;
d1404 1
a1404 1
  elf_swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
d1414 2
a1415 1
elf_link_flush_output_syms (struct elf_final_link_info *finfo)
d1425 1
a1425 1
      amt = finfo->symbuf_count * sizeof (Elf_External_Sym);
d1445 1
d1505 1
a1505 1
      symcount = hdr->sh_size / sizeof (Elf_External_Sym);
d1600 1
d1621 2
d1630 1
a1630 1
      && ! elf_link_check_versioned_symbol (finfo->info, h)
d1649 1
a1649 1
      && ! elf_link_check_versioned_symbol (finfo->info, h))
a1794 3
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (finfo->output_bfd);
d1854 1
a1854 1
      Elf_External_Sym *esym;
d1857 2
a1858 2
      esym = (Elf_External_Sym *) finfo->dynsym_sec->contents + h->dynindx;
      elf_swap_symbol_out (finfo->output_bfd, &sym, esym, 0);
d1959 1
a1959 1
      locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d2008 1
a2008 1
	  isec = section_from_elf_index (input_bfd, isym->st_shndx);
d2157 2
d2168 11
d2193 1
a2193 1
		  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
d2254 1
a2254 2
				  rel->r_info
				    = ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
d2323 1
a2323 1
				 == sizeof (Elf_External_Rela)));
d2371 1
a2371 1
		  r_symndx = ELF_R_SYM (irela->r_info);
d2495 2
a2496 2
		  irela->r_info = ELF_R_INFO (r_symndx,
					      ELF_R_TYPE (irela->r_info));
d2710 4
a2713 1
  irel[0].r_info = ELF_R_INFO (indx, howto->type);
d2720 1
a2720 1
	       * sizeof (Elf_External_Rel));
d2727 1
a2727 1
	       * sizeof (Elf_External_Rela));
d2780 1
d2788 1
a2788 1
	  nlocsyms = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d2813 5
d2824 1
a2824 1
	  r_symndx = ELF_R_SYM (rel->r_info);
d3142 1
d3147 1
a3147 1
  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size/sizeof (Elf_External_Sym);
d3254 5
d3269 2
d3298 1
a3298 1
	locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d3307 1
a3307 1
	      gotoff += ARCH_SIZE / 8;
d3316 2
d3320 1
a3320 1
			  &gotoff);
d3328 1
a3328 1
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *offarg)
d3330 1
a3330 1
  bfd_vma *off = offarg;
d3337 2
a3338 2
      h->got.offset = off[0];
      off[0] += ARCH_SIZE / 8;
d3377 1
a3377 1
      r_symndx = ELF_R_SYM (rcookie->rel->r_info);
d3411 1
a3411 1
	      isec = section_from_elf_index (rcookie->abfd, isym->st_shndx);
d3476 1
a3476 1
	  cookie.locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d3484 5
@


1.258
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@a22 3
#include "safe-ctype.h"

static bfd_boolean elf_link_add_object_symbols (bfd *, struct bfd_link_info *);
a24 1322
/* Given an ELF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
elf_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return elf_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return _bfd_elf_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* Add symbols from an ELF object file to the linker hash table.  */

static bfd_boolean
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean (*add_symbol_hook)
    (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
  bfd_boolean (*check_relocs)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
  bfd_boolean collect;
  Elf_Internal_Shdr *hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  struct elf_link_hash_entry **sym_hash;
  bfd_boolean dynamic;
  Elf_External_Versym *extversym = NULL;
  Elf_External_Versym *ever;
  struct elf_link_hash_entry *weaks;
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  bfd_boolean add_needed;
  struct elf_link_hash_table * hash_table;
  bfd_size_type amt;

  hash_table = elf_hash_table (info);

  bed = get_elf_backend_data (abfd);
  add_symbol_hook = bed->elf_add_symbol_hook;
  collect = bed->collect;

  if ((abfd->flags & DYNAMIC) == 0)
    dynamic = FALSE;
  else
    {
      dynamic = TRUE;

      /* You can't use -r against a dynamic object.  Also, there's no
	 hope of using a dynamic object which does not exactly match
	 the format of the output file.  */
      if (info->relocatable
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  goto error_return;
	}
    }

  /* As a GNU extension, any input sections which are named
     .gnu.warning.SYMBOL are treated as warning symbols for the given
     symbol.  This differs from .gnu.warning sections, which generate
     warnings when they are included in an output file.  */
  if (info->executable)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  const char *name;

	  name = bfd_get_section_name (abfd, s);
	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
	    {
	      char *msg;
	      bfd_size_type sz;
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");

	      name += sizeof ".gnu.warning." - 1;

	      /* If this is a shared object, then look up the symbol
		 in the hash table.  If it is there, and it is already
		 been defined, then we will not be using the entry
		 from this shared object, so we don't need to warn.
		 FIXME: If we see the definition in a regular object
		 later on, we will warn, but we shouldn't.  The only
		 fix is to keep track of what warnings we are supposed
		 to emit, and then handle them all at the end of the
		 link.  */
	      if (dynamic)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (hash_table, name,
					    FALSE, FALSE, TRUE);

		  /* FIXME: What about bfd_link_hash_common?  */
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak))
		    {
		      /* We don't want to issue this warning.  Clobber
			 the section size so that the warning does not
			 get copied into the output file.  */
		      s->_raw_size = 0;
		      continue;
		    }
		}

	      sz = bfd_section_size (abfd, s);
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
	      if (msg == NULL)
		goto error_return;

	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
		goto error_return;

	      msg[prefix_len + sz] = '\0';

	      if (! (_bfd_generic_link_add_one_symbol
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, collect, NULL)))
		goto error_return;

	      if (! info->relocatable)
		{
		  /* Clobber the section size so that the warning does
		     not get copied into the output file.  */
		  s->_raw_size = 0;
		}
	    }
	}
    }

  add_needed = TRUE;
  if (! dynamic)
    {
      /* If we are creating a shared library, create all the dynamic
	 sections immediately.  We need to attach them to something,
	 so we attach them to this BFD, provided it is the right
	 format.  FIXME: If there are no input BFD's of the same
	 format as the output, we can't make a shared library.  */
      if (info->shared
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
	{
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	    goto error_return;
	}
    }
  else if (!is_elf_hash_table (hash_table))
    goto error_return;
  else
    {
      asection *s;
      const char *soname = NULL;
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
      int ret;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;

      /* If this dynamic lib was specified on the command line with
	 --as-needed in effect, then we don't want to add a DT_NEEDED
	 tag unless the lib is actually used.  Similary for libs brought
	 in by another lib's DT_NEEDED.  */
      add_needed = elf_dyn_lib_class (abfd) == DYN_NORMAL;

      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	{
	  Elf_External_Dyn *dynbuf = NULL;
	  Elf_External_Dyn *extdyn;
	  Elf_External_Dyn *extdynend;
	  int elfsec;
	  unsigned long shlink;

	  dynbuf = bfd_malloc (s->_raw_size);
	  if (dynbuf == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
	    goto error_free_dyn;

	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
	  if (elfsec == -1)
	    goto error_free_dyn;
	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

	  extdyn = dynbuf;
	  extdynend = extdyn + s->_raw_size / sizeof (Elf_External_Dyn);
	  for (; extdyn < extdynend; extdyn++)
	    {
	      Elf_Internal_Dyn dyn;

	      elf_swap_dyn_in (abfd, extdyn, &dyn);
	      if (dyn.d_tag == DT_SONAME)
		{
		  unsigned int tagv = dyn.d_un.d_val;
		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (soname == NULL)
		    goto error_free_dyn;
		}
	      if (dyn.d_tag == DT_NEEDED)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & hash_table->needed;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      if (dyn.d_tag == DT_RUNPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & runpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
	      if (!runpath && dyn.d_tag == DT_RPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    {
		    error_free_dyn:
		      free (dynbuf);
		      goto error_return;
		    }
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & rpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	    }

	  free (dynbuf);
	}

      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

      /* We do not want to include any of the sections in a dynamic
	 object in the output file.  We hack by simply clobbering the
	 list of sections in the BFD.  This could be handled more
	 cleanly by, say, a new section flag; the existing
	 SEC_NEVER_LOAD flag is not the one we want, because that one
	 still implies that the section takes up space in the output
	 file.  */
      bfd_section_list_clear (abfd);

      /* If this is the first dynamic object found in the link, create
	 the special sections required for dynamic linking.  */
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;

      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  */
      if (soname == NULL || *soname == '\0')
	{
	  soname = elf_dt_name (abfd);
	  if (soname == NULL || *soname == '\0')
	    soname = bfd_get_filename (abfd);
	}

      /* Save the SONAME because sometimes the linker emulation code
	 will need to know it.  */
      elf_dt_name (abfd) = soname;

      ret = _bfd_elf_add_dt_needed_tag (info, soname, add_needed);
      if (ret < 0)
	goto error_return;

      /* If we have already included this dynamic object in the
	 link, just ignore it.  There is no reason to include a
	 particular dynamic object more than once.  */
      if (ret > 0)
	return TRUE;
    }

  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / sizeof (Elf_External_Sym);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  sym_hash = NULL;
  if (extsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;

      /* We store a pointer to the hash table entry for each external
	 symbol.  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sym_hash = bfd_alloc (abfd, amt);
      if (sym_hash == NULL)
	goto error_free_sym;
      elf_sym_hashes (abfd) = sym_hash;
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */
      if (! _bfd_elf_slurp_version_tables (abfd))
	goto error_free_sym;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_free_sym;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (extversym, amt, abfd) != amt)
	    goto error_free_vers;
	}
    }

  weaks = NULL;

  ever = extversym != NULL ? extversym + extsymoff : NULL;
  for (isym = isymbuf, isymend = isymbuf + extsymcount;
       isym < isymend;
       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
    {
      int bind;
      bfd_vma value;
      asection *sec;
      flagword flags;
      const char *name;
      struct elf_link_hash_entry *h;
      bfd_boolean definition;
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
      bfd_boolean new_weakdef;
      bfd_boolean override;
      unsigned int old_alignment;
      bfd *old_bfd;

      override = FALSE;

      flags = BSF_NO_FLAGS;
      sec = NULL;
      value = isym->st_value;
      *sym_hash = NULL;

      bind = ELF_ST_BIND (isym->st_info);
      if (bind == STB_LOCAL)
	{
	  /* This should be impossible, since ELF requires that all
	     global symbols follow all local symbols, and that sh_info
	     point to the first global symbol.  Unfortunately, Irix 5
	     screws this up.  */
	  continue;
	}
      else if (bind == STB_GLOBAL)
	{
	  if (isym->st_shndx != SHN_UNDEF
	      && isym->st_shndx != SHN_COMMON)
	    flags = BSF_GLOBAL;
	}
      else if (bind == STB_WEAK)
	flags = BSF_WEAK;
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      if (isym->st_shndx == SHN_UNDEF)
	sec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	{
	  sec = section_from_elf_index (abfd, isym->st_shndx);
	  if (sec == NULL)
	    sec = bfd_abs_section_ptr;
	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    value -= sec->vma;
	}
      else if (isym->st_shndx == SHN_ABS)
	sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	{
	  sec = bfd_com_section_ptr;
	  /* What ELF calls the size we call the value.  What ELF
	     calls the value we call the alignment.  */
	  value = isym->st_size;
	}
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	goto error_free_vers;

      if (isym->st_shndx == SHN_COMMON
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
	{
	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

	  if (tcomm == NULL)
	    {
	      tcomm = bfd_make_section (abfd, ".tcommon");
	      if (tcomm == NULL
		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
							   | SEC_IS_COMMON
							   | SEC_LINKER_CREATED
							   | SEC_THREAD_LOCAL)))
		goto error_free_vers;
	    }
	  sec = tcomm;
	}
      else if (add_symbol_hook)
	{
	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
				    &value))
	    goto error_free_vers;

	  /* The hook function sets the name to NULL if this symbol
	     should be skipped for some reason.  */
	  if (name == NULL)
	    continue;
	}

      /* Sanity check that all possibilities were handled.  */
      if (sec == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  goto error_free_vers;
	}

      if (bfd_is_und_section (sec)
	  || bfd_is_com_section (sec))
	definition = FALSE;
      else
	definition = TRUE;

      size_change_ok = FALSE;
      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
      old_alignment = 0;
      old_bfd = NULL;

      if (is_elf_hash_table (hash_table))
	{
	  Elf_Internal_Versym iver;
	  unsigned int vernum = 0;
	  bfd_boolean skip;

	  if (ever != NULL)
	    {
	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
	      vernum = iver.vs_vers & VERSYM_VERSION;

	      /* If this is a hidden symbol, or if it is not version
		 1, we append the version name to the symbol name.
		 However, we do not modify a non-hidden absolute
		 symbol, because it might be the version symbol
		 itself.  FIXME: What if it isn't?  */
	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
		{
		  const char *verstr;
		  size_t namelen, verlen, newlen;
		  char *newname, *p;

		  if (isym->st_shndx != SHN_UNDEF)
		    {
		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid version %u (max %d)"),
			     bfd_archive_filename (abfd), name, vernum,
			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		      else if (vernum > 1)
			verstr =
			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		      else
			verstr = "";
		    }
		  else
		    {
		      /* We cannot simply test for the number of
			 entries in the VERNEED section since the
			 numbers for the needed versions do not start
			 at 0.  */
		      Elf_Internal_Verneed *t;

		      verstr = NULL;
		      for (t = elf_tdata (abfd)->verref;
			   t != NULL;
			   t = t->vn_nextref)
			{
			  Elf_Internal_Vernaux *a;

			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
			    {
			      if (a->vna_other == vernum)
				{
				  verstr = a->vna_nodename;
				  break;
				}
			    }
			  if (a != NULL)
			    break;
			}
		      if (verstr == NULL)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid needed version %d"),
			     bfd_archive_filename (abfd), name, vernum);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		    }

		  namelen = strlen (name);
		  verlen = strlen (verstr);
		  newlen = namelen + verlen + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    ++newlen;

		  newname = bfd_alloc (abfd, newlen);
		  if (newname == NULL)
		    goto error_free_vers;
		  memcpy (newname, name, namelen);
		  p = newname + namelen;
		  *p++ = ELF_VER_CHR;
		  /* If this is a defined non-hidden version symbol,
		     we add another @@ to the name.  This indicates the
		     default version of the symbol.  */
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);

		  name = newname;
		}
	    }

	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok))
	    goto error_free_vers;

	  if (skip)
	    continue;

	  if (override)
	    definition = FALSE;

	  h = *sym_hash;
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* Remember the old alignment if this is a common symbol, so
	     that we don't reduce the alignment later on.  We can't
	     check later, because _bfd_generic_link_add_one_symbol
	     will set a default for the alignment which we want to
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;

	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }

	  if (elf_tdata (abfd)->verdef != NULL
	      && ! override
	      && vernum > 1
	      && definition)
	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
	}

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
	goto error_free_vers;

      h = *sym_hash;
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      *sym_hash = h;

      new_weakdef = FALSE;
      if (dynamic
	  && definition
	  && (flags & BSF_WEAK) != 0
	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
	  && is_elf_hash_table (hash_table)
	  && h->weakdef == NULL)
	{
	  /* Keep a list of all weak defined non function symbols from
	     a dynamic object, using the weakdef field.  Later in this
	     function we will set the weakdef field to the correct
	     value.  We only put non-function symbols from dynamic
	     objects on this list, because that happens to be the only
	     time we need to know the normal symbol corresponding to a
	     weak symbol, and the information is time consuming to
	     figure out.  If the weakdef field is not already NULL,
	     then this symbol was already defined by some previous
	     dynamic object, and we will be using that previous
	     definition anyhow.  */

	  h->weakdef = weaks;
	  weaks = h;
	  new_weakdef = TRUE;
	}

      /* Set the alignment of a common symbol.  */
      if (isym->st_shndx == SHN_COMMON
	  && h->root.type == bfd_link_hash_common)
	{
	  unsigned int align;

	  align = bfd_log2 (isym->st_value);
	  if (align > old_alignment
	      /* Permit an alignment power of zero if an alignment of one
		 is specified and no other alignments have been specified.  */
	      || (isym->st_value == 1 && old_alignment == 0))
	    h->root.u.c.p->alignment_power = align;
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
	}

      if (is_elf_hash_table (hash_table))
	{
	  int old_flags;
	  bfd_boolean dynsym;
	  int new_flag;

	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overridden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
	    }

	  /* Remember the symbol size and type.  */
	  if (isym->st_size != 0
	      && (definition || h->size == 0))
	    {
	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
		   name, (unsigned long) h->size,
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));

	      h->size = isym->st_size;
	    }

	  /* If this is a common symbol, then we always want H->SIZE
	     to be the size of the common symbol.  The code just above
	     won't fix the size if a common symbol becomes larger.  We
	     don't warn about a size change here, because that is
	     covered by --warn-common.  */
	  if (h->root.type == bfd_link_hash_common)
	    h->size = h->root.u.c.size;

	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
	      && (definition || h->type == STT_NOTYPE))
	    {
	      if (h->type != STT_NOTYPE
		  && h->type != ELF_ST_TYPE (isym->st_info)
		  && ! type_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
		   name, h->type, ELF_ST_TYPE (isym->st_info),
		   bfd_archive_filename (abfd));

	      h->type = ELF_ST_TYPE (isym->st_info);
	    }

	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

	  if (isym->st_other != 0 && !dynamic)
	    {
	      unsigned char hvis, symvis, other, nvis;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);

	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;

	      h->other = other | nvis;
	    }

	  /* Set a flag in the hash table entry indicating the type of
	     reference or definition we just found.  Keep a count of
	     the number of dynamic symbols we find.  A dynamic symbol
	     is one which is referenced or defined by both a regular
	     object and a shared object.  */
	  old_flags = h->elf_link_hash_flags;
	  dynsym = FALSE;
	  if (! dynamic)
	    {
	      if (! definition)
		{
		  new_flag = ELF_LINK_HASH_REF_REGULAR;
		  if (bind != STB_WEAK)
		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
		}
	      else
		new_flag = ELF_LINK_HASH_DEF_REGULAR;
	      if (! info->executable
		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
		dynsym = TRUE;
	    }
	  else
	    {
	      if (! definition)
		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
	      else
		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR)) != 0
		  || (h->weakdef != NULL
		      && ! new_weakdef
		      && h->weakdef->dynindx != -1))
		dynsym = TRUE;
	    }

	  h->elf_link_hash_flags |= new_flag;

	  /* Check to see if we need to add an indirect symbol for
	     the default name.  */
	  if (definition || h->root.type == bfd_link_hash_common)
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override))
	      goto error_free_vers;

	  if (definition && !dynamic)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (! nondeflt_vers)
		    {
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
		      nondeflt_vers = bfd_malloc (amt);
		    }
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
		}
	    }

	  if (dynsym && h->dynindx == -1)
	    {
	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
		goto error_free_vers;
	      if (h->weakdef != NULL
		  && ! new_weakdef
		  && h->weakdef->dynindx == -1)
		{
		  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
		    goto error_free_vers;
		}
	    }
	  else if (dynsym && h->dynindx != -1)
	    /* If the symbol already has a dynamic index, but
	       visibility says it should not be visible, turn it into
	       a local symbol.  */
	    switch (ELF_ST_VISIBILITY (h->other))
	      {
	      case STV_INTERNAL:
	      case STV_HIDDEN:
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
		dynsym = FALSE;
		break;
	      }

	  if (!add_needed
	      && definition
	      && dynsym
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_REF_REGULAR) != 0)
	    {
	      int ret;
	      const char *soname = elf_dt_name (abfd);

	      /* A symbol from a library loaded via DT_NEEDED of some
		 other library is referenced by a regular object.
		 Add a DT_NEEDED entry for it.  */
	      add_needed = TRUE;
	      ret = _bfd_elf_add_dt_needed_tag (info, soname, add_needed);
	      if (ret < 0)
		goto error_free_vers;

	      BFD_ASSERT (ret == 0);
	    }
	}
    }

  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = bfd_malloc (amt + 1);
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (&hash_table->root, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    free (isymbuf);
  isymbuf = NULL;

  /* Now set the weakdefs field correctly for all the weak defined
     symbols we found.  The only way to do this is to search all the
     symbols.  Since we only need the information for non functions in
     dynamic objects, that's the only time we actually put anything on
     the list WEAKS.  We need this information so that if a regular
     object refers to a symbol defined weakly in a dynamic object, the
     real symbol in the dynamic object is also put in the dynamic
     symbols; we also must arrange for both symbols to point to the
     same memory location.  We could handle the general case of symbol
     aliasing, but a general symbol alias can only be generated in
     assembler code, handling it correctly would be very time
     consuming, and other ELF linkers don't handle general aliasing
     either.  */
  if (weaks != NULL)
    {
      struct elf_link_hash_entry **hpp;
      struct elf_link_hash_entry **hppend;
      struct elf_link_hash_entry **sorted_sym_hash;
      struct elf_link_hash_entry *h;
      size_t sym_count;

      /* Since we have to search the whole symbol list for each weak
	 defined symbol, search time for N weak defined symbols will be
	 O(N^2). Binary search will cut it down to O(NlogN).  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sorted_sym_hash = bfd_malloc (amt);
      if (sorted_sym_hash == NULL)
	goto error_return;
      sym_hash = sorted_sym_hash;
      hpp = elf_sym_hashes (abfd);
      hppend = hpp + extsymcount;
      sym_count = 0;
      for (; hpp < hppend; hpp++)
	{
	  h = *hpp;
	  if (h != NULL
	      && h->root.type == bfd_link_hash_defined
	      && h->type != STT_FUNC)
	    {
	      *sym_hash = h;
	      sym_hash++;
	      sym_count++;
	    }
	}

      qsort (sorted_sym_hash, sym_count,
	     sizeof (struct elf_link_hash_entry *),
	     _bfd_elf_sort_symbol);

      while (weaks != NULL)
	{
	  struct elf_link_hash_entry *hlook;
	  asection *slook;
	  bfd_vma vlook;
	  long ilook;
	  size_t i, j, idx;

	  hlook = weaks;
	  weaks = hlook->weakdef;
	  hlook->weakdef = NULL;

	  BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
		      || hlook->root.type == bfd_link_hash_defweak
		      || hlook->root.type == bfd_link_hash_common
		      || hlook->root.type == bfd_link_hash_indirect);
	  slook = hlook->root.u.def.section;
	  vlook = hlook->root.u.def.value;

	  ilook = -1;
	  i = 0;
	  j = sym_count;
	  while (i < j)
	    {
	      bfd_signed_vma vdiff;
	      idx = (i + j) / 2;
	      h = sorted_sym_hash [idx];
	      vdiff = vlook - h->root.u.def.value;
	      if (vdiff < 0)
		j = idx;
	      else if (vdiff > 0)
		i = idx + 1;
	      else
		{
		  long sdiff = slook - h->root.u.def.section;
		  if (sdiff < 0)
		    j = idx;
		  else if (sdiff > 0)
		    i = idx + 1;
		  else
		    {
		      ilook = idx;
		      break;
		    }
		}
	    }

	  /* We didn't find a value/section match.  */
	  if (ilook == -1)
	    continue;

	  for (i = ilook; i < sym_count; i++)
	    {
	      h = sorted_sym_hash [i];

	      /* Stop if value or section doesn't match.  */
	      if (h->root.u.def.value != vlook
		  || h->root.u.def.section != slook)
		break;
	      else if (h != hlook)
		{
		  hlook->weakdef = h;

		  /* If the weak definition is in the list of dynamic
		     symbols, make sure the real definition is put
		     there as well.  */
		  if (hlook->dynindx != -1 && h->dynindx == -1)
		    {
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 h))
			goto error_return;
		    }

		  /* If the real definition is in the list of dynamic
		     symbols, make sure the weak definition is put
		     there as well.  If we don't do this, then the
		     dynamic loader might not merge the entries for the
		     real definition and the weak definition.  */
		  if (h->dynindx != -1 && hlook->dynindx == -1)
		    {
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 hlook))
			goto error_return;
		    }
		  break;
		}
	    }
	}

      free (sorted_sym_hash);
    }

  /* If this object is the same format as the output object, and it is
     not a shared library, then let the backend look through the
     relocs.

     This is required to build global offset table entries and to
     arrange for dynamic relocs.  It is not required for the
     particular common case of linking non PIC code, even when linking
     against shared libraries, but unfortunately there is no way of
     knowing whether an object file has been compiled PIC or not.
     Looking through the relocs is not particularly time consuming.
     The problem is that we must either (1) keep the relocs in memory,
     which causes the linker to require additional runtime memory or
     (2) read the relocs twice from the input file, which wastes time.
     This would be a good case for using mmap.

     I have no idea how to handle linking PIC code into a file of a
     different format.  It probably can't be done.  */
  check_relocs = get_elf_backend_data (abfd)->check_relocs;
  if (! dynamic
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
      && check_relocs != NULL)
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_boolean ok;

	  if ((o->flags & SEC_RELOC) == 0
	      || o->reloc_count == 0
	      || ((info->strip == strip_all || info->strip == strip_debugger)
		  && (o->flags & SEC_DEBUGGING) != 0)
	      || bfd_is_abs_section (o->output_section))
	    continue;

	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;

	  ok = (*check_relocs) (abfd, info, o, internal_relocs);

	  if (elf_section_data (o)->relocs != internal_relocs)
	    free (internal_relocs);

	  if (! ok)
	    goto error_return;
	}
    }

  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
  if (! dynamic
      && ! info->traditional_format
      && is_elf_hash_table (hash_table)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;

		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd,
					       & hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
	    }
	}
    }

  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (s->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (s);
	    if (! _bfd_merge_section (abfd,
				      & hash_table->merge_info,
				      s, &secdata->sec_info))
	      goto error_return;
	    else if (secdata->sec_info)
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }
    }

  if (is_elf_hash_table (hash_table))
    {
      /* Add this bfd to the loaded list.  */
      struct elf_link_loaded_list *n;

      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
      if (n == NULL)
	goto error_return;
      n->abfd = abfd;
      n->next = hash_table->loaded;
      hash_table->loaded = n;
    }

  return TRUE;

 error_free_vers:
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
  if (extversym != NULL)
    free (extversym);
 error_free_sym:
  if (isymbuf != NULL)
    free (isymbuf);
 error_return:
  return FALSE;
}

@


1.257
log
@	* elflink.c (_bfd_elf_merge_symbol): Revert last change.  Move
	type and size change code to where it was previously.  Remove
	dt_needed param.  Treat old weak syms as strong if new sym is
	from a shared lib, even when old sym is from another shared
	lib.  Remove unnecessary tests of oldweak and newweak.  Correct
	comments.
	(_bfd_elf_add_default_symbol): Remove dt_needed param.  Update
	_bfd_elf_merge_symbol calls.
	* elflink.h (elf_link_add_object_symbols): Update calls.  Remove
	dt_needed local var.  Update comments.
	* elf-bfd.h (_bfd_elf_merge_symbol): Update prototype.
	(_bfd_elf_add_default_symbol): Likewise.
@
text
@a25 3
static bfd_boolean elf_finalize_dynstr (bfd *, struct bfd_link_info *);
static bfd_boolean elf_collect_hash_codes (struct elf_link_hash_entry *,
					   void *);
a44 75

/* Sort symbol by value and section.  */
static int
sort_symbol (const void *arg1, const void *arg2)
{
  const struct elf_link_hash_entry *h1
    = *(const struct elf_link_hash_entry **) arg1;
  const struct elf_link_hash_entry *h2
    = *(const struct elf_link_hash_entry **) arg2;
  bfd_signed_vma vdiff = h1->root.u.def.value - h2->root.u.def.value;

  if (vdiff)
    return vdiff > 0 ? 1 : -1;
  else
    {
      long sdiff = h1->root.u.def.section - h2->root.u.def.section;
      if (sdiff)
	return sdiff > 0 ? 1 : -1;
      else
	return 0;
    }
}

/* Add a DT_NEEDED entry for this dynamic object.  Returns -1 on error,
   1 if a DT_NEEDED tag already exists, and 0 on success.  */

static int
add_dt_needed_tag (struct bfd_link_info *info, const char *soname,
		   bfd_boolean do_it)
{
  struct elf_link_hash_table *hash_table;
  bfd_size_type oldsize;
  bfd_size_type strindex;

  hash_table = elf_hash_table (info);
  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);
  if (strindex == (bfd_size_type) -1)
    return -1;

  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
    {
      asection *sdyn;
      Elf_External_Dyn *dyncon, *dynconend;

      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf_External_Dyn *) sdyn->contents;
      dynconend = (Elf_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  elf_swap_dyn_in (hash_table->dynobj, dyncon, & dyn);
	  if (dyn.d_tag == DT_NEEDED
	      && dyn.d_un.d_val == strindex)
	    {
	      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
	      return 1;
	    }
	}
    }

  if (do_it)
    {
      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	return -1;
    }
  else
    /* We were just checking for existence of the tag.  */
    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);

  return 0;
}
d382 1
a382 1
      ret = add_dt_needed_tag (info, soname, add_needed);
d986 1
d990 3
a992 1
	  if (!add_needed && definition
d997 1
d1003 1
a1003 1
	      ret = add_dt_needed_tag (info, elf_dt_name (abfd), add_needed);
d1118 1
a1118 1
	     sort_symbol);
a1348 1097

/* Add an entry to the .dynamic table.  */

bfd_boolean
elf_add_dynamic_entry (struct bfd_link_info *info, bfd_vma tag, bfd_vma val)
{
  Elf_Internal_Dyn dyn;
  bfd *dynobj;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  s = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);

  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
  newcontents = bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
    return FALSE;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  elf_swap_dyn_out (dynobj, &dyn,
		    (Elf_External_Dyn *) (newcontents + s->_raw_size));

  s->_raw_size = newsize;
  s->contents = newcontents;

  return TRUE;
}

/* Array used to determine the number of hash table buckets to use
   based on the number of symbols there are.  If there are fewer than
   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
   fewer than 37 we use 17 buckets, and so forth.  We never use more
   than 32771 buckets.  */

static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};

/* Compute bucket count for hashing table.  We do not use a static set
   of possible tables sizes anymore.  Instead we determine for all
   possible reasonable sizes of the table the outcome (i.e., the
   number of collisions etc) and choose the best solution.  The
   weighting functions are not too simple to allow the table to grow
   without bounds.  Instead one of the weighting factors is the size.
   Therefore the result is always a good payoff between few collisions
   (= short chain lengths) and table size.  */
static size_t
compute_bucket_count (struct bfd_link_info *info)
{
  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
  size_t best_size = 0;
  unsigned long int *hashcodes;
  unsigned long int *hashcodesp;
  unsigned long int i;
  bfd_size_type amt;

  /* Compute the hash values for all exported symbols.  At the same
     time store the values in an array so that we could use them for
     optimizations.  */
  amt = dynsymcount;
  amt *= sizeof (unsigned long int);
  hashcodes = bfd_malloc (amt);
  if (hashcodes == NULL)
    return 0;
  hashcodesp = hashcodes;

  /* Put all hash values in HASHCODES.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_collect_hash_codes, &hashcodesp);

  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
#ifdef BFD_HOST_U_64_BIT
  if (info->optimize)
    {
      unsigned long int nsyms = hashcodesp - hashcodes;
      size_t minsize;
      size_t maxsize;
      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
      unsigned long int *counts ;

      /* Possible optimization parameters: if we have NSYMS symbols we say
	 that the hashing table must at least have NSYMS/4 and at most
	 2*NSYMS buckets.  */
      minsize = nsyms / 4;
      if (minsize == 0)
	minsize = 1;
      best_size = maxsize = nsyms * 2;

      /* Create array where we count the collisions in.  We must use bfd_malloc
	 since the size could be large.  */
      amt = maxsize;
      amt *= sizeof (unsigned long int);
      counts = bfd_malloc (amt);
      if (counts == NULL)
	{
	  free (hashcodes);
	  return 0;
	}

      /* Compute the "optimal" size for the hash table.  The criteria is a
	 minimal chain length.  The minor criteria is (of course) the size
	 of the table.  */
      for (i = minsize; i < maxsize; ++i)
	{
	  /* Walk through the array of hashcodes and count the collisions.  */
	  BFD_HOST_U_64_BIT max;
	  unsigned long int j;
	  unsigned long int fact;

	  memset (counts, '\0', i * sizeof (unsigned long int));

	  /* Determine how often each hash bucket is used.  */
	  for (j = 0; j < nsyms; ++j)
	    ++counts[hashcodes[j] % i];

	  /* For the weight function we need some information about the
	     pagesize on the target.  This is information need not be 100%
	     accurate.  Since this information is not available (so far) we
	     define it here to a reasonable default value.  If it is crucial
	     to have a better value some day simply define this value.  */
# ifndef BFD_TARGET_PAGESIZE
#  define BFD_TARGET_PAGESIZE	(4096)
# endif

	  /* We in any case need 2 + NSYMS entries for the size values and
	     the chains.  */
	  max = (2 + nsyms) * (ARCH_SIZE / 8);

# if 1
	  /* Variant 1: optimize for short chains.  We add the squares
	     of all the chain lengths (which favors many small chain
	     over a few long chains).  */
	  for (j = 0; j < i; ++j)
	    max += counts[j] * counts[j];

	  /* This adds penalties for the overall size of the table.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
	  max *= fact * fact;
# else
	  /* Variant 2: Optimize a lot more for small table.  Here we
	     also add squares of the size but we also add penalties for
	     empty slots (the +1 term).  */
	  for (j = 0; j < i; ++j)
	    max += (1 + counts[j]) * (1 + counts[j]);

	  /* The overall size of the table is considered, but not as
	     strong as in variant 1, where it is squared.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
	  max *= fact;
# endif

	  /* Compare with current best results.  */
	  if (max < best_chlen)
	    {
	      best_chlen = max;
	      best_size = i;
	    }
	}

      free (counts);
    }
  else
#endif /* defined (BFD_HOST_U_64_BIT) */
    {
      /* This is the fallback solution if no 64bit type is available or if we
	 are not supposed to spend much time on optimizations.  We select the
	 bucket count using a fixed set of numbers.  */
      for (i = 0; elf_buckets[i] != 0; i++)
	{
	  best_size = elf_buckets[i];
	  if (dynsymcount < elf_buckets[i + 1])
	    break;
	}
    }

  /* Free the arrays we needed.  */
  free (hashcodes);

  return best_size;
}

/* Set up the sizes and contents of the ELF dynamic sections.  This is
   called by the ELF linker emulation before_allocation routine.  We
   must set the sizes of the sections before the linker sets the
   addresses of the various sections.  */

bfd_boolean
NAME(bfd_elf,size_dynamic_sections) (bfd *output_bfd,
				     const char *soname,
				     const char *rpath,
				     const char *filter_shlib,
				     const char * const *auxiliary_filters,
				     struct bfd_link_info *info,
				     asection **sinterpptr,
				     struct bfd_elf_version_tree *verdefs)
{
  bfd_size_type soname_indx;
  bfd *dynobj;
  const struct elf_backend_data *bed;
  struct elf_assign_sym_version_info asvinfo;

  *sinterpptr = NULL;

  soname_indx = (bfd_size_type) -1;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  if (info->execstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags & DYNAMIC)
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else
	    exec = PF_X;
	}
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
    }

  /* Any syms created from now on start with -1 in
     got.refcount/offset and plt.refcount/offset.  */
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;

  /* The backend may have to create some sections regardless of whether
     we're dynamic or not.  */
  bed = get_elf_backend_data (output_bfd);
  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  /* If there were no dynamic objects in the link, there is nothing to
     do here.  */
  if (dynobj == NULL)
    return TRUE;

  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_info_failed eif;
      struct elf_link_hash_entry *h;
      asection *dynstr;
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      bfd_boolean all_defined;

      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);

      if (soname != NULL)
	{
	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					     soname, TRUE);
	  if (soname_indx == (bfd_size_type) -1
	      || ! elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
	    return FALSE;
	}

      if (info->symbolic)
	{
	  if (! elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
	    return FALSE;
	  info->flags |= DF_SYMBOLIC;
	}

      if (rpath != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
				      TRUE);
	  if (info->new_dtags)
	    _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
	  if (indx == (bfd_size_type) -1
	      || ! elf_add_dynamic_entry (info, DT_RPATH, indx)
	      || (info->new_dtags
		  && ! elf_add_dynamic_entry (info, DT_RUNPATH, indx)))
	    return FALSE;
	}

      if (filter_shlib != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
				      filter_shlib, TRUE);
	  if (indx == (bfd_size_type) -1
	      || ! elf_add_dynamic_entry (info, DT_FILTER, indx))
	    return FALSE;
	}

      if (auxiliary_filters != NULL)
	{
	  const char * const *p;

	  for (p = auxiliary_filters; *p != NULL; p++)
	    {
	      bfd_size_type indx;

	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  *p, TRUE);
	      if (indx == (bfd_size_type) -1
		  || ! elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
		return FALSE;
	    }
	}

      eif.info = info;
      eif.verdefs = verdefs;
      eif.failed = FALSE;

      /* If we are supposed to export all symbols into the dynamic symbol
	 table (this is not the normal case), then do so.  */
      if (info->export_dynamic)
	{
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
				  &eif);
	  if (eif.failed)
	    return FALSE;
	}

      /* Make all global versions with definition.  */
      for (t = verdefs; t != NULL; t = t->next)
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->symbol)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;
	      struct elf_link_hash_entry *newh;

	      name = d->symbol;
	      namelen = strlen (name);
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3;

	      newname = bfd_malloc (newlen);
	      if (newname == NULL)
		return FALSE;
	      memcpy (newname, name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, FALSE, FALSE,
					   FALSE);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, FALSE, FALSE,
					       FALSE);
		}
	      free (newname);

	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
	      if (newh != NULL
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

      /* Attach all the symbols to their version information.  */
      asvinfo.output_bfd = output_bfd;
      asvinfo.info = info;
      asvinfo.verdefs = verdefs;
      asvinfo.failed = FALSE;

      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_link_assign_sym_version,
			      &asvinfo);
      if (asvinfo.failed)
	return FALSE;

      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definition.  */
	  all_defined = TRUE;
	  for (t = verdefs; t != NULL; t = t->next)
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (!d->symver && !d->script)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = FALSE;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      /* Find all symbols which were defined in a dynamic object and make
	 the backend pick a reasonable value for them.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_adjust_dynamic_symbol,
			      &eif);
      if (eif.failed)
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in elf_bfd_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */

      /* If there are initialization and/or finalization functions to
	 call then add the corresponding DT_INIT/DT_FINI entries.  */
      h = (info->init_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->init_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (! elf_add_dynamic_entry (info, DT_INIT, 0))
	    return FALSE;
	}
      h = (info->fini_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->fini_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (! elf_add_dynamic_entry (info, DT_FINI, 0))
	    return FALSE;
	}

      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (! info->executable)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%s: .preinit_array section is not allowed in DSO"),
			 bfd_archive_filename (sub));
		      break;
		    }

	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return FALSE;
	    }

	  if (!elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
	    return FALSE;
	}

      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
      /* If .dynstr is excluded from the link, we don't want any of
	 these tags.  Strictly, we should be checking each section
	 individually;  This quick check covers for the case where
	 someone does a /DISCARD/ : { *(*) }.  */
      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
	{
	  bfd_size_type strsize;

	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	  if (! elf_add_dynamic_entry (info, DT_HASH, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || ! elf_add_dynamic_entry (info, DT_SYMENT,
					  sizeof (Elf_External_Sym)))
	    return FALSE;
	}
    }

  /* The backend must work out the sizes of all the other dynamic
     sections.  */
  if (bed->elf_backend_size_dynamic_sections
      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_size_type dynsymcount;
      asection *s;
      size_t bucketcount = 0;
      size_t hash_entry_size;
      unsigned int dtagcount;

      /* Set up the version definition section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      BFD_ASSERT (s != NULL);

      /* We may have created additional version definitions if we are
	 just linking a regular application.  */
      verdefs = asvinfo.verdefs;

      /* Skip anonymous version tag.  */
      if (verdefs != NULL && verdefs->vernum == 0)
	verdefs = verdefs->next;

      if (verdefs == NULL)
	_bfd_strip_section_from_output (info, s);
      else
	{
	  unsigned int cdefs;
	  bfd_size_type size;
	  struct bfd_elf_version_tree *t;
	  bfd_byte *p;
	  Elf_Internal_Verdef def;
	  Elf_Internal_Verdaux defaux;

	  cdefs = 0;
	  size = 0;

	  /* Make space for the base version.  */
	  size += sizeof (Elf_External_Verdef);
	  size += sizeof (Elf_External_Verdaux);
	  ++cdefs;

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      struct bfd_elf_version_deps *n;

	      size += sizeof (Elf_External_Verdef);
	      size += sizeof (Elf_External_Verdaux);
	      ++cdefs;

	      for (n = t->deps; n != NULL; n = n->next)
		size += sizeof (Elf_External_Verdaux);
	    }

	  s->_raw_size = size;
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
	    return FALSE;

	  /* Fill in the version definition section.  */

	  p = s->contents;

	  def.vd_version = VER_DEF_CURRENT;
	  def.vd_flags = VER_FLG_BASE;
	  def.vd_ndx = 1;
	  def.vd_cnt = 1;
	  def.vd_aux = sizeof (Elf_External_Verdef);
	  def.vd_next = (sizeof (Elf_External_Verdef)
			 + sizeof (Elf_External_Verdaux));

	  if (soname_indx != (bfd_size_type) -1)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      soname_indx);
	      def.vd_hash = bfd_elf_hash (soname);
	      defaux.vda_name = soname_indx;
	    }
	  else
	    {
	      const char *name;
	      bfd_size_type indx;

	      name = basename (output_bfd->filename);
	      def.vd_hash = bfd_elf_hash (name);
	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  name, FALSE);
	      if (indx == (bfd_size_type) -1)
		return FALSE;
	      defaux.vda_name = indx;
	    }
	  defaux.vda_next = 0;

	  _bfd_elf_swap_verdef_out (output_bfd, &def,
				    (Elf_External_Verdef *) p);
	  p += sizeof (Elf_External_Verdef);
	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
				     (Elf_External_Verdaux *) p);
	  p += sizeof (Elf_External_Verdaux);

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      unsigned int cdeps;
	      struct bfd_elf_version_deps *n;
	      struct elf_link_hash_entry *h;
	      struct bfd_link_hash_entry *bh;

	      cdeps = 0;
	      for (n = t->deps; n != NULL; n = n->next)
		++cdeps;

	      /* Add a symbol representing this version.  */
	      bh = NULL;
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
		      0, NULL, FALSE,
		      get_elf_backend_data (dynobj)->collect, &bh)))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	      h->type = STT_OBJECT;
	      h->verinfo.vertree = t;

	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;

	      def.vd_version = VER_DEF_CURRENT;
	      def.vd_flags = 0;
	      if (t->globals.list == NULL && t->locals.list == NULL && ! t->used)
		def.vd_flags |= VER_FLG_WEAK;
	      def.vd_ndx = t->vernum + 1;
	      def.vd_cnt = cdeps + 1;
	      def.vd_hash = bfd_elf_hash (t->name);
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      if (t->next != NULL)
		def.vd_next = (sizeof (Elf_External_Verdef)
			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));
	      else
		def.vd_next = 0;

	      _bfd_elf_swap_verdef_out (output_bfd, &def,
					(Elf_External_Verdef *) p);
	      p += sizeof (Elf_External_Verdef);

	      defaux.vda_name = h->dynstr_index;
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      h->dynstr_index);
	      if (t->deps == NULL)
		defaux.vda_next = 0;
	      else
		defaux.vda_next = sizeof (Elf_External_Verdaux);
	      t->name_indx = defaux.vda_name;

	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					 (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);

	      for (n = t->deps; n != NULL; n = n->next)
		{
		  if (n->version_needed == NULL)
		    {
		      /* This can happen if there was an error in the
			 version script.  */
		      defaux.vda_name = 0;
		    }
		  else
		    {
		      defaux.vda_name = n->version_needed->name_indx;
		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
					      defaux.vda_name);
		    }
		  if (n->next == NULL)
		    defaux.vda_next = 0;
		  else
		    defaux.vda_next = sizeof (Elf_External_Verdaux);

		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					     (Elf_External_Verdaux *) p);
		  p += sizeof (Elf_External_Verdaux);
		}
	    }

	  if (! elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || ! elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
	    return FALSE;

	  elf_tdata (output_bfd)->cverdefs = cdefs;
	}

      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
	{
	  if (! elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
	    return FALSE;
	}
      else if (info->flags & DF_BIND_NOW)
	{
	  if (! elf_add_dynamic_entry (info, DT_BIND_NOW, 0))
	    return FALSE;
	}

      if (info->flags_1)
	{
	  if (info->executable)
	    info->flags_1 &= ~ (DF_1_INITFIRST
				| DF_1_NODELETE
				| DF_1_NOOPEN);
	  if (! elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
	    return FALSE;
	}

      /* Work out the size of the version reference section.  */

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      BFD_ASSERT (s != NULL);
      {
	struct elf_find_verdep_info sinfo;

	sinfo.output_bfd = output_bfd;
	sinfo.info = info;
	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
	if (sinfo.vers == 0)
	  sinfo.vers = 1;
	sinfo.failed = FALSE;

	elf_link_hash_traverse (elf_hash_table (info),
				_bfd_elf_link_find_version_dependencies,
				&sinfo);

	if (elf_tdata (output_bfd)->verref == NULL)
	  _bfd_strip_section_from_output (info, s);
	else
	  {
	    Elf_Internal_Verneed *t;
	    unsigned int size;
	    unsigned int crefs;
	    bfd_byte *p;

	    /* Build the version definition section.  */
	    size = 0;
	    crefs = 0;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		Elf_Internal_Vernaux *a;

		size += sizeof (Elf_External_Verneed);
		++crefs;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  size += sizeof (Elf_External_Vernaux);
	      }

	    s->_raw_size = size;
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
	    if (s->contents == NULL)
	      return FALSE;

	    p = s->contents;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		unsigned int caux;
		Elf_Internal_Vernaux *a;
		bfd_size_type indx;

		caux = 0;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  ++caux;

		t->vn_version = VER_NEED_CURRENT;
		t->vn_cnt = caux;
		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					    elf_dt_name (t->vn_bfd) != NULL
					    ? elf_dt_name (t->vn_bfd)
					    : basename (t->vn_bfd->filename),
					    FALSE);
		if (indx == (bfd_size_type) -1)
		  return FALSE;
		t->vn_file = indx;
		t->vn_aux = sizeof (Elf_External_Verneed);
		if (t->vn_nextref == NULL)
		  t->vn_next = 0;
		else
		  t->vn_next = (sizeof (Elf_External_Verneed)
				+ caux * sizeof (Elf_External_Vernaux));

		_bfd_elf_swap_verneed_out (output_bfd, t,
					   (Elf_External_Verneed *) p);
		p += sizeof (Elf_External_Verneed);

		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  {
		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
						a->vna_nodename, FALSE);
		    if (indx == (bfd_size_type) -1)
		      return FALSE;
		    a->vna_name = indx;
		    if (a->vna_nextptr == NULL)
		      a->vna_next = 0;
		    else
		      a->vna_next = sizeof (Elf_External_Vernaux);

		    _bfd_elf_swap_vernaux_out (output_bfd, a,
					       (Elf_External_Vernaux *) p);
		    p += sizeof (Elf_External_Vernaux);
		  }
	      }

	    if (! elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| ! elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
	      return FALSE;

	    elf_tdata (output_bfd)->cverrefs = crefs;
	  }
      }

      /* Assign dynsym indicies.  In a shared library we generate a
	 section symbol for each output section, which come first.
	 Next come all of the back-end allocated local dynamic syms,
	 followed by the rest of the global symbols.  */

      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);

      /* Work out the size of the symbol version section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version");
      BFD_ASSERT (s != NULL);
      if (dynsymcount == 0
	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
	{
	  _bfd_strip_section_from_output (info, s);
	  /* The DYNSYMCOUNT might have changed if we were going to
	     output a dynamic symbol table entry for S.  */
	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
	}
      else
	{
	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL)
	    return FALSE;

	  if (! elf_add_dynamic_entry (info, DT_VERSYM, 0))
	    return FALSE;
	}

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols in elf_link_add_object_symbols.
	 We will build the contents of .dynsym and .hash when we build
	 the final symbol table, because until then we do not know the
	 correct value to give the symbols.  We built the .dynstr
	 section as we went along in elf_link_add_object_symbols.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->_raw_size = dynsymcount * sizeof (Elf_External_Sym);
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;

      if (dynsymcount != 0)
	{
	  Elf_Internal_Sym isym;

	  /* The first entry in .dynsym is a dummy symbol.  */
	  isym.st_value = 0;
	  isym.st_size = 0;
	  isym.st_name = 0;
	  isym.st_info = 0;
	  isym.st_other = 0;
	  isym.st_shndx = 0;
	  elf_swap_symbol_out (output_bfd, &isym, s->contents, 0);
	}

      /* Compute the size of the hashing table.  As a side effect this
	 computes the hash values for all the names we export.  */
      bucketcount = compute_bucket_count (info);

      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;

      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
	       s->contents + hash_entry_size);

      elf_hash_table (info)->bucketcount = bucketcount;

      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);

      elf_finalize_dynstr (output_bfd, info);

      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
	if (! elf_add_dynamic_entry (info, DT_NULL, 0))
	  return FALSE;
    }

  return TRUE;
}

/* This function is used to adjust offsets into .dynstr for
   dynamic symbols.  This is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
{
  struct elf_strtab_hash *dynstr = data;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}

/* Assign string offsets in .dynstr, update all structures referencing
   them.  */

static bfd_boolean
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *sdyn;
  bfd_size_type size;
  Elf_External_Dyn *dyncon, *dynconend;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);

  /* Update all .dynamic entries referencing .dynstr strings.  */
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  dyncon = (Elf_External_Dyn *) sdyn->contents;
  dynconend = (Elf_External_Dyn *) (sdyn->contents +
				    sdyn->_raw_size);
  for (; dyncon < dynconend; dyncon++)
    {
      Elf_Internal_Dyn dyn;

      elf_swap_dyn_in (dynobj, dyncon, & dyn);
      switch (dyn.d_tag)
	{
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	default:
	  break;
	}
    }

  /* Now update local dynamic symbols.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);

  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_adjust_dynstr_offsets, dynstr);

  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = (bfd_byte *) s->contents;
      do
	{
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
	    {
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
	    }
	}
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = (bfd_byte *) s->contents;
      do
	{
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
	    {
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
	    }
	}
      while (need.vn_next);
    }

  return TRUE;
}
a4629 45
}

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  unsigned long **valuep = data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_hash (name);

  /* Store the found hash value in the array given as the argument.  */
  *(*valuep)++ = ha;

  /* And store it in the struct so that we can put it in the hash table
     later.  */
  h->elf_hash_value = ha;

  if (alc != NULL)
    free (alc);

  return TRUE;
@


1.256
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Delete dt_soname field.  Add
	dyn_lib_class field.  Rearrange for better packing.
	(elf_dt_soname): Delete.
	(elf_dyn_lib_class): Define.
	* elf.c (bfd_elf_set_dt_needed_name): Update comment.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): New function.
	* elflink.h (add_dt_needed_tag): New function.  Split out from..
	(elf_link_add_object_symbols): ..here.  Rename "name" to "soname".
	Use elf_dyn_lib_class to set dt_needed and add_needed.  Move fallback
	initialization of soname.
	(elf_link_check_versioned_symbol): Test elf_dyn_lib_class instead of
	elf_dt_soname.
	* bfd-in.h (enum dynamic_lib_link_class): New.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ld.texinfo: Add --as-needed doco.
	* ldmain.c (as_needed): New global var.
	* ldmain.h (as_needed): Declare.
	* lexsup.c (option_values): Add OPTION_AS_NEEDED and
	OPTION_NO_AS_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
	* ldlang.h (lang_input_statement_type): Add as_needed field.
	* ldlang.c (new_afile): Set p->as_needed.
	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): New function.
	(gld${EMULATION_NAME}_try_needed): Use bfd_elf_set_dyn_lib_class.
	(ld_${EMULATION_NAME}_emulation): Set LDEMUL_RECOGNIZED_FILE entry.

	* ldlang.c (open_input_bfds): Remove useless cast.
	(lang_do_assignments_1): Likewise.
	(lang_for_each_input_section): Delete.
@
text
@a149 1
  bfd_boolean dt_needed;
a255 1
  dt_needed = FALSE;
d291 3
a293 13
	 tag unless the lib is actually used.
	 For libs brought in by another lib's DT_NEEDED we do the same,
	 and also modify handling of weak syms.  */
      switch elf_dyn_lib_class (abfd)
	{
	case DYN_NORMAL:
	  break;
	case DYN_DT_NEEDED:
	  dt_needed = TRUE;
	  /* Fall thru */
	case DYN_AS_NEEDED:
	  add_needed = FALSE;
	}
d766 1
a766 2
				      &type_change_ok, &size_change_ok,
				      dt_needed))
d1023 1
a1023 1
					      override, dt_needed))
@


1.255
log
@	* elflink.c (_bfd_elf_merge_symbol): Rewrite weak symbol handling.
	(_bfd_elf_add_default_symbol): Remove indirect BFD_ASSERTs.
	* elflink.h (elf_link_add_object_symbols): Don't clear dt_needed in
	symbol loop.  Instead use add_needed to flag tag as written.
@
text
@d71 53
d258 1
a258 1
  add_needed = FALSE;
d280 1
a280 3
      const char *name;
      bfd_size_type oldsize;
      bfd_size_type strindex;
d282 1
d291 6
a296 10
      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  If the generic linker put a null string into
	 elf_dt_name, we don't make a DT_NEEDED entry at all, even if
	 there is a DT_SONAME entry.  */
      add_needed = TRUE;
      name = bfd_get_filename (abfd);
      if (elf_dt_name (abfd) != NULL)
d298 8
a305 5
	  name = elf_dt_name (abfd);
	  if (*name == '\0')
	    {
	      if (elf_dt_soname (abfd) != NULL)
		dt_needed = TRUE;
a306 3
	      add_needed = FALSE;
	    }
	}
d338 2
a339 2
		  name = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (name == NULL)
d456 6
a461 1
      if (add_needed)
d463 4
a466 5
	  /* Add a DT_NEEDED entry for this dynamic object.  */
	  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, FALSE);
	  if (strindex == (bfd_size_type) -1)
	    goto error_return;
d468 3
a470 4
	  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
	    {
	      asection *sdyn;
	      Elf_External_Dyn *dyncon, *dynconend;
d472 3
a474 28
	      /* The hash table size did not change, which means that
		 the dynamic object name was already entered.  If we
		 have already included this dynamic object in the
		 link, just ignore it.  There is no reason to include
		 a particular dynamic object more than once.  */
	      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
	      BFD_ASSERT (sdyn != NULL);

	      dyncon = (Elf_External_Dyn *) sdyn->contents;
	      dynconend = (Elf_External_Dyn *) (sdyn->contents +
						sdyn->_raw_size);
	      for (; dyncon < dynconend; dyncon++)
		{
		  Elf_Internal_Dyn dyn;

		  elf_swap_dyn_in (hash_table->dynobj, dyncon, & dyn);
		  if (dyn.d_tag == DT_NEEDED
		      && dyn.d_un.d_val == strindex)
		    {
		      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
		      return TRUE;
		    }
		}
	    }

	  if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	    goto error_return;
	}
d476 5
a480 5
      /* Save the SONAME, if there is one, because sometimes the
	 linker emulation code will need to know it.  */
      if (*name == '\0')
	name = basename (bfd_get_filename (abfd));
      elf_dt_name (abfd) = name;
d1080 1
a1080 1
	  if (dt_needed && !add_needed && definition
d1084 1
a1084 6
	      bfd_size_type oldsize;
	      bfd_size_type strindex;

	      /* The symbol from a DT_NEEDED object is referenced from
		 the regular object to create a dynamic executable. We
		 have to make sure there is a DT_NEEDED entry for it.  */
d1086 3
d1090 2
a1091 4
	      oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
	      strindex = _bfd_elf_strtab_add (hash_table->dynstr,
					      elf_dt_soname (abfd), FALSE);
	      if (strindex == (bfd_size_type) -1)
d1094 1
a1094 25
	      if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
		{
		  asection *sdyn;
		  Elf_External_Dyn *dyncon, *dynconend;

		  sdyn = bfd_get_section_by_name (hash_table->dynobj,
						  ".dynamic");
		  BFD_ASSERT (sdyn != NULL);

		  dyncon = (Elf_External_Dyn *) sdyn->contents;
		  dynconend = (Elf_External_Dyn *) (sdyn->contents +
						    sdyn->_raw_size);
		  for (; dyncon < dynconend; dyncon++)
		    {
		      Elf_Internal_Dyn dyn;

		      elf_swap_dyn_in (hash_table->dynobj,
				       dyncon, &dyn);
		      BFD_ASSERT (dyn.d_tag != DT_NEEDED ||
				  dyn.d_un.d_val != strindex);
		    }
		}

	      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
		goto error_free_vers;
d3951 2
a3952 1
      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
@


1.254
log
@2004-02-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_link_add_archive_symbols): New prototype.

	* elflink.h (is_global_data_symbol_definition): Moved to
	elflink.c.
	(elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_archive_symbols): Likewise. Renamed to
	_bfd_elf_link_add_archive_symbols.

	* elflink.c (elf_link_is_defined_archive_symbol): Get the size
	of ELF symbol table entry from backend.
	(_bfd_elf_link_add_archive_symbols): Call bfd_link_add_symbols
	instead of elf_link_add_object_symbols.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d98 1
d205 1
a226 1
      bfd_boolean add_needed;
d782 1
a782 1
	    
d1054 1
a1054 1
	  if (dt_needed && definition
d1065 1
a1065 1
	      dt_needed = FALSE;
d1361 1
a1361 1
      
d1376 1
a1376 1
		
@


1.254.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a70 53
/* Add a DT_NEEDED entry for this dynamic object.  Returns -1 on error,
   1 if a DT_NEEDED tag already exists, and 0 on success.  */

static int
add_dt_needed_tag (struct bfd_link_info *info, const char *soname,
		   bfd_boolean do_it)
{
  struct elf_link_hash_table *hash_table;
  bfd_size_type oldsize;
  bfd_size_type strindex;

  hash_table = elf_hash_table (info);
  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);
  if (strindex == (bfd_size_type) -1)
    return -1;

  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
    {
      asection *sdyn;
      Elf_External_Dyn *dyncon, *dynconend;

      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf_External_Dyn *) sdyn->contents;
      dynconend = (Elf_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  elf_swap_dyn_in (hash_table->dynobj, dyncon, & dyn);
	  if (dyn.d_tag == DT_NEEDED
	      && dyn.d_un.d_val == strindex)
	    {
	      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
	      return 1;
	    }
	}
    }

  if (do_it)
    {
      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	return -1;
    }
  else
    /* We were just checking for existence of the tag.  */
    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);

  return 0;
}

d97 1
a97 1
  bfd_boolean add_needed;
d203 1
a203 1
  add_needed = TRUE;
d225 4
a228 1
      const char *soname = NULL;
a229 1
      int ret;
d238 16
a253 5
      /* If this dynamic lib was specified on the command line with
	 --as-needed in effect, then we don't want to add a DT_NEEDED
	 tag unless the lib is actually used.  Similary for libs brought
	 in by another lib's DT_NEEDED.  */
      add_needed = elf_dyn_lib_class (abfd) == DYN_NORMAL;
d255 3
d289 2
a290 2
		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (soname == NULL)
d407 1
a407 6
      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  */
      if (soname == NULL || *soname == '\0')
d409 5
a413 4
	  soname = elf_dt_name (abfd);
	  if (soname == NULL || *soname == '\0')
	    soname = bfd_get_filename (abfd);
	}
d415 4
a418 3
      /* Save the SONAME because sometimes the linker emulation code
	 will need to know it.  */
      elf_dt_name (abfd) = soname;
d420 28
a447 3
      ret = add_dt_needed_tag (info, soname, add_needed);
      if (ret < 0)
	goto error_return;
d449 5
a453 5
      /* If we have already included this dynamic object in the
	 link, just ignore it.  There is no reason to include a
	 particular dynamic object more than once.  */
      if (ret > 0)
	return TRUE;
d751 2
a752 1
				      &type_change_ok, &size_change_ok))
d781 1
a781 1

d1009 1
a1009 1
					      override))
d1053 1
a1053 1
	  if (!add_needed && definition
d1057 2
a1058 1
	      int ret;
d1060 9
a1068 6
	      /* A symbol from a library loaded via DT_NEEDED of some
		 other library is referenced by a regular object.
		 Add a DT_NEEDED entry for it.  */
	      add_needed = TRUE;
	      ret = add_dt_needed_tag (info, elf_dt_name (abfd), add_needed);
	      if (ret < 0)
d1071 25
a1095 1
	      BFD_ASSERT (ret == 0);
d1360 1
a1360 1

d1375 1
a1375 1

d3952 1
a3952 2
      if ((abfd->flags & DYNAMIC) == 0
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
@


1.253
log
@2004-02-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.h (sort_symbol): New.
	(elf_link_add_object_symbols): Use a sorted symbol array for
	weakdef.
@
text
@a25 2
static bfd_boolean elf_link_add_archive_symbols (bfd *,
						 struct bfd_link_info *);
d42 1
a42 1
      return elf_link_add_archive_symbols (abfd, info);
a48 344
/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
{
  /* Local symbols do not count, but target specific ones might.  */
  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
    return FALSE;

  /* Function symbols do not count.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
    return FALSE;

  /* If the section is undefined, then so is the symbol.  */
  if (sym->st_shndx == SHN_UNDEF)
    return FALSE;

  /* If the symbol is defined in the common section, then
     it is a common definition and so does not count.  */
  if (sym->st_shndx == SHN_COMMON)
    return FALSE;

  /* If the symbol is in a target specific section then we
     must rely upon the backend to tell us what it is.  */
  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
    /* FIXME - this function is not coded yet:

       return _bfd_is_global_symbol_definition (abfd, sym);

       Instead for now assume that the definition is not global,
       Even if this is wrong, at least the linker will behave
       in the same way that it used to do.  */
    return FALSE;

  return TRUE;
}

/* Search the symbol table of the archive element of the archive ABFD
   whose archive map contains a mention of SYMDEF, and determine if
   the symbol is defined in this element.  */
static bfd_boolean
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
{
  Elf_Internal_Shdr * hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  bfd_boolean result;

  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
  if (abfd == NULL)
    return FALSE;

  if (! bfd_check_format (abfd, bfd_object))
    return FALSE;

  /* If we have already included the element containing this symbol in the
     link then we do not need to include it again.  Just claim that any symbol
     it contains is not a definition, so that our caller will not decide to
     (re)include this element.  */
  if (abfd->archive_pass)
    return FALSE;

  /* Select the appropriate symbol table.  */
  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / sizeof (Elf_External_Sym);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  if (extsymcount == 0)
    return FALSE;

  /* Read in the symbol table.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				  NULL, NULL, NULL);
  if (isymbuf == NULL)
    return FALSE;

  /* Scan the symbol table looking for SYMDEF.  */
  result = FALSE;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
    {
      const char *name;

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	break;

      if (strcmp (name, symdef->name) == 0)
	{
	  result = is_global_data_symbol_definition (abfd, isym);
	  break;
	}
    }

  free (isymbuf);

  return result;
}

/* Add symbols from an ELF archive file to the linker hash table.  We
   don't use _bfd_generic_link_add_archive_symbols because of a
   problem which arises on UnixWare.  The UnixWare libc.so is an
   archive which includes an entry libc.so.1 which defines a bunch of
   symbols.  The libc.so archive also includes a number of other
   object files, which also define symbols, some of which are the same
   as those defined in libc.so.1.  Correct linking requires that we
   consider each object file in turn, and include it if it defines any
   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
   this; it looks through the list of undefined symbols, and includes
   any object file which defines them.  When this algorithm is used on
   UnixWare, it winds up pulling in libc.so.1 early and defining a
   bunch of symbols.  This means that some of the other objects in the
   archive are not included in the link, which is incorrect since they
   precede libc.so.1 in the archive.

   Fortunately, ELF archive handling is simpler than that done by
   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
   oddities.  In ELF, if we find a symbol in the archive map, and the
   symbol is currently undefined, we know that we must pull in that
   object file.

   Unfortunately, we do have to make multiple passes over the symbol
   table until nothing further is resolved.  */

static bfd_boolean
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  symindex c;
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
  carsym *symdefs;
  bfd_boolean loop;
  bfd_size_type amt;

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  /* Keep track of all symbols we know to be already defined, and all
     files we know to be already included.  This is to speed up the
     second and subsequent passes.  */
  c = bfd_ardata (abfd)->symdef_count;
  if (c == 0)
    return TRUE;
  amt = c;
  amt *= sizeof (bfd_boolean);
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
    goto error_return;

  symdefs = bfd_ardata (abfd)->symdefs;

  do
    {
      file_ptr last;
      symindex i;
      carsym *symdef;
      carsym *symdefend;

      loop = FALSE;
      last = -1;

      symdef = symdefs;
      symdefend = symdef + c;
      for (i = 0; symdef < symdefend; symdef++, i++)
	{
	  struct elf_link_hash_entry *h;
	  bfd *element;
	  struct bfd_link_hash_entry *undefs_tail;
	  symindex mark;

	  if (defined[i] || included[i])
	    continue;
	  if (symdef->file_offset == last)
	    {
	      included[i] = TRUE;
	      continue;
	    }

	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
				    FALSE, FALSE, FALSE);

	  if (h == NULL)
	    {
	      char *p, *copy;
	      size_t len, first;

	      /* If this is a default version (the name contains @@@@),
		 look up the symbol again with only one `@@' as well
		 as without the version.  The effect is that references
		 to the symbol with and without the version will be
		 matched by the default symbol in the archive.  */

	      p = strchr (symdef->name, ELF_VER_CHR);
	      if (p == NULL || p[1] != ELF_VER_CHR)
		continue;

	      /* First check with only one `@@'.  */
	      len = strlen (symdef->name);
	      copy = bfd_alloc (abfd, len);
	      if (copy == NULL)
		goto error_return;
	      first = p - symdef->name + 1;
	      memcpy (copy, symdef->name, first);
	      memcpy (copy + first, symdef->name + first + 1, len - first);

	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
					FALSE, FALSE, FALSE);

	      if (h == NULL)
		{
		  /* We also need to check references to the symbol
		     without the version.  */

		  copy[first - 1] = '\0';
		  h = elf_link_hash_lookup (elf_hash_table (info),
					    copy, FALSE, FALSE, FALSE);
		}

	      bfd_release (abfd, copy);
	    }

	  if (h == NULL)
	    continue;

	  if (h->root.type == bfd_link_hash_common)
	    {
	      /* We currently have a common symbol.  The archive map contains
		 a reference to this symbol, so we may want to include it.  We
		 only want to include it however, if this archive element
		 contains a definition of the symbol, not just another common
		 declaration of it.

		 Unfortunately some archivers (including GNU ar) will put
		 declarations of common symbols into their archive maps, as
		 well as real definitions, so we cannot just go by the archive
		 map alone.  Instead we must read in the element's symbol
		 table and check that to see what kind of symbol definition
		 this is.  */
	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
		continue;
	    }
	  else if (h->root.type != bfd_link_hash_undefined)
	    {
	      if (h->root.type != bfd_link_hash_undefweak)
		defined[i] = TRUE;
	      continue;
	    }

	  /* We need to include this archive member.  */
	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
	  if (element == NULL)
	    goto error_return;

	  if (! bfd_check_format (element, bfd_object))
	    goto error_return;

	  /* Doublecheck that we have not included this object
	     already--it should be impossible, but there may be
	     something wrong with the archive.  */
	  if (element->archive_pass != 0)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
	  element->archive_pass = 1;

	  undefs_tail = info->hash->undefs_tail;

	  if (! (*info->callbacks->add_archive_element) (info, element,
							 symdef->name))
	    goto error_return;
	  if (! elf_link_add_object_symbols (element, info))
	    goto error_return;

	  /* If there are any new undefined symbols, we need to make
	     another pass through the archive in order to see whether
	     they can be defined.  FIXME: This isn't perfect, because
	     common symbols wind up on undefs_tail and because an
	     undefined symbol which is defined later on in this pass
	     does not require another pass.  This isn't a bug, but it
	     does make the code less efficient than it could be.  */
	  if (undefs_tail != info->hash->undefs_tail)
	    loop = TRUE;

	  /* Look backward to mark all symbols from this object file
	     which we have already seen in this pass.  */
	  mark = i;
	  do
	    {
	      included[mark] = TRUE;
	      if (mark == 0)
		break;
	      --mark;
	    }
	  while (symdefs[mark].file_offset == symdef->file_offset);

	  /* We mark subsequent symbols from this object file as we go
	     on through the loop.  */
	  last = symdef->file_offset;
	}
    }
  while (loop);

  free (defined);
  free (included);

  return TRUE;

 error_return:
  if (defined != NULL)
    free (defined);
  if (included != NULL)
    free (included);
  return FALSE;
}

@


1.252
log
@	* elflink.h (size_dynamic_sections): If not adding DT_FLAGS and
	DF_BIND_NOW is set in info->flags, create DT_BIND_NOW dynamic entry.
@
text
@d395 22
d1518 1
a1518 1
  while (weaks != NULL)
a1519 3
      struct elf_link_hash_entry *hlook;
      asection *slook;
      bfd_vma vlook;
d1522 3
d1526 8
a1533 11
      hlook = weaks;
      weaks = hlook->weakdef;
      hlook->weakdef = NULL;

      BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
		  || hlook->root.type == bfd_link_hash_defweak
		  || hlook->root.type == bfd_link_hash_common
		  || hlook->root.type == bfd_link_hash_indirect);
      slook = hlook->root.u.def.section;
      vlook = hlook->root.u.def.value;

d1536 1
a1538 2
	  struct elf_link_hash_entry *h;

d1540 1
a1540 1
	  if (h != NULL && h != hlook
d1542 1
a1542 2
	      && h->root.u.def.section == slook
	      && h->root.u.def.value == vlook)
d1544 5
a1548 1
	      hlook->weakdef = h;
d1550 37
a1586 5
	      /* If the weak definition is in the list of dynamic
		 symbols, make sure the real definition is put there
		 as well.  */
	      if (hlook->dynindx != -1
		  && h->dynindx == -1)
d1588 10
a1597 2
		  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
		    goto error_return;
d1599 1
d1601 13
a1613 7
	      /* If the real definition is in the list of dynamic
		 symbols, make sure the weak definition is put there
		 as well.  If we don't do this, then the dynamic
		 loader might not merge the entries for the real
		 definition and the weak definition.  */
	      if (h->dynindx != -1
		  && hlook->dynindx == -1)
d1615 24
a1638 2
		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
		    goto error_return;
a1639 1
	      break;
d1642 2
@


1.251
log
@	* elflink.h (elf_gc_sections): Warn when gc-sections option is ignored.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): New function.
	(elf32_h8_gc_sweep_hook): New function.
	(elf_backend_gc_mark_hook): Define.
	(elf_backend_gc_sweep_hook): Define.
	(elf_backend_can_gc_sections): Define.
@
text
@d2437 5
@


1.251.6.1
log
@Merge to 2.15 branch.
@
text
@a2436 5
      else if (info->flags & DF_BIND_NOW)
	{
	  if (! elf_add_dynamic_entry (info, DT_BIND_NOW, 0))
	    return FALSE;
	}
@


1.251.6.2
log
@Really remove elflink.h.  Delete consequent bogus changelog entry.
@
text
@@


1.251.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d23 2758
a2780 1
static bfd_boolean elf_section_ignore_discarded_relocs (asection *);
d2782 3
d4202 1
a4202 2
      if ((abfd->flags & DYNAMIC) == 0
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
d6064 45
@


1.251.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@@


1.250
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d5804 4
a5807 1
    return TRUE;
@


1.249
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d2836 2
a2837 1
  (struct elf_final_link_info *, const char *, Elf_Internal_Sym *, asection *);
d3411 2
a3412 1
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr))
d3428 1
a3428 1
			     &elfsym, bfd_abs_section_ptr))
d3453 1
a3453 1
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o))
d3707 2
a3708 1
	(void *, const char *, Elf_Internal_Sym *, asection *);
d4092 2
a4093 1
		     asection *input_sec)
d4098 2
a4099 2
    (bfd *, struct bfd_link_info *info, const char *,
     Elf_Internal_Sym *, asection *);
d4105 1
a4105 2
      if (! ((*output_symbol_hook)
	     (finfo->output_bfd, finfo->info, name, elfsym, input_sec)))
d4646 1
a4646 1
  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec))
d4851 1
a4851 1
      if (! elf_link_output_sym (finfo, name, &osym, isec))
d5213 2
a5214 1
			  if (! elf_link_output_sym (finfo, name, &sym, sec))
@


1.248
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d440 3
a442 1
      if (info->relocatable || info->hash->creator != abfd->xvec)
d480 1
a480 1
	      if (dynamic && abfd->xvec == info->hash->creator)
d536 3
a538 3
	  && is_elf_hash_table (info)
	  && ! hash_table->dynamic_sections_created
	  && abfd->xvec == info->hash->creator)
d544 1
a544 1
  else if (! is_elf_hash_table (info))
d728 2
a729 3
      if (! hash_table->dynamic_sections_created)
	if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	  goto error_return;
d972 1
a972 1
      if (info->hash->creator->flavour == bfd_target_elf_flavour)
d1135 1
a1135 1
	  && info->hash->creator->flavour == bfd_target_elf_flavour
d1171 1
a1171 1
      if (info->hash->creator->flavour == bfd_target_elf_flavour)
a1383 3
	      if (! is_elf_hash_table (info))
		goto error_free_vers;

d1447 1
a1447 1
	       bfd_link_hash_lookup (info->hash, shortname,
d1574 2
a1575 1
      && abfd->xvec == info->hash->creator
d1611 1
a1611 2
      && info->hash->creator->flavour == bfd_target_elf_flavour
      && is_elf_hash_table (info)
d1644 3
a1646 2
  if (! info->relocatable && ! dynamic
      && is_elf_hash_table (info))
d1666 1
a1666 1
  if (is_elf_hash_table (info))
d1704 1
a1704 1
  if (! is_elf_hash_table (info))
d1909 1
a1909 4
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
    return TRUE;

  if (! is_elf_hash_table (info))
d3111 1
a3111 1
  if (! is_elf_hash_table (info))
d4187 1
a4187 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
d5796 3
a5798 1
      || info->relocatable || info->emitrelocations
d5974 3
d6183 1
a6183 2
      || info->hash->creator->flavour != bfd_target_elf_flavour
      || ! is_elf_hash_table (info))
@


1.247
log
@Fix decision about when a .interp section should exist
@
text
@d878 1
a878 1
	     point to the first global symbol.  Unfortunatealy, Irix 5
d1177 1
a1177 1
	     can change when a common symbol is overriden by a normal
d1835 1
a1835 1
	     of all the chain lengths (which favous many small chain
d2059 1
a2059 1
      /* Make all global versions with definiton.  */
d2124 1
a2124 1
	  /* Check if all global versions have a definiton.  */
d5677 1
a5677 1
/* Propogate collected vtable information.  This is called through
d5843 1
a5843 1
/* Called from check_relocs to record the existance of a VTINHERIT reloc.  */
d5899 1
a5899 1
/* Called from check_relocs to record the existance of a VTENTRY reloc.  */
@


1.246
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d1984 1
a1984 1
      BFD_ASSERT (*sinterpptr != NULL || info->shared);
@


1.245
log
@bfd/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Look up
	hash table for real symbols.

include/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_version_expr): Add "symbol" and remove
	"wildcard".

ld/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_vers_match): Check "symbol" instead of
	"wildcard" and "pattern". Fix a typo.
	(lang_finalize_version_expr_head): Likewise.
	(lang_register_vers_node): Likewise.
	(realsymbol): New function.
	(lang_new_vers_pattern): Set "symbol" and remove "wildcard".

	* ldlex.l (V_IDENTIFIER): Allow '\\'.
@
text
@a2806 2
  /* first SHF_TLS section (if any).  */
  asection *first_tls_sec;
a3160 8
  finfo.first_tls_sec = NULL;
  for (o = abfd->sections; o != NULL; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
	&& (o->flags & SEC_LOAD) != 0)
      {
	finfo.first_tls_sec = o;
	break;
      }
d3518 1
a3518 1
  if (finfo.first_tls_sec)
d3520 1
a3520 2
      unsigned int align = 0;
      bfd_vma base = finfo.first_tls_sec->vma, end = 0;
d3523 1
a3523 1
      for (sec = finfo.first_tls_sec;
d3529 1
a3529 3
	  if (bfd_get_section_alignment (abfd, sec) > align)
	    align = bfd_get_section_alignment (abfd, sec);
	  if (sec->_raw_size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
a3532 1
	      size = 0;
d3539 3
a3541 7
      elf_hash_table (info)->tls_segment
	= bfd_zalloc (abfd, sizeof (struct elf_link_tls_segment));
      if (elf_hash_table (info)->tls_segment == NULL)
	goto error_return;
      elf_hash_table (info)->tls_segment->start = base;
      elf_hash_table (info)->tls_segment->size = end - base;
      elf_hash_table (info)->tls_segment->align = align;
d4488 2
a4489 2
		    BFD_ASSERT (finfo->first_tls_sec != NULL);
		    sym.st_value -= finfo->first_tls_sec->vma;
d4847 2
a4848 2
	      BFD_ASSERT (finfo->first_tls_sec != NULL);
	      osym.st_value -= finfo->first_tls_sec->vma;
d5204 4
a5207 2
				  BFD_ASSERT (finfo->first_tls_sec != NULL);
				  sym.st_value -= finfo->first_tls_sec->vma;
@


1.244
log
@bfd/
	* elflink.c (_bfd_elf_export_symbol): Adjust for globals and locals
	field changes.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elflink.h (size_dynamic_sections): Likewise.
include/
	* bfdlink.h (struct bfd_elf_version_expr): Remove match field.
	Add wildcard and mask fields.
	(BFD_ELF_VERSION_C_TYPE): Define.
	(BFD_ELF_VERSION_CXX_TYPE): Likewise.
	(BFD_ELF_VERSION_JAVA_TYPE): Likewise.
	(struct bfd_elf_version_expr_head): New.
	(struct bfd_elf_version_tree): Add match field.
	Change type of globals and locals fields
	to struct bfd_elf_version_expr_head.
ld/
	* ldlang.c: Include hashtab.h.
	(lang_vers_match_lang_c, lang_vers_match_lang_cplusplus,
	lang_vers_match_lang_java): Remove.
	(lang_vers_match): New function.
	(lang_new_vers_pattern): Initialize wildcard and mask
	fields, don't initialize match.
	(lang_new_vers_node): Use xcalloc.  Adjust for globals and
	locals field type changes.  Set match field.
	(version_expr_head_hash, version_expr_head_eq): New functions.
	(lang_finalize_version_expr_head): New function.
	(lang_register_vers_node): Call lang_finalize_version_expr_head.
	Search in hash table if not wildcard when looking for duplicates.
	* emultempl/ppc64elf.em (new_vers_pattern): Don't bother with
	duplicate checking.  Initialize all fields of dot_entry from entry
	with the exception of pattern and next.
@
text
@d2062 1
a2062 3
	  /* FIXME: Shouldn't this be !d->symver && d->wildcard == 0
	     instead?  */
	  if (!d->symver && strchr (d->pattern, '*') == NULL)
d2069 1
a2069 1
	      name = d->pattern;
@


1.243
log
@2003-10-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also warn
	undefined patterns with '*'.
@
text
@d2061 3
a2063 1
	for (d = t->globals; d != NULL; d = d->next)
d2129 1
a2129 1
	    for (d = t->globals; d != NULL; d = d->next)
d2377 1
a2377 1
	      if (t->globals == NULL && t->locals == NULL && ! t->used)
@


1.242
log
@	* elf-bfd.h (struct elf_backend_data): New function pointer member
	elf_backend_merge_symbol_attribute.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_merge_symbol_attribute if the backend defined it.
        * elfxx-target.h (elf_backend_merge_symbol_attribute): New macro.
        (elfNN_bed): Add that to the initializer.
@
text
@d2128 1
a2128 2
	      if (!d->symver && !d->script
		  && strchr (d->pattern, '*') == NULL)
@


1.241
log
@bfd/Changelog:
	* libbfd-in.h (_bfd_link_section_stabs): Add string offset
	parameter.
	* cofflink.c (coff_link_add_symbols): Deal with split stab
	sections.
	* elflink.h (elf_link_add_object_symbols): Deal with split stab
	sections.
	* stabs.c (_bfd_link_section_stabs): Add string offset parameter.
	* libbfd.h: Regenerated.
ld/ChangeLog:
	* ldwrite.c (unsplittable_name): New.
	(clone_section): Strip existing numeric suffix. Only truncate names
	for coff targets.
	(split_sections): Use unsplittable_name.
binutils/ChangeLog:
	* objdump.c (read_section_stabs): Just read one section, return
	pointer to it. Add size parameter.
	(print_section_stabs): Add string offset parameter. Adjust.
	(struct stab_section_names): Add string offset member.
	(find_stabs_sections): Correct check for split section suffix,
	adjust read_section_stabs and print_section_stabs calls.
	(dump_stabs_section): Clear string_offset, free string table.
@
text
@d1264 4
@


1.240
log
@	* elflink.h (elf_link_add_object_symbols): Don't crash on NULL owner.
@
text
@d23 2
d1612 26
a1637 21
      asection *stab, *stabstr;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->flags & SEC_MERGE) == 0
	  && !bfd_is_abs_section (stab->output_section))
	{
	  stabstr = bfd_get_section_by_name (abfd, ".stabstr");

	  if (stabstr != NULL)
	    {
	      struct bfd_elf_section_data *secdata;

	      secdata = elf_section_data (stab);
	      if (! _bfd_link_section_stabs (abfd,
					     & hash_table->stab_info,
					     stab, stabstr,
					     &secdata->sec_info))
		goto error_return;
	      if (secdata->sec_info)
		stab->sec_info_type = ELF_INFO_TYPE_STABS;
@


1.239
log
@Better handking for unresolved symbols
@
text
@d1189 2
a1190 1
	      if ((h->root.u.def.section->owner->flags & DYNAMIC) == 0)
@


1.238
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d4366 5
a4370 11
  /* If we are not creating a shared library, and this symbol is
     referenced by a shared library but is not defined anywhere, then
     warn that it is undefined.  If we do not do this, the runtime
     linker will complain that the symbol is undefined when the
     program is run.  We don't have to worry about symbols that are
     referenced by regular files, because we will already have issued
     warnings for them.  */
  if (! finfo->info->relocatable
      && (finfo->info->executable
	  || ! finfo->info->allow_shlib_undefined)
      && h->root.type == bfd_link_hash_undefined
d4373 2
a4374 1
      && ! elf_link_check_versioned_symbol (finfo->info, h))
d4378 1
a4378 1
	      NULL, 0, TRUE)))
d4388 1
a4388 1
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
d4390 1
a4390 2
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC
	     | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
@


1.237
log
@Prefix .gnu.warning section messages with "warning: ".
@
text
@d418 1
a418 1
  struct elf_backend_data *bed;
d1891 1
a1891 1
  struct elf_backend_data *bed;
d2862 1
a2862 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2967 1
a2967 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3099 1
a3099 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4544 1
a4544 1
      struct elf_backend_data *bed;
d4690 1
a4690 1
  struct elf_backend_data *bed;
d5324 1
a5324 1
  struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
d5512 1
a5512 1
      struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
d5730 2
a5731 3
	  asection *sec = h->root.u.def.section;
	  struct elf_backend_data *bed = get_elf_backend_data (sec->owner);
	  unsigned int log_file_align = bed->s->log_file_align;
d5733 2
d5755 1
a5755 1
  struct elf_backend_data *bed;
d5918 1
a5918 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5984 1
a5984 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6187 1
a6187 1
  struct elf_backend_data *bed;
d6320 1
a6320 1
  struct elf_backend_data *bed;
@


1.236
log
@	* elfcode.h: Convert to C90, remove unneeded casts and prototypes.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf.c (sym_is_global): Remove INLINE.
	(align_file_position): Replace INLINE with inline.
	* elfcode.h (elf_swap_dyn_in, elf_swap_dyn_out): Remove INLINE.
	(elf_file_p): Replace INLINE with inline.
@
text
@d462 2
d497 2
a498 1
	      msg = bfd_alloc (abfd, sz + 1);
d502 2
a503 1
	      if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
d506 1
a506 1
	      msg[sz] = '\0';
@


1.235
log
@	* elf64-ppc.c (bfd_elf64_mkobject): Define.
	(struct ppc64_elf_obj_tdata): New.
	(ppc64_elf_tdata, ppc64_tlsld_got): Define.
	(ppc64_elf_mkobject): New function.
	(struct got_entry): Add "owner".  Move "tls_type".
	(struct ppc_link_hash_table): Delete "relgot", "tlsld_got".
	(ppc64_elf_init_stub_bfd): New function.
	(create_got_section): Create header .got in dynobj.  Create .got
	and .rela.got in each bfd.  Stash pointers in ppc64_elf_obj_tdata.
	(ppc64_elf_create_dynamic_sections): Don't call create_got_section.
	Look for dynobj .got, and test it.
	(ppc64_elf_copy_indirect_symbol): Adjust for changed got.
	(update_local_sym_info): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	(ppc64_elf_gc_sweep_hook): Likewise.
	(ppc64_elf_tls_optimize): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	(ppc64_elf_next_toc_section): Update comment.
	(toc_adjusting_stub_needed): Remove unneeded cast.
	(ppc64_elf_build_stubs): Check for stub sections in stub bfd by
	testing section flags.
	(ppc64_elf_build_stubs): Likewise.
	(ppc64_elf_size_stubs): Likewise.  Remove stub_bfd param.
	(ppc64_elf_finish_dynamic_sections): Write out got sections.
	(func_desc_adjust): Copy over dynamic info for undef weaks.
	* elf64-ppc.h (ppc64_elf_init_stub_bfd): Declare.
	(ppc64_elf_size_stubs): Update prototype.
	* elflink.h (elf_link_sort_relocs): Use link_orders to find reldyn
	input sections rather than scanning dynobj.
@
text
@d23 7
a29 25
static bfd_boolean is_global_data_symbol_definition
  PARAMS ((bfd *, Elf_Internal_Sym *));
static bfd_boolean elf_link_is_defined_archive_symbol
  PARAMS ((bfd *, carsym *));
static bfd_boolean elf_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_link_add_archive_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_finalize_dynstr
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_collect_hash_codes
  PARAMS ((struct elf_link_hash_entry *, PTR));
static size_t compute_bucket_count
  PARAMS ((struct bfd_link_info *));
static void elf_link_adjust_relocs
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned int,
	   struct elf_link_hash_entry **));
static int elf_link_sort_cmp1
  PARAMS ((const void *, const void *));
static int elf_link_sort_cmp2
  PARAMS ((const void *, const void *));
static size_t elf_link_sort_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection **));
static bfd_boolean elf_section_ignore_discarded_relocs
  PARAMS ((asection *));
d35 1
a35 3
elf_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d51 2
a52 3
is_global_data_symbol_definition (abfd, sym)
     bfd * abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Sym * sym;
d91 1
a91 3
elf_link_is_defined_archive_symbol (abfd, symdef)
     bfd * abfd;
     carsym * symdef;
d103 1
a103 1
  if (abfd == (bfd *) NULL)
d154 1
a154 1
      if (name == (const char *) NULL)
d195 1
a195 3
elf_link_add_archive_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d207 1
a207 1
      if (bfd_openr_next_archived_file (abfd, (bfd *) NULL) == NULL)
d221 3
a223 3
  defined = (bfd_boolean *) bfd_zmalloc (amt);
  included = (bfd_boolean *) bfd_zmalloc (amt);
  if (defined == (bfd_boolean *) NULL || included == (bfd_boolean *) NULL)
d275 1
a275 1
	      copy = bfd_alloc (abfd, (bfd_size_type) len);
d327 1
a327 1
	  if (element == (bfd *) NULL)
d386 1
a386 1
  if (defined != (bfd_boolean *) NULL)
d388 1
a388 1
  if (included != (bfd_boolean *) NULL)
d396 1
a396 3
elf_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d399 2
a400 2
    PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	     const char **, flagword *, asection **, bfd_vma *));
d402 1
a402 2
    PARAMS ((bfd *, struct bfd_link_info *, asection *,
	     const Elf_Internal_Rela *));
d495 1
a495 1
	      msg = (char *) bfd_alloc (abfd, sz + 1);
d499 1
a499 1
	      if (! bfd_get_section_contents (abfd, s, msg, (file_ptr) 0, sz))
d505 2
a506 2
		     (info, abfd, name, BSF_WARNING, s, (bfd_vma) 0, msg,
		      FALSE, collect, (struct bfd_link_hash_entry **) NULL)))
d583 1
a583 1
	  dynbuf = (Elf_External_Dyn *) bfd_malloc (s->_raw_size);
d587 1
a587 2
	  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf,
					  (file_ptr) 0, s->_raw_size))
d616 1
a616 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d624 1
a624 1
		  memcpy (anm, fnm, (size_t) amt);
d641 1
a641 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d649 1
a649 1
		  memcpy (anm, fnm, (size_t) amt);
d667 1
a667 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d679 1
a679 1
		  memcpy (anm, fnm, (size_t) amt);
d762 1
a762 1
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
d810 1
a810 1
      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
d829 1
a829 1
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
d834 1
a834 1
	      || bfd_bread ((PTR) extversym, amt, abfd) != amt)
d915 1
a915 1
      if (name == (const char *) NULL)
d943 1
a943 1
	  if (name == (const char *) NULL)
d948 1
a948 1
      if (sec == (asection *) NULL)
d1048 1
a1048 1
		  newname = (char *) bfd_alloc (abfd, (bfd_size_type) newlen);
d1113 2
a1114 2
	     (info, abfd, name, flags, sec, value, (const char *) NULL,
	      FALSE, collect, (struct bfd_link_hash_entry **) sym_hash)))
d1409 1
a1409 1
	      if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
d1582 2
a1583 4
	  internal_relocs
	    = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
					 info->keep_memory);
d1656 1
a1656 2
      n = ((struct elf_link_loaded_list *)
	   bfd_alloc (abfd, sizeof (struct elf_link_loaded_list)));
d1681 1
a1681 4
elf_add_dynamic_entry (info, tag, val)
     struct bfd_link_info *info;
     bfd_vma tag;
     bfd_vma val;
d1698 1
a1698 1
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
d1734 1
a1734 2
compute_bucket_count (info)
     struct bfd_link_info *info;
d1748 1
a1748 1
  hashcodes = (unsigned long int *) bfd_malloc (amt);
d1781 1
a1781 1
      counts = (unsigned long int *) bfd_malloc (amt);
d1876 8
a1883 12
NAME(bfd_elf,size_dynamic_sections) (output_bfd, soname, rpath,
				     filter_shlib,
				     auxiliary_filters, info, sinterpptr,
				     verdefs)
     bfd *output_bfd;
     const char *soname;
     const char *rpath;
     const char *filter_shlib;
     const char * const *auxiliary_filters;
     struct bfd_link_info *info;
     asection **sinterpptr;
     struct bfd_elf_version_tree *verdefs;
d1975 1
a1975 2
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SONAME,
					  soname_indx))
d1981 1
a1981 2
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMBOLIC,
				       (bfd_vma) 0))
d1995 1
a1995 1
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_RPATH, indx)
d1997 1
a1997 2
		  && ! elf_add_dynamic_entry (info, (bfd_vma) DT_RUNPATH,
					      indx)))
d2008 1
a2008 1
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_FILTER, indx))
d2023 1
a2023 2
		  || ! elf_add_dynamic_entry (info, (bfd_vma) DT_AUXILIARY,
					      indx))
d2038 1
a2038 1
				  (PTR) &eif);
d2059 1
a2059 1
	      newname = (char *) bfd_malloc ((bfd_size_type) newlen);
d2102 1
a2102 1
			      (PTR) &asvinfo);
d2132 1
a2132 1
			      (PTR) &eif);
d2151 1
a2151 1
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_INIT, (bfd_vma) 0))
d2163 1
a2163 1
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FINI, (bfd_vma) 0))
d2191 2
a2192 4
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAYSZ,
					 (bfd_vma) 0))
d2197 2
a2198 4
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAYSZ,
					 (bfd_vma) 0))
d2203 2
a2204 4
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAYSZ,
					 (bfd_vma) 0))
d2218 6
a2223 6
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_HASH, (bfd_vma) 0)
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRTAB, (bfd_vma) 0)
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMTAB, (bfd_vma) 0)
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRSZ, strsize)
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMENT,
					  (bfd_vma) sizeof (Elf_External_Sym)))
d2286 1
a2286 1
	  s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
d2346 1
a2346 1
		      (bfd_vma) 0, (const char *) NULL, FALSE,
d2414 2
a2415 3
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEF, (bfd_vma) 0)
	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEFNUM,
					  (bfd_vma) cdefs))
d2423 1
a2423 1
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS, info->flags))
d2433 1
a2433 2
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS_1,
				       info->flags_1))
d2453 1
a2453 1
				(PTR) &sinfo);
d2480 1
a2480 1
	    s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
d2537 2
a2538 4
	    if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEED,
					 (bfd_vma) 0)
		|| ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEEDNUM,
					    (bfd_vma) crefs))
d2566 1
a2566 1
	  s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d2570 1
a2570 1
	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERSYM, (bfd_vma) 0))
d2583 1
a2583 1
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
d2598 1
a2598 1
	  elf_swap_symbol_out (output_bfd, &isym, (PTR) s->contents, (PTR) 0);
d2609 1
a2609 1
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d2613 2
a2614 3
      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) bucketcount,
	       s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) dynsymcount,
d2627 1
a2627 1
	if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NULL, (bfd_vma) 0))
a2636 3
static bfd_boolean elf_adjust_dynstr_offsets
  PARAMS ((struct elf_link_hash_entry *, PTR));

d2638 1
a2638 3
elf_adjust_dynstr_offsets (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d2640 1
a2640 1
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
d2654 1
a2654 3
elf_finalize_dynstr (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d2797 1
a2797 1
  PTR external_relocs;
d2827 1
a2827 2
  PARAMS ((struct elf_final_link_info *, const char *,
	   Elf_Internal_Sym *, asection *));
d2829 1
a2829 1
  PARAMS ((struct elf_final_link_info *));
d2831 1
a2831 3
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_link_check_versioned_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d2833 1
a2833 1
  PARAMS ((struct elf_final_link_info *, bfd *));
d2835 1
a2835 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   struct bfd_link_order *));
d2852 4
a2855 5
elf_link_adjust_relocs (abfd, rel_hdr, count, rel_hash)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     unsigned int count;
     struct elf_link_hash_entry **rel_hash;
d2860 2
a2861 2
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d2907 1
a2907 3
elf_link_sort_cmp1 (A, B)
     const PTR A;
     const PTR B;
d2909 2
a2910 2
  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
d2932 1
a2932 3
elf_link_sort_cmp2 (A, B)
     const PTR A;
     const PTR B;
d2934 2
a2935 2
  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
d2956 1
a2956 4
elf_link_sort_relocs (abfd, info, psec)
     bfd *abfd;
     struct bfd_link_info *info;
     asection **psec;
d2965 2
a2966 2
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d3004 1
a3004 2
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0,
	 (bfd_vma) 0);
d3027 1
a3027 1
  qsort (sort, (size_t) count, sort_elt, elf_link_sort_cmp1);
d3047 1
a3047 1
  qsort (s_non_relative, (size_t) count - ret, sort_elt, elf_link_sort_cmp2);
d3075 1
a3075 3
elf_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3149 1
a3149 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d3166 1
a3166 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d3202 2
a3203 4
		  relocs
		    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
						 (Elf_Internal_Rela *) NULL,
						 info->keep_memory);
d3321 1
a3321 1
			    _bfd_elf_link_sec_merge_syms, (PTR) abfd);
d3385 1
a3385 1
  finfo.symbuf = (Elf_External_Sym *) bfd_malloc (amt);
d3394 1
a3394 1
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
d3409 1
a3409 2
      if (! elf_link_output_sym (&finfo, (const char *) NULL,
				 &elfsym, bfd_und_section_ptr))
d3450 1
a3450 2
	  if (! elf_link_output_sym (&finfo, (const char *) NULL,
				     &elfsym, o))
d3461 1
a3461 1
      finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d3468 1
a3468 1
      finfo.external_relocs = (PTR) bfd_malloc (max_external_reloc_size);
d3477 1
a3477 1
      finfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
d3485 1
a3485 1
      finfo.external_syms = (Elf_External_Sym *) bfd_malloc (amt);
d3490 1
a3490 1
      finfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
d3495 1
a3495 1
      finfo.indices = (long *) bfd_malloc (amt);
d3500 1
a3500 1
      finfo.sections = (asection **) bfd_malloc (amt);
d3508 1
a3508 1
      finfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
d3609 1
a3609 1
			  (PTR) &eoinfo);
d3649 1
a3649 1
	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
d3690 1
a3690 1
	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
d3703 1
a3703 1
			  (PTR) &eoinfo);
d3712 1
a3712 1
	PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *));
d3715 1
a3715 1
	     (abfd, info, (PTR) &finfo, (out_sym_func) elf_link_output_sym)))
d3739 1
a3739 1
	  || (bfd_bwrite ((PTR) finfo.symshndxbuf, amt, abfd) != amt))
d4093 4
a4096 5
elf_link_output_sym (finfo, name, elfsym, input_sec)
     struct elf_final_link_info *finfo;
     const char *name;
     Elf_Internal_Sym *elfsym;
     asection *input_sec;
d4101 2
a4102 2
    PARAMS ((bfd *, struct bfd_link_info *info, const char *,
	     Elf_Internal_Sym *, asection *));
d4113 1
a4113 1
  if (name == (const char *) NULL || *name == '\0')
d4149 1
a4149 1
  elf_swap_symbol_out (finfo->output_bfd, elfsym, (PTR) dest, (PTR) destshndx);
d4159 1
a4159 2
elf_link_flush_output_syms (finfo)
     struct elf_final_link_info *finfo;
d4171 1
a4171 1
	  || bfd_bwrite ((PTR) finfo->symbuf, amt, finfo->output_bfd) != amt)
d4188 2
a4189 3
elf_link_check_versioned_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d4269 1
a4269 1
      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
d4274 1
a4274 1
	  || (bfd_bread ((PTR) extversym, versymhdr->sh_size, input)
d4335 1
a4335 3
elf_link_output_extsym (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d4337 1
a4337 1
  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
d4379 1
a4379 1
	      (asection *) NULL, (bfd_vma) 0, TRUE)))
d4606 1
a4606 1
      elf_swap_symbol_out (finfo->output_bfd, &sym, (PTR) esym, (PTR) 0);
d4615 1
a4615 2
      bfd_put (8 * hash_entry_size, finfo->output_bfd, (bfd_vma) h->dynindx,
	       bucketpos);
d4671 1
a4671 3
elf_link_input_bfd (finfo, input_bfd)
     struct elf_final_link_info *finfo;
     bfd *input_bfd;
d4674 2
a4675 2
    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d4763 1
a4763 1
					  isym->st_value, (bfd_vma) 0);
d4897 2
a4898 2
	  if (! bfd_get_section_contents (input_bfd, o, contents,
					  (file_ptr) 0, o->_raw_size))
d5053 1
a5053 2
		PARAMS ((bfd *, asection *, Elf_Internal_Shdr *,
			 Elf_Internal_Rela *));
d5309 4
a5312 5
elf_reloc_link_order (output_bfd, info, output_section, link_order)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection *output_section;
     struct bfd_link_order *link_order;
d5379 1
a5379 2
		 (info, link_order->u.reloc.p->u.name, (bfd *) NULL,
		  (asection *) NULL, (bfd_vma) 0)))
d5396 2
a5397 2
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == (bfd_byte *) NULL)
d5399 1
a5399 1
      rstat = _bfd_relocate_contents (howto, output_bfd, (bfd_vma) addend, buf);
d5416 1
a5416 2
		 (info, sym_name, howto->name, addend,
		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
d5423 2
a5424 2
      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
				     (file_ptr) link_order->offset, size);
a5467 11
static bfd_boolean elf_gc_mark
  PARAMS ((struct bfd_link_info *, asection *,
	   asection * (*) (asection *, struct bfd_link_info *,
			   Elf_Internal_Rela *, struct elf_link_hash_entry *,
			   Elf_Internal_Sym *)));

static bfd_boolean elf_gc_sweep
  PARAMS ((struct bfd_link_info *,
	   bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *,
			    const Elf_Internal_Rela *)));

d5469 1
a5469 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d5472 1
a5472 7
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean elf_gc_propagate_vtable_entries_used
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean elf_gc_smash_unused_vtentry_relocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
d5479 2
a5480 2
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d5483 3
a5485 4
elf_gc_mark (info, sec, gc_mark_hook)
     struct bfd_link_info *info;
     asection *sec;
     gc_mark_hook_fn gc_mark_hook;
d5533 1
a5533 2
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL,
					    (Elf_Internal_Rela *) NULL,
d5594 1
a5594 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d5597 1
a5597 3
elf_gc_sweep (info, gc_sweep_hook)
     struct bfd_link_info *info;
     gc_sweep_hook_fn gc_sweep_hook;
d5635 1
a5635 2
		= _bfd_elf_link_read_relocs (o->owner, o, NULL,
					     (Elf_Internal_Rela *) NULL,
d5657 1
a5657 3
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_gc_sweep_symbol,
			    (PTR) &i);
d5668 1
a5668 3
elf_gc_sweep_symbol (h, idxptr)
     struct elf_link_hash_entry *h;
     PTR idxptr;
d5670 1
a5670 1
  int *idx = (int *) idxptr;
d5688 1
a5688 3
elf_gc_propagate_vtable_entries_used (h, okp)
     struct elf_link_hash_entry *h;
     PTR okp;
d5745 1
a5745 3
elf_gc_smash_unused_vtentry_relocs (h, okp)
     struct elf_link_hash_entry *h;
     PTR okp;
d5768 1
a5768 2
  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL,
					(Elf_Internal_Rela *) NULL, TRUE);
d5797 1
a5797 3
elf_gc_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d5802 2
a5803 2
    PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));
d5813 1
a5813 1
			  (PTR) &ok);
d5820 1
a5820 1
			  (PTR) &ok);
d5852 4
a5855 5
elf_gc_record_vtinherit (abfd, sec, h, offset)
     bfd *abfd;
     asection *sec;
     struct elf_link_hash_entry *h;
     bfd_vma offset;
d5908 4
a5911 5
elf_gc_record_vtentry (abfd, sec, h, addend)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
     bfd_vma addend;
d5944 1
a5944 1
	  ptr = bfd_realloc (ptr - 1, (bfd_size_type) bytes);
d5956 1
a5956 1
	ptr = bfd_zmalloc ((bfd_size_type) bytes);
d5975 2
a5976 3
elf_gc_common_finalize_got_offsets (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d6025 1
a6025 1
			  (PTR) &gotoff);
d6033 1
a6033 3
elf_gc_allocate_got_offsets (h, offarg)
     struct elf_link_hash_entry *h;
     PTR offarg;
d6035 1
a6035 1
  bfd_vma *off = (bfd_vma *) offarg;
d6055 1
a6055 3
elf_gc_common_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d6068 1
a6068 3
elf_collect_hash_codes (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d6070 1
a6070 1
  unsigned long **valuep = (unsigned long **) data;
d6087 2
a6088 2
      alc = bfd_malloc ((bfd_size_type) (p - name + 1));
      memcpy (alc, name, (size_t) (p - name));
d6110 1
a6110 3
elf_reloc_symbol_deleted_p (offset, cookie)
     bfd_vma offset;
     PTR cookie;
d6112 1
a6112 1
  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;
d6177 1
a6177 3
elf_bfd_discard_info (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d6251 2
a6252 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, stab, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
d6273 2
a6274 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, eh, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
d6313 1
a6313 2
elf_section_ignore_discarded_relocs (sec)
     asection *sec;
@


1.234
log
@	* elf-bfd.h (_bfd_elf_create_linker_section) Don't declare.
	(_bfd_elf_find_pointer_linker_section): Likewise.
	(bfd_elf32_create_pointer_linker_section): Likewise.
	(bfd_elf32_finish_pointer_linker_section): Likewise.
	(bfd_elf64_create_pointer_linker_section): Likewise.
	(bfd_elf64_finish_pointer_linker_section): Likewise.
	(_bfd_elf_make_linker_section_rela): Likewise.
	* elfcode.h (elf_create_pointer_linker_section): Don't define.
	(elf_finish_pointer_linker_section): Likewise.
	* elflink.c (_bfd_elf_make_linker_section_rela): Delete.
	(_bfd_elf_create_linker_section): Move this function..
	(_bfd_elf_find_pointer_linker_section): ..and this..
	* elflink.h (elf_create_pointer_linker_section): ..and this..
	(elf_finish_pointer_linker_section): ..and this..
	* elf32-ppc.c: ..to here, renaming to the following, and adjusting
	calls.
	(elf_create_linker_section): Convert to C90, tidy.
	(elf_find_pointer_linker_section): Likewise.
	(elf_create_pointer_linker_section): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	* elf32-i370.c: Delete #if 0 code.
@
text
@d3032 1
a3032 2
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *reldyn, *o;
d3041 1
d3062 6
a3067 5
  for (o = dynobj->sections; o != NULL; o = o->next)
    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
	&& o->output_section == reldyn)
      size += o->_raw_size;
d3083 2
a3084 4
  for (o = dynobj->sections; o != NULL; o = o->next)
    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
	&& o->output_section == reldyn)
d3087 1
d3124 2
a3125 4
  for (o = dynobj->sections; o != NULL; o = o->next)
    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
	&& o->output_section == reldyn)
d3128 1
@


1.233
log
@Correct spelling of "relocatable".
@
text
@a5559 258
/* Allocate a pointer to live in a linker created section.  */

bfd_boolean
elf_create_pointer_linker_section (abfd, info, lsect, h, rel)
     bfd *abfd;
     struct bfd_link_info *info;
     elf_linker_section_t *lsect;
     struct elf_link_hash_entry *h;
     const Elf_Internal_Rela *rel;
{
  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
  elf_linker_section_pointers_t *linker_section_ptr;
  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
  bfd_size_type amt;

  BFD_ASSERT (lsect != NULL);

  /* Is this a global symbol?  */
  if (h != NULL)
    {
      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (_bfd_elf_find_pointer_linker_section (h->linker_section_pointer,
						rel->r_addend,
						lsect->which))
	return TRUE;

      ptr_linker_section_ptr = &h->linker_section_pointer;
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (lsect->rel_section)
	lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
    }
  else
    {
      /* Allocation of a pointer to a local symbol.  */
      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);

      /* Allocate a table to hold the local symbols if first time.  */
      if (!ptr)
	{
	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;
	  register unsigned int i;

	  amt = num_symbols;
	  amt *= sizeof (elf_linker_section_pointers_t *);
	  ptr = (elf_linker_section_pointers_t **) bfd_alloc (abfd, amt);

	  if (!ptr)
	    return FALSE;

	  elf_local_ptr_offsets (abfd) = ptr;
	  for (i = 0; i < num_symbols; i++)
	    ptr[i] = (elf_linker_section_pointers_t *) 0;
	}

      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (_bfd_elf_find_pointer_linker_section (ptr[r_symndx],
						rel->r_addend,
						lsect->which))
	return TRUE;

      ptr_linker_section_ptr = &ptr[r_symndx];

      if (info->shared)
	{
	  /* If we are generating a shared object, we need to
	     output a R_<xxx>_RELATIVE reloc so that the
	     dynamic linker can adjust this GOT entry.  */
	  BFD_ASSERT (lsect->rel_section != NULL);
	  lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
	}
    }

  /* Allocate space for a pointer in the linker section, and allocate
     a new pointer record from internal memory.  */
  BFD_ASSERT (ptr_linker_section_ptr != NULL);
  amt = sizeof (elf_linker_section_pointers_t);
  linker_section_ptr = (elf_linker_section_pointers_t *) bfd_alloc (abfd, amt);

  if (!linker_section_ptr)
    return FALSE;

  linker_section_ptr->next = *ptr_linker_section_ptr;
  linker_section_ptr->addend = rel->r_addend;
  linker_section_ptr->which = lsect->which;
  linker_section_ptr->written_address_p = FALSE;
  *ptr_linker_section_ptr = linker_section_ptr;

#if 0
  if (lsect->hole_size && lsect->hole_offset < lsect->max_hole_offset)
    {
      linker_section_ptr->offset = (lsect->section->_raw_size
				    - lsect->hole_size + (ARCH_SIZE / 8));
      lsect->hole_offset += ARCH_SIZE / 8;
      lsect->sym_offset  += ARCH_SIZE / 8;
      if (lsect->sym_hash)
	{
	  /* Bump up symbol value if needed.  */
	  lsect->sym_hash->root.u.def.value += ARCH_SIZE / 8;
#ifdef DEBUG
	  fprintf (stderr, "Bump up %s by %ld, current value = %ld\n",
		   lsect->sym_hash->root.root.string,
		   (long) ARCH_SIZE / 8,
		   (long) lsect->sym_hash->root.u.def.value);
#endif
	}
    }
  else
#endif
    linker_section_ptr->offset = lsect->section->_raw_size;

  lsect->section->_raw_size += ARCH_SIZE / 8;

#ifdef DEBUG
  fprintf (stderr,
	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long) linker_section_ptr->offset,
	   (long) lsect->section->_raw_size);
#endif

  return TRUE;
}

#if ARCH_SIZE==64
#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_64 (BFD, VAL, ADDR)
#endif
#if ARCH_SIZE==32
#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_32 (BFD, VAL, ADDR)
#endif

/* Fill in the address for a pointer generated in a linker section.  */

bfd_vma
elf_finish_pointer_linker_section (output_bfd, input_bfd, info, lsect, h,
				   relocation, rel, relative_reloc)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
     elf_linker_section_t *lsect;
     struct elf_link_hash_entry *h;
     bfd_vma relocation;
     const Elf_Internal_Rela *rel;
     int relative_reloc;
{
  elf_linker_section_pointers_t *linker_section_ptr;

  BFD_ASSERT (lsect != NULL);

  if (h != NULL)
    {
      /* Handle global symbol.  */
      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
			    (h->linker_section_pointer,
			     rel->r_addend,
			     lsect->which));

      BFD_ASSERT (linker_section_ptr != NULL);

      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && info->symbolic
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	{
	  /* This is actually a static link, or it is a
	     -Bsymbolic link and the symbol is defined
	     locally.  We must initialize this entry in the
	     global section.

	     When doing a dynamic link, we create a .rela.<xxx>
	     relocation entry to initialize the value.  This
	     is done in the finish_dynamic_symbol routine.  */
	  if (!linker_section_ptr->written_address_p)
	    {
	      linker_section_ptr->written_address_p = TRUE;
	      bfd_put_ptr (output_bfd,
			   relocation + linker_section_ptr->addend,
			   (lsect->section->contents
			    + linker_section_ptr->offset));
	    }
	}
    }
  else
    {
      /* Handle local symbol.  */
      unsigned long r_symndx = ELF_R_SYM (rel->r_info);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
			     rel->r_addend,
			     lsect->which));

      BFD_ASSERT (linker_section_ptr != NULL);

      /* Write out pointer if it hasn't been rewritten out before.  */
      if (!linker_section_ptr->written_address_p)
	{
	  linker_section_ptr->written_address_p = TRUE;
	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
		       lsect->section->contents + linker_section_ptr->offset);

	  if (info->shared)
	    {
	      asection *srel = lsect->rel_section;
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
	      unsigned int i;

	      /* We need to generate a relative reloc for the dynamic
		 linker.  */
	      if (!srel)
		{
		  srel = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
						  lsect->rel_name);
		  lsect->rel_section = srel;
		}

	      BFD_ASSERT (srel != NULL);

	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
	      outrel[0].r_info = ELF_R_INFO (0, relative_reloc);
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf_External_Rela));
	      elf_swap_reloca_out (output_bfd, outrel, erel);
	    }
	}
    }

  relocation = (lsect->section->output_offset
		+ linker_section_ptr->offset
		- lsect->hole_offset
		- lsect->sym_offset);

#ifdef DEBUG
  fprintf (stderr,
	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long) relocation, (long) relocation);
#endif

  /* Subtract out the addend, because it will get added back in by the normal
     processing.  */
  return relocation - linker_section_ptr->addend;
}

@


1.232
log
@2003-06-23  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.h (elf_link_input_bfd): Check raw size when using
	kept_section to preserve debug information discarded by
	linkonce.
@
text
@d466 1
a466 1
      if (info->relocateable || info->hash->creator != abfd->xvec)
d537 1
a537 1
	      if (! info->relocateable)
d1661 1
a1661 1
  if (! info->relocateable && ! dynamic
d1971 1
a1971 1
	  if (exec && info->relocateable
d2912 1
a2912 1
/* When performing a relocateable link, the input relocations are
d3189 1
a3189 1
  emit_relocs = (info->relocateable
d3274 1
a3274 1
	      if (info->relocateable || info->emitrelocations)
d3399 1
a3399 1
  if (! info->relocateable && merged)
d3527 1
a3527 1
	  if (info->relocateable || o == NULL)
d3638 1
a3638 1
     we are generating relocateable output, and we see a reloc against
d3644 1
a3644 1
     it.  Fortunately, it only happens when performing a relocateable
d4084 1
a4084 1
  if (info->relocateable)
d4456 1
a4456 1
  if (! finfo->info->relocateable
d4475 1
a4475 1
  if (! finfo->info->relocateable
d4573 2
a4574 2
	    /* ELF symbols in relocateable files are section relative,
	       but in nonrelocateable files they are virtual
d4577 1
a4577 1
	    if (! finfo->info->relocateable)
d4660 1
a4660 1
  if (! finfo->info->relocateable
d4790 1
a4790 1
  emit_relocs = (finfo->info->relocateable
d4885 1
a4885 1
	 output this one.  If we are generating a relocateable output
d4900 1
a4900 1
	      || (! finfo->info->relocateable
d4915 1
a4915 1
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocateable)
d4932 1
a4932 1
      /* ELF symbols in relocateable files are section relative, but
d4940 1
a4940 1
      if (! finfo->info->relocateable)
d5111 1
a5111 1
	     and generating a relocateable output file) adjusting the
d5121 1
a5121 1
	     When generating relocateable output, the back end routine
d5160 1
a5160 1
	      if (!finfo->info->relocateable)
d5193 1
a5193 1
		  if (!finfo->info->relocateable)
d5297 1
a5297 1
			  if (! finfo->info->relocateable)
d5325 1
a5325 1
		  && !(finfo->info->relocateable
d5525 1
a5525 1
     relocateable file, and is a virtual address in an executable
d5528 1
a5528 1
  if (! info->relocateable)
d6192 1
a6192 1
      || info->relocateable || info->emitrelocations
d6602 1
a6602 1
      if (info->relocateable
d6708 1
a6708 1
      && !info->relocateable
@


1.231
log
@	* elflink.h (elf_gc_record_vtentry): Revert last change.  Correct
	size calculation from addend.  Round size up.
@
text
@d5045 1
a5045 1
				  && sec->_cooked_size == sec->kept_section->_cooked_size)
d5074 1
a5074 1
				  && sec->_cooked_size == sec->kept_section->_cooked_size)
@


1.230
log
@bfd/

2003-06-17  H.J. Lu <hongjiu.lu@@intel.com>

	* section.c (struct sec): Put back kept_section.
	(STD_SECTION): Put back kept_section initialization.
	* bfd-in2.h: Regenerate.

	* elflink.h (elf_link_input_bfd): Also check discarded linkonce
	sections for relocateable output. Use kept_section to preserve
	debug information discarded by linkonce.

ld/

2003-06-17  H.J. Lu <hongjiu.lu@@intel.com>

	* ldlang.c (section_already_linked): Put back assignment of
	kept_section.
@
text
@d6304 1
a6304 1
  if (addend > h->vtable_entries_size)
d6306 1
a6306 1
      size_t size, bytes;
d6311 1
d6313 1
a6313 1
	size = addend;
d6317 1
a6317 1
	  if (size < addend)
d6321 1
a6321 1
	      size = addend;
d6324 1
d6327 2
a6328 3
	 consolidation pass and another extra entry because we are
	 going to write up to and including 'size' entries.  */
      bytes = ((size >> log_file_align) + 2) * sizeof (bfd_boolean);
@


1.229
log
@(elf_gc_record_vtentry): Allocate an extra element in the vtable_entries_used
array to allow for the accessing the largest element.
@
text
@d5008 3
a5010 3
	     link-once sections.  */
	  if (!finfo->info->relocateable
	      && !elf_section_ignore_discarded_relocs (o))
d5019 1
d5034 1
d5037 1
a5037 1
			  && elf_discarded_section (h->root.u.def.section))
d5042 8
a5049 1
			      memset (rel, 0, sizeof (*rel));
d5063 1
a5063 1
		      asection *sec = finfo->sections[r_symndx];
d5071 12
a5082 3
			      rel->r_info
				= ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
			      rel->r_addend = 0;
@


1.228
log
@binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_STACK.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_STACK.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Create PT_GNU_STACK segment header.
	(get_program_header_size): Count with PT_GNU_STACK.
	* elf-bfd.h (struct elf_obj_tdata): Add stack_flags.
	* elflink.h (bfd_elfNN_size_dynamic_sections): Set stack_flags.
include/
	* bfdlink.h (struct bfd_link_info): Add execstack and noexecstack.
	* elf/common.h (PT_GNU_STACK): Define.
ld/
	* ldgram.y (phdr_type): Grok PT_GNU_STACK.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z execstack and -z noexecstack.
	(gld${EMULATION_NAME}_list_options): Likewise.
	* scripttempl/elf.sc: If not -r, discard .note.GNU-stack section.
@
text
@d6286 1
a6286 1
  if (addend >= h->vtable_entries_size)
d6307 3
a6309 2
	 consolidation pass.  */
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);
@


1.227
log
@bfd/

2003-06-03  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.h (elf_link_input_bfd): Call linker error_handler
	for discarded definitions.

include/

2003-06-03  H.J. Lu <hongjiu.lu@@intel.com>

	* bfdlink.h (LD_DEFINITION_IN_DISCARDED_SECTION): New.

ld/

2003-06-03  H.J. Lu <hongjiu.lu@@intel.com>

	* ldmisc.c: Include "bfdlink.h".
	(error_handler): Handle LD_DEFINITION_IN_DISCARDED_SECTION
	and -LD_DEFINITION_IN_DISCARDED_SECTION.

	* Makefile.am: Rebuild dependency.
	* Makefile.in: Regenerated.

ld/testsuite/

2003-06-03  H.J. Lu <hongjiu.lu@@intel.com>

	* ld-discard/extern.d: Updated.
	* ld-discard/start.d: Likewise.
	* ld-discard/static.d: Likewise.
@
text
@d1940 37
@


1.226
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d5006 7
a5012 7
			    {
			      if (! ((*finfo->info->callbacks->undefined_symbol)
				     (finfo->info, h->root.root.string,
				      input_bfd, o, rel->r_offset,
				      TRUE)))
				return FALSE;
			    }
d5031 3
a5033 6
			      bfd_boolean ok;
			      const char *msg
				= _("local symbols in discarded section %s");
			      bfd_size_type amt
				= strlen (sec->name) + strlen (msg) - 1;
			      char *buf = (char *) bfd_malloc (amt);
d5035 10
a5044 10
			      if (buf != NULL)
				sprintf (buf, msg, sec->name);
			      else
				buf = (char *) sec->name;
			      ok = (*finfo->info->callbacks
				    ->undefined_symbol) (finfo->info, buf,
							 input_bfd, o,
							 rel->r_offset,
							 TRUE);
			      if (buf != sec->name)
a5045 2
			      if (!ok)
				return FALSE;
@


1.225
log
@bfd/

2003-05-20  Jakub Jelinek  <jakub@@redhat.com>

	* elflink.h (elf_link_output_extsym): Only issue error about !=
	STV_DEFAULT symbols if they are bfd_link_hash_undefined.

2003-05-20  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Check ELF_LINK_DYNAMIC_DEF
	when removing the old definition for symbols with non-default
	visibility.

ld/testsuite/

2003-05-20  Jakub Jelinek  <jakub@@redhat.com>

	* ld-elfvsb/common.c: New file.
	* ld-elfvsb/elfvsb.exp: Add common.

2003-05-20  H.J. Lu <hongjiu.lu@@intel.com>

	* ld-elfvsb/sh3.c: New file.
	* ld-elfvsb/test.c: Likewise.

	* ld-elfvsb/elfvsb.exp: Add new weak hidden symbol tests.
@
text
@d477 1
a477 1
  if (! info->shared)
d1324 1
a1324 1
	      if (info->shared
d2177 1
a2177 1
	  if (info->shared)
d2443 1
a2443 1
	  if (! info->shared)
d4420 2
a4421 1
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
@


1.224
log
@	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't test
	dynamic_sections_created here.  Update comment.  Move undefweak
	non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elflink.h (elf_link_output_extsym): Compare ELF_ST_VISIBILITY with
	STV_DEFAULT rather than comparing with zero.
	* elflink.c (_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.  Format comment.
@
text
@d4625 1
a4625 1
      && h->root.type != bfd_link_hash_undefweak
@


1.223
log
@2003-05-14  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.h (elf_link_check_versioned_symbol): Also allow
	the base version.
@
text
@d4623 1
a4623 1
      && ELF_ST_VISIBILITY (sym.st_other)
@


1.222
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d4337 1
d4358 2
a4359 1
	  if ((iver.vs_vers & VERSYM_VERSION) == 2)
d4361 1
a4361 1
	      /* This is the oldest (default) sym.  We can use it.  */
@


1.221
log
@2003-05-08  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.h (elf_add_default_symbol): After skipping the
	unversioned symbol, go to non-default one.
@
text
@a22 10
/* This struct is used to pass information to routines called via
   elf_link_hash_traverse which must return failure.  */

struct elf_info_failed
{
  bfd_boolean failed;
  struct bfd_link_info *info;
  struct bfd_elf_version_tree *verdefs;
};

a30 11
static bfd_boolean elf_merge_symbol
  PARAMS ((bfd *, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection **, bfd_vma *,
	   struct elf_link_hash_entry **, bfd_boolean *, bfd_boolean *,
	   bfd_boolean *, bfd_boolean *, bfd_boolean));
static bfd_boolean elf_add_default_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   const char *, Elf_Internal_Sym *, asection **, bfd_vma *,
	   bfd_boolean *, bfd_boolean, bfd_boolean));
static bfd_boolean elf_export_symbol
  PARAMS ((struct elf_link_hash_entry *, PTR));
a32 8
static bfd_boolean elf_fix_symbol_flags
  PARAMS ((struct elf_link_hash_entry *, struct elf_info_failed *));
static bfd_boolean elf_adjust_dynamic_symbol
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_link_find_version_dependencies
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_link_assign_sym_version
  PARAMS ((struct elf_link_hash_entry *, PTR));
a34 2
static bfd_boolean elf_link_read_relocs_from_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));
a36 4
static bfd_boolean elf_link_output_relocs
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *));
static bfd_boolean elf_link_size_reloc_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
a417 831
/* This function is called when we want to define a new symbol.  It
   handles the various cases which arise when we find a definition in
   a dynamic object, or when there is already a definition in a
   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
   OVERRIDE if the old symbol is overriding a new definition.  We set
   TYPE_CHANGE_OK if it is OK for the type to change.  We set
   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
   change, we mean that we shouldn't warn if the type or size does
   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
   a shared object.  */

static bfd_boolean
elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
		  override, type_change_ok, size_change_ok, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *pvalue;
     struct elf_link_hash_entry **sym_hash;
     bfd_boolean *skip;
     bfd_boolean *override;
     bfd_boolean *type_change_ok;
     bfd_boolean *size_change_ok;
     bfd_boolean dt_needed;
{
  asection *sec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;

  *skip = FALSE;
  *override = FALSE;

  sec = *psec;
  bind = ELF_ST_BIND (sym->st_info);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
  else
    h = ((struct elf_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
  if (h == NULL)
    return FALSE;
  *sym_hash = h;

  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (info->hash->creator != abfd->xvec)
    return TRUE;

  /* For merging, we only care about real symbols.  */

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If we just created the symbol, mark it as being an ELF symbol.
     Other than that, there is nothing to do--there is no merge issue
     with a newly defined symbol--so we just return.  */

  if (h->root.type == bfd_link_hash_new)
    {
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
      return TRUE;
    }

  /* OLDBFD is a BFD associated with the existing symbol.  */

  switch (h->root.type)
    {
    default:
      oldbfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      break;
    }

  /* In cases involving weak versioned symbols, we may wind up trying
     to merge a symbol with itself.  Catch that here, to avoid the
     confusion that results if we try to override a symbol with
     itself.  The additional tests catch cases like
     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
     dynamic object, which we do want to handle here.  */
  if (abfd == oldbfd
      && ((abfd->flags & DYNAMIC) == 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
    return TRUE;

  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  if ((abfd->flags & DYNAMIC) != 0)
    newdyn = TRUE;
  else
    newdyn = FALSE;

  if (oldbfd != NULL)
    olddyn = (oldbfd->flags & DYNAMIC) != 0;
  else
    {
      asection *hsec;

      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
	 indices used by MIPS ELF.  */
      switch (h->root.type)
	{
	default:
	  hsec = NULL;
	  break;

	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  hsec = h->root.u.def.section;
	  break;

	case bfd_link_hash_common:
	  hsec = h->root.u.c.p->section;
	  break;
	}

      if (hsec == NULL)
	olddyn = FALSE;
      else
	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
    }

  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
     respectively, appear to be a definition rather than reference.  */

  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
    newdef = FALSE;
  else
    newdef = TRUE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_common)
    olddef = FALSE;
  else
    olddef = TRUE;

  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
	    }
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
	}
    }

  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other)
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return _bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	h = *sym_hash;
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }

  /* We need to treat weak definiton right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
	{
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;

  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;

  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;

  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;

  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
     symbol, respectively, appears to be a common symbol in a dynamic
     object.  If a symbol appears in an uninitialized section, and is
     not weak, and is not a function, then it may be a common symbol
     which was resolved when the dynamic object was created.  We want
     to treat such symbols specially, because they raise special
     considerations when setting the symbol size: if the symbol
     appears as a common symbol in a regular object, and the size in
     the regular object is larger, we must make sure that we use the
     larger size.  This problematic case can always be avoided in C,
     but it must be handled correctly when using Fortran shared
     libraries.

     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
     likewise for OLDDYNCOMMON and OLDDEF.

     Note that this test is just a heuristic, and that it is quite
     possible to have an uninitialized symbol in a shared object which
     is really a definition, rather than a common symbol.  This could
     lead to some minor confusion when the symbol really is a common
     symbol in some regular object.  However, I think it will be
     harmless.  */

  if (newdyn
      && newdef
      && (sec->flags & SEC_ALLOC) != 0
      && (sec->flags & SEC_LOAD) == 0
      && sym->st_size > 0
      && !newweakdef
      && !newweakundef
      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    newdyncommon = TRUE;
  else
    newdyncommon = FALSE;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
      && (h->root.u.def.section->flags & SEC_LOAD) == 0
      && h->size > 0
      && h->type != STT_FUNC)
    olddyncommon = TRUE;
  else
    olddyncommon = FALSE;

  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak unless it comes from a DT_NEEDED entry of
     a shared object, in which case, the DT_NEEDED entry may not be
     required at the run time.  */

  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef)
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

  /* If both the old and the new symbols look like common symbols in a
     dynamic object, set the size of the symbol to the larger of the
     two.  */

  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {
      /* Since we think we have two common symbols, issue a multiple
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */

      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      if (sym->st_size > h->size)
	h->size = sym->st_size;

      *size_change_ok = TRUE;
    }

  /* If we are looking at a dynamic object, and we have found a
     definition, we need to see if the symbol was already defined by
     some other object.  If so, we want to use the existing
     definition, and we do not want to report a multiple symbol
     definition error; we do this by clobbering *PSEC to be
     bfd_und_section_ptr.

     We treat a common symbol as a definition if the symbol in the
     shared library is a function, since common symbols always
     represent variables; this can cause confusion in principle, but
     any such confusion would seem to indicate an erroneous program or
     shared library.  We also permit a common symbol in a regular
     object to override a weak symbol in a shared object.

     We prefer a non-weak definition in a shared library to a weak
     definition in the executable unless it comes from a DT_NEEDED
     entry of a shared object, in which case, the DT_NEEDED entry
     may not be required at the run time.  */

  if (newdyn
      && newdef
      && (olddef
	  || (h->root.type == bfd_link_hash_common
	      && (newweakdef
		  || newweakundef
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
      && (!oldweakdef
	  || dt_needed
	  || newweakdef
	  || newweakundef))
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;

      *psec = sec = bfd_und_section_ptr;
      *size_change_ok = TRUE;

      /* If we get here when the old symbol is a common symbol, then
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */

      if (h->root.type == bfd_link_hash_common)
	*type_change_ok = TRUE;
    }

  /* Handle the special case of an old common symbol merging with a
     new symbol which looks like a common symbol in a shared object.
     We change *PSEC and *PVALUE to make the new symbol look like a
     common symbol, and let _bfd_generic_link_add_one_symbol will do
     the right thing.  */

  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
      *pvalue = sym->st_size;
      *psec = sec = bfd_com_section_ptr;
      *size_change_ok = TRUE;
    }

  /* If the old symbol is from a dynamic object, and the new symbol is
     a definition which is not from a dynamic object, then the new
     symbol overrides the old symbol.  Symbols from regular files
     always take precedence over symbols from dynamic objects, even if
     they are defined after the dynamic object in the link.

     As above, we again permit a common symbol in a regular object to
     override a definition in a shared object if the shared object
     symbol is a function or is weak.

     As above, we permit a non-weak definition in a shared object to
     override a weak definition in a regular object.  */

  flip = NULL;
  if (! newdyn
      && (newdef
	  || (bfd_is_com_section (sec)
	      && (oldweakdef || h->type == STT_FUNC)))
      && olddyn
      && olddef
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && ((!newweakdef && !newweakundef) || oldweakdef))
    {
      /* Change the hash table entry to undefined, and let
	 _bfd_generic_link_add_one_symbol do the right thing with the
	 new definition.  */

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = TRUE;

      olddef = FALSE;
      olddyncommon = FALSE;

      /* We again permit a type change when a common symbol may be
	 overriding a function.  */

      if (bfd_is_com_section (sec))
	*type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
    }

  /* Handle the special case of a new common symbol merging with an
     old symbol that looks like it might be a common symbol defined in
     a shared object.  Note that we have already handled the case in
     which a new common symbol should simply override the definition
     in the shared library.  */

  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {
      /* It would be best if we could set the hash table entry to a
	 common symbol, but we don't know what to use for the section
	 or the alignment.  */
      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      /* If the predumed common symbol in the dynamic object is
	 larger, pretend that the new symbol has its size.  */

      if (h->size > *pvalue)
	*pvalue = h->size;

      /* FIXME: We no longer know the alignment required by the symbol
	 in the dynamic object, so we just wind up using the one from
	 the regular object.  */

      olddef = FALSE;
      olddyncommon = FALSE;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = TRUE;
      *type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
    }

  /* Handle the special case of a weak definition in a regular object
     followed by a non-weak definition in a shared object.  In this
     case, we prefer the definition in the shared object unless it
     comes from a DT_NEEDED entry of a shared object, in which case,
     the DT_NEEDED entry may not be required at the run time.  */
  if (olddef
      && ! dt_needed
      && oldweakdef
      && newdef
      && newdyn
      && !newweakdef
      && !newweakundef)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the regular
	 definition.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
				   | ELF_LINK_HASH_DEF_DYNAMIC);

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

  /* Handle the special case of a non-weak definition in a shared
     object followed by a weak definition in a regular object.  In
     this case we prefer the definition in the shared object.  To make
     this work we have to tell the caller to not treat the new symbol
     as a definition.  */
  if (olddef
      && olddyn
      && !oldweakdef
      && newdef
      && ! newdyn
      && (newweakdef || newweakundef))
    *override = TRUE;

  return TRUE;
}

/* This function is called to create an indirect symbol from the
   default for the symbol with the default version if needed. The
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
   indicates if it comes from a DT_NEEDED entry of a shared object.  */

static bfd_boolean
elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
			dynsym, override, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *value;
     bfd_boolean *dynsym;
     bfd_boolean override;
     bfd_boolean dt_needed;
{
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
  bfd_boolean skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
  bfd_boolean collect;
  bfd_boolean dynamic;
  char *p;
  size_t len, shortlen;
  asection *sec;

  /* If this symbol has a version, and it is the default version, we
     create an indirect symbol from the default name to the fully
     decorated name.  This will cause external references which do not
     specify a version to be bound to this version of the symbol.  */
  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return TRUE;

  if (override)
    {
      /* We are overridden by an old defition. We need to check if we
	 need to create the indirect symbol from the default name.  */
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
      BFD_ASSERT (hi != NULL);
      if (hi == h)
	return TRUE;
      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	{
	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
	  if (hi == h)
	    return TRUE;
	}
    }

  bed = get_elf_backend_data (abfd);
  collect = bed->collect;
  dynamic = (abfd->flags & DYNAMIC) != 0;

  shortlen = p - name;
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';

  /* We are going to create a new symbol.  Merge it with any existing
     symbol with this name.  For the purposes of the merge, act as
     though we were defining the symbol we just defined, although we
     actually going to define an indirect symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			  &hi, &skip, &override, &type_change_ok,
			  &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    goto nondefault;

  if (! override)
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
	      (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;
    }
  else
    {
      /* In this case the symbol named SHORTNAME is overriding the
	 indirect symbol we want to add.  We were planning on making
	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
	 is the name without a version.  NAME is the fully versioned
	 name, and it is the default version.

	 Overriding means that we already saw a definition for the
	 symbol SHORTNAME in a regular object, and it is overriding
	 the symbol defined in the dynamic object.

	 When this happens, we actually want to change NAME, the
	 symbol we just added, to refer to SHORTNAME.  This will cause
	 references to NAME in the shared object to become references
	 to SHORTNAME in the regular object.  This is what we expect
	 when we override a function in a shared object: that the
	 references in the shared object will be mapped to the
	 definition in the regular object.  */

      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	  if (hi->elf_link_hash_flags
	      & (ELF_LINK_HASH_REF_REGULAR
		 | ELF_LINK_HASH_DEF_REGULAR))
	    {
	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
		return FALSE;
	    }
	}

      /* Now set HI to H, so that the following code will set the
	 other fields correctly.  */
      hi = h;
    }

  /* If there is a duplicate definition somewhere, then HI may not
     point to an indirect symbol.  We will have reported an error to
     the user in that case.  */

  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;

      /* If the symbol became indirect, then we assume that we have
	 not seen a definition before.  */
      BFD_ASSERT ((hi->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_DYNAMIC
		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);

      /* See if the new flags lead us to realize that the symbol must
	 be dynamic.  */
      if (! *dynsym)
	{
	  if (! dynamic)
	    {
	      if (info->shared
		  || ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		*dynsym = TRUE;
	    }
	  else
	    {
	      if ((hi->elf_link_hash_flags
		   & ELF_LINK_HASH_REF_REGULAR) != 0)
		*dynsym = TRUE;
	    }
	}
    }

  /* We also need to define an indirection from the nondefault version
     of the symbol.  */

nondefault:
  len = strlen (name);
  shortname = bfd_hash_allocate (&info->hash->table, len);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);

  /* Once again, merge with any existing symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			  &hi, &skip, &override, &type_change_ok,
			  &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    return TRUE;

  if (override)
    {
      /* Here SHORTNAME is a versioned name, so we don't expect to see
	 the type of override we do in the case above unless it is
	 overridden by a versioned definiton.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT,
	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;

      /* If there is a duplicate definition somewhere, then HI may not
	 point to an indirect symbol.  We will have reported an error
	 to the user in that case.  */

      if (hi->root.type == bfd_link_hash_indirect)
	{
	  /* If the symbol became indirect, then we assume that we have
	     not seen a definition before.  */
	  BFD_ASSERT ((hi->elf_link_hash_flags
		       & (ELF_LINK_HASH_DEF_DYNAMIC
			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);

	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);

	  /* See if the new flags lead us to realize that the symbol
	     must be dynamic.  */
	  if (! *dynsym)
	    {
	      if (! dynamic)
		{
		  if (info->shared
		      || ((hi->elf_link_hash_flags
			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		    *dynsym = TRUE;
		}
	      else
		{
		  if ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_REGULAR) != 0)
		    *dynsym = TRUE;
		}
	    }
	}
    }

  return TRUE;
}

d560 1
a560 1
	  if (! elf_link_create_dynamic_sections (abfd, info))
d750 1
a750 1
	if (! elf_link_create_dynamic_sections (abfd, info))
d1095 4
a1098 4
	  if (! elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				  sym_hash, &skip, &override,
				  &type_change_ok, &size_change_ok,
				  dt_needed))
d1348 3
a1350 3
	    if (! elf_add_default_symbol (abfd, info, h, name, isym,
					  &sec, &value, &dynsym,
					  override, dt_needed))
d1611 4
a1614 4
	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
			     (abfd, o, (PTR) NULL,
			      (Elf_Internal_Rela *) NULL,
			      info->keep_memory));
d1710 1
a1710 6
/* Create some sections which will be filled in with dynamic linking
   information.  ABFD is an input file which requires dynamic sections
   to be created.  The dynamic sections take up virtual memory space
   when the final executable is run, so we need to create them before
   addresses are assigned to the output sections.  We work out the
   actual contents and size of these sections later.  */
d1713 1
a1713 2
elf_link_create_dynamic_sections (abfd, info)
     bfd *abfd;
d1715 2
d1718 5
a1722 5
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
d1727 1
a1727 2
  if (elf_hash_table (info)->dynamic_sections_created)
    return TRUE;
d1729 2
a1730 5
  /* Make sure that all dynamic sections use the same input BFD.  */
  if (elf_hash_table (info)->dynobj == NULL)
    elf_hash_table (info)->dynobj = abfd;
  else
    abfd = elf_hash_table (info)->dynobj;
d1732 4
a1735 4
  /* Note that we set the SEC_IN_MEMORY flag for all of these
     sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d1737 3
a1739 137
  /* A dynamically linked executable has a .interp section, but a
     shared library does not.  */
  if (! info->shared)
    {
      s = bfd_make_section (abfd, ".interp");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
	return FALSE;
    }

  if (! info->traditional_format
      && info->hash->creator->flavour == bfd_target_elf_flavour)
    {
      s = bfd_make_section (abfd, ".eh_frame_hdr");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
      elf_hash_table (info)->eh_info.hdr_sec = s;
    }

  /* Create sections to hold version informations.  These are removed
     if they are not needed.  */
  s = bfd_make_section (abfd, ".gnu.version_d");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, 1))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version_r");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
    return FALSE;

  s = bfd_make_section (abfd, ".dynsym");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
    return FALSE;

  s = bfd_make_section (abfd, ".dynstr");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
    return FALSE;

  /* Create a strtab to hold the dynamic symbol names.  */
  if (elf_hash_table (info)->dynstr == NULL)
    {
      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
      if (elf_hash_table (info)->dynstr == NULL)
	return FALSE;
    }

  s = bfd_make_section (abfd, ".dynamic");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
    return FALSE;

  /* The special symbol _DYNAMIC is always set to the start of the
     .dynamic section.  This call occurs before we have processed the
     symbols for any dynamic object, so we don't have to worry about
     overriding a dynamic definition.  We could set _DYNAMIC in a
     linker script, but we only want to define it if we are, in fact,
     creating a .dynamic section.  We don't want to define it if there
     is no .dynamic section, since on some ELF platforms the start up
     code examines it to decide how to initialize the process.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  bed = get_elf_backend_data (abfd);

  s = bfd_make_section (abfd, ".hash");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
    return FALSE;
  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;

  /* Let the backend create the rest of the sections.  This lets the
     backend set the right flags.  The backend will normally create
     the .got and .plt sections.  */
  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return FALSE;

  elf_hash_table (info)->dynamic_sections_created = TRUE;

  return TRUE;
}

/* Add an entry to the .dynamic table.  */

bfd_boolean
elf_add_dynamic_entry (info, tag, val)
     struct bfd_link_info *info;
     bfd_vma tag;
     bfd_vma val;
{
  Elf_Internal_Dyn dyn;
  bfd *dynobj;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;

  if (! is_elf_hash_table (info))
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  s = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);

  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
    return FALSE;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  elf_swap_dyn_out (dynobj, &dyn,
a1747 245
/* Read and swap the relocs from the section indicated by SHDR.  This
   may be either a REL or a RELA section.  The relocations are
   translated into RELA relocations and stored in INTERNAL_RELOCS,
   which should have already been allocated to contain enough space.
   The EXTERNAL_RELOCS are a buffer where the external form of the
   relocations should be stored.

   Returns FALSE if something goes wrong.  */

static bfd_boolean
elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
				   internal_relocs)
     bfd *abfd;
     Elf_Internal_Shdr *shdr;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
{
  struct elf_backend_data *bed;
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;

  /* If there aren't any relocations, that's OK.  */
  if (!shdr)
    return TRUE;

  /* Position ourselves at the start of the section.  */
  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
    return FALSE;

  /* Read the relocations.  */
  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  /* Convert the external relocations to the internal format.  */
  if (shdr->sh_entsize == sizeof (Elf_External_Rel))
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == sizeof (Elf_External_Rela))
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erela = external_relocs;
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
  irela = internal_relocs;
  while (erela < erelaend)
    {
      (*swap_in) (abfd, erela, irela);
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }

  return TRUE;
}

/* Read and swap the relocs for a section O.  They may have been
   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
   not NULL, they are used as buffers to read into.  They are known to
   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
   the return value is allocated using either malloc or bfd_alloc,
   according to the KEEP_MEMORY argument.  If O has two relocation
   sections (both REL and RELA relocations), then the REL_HDR
   relocations will appear first in INTERNAL_RELOCS, followed by the
   REL_HDR2 relocations.  */

Elf_Internal_Rela *
NAME(_bfd_elf,link_read_relocs) (abfd, o, external_relocs, internal_relocs,
				 keep_memory)
     bfd *abfd;
     asection *o;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
     bfd_boolean keep_memory;
{
  Elf_Internal_Shdr *rel_hdr;
  PTR alloc1 = NULL;
  Elf_Internal_Rela *alloc2 = NULL;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (elf_section_data (o)->relocs != NULL)
    return elf_section_data (o)->relocs;

  if (o->reloc_count == 0)
    return NULL;

  rel_hdr = &elf_section_data (o)->rel_hdr;

  if (internal_relocs == NULL)
    {
      bfd_size_type size;

      size = o->reloc_count;
      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      if (keep_memory)
	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
      else
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
      if (internal_relocs == NULL)
	goto error_return;
    }

  if (external_relocs == NULL)
    {
      bfd_size_type size = rel_hdr->sh_size;

      if (elf_section_data (o)->rel_hdr2)
	size += elf_section_data (o)->rel_hdr2->sh_size;
      alloc1 = (PTR) bfd_malloc (size);
      if (alloc1 == NULL)
	goto error_return;
      external_relocs = alloc1;
    }

  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
					  external_relocs,
					  internal_relocs))
    goto error_return;
  if (!elf_link_read_relocs_from_section
      (abfd,
       elf_section_data (o)->rel_hdr2,
       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			  * bed->s->int_rels_per_ext_rel)))
    goto error_return;

  /* Cache the results for next time, if we can.  */
  if (keep_memory)
    elf_section_data (o)->relocs = internal_relocs;

  if (alloc1 != NULL)
    free (alloc1);

  /* Don't free alloc2, since if it was allocated we are passing it
     back (under the name of internal_relocs).  */

  return internal_relocs;

 error_return:
  if (alloc1 != NULL)
    free (alloc1);
  if (alloc2 != NULL)
    free (alloc2);
  return NULL;
}

/* Record an assignment to a symbol made by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
NAME(bfd_elf,record_link_assignment) (output_bfd, info, name, provide)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     const char *name;
     bfd_boolean provide;
{
  struct elf_link_hash_entry *h;

  if (info->hash->creator->flavour != bfd_target_elf_flavour)
    return TRUE;

  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
  if (h == NULL)
    return FALSE;

  if (h->root.type == bfd_link_hash_new)
    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;

  /* If this symbol is being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular
     object, then mark it as undefined so that the generic linker will
     force the correct value.  */
  if (provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->root.type = bfd_link_hash_undefined;

  /* If this symbol is not being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular object,
     then clear out any version information because the symbol will not be
     associated with the dynamic object any more.  */
  if (!provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->verinfo.verdef = NULL;

  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
       || info->shared)
      && h->dynindx == -1)
    {
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      /* If this is a weak defined symbol, and we know a corresponding
	 real symbol from the same dynamic object, make sure the real
	 symbol is also made into a dynamic symbol.  */
      if (h->weakdef != NULL
	  && h->weakdef->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
	    return FALSE;
	}
    }

  return TRUE;
}

/* This structure is used to pass information to
   elf_link_assign_sym_version.  */

struct elf_assign_sym_version_info
{
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* Version tree.  */
  struct bfd_elf_version_tree *verdefs;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};

/* This structure is used to pass information to
   elf_link_find_version_dependencies.  */

struct elf_find_verdep_info
{
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* The number of dependencies.  */
  unsigned int vers;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};

d2043 2
a2044 1
	  elf_link_hash_traverse (elf_hash_table (info), elf_export_symbol,
d2108 1
a2108 1
			      elf_link_assign_sym_version,
d2138 1
a2138 1
			      elf_adjust_dynamic_symbol,
d2467 1
a2467 1
				elf_link_find_version_dependencies,
d2635 1
a2635 552
      elf_hash_table (info)->bucketcount = bucketcount;

      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);

      elf_finalize_dynstr (output_bfd, info);

      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
	if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NULL, (bfd_vma) 0))
	  return FALSE;
    }

  return TRUE;
}

/* This function is used to adjust offsets into .dynstr for
   dynamic symbols.  This is called via elf_link_hash_traverse.  */

static bfd_boolean elf_adjust_dynstr_offsets
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean
elf_adjust_dynstr_offsets (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}

/* Assign string offsets in .dynstr, update all structures referencing
   them.  */

static bfd_boolean
elf_finalize_dynstr (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *sdyn;
  bfd_size_type size;
  Elf_External_Dyn *dyncon, *dynconend;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);

  /* Update all .dynamic entries referencing .dynstr strings.  */
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  dyncon = (Elf_External_Dyn *) sdyn->contents;
  dynconend = (Elf_External_Dyn *) (sdyn->contents +
				    sdyn->_raw_size);
  for (; dyncon < dynconend; dyncon++)
    {
      Elf_Internal_Dyn dyn;

      elf_swap_dyn_in (dynobj, dyncon, & dyn);
      switch (dyn.d_tag)
	{
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	default:
	  break;
	}
    }

  /* Now update local dynamic symbols.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);

  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_adjust_dynstr_offsets, dynstr);

  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = (bfd_byte *) s->contents;
      do
	{
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
	    {
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
	    }
	}
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = (bfd_byte *) s->contents;
      do
	{
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
	    {
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
	    }
	}
      while (need.vn_next);
    }

  return TRUE;
}

/* Fix up the flags for a symbol.  This handles various cases which
   can only be fixed after all the input files are seen.  This is
   currently called by both adjust_dynamic_symbol and
   assign_sym_version, which is unnecessary but perhaps more robust in
   the face of future changes.  */

static bfd_boolean
elf_fix_symbol_flags (h, eif)
     struct elf_link_hash_entry *h;
     struct elf_info_failed *eif;
{
  /* If this symbol was mentioned in a non-ELF file, try to set
     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
     permit a non-ELF file to correctly refer to a symbol defined in
     an ELF dynamic object.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
    {
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
      else
	{
	  if (h->root.u.def.section->owner != NULL
	      && (bfd_get_flavour (h->root.u.def.section->owner)
		  == bfd_target_elf_flavour))
	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
	  else
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	}

      if (h->dynindx == -1
	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	  && (h->root.u.def.section->owner != NULL
	      ? (bfd_get_flavour (h->root.u.def.section->owner)
		 != bfd_target_elf_flavour)
	      : (bfd_is_abs_section (h->root.u.def.section)
		 && (h->elf_link_hash_flags
		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
     flag will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  /* If -Bsymbolic was used (which means to bind references to global
     symbols to the definition within the shared object), and this
     symbol was defined in a regular object, then it actually doesn't
     need a PLT entry, and we can accomplish that by forcing it local.
     Likewise, if the symbol has hidden or internal visibility.
     FIXME: It might be that we also do not need a PLT for other
     non-hidden visibilities, but we would have to tell that to the
     backend specifically; we can't just clear PLT-related data here.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
      && eif->info->shared
      && is_elf_hash_table (eif->info)
      && (eif->info->symbolic
	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
    {
      struct elf_backend_data *bed;
      bfd_boolean force_local;

      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);

      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }

  /* If a weak undefined symbol has non-default visibility, we also
     hide it from the dynamic linker.  */
  if (ELF_ST_VISIBILITY (h->other)
      && h->root.type == bfd_link_hash_undefweak)
    {
      struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);
    }

  /* If this is a weak defined symbol in a dynamic object, and we know
     the real definition in the dynamic object, copy interesting flags
     over to the real definition.  */
  if (h->weakdef != NULL)
    {
      struct elf_link_hash_entry *weakdef;

      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);

      /* If the real definition is defined by a regular object file,
	 don't do anything special.  See the longer description in
	 elf_adjust_dynamic_symbol, below.  */
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->weakdef = NULL;
      else
	{
	  struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
	}
    }

  return TRUE;
}

/* Make the backend pick a good value for a dynamic symbol.  This is
   called via elf_link_hash_traverse, and also calls itself
   recursively.  */

static bfd_boolean
elf_adjust_dynamic_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
  bfd *dynobj;
  struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info))
    return FALSE;

  if (h->root.type == bfd_link_hash_warning)
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Fix the symbol flags.  */
  if (! elf_fix_symbol_flags (h, eif))
    return FALSE;

  /* If this symbol does not require a PLT entry, and it is not
     defined by a dynamic object, or is not referenced by a regular
     object, ignore it.  We do have to handle a weak defined symbol,
     even if no regular object refers to it, if we decided to add it
     to the dynamic symbol table.  FIXME: Do we normally need to worry
     about symbols which are defined by one dynamic object and
     referenced by another one?  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      return TRUE;
    }

  /* If we've already adjusted this symbol, don't do it again.  This
     can happen via a recursive call.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    return TRUE;

  /* Don't look at this symbol again.  Note that we must set this
     after checking the above conditions, because we may look at a
     symbol once, decide not to do anything, and then get called
     recursively later after REF_REGULAR is set below.  */
  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;

  /* If this is a weak definition, and we know a real definition, and
     the real symbol is not itself defined by a regular object file,
     then get a good value for the real definition.  We handle the
     real symbol first, for the convenience of the backend routine.

     Note that there is a confusing case here.  If the real definition
     is defined by a regular object file, we don't get the real symbol
     from the dynamic object, but we do get the weak symbol.  If the
     processor backend uses a COPY reloc, then if some routine in the
     dynamic object changes the real symbol, we will not see that
     change in the corresponding weak symbol.  This is the way other
     ELF linkers work as well, and seems to be a result of the shared
     library model.

     I will clarify this issue.  Most SVR4 shared libraries define the
     variable _timezone and define timezone as a weak synonym.  The
     tzset call changes _timezone.  If you write
       extern int timezone;
       int _timezone = 5;
       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
     you might expect that, since timezone is a synonym for _timezone,
     the same number will print both times.  However, if the processor
     backend uses a COPY reloc, then actually timezone will be copied
     into your process image, and, since you define _timezone
     yourself, _timezone will not.  Thus timezone and _timezone will
     wind up at different memory locations.  The tzset call will set
     _timezone, leaving timezone unchanged.  */

  if (h->weakdef != NULL)
    {
      /* If we get to this point, we know there is an implicit
	 reference by a regular object file via the weak symbol H.
	 FIXME: Is this really true?  What if the traversal finds
	 H->WEAKDEF before it finds H?  */
      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;

      if (! elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
	return FALSE;
    }

  /* If a symbol has no type and no size and does not require a PLT
     entry, then we are probably about to do the wrong thing here: we
     are probably going to create a COPY reloc for an empty object.
     This case can arise when a shared object is built with assembly
     code, and the assembly code fails to set the symbol type.  */
  if (h->size == 0
      && h->type == STT_NOTYPE
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    (*_bfd_error_handler)
      (_("warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  dynobj = elf_hash_table (eif->info)->dynobj;
  bed = get_elf_backend_data (dynobj);
  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* This routine is used to export all defined symbols into the dynamic
   symbol table.  It is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_export_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1
      && (h->elf_link_hash_flags
	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;

      for (t = eif->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals != NULL)
	    {
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    goto doit;
		}
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals ; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    return TRUE;
		}
	    }
	}

      if (!eif->verdefs)
	{
	doit:
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Look through the symbols which are defined in other shared
   libraries and referenced here.  Update the list of version
   dependencies.  This will be put into the .gnu.version_r section.
   This function is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_link_find_version_dependencies (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* We only care about symbols defined in shared objects with version
     information.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      || h->dynindx == -1
      || h->verinfo.verdef == NULL)
    return TRUE;

  /* See if we already know about this version.  */
  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
	continue;

      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
	  return TRUE;

      break;
    }

  /* This is a new version.  Add it to tree we are building.  */

  if (t == NULL)
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
      if (t == NULL)
	{
	  rinfo->failed = TRUE;
	  return FALSE;
	}

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
      elf_tdata (rinfo->output_bfd)->verref = t;
    }
d2637 2
a2638 2
  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);
d2640 1
a2640 5
  /* Note that we are copying a string pointer here, and testing it
     above.  If bfd_elf_string_from_elf_section is ever changed to
     discard the string data when low in memory, this will have to be
     fixed.  */
  a->vna_nodename = h->verinfo.verdef->vd_nodename;
d2642 1
a2642 2
  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;
d2644 4
a2647 6
  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;
d2651 3
d2655 2
a2656 4
/* Figure out appropriate versions for all the symbols.  We may not
   have the version number script until we have read all of the input
   files, so until that point we don't know which symbols should be
   local.  This function is called via elf_link_hash_traverse.  */
d2659 1
a2659 1
elf_link_assign_sym_version (h, data)
d2663 1
a2663 9
  struct elf_assign_sym_version_info *sinfo;
  struct bfd_link_info *info;
  struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  bfd_size_type amt;

  sinfo = (struct elf_assign_sym_version_info *) data;
  info = sinfo->info;
d2668 7
a2674 9
  /* Fix the symbol flags.  */
  eif.failed = FALSE;
  eif.info = info;
  if (! elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
	sinfo->failed = TRUE;
      return FALSE;
    }
d2676 11
a2686 4
  /* We only need version numbers for symbols defined in regular
     objects.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;
d2688 2
a2689 6
  bed = get_elf_backend_data (sinfo->output_bfd);
  p = strchr (h->root.root.string, ELF_VER_CHR);
  if (p != NULL && h->verinfo.vertree == NULL)
    {
      struct bfd_elf_version_tree *t;
      bfd_boolean hidden;
d2691 3
a2693 1
      hidden = TRUE;
d2695 6
a2700 8
      /* There are two consecutive ELF_VER_CHR characters if this is
	 not a hidden symbol.  */
      ++p;
      if (*p == ELF_VER_CHR)
	{
	  hidden = FALSE;
	  ++p;
	}
d2702 2
a2703 2
      /* If there is no version string, we can just return out.  */
      if (*p == '\0')
d2705 15
a2719 3
	  if (hidden)
	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
	  return TRUE;
d2721 1
d2723 4
a2726 8
      /* Look for the version.  If we find it, it is no longer weak.  */
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (strcmp (t->name, p) == 0)
	    {
	      size_t len;
	      char *alc;
	      struct bfd_elf_version_expr *d;
d2728 3
a2730 8
	      len = p - h->root.root.string;
	      alc = bfd_malloc ((bfd_size_type) len);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, h->root.root.string, len - 1);
	      alc[len - 1] = '\0';
	      if (alc[len - 2] == ELF_VER_CHR)
		alc[len - 2] = '\0';
d2732 8
a2739 3
	      h->verinfo.vertree = t;
	      t->used = TRUE;
	      d = NULL;
d2741 8
a2748 48
	      if (t->globals != NULL)
		{
		  for (d = t->globals; d != NULL; d = d->next)
		    if ((*d->match) (d, alc))
		      break;
		}

	      /* See if there is anything to force this symbol to
		 local scope.  */
	      if (d == NULL && t->locals != NULL)
		{
		  for (d = t->locals; d != NULL; d = d->next)
		    {
		      if ((*d->match) (d, alc))
			{
			  if (h->dynindx != -1
			      && info->shared
			      && ! info->export_dynamic)
			    {
			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
			    }

			  break;
			}
		    }
		}

	      free (alc);
	      break;
	    }
	}

      /* If we are building an application, we need to create a
	 version node for this version.  */
      if (t == NULL && ! info->shared)
	{
	  struct bfd_elf_version_tree **pp;
	  int version_index;

	  /* If we aren't going to export this symbol, we don't need
	     to worry about it.  */
	  if (h->dynindx == -1)
	    return TRUE;

	  amt = sizeof *t;
	  t = ((struct bfd_elf_version_tree *)
	       bfd_alloc (sinfo->output_bfd, amt));
	  if (t == NULL)
d2750 7
a2756 2
	      sinfo->failed = TRUE;
	      return FALSE;
a2757 31

	  t->next = NULL;
	  t->name = p;
	  t->globals = NULL;
	  t->locals = NULL;
	  t->deps = NULL;
	  t->name_indx = (unsigned int) -1;
	  t->used = TRUE;

	  version_index = 1;
	  /* Don't count anonymous version tag.  */
	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
	    version_index = 0;
	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
	    ++version_index;
	  t->vernum = version_index;

	  *pp = t;

	  h->verinfo.vertree = t;
	}
      else if (t == NULL)
	{
	  /* We could not find the version for a symbol when
	     generating a shared archive.  Return an error.  */
	  (*_bfd_error_handler)
	    (_("%s: undefined versioned symbol name %s"),
	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  sinfo->failed = TRUE;
	  return FALSE;
d2759 1
a2759 3

      if (hidden)
	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
d2762 2
a2763 3
  /* If we don't have a version for this symbol, see if we can find
     something.  */
  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
d2765 5
a2769 3
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_tree *local_ver;
      struct bfd_elf_version_expr *d;
d2771 3
a2773 5
      /* See if can find what version this symbol is in.  If the
	 symbol is supposed to be local, then don't actually register
	 it.  */
      local_ver = NULL;
      for (t = sinfo->verdefs; t != NULL; t = t->next)
d2775 7
a2781 1
	  if (t->globals != NULL)
d2783 8
a2790 58
	      bfd_boolean matched;

	      matched = FALSE;
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    {
		      if (d->symver)
			matched = TRUE;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
		    }
		}

	      if (d != NULL)
		break;
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals; d != NULL; d = d->next)
		{
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.  */
		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
		    local_ver = t;
		  else if ((*d->match) (d, h->root.root.string))
		    {
		      local_ver = t;
		      break;
		    }
		}

	      if (d != NULL)
		break;
	    }
	}

      if (local_ver != NULL)
	{
	  h->verinfo.vertree = local_ver;
	  if (h->dynindx != -1
	      && info->shared
	      && ! info->export_dynamic)
	    {
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
d2793 1
a2857 2
static bfd_boolean elf_link_sec_merge_syms
  PARAMS ((struct elf_link_hash_entry *, PTR));
a2874 52
/* Compute the size of, and allocate space for, REL_HDR which is the
   section header for a section containing relocations for O.  */

static bfd_boolean
elf_link_size_reloc_section (abfd, rel_hdr, o)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *o;
{
  bfd_size_type reloc_count;
  bfd_size_type num_rel_hashes;

  /* Figure out how many relocations there will be.  */
  if (rel_hdr == &elf_section_data (o)->rel_hdr)
    reloc_count = elf_section_data (o)->rel_count;
  else
    reloc_count = elf_section_data (o)->rel_count2;

  num_rel_hashes = o->reloc_count;
  if (num_rel_hashes < reloc_count)
    num_rel_hashes = reloc_count;

  /* That allows us to calculate the size of the section.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;

  /* The contents field must last into write_object_contents, so we
     allocate it with bfd_alloc rather than malloc.  Also since we
     cannot be sure that the contents will actually be filled in,
     we zero the allocated space.  */
  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
    return FALSE;

  /* We only allocate one set of hash entries, so we only do it the
     first time we are called.  */
  if (elf_section_data (o)->rel_hashes == NULL
      && num_rel_hashes)
    {
      struct elf_link_hash_entry **p;

      p = ((struct elf_link_hash_entry **)
	   bfd_zmalloc (num_rel_hashes
			* sizeof (struct elf_link_hash_entry *)));
      if (p == NULL)
	return FALSE;

      elf_section_data (o)->rel_hashes = p;
    }

  return TRUE;
}

d3243 4
a3246 3
		  relocs = (NAME(_bfd_elf,link_read_relocs)
			    (abfd, sec, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL, info->keep_memory));
d3364 1
a3364 1
			    elf_link_sec_merge_syms, (PTR) abfd);
d3380 2
a3381 3
	  if (!elf_link_size_reloc_section (abfd,
					    &elf_section_data (o)->rel_hdr,
					    o))
d3385 2
a3386 3
	      && !elf_link_size_reloc_section (abfd,
					       elf_section_data (o)->rel_hdr2,
					       o))
d3411 1
a3411 1
  symtab_hdr->sh_addralign = bed->s->file_align;
d4021 1
a4021 1
		 created by elf_link_create_dynamic_sections.  */
a4227 30
/* Adjust all external symbols pointing into SEC_MERGE sections
   to reflect the object merging within the sections.  */

static bfd_boolean
elf_link_sec_merge_syms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  asection *sec;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      bfd *output_bfd = (bfd *) data;

      h->root.u.def.value =
	_bfd_merged_section_offset (output_bfd,
				    &h->root.u.def.section,
				    elf_section_data (sec)->sec_info,
				    h->root.u.def.value, (bfd_vma) 0);
    }

  return TRUE;
}

a4712 75
/* Copy the relocations indicated by the INTERNAL_RELOCS (which
   originated from the section given by INPUT_REL_HDR) to the
   OUTPUT_BFD.  */

static bfd_boolean
elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
			internal_relocs)
     bfd *output_bfd;
     asection *input_section;
     Elf_Internal_Shdr *input_rel_hdr;
     Elf_Internal_Rela *internal_relocs;
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  Elf_Internal_Shdr *output_rel_hdr;
  asection *output_section;
  unsigned int *rel_countp = NULL;
  struct elf_backend_data *bed;
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));

  output_section = input_section->output_section;
  output_rel_hdr = NULL;

  if (elf_section_data (output_section)->rel_hdr.sh_entsize
      == input_rel_hdr->sh_entsize)
    {
      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
      rel_countp = &elf_section_data (output_section)->rel_count;
    }
  else if (elf_section_data (output_section)->rel_hdr2
	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
	       == input_rel_hdr->sh_entsize))
    {
      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
      rel_countp = &elf_section_data (output_section)->rel_count2;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
      bfd_set_error (bfd_error_wrong_object_format);
      return FALSE;
    }

  bed = get_elf_backend_data (output_bfd);
  if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }

  /* Bump the counter, so that we know where to add the next set of
     relocations.  */
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);

  return TRUE;
}

d4933 1
a4933 1
	  /* Section was created by elf_link_create_dynamic_sections
d4957 3
a4959 3
	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
			     (input_bfd, o, finfo->external_relocs,
			      finfo->internal_relocs, FALSE));
d5276 1
a5276 1
		reloc_emitter = elf_link_output_relocs;
d5850 3
a5852 3
      relstart = (NAME(_bfd_elf,link_read_relocs)
		  (input_bfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		   info->keep_memory));
d5955 4
a5958 2
	      internal_relocs = (NAME(_bfd_elf,link_read_relocs)
				 (o->owner, o, NULL, NULL, info->keep_memory));
d6056 1
a6056 1
	  int file_align = bed->s->file_align;
d6058 1
a6058 1
	  n = h->vtable_parent->vtable_entries_size / file_align;
d6081 1
a6081 1
  int file_align;
d6098 2
a6099 2
  relstart = (NAME(_bfd_elf,link_read_relocs)
	      (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL, TRUE));
d6103 1
a6103 1
  file_align = bed->s->file_align;
d6114 1
a6114 1
	    bfd_vma entry = (rel->r_offset - hstart) / file_align;
d6249 1
a6249 1
  int file_align = bed->s->file_align;
d6273 1
a6273 1
      bytes = (size / file_align + 1) * sizeof (bfd_boolean);
d6283 1
a6283 1
	      oldbytes = ((h->vtable_entries_size / file_align + 1)
d6299 1
a6299 1
  h->vtable_entries_used[addend / file_align] = TRUE;
d6595 4
a6598 3
	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
			   (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			    info->keep_memory));
d6619 4
a6622 3
	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
			   (abfd, eh, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			    info->keep_memory));
@


1.220
log
@2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.h (elf_link_check_versioned_symbol): Also handle the
	case that a DSO references a hidden symbol which may be
	satisfied by a versioned symbol in another DSO.
	(elf_link_output_extsym): Check versioned definition for hidden
	symbol referenced by a DSO.
@
text
@d1111 1
a1111 1
    return TRUE;
d1206 1
@


1.219
log
@bfd/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* elf32-i386.c (allocate_dynrelocs): Don't allocate dynamic
	relocation entries for weak undefined symbols with non-default
	visibility.
	(elf_i386_relocate_section): Initialize the GOT entries and
	skip R_386_32/R_386_PC32 for weak undefined symbols with
	non-default visibility.

	* elfxx-ia64.c (allocate_fptr): Don't allocate function
	descriptors for weak undefined symbols with non-default
	visibility.
	(allocate_dynrel_entries): Don't allocate relocation entries
	for symbols resolved to 0.
	(set_got_entry): Don't install dynamic relocation for weak
	undefined symbols with non-default visibility.
	(set_pltoff_entry): Likewise.

	* elflink.h (elf_fix_symbol_flags): Hide weak undefined symbols
	with non-default visibility.
	(elf_link_output_extsym): Don't make weak undefined symbols
	with non-default visibility dynamic.

ld/testsuite/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* ld-elfvsb/main.c: Updated.
	* ld-elfvsb/sh1.c: Likewise.
@
text
@d6233 3
a6235 1
   versioned symbol that would normally require an explicit version.  */
d6242 1
a6242 1
  bfd *undef_bfd = h->root.u.undef.abfd;
d6245 1
a6245 3
  if ((undef_bfd->flags & DYNAMIC) == 0
      || info->hash->creator->flavour != bfd_target_elf_flavour
      || elf_dt_soname (undef_bfd) == NULL)
d6248 24
d6291 1
a6291 1
      if (input == undef_bfd
d6443 2
a6444 1
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC))
@


1.218
log
@bfd/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_merge_symbol): Correctly handle weak definiton.

ld/testsuite/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* ld-elfvers/vers18.dsym: Updated for weak definiton change.
	* ld-elfvers/vers18.ver: Likewise.
	* ld-elfvers/vers19.ver: Likewise.

	* ld-elfweak/elfweak.exp: Remove xfail.
@
text
@d4154 10
d6559 3
a6561 1
      && (finfo->info->shared
@


1.217
log
@2003-05-04  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_merge_symbol): Don't record a hidden/internal
	symbol dynamic. Check indirection when removing the old
	definition for symbols with non-default visibility.
	(elf_add_default_symbol): Skip when told by elf_merge_symbol.
@
text
@d487 1
d674 43
d745 2
a746 1
      && bind != STB_WEAK
d769 4
a772 3
  if ((! dt_needed && h->root.type == bfd_link_hash_defweak)
      || h->root.type == bfd_link_hash_undefweak
      || bind == STB_WEAK)
d830 2
a831 1
	      && (bind == STB_WEAK
d833 1
a833 1
      && (h->root.type != bfd_link_hash_defweak
d835 2
a836 1
	  || bind == STB_WEAK))
d889 1
a889 2
	      && (h->root.type == bfd_link_hash_defweak
		  || h->type == STT_FUNC)))
d893 1
a893 2
      && (bind != STB_WEAK
	  || h->root.type == bfd_link_hash_defweak))
d989 1
a989 1
      && h->root.type == bfd_link_hash_defweak
d992 2
a993 1
      && bind != STB_WEAK)
d1019 1
a1019 1
      && h->root.type != bfd_link_hash_defweak
d1022 1
a1022 1
      && bind == STB_WEAK)
@


1.216
log
@bfd/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_merge_symbol): Call elf_backend_copy_indirect_symbol
	to copy any information related to dynamic linking when we flip
	the indirection.

ld/testsuite/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* ld-elfvers/vers.exp (picflag): Set PIC flag for compiler.
	(build_vers_lib): Support PIC.
	(build_vers_lib_no_pic): New. Change all calls to build_vers_lib
	to build_vers_lib_no_pic.
	(build_vers_lib_pic): New.
	Add tests vers26a, vers26b1, vers26b2 and vers26b3 for versioned
	definition vs. normal definition in different files.

	* ld-elfvers/vers26a.c: New file.
	* ld-elfvers/vers26a.dsym: Likewise.
	* ld-elfvers/vers26a.map: Likewise.
	* ld-elfvers/vers26a.ver: Likewise.
	* ld-elfvers/vers26b.c: Likewise.

	* ld-elfvers/vers26b.dsym: New empty file.
	* ld-elfvers/vers26b.ver: Likewise.
@
text
@d642 8
a649 2
      /* FIXME: Should we check type and size for protected symbol?  */
      return _bfd_elf_link_record_dynamic_symbol (info, h);
d658 2
d662 5
a666 2
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
d1063 3
d1174 3
@


1.215
log
@bfd/

2003-04-27  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (ELF_LINK_DYNAMIC_DEF): New.
	(ELF_LINK_DYNAMIC_WEAK): New.

	* elflink.h (elf_merge_symbol): Add one argument to indicate if
	a symbol should be skipped. Ignore definitions in dynamic
	objects for symbols with non-default visibility.
	(elf_add_default_symbol): Adjusted.
	(elf_link_add_object_symbols): Check if a symbol should be
	skipped. Don't merge the visibility field with the one from
	a dynamic object.
	(elf_link_check_versioned_symbol): Use undef_bfd.
	(elf_link_output_extsym): Warn if a forced local symbol is
	referenced from dynamic objects. Make non-weak undefined symbol
	with non-default visibility a fatal error.

ld/testsuite/

2003-04-27  H.J. Lu <hjl@@gnu.org>

	* ld-elfvsb/elfvsb.dat: Updated.
	* ld-elfvsb/elfvsb.exp: Likewise.
	* ld-elfvsb/main.c: Likewise.
	* ld-elfvsb/sh1.c: Likewise.
	* ld-elfvsb/sh2.c: Likewise.
@
text
@d912 1
a913 1
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
d916 2
@


1.214
log
@2003-04-25  Alan Modra  <amodra@@bigpond.net.au>

	* elflink.h (elf_merge_symbol): When we find a regular definition
	for an indirect symbol, flip the indirection so that the old
	direct symbol now points to the new definition.
@
text
@d45 1
a45 1
	   bfd_boolean *, bfd_boolean));
d466 1
a466 1
elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash,
d475 1
d488 1
d611 51
d990 1
d1046 1
a1046 1
			  &hi, &override, &type_change_ok,
d1155 1
a1155 1
			  &hi, &override, &type_change_ok,
d1797 1
d1895 3
a1897 2
				  sym_hash, &override, &type_change_ok,
				  &size_change_ok, dt_needed))
d1900 3
d2082 4
a2085 3
	  /* If st_other has a processor-specific meaning, specific code
	     might be needed here.  */
	  if (isym->st_other != 0)
d2152 1
a2152 1
	  if (definition && (abfd->flags & DYNAMIC) == 0)
d6169 1
a6169 1
      || elf_dt_soname (h->root.u.undef.abfd) == NULL)
d6336 22
d6518 2
a6519 1
  /* If a symbol is not defined locally, we clear the visibility field.  */
d6521 3
d6525 12
a6536 1
    sym.st_other &= ~ ELF_ST_VISIBILITY (-1);
@


1.214.2.1
log
@	Merge from mainline:
	2003-04-28  H.J. Lu <hjl@@gnu.org>
	* elfxx-ia64.c (elfNN_ia64_relax_section): Relax ldxmov during
	the relax finalize pass.

	* section.c (struct sec): Add need_finalize_relax and remove
	flag11.
	(STD_SECTION): Update struct sec initializer.
	* bfd-in2.h: Regenerated.

	2003-04-28  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_merge_symbol): Call elf_backend_copy_indirect_symbol
	to copy any information related to dynamic linking when we flip
	the indirection.

	2003-04-27  H.J. Lu <hjl@@gnu.org>
	* elf-bfd.h (ELF_LINK_DYNAMIC_DEF): New.
	(ELF_LINK_DYNAMIC_WEAK): New.

	* elflink.h (elf_merge_symbol): Add one argument to indicate if
	a symbol should be skipped. Ignore definitions in dynamic
	objects for symbols with non-default visibility.
	(elf_add_default_symbol): Adjusted.
	(elf_link_add_object_symbols): Check if a symbol should be
	skipped. Don't merge the visibility field with the one from
	a dynamic object.
	(elf_link_check_versioned_symbol): Use undef_bfd.
	(elf_link_output_extsym): Warn if a forced local symbol is
	referenced from dynamic objects. Make non-weak undefined symbol
	with non-default visibility a fatal error.
@
text
@d45 1
a45 1
	   bfd_boolean *, bfd_boolean *, bfd_boolean));
d466 1
a466 1
elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
a474 1
     bfd_boolean *skip;
a486 1
  *skip = FALSE;
a608 51
  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
	    }
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
	}
    }

  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other)
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      return _bfd_elf_link_record_dynamic_symbol (info, h);
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }

a858 1
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
d860 1
a862 2
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
a936 1
  bfd_boolean skip;
d992 1
a992 1
			  &hi, &skip, &override, &type_change_ok,
d1101 1
a1101 1
			  &hi, &skip, &override, &type_change_ok,
a1742 1
	  bfd_boolean skip;
d1840 2
a1841 3
				  sym_hash, &skip, &override,
				  &type_change_ok, &size_change_ok,
				  dt_needed))
a1843 3
	  if (skip)
	    continue;

d2023 3
a2025 4
	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (isym->st_other != 0 && !dynamic)
d2092 1
a2092 1
	  if (definition && !dynamic)
d6109 1
a6109 1
      || elf_dt_soname (undef_bfd) == NULL)
a6275 22
  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocateable
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC
	     | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

d6436 1
a6436 2
  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
a6437 3
      && ELF_ST_VISIBILITY (sym.st_other)
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type != bfd_link_hash_undefweak
d6439 1
a6439 12
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }
@


1.214.2.2
log
@	* elflink.h (elf_merge_symbol): Correctly handle weak definiton.

	* elflink.h (elf_merge_symbol): Don't record a hidden/internal
	symbol dynamic. Check indirection when removing the old
	definition for symbols with non-default visibility.
	(elf_add_default_symbol): Skip when told by elf_merge_symbol.
@
text
@a486 1
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;
d642 2
a643 8
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return _bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
a651 2
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	h = *sym_hash;
d654 2
a655 5
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
a661 43
  /* We need to treat weak definiton right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
	{
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;

  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;

  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;

  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;

d690 1
a690 2
      && !newweakdef
      && !newweakundef
d713 3
a715 4
  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef)
d773 1
a773 2
	      && (newweakdef
		  || newweakundef
d775 1
a775 1
      && (!oldweakdef
d777 1
a777 2
	  || newweakdef
	  || newweakundef))
d830 2
a831 1
	      && (oldweakdef || h->type == STT_FUNC)))
d835 2
a836 1
      && ((!newweakdef && !newweakundef) || oldweakdef))
d932 1
a932 1
      && oldweakdef
d935 1
a935 2
      && !newweakdef
      && !newweakundef)
d961 1
a961 1
      && !oldweakdef
d964 1
a964 1
      && (newweakdef || newweakundef))
a1051 3
  if (skip)
    return TRUE;

a1159 3

  if (skip)
    return TRUE;
@


1.214.2.3
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.

	2003-05-08  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_add_default_symbol): After skipping the
	unversioned symbol, go to non-default one.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_link_check_versioned_symbol): Also handle the
	case that a DSO references a hidden symbol which may be
	satisfied by a versioned symbol in another DSO.
	(elf_link_output_extsym): Check versioned definition for hidden
	symbol referenced by a DSO.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Improve
	error message for mixing different-endian files.  Check for ABI
	compatibility of input files with the selected emulation.
@
text
@d1111 1
a1111 1
    goto nondefault;
a1205 1
nondefault:
d6223 1
a6223 3
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */
d6230 1
a6230 1
  bfd *abfd;
d6233 3
a6235 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
a6237 24
  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

d6257 1
a6257 1
      if (input == abfd
d6409 1
a6409 2
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, h))
@


1.214.2.4
log
@	Merge from mainline:
	2003-05-20  Jakub Jelinek  <jakub@@redhat.com>
	* elflink.h (elf_link_output_extsym): Only issue error about !=
	STV_DEFAULT symbols if they are bfd_link_hash_undefined.

	* elflink.h (elf_merge_symbol): Change from:
	 2003-05-20  H.J. Lu <hongjiu.lu@@intel.com>
	 * elflink.c (_bfd_elf_merge_symbol): Check ELF_LINK_DYNAMIC_DEF
	 when removing the old definition for symbols with non-default
	 visibility.
@
text
@d666 1
a666 2
	  h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_DYNAMIC
				     | ELF_LINK_DYNAMIC_DEF);
d6615 1
a6615 1
      && h->root.type == bfd_link_hash_undefined
@


1.214.2.5
log
@(elf_gc_record_vtentry): Allocate an extra element in the vtable_entries_used
array to allow for the accessing the largest element.
@
text
@d8317 1
a8317 1
  if (addend > h->vtable_entries_size)
d8338 2
a8339 3
	 consolidation pass and another extra entry because we are
	 going to write up to and including 'size' entries.  */
      bytes = (size / file_align + 2) * sizeof (bfd_boolean);
@


1.214.2.6
log
@	* elflink.h (elf_gc_record_vtentry): Revert last change.  Correct
	size calculation from addend.  Round size up.
@
text
@d8317 1
a8317 1
  if (addend >= h->vtable_entries_size)
d8325 1
a8325 1
	size = addend + file_align;
d8329 1
a8329 1
	  if (addend >= size)
d8333 1
a8333 1
	      size = addend + file_align;
a8335 1
      size = (size + file_align - 1) / file_align * file_align;
d8338 3
a8340 2
	 consolidation pass.  */
      bytes = (size / file_align + 1) * sizeof (bfd_boolean);
@


1.213
log
@Properly report	filename for alignment reduction.
Add test for alignment reduction.
@
text
@d482 1
d773 1
d802 7
a808 13
      /* This union may have been set to be non-NULL when this symbol
	 was seen in a dynamic object.  We must force the union to be
	 NULL, so that it is correct for a regular symbol.  */

      h->verinfo.vertree = NULL;

      /* In this special case, if H is the target of an indirection,
	 we want the caller to frob with H rather than with the
	 indirect symbol.  That will permit the caller to redefine the
	 target of the indirection, rather than the indirect symbol
	 itself.  FIXME: This will break the -y option if we store a
	 symbol with a different name.  */
      *sym_hash = h;
d848 20
a867 1
      h->verinfo.vertree = NULL;
d901 1
a901 1
     this case we prefer to definition in the shared object.  To make
@


1.213.2.1
log
@Merge from mainline.
@
text
@d45 1
a45 1
	   bfd_boolean *, bfd_boolean *, bfd_boolean));
d466 1
a466 1
elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
a474 1
     bfd_boolean *skip;
a481 1
  struct elf_link_hash_entry *flip;
a485 1
  *skip = FALSE;
a607 51
  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
	    }
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
	}
    }

  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other)
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      return _bfd_elf_link_record_dynamic_symbol (info, h);
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }

a771 1
  flip = NULL;
d800 13
a812 7
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
d852 1
a852 22
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
d886 1
a886 1
     this case we prefer the definition in the shared object.  To make
a921 1
  bfd_boolean skip;
d977 1
a977 1
			  &hi, &skip, &override, &type_change_ok,
d1086 1
a1086 1
			  &hi, &skip, &override, &type_change_ok,
a1727 1
	  bfd_boolean skip;
d1825 2
a1826 3
				  sym_hash, &skip, &override,
				  &type_change_ok, &size_change_ok,
				  dt_needed))
a1828 3
	  if (skip)
	    continue;

d2008 3
a2010 4
	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (isym->st_other != 0 && !dynamic)
d2077 1
a2077 1
	  if (definition && !dynamic)
d6094 1
a6094 1
      || elf_dt_soname (undef_bfd) == NULL)
a6260 22
  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocateable
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC
	     | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

d6421 1
a6421 2
  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
a6422 3
      && ELF_ST_VISIBILITY (sym.st_other)
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type != bfd_link_hash_undefweak
d6424 1
a6424 12
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }
@


1.213.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d23 10
d41 11
d54 8
d64 2
d68 4
d453 766
d1361 1
a1361 1
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1551 1
a1551 1
	if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1896 4
a1899 4
	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok,
				      dt_needed))
d2149 3
a2151 3
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override, dt_needed))
d2412 4
a2415 4
	  internal_relocs
	    = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
					 info->keep_memory);
d2511 6
a2516 1
/* Add an entry to the .dynamic table.  */
d2519 2
a2520 1
elf_add_dynamic_entry (info, tag, val)
a2521 2
     bfd_vma tag;
     bfd_vma val;
d2523 5
a2527 5
  Elf_Internal_Dyn dyn;
  bfd *dynobj;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
d2532 48
a2579 1
  dynobj = elf_hash_table (info)->dynobj;
d2581 5
a2585 2
  s = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);
d2587 4
a2590 3
  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
d2593 4
a2596 4
  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  elf_swap_dyn_out (dynobj, &dyn,
		    (Elf_External_Dyn *) (newcontents + s->_raw_size));
d2598 89
a2686 2
  s->_raw_size = newsize;
  s->contents = newcontents;
d2691 245
d3231 1
a3231 2
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
d3295 1
a3295 1
			      _bfd_elf_link_assign_sym_version,
d3325 1
a3325 1
			      _bfd_elf_adjust_dynamic_symbol,
d3654 1
a3654 1
				_bfd_elf_link_find_version_dependencies,
d3849 557
a4405 2
{
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
d4410 9
a4418 4
  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}
d4420 4
a4423 2
/* Assign string offsets in .dynstr, update all structures referencing
   them.  */
d4425 6
a4430 11
static bfd_boolean
elf_finalize_dynstr (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *sdyn;
  bfd_size_type size;
  Elf_External_Dyn *dyncon, *dynconend;
d4432 1
a4432 2
  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);
d4434 8
a4441 3
  /* Update all .dynamic entries referencing .dynstr strings.  */
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);
d4443 7
a4449 6
  dyncon = (Elf_External_Dyn *) sdyn->contents;
  dynconend = (Elf_External_Dyn *) (sdyn->contents +
				    sdyn->_raw_size);
  for (; dyncon < dynconend; dyncon++)
    {
      Elf_Internal_Dyn dyn;
d4451 2
a4452 2
      elf_swap_dyn_in (dynobj, dyncon, & dyn);
      switch (dyn.d_tag)
d4454 49
a4502 15
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	default:
	  break;
a4503 1
    }
d4505 52
a4556 4
  /* Now update local dynamic symbols.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);
d4558 3
a4560 3
  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_adjust_dynstr_offsets, dynstr);
d4562 3
a4564 2
  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
d4566 3
a4568 5
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;
d4570 5
a4574 3
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = (bfd_byte *) s->contents;
      do
d4576 33
a4608 4
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
d4610 15
a4624 7
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
a4626 2
      while (def.vd_next);
    }
d4628 1
a4628 12
  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = (bfd_byte *) s->contents;
      do
d4630 4
a4633 7
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
d4635 1
a4635 8
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
a4637 1
      while (need.vn_next);
d4702 2
d4721 52
d5141 3
a5143 4
		  relocs
		    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
						 (Elf_Internal_Rela *) NULL,
						 info->keep_memory);
d5261 1
a5261 1
			    _bfd_elf_link_sec_merge_syms, (PTR) abfd);
d5277 3
a5279 2
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
d5283 3
a5285 2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
d5310 1
a5310 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d5920 1
a5920 1
		 created by _bfd_elf_link_create_dynamic_sections.  */
d6127 30
d6159 1
a6159 3
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */
d6166 1
a6166 1
  bfd *abfd;
d6169 3
a6171 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
a6173 24
  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

d6193 1
a6193 1
      if (input == abfd
a6241 1
	  unsigned short version_index;
d6262 1
a6262 2
	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
d6264 1
a6264 1
	      /* This is the base or first version.  We can use it.  */
d6345 1
a6345 2
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, h))
d6485 1
a6485 3
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
d6523 1
a6523 1
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
d6615 75
d6910 1
a6910 1
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
d6934 3
a6936 3
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
d7253 1
a7253 1
		reloc_emitter = _bfd_elf_link_output_relocs;
d7827 3
a7829 3
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d7932 2
a7933 4
	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d8031 1
a8031 1
	  unsigned int log_file_align = bed->s->log_file_align;
d8033 1
a8033 1
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
d8056 1
a8056 1
  unsigned int log_file_align;
d8073 2
a8074 2
  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL,
					(Elf_Internal_Rela *) NULL, TRUE);
d8078 1
a8078 1
  log_file_align = bed->s->log_file_align;
d8089 1
a8089 1
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
d8224 1
a8224 1
  unsigned int log_file_align = bed->s->log_file_align;
d8248 1
a8248 1
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);
d8258 1
a8258 1
	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
d8274 1
a8274 1
  h->vtable_entries_used[addend >> log_file_align] = TRUE;
d8570 3
a8572 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, stab, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
d8593 3
a8595 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, eh, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
@


1.212
log
@Maintain maximum alignment for common symbols. Warn reducing alignment for
common symbols. Report old filename when symbol size changes.
@
text
@d1932 5
a1936 1
	      unsigned int common_align, normal_align, symbol_align;
d1949 5
a1953 1
		common_align = old_alignment;
d1955 5
a1959 1
		common_align = bfd_log2 (isym->st_value);
d1964 5
a1968 3
		   1 << normal_align, name,
		   bfd_archive_filename (old_bfd),
		   1 << common_align, bfd_archive_filename (abfd));
@


1.211
log
@Fix memory leaks
@
text
@d1612 2
a1613 1
      bfd_boolean size_change_ok, type_change_ok;
d1615 1
d1617 1
a1617 1
      bfd_boolean override;
d1722 2
d1841 17
a1857 3
	     override.  */
	  if (h->root.type == bfd_link_hash_common)
	    old_alignment = h->root.u.c.p->alignment_power;
d1914 2
d1924 33
d1963 1
a1963 1
		  (_("Warning: size of symbol `%s' changed from %lu to %lu in %s"),
d1965 3
a1967 1
		   (unsigned long) isym->st_size, bfd_archive_filename (abfd));
@


1.210
log
@2003-03-28  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Correctly combine
	visibilities.
@
text
@d4858 1
@


1.209
log
@2003-03-06  Jakub Jelinek <jakub@@redhat.com>
        Andrew Haley  <aph@@redhat.com>

        * elflink.h (elf_bfd_discard_info): Don't process eh frames if
        output is relocateable.
@
text
@d1943 1
a1943 1
	      unsigned char hvis, symvis, other;
d1952 6
d1959 1
a1959 1
	      h->other = other | (hvis > symvis ? hvis : symvis);
@


1.209.8.1
log
@Merge with mainline.
@
text
@d1943 1
a1943 1
	      unsigned char hvis, symvis, other, nvis;
a1951 6
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;
d1953 1
a1953 1
	      h->other = other | nvis;
@


1.208
log
@	* elflink.h (elf_link_read_relocs_from_section): Don't abort with
	wrong reloc sizes.
@
text
@d8332 4
a8335 3
      if (eh != NULL
	  && (eh->_raw_size == 0
	      || bfd_is_abs_section (eh->output_section)))
d8436 1
@


1.207
log
@	* elflink.h (elf_bfd_final_link): Apportion reloc counts to rel_hdr
	and rel_hdr2 when initially counting input relocs rather than after
	creating output reloc sections.
@
text
@d2582 4
a2585 1
    abort ();
@


1.206
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d4951 1
d4956 4
d4962 1
a4962 1
	    ++o->reloc_count;
d4968 1
d4980 1
a4980 1
		o->reloc_count += sec->reloc_count;
d4989 1
a4989 2
		  o->reloc_count
		    += (*bed->elf_backend_count_relocs) (sec, relocs);
d5032 50
a5113 57

  /* Figure out how many relocations we will have in each section.
     Just using RELOC_COUNT isn't good enough since that doesn't
     maintain a separate value for REL vs. RELA relocations.  */
  if (emit_relocs)
    for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
      for (o = sub->sections; o != NULL; o = o->next)
	{
	  asection *output_section;

	  if (! o->linker_mark)
	    {
	      /* This section was omitted from the link.  */
	      continue;
	    }

	  output_section = o->output_section;

	  if (output_section != NULL
	      && (o->flags & SEC_RELOC) != 0)
	    {
	      struct bfd_elf_section_data *esdi
		= elf_section_data (o);
	      struct bfd_elf_section_data *esdo
		= elf_section_data (output_section);
	      unsigned int *rel_count;
	      unsigned int *rel_count2;
	      bfd_size_type entsize;
	      bfd_size_type entsize2;

	      /* We must be careful to add the relocations from the
		 input section to the right output count.  */
	      entsize = esdi->rel_hdr.sh_entsize;
	      entsize2 = esdi->rel_hdr2 ? esdi->rel_hdr2->sh_entsize : 0;
	      BFD_ASSERT ((entsize == sizeof (Elf_External_Rel)
			   || entsize == sizeof (Elf_External_Rela))
			  && entsize2 != entsize
			  && (entsize2 == 0
			      || entsize2 == sizeof (Elf_External_Rel)
			      || entsize2 == sizeof (Elf_External_Rela)));
	      if (entsize == esdo->rel_hdr.sh_entsize)
		{
		  rel_count = &esdo->rel_count;
		  rel_count2 = &esdo->rel_count2;
		}
	      else
		{
		  rel_count = &esdo->rel_count2;
		  rel_count2 = &esdo->rel_count;
		}

	      *rel_count += NUM_SHDR_ENTRIES (& esdi->rel_hdr);
	      if (esdi->rel_hdr2)
		*rel_count2 += NUM_SHDR_ENTRIES (esdi->rel_hdr2);
	      output_section->flags |= SEC_RELOC;
	    }
	}
@


1.205
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Handle .symver x, x@@FOO.
ld/testsuite/
	* ld-shared/shared.exp: Run on s390*-*-linux* and x86_64-*-linux* too.
	xfail tests linking non-pic code into shared libs on x86_64-*-linux*.
	* ld-elfvsb/elfvsb.exp: Likewise.
	* ld-elfvers/vers.exp: Likewise.  Add vers24a, vers24b and vers24c
	tests.
	* ld-elfvers/vers3.ver: Allow VERS_2.0 to come before GLIBC_*
	version.
	* ld-elfvers/vers19.ver: Likewise.
	* ld-elfvers/vers24a.c: New test.
	* ld-elfvers/vers24b.c: New test.
	* ld-elfvers/vers24c.c: New test.
	* ld-elfvers/vers24.map: New test.
	* ld-elfvers/vers24.rd: New test.
	* lib/ld-lib.exp (run_ld_link_tests): Add optional 7th argument
	cflags.  If source files have .c extension, compile them first.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d6169 1
a6169 2
      && ! finfo->info->allow_shlib_undefined
      && ! finfo->info->shared
@


1.204
log
@	* elf-bfd.h (struct got_entry, struct plt_entry): Forward declare.
	(struct elf_link_hash_entry): Add "glist" and "plist" fields to
	"got" union, and declare as gotplt_union.  Use gotplt_uinion for
	"plt" field.
	(struct elf_link_hash_table): Make "init_refcount" a gotplt_union.
	Add "init_offset" field.
	(struct elf_obj_tdata <local_got>): Add "struct got_entry **" to union.
	(elf_local_got_ents): Declare.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust initialization of "got"
	and "plt".
	(_bfd_elf_link_hash_hide_symbol): Use "init_offset".
	(_bfd_elf_link_hash_table_init): Set "init_offset".
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set init_refcount
	from init_offset.
	(elf_adjust_dynamic_symbol): Set plt and got offsets using init_offset.

	* elf.c (bfd_elf_local_sym_name): Split out from..
	(group_signature): ..here.
	* elf-bfd.h (bfd_elf_local_sym_name): Declare.
@
text
@d1171 2
d2002 17
d2093 49
d2348 2
@


1.203
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d2905 1
a2905 1
  elf_hash_table (info)->init_refcount = -1;
d3912 3
d3917 2
a3918 2
      h->plt.offset = (bfd_vma) -1;
      h->got.offset = (bfd_vma) -1;
a3929 3
  if (! is_elf_hash_table (eif->info))
    return FALSE;

d3947 1
a3947 1
      h->plt.offset = (bfd_vma) -1;
@


1.202
log
@	* elflink.h (elf_link_output_extsym): Heed strip_discarded.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1307 1
a1307 1
	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d2237 1
a2237 1
		secdata->sec_info_type = ELF_INFO_TYPE_STABS;
d2259 1
a2259 1
	      secdata->sec_info_type = ELF_INFO_TYPE_MERGE;
d5919 1
a5919 1
      && elf_section_data (sec)->sec_info_type == ELF_INFO_TYPE_MERGE)
d6525 1
a6525 1
	      && elf_section_data (isec)->sec_info_type == ELF_INFO_TYPE_MERGE
d7018 1
a7018 1
      else switch (elf_section_data (o)->sec_info_type)
d8271 1
a8271 1
	      || elf_section_data (stab)->sec_info_type != ELF_INFO_TYPE_STABS))
d8377 1
a8377 1
  switch (elf_section_data (sec)->sec_info_type)
@


1.201
log
@Comment typo fixes.
@
text
@d6126 10
a6135 5
  else if (finfo->info->strip == strip_all
	   || (finfo->info->strip == strip_some
	       && bfd_hash_lookup (finfo->info->keep_hash,
				   h->root.root.string,
				   FALSE, FALSE) == NULL))
@


1.200
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d8226 1
a8226 1
   which is TRUE for all known assemblers.  */
@


1.199
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d28 1
a28 1
  boolean failed;
d33 1
a33 1
static boolean is_global_data_symbol_definition
d35 1
a35 1
static boolean elf_link_is_defined_archive_symbol
d37 1
a37 1
static boolean elf_link_add_object_symbols
d39 1
a39 1
static boolean elf_link_add_archive_symbols
d41 1
a41 1
static boolean elf_merge_symbol
d44 3
a46 3
	   struct elf_link_hash_entry **, boolean *, boolean *,
	   boolean *, boolean));
static boolean elf_add_default_symbol
d49 2
a50 2
	   boolean *, boolean, boolean));
static boolean elf_export_symbol
d52 1
a52 1
static boolean elf_finalize_dynstr
d54 1
a54 1
static boolean elf_fix_symbol_flags
d56 1
a56 1
static boolean elf_adjust_dynamic_symbol
d58 1
a58 1
static boolean elf_link_find_version_dependencies
d60 1
a60 1
static boolean elf_link_assign_sym_version
d62 1
a62 1
static boolean elf_collect_hash_codes
d64 1
a64 1
static boolean elf_link_read_relocs_from_section
d68 1
a68 1
static boolean elf_link_output_relocs
d70 1
a70 1
static boolean elf_link_size_reloc_section
d81 1
a81 1
static boolean elf_section_ignore_discarded_relocs
d87 1
a87 1
boolean
d100 1
a100 1
      return false;
d104 2
a105 2
/* Return true iff this is a non-common, definition of a non-function symbol.  */
static boolean
d113 1
a113 1
    return false;
d117 1
a117 1
    return false;
d121 1
a121 1
    return false;
d126 1
a126 1
    return false;
d138 1
a138 1
    return false;
d140 1
a140 1
  return true;
d146 1
a146 1
static boolean
d158 1
a158 1
  boolean result;
d162 1
a162 1
    return false;
d165 1
a165 1
    return false;
d172 1
a172 1
    return false;
d196 1
a196 1
    return false;
d202 1
a202 1
    return false;
d205 1
a205 1
  result = false;
d252 1
a252 1
static boolean
d258 2
a259 2
  boolean *defined = NULL;
  boolean *included = NULL;
d261 1
a261 1
  boolean loop;
d268 1
a268 1
	return true;
d270 1
a270 1
      return false;
d278 1
a278 1
    return true;
d280 4
a283 4
  amt *= sizeof (boolean);
  defined = (boolean *) bfd_zmalloc (amt);
  included = (boolean *) bfd_zmalloc (amt);
  if (defined == (boolean *) NULL || included == (boolean *) NULL)
d295 1
a295 1
      loop = false;
d311 1
a311 1
	      included[i] = true;
d316 1
a316 1
				    false, false, false);
d343 1
a343 1
					false, false, false);
d352 1
a352 1
					    copy, false, false, false);
d381 1
a381 1
		defined[i] = true;
d419 1
a419 1
	    loop = true;
d426 1
a426 1
	      included[mark] = true;
d443 1
a443 1
  return true;
d446 1
a446 1
  if (defined != (boolean *) NULL)
d448 1
a448 1
  if (included != (boolean *) NULL)
d450 1
a450 1
  return false;
d465 1
a465 1
static boolean
d475 4
a478 4
     boolean *override;
     boolean *type_change_ok;
     boolean *size_change_ok;
     boolean dt_needed;
d484 1
a484 1
  boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
d486 1
a486 1
  *override = false;
d492 1
a492 1
    h = elf_link_hash_lookup (elf_hash_table (info), name, true, false, false);
d495 1
a495 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, false, false));
d497 1
a497 1
    return false;
d503 1
a503 1
    return true;
d518 1
a518 1
      return true;
d553 1
a553 1
    return true;
d559 1
a559 1
    newdyn = true;
d561 1
a561 1
    newdyn = false;
d588 1
a588 1
	olddyn = false;
d597 1
a597 1
    newdef = false;
d599 1
a599 1
    newdef = true;
d604 1
a604 1
    olddef = false;
d606 1
a606 1
    olddef = true;
d638 1
a638 1
    newdyncommon = true;
d640 1
a640 1
    newdyncommon = false;
d650 1
a650 1
    olddyncommon = true;
d652 1
a652 1
    olddyncommon = false;
d662 1
a662 1
    *type_change_ok = true;
d669 1
a669 1
    *size_change_ok = true;
d688 1
a688 1
	return false;
d693 1
a693 1
      *size_change_ok = true;
d725 3
a727 3
      *override = true;
      newdef = false;
      newdyncommon = false;
d730 1
a730 1
      *size_change_ok = true;
d739 1
a739 1
	*type_change_ok = true;
d751 3
a753 3
      *override = true;
      newdef = false;
      newdyncommon = false;
d756 1
a756 1
      *size_change_ok = true;
d789 1
a789 1
      *size_change_ok = true;
d791 2
a792 2
      olddef = false;
      olddyncommon = false;
d798 1
a798 1
	*type_change_ok = true;
d831 1
a831 1
	return false;
d843 2
a844 2
      olddef = false;
      olddyncommon = false;
d849 2
a850 2
      *size_change_ok = true;
      *type_change_ok = true;
d895 1
a895 1
    *override = true;
d897 1
a897 1
  return true;
d906 1
a906 1
static boolean
d916 3
a918 3
     boolean *dynsym;
     boolean override;
     boolean dt_needed;
d920 2
a921 2
  boolean type_change_ok;
  boolean size_change_ok;
d926 2
a927 2
  boolean collect;
  boolean dynamic;
d938 1
a938 1
    return true;
d944 2
a945 2
      hi = elf_link_hash_lookup (elf_hash_table (info), name, true,
				 false, false);
d948 1
a948 1
	return true;
d954 1
a954 1
	    return true;
d965 1
a965 1
    return false;
d973 2
a974 2
  type_change_ok = false;
  size_change_ok = false;
d979 1
a979 1
    return false;
d986 2
a987 2
	      (bfd_vma) 0, name, false, collect, &bh)))
	return false;
d1025 1
a1025 1
		return false;
d1060 1
a1060 1
		*dynsym = true;
d1066 1
a1066 1
		*dynsym = true;
d1077 1
a1077 1
    return false;
d1082 2
a1083 2
  type_change_ok = false;
  size_change_ok = false;
d1088 1
a1088 1
    return false;
d1106 2
a1107 2
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
	return false;
d1133 1
a1133 1
		    *dynsym = true;
d1139 1
a1139 1
		    *dynsym = true;
d1145 1
a1145 1
  return true;
d1150 1
a1150 1
static boolean
d1155 7
a1161 7
  boolean (*add_symbol_hook) PARAMS ((bfd *, struct bfd_link_info *,
				      const Elf_Internal_Sym *,
				      const char **, flagword *,
				      asection **, bfd_vma *));
  boolean (*check_relocs) PARAMS ((bfd *, struct bfd_link_info *,
				   asection *, const Elf_Internal_Rela *));
  boolean collect;
d1167 1
a1167 1
  boolean dynamic;
d1175 1
a1175 1
  boolean dt_needed;
d1186 1
a1186 1
    dynamic = false;
d1189 1
a1189 1
      dynamic = true;
d1235 1
a1235 1
					    false, false, true);
d1262 1
a1262 1
		      false, collect, (struct bfd_link_hash_entry **) NULL)))
d1275 1
a1275 1
  dt_needed = false;
d1297 1
a1297 1
      boolean add_needed;
d1317 1
a1317 1
      add_needed = true;
d1325 1
a1325 1
		dt_needed = true;
d1327 1
a1327 1
	      add_needed = false;
d1485 1
a1485 1
	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, false);
d1514 1
a1514 1
		      return true;
d1609 3
a1611 3
      boolean definition;
      boolean size_change_ok, type_change_ok;
      boolean new_weakdef;
d1613 1
a1613 1
      boolean override;
d1615 1
a1615 1
      override = false;
d1711 1
a1711 1
	definition = false;
d1713 1
a1713 1
	definition = true;
d1715 1
a1715 1
      size_change_ok = false;
d1824 1
a1824 1
	    definition = false;
d1848 1
a1848 1
	      false, collect, (struct bfd_link_hash_entry **) sym_hash)))
d1857 1
a1857 1
      new_weakdef = false;
d1879 1
a1879 1
	  new_weakdef = true;
d1899 1
a1899 1
	  boolean dynsym;
d1960 1
a1960 1
	  dynsym = false;
d1974 1
a1974 1
		dynsym = true;
d1987 1
a1987 1
		dynsym = true;
d2020 1
a2020 1
		(*bed->elf_backend_hide_symbol) (info, h, true);
d2038 1
a2038 1
	      dt_needed = false;
d2041 1
a2041 1
					      elf_dt_soname (abfd), false);
d2183 1
a2183 1
	  boolean ok;
d2277 1
a2277 1
  return true;
d2286 1
a2286 1
  return false;
d2296 1
a2296 1
boolean
d2308 1
a2308 1
    return false;
d2311 1
a2311 1
    return true;
d2331 1
a2331 1
	return false;
d2341 1
a2341 1
	return false;
d2351 1
a2351 1
    return false;
d2357 1
a2357 1
    return false;
d2363 1
a2363 1
    return false;
d2369 1
a2369 1
    return false;
d2374 1
a2374 1
    return false;
d2381 1
a2381 1
	return false;
d2388 1
a2388 1
    return false;
d2401 2
a2402 2
	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
    return false;
d2409 1
a2409 1
    return false;
d2417 1
a2417 1
    return false;
d2424 1
a2424 1
    return false;
d2426 1
a2426 1
  elf_hash_table (info)->dynamic_sections_created = true;
d2428 1
a2428 1
  return true;
d2433 1
a2433 1
boolean
d2446 1
a2446 1
    return false;
d2456 1
a2456 1
    return false;
d2466 1
a2466 1
  return true;
d2476 1
a2476 1
   Returns false if something goes wrong.  */
d2478 1
a2478 1
static boolean
d2494 1
a2494 1
    return true;
d2498 1
a2498 1
    return false;
d2502 1
a2502 1
    return false;
d2524 1
a2524 1
  return true;
d2544 1
a2544 1
     boolean keep_memory;
d2620 1
a2620 1
boolean
d2625 1
a2625 1
     boolean provide;
d2630 1
a2630 1
    return true;
d2632 1
a2632 1
  h = elf_link_hash_lookup (elf_hash_table (info), name, true, true, false);
d2634 1
a2634 1
    return false;
d2665 1
a2665 1
	return false;
d2674 1
a2674 1
	    return false;
d2678 1
a2678 1
  return true;
d2693 1
a2693 1
  boolean failed;
d2708 1
a2708 1
  boolean failed;
d2874 1
a2874 1
boolean
d2898 1
a2898 1
    return true;
d2901 1
a2901 1
    return true;
d2912 1
a2912 1
    return false;
d2919 1
a2919 1
    return true;
d2922 1
a2922 1
    return false;
d2931 1
a2931 1
      boolean all_defined;
d2939 1
a2939 1
					     soname, true);
d2943 1
a2943 1
	    return false;
d2950 1
a2950 1
	    return false;
d2959 1
a2959 1
				      true);
d2967 1
a2967 1
	    return false;
d2975 1
a2975 1
				      filter_shlib, true);
d2978 1
a2978 1
	    return false;
d2990 1
a2990 1
					  *p, true);
d2994 1
a2994 1
		return false;
d3000 1
a3000 1
      eif.failed = false;
d3009 1
a3009 1
	    return false;
d3026 1
a3026 1
	      newlen = namelen + verlen + 3; 
d3030 1
a3030 1
		return false;
d3038 2
a3039 2
					   newname, false, false,
					   false);
d3048 2
a3049 2
					       newname, false, false,
					       false);
d3067 1
a3067 1
      asvinfo.failed = false;
d3073 1
a3073 1
	return false;
d3078 1
a3078 1
	  all_defined = true;
d3087 1
a3087 1
		  all_defined = false;
d3093 1
a3093 1
	      return false;
d3103 1
a3103 1
	return false;
d3113 2
a3114 2
				   info->init_function, false,
				   false, false)
d3121 1
a3121 1
	    return false;
d3125 2
a3126 2
				   info->fini_function, false,
				   false, false)
d3133 1
a3133 1
	    return false;
d3157 1
a3157 1
	      return false;
d3164 1
a3164 1
	    return false;
d3172 1
a3172 1
	    return false;
d3180 1
a3180 1
	    return false;
d3199 1
a3199 1
	    return false;
d3207 1
a3207 1
    return false;
d3263 1
a3263 1
	    return false;
d3292 1
a3292 1
					  name, false);
d3294 1
a3294 1
		return false;
d3321 1
a3321 1
		      (bfd_vma) 0, (const char *) NULL, false,
d3323 1
a3323 1
		return false;
d3331 1
a3331 1
		return false;
d3392 1
a3392 1
	    return false;
d3400 1
a3400 1
	    return false;
d3411 1
a3411 1
	    return false;
d3426 1
a3426 1
	sinfo.failed = false;
d3459 1
a3459 1
	      return false;
d3480 1
a3480 1
					    false);
d3482 1
a3482 1
		  return false;
d3499 1
a3499 1
						a->vna_nodename, false);
d3501 1
a3501 1
		      return false;
d3518 1
a3518 1
	      return false;
d3547 1
a3547 1
	    return false;
d3550 1
a3550 1
	    return false;
d3564 1
a3564 1
	return false;
d3590 1
a3590 1
	return false;
d3608 1
a3608 1
	  return false;
d3611 1
a3611 1
  return true;
d3617 2
a3618 2
static boolean elf_adjust_dynstr_offsets
PARAMS ((struct elf_link_hash_entry *, PTR));
d3620 1
a3620 1
static boolean
d3632 1
a3632 1
  return true;
d3638 1
a3638 1
static boolean
d3758 1
a3758 1
  return true;
d3767 1
a3767 1
static boolean
d3802 2
a3803 2
	      eif->failed = true;
	      return false;
d3856 1
a3856 1
      boolean force_local;
d3896 1
a3896 1
  return true;
d3903 1
a3903 1
static boolean
d3925 1
a3925 1
    return true;
d3928 1
a3928 1
    return false;
d3932 1
a3932 1
    return false;
d3948 1
a3948 1
      return true;
d3954 1
a3954 1
    return true;
d3999 1
a3999 1
	return false;
d4018 2
a4019 2
      eif->failed = true;
      return false;
d4022 1
a4022 1
  return true;
d4028 1
a4028 1
static boolean
d4037 1
a4037 1
    return true;
d4065 1
a4065 1
		    return true;
d4075 2
a4076 2
	      eif->failed = true;
	      return false;
d4081 1
a4081 1
  return true;
d4089 1
a4089 1
static boolean
d4108 1
a4108 1
    return true;
d4118 1
a4118 1
	  return true;
d4131 2
a4132 2
	  rinfo->failed = true;
	  return false;
d4159 1
a4159 1
  return true;
d4167 1
a4167 1
static boolean
d4186 1
a4186 1
  eif.failed = false;
d4191 2
a4192 2
	sinfo->failed = true;
      return false;
d4198 1
a4198 1
    return true;
d4205 1
a4205 1
      boolean hidden;
d4207 1
a4207 1
      hidden = true;
d4214 1
a4214 1
	  hidden = false;
d4223 1
a4223 1
	  return true;
d4238 1
a4238 1
		return false;
d4245 1
a4245 1
	      t->used = true;
d4267 1
a4267 1
			      (*bed->elf_backend_hide_symbol) (info, h, true);
d4290 1
a4290 1
	    return true;
d4297 2
a4298 2
	      sinfo->failed = true;
	      return false;
d4307 1
a4307 1
	  t->used = true;
d4329 2
a4330 2
	  sinfo->failed = true;
	  return false;
d4353 1
a4353 1
	      boolean matched;
d4355 1
a4355 1
	      matched = false;
d4361 1
a4361 1
			matched = true;
d4380 1
a4380 1
		(*bed->elf_backend_hide_symbol) (info, h, true);
d4410 1
a4410 1
	      (*bed->elf_backend_hide_symbol) (info, h, true);
d4415 1
a4415 1
  return true;
d4470 1
a4470 1
static boolean elf_link_output_sym
d4473 1
a4473 1
static boolean elf_link_flush_output_syms
d4475 1
a4475 1
static boolean elf_link_output_extsym
d4477 1
a4477 1
static boolean elf_link_sec_merge_syms
d4479 1
a4479 1
static boolean elf_link_check_versioned_symbol
d4481 1
a4481 1
static boolean elf_link_input_bfd
d4483 1
a4483 1
static boolean elf_reloc_link_order
d4491 2
a4492 2
  boolean failed;
  boolean localsyms;
d4499 1
a4499 1
static boolean
d4527 1
a4527 1
    return false;
d4540 1
a4540 1
	return false;
d4545 1
a4545 1
  return true;
d4785 1
a4785 1
boolean
d4790 2
a4791 2
  boolean dynamic;
  boolean emit_relocs;
d4810 1
a4810 1
  boolean merged;
d4816 1
a4816 1
    return false;
d4832 1
a4832 1
    return false;
d4878 1
a4878 1
  merged = false;
d4898 1
a4898 1
	      sec->linker_mark = true;
d4901 1
a4901 1
		merged = true;
d5089 1
a5089 1
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, true);
d5288 1
a5288 1
    sub->output_has_begun = false;
d5302 1
a5302 1
		  sub->output_has_begun = true;
d5325 1
a5325 1
  eoinfo.failed = false;
d5327 1
a5327 1
  eoinfo.localsyms = true;
d5331 1
a5331 1
    return false;
d5419 2
a5420 2
  eoinfo.failed = false;
  eoinfo.localsyms = false;
d5425 1
a5425 1
    return false;
d5431 2
a5432 3
      typedef boolean (*out_sym_func) PARAMS ((PTR, const char *,
					       Elf_Internal_Sym *,
					       asection *));
d5436 1
a5436 1
	return false;
d5441 1
a5441 1
    return false;
d5456 1
a5456 1
						       off, true);
d5460 1
a5460 1
	return false;
d5478 1
a5478 1
  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, true);
d5485 1
a5485 1
	return false;
d5562 1
a5562 1
					  false, false, true);
d5724 1
a5724 1
      boolean failed = false;
d5773 1
a5773 1
  elf_tdata (abfd)->linker = true;
d5775 1
a5775 1
  return true;
d5807 1
a5807 1
  return false;
d5812 1
a5812 1
static boolean
d5821 3
a5823 6

  boolean (*output_symbol_hook) PARAMS ((bfd *,
					 struct bfd_link_info *info,
					 const char *,
					 Elf_Internal_Sym *,
					 asection *));
d5831 1
a5831 1
	return false;
d5841 1
a5841 1
							    name, true, false);
d5843 1
a5843 1
	return false;
d5849 1
a5849 1
	return false;
d5863 1
a5863 1
	    return false;
d5874 1
a5874 1
  return true;
d5879 1
a5879 1
static boolean
d5894 1
a5894 1
	return false;
d5900 1
a5900 1
  return true;
d5906 1
a5906 1
static boolean
d5930 1
a5930 1
  return true;
d5937 1
a5937 1
static boolean
d5948 1
a5948 1
    return false;
d5994 1
a5994 1
	return false;
d6009 1
a6009 1
	  return false;
d6043 1
a6043 1
	      return true;
d6051 1
a6051 1
  return false;
d6061 1
a6061 1
static boolean
d6068 1
a6068 1
  boolean strip;
d6076 1
a6076 1
	return true;
d6083 1
a6083 1
	return true;
d6088 1
a6088 1
	return true;
d6108 1
a6108 1
	      (asection *) NULL, (bfd_vma) 0, true)))
d6110 2
a6111 2
	  eoinfo->failed = true;
	  return false;
d6120 1
a6120 1
    strip = false;
d6125 1
a6125 1
    strip = true;
d6130 2
a6131 2
				   false, false) == NULL))
    strip = true;
d6133 1
a6133 1
    strip = false;
d6140 1
a6140 1
    return true;
d6159 1
a6159 1
      return false;
d6183 2
a6184 2
		eoinfo->failed = true;
		return false;
d6226 1
a6226 1
      return true;
d6245 2
a6246 2
	  eoinfo->failed = true;
	  return false;
d6337 1
a6337 1
    return true;
d6343 2
a6344 2
      eoinfo->failed = true;
      return false;
d6347 1
a6347 1
  return true;
d6354 1
a6354 1
static boolean
d6395 1
a6395 1
      return false;
d6422 1
a6422 1
  return true;
d6430 1
a6430 1
static boolean
d6435 3
a6437 4
  boolean (*relocate_section) PARAMS ((bfd *, struct bfd_link_info *,
				       bfd *, asection *, bfd_byte *,
				       Elf_Internal_Rela *,
				       Elf_Internal_Sym *, asection **));
d6449 1
a6449 1
  boolean emit_relocs;
d6460 1
a6460 1
    return true;
d6487 1
a6487 1
	return false;
d6580 1
a6580 1
	return false;
d6584 1
a6584 1
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, false, false)
d6600 1
a6600 1
	return false;
d6624 1
a6624 1
	return false;
d6661 1
a6661 1
	    return false;
d6671 1
a6671 1
			      finfo->internal_relocs, false));
d6674 1
a6674 1
	    return false;
d6719 2
a6720 2
				      true)))
				return false;
d6740 1
a6740 1
			      boolean ok;
d6755 1
a6755 1
							 true);
d6759 1
a6759 1
				return false;
d6791 1
a6791 1
	    return false;
d6801 4
a6804 4
	      boolean (*reloc_emitter) PARAMS ((bfd *, asection *,
						Elf_Internal_Shdr *,
						Elf_Internal_Rela *));
	      boolean rela_normal;
d6842 1
a6842 1
			 being ordered.  */ 
d6911 1
a6911 1
			  return false;
d6936 1
a6936 1
			      return false;
d6946 1
a6946 1
			    return false;
d6953 1
a6953 1
			    return false;
d6972 1
a6972 1
			    return false;
d6993 1
a6993 1
		return false;
d7002 1
a7002 1
		    return false;
d7020 1
a7020 1
	    return false;
d7025 1
a7025 1
	    return false;
d7031 1
a7031 1
	      return false;
d7044 1
a7044 1
	      return false;
d7050 1
a7050 1
  return true;
d7058 1
a7058 1
static boolean
d7080 1
a7080 1
      return false;
d7104 1
a7104 1
					 false, false, true));
d7132 1
a7132 1
	    return false;
d7144 1
a7144 1
      boolean ok;
d7150 1
a7150 1
	return false;
d7172 1
a7172 1
	      return false;
d7180 1
a7180 1
	return false;
d7216 1
a7216 1
  return true;
d7221 1
a7221 1
boolean
d7243 1
a7243 1
	return true;
d7250 1
a7250 1
	    return false;
d7272 1
a7272 1
	    return false;
d7283 1
a7283 1
	return true;
d7304 1
a7304 1
    return false;
d7309 1
a7309 1
  linker_section_ptr->written_address_p = false;
d7344 1
a7344 1
  return true;
d7397 1
a7397 1
	      linker_section_ptr->written_address_p = true;
d7421 1
a7421 1
	  linker_section_ptr->written_address_p = true;
d7479 1
a7479 1
static boolean elf_gc_mark
d7485 1
a7485 1
static boolean elf_gc_sweep
d7487 2
a7488 2
	   boolean (*) (bfd *, struct bfd_link_info *, asection *,
			const Elf_Internal_Rela *)));
d7490 1
a7490 1
static boolean elf_gc_sweep_symbol
d7493 1
a7493 1
static boolean elf_gc_allocate_got_offsets
d7496 1
a7496 1
static boolean elf_gc_propagate_vtable_entries_used
d7499 1
a7499 1
static boolean elf_gc_smash_unused_vtentry_relocs
d7506 5
a7510 1
static boolean
d7514 1
a7514 4
     asection * (*gc_mark_hook) PARAMS ((asection *, struct bfd_link_info *,
					 Elf_Internal_Rela *,
					 struct elf_link_hash_entry *,
					 Elf_Internal_Sym *));
d7516 1
a7516 1
  boolean ret;
d7525 1
a7525 1
      return false;
d7528 1
a7528 1
  ret = true;
d7558 1
a7558 1
	    return false;
d7567 1
a7567 1
	  ret = false;
d7599 1
a7599 1
		  ret = false;
d7623 5
a7627 1
static boolean
d7630 1
a7630 2
     boolean (*gc_sweep_hook) PARAMS ((bfd *, struct bfd_link_info *,
				       asection *, const Elf_Internal_Rela *));
d7665 1
a7665 1
	      boolean r;
d7670 1
a7670 1
		return false;
d7678 1
a7678 1
		return false;
d7696 1
a7696 1
  return true;
d7701 1
a7701 1
static boolean
d7717 1
a7717 1
  return true;
d7723 1
a7723 1
static boolean
d7733 1
a7733 1
    return true;
d7737 1
a7737 1
    return true;
d7741 1
a7741 1
    return true;
d7756 1
a7756 1
      boolean *cu, *pu;
d7760 1
a7760 1
      cu[-1] = true;
d7772 1
a7772 1
		*cu = true;
d7779 1
a7779 1
  return true;
d7782 1
a7782 1
static boolean
d7799 1
a7799 1
    return true;
d7809 1
a7809 1
	      (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL, true));
d7811 1
a7811 1
    return *(boolean *) okp = false;
d7832 1
a7832 1
  return true;
d7837 1
a7837 1
boolean
d7842 1
a7842 1
  boolean ok = true;
d7851 1
a7851 1
    return true;
d7858 1
a7858 1
    return false;
d7865 1
a7865 1
    return false;
d7881 1
a7881 1
	      return false;
d7887 1
a7887 1
    return false;
d7889 1
a7889 1
  return true;
d7894 1
a7894 1
boolean
d7931 1
a7931 1
  return false;
d7946 1
a7946 1
  return true;
d7951 1
a7951 1
boolean
d7964 1
a7964 1
      boolean *ptr = h->vtable_entries_used;
d7983 1
a7983 1
      bytes = (size / file_align + 1) * sizeof (boolean);
d7994 1
a7994 1
			  * sizeof (boolean));
d8002 1
a8002 1
	return false;
d8009 1
a8009 1
  h->vtable_entries_used[addend / file_align] = true;
d8011 1
a8011 1
  return true;
d8017 1
a8017 1
boolean
d8070 1
a8070 1
  return true;
d8076 1
a8076 1
static boolean
d8094 1
a8094 1
  return true;
d8100 1
a8100 1
boolean
d8106 1
a8106 1
    return false;
d8115 1
a8115 1
static boolean
d8131 1
a8131 1
    return true;
d8156 1
a8156 1
  return true;
d8159 1
a8159 1
boolean
d8175 1
a8175 1
	  return false;
d8181 1
a8181 1
	return true;
d8197 1
a8197 1
	    return true;
d8199 1
a8199 1
	    return false;
d8215 1
a8215 1
		return true;
d8218 1
a8218 1
      return false;
d8220 1
a8220 1
  return false;
d8224 1
a8224 1
   Returns true if any section's size was changed.  */
d8226 1
a8226 1
   which is true for all known assemblers.  */
d8228 1
a8228 1
boolean
d8239 1
a8239 1
  boolean ret = false;
d8244 1
a8244 1
    return false;
d8296 1
a8296 1
	    return false;
d8316 1
a8316 1
		ret = true;
d8338 1
a8338 1
	    ret = true;
d8347 1
a8347 1
	ret = true;
d8361 1
a8361 1
    ret = true;
d8366 1
a8366 1
static boolean
d8376 1
a8376 1
      return true;
d8384 1
a8384 1
    return true;
d8386 1
a8386 1
  return false;
@


1.198
log
@	* elf-eh-frame.c (ENSURE_NO_RELOCS): Disregard R_*_NONE relocs.
	(_bfd_elf_discard_section_eh_frame): Don't discard duplicate CIEs
	on a relocatable link.  Comment typos.
	* elf.c (_bfd_elf_link_hash_newfunc): Assign elements of structure
	in the order they are declared.  Clear elf_hash_value too.
	(_bfd_elf_link_hash_table_init): Likewise assign in order.  Clear
	eh_info and tls_segment.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Keep reloc offsets
	sorted when discarding relocs by turning them into R_*_NONE.

	* libbfd.c (warn_deprecated): Comment spelling.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d2487 4
a2490 1
  bfd_size_type amt;
d2508 5
a2512 14
    {
      Elf_External_Rel *erel;
      Elf_External_Rel *erelend;
      Elf_Internal_Rela *irela;
      Elf_Internal_Rel *irel;

      erel = (Elf_External_Rel *) external_relocs;
      erelend = erel + NUM_SHDR_ENTRIES (shdr);
      irela = internal_relocs;
      amt = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
      irel = bfd_alloc (abfd, amt);
      for (; erel < erelend; erel++, irela += bed->s->int_rels_per_ext_rel)
	{
	  unsigned int i;
d2514 4
a2517 14
	  if (bed->s->swap_reloc_in)
	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, irel);
	  else
	    elf_swap_reloc_in (abfd, erel, irel);

	  for (i = 0; i < bed->s->int_rels_per_ext_rel; ++i)
	    {
	      irela[i].r_offset = irel[i].r_offset;
	      irela[i].r_info = irel[i].r_info;
	      irela[i].r_addend = 0;
	    }
	}
    }
  else
d2519 3
a2521 16
      Elf_External_Rela *erela;
      Elf_External_Rela *erelaend;
      Elf_Internal_Rela *irela;

      BFD_ASSERT (shdr->sh_entsize == sizeof (Elf_External_Rela));

      erela = (Elf_External_Rela *) external_relocs;
      erelaend = erela + NUM_SHDR_ENTRIES (shdr);
      irela = internal_relocs;
      for (; erela < erelaend; erela++, irela += bed->s->int_rels_per_ext_rel)
	{
	  if (bed->s->swap_reloca_in)
	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, irela);
	  else
	    elf_swap_reloca_in (abfd, erela, irela);
	}
d4562 3
a4564 3
  Elf_Internal_Rel *irel;
  Elf_Internal_Rela *irela;
  bfd_size_type amt = sizeof (Elf_Internal_Rel) * bed->s->int_rels_per_ext_rel;
d4566 1
a4566 2
  irel = (Elf_Internal_Rel *) bfd_zmalloc (amt);
  if (irel == NULL)
d4568 2
a4569 2
      (*_bfd_error_handler) (_("Error: out of memory"));
      abort ();
d4571 1
a4571 4

  amt = sizeof (Elf_Internal_Rela) * bed->s->int_rels_per_ext_rel;
  irela = (Elf_Internal_Rela *) bfd_zmalloc (amt);
  if (irela == NULL)
d4573 2
a4574 2
      (*_bfd_error_handler) (_("Error: out of memory"));
      abort ();
d4576 5
d4582 2
a4583 1
  for (i = 0; i < count; i++, rel_hash++)
d4585 3
d4593 5
a4597 43
      if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
	{
	  Elf_External_Rel *erel;
	  unsigned int j;

	  erel = (Elf_External_Rel *) rel_hdr->contents + i;
	  if (bed->s->swap_reloc_in)
	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, irel);
	  else
	    elf_swap_reloc_in (abfd, erel, irel);

	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	    irel[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
					 ELF_R_TYPE (irel[j].r_info));

	  if (bed->s->swap_reloc_out)
	    (*bed->s->swap_reloc_out) (abfd, irel, (bfd_byte *) erel);
	  else
	    elf_swap_reloc_out (abfd, irel, erel);
	}
      else
	{
	  Elf_External_Rela *erela;
	  unsigned int j;

	  BFD_ASSERT (rel_hdr->sh_entsize
		      == sizeof (Elf_External_Rela));

	  erela = (Elf_External_Rela *) rel_hdr->contents + i;
	  if (bed->s->swap_reloca_in)
	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, irela);
	  else
	    elf_swap_reloca_in (abfd, erela, irela);

	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	    irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
					  ELF_R_TYPE (irela[j].r_info));

	  if (bed->s->swap_reloca_out)
	    (*bed->s->swap_reloca_out) (abfd, irela, (bfd_byte *) erela);
	  else
	    elf_swap_reloca_out (abfd, irela, erela);
	}
a4598 3

  free (irel);
  free (irela);
d4605 2
a4606 6
  union
  {
    /* We use these as arrays of size int_rels_per_ext_rel.  */
    Elf_Internal_Rel rel[1];
    Elf_Internal_Rela rela[1];
  } u;
d4625 1
a4625 1
  if (ELF_R_SYM (a->u.rel->r_info) < ELF_R_SYM (b->u.rel->r_info))
d4627 1
a4627 1
  if (ELF_R_SYM (a->u.rel->r_info) > ELF_R_SYM (b->u.rel->r_info))
d4629 1
a4629 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4631 1
a4631 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
d4655 1
a4655 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4657 1
a4657 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
a4669 1
  boolean rel = false;
d4671 3
a4673 2
  size_t i, j, ret;
  struct elf_link_sort_rela *rela;
d4676 2
d4685 3
a4687 2
      rel = true;
      count = reldyn->_raw_size / sizeof (Elf_External_Rel);
d4690 6
a4695 1
    count = reldyn->_raw_size / sizeof (Elf_External_Rela);
d4707 4
a4710 18
  /* We waste some memory here when N = i2e is greater than 1, since
     we allocate space for N * sizeof (*rela) where sizeof (*rela) +
     (N - 1) * sizeof (Elf_Internal_Rel/Rela) would do.  Also, we use
     rela[k] only when k is a multiple of N, and then we index the
     array within the union, such that rela[k].u.rel[i], i < N, is the
     (i+1)th internal relocation corresponding to the (k/N)th external
     relocation.  This is done such that the relocation swap-in and
     swap-out functions can gen pointers to arrays of internal
     relocations that form a single external relocation.

     If C permitted arrays of structures with dynamic sizes, we could
     do better, but trying to avoid wasting space at the end of the
     chunk from rela[k] to rela[k+N-1] would require us to allocate a
     separate array of pointers and since most ports have N == 1, this
     would be more wasteful.  */
  rela = (struct elf_link_sort_rela *) bfd_zmalloc
    (sizeof (*rela) * count * i2e);
  if (rela == NULL)
d4723 6
a4728 1
	if (rel)
d4730 7
a4736 2
	    Elf_External_Rel *erel, *erelend;
	    struct elf_link_sort_rela *s;
d4738 1
a4738 10
	    erel = (Elf_External_Rel *) o->contents;
	    erelend = (Elf_External_Rel *) (o->contents + o->_raw_size);
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
	      {
		if (bed->s->swap_reloc_in)
		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel,
					    s->u.rel);
		else
		  elf_swap_reloc_in (abfd, erel, s->u.rel);
d4740 8
a4747 7
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
	      }
	  }
	else
	  {
	    Elf_External_Rela *erela, *erelaend;
	    struct elf_link_sort_rela *s;
d4749 8
a4756 10
	    erela = (Elf_External_Rela *) o->contents;
	    erelaend = (Elf_External_Rela *) (o->contents + o->_raw_size);
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
	      {
		if (bed->s->swap_reloca_in)
		  (*bed->s->swap_reloca_in) (dynobj, (bfd_byte *) erela,
					     s->u.rela);
		else
		  elf_swap_reloca_in (dynobj, erela, s->u.rela);
d4758 1
a4758 19
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
	      }
	  }
      }

  qsort (rela, (size_t) count, sizeof (*rela) * i2e, elf_link_sort_cmp1);
  for (ret = 0; ret < count * i2e && rela[ret].type == reloc_class_relative;
       ret += i2e)
    ;
  for (i = ret, j = ret; i < count * i2e; i += i2e)
    {
      if (ELF_R_SYM (rela[i].u.rel->r_info)
	  != ELF_R_SYM (rela[j].u.rel->r_info))
	j = i;
      rela[i].offset = rela[j].u.rel->r_offset;
    }
  ret /= i2e;
  qsort (rela + ret, (size_t) count - ret,
	 sizeof (*rela) * i2e, elf_link_sort_cmp2);
d4765 1
a4765 4
	if (rel)
	  {
	    Elf_External_Rel *erel, *erelend;
	    struct elf_link_sort_rela *s;
d4767 4
a4770 13
	    erel = (Elf_External_Rel *) o->contents;
	    erelend = (Elf_External_Rel *) (o->contents + o->_raw_size);
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
	      {
		if (bed->s->swap_reloc_out)
		  (*bed->s->swap_reloc_out) (abfd, s->u.rel,
					     (bfd_byte *) erel);
		else
		  elf_swap_reloc_out (abfd, s->u.rel, erel);
	      }
	  }
	else
d4772 4
a4775 14
	    Elf_External_Rela *erela, *erelaend;
	    struct elf_link_sort_rela *s;

	    erela = (Elf_External_Rela *) o->contents;
	    erelaend = (Elf_External_Rela *) (o->contents + o->_raw_size);
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
	      {
		if (bed->s->swap_reloca_out)
		  (*bed->s->swap_reloca_out) (dynobj, s->u.rela,
					      (bfd_byte *) erela);
		else
		  elf_swap_reloca_out (dynobj, s->u.rela, erela);
	      }
a4778 1
  free (rela);
d6368 1
d6373 1
a6373 1
  bfd_size_type amt;
d6403 9
d6415 1
a6415 35

  if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
    {
      Elf_External_Rel *erel;
      Elf_Internal_Rel *irel;

      amt = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
      irel = (Elf_Internal_Rel *) bfd_zmalloc (amt);
      if (irel == NULL)
	{
	  (*_bfd_error_handler) (_("Error: out of memory"));
	  abort ();
	}

      erel = ((Elf_External_Rel *) output_rel_hdr->contents + *rel_countp);
      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erel++)
	{
	  unsigned int i;

	  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	    {
	      irel[i].r_offset = irela[i].r_offset;
	      irel[i].r_info = irela[i].r_info;
	      BFD_ASSERT (irela[i].r_addend == 0);
	    }

	  if (bed->s->swap_reloc_out)
	    (*bed->s->swap_reloc_out) (output_bfd, irel, (PTR) erel);
	  else
	    elf_swap_reloc_out (output_bfd, irel, erel);
	}

      free (irel);
    }
  else
d6417 3
a6419 10
      Elf_External_Rela *erela;

      BFD_ASSERT (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela));

      erela = ((Elf_External_Rela *) output_rel_hdr->contents + *rel_countp);
      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erela++)
	if (bed->s->swap_reloca_out)
	  (*bed->s->swap_reloca_out) (output_bfd, irela, (PTR) erela);
	else
	  elf_swap_reloca_out (output_bfd, irela, erela);
d7077 3
d7195 8
d7204 1
a7204 1

d7207 3
a7209 23
      bfd_size_type size;
      Elf_Internal_Rel *irel;
      Elf_External_Rel *erel;
      unsigned int i;

      size = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
      irel = (Elf_Internal_Rel *) bfd_zmalloc (size);
      if (irel == NULL)
	return false;

      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	irel[i].r_offset = offset;
      irel[0].r_info = ELF_R_INFO (indx, howto->type);

      erel = ((Elf_External_Rel *) rel_hdr->contents
	      + elf_section_data (output_section)->rel_count);

      if (bed->s->swap_reloc_out)
	(*bed->s->swap_reloc_out) (output_bfd, irel, (bfd_byte *) erel);
      else
	elf_swap_reloc_out (output_bfd, irel, erel);

      free (irel);
d7213 4
a7216 22
      bfd_size_type size;
      Elf_Internal_Rela *irela;
      Elf_External_Rela *erela;
      unsigned int i;

      size = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      irela = (Elf_Internal_Rela *) bfd_zmalloc (size);
      if (irela == NULL)
	return false;

      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	irela[i].r_offset = offset;
      irela[0].r_info = ELF_R_INFO (indx, howto->type);
      irela[0].r_addend = addend;

      erela = ((Elf_External_Rela *) rel_hdr->contents
	       + elf_section_data (output_section)->rel_count);

      if (bed->s->swap_reloca_out)
	(*bed->s->swap_reloca_out) (output_bfd, irela, (bfd_byte *) erela);
      else
	elf_swap_reloca_out (output_bfd, irela, erela);
d7433 2
a7434 2
	      Elf_Internal_Rela *outrel;
	      Elf_External_Rela *erel;
a7436 9
	      bfd_size_type amt;

	      amt = sizeof (Elf_Internal_Rela) * bed->s->int_rels_per_ext_rel;
	      outrel = (Elf_Internal_Rela *) bfd_zmalloc (amt);
	      if (outrel == NULL)
		{
		  (*_bfd_error_handler) (_("Error: out of memory"));
		  return 0;
		}
d7450 7
a7456 3
		outrel[i].r_offset = (lsect->section->output_section->vma
				      + lsect->section->output_offset
				      + linker_section_ptr->offset);
d7458 3
a7460 3
	      outrel[0].r_addend = 0;
	      erel = (Elf_External_Rela *) lsect->section->contents;
	      erel += elf_section_data (lsect->section)->rel_count;
a7461 3
	      ++elf_section_data (lsect->section)->rel_count;

	      free (outrel);
@


1.197
log
@        * elflink.h (elf_link_add_object_symbols): Don't overwrite the
        arch's st_other bits when merging visibilities.
        (elf_link_output_extsym): Tidy clearing of visibility field.
@
text
@d6949 1
d6970 3
d6990 8
a6997 2
		      /* This is a reloc for a deleted entry or somesuch.  */
		      memset (irela, 0, sizeof (*irela));
d7007 2
d7010 1
a7010 2

		  if (r_symndx == 0)
@


1.196
log
@	* elflink.h (elf_link_add_object_symbols): Optimize stabs for
	relocatable link too.
	(elf_link_input_bfd): When emitting relocs, adjust offsets for
	eh_frame and stab sections.  Zap deleted relocs.
	(elf_reloc_symbol_deleted_p): Return true for zero r_symndx.
	(elf_bfd_discard_info): Run for relocatable link too.
	* elf64-ppc.c (ppc64_elf_edit_opd): Rename from edit_opd.  Make global.
	Handle ld -r case.
	(ppc64_elf_size_dynamic_sections): Don't call edit_opd from here.
	* elf64-ppc.h (ppc64_elf_edit_opd): Declare.
@
text
@d1941 6
d1948 2
a1949 5
	      unsigned char hvis   = ELF_ST_VISIBILITY (h->other);
	      unsigned char symvis = ELF_ST_VISIBILITY (isym->st_other);

	      if (symvis && (hvis > symvis || hvis == 0))
		h->other = isym->st_other;
d1951 1
a1951 6
	      /* If neither has visibility, use the st_other of the
		 definition.  This is an arbitrary choice, since the
		 other bits have no general meaning.  */
	      if (!symvis && !hvis
		  && (definition || h->other == 0))
		h->other = isym->st_other;
d6390 1
a6390 2
  /* If a symbol is not defined locally, we clear the visibility
     field.  */
d6393 1
a6393 1
    sym.st_other ^= ELF_ST_VISIBILITY (sym.st_other);
@


1.195
log
@	* elf-bfd.h (struct cie_header): Move from elf_eh-frame.c.
	(struct cie, struct eh_cie_fde, struct eh_frame_sec_info): Likewise.
	(struct eh_frame_array_ent, struct eh_frame_hdr_info): Likewise.
	(enum elf_link_info_type): Remove ELF_INFO_TYPE_EH_FRAME_HDR.
	(struct eh_frame_hdr_info): Add "hdr_sec", remove "split".
	(struct elf_link_hash_table): Add eh_info.
	(struct elf_obj_tdata): Change eh_frame_hdr to an asection *.
	(_bfd_elf_discard_section_eh_frame): Update prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Remove "ehdrsec"
	param.  Get "hdr_info" from link hash table.
	(_bfd_elf_discard_section_eh_frame_hdr): Remove "sec" param.  Get
	header section from link hash table.  Save header section to elf_tdata.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Remove local "sec".  Use
	header section from link hash table.  Don't alloc hdr_info.  Clear
	hdr_sec instead of setting "strip".
	(_bfd_elf_eh_frame_section_offset): Formatting.
	(_bfd_elf_write_section_eh_frame): Remove "ehdrsec", add "info" param.
	Get header section from link hash table.
	(_bfd_elf_write_section_eh_frame_hdr): Remove "sec", add "info" param.
	Get header section from link hash table.
	* elf.c (map_sections_to_segments): Use cached eh_frame_hdr.
	(get_program_header_size): Likewise.
	(_bfd_elf_section_offset): Formatting.
	* elflink.h (elf_link_create_dynamic_sections): Stash eh frame header
	section pointer in link hash table.
	(elf_bfd_final_link): Adjust _bfd_elf_write_section_eh_frame_hdr
	and _bfd_elf_write_section_eh_frame calls.  Update comment about
	eh_frame entries.
	(elf_bfd_discard_info): Adjust _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr calls.  Remove "ehdr".

	* po/SRC-POTFILES.in: Regenerate.
@
text
@d2211 2
a2212 2
  /* If this is a non-traditional, non-relocateable link, try to
     optimize the handling of the .stab/.stabstr sections.  */
a2213 1
      && ! info->relocateable
d6984 10
d8346 1
a8346 1
      unsigned long r_symndx = ELF_R_SYM (rcookie->rel->r_info);
d8354 4
d8416 1
a8416 2
  if (info->relocateable
      || info->traditional_format
@


1.194
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't zero
	relocs for discarded FDEs.  Remove dead code.
	(_bfd_elf_write_section_eh_frame_hdr): Remove dead code.
	* elflink.h (elf_bfd_discard_info): Don't save edited relocs.
	Tidy conditions under which stabs are edited.  Formatting.
	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from discarded relocs.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Add reloc output
	section adjustments after testing magic values.
@
text
@d2345 1
d5858 1
a5858 1
  if (info->eh_frame_hdr && elf_hash_table (info)->dynobj)
d5860 2
a5861 9
      o = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
				   ".eh_frame_hdr");
      if (o
	  && (elf_section_data (o)->sec_info_type
	      == ELF_INFO_TYPE_EH_FRAME_HDR))
	{
	  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, o))
	    goto error_return;
	}
d6836 1
a6836 6
	     link-once sections.  We should really complain if
	     anything in the final link tries to use it, but
	     DWARF-based exception handling might have an entry in
	     .eh_frame to describe a routine in the linkonce section,
	     and it turns out to be hard to remove the .eh_frame
	     entry too.  FIXME.  */
d7158 2
a7159 2
	  if (! (_bfd_write_merged_section
		 (output_bfd, o, elf_section_data (o)->sec_info)))
d7164 2
a7165 7
	    asection *ehdrsec;

	    ehdrsec
	      = bfd_get_section_by_name (elf_hash_table (finfo->info)->dynobj,
					 ".eh_frame_hdr");
	    if (! (_bfd_elf_write_section_eh_frame (output_bfd, o, ehdrsec,
						    contents)))
d8396 1
a8396 1
  asection *stab, *eh, *ehdr;
a8408 5
  ehdr = NULL;
  if (elf_hash_table (info)->dynobj != NULL)
    ehdr = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
				    ".eh_frame_hdr");

d8419 5
a8423 9
      eh = NULL;
      if (ehdr != NULL)
	{
	  eh = bfd_get_section_by_name (abfd, ".eh_frame");
	  if (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section)))
	    eh = NULL;
	}
d8498 1
a8498 1
	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh, ehdr,
d8522 2
a8523 2
  if (ehdr != NULL
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info, ehdr))
@


1.193
log
@	* elflink.h (struct elf_final_link_info): Add shndxbuf_size.
	(elf_bfd_final_link): Don't bother zeroing symtab_hdr fields.
	Set up a larger symshndxbuf, and write it out.  Free it on
	exit rather than freeing symbuf twice.  Correct section index
	on output section symbol loop.
	(elf_link_output_sym): Accumulate symbol extension section
	indices, reallocating symshndxbuf rather than writing it out.
	(elf_link_flush_output_syms): Don't flush symshndxbuf.
	* elf.c (assign_section_numbers): Init i_shdrp to all zero.
	Use bfd_zalloc to clear i_shdrp[0] too.
@
text
@d8416 1
a8417 1
  boolean strip = info->strip == strip_all || info->strip == strip_debugger;
d8441 1
a8441 1
      if (ehdr)
d8444 3
a8446 2
	  if (eh && (eh->_raw_size == 0
		     || bfd_is_abs_section (eh->output_section)))
d8450 10
a8459 12
      stab = NULL;
      if (!strip)
	{
	  stab = bfd_get_section_by_name (abfd, ".stab");
	  if (stab && (stab->_raw_size == 0
		       || bfd_is_abs_section (stab->output_section)))
	    stab = NULL;
	}
      if ((! stab
	   || elf_section_data(stab)->sec_info_type != ELF_INFO_TYPE_STABS)
	  && ! eh
	  && (strip || ! bed->elf_backend_discard_info))
d8468 1
a8468 2
	  cookie.locsymcount =
	    symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d8487 1
a8487 1
      if (stab)
d8489 7
a8495 4
	  cookie.rels = (NAME(_bfd_elf,link_read_relocs)
			 (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			  info->keep_memory));
	  if (cookie.rels)
d8498 2
a8499 2
	      cookie.relend =
		cookie.rels + stab->reloc_count * bed->s->int_rels_per_ext_rel;
d8510 1
a8510 1
      if (eh)
d8513 2
a8514 3
	  cookie.rel = NULL;
	  cookie.relend = NULL;
	  if (eh->reloc_count)
d8518 5
a8522 6
	  if (cookie.rels)
	    {
	      cookie.rel = cookie.rels;
	      cookie.relend =
		cookie.rels + eh->reloc_count * bed->s->int_rels_per_ext_rel;
	    }
d8526 4
a8529 7
	    {
	      /* Relocs have been edited.  Ensure edited version is
		 used later in relocate_section.  */
	      elf_section_data (eh)->relocs = cookie.rels;
	      ret = true;
	    }
	  if (cookie.rels && elf_section_data (eh)->relocs != cookie.rels)
d8533 3
a8535 5
      if (bed->elf_backend_discard_info)
	{
	  if (bed->elf_backend_discard_info (abfd, &cookie, info))
	    ret = true;
	}
d8547 2
a8548 1
  if (ehdr && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info, ehdr))
d8550 1
@


1.192
log
@* elflink.h (struct elf_link_sort_rela): Turn rel and rela
into arrays.
(elf_link_sort_cmp1, elf_link_sort_cmp2): Adjust.
(elf_link_sort_relocs): Likewise.  Take int_rels_per_ext_rel
into account.
* elfxx-mips.c (mips_elf_create_dynamic_relocation): Compose
R_MIPS_REL32 with R_MIPS64 if ABI_64_P.
@
text
@d4497 2
d4924 1
d4978 1
d5199 1
a5199 3
  symtab_hdr->sh_flags = 0;
  symtab_hdr->sh_addr = 0;
  symtab_hdr->sh_size = 0;
d5226 3
a5228 1
      amt = finfo.symbuf_size;
d5230 1
a5230 1
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
d5290 1
a5290 1
	  if (i == SHN_LORESERVE)
d5565 18
d5891 1
a5891 1
    free (finfo.symbuf);
d5925 1
a5925 1
    free (finfo.symbuf);
d5984 15
a5998 1
    destshndx += finfo->symbuf_count;
d6000 2
a6001 3
  ++finfo->symbuf_count;

  ++ bfd_get_symcount (finfo->output_bfd);
a6025 14

      if (finfo->symshndxbuf != NULL)
	{
	  hdr = &elf_tdata (finfo->output_bfd)->symtab_shndx_hdr;
	  pos = hdr->sh_offset + hdr->sh_size;
	  amt = finfo->symbuf_count * sizeof (Elf_External_Sym_Shndx);
	  if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
	      || (bfd_bwrite ((PTR) finfo->symshndxbuf, amt, finfo->output_bfd)
		  != amt))
	    return false;

	  hdr->sh_size += amt;
	}

@


1.191
log
@2002-10-19  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Correctly handle
	DT_RPATH and DT_RUNPATH.
:VS: ----------------------------------------------------------------------
@
text
@d4672 3
a4674 2
    Elf_Internal_Rel rel;
    Elf_Internal_Rela rela;
d4694 1
a4694 1
  if (ELF_R_SYM (a->u.rel.r_info) < ELF_R_SYM (b->u.rel.r_info))
d4696 1
a4696 1
  if (ELF_R_SYM (a->u.rel.r_info) > ELF_R_SYM (b->u.rel.r_info))
d4698 1
a4698 1
  if (a->u.rel.r_offset < b->u.rel.r_offset)
d4700 1
a4700 1
  if (a->u.rel.r_offset > b->u.rel.r_offset)
d4724 1
a4724 1
  if (a->u.rel.r_offset < b->u.rel.r_offset)
d4726 1
a4726 1
  if (a->u.rel.r_offset > b->u.rel.r_offset)
d4744 1
d4768 17
a4784 1
  rela = (struct elf_link_sort_rela *) bfd_zmalloc (sizeof (*rela) * count);
d4805 2
a4806 2
	    s = rela + o->output_offset / sizeof (Elf_External_Rel);
	    for (; erel < erelend; erel++, s++)
d4809 2
a4810 1
		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, &s->u.rel);
d4812 1
a4812 1
		  elf_swap_reloc_in (abfd, erel, &s->u.rel);
d4814 1
a4814 1
		s->type = (*bed->elf_backend_reloc_type_class) (&s->u.rela);
d4824 2
a4825 2
	    s = rela + o->output_offset / sizeof (Elf_External_Rela);
	    for (; erela < erelaend; erela++, s++)
d4829 1
a4829 1
					     &s->u.rela);
d4831 1
a4831 1
		  elf_swap_reloca_in (dynobj, erela, &s->u.rela);
d4833 1
a4833 1
		s->type = (*bed->elf_backend_reloc_type_class) (&s->u.rela);
d4838 3
a4840 2
  qsort (rela, (size_t) count, sizeof (*rela), elf_link_sort_cmp1);
  for (ret = 0; ret < count && rela[ret].type == reloc_class_relative; ret++)
d4842 1
a4842 1
  for (i = ret, j = ret; i < count; i++)
d4844 2
a4845 1
      if (ELF_R_SYM (rela[i].u.rel.r_info) != ELF_R_SYM (rela[j].u.rel.r_info))
d4847 1
a4847 1
      rela[i].offset = rela[j].u.rel.r_offset;
d4849 3
a4851 1
  qsort (rela + ret, (size_t) count - ret, sizeof (*rela), elf_link_sort_cmp2);
d4865 2
a4866 2
	    s = rela + o->output_offset / sizeof (Elf_External_Rel);
	    for (; erel < erelend; erel++, s++)
d4869 1
a4869 1
		  (*bed->s->swap_reloc_out) (abfd, &s->u.rel,
d4872 1
a4872 1
		  elf_swap_reloc_out (abfd, &s->u.rel, erel);
d4882 2
a4883 2
	    s = rela + o->output_offset / sizeof (Elf_External_Rela);
	    for (; erela < erelaend; erela++, s++)
d4886 1
a4886 1
		  (*bed->s->swap_reloca_out) (dynobj, &s->u.rela,
d4889 1
a4889 1
		  elf_swap_reloca_out (dynobj, &s->u.rela, erela);
@


1.190
log
@	* elflink.h (elf_link_add_object_symbols): Error out on dynamic objects
	loaded with --just-symbols.
@
text
@d1301 1
a1337 2
	  int rpath;
	  int runpath;
a1353 2
	  rpath = 0;
	  runpath = 0;
a1396 7
		  /* When we see DT_RPATH before DT_RUNPATH, we have
		     to clear runpath.  Do _NOT_ bfd_release, as that
		     frees all more recently bfd_alloc'd blocks as
		     well.  */
		  if (rpath && hash_table->runpath)
		    hash_table->runpath = NULL;

d1410 1
a1410 1
		  for (pn = & hash_table->runpath;
a1414 2
		  runpath = 1;
		  rpath = 0;
d1440 1
a1440 1
		  for (pn = & hash_table->runpath;
a1444 1
		  rpath = 1;
d1449 15
@


1.189
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d1302 7
@


1.188
log
@	* elflink.h (elf_link_input_bfd): Remove BFD_VERSION_DATE dependent
	code.
@
text
@d924 1
d983 1
d986 1
a986 2
	      (bfd_vma) 0, name, false, collect,
	      (struct bfd_link_hash_entry **) &hi)))
d988 1
d1103 1
d1106 1
a1106 2
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false,
	      collect, (struct bfd_link_hash_entry **) &hi)))
d1108 1
d2298 1
d2391 1
a2391 1
  h = NULL;
d2394 1
a2394 2
	  (const char *) NULL, false, get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
d2396 1
d3333 1
d3340 1
a3340 1
	      h = NULL;
d3344 1
a3344 2
		      get_elf_backend_data (dynobj)->collect,
		      (struct bfd_link_hash_entry **) &h)))
d3346 1
@


1.187
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.
@
text
@a6817 1
#if BFD_VERSION_DATE < 20031005
a6819 6
#if BFD_VERSION_DATE > 20021005
			      (*finfo->info->callbacks->warning)
				(finfo->info,
				 _("warning: relocation against removed section; zeroing"),
				 NULL, input_bfd, o, rel->r_offset);
#endif
a6823 1
#endif
a6838 1
#if BFD_VERSION_DATE < 20031005
a6841 6
#if BFD_VERSION_DATE > 20021005
			      (*finfo->info->callbacks->warning)
				(finfo->info,
				 _("warning: relocation against removed section"),
				 NULL, input_bfd, o, rel->r_offset);
#endif
a6847 1
#endif
@


1.187.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a923 1
  struct bfd_link_hash_entry *bh;
a981 1
      bh = &hi->root;
d984 2
a985 1
	      (bfd_vma) 0, name, false, collect, &bh)))
a986 1
      hi = (struct elf_link_hash_entry *) bh;
a1100 1
      bh = &hi->root;
d1103 2
a1104 1
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
a1105 1
      hi = (struct elf_link_hash_entry *) bh;
a1297 8
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;
d1327 2
d1345 2
d1390 7
d1410 1
a1410 1
		  for (pn = & runpath;
d1415 2
d1442 1
a1442 1
		  for (pn = & rpath;
d1447 1
a1453 15
      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

a2294 1
  struct bfd_link_hash_entry *bh;
d2387 1
a2387 1
  bh = NULL;
d2390 2
a2391 1
	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
a2392 1
  h = (struct elf_link_hash_entry *) bh;
a3328 1
	      struct bfd_link_hash_entry *bh;
d3335 1
a3335 1
	      bh = NULL;
d3339 2
a3340 1
		      get_elf_backend_data (dynobj)->collect, &bh)))
a3341 1
	      h = (struct elf_link_hash_entry *) bh;
d4658 2
a4659 3
    /* We use these as arrays of size int_rels_per_ext_rel.  */
    Elf_Internal_Rel rel[1];
    Elf_Internal_Rela rela[1];
d4679 1
a4679 1
  if (ELF_R_SYM (a->u.rel->r_info) < ELF_R_SYM (b->u.rel->r_info))
d4681 1
a4681 1
  if (ELF_R_SYM (a->u.rel->r_info) > ELF_R_SYM (b->u.rel->r_info))
d4683 1
a4683 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4685 1
a4685 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
d4709 1
a4709 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4711 1
a4711 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
a4728 1
  int i2e = bed->s->int_rels_per_ext_rel;
d4752 1
a4752 17
  /* We waste some memory here when N = i2e is greater than 1, since
     we allocate space for N * sizeof (*rela) where sizeof (*rela) +
     (N - 1) * sizeof (Elf_Internal_Rel/Rela) would do.  Also, we use
     rela[k] only when k is a multiple of N, and then we index the
     array within the union, such that rela[k].u.rel[i], i < N, is the
     (i+1)th internal relocation corresponding to the (k/N)th external
     relocation.  This is done such that the relocation swap-in and
     swap-out functions can gen pointers to arrays of internal
     relocations that form a single external relocation.

     If C permitted arrays of structures with dynamic sizes, we could
     do better, but trying to avoid wasting space at the end of the
     chunk from rela[k] to rela[k+N-1] would require us to allocate a
     separate array of pointers and since most ports have N == 1, this
     would be more wasteful.  */
  rela = (struct elf_link_sort_rela *) bfd_zmalloc
    (sizeof (*rela) * count * i2e);
d4773 2
a4774 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4777 1
a4777 2
		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel,
					    s->u.rel);
d4779 1
a4779 1
		  elf_swap_reloc_in (abfd, erel, s->u.rel);
d4781 1
a4781 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4791 2
a4792 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4796 1
a4796 1
					     s->u.rela);
d4798 1
a4798 1
		  elf_swap_reloca_in (dynobj, erela, s->u.rela);
d4800 1
a4800 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4805 2
a4806 3
  qsort (rela, (size_t) count, sizeof (*rela) * i2e, elf_link_sort_cmp1);
  for (ret = 0; ret < count * i2e && rela[ret].type == reloc_class_relative;
       ret += i2e)
d4808 1
a4808 1
  for (i = ret, j = ret; i < count * i2e; i += i2e)
d4810 1
a4810 2
      if (ELF_R_SYM (rela[i].u.rel->r_info)
	  != ELF_R_SYM (rela[j].u.rel->r_info))
d4812 1
a4812 1
      rela[i].offset = rela[j].u.rel->r_offset;
d4814 1
a4814 3
  ret /= i2e;
  qsort (rela + ret, (size_t) count - ret,
	 sizeof (*rela) * i2e, elf_link_sort_cmp2);
d4828 2
a4829 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4832 1
a4832 1
		  (*bed->s->swap_reloc_out) (abfd, s->u.rel,
d4835 1
a4835 1
		  elf_swap_reloc_out (abfd, s->u.rel, erel);
d4845 2
a4846 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4849 1
a4849 1
		  (*bed->s->swap_reloca_out) (dynobj, s->u.rela,
d4852 1
a4852 1
		  elf_swap_reloca_out (dynobj, s->u.rela, erela);
d6818 1
d6821 6
d6831 1
d6847 1
d6851 6
d6863 1
@


1.187.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 2
a24 1
#include "safe-ctype.h"
d26 57
a82 7
static bfd_boolean elf_link_add_object_symbols (bfd *, struct bfd_link_info *);
static bfd_boolean elf_link_add_archive_symbols (bfd *,
						 struct bfd_link_info *);
static bfd_boolean elf_finalize_dynstr (bfd *, struct bfd_link_info *);
static bfd_boolean elf_collect_hash_codes (struct elf_link_hash_entry *,
					   void *);
static bfd_boolean elf_section_ignore_discarded_relocs (asection *);
d87 4
a90 2
bfd_boolean
elf_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d100 1
a100 1
      return FALSE;
d104 5
a108 4
/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
d113 1
a113 1
    return FALSE;
d117 1
a117 1
    return FALSE;
d121 1
a121 1
    return FALSE;
d126 1
a126 1
    return FALSE;
d138 1
a138 1
    return FALSE;
d140 1
a140 1
  return TRUE;
d146 4
a149 2
static bfd_boolean
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
d158 1
a158 1
  bfd_boolean result;
d161 2
a162 2
  if (abfd == NULL)
    return FALSE;
d165 1
a165 1
    return FALSE;
d172 1
a172 1
    return FALSE;
d196 1
a196 1
    return FALSE;
d202 1
a202 1
    return FALSE;
d205 1
a205 1
  result = FALSE;
d212 1
a212 1
      if (name == NULL)
d252 4
a255 2
static bfd_boolean
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
d258 2
a259 2
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
d261 1
a261 1
  bfd_boolean loop;
d267 2
a268 2
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
d270 1
a270 1
      return FALSE;
d278 1
a278 1
    return TRUE;
d280 4
a283 4
  amt *= sizeof (bfd_boolean);
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
d295 1
a295 1
      loop = FALSE;
d311 1
a311 1
	      included[i] = TRUE;
d316 1
a316 1
				    FALSE, FALSE, FALSE);
d335 1
a335 1
	      copy = bfd_alloc (abfd, len);
d343 1
a343 1
					FALSE, FALSE, FALSE);
d352 1
a352 1
					    copy, FALSE, FALSE, FALSE);
d381 1
a381 1
		defined[i] = TRUE;
d387 1
a387 1
	  if (element == NULL)
d419 1
a419 1
	    loop = TRUE;
d426 1
a426 1
	      included[mark] = TRUE;
d443 1
a443 1
  return TRUE;
d446 1
a446 1
  if (defined != NULL)
d448 1
a448 1
  if (included != NULL)
d450 696
a1145 1
  return FALSE;
d1150 4
a1153 2
static bfd_boolean
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
d1155 7
a1161 6
  bfd_boolean (*add_symbol_hook)
    (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
  bfd_boolean (*check_relocs)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
  bfd_boolean collect;
d1167 1
a1167 1
  bfd_boolean dynamic;
a1170 2
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
d1174 2
a1175 2
  const struct elf_backend_data *bed;
  bfd_boolean dt_needed;
d1186 1
a1186 1
    dynamic = FALSE;
d1189 1
a1189 1
      dynamic = TRUE;
d1194 1
a1194 3
      if (info->relocatable
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
d1205 1
a1205 1
  if (info->executable)
a1217 2
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");
d1230 1
a1230 1
	      if (dynamic)
d1235 1
a1235 1
					    FALSE, FALSE, TRUE);
d1251 1
a1251 2
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
d1255 1
a1255 2
	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
d1258 1
a1258 1
	      msg[prefix_len + sz] = '\0';
d1261 2
a1262 2
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, collect, NULL)))
d1265 1
a1265 1
	      if (! info->relocatable)
d1275 1
a1275 1
  dt_needed = FALSE;
d1284 3
a1286 3
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
d1288 1
a1288 1
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1292 1
a1292 1
  else if (!is_elf_hash_table (hash_table))
d1297 1
a1297 1
      bfd_boolean add_needed;
d1307 1
a1307 1
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d1317 1
a1317 1
      add_needed = TRUE;
d1325 1
a1325 1
		dt_needed = TRUE;
d1327 1
a1327 1
	      add_needed = FALSE;
d1339 1
a1339 1
	  dynbuf = bfd_malloc (s->_raw_size);
d1343 2
a1344 1
	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1373 1
a1373 1
		  n = bfd_alloc (abfd, amt);
d1381 1
a1381 1
		  memcpy (anm, fnm, amt);
d1398 1
a1398 1
		  n = bfd_alloc (abfd, amt);
d1406 1
a1406 1
		  memcpy (anm, fnm, amt);
d1424 1
a1424 1
		  n = bfd_alloc (abfd, amt);
d1436 1
a1436 1
		  memcpy (anm, fnm, amt);
d1477 3
a1479 2
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;
d1485 1
a1485 1
	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, FALSE);
d1514 1
a1514 1
		      return TRUE;
d1519 1
a1519 1
	  if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
d1567 1
a1567 1
      sym_hash = bfd_alloc (abfd, amt);
d1586 1
a1586 1
	  extversym = bfd_malloc (versymhdr->sh_size);
d1591 1
a1591 1
	      || bfd_bread (extversym, amt, abfd) != amt)
d1609 3
a1611 5
      bfd_boolean definition;
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
      bfd_boolean new_weakdef;
      bfd_boolean override;
d1613 1
a1613 1
      bfd *old_bfd;
d1615 1
a1615 1
      override = FALSE;
d1627 1
a1627 1
	     point to the first global symbol.  Unfortunately, Irix 5
d1670 1
a1670 1
      if (name == NULL)
d1698 1
a1698 1
	  if (name == NULL)
d1703 1
a1703 1
      if (sec == NULL)
d1711 1
a1711 1
	definition = FALSE;
d1713 1
a1713 1
	definition = TRUE;
d1715 1
a1715 1
      size_change_ok = FALSE;
d1718 1
a1718 3
      old_bfd = NULL;

      if (is_elf_hash_table (hash_table))
a1721 1
	  bfd_boolean skip;
d1800 1
a1800 1
		  newname = bfd_alloc (abfd, newlen);
d1818 3
a1820 4
	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok,
				      dt_needed))
a1822 3
	  if (skip)
	    continue;

d1824 1
a1824 1
	    definition = FALSE;
d1835 3
a1837 17
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;
	    
	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }
d1847 2
a1848 2
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
d1857 1
a1857 1
      new_weakdef = FALSE;
d1862 1
a1862 1
	  && is_elf_hash_table (hash_table)
d1879 1
a1879 1
	  new_weakdef = TRUE;
a1893 2
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
d1896 1
a1896 1
      if (is_elf_hash_table (hash_table))
d1899 1
a1899 1
	  bfd_boolean dynsym;
a1901 48
	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overridden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
	    }

d1908 1
a1908 1
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
d1910 1
a1910 3
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));
d1937 7
a1943 14
	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

	  if (isym->st_other != 0 && !dynamic)
	    {
	      unsigned char hvis, symvis, other, nvis;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);
d1945 2
a1946 9
	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;
d1948 6
a1953 1
	      h->other = other | nvis;
d1962 1
a1962 1
	  dynsym = FALSE;
d1973 1
a1973 1
	      if (! info->executable
d1976 1
a1976 1
		dynsym = TRUE;
d1989 1
a1989 1
		dynsym = TRUE;
d1997 3
a1999 3
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override, dt_needed))
a2001 17
	  if (definition && !dynamic)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (! nondeflt_vers)
		    {
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
		      nondeflt_vers = bfd_malloc (amt);
		    }
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
		}
	    }

d2022 1
a2022 1
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
d2033 3
d2040 1
a2040 1
	      dt_needed = FALSE;
d2043 1
a2043 1
					      elf_dt_soname (abfd), FALSE);
d2070 1
a2070 1
	      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
a2075 49
  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = bfd_malloc (amt + 1);
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (&hash_table->root, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

d2177 1
a2177 2
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
d2185 1
a2185 1
	  bfd_boolean ok;
d2194 4
a2197 2
	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
d2211 2
a2212 2
  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
d2214 1
d2216 2
a2217 1
      && is_elf_hash_table (hash_table)
d2220 21
a2240 26
      asection *stabstr;
      
      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;
		
		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd,
					       & hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
d2245 2
a2246 3
  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
d2262 1
a2262 1
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
d2266 1
a2266 1
  if (is_elf_hash_table (hash_table))
d2271 2
a2272 1
      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
d2280 1
a2280 1
  return TRUE;
a2282 2
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
d2289 142
a2430 1
  return FALSE;
d2435 5
a2439 2
bfd_boolean
elf_add_dynamic_entry (struct bfd_link_info *info, bfd_vma tag, bfd_vma val)
d2447 2
a2448 2
  if (! is_elf_hash_table (info->hash))
    return FALSE;
d2456 1
a2456 1
  newcontents = bfd_realloc (s->contents, newsize);
d2458 1
a2458 1
    return FALSE;
d2468 1
a2468 1
  return TRUE;
d2471 16
a2486 22
/* Array used to determine the number of hash table buckets to use
   based on the number of symbols there are.  If there are fewer than
   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
   fewer than 37 we use 17 buckets, and so forth.  We never use more
   than 32771 buckets.  */

static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};

/* Compute bucket count for hashing table.  We do not use a static set
   of possible tables sizes anymore.  Instead we determine for all
   possible reasonable sizes of the table the outcome (i.e., the
   number of collisions etc) and choose the best solution.  The
   weighting functions are not too simple to allow the table to grow
   without bounds.  Instead one of the weighting factors is the size.
   Therefore the result is always a good payoff between few collisions
   (= short chain lengths) and table size.  */
static size_t
compute_bucket_count (struct bfd_link_info *info)
d2488 1
a2488 5
  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
  size_t best_size = 0;
  unsigned long int *hashcodes;
  unsigned long int *hashcodesp;
  unsigned long int i;
d2491 11
a2501 9
  /* Compute the hash values for all exported symbols.  At the same
     time store the values in an array so that we could use them for
     optimizations.  */
  amt = dynsymcount;
  amt *= sizeof (unsigned long int);
  hashcodes = bfd_malloc (amt);
  if (hashcodes == NULL)
    return 0;
  hashcodesp = hashcodes;
d2503 283
a2785 3
  /* Put all hash values in HASHCODES.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_collect_hash_codes, &hashcodesp);
d2811 1
a2811 1
      counts = bfd_malloc (amt);
d2849 1
a2849 1
	     of all the chain lengths (which favors many small chain
d2905 13
a2917 9
bfd_boolean
NAME(bfd_elf,size_dynamic_sections) (bfd *output_bfd,
				     const char *soname,
				     const char *rpath,
				     const char *filter_shlib,
				     const char * const *auxiliary_filters,
				     struct bfd_link_info *info,
				     asection **sinterpptr,
				     struct bfd_elf_version_tree *verdefs)
d2921 1
a2921 1
  const struct elf_backend_data *bed;
d2928 2
a2929 2
  if (!is_elf_hash_table (info->hash))
    return TRUE;
d2931 2
a2932 36
  if (info->execstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags & DYNAMIC)
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else
	    exec = PF_X;
	}
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
    }
d2936 1
a2936 1
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;
d2943 1
a2943 1
    return FALSE;
d2950 1
a2950 1
    return TRUE;
d2953 1
a2953 1
    return FALSE;
d2962 1
a2962 1
      bfd_boolean all_defined;
d2965 1
a2965 1
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);
d2970 1
a2970 1
					     soname, TRUE);
d2972 3
a2974 2
	      || ! elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
	    return FALSE;
d2979 3
a2981 2
	  if (! elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
	    return FALSE;
d2990 1
a2990 1
				      TRUE);
d2994 1
a2994 1
	      || ! elf_add_dynamic_entry (info, DT_RPATH, indx)
d2996 3
a2998 2
		  && ! elf_add_dynamic_entry (info, DT_RUNPATH, indx)))
	    return FALSE;
d3006 1
a3006 1
				      filter_shlib, TRUE);
d3008 2
a3009 2
	      || ! elf_add_dynamic_entry (info, DT_FILTER, indx))
	    return FALSE;
d3021 1
a3021 1
					  *p, TRUE);
d3023 3
a3025 2
		  || ! elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
		return FALSE;
d3031 1
a3031 1
      eif.failed = FALSE;
d3037 2
a3038 3
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
				  &eif);
d3040 1
a3040 1
	    return FALSE;
d3043 1
a3043 1
      /* Make all global versions with definition.  */
d3045 2
a3046 2
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->symbol)
d3053 1
a3053 1
	      name = d->symbol;
d3057 1
a3057 1
	      newlen = namelen + verlen + 3;
d3059 1
a3059 1
	      newname = bfd_malloc (newlen);
d3061 1
a3061 1
		return FALSE;
d3069 2
a3070 2
					   newname, FALSE, FALSE,
					   FALSE);
d3079 2
a3080 2
					       newname, FALSE, FALSE,
					       FALSE);
d3098 1
a3098 1
      asvinfo.failed = FALSE;
d3101 2
a3102 2
			      _bfd_elf_link_assign_sym_version,
			      &asvinfo);
d3104 1
a3104 1
	return FALSE;
d3108 2
a3109 2
	  /* Check if all global versions have a definition.  */
	  all_defined = TRUE;
d3111 3
a3113 2
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (!d->symver && !d->script)
d3118 1
a3118 1
		  all_defined = FALSE;
d3124 1
a3124 1
	      return FALSE;
d3131 2
a3132 2
			      _bfd_elf_adjust_dynamic_symbol,
			      &eif);
d3134 1
a3134 1
	return FALSE;
d3144 2
a3145 2
				   info->init_function, FALSE,
				   FALSE, FALSE)
d3151 2
a3152 2
	  if (! elf_add_dynamic_entry (info, DT_INIT, 0))
	    return FALSE;
d3156 2
a3157 2
				   info->fini_function, FALSE,
				   FALSE, FALSE)
d3163 2
a3164 2
	  if (! elf_add_dynamic_entry (info, DT_FINI, 0))
	    return FALSE;
d3170 1
a3170 1
	  if (! info->executable)
d3188 1
a3188 1
	      return FALSE;
d3191 5
a3195 3
	  if (!elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
	    return FALSE;
d3199 5
a3203 3
	  if (!elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
	    return FALSE;
d3207 5
a3211 3
	  if (!elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
	    return FALSE;
d3224 7
a3230 7
	  if (! elf_add_dynamic_entry (info, DT_HASH, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || ! elf_add_dynamic_entry (info, DT_SYMENT,
					  sizeof (Elf_External_Sym)))
	    return FALSE;
d3238 1
a3238 1
    return FALSE;
d3292 1
a3292 1
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
d3294 1
a3294 1
	    return FALSE;
d3323 1
a3323 1
					  name, FALSE);
d3325 1
a3325 1
		return FALSE;
d3352 1
a3352 1
		      0, NULL, FALSE,
d3354 1
a3354 1
		return FALSE;
d3362 1
a3362 1
		return FALSE;
d3366 1
a3366 1
	      if (t->globals.list == NULL && t->locals.list == NULL && ! t->used)
d3420 4
a3423 3
	  if (! elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || ! elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
	    return FALSE;
d3430 2
a3431 2
	  if (! elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
	    return FALSE;
d3436 1
a3436 1
	  if (info->executable)
d3440 3
a3442 2
	  if (! elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
	    return FALSE;
d3457 1
a3457 1
	sinfo.failed = FALSE;
d3460 2
a3461 2
				_bfd_elf_link_find_version_dependencies,
				&sinfo);
d3488 1
a3488 1
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
d3490 1
a3490 1
	      return FALSE;
d3511 1
a3511 1
					    FALSE);
d3513 1
a3513 1
		  return FALSE;
d3530 1
a3530 1
						a->vna_nodename, FALSE);
d3532 1
a3532 1
		      return FALSE;
d3545 5
a3549 3
	    if (! elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| ! elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
	      return FALSE;
d3576 1
a3576 1
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d3578 1
a3578 1
	    return FALSE;
d3580 2
a3581 2
	  if (! elf_add_dynamic_entry (info, DT_VERSYM, 0))
	    return FALSE;
d3593 1
a3593 1
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
d3595 1
a3595 1
	return FALSE;
d3608 1
a3608 1
	  elf_swap_symbol_out (output_bfd, &isym, s->contents, 0);
d3619 1
a3619 1
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d3621 1
a3621 1
	return FALSE;
d3623 3
a3625 2
      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
d3638 2
a3639 2
	if (! elf_add_dynamic_entry (info, DT_NULL, 0))
	  return FALSE;
d3642 1
a3642 1
  return TRUE;
d3648 7
a3654 2
static bfd_boolean
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
d3656 1
a3656 1
  struct elf_strtab_hash *dynstr = data;
d3663 1
a3663 1
  return TRUE;
d3669 4
a3672 2
static bfd_boolean
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
d3789 658
a4446 1
  return TRUE;
d4467 2
d4472 1
a4472 1
  void *external_relocs;
a4496 2
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
d4499 16
a4514 11
static bfd_boolean elf_link_output_sym
  (struct elf_final_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
static bfd_boolean elf_link_flush_output_syms
  (struct elf_final_link_info *);
static bfd_boolean elf_link_output_extsym
  (struct elf_link_hash_entry *, void *);
static bfd_boolean elf_link_input_bfd
  (struct elf_final_link_info *, bfd *);
static bfd_boolean elf_reloc_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
d4520 2
a4521 2
  bfd_boolean failed;
  bfd_boolean localsyms;
d4525 53
a4577 1
/* When performing a relocatable link, the input relocations are
d4583 5
a4587 4
elf_link_adjust_relocs (bfd *abfd,
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
d4590 4
a4593 4
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d4595 2
a4596 1
  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
d4598 2
a4599 2
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
d4601 4
a4604 1
  else if (rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
d4606 2
a4607 2
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
a4608 2
  else
    abort ();
d4610 1
a4610 5
  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
a4611 3
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

d4617 43
a4659 5
      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
				      ELF_R_TYPE (irela[j].r_info));
      (*swap_out) (abfd, irela, erela);
d4661 3
d4670 6
a4675 2
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
d4679 3
a4681 1
elf_link_sort_cmp1 (const void *A, const void *B)
d4683 2
a4684 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d4694 1
a4694 1
  if (ELF_R_SYM (a->rela->r_info) < ELF_R_SYM (b->rela->r_info))
d4696 1
a4696 1
  if (ELF_R_SYM (a->rela->r_info) > ELF_R_SYM (b->rela->r_info))
d4698 1
a4698 1
  if (a->rela->r_offset < b->rela->r_offset)
d4700 1
a4700 1
  if (a->rela->r_offset > b->rela->r_offset)
d4706 3
a4708 1
elf_link_sort_cmp2 (const void *A, const void *B)
d4710 2
a4711 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d4724 1
a4724 1
  if (a->rela->r_offset < b->rela->r_offset)
d4726 1
a4726 1
  if (a->rela->r_offset > b->rela->r_offset)
d4732 4
a4735 1
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
d4737 3
a4739 1
  asection *reldyn;
d4741 3
a4743 4
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a4744 3
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
d4752 2
a4753 3
      ext_size = sizeof (Elf_External_Rel);
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
d4756 1
a4756 6
    {
      ext_size = sizeof (Elf_External_Rela);
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  count = reldyn->_raw_size / ext_size;
d4759 5
a4763 6
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	asection *o = lo->u.indirect.section;
	size += o->_raw_size;
      }
d4768 18
a4785 4
  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
  sort = bfd_zmalloc (sort_elt * count);
  if (sort == NULL)
d4788 2
a4789 1
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
d4793 4
a4796 2
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
d4798 1
a4798 7
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
d4800 2
a4801 7
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
	    p += sort_elt;
	    erel += ext_size;
	  }
      }
d4803 10
a4812 1
  qsort (sort, count, sort_elt, elf_link_sort_cmp1);
d4814 7
a4820 8
  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;
d4822 10
a4831 8
  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (ELF_R_SYM (sp->rela->r_info) != ELF_R_SYM (sq->rela->r_info))
	sq = sp;
      sp->offset = sq->rela->r_offset;
    }
d4833 4
a4836 1
  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);
d4838 19
a4856 2
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
d4858 4
a4861 2
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;
d4863 13
a4875 4
	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
d4877 14
a4890 4
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
d4894 1
a4894 1
  free (sort);
d4901 4
a4904 2
bfd_boolean
elf_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
d4906 2
a4907 2
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
a4921 1
  Elf_Internal_Shdr *symtab_shndx_hdr;
d4923 1
a4923 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4925 1
a4925 1
  bfd_boolean merged;
d4930 2
a4931 2
  if (! is_elf_hash_table (info->hash))
    return FALSE;
d4939 1
a4939 1
  emit_relocs = (info->relocatable
d4947 1
a4947 1
    return FALSE;
d4975 8
a4982 1
  finfo.shndxbuf_size = 0;
d4992 2
a4993 2
  merged = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
a4994 1
      struct bfd_elf_section_data *esdo = elf_section_data (o);
a4998 4
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;
	  unsigned int *rel_count1;

d5001 1
a5001 1
	    reloc_count = 1;
a5006 1
	      esdi = elf_section_data (sec);
d5012 1
a5012 1
	      sec->linker_mark = TRUE;
d5015 1
a5015 1
		merged = TRUE;
d5017 2
a5018 2
	      if (info->relocatable || info->emitrelocations)
		reloc_count = sec->reloc_count;
d5023 3
a5025 2
		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						      info->keep_memory);
d5027 2
a5028 1
		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);
a5070 50

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      BFD_ASSERT (entsize1 == sizeof (Elf_External_Rel)
			  || entsize1 == sizeof (Elf_External_Rela));
	      same_size = (!o->use_rela_p
			   == (entsize1 == sizeof (Elf_External_Rel)));

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == sizeof (Elf_External_Rel)
				  || entsize2 == sizeof (Elf_External_Rela)));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
	    }
	  *rel_count1 += reloc_count;
d5092 1
a5092 1
  if (! info->relocatable && merged)
d5094 1
a5094 1
			    _bfd_elf_link_sec_merge_syms, abfd);
d5104 57
d5167 3
a5169 2
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
d5173 3
a5175 2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
d5195 3
a5197 1
  /* sh_flags, sh_addr and sh_size all start off zero.  */
d5202 1
a5202 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d5205 1
a5205 1
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);
d5219 1
a5219 1
  finfo.symbuf = bfd_malloc (amt);
d5224 1
a5224 3
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
d5226 1
a5226 1
      finfo.symshndxbuf = bfd_zmalloc (amt);
d5241 2
a5242 2
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
d5258 1
a5258 1
			     &elfsym, bfd_abs_section_ptr, NULL))
d5279 1
a5279 1
	  if (info->relocatable || o == NULL)
d5283 2
a5284 1
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
d5286 1
a5286 1
	  if (i == SHN_LORESERVE - 1)
d5295 1
a5295 1
      finfo.contents = bfd_malloc (max_contents_size);
d5302 1
a5302 1
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
d5311 1
a5311 1
      finfo.internal_relocs = bfd_malloc (amt);
d5319 1
a5319 1
      finfo.external_syms = bfd_malloc (amt);
d5324 1
a5324 1
      finfo.internal_syms = bfd_malloc (amt);
d5329 1
a5329 1
      finfo.indices = bfd_malloc (amt);
d5334 1
a5334 1
      finfo.sections = bfd_malloc (amt);
d5342 1
a5342 1
      finfo.locsym_shndx = bfd_malloc (amt);
d5347 1
a5347 1
  if (elf_hash_table (info)->tls_sec)
d5349 2
a5350 1
      bfd_vma base, end = 0;
d5353 1
a5353 1
      for (sec = elf_hash_table (info)->tls_sec;
d5359 3
a5361 1
	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
d5365 1
d5372 7
a5378 3
      base = elf_hash_table (info)->tls_sec->vma;
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
d5390 1
a5390 1
     we are generating relocatable output, and we see a reloc against
d5396 1
a5396 1
     it.  Fortunately, it only happens when performing a relocatable
d5402 1
a5402 1
    sub->output_has_begun = FALSE;
d5416 1
a5416 1
		  sub->output_has_begun = TRUE;
d5439 1
a5439 1
  eoinfo.failed = FALSE;
d5441 1
a5441 1
  eoinfo.localsyms = TRUE;
d5443 1
a5443 1
			  &eoinfo);
d5445 1
a5445 1
    return FALSE;
d5483 1
a5483 1
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d5524 1
a5524 1
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d5533 2
a5534 2
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
d5537 1
a5537 1
			  &eoinfo);
d5539 1
a5539 1
    return FALSE;
d5545 3
a5547 3
      typedef bfd_boolean (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);
d5550 2
a5551 2
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
d5556 1
a5556 1
    return FALSE;
a5560 18
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, TRUE);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
	return FALSE;
    }


d5575 1
a5575 1
  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
d5582 1
a5582 1
	return FALSE;
d5659 1
a5659 1
					  FALSE, FALSE, TRUE);
d5793 1
a5793 1
		 created by _bfd_elf_link_create_dynamic_sections.  */
d5819 1
a5819 1
  if (info->relocatable)
d5821 1
a5821 1
      bfd_boolean failed = FALSE;
d5835 1
a5835 1
  if (info->eh_frame_hdr)
d5837 9
a5845 2
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
d5869 1
a5869 1
    free (finfo.symshndxbuf);
d5877 1
a5877 1
  elf_tdata (abfd)->linker = TRUE;
d5879 1
a5879 1
  return TRUE;
d5903 1
a5903 1
    free (finfo.symshndxbuf);
d5911 1
a5911 1
  return FALSE;
d5916 6
a5921 6
static bfd_boolean
elf_link_output_sym (struct elf_final_link_info *finfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
d5925 6
a5930 3
  bfd_boolean (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
d5936 3
a5938 2
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
	return FALSE;
d5941 1
a5941 1
  if (name == NULL || *name == '\0')
d5948 1
a5948 1
							    name, TRUE, FALSE);
d5950 1
a5950 1
	return FALSE;
d5956 1
a5956 1
	return FALSE;
d5962 3
a5964 4
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;
d5966 1
a5966 9
	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return FALSE;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }
d5968 1
a5968 5
  elf_swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;

  return TRUE;
d5973 3
a5975 2
static bfd_boolean
elf_link_flush_output_syms (struct elf_final_link_info *finfo)
d5987 2
a5988 2
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
	return FALSE;
d5991 14
d6008 1
a6008 1
  return TRUE;
d6011 7
a6017 9
/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */

static bfd_boolean
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
d6019 1
a6019 2
  bfd *abfd;
  struct elf_link_loaded_list *loaded;
d6021 2
a6022 2
  if (!is_elf_hash_table (info->hash))
    return FALSE;
d6024 4
a6027 1
  switch (h->root.type)
d6029 11
a6039 3
    default:
      abfd = NULL;
      break;
d6041 3
a6043 6
    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
	return FALSE;
      break;
d6045 7
a6051 4
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;
d6053 4
a6056 5
    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);
d6077 1
a6077 1
      if (input == abfd
d6102 1
a6102 1
	return FALSE;
d6106 1
a6106 1
      extversym = bfd_malloc (versymhdr->sh_size);
d6111 1
a6111 1
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
d6117 1
a6117 1
	  return FALSE;
a6125 1
	  unsigned short version_index;
d6146 1
a6146 2
	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
d6148 1
a6148 1
	      /* This is the base or first version.  We can use it.  */
d6151 1
a6151 1
	      return TRUE;
d6159 1
a6159 1
  return FALSE;
d6169 4
a6172 2
static bfd_boolean
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
d6174 1
a6174 1
  struct elf_outext_info *eoinfo = data;
d6176 1
a6176 1
  bfd_boolean strip;
d6184 1
a6184 1
	return TRUE;
d6191 1
a6191 1
	return TRUE;
d6196 1
a6196 1
	return TRUE;
d6199 11
a6209 5
  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
d6212 1
a6212 2
      && ! elf_link_check_versioned_symbol (finfo->info, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
d6216 1
a6216 1
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
d6218 2
a6219 2
	  eoinfo->failed = TRUE;
	  return FALSE;
a6222 22
  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocatable
      && (! finfo->info->shared)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, h))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

d6228 1
a6228 1
    strip = FALSE;
d6233 7
a6239 12
    strip = TRUE;
  else if (finfo->info->strip == strip_all)
    strip = TRUE;
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
    strip = TRUE;
d6241 1
a6241 1
    strip = FALSE;
d6248 1
a6248 1
    return TRUE;
d6267 1
a6267 1
      return FALSE;
d6291 2
a6292 2
		eoinfo->failed = TRUE;
		return FALSE;
d6295 2
a6296 2
	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
d6299 1
a6299 1
	    if (! finfo->info->relocatable)
d6306 2
a6307 2
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
d6334 1
a6334 1
      return TRUE;
d6343 1
a6343 3
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
d6347 1
a6347 1
      const struct elf_backend_data *bed;
d6353 2
a6354 2
	  eoinfo->failed = TRUE;
	  return FALSE;
d6378 3
a6380 6
  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
  if (! finfo->info->relocatable
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type == bfd_link_hash_undefined
d6382 1
a6382 12
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }
d6399 1
a6399 1
      elf_swap_symbol_out (finfo->output_bfd, &sym, esym, 0);
d6408 2
a6409 1
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
d6446 1
a6446 1
    return TRUE;
d6450 95
a6544 1
  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
d6546 10
a6555 2
      eoinfo->failed = TRUE;
      return FALSE;
d6558 5
a6562 1
  return TRUE;
d6570 4
a6573 2
static bfd_boolean
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
d6575 4
a6578 3
  bfd_boolean (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d6589 2
a6590 2
  const struct elf_backend_data *bed;
  bfd_boolean emit_relocs;
d6601 1
a6601 1
    return TRUE;
d6603 1
a6603 1
  emit_relocs = (finfo->info->relocatable
d6628 1
a6628 1
	return FALSE;
d6661 1
a6661 1
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
d6666 1
a6666 1
					  isym->st_value, 0);
d6698 1
a6698 1
	 output this one.  If we are generating a relocatable output
d6713 1
a6713 1
	      || (! finfo->info->relocatable
d6721 1
a6721 1
	return FALSE;
d6725 1
a6725 1
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d6728 1
a6728 1
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
d6741 1
a6741 1
	return FALSE;
d6745 1
a6745 1
      /* ELF symbols in relocatable files are section relative, but
d6753 1
a6753 1
      if (! finfo->info->relocatable)
d6759 2
a6760 2
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
d6764 2
a6765 2
      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
	return FALSE;
d6786 1
a6786 1
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
d6800 3
a6802 3
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
	    return FALSE;
d6810 3
a6812 3
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
d6815 1
a6815 1
	    return FALSE;
d6821 8
a6828 3
	     link-once sections.  Preserve debug information as much
	     as we can.  */
	  if (!elf_section_ignore_discarded_relocs (o))
a6836 1
		  asection *sec;
a6850 1
		      sec = h->root.u.def.section;
d6853 1
a6853 1
			  && elf_discarded_section (sec))
d6858 1
a6858 8
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
d6861 7
a6867 7
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
d6872 1
a6872 1
		      sec = finfo->sections[r_symndx];
d6880 3
a6882 12
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info
				    = ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
				  rel->r_addend = 0;
				}
d6886 17
a6902 14
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
d6904 2
d6916 1
a6916 1
	     and generating a relocatable output file) adjusting the
d6926 1
a6926 1
	     When generating relocatable output, the back end routine
d6937 1
a6937 1
	    return FALSE;
a6942 1
	      bfd_vma last_offset;
d6946 4
a6949 3
	      bfd_boolean (*reloc_emitter)
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
	      bfd_boolean rela_normal;
a6962 3
	      last_offset = o->output_offset;
	      if (!finfo->info->relocatable)
		last_offset += o->output_section->vma;
a6974 16
		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     finfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 elf_bfd_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
		      continue;
		    }

d6978 1
a6978 1
		  if (!finfo->info->relocatable)
d6981 1
a6981 1
		  last_offset = irela->r_offset;
d6983 1
a6983 2
		  r_symndx = ELF_R_SYM (irela->r_info);
		  if (r_symndx == STN_UNDEF)
d7036 1
a7036 1
			  return FALSE;
d7061 1
a7061 1
			      return FALSE;
d7071 1
a7071 1
			    return FALSE;
d7078 1
a7078 1
			    return FALSE;
d7081 1
a7081 1
			  if (! finfo->info->relocatable)
d7088 2
a7089 4
				  BFD_ASSERT (elf_hash_table (finfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (finfo->info)
						   ->tls_sec->vma);
d7096 2
a7097 3
			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
			    return FALSE;
d7109 1
a7109 1
		  && !(finfo->info->relocatable
d7113 1
a7113 1
		reloc_emitter = _bfd_elf_link_output_relocs;
d7118 1
a7118 1
		return FALSE;
d7127 1
a7127 1
		    return FALSE;
d7138 1
a7138 1
      else switch (o->sec_info_type)
d7145 1
a7145 1
	    return FALSE;
d7148 3
a7150 3
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
	    return FALSE;
d7154 8
a7161 3
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
						   o, contents))
	      return FALSE;
d7174 1
a7174 1
	      return FALSE;
d7180 1
a7180 1
  return TRUE;
d7188 6
a7193 5
static bfd_boolean
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
d7201 1
a7201 4
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;
d7207 1
a7207 1
      return FALSE;
d7231 1
a7231 1
					 FALSE, FALSE, TRUE));
d7257 3
a7259 2
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
d7271 1
a7271 1
      bfd_boolean ok;
d7275 4
a7278 4
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
d7295 2
a7296 1
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
d7299 1
a7299 1
	      return FALSE;
d7303 2
a7304 2
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
d7307 1
a7307 1
	return FALSE;
d7311 1
a7311 1
     relocatable file, and is a virtual address in an executable
d7314 1
a7314 1
  if (! info->relocatable)
d7317 154
a7470 1
  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
d7472 15
a7486 3
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
d7488 40
a7527 1
  irel[0].r_info = ELF_R_INFO (indx, howto->type);
d7529 1
a7529 3
  rel_hdr = &elf_section_data (output_section)->rel_hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == SHT_REL)
d7531 30
a7560 3
      erel += (elf_section_data (output_section)->rel_count
	       * sizeof (Elf_External_Rel));
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
d7564 60
a7623 4
      irel[0].r_addend = addend;
      erel += (elf_section_data (output_section)->rel_count
	       * sizeof (Elf_External_Rela));
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
d7626 10
a7635 1
  ++elf_section_data (output_section)->rel_count;
d7637 3
a7639 1
  return TRUE;
d7644 16
a7659 2
static bfd_boolean elf_gc_sweep_symbol
  (struct elf_link_hash_entry *, void *);
d7661 5
a7665 2
static bfd_boolean elf_gc_allocate_got_offsets
  (struct elf_link_hash_entry *, void *);
d7671 8
a7678 8
typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

static bfd_boolean
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
d7680 1
a7680 1
  bfd_boolean ret;
d7689 1
a7689 1
      return FALSE;
d7692 1
a7692 1
  ret = TRUE;
d7701 1
a7701 1
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
d7722 1
a7722 1
	    return FALSE;
d7726 3
a7728 2
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
					    info->keep_memory);
d7731 1
a7731 1
	  ret = FALSE;
d7763 1
a7763 1
		  ret = FALSE;
d7787 5
a7791 5
typedef bfd_boolean (*gc_sweep_hook_fn)
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);

static bfd_boolean
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
d7826 1
a7826 1
	      bfd_boolean r;
d7828 2
a7829 3
	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
					     info->keep_memory);
d7831 1
a7831 1
		return FALSE;
d7839 1
a7839 1
		return FALSE;
d7850 3
a7852 1
    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);
d7857 1
a7857 1
  return TRUE;
d7862 4
a7865 2
static bfd_boolean
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
d7867 1
a7867 1
  int *idx = idxptr;
d7878 1
a7878 1
  return TRUE;
d7881 1
a7881 1
/* Propagate collected vtable information.  This is called through
d7884 4
a7887 2
static bfd_boolean
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
d7894 1
a7894 1
    return TRUE;
d7898 1
a7898 1
    return TRUE;
d7902 1
a7902 1
    return TRUE;
d7917 1
a7917 1
      bfd_boolean *cu, *pu;
d7921 1
a7921 1
      cu[-1] = TRUE;
d7925 3
a7927 2
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;
d7929 1
a7929 3
	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
d7933 1
a7933 1
		*cu = TRUE;
d7940 1
a7940 1
  return TRUE;
d7943 4
a7946 2
static bfd_boolean
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
d7951 2
a7952 2
  const struct elf_backend_data *bed;
  unsigned int log_file_align;
d7960 1
a7960 1
    return TRUE;
d7969 2
a7970 1
  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
d7972 1
a7972 1
    return *(bfd_boolean *) okp = FALSE;
d7974 1
a7974 1
  log_file_align = bed->s->log_file_align;
d7985 1
a7985 1
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
d7993 1
a7993 1
  return TRUE;
d7998 4
a8001 2
bfd_boolean
elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
d8003 1
a8003 1
  bfd_boolean ok = TRUE;
d8006 2
a8007 2
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);
d8010 1
a8010 3
      || info->relocatable
      || info->emitrelocations
      || !is_elf_hash_table (info->hash)
d8012 1
a8012 1
    return TRUE;
d8017 1
a8017 1
			  &ok);
d8019 1
a8019 1
    return FALSE;
d8024 1
a8024 1
			  &ok);
d8026 1
a8026 1
    return FALSE;
d8042 1
a8042 1
	      return FALSE;
d8048 1
a8048 1
    return FALSE;
d8050 1
a8050 1
  return TRUE;
d8053 1
a8053 1
/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */
d8055 6
a8060 5
bfd_boolean
elf_gc_record_vtinherit (bfd *abfd,
			 asection *sec,
			 struct elf_link_hash_entry *h,
			 bfd_vma offset)
d8092 1
a8092 1
  return FALSE;
d8107 1
a8107 1
  return TRUE;
d8110 1
a8110 1
/* Called from check_relocs to record the existence of a VTENTRY reloc.  */
d8112 6
a8117 5
bfd_boolean
elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *sec ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       bfd_vma addend)
d8119 2
a8120 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int log_file_align = bed->s->log_file_align;
d8124 2
a8125 2
      size_t size, bytes, file_align;
      bfd_boolean *ptr = h->vtable_entries_used;
a8128 1
      file_align = 1 << log_file_align;
d8130 1
a8130 1
	size = addend + file_align;
d8134 1
a8134 1
	  if (addend >= size)
d8138 1
a8138 1
	      size = addend + file_align;
a8140 1
      size = (size + file_align - 1) & -file_align;
d8144 1
a8144 1
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);
d8148 1
a8148 1
	  ptr = bfd_realloc (ptr - 1, bytes);
d8154 2
a8155 2
	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
			  * sizeof (bfd_boolean));
d8160 1
a8160 1
	ptr = bfd_zmalloc (bytes);
d8163 1
a8163 1
	return FALSE;
d8170 1
a8170 1
  h->vtable_entries_used[addend >> log_file_align] = TRUE;
d8172 1
a8172 1
  return TRUE;
d8178 4
a8181 3
bfd_boolean
elf_gc_common_finalize_got_offsets (bfd *abfd,
				    struct bfd_link_info *info)
d8184 1
a8184 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a8186 3
  if (! is_elf_hash_table (info->hash))
    return FALSE;

d8230 2
a8231 2
			  &gotoff);
  return TRUE;
d8237 4
a8240 2
static bfd_boolean
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *offarg)
d8242 1
a8242 1
  bfd_vma *off = offarg;
d8255 1
a8255 1
  return TRUE;
d8261 4
a8264 2
bfd_boolean
elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
d8267 1
a8267 1
    return FALSE;
d8276 4
a8279 2
static bfd_boolean
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
d8281 1
a8281 1
  unsigned long **valuep = data;
d8292 1
a8292 1
    return TRUE;
d8298 2
a8299 2
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
d8317 1
a8317 1
  return TRUE;
d8320 4
a8323 2
bfd_boolean
elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
d8325 1
a8325 1
  struct elf_reloc_cookie *rcookie = cookie;
d8332 1
a8332 1
      unsigned long r_symndx;
d8336 1
a8336 1
	  return FALSE;
a8339 4
      r_symndx = ELF_R_SYM (rcookie->rel->r_info);
      if (r_symndx == SHN_UNDEF)
	return TRUE;

d8354 1
a8354 1
	    return TRUE;
d8356 1
a8356 1
	    return FALSE;
d8372 1
a8372 1
		return TRUE;
d8375 1
a8375 1
      return FALSE;
d8377 1
a8377 1
  return FALSE;
d8381 1
a8381 1
   Returns TRUE if any section's size was changed.  */
d8385 4
a8388 2
bfd_boolean
elf_bfd_discard_info (bfd *output_bfd, struct bfd_link_info *info)
d8391 1
a8391 1
  asection *stab, *eh;
d8393 1
a8393 1
  const struct elf_backend_data *bed;
d8395 2
a8396 2
  unsigned int count;
  bfd_boolean ret = FALSE;
d8398 10
a8407 3
  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return FALSE;
d8419 21
a8439 17
      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (info->relocatable
	  || (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section))))
	eh = NULL;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->_raw_size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
d8448 2
a8449 1
	  cookie.locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d8465 1
a8465 1
	    return FALSE;
d8468 1
a8468 1
      if (stab != NULL)
d8470 4
a8473 6
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
	  if (cookie.rels != NULL)
d8476 2
a8477 2
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
d8482 1
a8482 1
		ret = TRUE;
d8488 1
a8488 1
      if (eh != NULL)
d8491 13
a8503 10
	  count = eh->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
d8506 7
a8512 4
	    ret = TRUE;

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
d8516 5
a8520 3
      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = TRUE;
d8532 2
a8533 5
  if (info->eh_frame_hdr
      && !info->relocatable
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
    ret = TRUE;

d8537 3
a8539 2
static bfd_boolean
elf_section_ignore_discarded_relocs (asection *sec)
d8541 1
a8541 1
  const struct elf_backend_data *bed;
d8543 1
a8543 1
  switch (sec->sec_info_type)
d8547 1
a8547 1
      return TRUE;
d8555 1
a8555 1
    return TRUE;
d8557 1
a8557 1
  return FALSE;
@


1.187.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d5804 1
a5804 4
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }
@


1.186
log
@When examining weak symbols, follow indirect links.
@
text
@d8485 6
a8490 1
	    ret = true;
@


1.186.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d8485 1
a8485 6
	    {
	      /* Relocs have been edited.  Ensure edited version is
		 used later in relocate_section.  */
	      elf_section_data (eh)->relocs = cookie.rels;
	      ret = true;
	    }
@


1.186.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a923 1
  struct bfd_link_hash_entry *bh;
a981 1
      bh = &hi->root;
d984 2
a985 1
	      (bfd_vma) 0, name, false, collect, &bh)))
a986 1
      hi = (struct elf_link_hash_entry *) bh;
a1100 1
      bh = &hi->root;
d1103 2
a1104 1
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
a1105 1
      hi = (struct elf_link_hash_entry *) bh;
a2294 1
  struct bfd_link_hash_entry *bh;
d2387 1
a2387 1
  bh = NULL;
d2390 2
a2391 1
	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
a2392 1
  h = (struct elf_link_hash_entry *) bh;
a3328 1
	      struct bfd_link_hash_entry *bh;
d3335 1
a3335 1
	      bh = NULL;
d3339 2
a3340 1
		      get_elf_backend_data (dynobj)->collect, &bh)))
a3341 1
	      h = (struct elf_link_hash_entry *) bh;
d6818 1
d6821 6
d6831 1
d6847 1
d6851 6
d6863 1
@


1.186.2.3
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a1300 8
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;
d1330 2
d1348 2
d1393 7
d1413 1
a1413 1
		  for (pn = & runpath;
d1418 2
d1445 1
a1445 1
		  for (pn = & rpath;
d1450 1
a1456 15
      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

d4663 2
a4664 3
    /* We use these as arrays of size int_rels_per_ext_rel.  */
    Elf_Internal_Rel rel[1];
    Elf_Internal_Rela rela[1];
d4684 1
a4684 1
  if (ELF_R_SYM (a->u.rel->r_info) < ELF_R_SYM (b->u.rel->r_info))
d4686 1
a4686 1
  if (ELF_R_SYM (a->u.rel->r_info) > ELF_R_SYM (b->u.rel->r_info))
d4688 1
a4688 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4690 1
a4690 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
d4714 1
a4714 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4716 1
a4716 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
a4733 1
  int i2e = bed->s->int_rels_per_ext_rel;
d4757 1
a4757 17
  /* We waste some memory here when N = i2e is greater than 1, since
     we allocate space for N * sizeof (*rela) where sizeof (*rela) +
     (N - 1) * sizeof (Elf_Internal_Rel/Rela) would do.  Also, we use
     rela[k] only when k is a multiple of N, and then we index the
     array within the union, such that rela[k].u.rel[i], i < N, is the
     (i+1)th internal relocation corresponding to the (k/N)th external
     relocation.  This is done such that the relocation swap-in and
     swap-out functions can gen pointers to arrays of internal
     relocations that form a single external relocation.

     If C permitted arrays of structures with dynamic sizes, we could
     do better, but trying to avoid wasting space at the end of the
     chunk from rela[k] to rela[k+N-1] would require us to allocate a
     separate array of pointers and since most ports have N == 1, this
     would be more wasteful.  */
  rela = (struct elf_link_sort_rela *) bfd_zmalloc
    (sizeof (*rela) * count * i2e);
d4778 2
a4779 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4782 1
a4782 2
		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel,
					    s->u.rel);
d4784 1
a4784 1
		  elf_swap_reloc_in (abfd, erel, s->u.rel);
d4786 1
a4786 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4796 2
a4797 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4801 1
a4801 1
					     s->u.rela);
d4803 1
a4803 1
		  elf_swap_reloca_in (dynobj, erela, s->u.rela);
d4805 1
a4805 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4810 2
a4811 3
  qsort (rela, (size_t) count, sizeof (*rela) * i2e, elf_link_sort_cmp1);
  for (ret = 0; ret < count * i2e && rela[ret].type == reloc_class_relative;
       ret += i2e)
d4813 1
a4813 1
  for (i = ret, j = ret; i < count * i2e; i += i2e)
d4815 1
a4815 2
      if (ELF_R_SYM (rela[i].u.rel->r_info)
	  != ELF_R_SYM (rela[j].u.rel->r_info))
d4817 1
a4817 1
      rela[i].offset = rela[j].u.rel->r_offset;
d4819 1
a4819 3
  ret /= i2e;
  qsort (rela + ret, (size_t) count - ret,
	 sizeof (*rela) * i2e, elf_link_sort_cmp2);
d4833 2
a4834 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4837 1
a4837 1
		  (*bed->s->swap_reloc_out) (abfd, s->u.rel,
d4840 1
a4840 1
		  elf_swap_reloc_out (abfd, s->u.rel, erel);
d4850 2
a4851 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4854 1
a4854 1
		  (*bed->s->swap_reloca_out) (dynobj, s->u.rela,
d4857 1
a4857 1
		  elf_swap_reloca_out (dynobj, s->u.rela, erela);
@


1.186.2.4
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2211 2
a2212 2
  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
d2214 1
a2344 1
      elf_hash_table (info)->eh_info.hdr_sec = s;
a4496 2
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
a4921 1
  Elf_Internal_Shdr *symtab_shndx_hdr;
a4974 1
  finfo.shndxbuf_size = 0;
d5195 3
a5197 1
  /* sh_flags, sh_addr and sh_size all start off zero.  */
d5224 1
a5224 3
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
d5226 1
a5226 1
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
d5286 1
a5286 1
	  if (i == SHN_LORESERVE - 1)
a5560 18
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, true);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite ((PTR) finfo.symshndxbuf, amt, abfd) != amt))
	return false;
    }


d5835 1
a5835 1
  if (info->eh_frame_hdr)
d5837 9
a5845 2
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
d5869 1
a5869 1
    free (finfo.symshndxbuf);
d5903 1
a5903 1
    free (finfo.symshndxbuf);
d5962 3
a5964 4
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;
d5966 1
a5966 13
	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return false;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }

  elf_swap_symbol_out (finfo->output_bfd, elfsym, (PTR) dest, (PTR) destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;
d5991 14
d6821 6
a6826 1
	     link-once sections.  */
a6974 10
		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     finfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.  */
		      memset (irela, 0, sizeof (*irela));
		      continue;
		    }

d7148 2
a7149 2
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
d7154 7
a7160 2
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
						   o, contents))
d8332 1
a8332 1
      unsigned long r_symndx;
a8339 4
      r_symndx = ELF_R_SYM (rcookie->rel->r_info);
      if (r_symndx == SHN_UNDEF)
	return true;

d8391 1
a8391 1
  asection *stab, *eh;
a8394 1
  unsigned int count;
d8396 1
d8398 2
a8399 1
  if (info->traditional_format
d8404 5
d8419 21
a8439 16
      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (eh != NULL
	  && (eh->_raw_size == 0
	      || bfd_is_abs_section (eh->output_section)))
	eh = NULL;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->_raw_size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || elf_section_data (stab)->sec_info_type != ELF_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
d8448 2
a8449 1
	  cookie.locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
d8468 1
a8468 1
      if (stab != NULL)
d8470 4
a8473 7
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
			   (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			    info->keep_memory));
	  if (cookie.rels != NULL)
d8476 2
a8477 2
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
d8488 1
a8488 1
      if (eh != NULL)
d8491 3
a8493 2
	  count = eh->reloc_count;
	  if (count != 0)
d8497 7
a8503 6
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
d8506 7
a8512 4
	    ret = true;

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
d8516 5
a8520 3
      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = true;
d8532 1
a8532 2
  if (info->eh_frame_hdr
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
a8533 1

@


1.186.2.5
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d28 1
a28 1
  bfd_boolean failed;
d33 1
a33 1
static bfd_boolean is_global_data_symbol_definition
d35 1
a35 1
static bfd_boolean elf_link_is_defined_archive_symbol
d37 1
a37 1
static bfd_boolean elf_link_add_object_symbols
d39 1
a39 1
static bfd_boolean elf_link_add_archive_symbols
d41 1
a41 1
static bfd_boolean elf_merge_symbol
d44 3
a46 3
	   struct elf_link_hash_entry **, bfd_boolean *, bfd_boolean *,
	   bfd_boolean *, bfd_boolean));
static bfd_boolean elf_add_default_symbol
d49 2
a50 2
	   bfd_boolean *, bfd_boolean, bfd_boolean));
static bfd_boolean elf_export_symbol
d52 1
a52 1
static bfd_boolean elf_finalize_dynstr
d54 1
a54 1
static bfd_boolean elf_fix_symbol_flags
d56 1
a56 1
static bfd_boolean elf_adjust_dynamic_symbol
d58 1
a58 1
static bfd_boolean elf_link_find_version_dependencies
d60 1
a60 1
static bfd_boolean elf_link_assign_sym_version
d62 1
a62 1
static bfd_boolean elf_collect_hash_codes
d64 1
a64 1
static bfd_boolean elf_link_read_relocs_from_section
d68 1
a68 1
static bfd_boolean elf_link_output_relocs
d70 1
a70 1
static bfd_boolean elf_link_size_reloc_section
d81 1
a81 1
static bfd_boolean elf_section_ignore_discarded_relocs
d87 1
a87 1
bfd_boolean
d100 1
a100 1
      return FALSE;
d104 2
a105 2
/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
d113 1
a113 1
    return FALSE;
d117 1
a117 1
    return FALSE;
d121 1
a121 1
    return FALSE;
d126 1
a126 1
    return FALSE;
d138 1
a138 1
    return FALSE;
d140 1
a140 1
  return TRUE;
d146 1
a146 1
static bfd_boolean
d158 1
a158 1
  bfd_boolean result;
d162 1
a162 1
    return FALSE;
d165 1
a165 1
    return FALSE;
d172 1
a172 1
    return FALSE;
d196 1
a196 1
    return FALSE;
d202 1
a202 1
    return FALSE;
d205 1
a205 1
  result = FALSE;
d252 1
a252 1
static bfd_boolean
d258 2
a259 2
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
d261 1
a261 1
  bfd_boolean loop;
d268 1
a268 1
	return TRUE;
d270 1
a270 1
      return FALSE;
d278 1
a278 1
    return TRUE;
d280 4
a283 4
  amt *= sizeof (bfd_boolean);
  defined = (bfd_boolean *) bfd_zmalloc (amt);
  included = (bfd_boolean *) bfd_zmalloc (amt);
  if (defined == (bfd_boolean *) NULL || included == (bfd_boolean *) NULL)
d295 1
a295 1
      loop = FALSE;
d311 1
a311 1
	      included[i] = TRUE;
d316 1
a316 1
				    FALSE, FALSE, FALSE);
d343 1
a343 1
					FALSE, FALSE, FALSE);
d352 1
a352 1
					    copy, FALSE, FALSE, FALSE);
d381 1
a381 1
		defined[i] = TRUE;
d419 1
a419 1
	    loop = TRUE;
d426 1
a426 1
	      included[mark] = TRUE;
d443 1
a443 1
  return TRUE;
d446 1
a446 1
  if (defined != (bfd_boolean *) NULL)
d448 1
a448 1
  if (included != (bfd_boolean *) NULL)
d450 1
a450 1
  return FALSE;
d465 1
a465 1
static bfd_boolean
d475 4
a478 4
     bfd_boolean *override;
     bfd_boolean *type_change_ok;
     bfd_boolean *size_change_ok;
     bfd_boolean dt_needed;
d484 1
a484 1
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
d486 1
a486 1
  *override = FALSE;
d492 1
a492 1
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
d495 1
a495 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
d497 1
a497 1
    return FALSE;
d503 1
a503 1
    return TRUE;
d518 1
a518 1
      return TRUE;
d553 1
a553 1
    return TRUE;
d559 1
a559 1
    newdyn = TRUE;
d561 1
a561 1
    newdyn = FALSE;
d588 1
a588 1
	olddyn = FALSE;
d597 1
a597 1
    newdef = FALSE;
d599 1
a599 1
    newdef = TRUE;
d604 1
a604 1
    olddef = FALSE;
d606 1
a606 1
    olddef = TRUE;
d638 1
a638 1
    newdyncommon = TRUE;
d640 1
a640 1
    newdyncommon = FALSE;
d650 1
a650 1
    olddyncommon = TRUE;
d652 1
a652 1
    olddyncommon = FALSE;
d662 1
a662 1
    *type_change_ok = TRUE;
d669 1
a669 1
    *size_change_ok = TRUE;
d688 1
a688 1
	return FALSE;
d693 1
a693 1
      *size_change_ok = TRUE;
d725 3
a727 3
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
d730 1
a730 1
      *size_change_ok = TRUE;
d739 1
a739 1
	*type_change_ok = TRUE;
d751 3
a753 3
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
d756 1
a756 1
      *size_change_ok = TRUE;
d789 1
a789 1
      *size_change_ok = TRUE;
d791 2
a792 2
      olddef = FALSE;
      olddyncommon = FALSE;
d798 1
a798 1
	*type_change_ok = TRUE;
d831 1
a831 1
	return FALSE;
d843 2
a844 2
      olddef = FALSE;
      olddyncommon = FALSE;
d849 2
a850 2
      *size_change_ok = TRUE;
      *type_change_ok = TRUE;
d895 1
a895 1
    *override = TRUE;
d897 1
a897 1
  return TRUE;
d906 1
a906 1
static bfd_boolean
d916 3
a918 3
     bfd_boolean *dynsym;
     bfd_boolean override;
     bfd_boolean dt_needed;
d920 2
a921 2
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
d926 2
a927 2
  bfd_boolean collect;
  bfd_boolean dynamic;
d938 1
a938 1
    return TRUE;
d944 2
a945 2
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
d948 1
a948 1
	return TRUE;
d954 1
a954 1
	    return TRUE;
d965 1
a965 1
    return FALSE;
d973 2
a974 2
  type_change_ok = FALSE;
  size_change_ok = FALSE;
d979 1
a979 1
    return FALSE;
d986 2
a987 2
	      (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
d1025 1
a1025 1
		return FALSE;
d1060 1
a1060 1
		*dynsym = TRUE;
d1066 1
a1066 1
		*dynsym = TRUE;
d1077 1
a1077 1
    return FALSE;
d1082 2
a1083 2
  type_change_ok = FALSE;
  size_change_ok = FALSE;
d1088 1
a1088 1
    return FALSE;
d1106 2
a1107 2
	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
d1133 1
a1133 1
		    *dynsym = TRUE;
d1139 1
a1139 1
		    *dynsym = TRUE;
d1145 1
a1145 1
  return TRUE;
d1150 1
a1150 1
static bfd_boolean
d1155 7
a1161 7
  bfd_boolean (*add_symbol_hook)
    PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	     const char **, flagword *, asection **, bfd_vma *));
  bfd_boolean (*check_relocs)
    PARAMS ((bfd *, struct bfd_link_info *, asection *,
	     const Elf_Internal_Rela *));
  bfd_boolean collect;
d1167 1
a1167 1
  bfd_boolean dynamic;
d1175 1
a1175 1
  bfd_boolean dt_needed;
d1186 1
a1186 1
    dynamic = FALSE;
d1189 1
a1189 1
      dynamic = TRUE;
d1235 1
a1235 1
					    FALSE, FALSE, TRUE);
d1262 1
a1262 1
		      FALSE, collect, (struct bfd_link_hash_entry **) NULL)))
d1275 1
a1275 1
  dt_needed = FALSE;
d1297 1
a1297 1
      bfd_boolean add_needed;
d1317 1
a1317 1
      add_needed = TRUE;
d1325 1
a1325 1
		dt_needed = TRUE;
d1327 1
a1327 1
	      add_needed = FALSE;
d1485 1
a1485 1
	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, FALSE);
d1514 1
a1514 1
		      return TRUE;
d1609 3
a1611 3
      bfd_boolean definition;
      bfd_boolean size_change_ok, type_change_ok;
      bfd_boolean new_weakdef;
d1613 1
a1613 1
      bfd_boolean override;
d1615 1
a1615 1
      override = FALSE;
d1711 1
a1711 1
	definition = FALSE;
d1713 1
a1713 1
	definition = TRUE;
d1715 1
a1715 1
      size_change_ok = FALSE;
d1824 1
a1824 1
	    definition = FALSE;
d1848 1
a1848 1
	      FALSE, collect, (struct bfd_link_hash_entry **) sym_hash)))
d1857 1
a1857 1
      new_weakdef = FALSE;
d1879 1
a1879 1
	  new_weakdef = TRUE;
d1899 1
a1899 1
	  bfd_boolean dynsym;
d1941 3
a1943 5
	      unsigned char hvis, symvis, other;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);
d1945 2
a1946 3
	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
d1948 6
a1953 1
	      h->other = other | (hvis > symvis ? hvis : symvis);
d1962 1
a1962 1
	  dynsym = FALSE;
d1976 1
a1976 1
		dynsym = TRUE;
d1989 1
a1989 1
		dynsym = TRUE;
d2022 1
a2022 1
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
d2040 1
a2040 1
	      dt_needed = FALSE;
d2043 1
a2043 1
					      elf_dt_soname (abfd), FALSE);
d2185 1
a2185 1
	  bfd_boolean ok;
d2279 1
a2279 1
  return TRUE;
d2288 1
a2288 1
  return FALSE;
d2298 1
a2298 1
bfd_boolean
d2310 1
a2310 1
    return FALSE;
d2313 1
a2313 1
    return TRUE;
d2333 1
a2333 1
	return FALSE;
d2343 1
a2343 1
	return FALSE;
d2353 1
a2353 1
    return FALSE;
d2359 1
a2359 1
    return FALSE;
d2365 1
a2365 1
    return FALSE;
d2371 1
a2371 1
    return FALSE;
d2376 1
a2376 1
    return FALSE;
d2383 1
a2383 1
	return FALSE;
d2390 1
a2390 1
    return FALSE;
d2403 2
a2404 2
	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
d2411 1
a2411 1
    return FALSE;
d2419 1
a2419 1
    return FALSE;
d2426 1
a2426 1
    return FALSE;
d2428 1
a2428 1
  elf_hash_table (info)->dynamic_sections_created = TRUE;
d2430 1
a2430 1
  return TRUE;
d2435 1
a2435 1
bfd_boolean
d2448 1
a2448 1
    return FALSE;
d2458 1
a2458 1
    return FALSE;
d2468 1
a2468 1
  return TRUE;
d2478 1
a2478 1
   Returns FALSE if something goes wrong.  */
d2480 1
a2480 1
static bfd_boolean
d2489 1
a2489 4
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;
d2493 1
a2493 1
    return TRUE;
d2497 1
a2497 1
    return FALSE;
d2501 1
a2501 1
    return FALSE;
d2507 28
a2534 3
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == sizeof (Elf_External_Rela))
    swap_in = bed->s->swap_reloca_in;
a2535 6
    abort ();

  erela = external_relocs;
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
  irela = internal_relocs;
  while (erela < erelaend)
d2537 16
a2552 3
      (*swap_in) (abfd, erela, irela);
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
d2555 1
a2555 1
  return TRUE;
d2575 1
a2575 1
     bfd_boolean keep_memory;
d2651 1
a2651 1
bfd_boolean
d2656 1
a2656 1
     bfd_boolean provide;
d2661 1
a2661 1
    return TRUE;
d2663 1
a2663 1
  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
d2665 1
a2665 1
    return FALSE;
d2696 1
a2696 1
	return FALSE;
d2705 1
a2705 1
	    return FALSE;
d2709 1
a2709 1
  return TRUE;
d2724 1
a2724 1
  bfd_boolean failed;
d2739 1
a2739 1
  bfd_boolean failed;
d2905 1
a2905 1
bfd_boolean
d2929 1
a2929 1
    return TRUE;
d2932 1
a2932 1
    return TRUE;
d2943 1
a2943 1
    return FALSE;
d2950 1
a2950 1
    return TRUE;
d2953 1
a2953 1
    return FALSE;
d2962 1
a2962 1
      bfd_boolean all_defined;
d2970 1
a2970 1
					     soname, TRUE);
d2974 1
a2974 1
	    return FALSE;
d2981 1
a2981 1
	    return FALSE;
d2990 1
a2990 1
				      TRUE);
d2998 1
a2998 1
	    return FALSE;
d3006 1
a3006 1
				      filter_shlib, TRUE);
d3009 1
a3009 1
	    return FALSE;
d3021 1
a3021 1
					  *p, TRUE);
d3025 1
a3025 1
		return FALSE;
d3031 1
a3031 1
      eif.failed = FALSE;
d3040 1
a3040 1
	    return FALSE;
d3057 1
a3057 1
	      newlen = namelen + verlen + 3;
d3061 1
a3061 1
		return FALSE;
d3069 2
a3070 2
					   newname, FALSE, FALSE,
					   FALSE);
d3079 2
a3080 2
					       newname, FALSE, FALSE,
					       FALSE);
d3098 1
a3098 1
      asvinfo.failed = FALSE;
d3104 1
a3104 1
	return FALSE;
d3109 1
a3109 1
	  all_defined = TRUE;
d3118 1
a3118 1
		  all_defined = FALSE;
d3124 1
a3124 1
	      return FALSE;
d3134 1
a3134 1
	return FALSE;
d3144 2
a3145 2
				   info->init_function, FALSE,
				   FALSE, FALSE)
d3152 1
a3152 1
	    return FALSE;
d3156 2
a3157 2
				   info->fini_function, FALSE,
				   FALSE, FALSE)
d3164 1
a3164 1
	    return FALSE;
d3188 1
a3188 1
	      return FALSE;
d3195 1
a3195 1
	    return FALSE;
d3203 1
a3203 1
	    return FALSE;
d3211 1
a3211 1
	    return FALSE;
d3230 1
a3230 1
	    return FALSE;
d3238 1
a3238 1
    return FALSE;
d3294 1
a3294 1
	    return FALSE;
d3323 1
a3323 1
					  name, FALSE);
d3325 1
a3325 1
		return FALSE;
d3352 1
a3352 1
		      (bfd_vma) 0, (const char *) NULL, FALSE,
d3354 1
a3354 1
		return FALSE;
d3362 1
a3362 1
		return FALSE;
d3423 1
a3423 1
	    return FALSE;
d3431 1
a3431 1
	    return FALSE;
d3442 1
a3442 1
	    return FALSE;
d3457 1
a3457 1
	sinfo.failed = FALSE;
d3490 1
a3490 1
	      return FALSE;
d3511 1
a3511 1
					    FALSE);
d3513 1
a3513 1
		  return FALSE;
d3530 1
a3530 1
						a->vna_nodename, FALSE);
d3532 1
a3532 1
		      return FALSE;
d3549 1
a3549 1
	      return FALSE;
d3578 1
a3578 1
	    return FALSE;
d3581 1
a3581 1
	    return FALSE;
d3595 1
a3595 1
	return FALSE;
d3621 1
a3621 1
	return FALSE;
d3639 1
a3639 1
	  return FALSE;
d3642 1
a3642 1
  return TRUE;
d3648 2
a3649 2
static bfd_boolean elf_adjust_dynstr_offsets
  PARAMS ((struct elf_link_hash_entry *, PTR));
d3651 1
a3651 1
static bfd_boolean
d3663 1
a3663 1
  return TRUE;
d3669 1
a3669 1
static bfd_boolean
d3789 1
a3789 1
  return TRUE;
d3798 1
a3798 1
static bfd_boolean
d3833 2
a3834 2
	      eif->failed = TRUE;
	      return FALSE;
d3887 1
a3887 1
      bfd_boolean force_local;
d3927 1
a3927 1
  return TRUE;
d3934 1
a3934 1
static bfd_boolean
d3956 1
a3956 1
    return TRUE;
d3959 1
a3959 1
    return FALSE;
d3963 1
a3963 1
    return FALSE;
d3979 1
a3979 1
      return TRUE;
d3985 1
a3985 1
    return TRUE;
d4030 1
a4030 1
	return FALSE;
d4049 2
a4050 2
      eif->failed = TRUE;
      return FALSE;
d4053 1
a4053 1
  return TRUE;
d4059 1
a4059 1
static bfd_boolean
d4068 1
a4068 1
    return TRUE;
d4096 1
a4096 1
		    return TRUE;
d4106 2
a4107 2
	      eif->failed = TRUE;
	      return FALSE;
d4112 1
a4112 1
  return TRUE;
d4120 1
a4120 1
static bfd_boolean
d4139 1
a4139 1
    return TRUE;
d4149 1
a4149 1
	  return TRUE;
d4162 2
a4163 2
	  rinfo->failed = TRUE;
	  return FALSE;
d4190 1
a4190 1
  return TRUE;
d4198 1
a4198 1
static bfd_boolean
d4217 1
a4217 1
  eif.failed = FALSE;
d4222 2
a4223 2
	sinfo->failed = TRUE;
      return FALSE;
d4229 1
a4229 1
    return TRUE;
d4236 1
a4236 1
      bfd_boolean hidden;
d4238 1
a4238 1
      hidden = TRUE;
d4245 1
a4245 1
	  hidden = FALSE;
d4254 1
a4254 1
	  return TRUE;
d4269 1
a4269 1
		return FALSE;
d4276 1
a4276 1
	      t->used = TRUE;
d4298 1
a4298 1
			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
d4321 1
a4321 1
	    return TRUE;
d4328 2
a4329 2
	      sinfo->failed = TRUE;
	      return FALSE;
d4338 1
a4338 1
	  t->used = TRUE;
d4360 2
a4361 2
	  sinfo->failed = TRUE;
	  return FALSE;
d4384 1
a4384 1
	      bfd_boolean matched;
d4386 1
a4386 1
	      matched = FALSE;
d4392 1
a4392 1
			matched = TRUE;
d4411 1
a4411 1
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
d4441 1
a4441 1
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
d4446 1
a4446 1
  return TRUE;
d4501 1
a4501 1
static bfd_boolean elf_link_output_sym
d4504 1
a4504 1
static bfd_boolean elf_link_flush_output_syms
d4506 1
a4506 1
static bfd_boolean elf_link_output_extsym
d4508 1
a4508 1
static bfd_boolean elf_link_sec_merge_syms
d4510 1
a4510 1
static bfd_boolean elf_link_check_versioned_symbol
d4512 1
a4512 1
static bfd_boolean elf_link_input_bfd
d4514 1
a4514 1
static bfd_boolean elf_reloc_link_order
d4522 2
a4523 2
  bfd_boolean failed;
  bfd_boolean localsyms;
d4530 1
a4530 1
static bfd_boolean
d4558 1
a4558 1
    return FALSE;
d4571 1
a4571 1
	return FALSE;
d4576 1
a4576 1
  return TRUE;
d4593 3
a4595 3
  bfd_byte *erela;
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d4597 2
a4598 1
  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
d4600 2
a4601 2
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
d4603 4
a4606 1
  else if (rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
d4608 2
a4609 2
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
a4610 2
  else
    abort ();
d4612 1
a4612 5
  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
a4613 3
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

d4619 43
a4661 5
      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
				      ELF_R_TYPE (irela[j].r_info));
      (*swap_out) (abfd, irela, erela);
d4663 3
d4672 6
a4677 2
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
d4696 1
a4696 1
  if (ELF_R_SYM (a->rela->r_info) < ELF_R_SYM (b->rela->r_info))
d4698 1
a4698 1
  if (ELF_R_SYM (a->rela->r_info) > ELF_R_SYM (b->rela->r_info))
d4700 1
a4700 1
  if (a->rela->r_offset < b->rela->r_offset)
d4702 1
a4702 1
  if (a->rela->r_offset > b->rela->r_offset)
d4726 1
a4726 1
  if (a->rela->r_offset < b->rela->r_offset)
d4728 1
a4728 1
  if (a->rela->r_offset > b->rela->r_offset)
d4741 1
d4743 2
a4744 3
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
a4746 2
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d4754 2
a4755 3
      ext_size = sizeof (Elf_External_Rel);
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
d4758 1
a4758 6
    {
      ext_size = sizeof (Elf_External_Rela);
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  count = reldyn->_raw_size / ext_size;
d4770 18
a4787 4
  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
  sort = bfd_zmalloc (sort_elt * count);
  if (sort == NULL)
d4800 15
a4814 1
	bfd_byte *erel, *erelend;
d4816 4
a4819 4
	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
d4821 16
a4836 5
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
	    p += sort_elt;
	    erel += ext_size;
d4840 14
a4853 21
  qsort (sort, (size_t) count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (ELF_R_SYM (sp->rela->r_info) != ELF_R_SYM (sq->rela->r_info))
	sq = sp;
      sp->offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, (size_t) count - ret, sort_elt, elf_link_sort_cmp2);
d4860 4
a4863 1
	bfd_byte *erel, *erelend;
d4865 13
a4877 4
	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
d4879 14
a4892 4
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
d4896 1
d4903 1
a4903 1
bfd_boolean
d4908 2
a4909 2
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
d4928 1
a4928 1
  bfd_boolean merged;
d4934 1
a4934 1
    return FALSE;
d4950 1
a4950 1
    return FALSE;
d4996 1
a4996 1
  merged = FALSE;
d5016 1
a5016 1
	      sec->linker_mark = TRUE;
d5019 1
a5019 1
		merged = TRUE;
d5207 1
a5207 1
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);
d5406 1
a5406 1
    sub->output_has_begun = FALSE;
d5420 1
a5420 1
		  sub->output_has_begun = TRUE;
d5443 1
a5443 1
  eoinfo.failed = FALSE;
d5445 1
a5445 1
  eoinfo.localsyms = TRUE;
d5449 1
a5449 1
    return FALSE;
d5537 2
a5538 2
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
d5543 1
a5543 1
    return FALSE;
d5549 3
a5551 2
      typedef bfd_boolean (*out_sym_func)
	PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *));
d5555 1
a5555 1
	return FALSE;
d5560 1
a5560 1
    return FALSE;
d5575 1
a5575 1
						       off, TRUE);
d5579 1
a5579 1
	return FALSE;
d5597 1
a5597 1
  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
d5604 1
a5604 1
	return FALSE;
d5681 1
a5681 1
					  FALSE, FALSE, TRUE);
d5843 1
a5843 1
      bfd_boolean failed = FALSE;
d5892 1
a5892 1
  elf_tdata (abfd)->linker = TRUE;
d5894 1
a5894 1
  return TRUE;
d5926 1
a5926 1
  return FALSE;
d5931 1
a5931 1
static bfd_boolean
d5940 6
a5945 3
  bfd_boolean (*output_symbol_hook)
    PARAMS ((bfd *, struct bfd_link_info *info, const char *,
	     Elf_Internal_Sym *, asection *));
d5953 1
a5953 1
	return FALSE;
d5963 1
a5963 1
							    name, TRUE, FALSE);
d5965 1
a5965 1
	return FALSE;
d5971 1
a5971 1
	return FALSE;
d5985 1
a5985 1
	    return FALSE;
d5996 1
a5996 1
  return TRUE;
d6001 1
a6001 1
static bfd_boolean
d6016 1
a6016 1
	return FALSE;
d6022 1
a6022 1
  return TRUE;
d6028 1
a6028 1
static bfd_boolean
d6052 1
a6052 1
  return TRUE;
d6059 1
a6059 1
static bfd_boolean
d6070 1
a6070 1
    return FALSE;
d6116 1
a6116 1
	return FALSE;
d6131 1
a6131 1
	  return FALSE;
d6165 1
a6165 1
	      return TRUE;
d6173 1
a6173 1
  return FALSE;
d6183 1
a6183 1
static bfd_boolean
d6190 1
a6190 1
  bfd_boolean strip;
d6198 1
a6198 1
	return TRUE;
d6205 1
a6205 1
	return TRUE;
d6210 1
a6210 1
	return TRUE;
d6230 1
a6230 1
	      (asection *) NULL, (bfd_vma) 0, TRUE)))
d6232 2
a6233 2
	  eoinfo->failed = TRUE;
	  return FALSE;
d6242 1
a6242 1
    strip = FALSE;
d6247 7
a6253 12
    strip = TRUE;
  else if (finfo->info->strip == strip_all)
    strip = TRUE;
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
    strip = TRUE;
d6255 1
a6255 1
    strip = FALSE;
d6262 1
a6262 1
    return TRUE;
d6281 1
a6281 1
      return FALSE;
d6305 2
a6306 2
		eoinfo->failed = TRUE;
		return FALSE;
d6348 1
a6348 1
      return TRUE;
d6367 2
a6368 2
	  eoinfo->failed = TRUE;
	  return FALSE;
d6392 2
a6393 1
  /* If a symbol is not defined locally, we clear the visibility field.  */
d6396 1
a6396 1
    sym.st_other &= ~ ELF_ST_VISIBILITY (-1);
d6460 1
a6460 1
    return TRUE;
d6466 2
a6467 2
      eoinfo->failed = TRUE;
      return FALSE;
d6470 1
a6470 1
  return TRUE;
d6477 1
a6477 1
static bfd_boolean
a6486 1
  bfd_byte *erel;
d6491 1
a6491 1
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d6517 1
a6517 1
      return FALSE;
a6520 9
  if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
d6524 35
a6558 1
  while (irela < irelaend)
d6560 10
a6569 3
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
d6576 1
a6576 1
  return TRUE;
d6584 1
a6584 1
static bfd_boolean
d6589 4
a6592 3
  bfd_boolean (*relocate_section)
    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d6604 1
a6604 1
  bfd_boolean emit_relocs;
d6615 1
a6615 1
    return TRUE;
d6642 1
a6642 1
	return FALSE;
d6735 1
a6735 1
	return FALSE;
d6739 1
a6739 1
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d6755 1
a6755 1
	return FALSE;
d6779 1
a6779 1
	return FALSE;
d6816 1
a6816 1
	    return FALSE;
d6826 1
a6826 1
			      finfo->internal_relocs, FALSE));
d6829 1
a6829 1
	    return FALSE;
d6874 2
a6875 2
				      TRUE)))
				return FALSE;
d6895 1
a6895 1
			      bfd_boolean ok;
d6910 1
a6910 1
							 TRUE);
d6914 1
a6914 1
				return FALSE;
d6946 1
a6946 1
	    return FALSE;
a6951 1
	      bfd_vma last_offset;
d6955 4
a6958 4
	      bfd_boolean (*reloc_emitter)
		PARAMS ((bfd *, asection *, Elf_Internal_Shdr *,
			 Elf_Internal_Rela *));
	      bfd_boolean rela_normal;
a6971 3
	      last_offset = o->output_offset;
	      if (!finfo->info->relocateable)
		last_offset += o->output_section->vma;
d6989 2
a6990 8
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 elf_bfd_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
d7000 1
a7000 1
		  last_offset = irela->r_offset;
d7002 1
a7002 2
		  r_symndx = ELF_R_SYM (irela->r_info);
		  if (r_symndx == STN_UNDEF)
d7055 1
a7055 1
			  return FALSE;
d7080 1
a7080 1
			      return FALSE;
d7090 1
a7090 1
			    return FALSE;
d7097 1
a7097 1
			    return FALSE;
d7116 1
a7116 1
			    return FALSE;
d7137 1
a7137 1
		return FALSE;
d7146 1
a7146 1
		    return FALSE;
d7164 1
a7164 1
	    return FALSE;
d7169 1
a7169 1
	    return FALSE;
d7175 1
a7175 1
	      return FALSE;
d7188 1
a7188 1
	      return FALSE;
d7194 1
a7194 1
  return TRUE;
d7202 1
a7202 1
static bfd_boolean
a7215 3
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;
d7221 1
a7221 1
      return FALSE;
d7245 1
a7245 1
					 FALSE, FALSE, TRUE));
d7273 1
a7273 1
	    return FALSE;
d7285 1
a7285 1
      bfd_boolean ok;
d7291 1
a7291 1
	return FALSE;
d7313 1
a7313 1
	      return FALSE;
d7321 1
a7321 1
	return FALSE;
d7331 1
a7331 7
  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  irel[0].r_info = ELF_R_INFO (indx, howto->type);
a7332 2
  rel_hdr = &elf_section_data (output_section)->rel_hdr;
  erel = rel_hdr->contents;
d7335 23
a7357 3
      erel += (elf_section_data (output_section)->rel_count
	       * sizeof (Elf_External_Rel));
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
d7361 22
a7382 4
      irel[0].r_addend = addend;
      erel += (elf_section_data (output_section)->rel_count
	       * sizeof (Elf_External_Rela));
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
d7387 1
a7387 1
  return TRUE;
d7392 1
a7392 1
bfd_boolean
d7414 1
a7414 1
	return TRUE;
d7421 1
a7421 1
	    return FALSE;
d7443 1
a7443 1
	    return FALSE;
d7454 1
a7454 1
	return TRUE;
d7475 1
a7475 1
    return FALSE;
d7480 1
a7480 1
  linker_section_ptr->written_address_p = FALSE;
d7515 1
a7515 1
  return TRUE;
d7568 1
a7568 1
	      linker_section_ptr->written_address_p = TRUE;
d7592 1
a7592 1
	  linker_section_ptr->written_address_p = TRUE;
d7599 2
a7600 2
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
d7603 9
d7625 3
a7627 7
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
d7629 3
a7631 3
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf_External_Rela));
d7633 3
d7658 1
a7658 1
static bfd_boolean elf_gc_mark
d7664 1
a7664 1
static bfd_boolean elf_gc_sweep
d7666 2
a7667 2
	   bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *,
			    const Elf_Internal_Rela *)));
d7669 1
a7669 1
static bfd_boolean elf_gc_sweep_symbol
d7672 1
a7672 1
static bfd_boolean elf_gc_allocate_got_offsets
d7675 1
a7675 1
static bfd_boolean elf_gc_propagate_vtable_entries_used
d7678 1
a7678 1
static bfd_boolean elf_gc_smash_unused_vtentry_relocs
d7685 1
a7685 5
typedef asection * (*gc_mark_hook_fn)
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean
d7689 4
a7692 1
     gc_mark_hook_fn gc_mark_hook;
d7694 1
a7694 1
  bfd_boolean ret;
d7703 1
a7703 1
      return FALSE;
d7706 1
a7706 1
  ret = TRUE;
d7736 1
a7736 1
	    return FALSE;
d7745 1
a7745 1
	  ret = FALSE;
d7777 1
a7777 1
		  ret = FALSE;
d7801 1
a7801 5
typedef bfd_boolean (*gc_sweep_hook_fn)
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_boolean
d7804 2
a7805 1
     gc_sweep_hook_fn gc_sweep_hook;
d7840 1
a7840 1
	      bfd_boolean r;
d7845 1
a7845 1
		return FALSE;
d7853 1
a7853 1
		return FALSE;
d7871 1
a7871 1
  return TRUE;
d7876 1
a7876 1
static bfd_boolean
d7892 1
a7892 1
  return TRUE;
d7898 1
a7898 1
static bfd_boolean
d7908 1
a7908 1
    return TRUE;
d7912 1
a7912 1
    return TRUE;
d7916 1
a7916 1
    return TRUE;
d7931 1
a7931 1
      bfd_boolean *cu, *pu;
d7935 1
a7935 1
      cu[-1] = TRUE;
d7947 1
a7947 1
		*cu = TRUE;
d7954 1
a7954 1
  return TRUE;
d7957 1
a7957 1
static bfd_boolean
d7974 1
a7974 1
    return TRUE;
d7984 1
a7984 1
	      (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL, TRUE));
d7986 1
a7986 1
    return *(bfd_boolean *) okp = FALSE;
d8007 1
a8007 1
  return TRUE;
d8012 1
a8012 1
bfd_boolean
d8017 1
a8017 1
  bfd_boolean ok = TRUE;
d8026 1
a8026 1
    return TRUE;
d8033 1
a8033 1
    return FALSE;
d8040 1
a8040 1
    return FALSE;
d8056 1
a8056 1
	      return FALSE;
d8062 1
a8062 1
    return FALSE;
d8064 1
a8064 1
  return TRUE;
d8069 1
a8069 1
bfd_boolean
d8106 1
a8106 1
  return FALSE;
d8121 1
a8121 1
  return TRUE;
d8126 1
a8126 1
bfd_boolean
d8139 1
a8139 1
      bfd_boolean *ptr = h->vtable_entries_used;
d8158 1
a8158 1
      bytes = (size / file_align + 1) * sizeof (bfd_boolean);
d8169 1
a8169 1
			  * sizeof (bfd_boolean));
d8177 1
a8177 1
	return FALSE;
d8184 1
a8184 1
  h->vtable_entries_used[addend / file_align] = TRUE;
d8186 1
a8186 1
  return TRUE;
d8192 1
a8192 1
bfd_boolean
d8245 1
a8245 1
  return TRUE;
d8251 1
a8251 1
static bfd_boolean
d8269 1
a8269 1
  return TRUE;
d8275 1
a8275 1
bfd_boolean
d8281 1
a8281 1
    return FALSE;
d8290 1
a8290 1
static bfd_boolean
d8306 1
a8306 1
    return TRUE;
d8331 1
a8331 1
  return TRUE;
d8334 1
a8334 1
bfd_boolean
d8350 1
a8350 1
	  return FALSE;
d8356 1
a8356 1
	return TRUE;
d8372 1
a8372 1
	    return TRUE;
d8374 1
a8374 1
	    return FALSE;
d8390 1
a8390 1
		return TRUE;
d8393 1
a8393 1
      return FALSE;
d8395 1
a8395 1
  return FALSE;
d8399 1
a8399 1
   Returns TRUE if any section's size was changed.  */
d8403 1
a8403 1
bfd_boolean
d8414 1
a8414 1
  bfd_boolean ret = FALSE;
d8419 1
a8419 1
    return FALSE;
d8471 1
a8471 1
	    return FALSE;
d8491 1
a8491 1
		ret = TRUE;
d8513 1
a8513 1
	    ret = TRUE;
d8522 1
a8522 1
	ret = TRUE;
d8536 1
a8536 1
    ret = TRUE;
d8541 1
a8541 1
static bfd_boolean
d8551 1
a8551 1
      return TRUE;
d8559 1
a8559 1
    return TRUE;
d8561 1
a8561 1
  return FALSE;
@


1.186.2.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1307 1
a1307 1
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d2237 1
a2237 1
		stab->sec_info_type = ELF_INFO_TYPE_STABS;
d2259 1
a2259 1
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
d2905 1
a2905 1
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;
a3911 3
  if (! is_elf_hash_table (eif->info))
    return FALSE;

d3914 2
a3915 2
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;
d3927 3
d3947 1
a3947 1
      h->plt = elf_hash_table (eif->info)->init_offset;
d5919 1
a5919 1
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d6525 1
a6525 1
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
d7018 1
a7018 1
      else switch (o->sec_info_type)
d8271 1
a8271 1
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
d8377 1
a8377 1
  switch (sec->sec_info_type)
@


1.186.2.7
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a1170 2
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
a1999 17
	  if (definition && (abfd->flags & DYNAMIC) == 0)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (! nondeflt_vers)
		    {
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
		      nondeflt_vers = bfd_malloc (amt);
		    }
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
		}
	    }

a2073 49
  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = bfd_malloc (amt + 1);
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (info->hash, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

a2279 2
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
d2512 1
a2512 4
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
a4880 1
      struct bfd_elf_section_data *esdo = elf_section_data (o);
a4884 4
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;
	  unsigned int *rel_count1;

d4887 1
a4887 1
	    reloc_count = 1;
a4892 1
	      esdi = elf_section_data (sec);
d4904 1
a4904 1
		reloc_count = sec->reloc_count;
d4913 2
a4914 1
		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);
a4956 50

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      BFD_ASSERT (entsize1 == sizeof (Elf_External_Rel)
			  || entsize1 == sizeof (Elf_External_Rela));
	      same_size = (!o->use_rela_p
			   == (entsize1 == sizeof (Elf_External_Rel)));

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == sizeof (Elf_External_Rel)
				  || entsize2 == sizeof (Elf_External_Rela)));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
	    }
	  *rel_count1 += reloc_count;
d4990 57
d6099 2
a6100 1
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
@


1.186.2.8
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1612 1
a1612 2
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
d1614 1
a1615 2
      unsigned int old_alignment;
      bfd *old_bfd;
a1719 2
      old_bfd = NULL;

d1837 3
a1839 17
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;
	    
	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }
a1895 2
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
a1903 47
	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overriden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if ((h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
	    }

d1910 1
a1910 1
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
d1912 1
a1912 3
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));
d1943 1
a1943 1
	      unsigned char hvis, symvis, other, nvis;
a1951 6
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;
d1953 1
a1953 1
	      h->other = other | nvis;
a4851 1
  free (sort);
d8332 3
a8334 4
      if (info->relocateable
	  || (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section))))
a8434 1
      && !info->relocateable
@


1.186.2.9
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d45 1
a45 1
	   bfd_boolean *, bfd_boolean *, bfd_boolean));
d466 1
a466 1
elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
a474 1
     bfd_boolean *skip;
a481 1
  struct elf_link_hash_entry *flip;
a485 1
  *skip = FALSE;
a607 51
  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
	    }
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
	}
    }

  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other)
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      return _bfd_elf_link_record_dynamic_symbol (info, h);
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }

a771 1
  flip = NULL;
d800 13
a812 7
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
d852 1
a852 22
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
d886 1
a886 1
     this case we prefer the definition in the shared object.  To make
a921 1
  bfd_boolean skip;
d977 1
a977 1
			  &hi, &skip, &override, &type_change_ok,
d1086 1
a1086 1
			  &hi, &skip, &override, &type_change_ok,
a1727 1
	  bfd_boolean skip;
d1825 2
a1826 3
				  sym_hash, &skip, &override,
				  &type_change_ok, &size_change_ok,
				  dt_needed))
a1828 3
	  if (skip)
	    continue;

d2008 3
a2010 4
	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (isym->st_other != 0 && !dynamic)
d2077 1
a2077 1
	  if (definition && !dynamic)
d6094 1
a6094 1
      || elf_dt_soname (undef_bfd) == NULL)
a6260 22
  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocateable
      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC
	     | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

d6421 1
a6421 2
  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
a6422 3
      && ELF_ST_VISIBILITY (sym.st_other)
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type != bfd_link_hash_undefweak
d6424 1
a6424 12
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }
@


1.186.2.10
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d23 10
d41 11
d54 8
d64 2
d68 4
d453 766
d1361 1
a1361 1
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1551 1
a1551 1
	if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1896 4
a1899 4
	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok,
				      dt_needed))
d2149 3
a2151 3
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override, dt_needed))
d2412 4
a2415 4
	  internal_relocs
	    = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
					 info->keep_memory);
d2511 6
a2516 1
/* Add an entry to the .dynamic table.  */
d2519 2
a2520 1
elf_add_dynamic_entry (info, tag, val)
a2521 2
     bfd_vma tag;
     bfd_vma val;
d2523 5
a2527 5
  Elf_Internal_Dyn dyn;
  bfd *dynobj;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
d2532 48
a2579 1
  dynobj = elf_hash_table (info)->dynobj;
d2581 5
a2585 2
  s = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);
d2587 4
a2590 3
  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
d2593 4
a2596 4
  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  elf_swap_dyn_out (dynobj, &dyn,
		    (Elf_External_Dyn *) (newcontents + s->_raw_size));
d2598 89
a2686 2
  s->_raw_size = newsize;
  s->contents = newcontents;
d2691 245
d3231 1
a3231 2
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
d3295 1
a3295 1
			      _bfd_elf_link_assign_sym_version,
d3325 1
a3325 1
			      _bfd_elf_adjust_dynamic_symbol,
d3654 1
a3654 1
				_bfd_elf_link_find_version_dependencies,
d3850 556
a4405 1
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
d4410 9
a4418 4
  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}
d4420 4
a4423 2
/* Assign string offsets in .dynstr, update all structures referencing
   them.  */
d4425 6
a4430 11
static bfd_boolean
elf_finalize_dynstr (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *sdyn;
  bfd_size_type size;
  Elf_External_Dyn *dyncon, *dynconend;
d4432 1
a4432 2
  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);
d4434 8
a4441 3
  /* Update all .dynamic entries referencing .dynstr strings.  */
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);
d4443 7
a4449 6
  dyncon = (Elf_External_Dyn *) sdyn->contents;
  dynconend = (Elf_External_Dyn *) (sdyn->contents +
				    sdyn->_raw_size);
  for (; dyncon < dynconend; dyncon++)
    {
      Elf_Internal_Dyn dyn;
d4451 2
a4452 2
      elf_swap_dyn_in (dynobj, dyncon, & dyn);
      switch (dyn.d_tag)
d4454 49
a4502 15
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
	  break;
	default:
	  break;
a4503 1
    }
d4505 52
a4556 4
  /* Now update local dynamic symbols.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);
d4558 3
a4560 3
  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_adjust_dynstr_offsets, dynstr);
d4562 3
a4564 2
  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
d4566 3
a4568 5
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;
d4570 5
a4574 3
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = (bfd_byte *) s->contents;
      do
d4576 33
a4608 4
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
d4610 15
a4624 7
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
a4626 11
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;
d4628 1
a4628 3
      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = (bfd_byte *) s->contents;
      do
d4630 4
a4633 7
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
d4635 1
a4635 8
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
a4637 1
      while (need.vn_next);
d4702 2
d4721 52
d5141 3
a5143 4
		  relocs
		    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
						 (Elf_Internal_Rela *) NULL,
						 info->keep_memory);
d5261 1
a5261 1
			    _bfd_elf_link_sec_merge_syms, (PTR) abfd);
d5277 3
a5279 2
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
d5283 3
a5285 2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
d5310 1
a5310 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d5920 1
a5920 1
		 created by _bfd_elf_link_create_dynamic_sections.  */
d6127 30
d6159 1
a6159 3
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */
d6166 1
a6166 1
  bfd *abfd;
d6169 3
a6171 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
a6173 24
  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

d6193 1
a6193 1
      if (input == abfd
a6241 1
	  unsigned short version_index;
d6262 1
a6262 2
	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
d6264 1
a6264 1
	      /* This is the base or first version.  We can use it.  */
d6345 1
a6345 2
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, h))
d6485 1
a6485 3
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
d6523 1
a6523 1
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
d6525 1
a6525 1
      && h->root.type == bfd_link_hash_undefined
d6615 75
d6910 1
a6910 1
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
d6934 3
a6936 3
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
d7253 1
a7253 1
		reloc_emitter = _bfd_elf_link_output_relocs;
d7827 3
a7829 3
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d7932 2
a7933 4
	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d8031 1
a8031 1
	  unsigned int log_file_align = bed->s->log_file_align;
d8033 1
a8033 1
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
d8056 1
a8056 1
  unsigned int log_file_align;
d8073 2
a8074 2
  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL,
					(Elf_Internal_Rela *) NULL, TRUE);
d8078 1
a8078 1
  log_file_align = bed->s->log_file_align;
d8089 1
a8089 1
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
d8224 1
a8224 1
  unsigned int log_file_align = bed->s->log_file_align;
d8248 1
a8248 1
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);
d8258 1
a8258 1
	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
d8274 1
a8274 1
  h->vtable_entries_used[addend >> log_file_align] = TRUE;
d8570 3
a8572 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, stab, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
d8593 3
a8595 4
	    cookie.rels
	      = _bfd_elf_link_read_relocs (abfd, eh, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   info->keep_memory);
@


1.186.2.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d466 1
a466 1
      if (info->relocatable || info->hash->creator != abfd->xvec)
d477 1
a477 1
  if (info->executable)
d537 1
a537 1
	      if (! info->relocatable)
d1324 1
a1324 1
	      if (! info->executable
d1661 1
a1661 1
  if (! info->relocatable && ! dynamic
a1939 37
  if (info->execstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags & DYNAMIC)
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else
	    exec = PF_X;
	}
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
    }

d2177 1
a2177 1
	  if (! info->executable)
d2443 1
a2443 1
	  if (info->executable)
d2875 1
a2875 1
/* When performing a relocatable link, the input relocations are
d3152 1
a3152 1
  emit_relocs = (info->relocatable
d3237 1
a3237 1
	      if (info->relocatable || info->emitrelocations)
d3362 1
a3362 1
  if (! info->relocatable && merged)
d3490 1
a3490 1
	  if (info->relocatable || o == NULL)
d3601 1
a3601 1
     we are generating relocatable output, and we see a reloc against
d3607 1
a3607 1
     it.  Fortunately, it only happens when performing a relocatable
d4047 1
a4047 1
  if (info->relocatable)
d4419 2
a4420 3
  if (! finfo->info->relocatable
      && (finfo->info->executable
	  || ! finfo->info->allow_shlib_undefined)
d4437 1
a4437 1
  if (! finfo->info->relocatable
d4535 2
a4536 2
	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
d4539 1
a4539 1
	    if (! finfo->info->relocatable)
d4622 1
a4622 1
  if (! finfo->info->relocatable
d4752 1
a4752 1
  emit_relocs = (finfo->info->relocatable
d4847 1
a4847 1
	 output this one.  If we are generating a relocatable output
d4862 1
a4862 1
	      || (! finfo->info->relocatable
d4877 1
a4877 1
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
d4894 1
a4894 1
      /* ELF symbols in relocatable files are section relative, but
d4902 1
a4902 1
      if (! finfo->info->relocatable)
d4970 3
a4972 3
	     link-once sections.  Preserve debug information as much
	     as we can.  */
	  if (!elf_section_ignore_discarded_relocs (o))
a4980 1
		  asection *sec;
a4994 1
		      sec = h->root.u.def.section;
d4997 1
a4997 1
			  && elf_discarded_section (sec))
d5002 1
a5002 8
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
d5005 7
a5011 7
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
d5016 1
a5016 1
		      sec = finfo->sections[r_symndx];
d5024 3
a5026 12
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info
				    = ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
				  rel->r_addend = 0;
				}
d5030 17
a5046 14
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
d5048 2
d5060 1
a5060 1
	     and generating a relocatable output file) adjusting the
d5070 1
a5070 1
	     When generating relocatable output, the back end routine
d5109 1
a5109 1
	      if (!finfo->info->relocatable)
d5142 1
a5142 1
		  if (!finfo->info->relocatable)
d5246 1
a5246 1
			  if (! finfo->info->relocatable)
d5274 1
a5274 1
		  && !(finfo->info->relocatable
d5474 1
a5474 1
     relocatable file, and is a virtual address in an executable
d5477 1
a5477 1
  if (! info->relocatable)
d6141 1
a6141 1
      || info->relocatable || info->emitrelocations
d6255 1
a6255 1
      size_t size, bytes, file_align;
a6259 1
      file_align = 1 << log_file_align;
d6261 1
a6261 1
	size = addend + file_align;
d6265 1
a6265 1
	  if (addend >= size)
d6269 1
a6269 1
	      size = addend + file_align;
a6271 1
      size = (size + file_align - 1) & -file_align;
d6549 1
a6549 1
      if (info->relocatable
d6655 1
a6655 1
      && !info->relocatable
@


1.186.2.12
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d23 25
a47 7
static bfd_boolean elf_link_add_object_symbols (bfd *, struct bfd_link_info *);
static bfd_boolean elf_link_add_archive_symbols (bfd *,
						 struct bfd_link_info *);
static bfd_boolean elf_finalize_dynstr (bfd *, struct bfd_link_info *);
static bfd_boolean elf_collect_hash_codes (struct elf_link_hash_entry *,
					   void *);
static bfd_boolean elf_section_ignore_discarded_relocs (asection *);
d53 3
a55 1
elf_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d71 3
a73 2
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
d112 3
a114 1
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
d126 1
a126 1
  if (abfd == NULL)
d177 1
a177 1
      if (name == NULL)
d218 3
a220 1
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
d232 1
a232 1
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
d246 3
a248 3
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
d300 1
a300 1
	      copy = bfd_alloc (abfd, len);
d352 1
a352 1
	  if (element == NULL)
d411 1
a411 1
  if (defined != NULL)
d413 1
a413 1
  if (included != NULL)
d421 3
a423 1
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
d426 2
a427 2
    (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
d429 2
a430 1
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
a489 2
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");
d523 1
a523 2
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
d527 1
a527 2
	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
d530 1
a530 1
	      msg[prefix_len + sz] = '\0';
d533 2
a534 2
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, collect, NULL)))
d611 1
a611 1
	  dynbuf = bfd_malloc (s->_raw_size);
d615 2
a616 1
	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d645 1
a645 1
		  n = bfd_alloc (abfd, amt);
d653 1
a653 1
		  memcpy (anm, fnm, amt);
d670 1
a670 1
		  n = bfd_alloc (abfd, amt);
d678 1
a678 1
		  memcpy (anm, fnm, amt);
d696 1
a696 1
		  n = bfd_alloc (abfd, amt);
d708 1
a708 1
		  memcpy (anm, fnm, amt);
d791 1
a791 1
	  if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
d839 1
a839 1
      sym_hash = bfd_alloc (abfd, amt);
d858 1
a858 1
	  extversym = bfd_malloc (versymhdr->sh_size);
d863 1
a863 1
	      || bfd_bread (extversym, amt, abfd) != amt)
d944 1
a944 1
      if (name == NULL)
d972 1
a972 1
	  if (name == NULL)
d977 1
a977 1
      if (sec == NULL)
d1077 1
a1077 1
		  newname = bfd_alloc (abfd, newlen);
d1142 2
a1143 2
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
d1438 1
a1438 1
	      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
d1611 4
a1614 2
	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
d1687 2
a1688 1
      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
d1713 4
a1716 1
elf_add_dynamic_entry (struct bfd_link_info *info, bfd_vma tag, bfd_vma val)
d1733 1
a1733 1
  newcontents = bfd_realloc (s->contents, newsize);
d1769 2
a1770 1
compute_bucket_count (struct bfd_link_info *info)
d1784 1
a1784 1
  hashcodes = bfd_malloc (amt);
d1817 1
a1817 1
      counts = bfd_malloc (amt);
d1912 12
a1923 8
NAME(bfd_elf,size_dynamic_sections) (bfd *output_bfd,
				     const char *soname,
				     const char *rpath,
				     const char *filter_shlib,
				     const char * const *auxiliary_filters,
				     struct bfd_link_info *info,
				     asection **sinterpptr,
				     struct bfd_elf_version_tree *verdefs)
d2015 2
a2016 1
	      || ! elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
d2022 2
a2023 1
	  if (! elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
d2037 1
a2037 1
	      || ! elf_add_dynamic_entry (info, DT_RPATH, indx)
d2039 2
a2040 1
		  && ! elf_add_dynamic_entry (info, DT_RUNPATH, indx)))
d2051 1
a2051 1
	      || ! elf_add_dynamic_entry (info, DT_FILTER, indx))
d2066 2
a2067 1
		  || ! elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
d2082 1
a2082 1
				  &eif);
d2103 1
a2103 1
	      newname = bfd_malloc (newlen);
d2146 1
a2146 1
			      &asvinfo);
d2176 1
a2176 1
			      &eif);
d2195 1
a2195 1
	  if (! elf_add_dynamic_entry (info, DT_INIT, 0))
d2207 1
a2207 1
	  if (! elf_add_dynamic_entry (info, DT_FINI, 0))
d2235 4
a2238 2
	  if (!elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
d2243 4
a2246 2
	  if (!elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
d2251 4
a2254 2
	  if (!elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
d2268 6
a2273 6
	  if (! elf_add_dynamic_entry (info, DT_HASH, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || ! elf_add_dynamic_entry (info, DT_SYMENT,
					  sizeof (Elf_External_Sym)))
d2336 1
a2336 1
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
d2396 1
a2396 1
		      0, NULL, FALSE,
d2464 3
a2466 2
	  if (! elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || ! elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
d2474 1
a2474 1
	  if (! elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
d2484 2
a2485 1
	  if (! elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
d2505 1
a2505 1
				&sinfo);
d2532 1
a2532 1
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
d2589 4
a2592 2
	    if (! elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| ! elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
d2620 1
a2620 1
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d2624 1
a2624 1
	  if (! elf_add_dynamic_entry (info, DT_VERSYM, 0))
d2637 1
a2637 1
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
d2652 1
a2652 1
	  elf_swap_symbol_out (output_bfd, &isym, s->contents, 0);
d2663 1
a2663 1
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d2667 3
a2669 2
      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
d2682 1
a2682 1
	if (! elf_add_dynamic_entry (info, DT_NULL, 0))
d2692 3
d2696 3
a2698 1
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
d2700 1
a2700 1
  struct elf_strtab_hash *dynstr = data;
d2714 3
a2716 1
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
d2859 1
a2859 1
  void *external_relocs;
d2889 2
a2890 1
  (struct elf_final_link_info *, const char *, Elf_Internal_Sym *, asection *);
d2892 1
a2892 1
  (struct elf_final_link_info *);
d2894 3
a2896 1
  (struct elf_link_hash_entry *, void *);
d2898 1
a2898 1
  (struct elf_final_link_info *, bfd *);
d2900 2
a2901 1
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
d2918 5
a2922 4
elf_link_adjust_relocs (bfd *abfd,
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
d2927 2
a2928 2
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d2974 3
a2976 1
elf_link_sort_cmp1 (const void *A, const void *B)
d2978 2
a2979 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d3001 3
a3003 1
elf_link_sort_cmp2 (const void *A, const void *B)
d3005 2
a3006 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d3027 4
a3030 1
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
d3032 2
a3033 1
  asection *reldyn;
d3040 2
a3041 3
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
d3062 5
a3066 6
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	asection *o = lo->u.indirect.section;
	size += o->_raw_size;
      }
d3077 2
a3078 1
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
d3082 4
a3085 2
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
a3087 1
	asection *o = lo->u.indirect.section;
d3102 1
a3102 1
  qsort (sort, count, sort_elt, elf_link_sort_cmp1);
d3122 1
a3122 1
  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);
d3124 4
a3127 2
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
a3129 1
	asection *o = lo->u.indirect.section;
d3151 3
a3153 1
elf_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
d3227 1
a3227 1
  for (o = abfd->sections; o != NULL; o = o->next)
d3244 1
a3244 1
  for (o = abfd->sections; o != NULL; o = o->next)
d3280 4
a3283 2
		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						      info->keep_memory);
d3401 1
a3401 1
			    _bfd_elf_link_sec_merge_syms, abfd);
d3465 1
a3465 1
  finfo.symbuf = bfd_malloc (amt);
d3474 1
a3474 1
      finfo.symshndxbuf = bfd_zmalloc (amt);
d3489 2
a3490 1
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr))
d3531 2
a3532 1
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o))
d3543 1
a3543 1
      finfo.contents = bfd_malloc (max_contents_size);
d3550 1
a3550 1
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
d3559 1
a3559 1
      finfo.internal_relocs = bfd_malloc (amt);
d3567 1
a3567 1
      finfo.external_syms = bfd_malloc (amt);
d3572 1
a3572 1
      finfo.internal_syms = bfd_malloc (amt);
d3577 1
a3577 1
      finfo.indices = bfd_malloc (amt);
d3582 1
a3582 1
      finfo.sections = bfd_malloc (amt);
d3590 1
a3590 1
      finfo.locsym_shndx = bfd_malloc (amt);
d3691 1
a3691 1
			  &eoinfo);
d3731 1
a3731 1
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d3772 1
a3772 1
	      elf_swap_symbol_out (abfd, &sym, dest, 0);
d3785 1
a3785 1
			  &eoinfo);
d3794 1
a3794 1
	(void *, const char *, Elf_Internal_Sym *, asection *);
d3797 1
a3797 1
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
d3821 1
a3821 1
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
d4175 5
a4179 4
elf_link_output_sym (struct elf_final_link_info *finfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec)
d4184 2
a4185 2
    (bfd *, struct bfd_link_info *info, const char *,
     Elf_Internal_Sym *, asection *);
d4196 1
a4196 1
  if (name == NULL || *name == '\0')
d4232 1
a4232 1
  elf_swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
d4242 2
a4243 1
elf_link_flush_output_syms (struct elf_final_link_info *finfo)
d4255 1
a4255 1
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
d4272 3
a4274 2
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
d4354 1
a4354 1
      extversym = bfd_malloc (versymhdr->sh_size);
d4359 1
a4359 1
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
d4420 3
a4422 1
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
d4424 1
a4424 1
  struct elf_outext_info *eoinfo = data;
d4466 1
a4466 1
	      NULL, 0, TRUE)))
d4693 1
a4693 1
      elf_swap_symbol_out (finfo->output_bfd, &sym, esym, 0);
d4702 2
a4703 1
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
d4759 3
a4761 1
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
d4764 2
a4765 2
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d4853 1
a4853 1
					  isym->st_value, 0);
d4987 2
a4988 2
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
d5143 2
a5144 1
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
d5400 5
a5404 4
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
d5471 2
a5472 1
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
d5489 2
a5490 2
      buf = bfd_zmalloc (size);
      if (buf == NULL)
d5492 1
a5492 1
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
d5509 2
a5510 1
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
d5517 2
a5518 2
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
d5560 258
d5820 11
d5832 1
a5832 1
  (struct elf_link_hash_entry *, void *);
d5835 7
a5841 1
  (struct elf_link_hash_entry *, void *);
d5848 2
a5849 2
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
d5852 4
a5855 3
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
d5903 2
a5904 1
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
d5965 2
a5966 1
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d5969 3
a5971 1
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
d6009 2
a6010 1
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
d6032 3
a6034 1
    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);
d6045 3
a6047 1
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
d6049 1
a6049 1
  int *idx = idxptr;
d6067 3
a6069 1
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
d6126 3
a6128 1
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
d6151 2
a6152 1
  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
d6181 3
a6183 1
elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
d6188 2
a6189 2
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);
d6199 1
a6199 1
			  &ok);
d6206 1
a6206 1
			  &ok);
d6238 5
a6242 4
elf_gc_record_vtinherit (bfd *abfd,
			 asection *sec,
			 struct elf_link_hash_entry *h,
			 bfd_vma offset)
d6295 5
a6299 4
elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *sec ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       bfd_vma addend)
d6332 1
a6332 1
	  ptr = bfd_realloc (ptr - 1, bytes);
d6344 1
a6344 1
	ptr = bfd_zmalloc (bytes);
d6363 3
a6365 2
elf_gc_common_finalize_got_offsets (bfd *abfd,
				    struct bfd_link_info *info)
d6414 1
a6414 1
			  &gotoff);
d6422 3
a6424 1
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *offarg)
d6426 1
a6426 1
  bfd_vma *off = offarg;
d6446 3
a6448 1
elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
d6461 3
a6463 1
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
d6465 1
a6465 1
  unsigned long **valuep = data;
d6482 2
a6483 2
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
d6505 3
a6507 1
elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
d6509 1
a6509 1
  struct elf_reloc_cookie *rcookie = cookie;
d6574 3
a6576 1
elf_bfd_discard_info (bfd *output_bfd, struct bfd_link_info *info)
d6650 4
a6653 2
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
d6674 4
a6677 2
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
d6716 2
a6717 1
elf_section_ignore_discarded_relocs (asection *sec)
@


1.186.2.13
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d418 1
a418 1
  const struct elf_backend_data *bed;
d1189 1
a1189 2
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
d1891 1
a1891 1
  const struct elf_backend_data *bed;
d2862 1
a2862 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2967 1
a2967 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3099 1
a3099 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4366 11
a4376 5
  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
d4379 1
a4379 2
      && ! elf_link_check_versioned_symbol (finfo->info, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
d4383 1
a4383 1
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
d4393 1
a4393 1
      && (! finfo->info->shared)
d4395 2
a4396 1
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
d4544 1
a4544 1
      const struct elf_backend_data *bed;
d4690 1
a4690 1
  const struct elf_backend_data *bed;
d5324 1
a5324 1
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
d5512 1
a5512 1
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
d5730 3
a5732 2
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;
a5733 2
	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
d5754 1
a5754 1
  const struct elf_backend_data *bed;
d5917 1
a5917 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5983 1
a5983 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6186 1
a6186 1
  const struct elf_backend_data *bed;
d6319 1
a6319 1
  const struct elf_backend_data *bed;
@


1.186.2.14
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a22 2
#include "safe-ctype.h"

a1261 4
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

d1610 21
a1630 26
      asection *stabstr;
      
      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;
		
		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd,
					       & hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
d1973 1
a1973 1
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);
d2050 2
a2051 2
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->symbol)
d2058 1
a2058 1
	      name = d->symbol;
d2116 3
a2118 2
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (!d->symver && !d->script)
d2365 1
a2365 1
	      if (t->globals.list == NULL && t->locals.list == NULL && ! t->used)
d2797 2
d3153 8
d3518 1
a3518 1
  if (elf_hash_table (info)->tls_sec)
d3520 2
a3521 1
      bfd_vma base, end = 0;
d3524 1
a3524 1
      for (sec = elf_hash_table (info)->tls_sec;
d3530 3
a3532 1
	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
d3536 1
d3543 7
a3549 3
      base = elf_hash_table (info)->tls_sec->vma;
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
d4496 2
a4497 2
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
d4855 2
a4856 2
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
d5212 2
a5213 4
				  BFD_ASSERT (elf_hash_table (finfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (finfo->info)
						   ->tls_sec->vma);
@


1.186.2.15
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d440 1
a440 3
      if (info->relocatable
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
d478 1
a478 1
	      if (dynamic)
d534 3
a536 3
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
d542 1
a542 1
  else if (!is_elf_hash_table (hash_table))
d726 3
a728 2
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;
d878 1
a878 1
	     point to the first global symbol.  Unfortunately, Irix 5
d971 1
a971 1
      if (is_elf_hash_table (hash_table))
d1134 1
a1134 1
	  && is_elf_hash_table (hash_table)
d1170 1
a1170 1
      if (is_elf_hash_table (hash_table))
d1177 1
a1177 1
	     can change when a common symbol is overridden by a normal
d1383 3
d1449 1
a1449 1
	       bfd_link_hash_lookup (&hash_table->root, shortname,
d1576 1
a1576 2
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
d1612 2
a1613 1
      && is_elf_hash_table (hash_table)
d1646 2
a1647 3
  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
d1667 1
a1667 1
  if (is_elf_hash_table (hash_table))
d1705 1
a1705 1
  if (! is_elf_hash_table (info->hash))
d1835 1
a1835 1
	     of all the chain lengths (which favors many small chain
d1910 4
a1913 1
  if (!is_elf_hash_table (info->hash))
d2059 1
a2059 1
      /* Make all global versions with definition.  */
d2124 1
a2124 1
	  /* Check if all global versions have a definition.  */
d2840 1
a2840 2
  (struct elf_final_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
d3115 1
a3115 1
  if (! is_elf_hash_table (info->hash))
d3414 1
a3414 2
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
d3430 1
a3430 1
			     &elfsym, bfd_abs_section_ptr, NULL))
d3455 1
a3455 1
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
d3709 1
a3709 2
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);
d4093 1
a4093 2
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
d4098 2
a4099 2
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
d4105 2
a4106 1
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
d4191 1
a4191 1
  if (!is_elf_hash_table (info->hash))
d4647 1
a4647 1
  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
d4852 1
a4852 1
      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
d5214 1
a5214 2
			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
d5677 1
a5677 1
/* Propagate collected vtable information.  This is called through
d5800 1
a5800 3
      || info->relocatable
      || info->emitrelocations
      || !is_elf_hash_table (info->hash)
d5843 1
a5843 1
/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */
d5899 1
a5899 1
/* Called from check_relocs to record the existence of a VTENTRY reloc.  */
a5975 3
  if (! is_elf_hash_table (info->hash))
    return FALSE;

d6182 2
a6183 1
      || !is_elf_hash_table (info->hash))
@


1.186.2.16
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d5804 1
a5804 4
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }
@


1.185
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d3889 4
a3894 1
      weakdef = h->weakdef;
@


1.184
log
@2002-08-13  H.J. Lu <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.
@
text
@d1047 1
a1047 1
      (*bed->elf_backend_copy_indirect_symbol) (ht, hi);
d1119 1
a1119 1
	  (*bed->elf_backend_copy_indirect_symbol) (h, hi);
d3906 1
a3906 1
	  (*bed->elf_backend_copy_indirect_symbol) (weakdef, h);
@


1.183
log
@2002-08-12  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.
@
text
@d3071 2
a3072 1
	      /* Mark this version if there is a definition.  */
d3074 2
@


1.182
log
@2002-08-08  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.
@
text
@d902 1
a902 1
   symbol is described by H, NAME, SYM, SEC, VALUE, and OVERRIDE.  We
d907 1
a907 1
elf_add_default_symbol (abfd, info, h, name, sym, sec, value,
d914 1
a914 1
     asection **sec;
d929 1
d974 2
a975 1
  if (! elf_merge_symbol (abfd, info, shortname, sym, sec, value,
d1082 2
a1083 1
  if (! elf_merge_symbol (abfd, info, shortname, sym, sec, value,
@


1.181
log
@Check symbols with undefine version.
@
text
@d1088 7
a1094 4
	 the type of override we do in the case above.  */
      (*_bfd_error_handler)
	(_("%s: warning: unexpected redefinition of `%s'"),
	 bfd_archive_filename (abfd), shortname);
@


1.180
log
@	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.
@
text
@d2941 3
d3024 48
d3084 22
a4333 1
	error_return:
d4358 3
d4365 12
a4376 3
		      h->verinfo.vertree = t;
		      local_ver = NULL;
		      break;
d4382 4
a4416 37
	}

      /* We need to check if a hidden versioned definition should
	 hide the default one.  */
      if (h->dynindx != -1 && h->verinfo.vertree != NULL)
	{
	  const char *verstr, *name;
	  size_t namelen, verlen, newlen;
	  char *newname;
	  struct elf_link_hash_entry *newh;

	  name = h->root.root.string;
	  namelen = strlen (name);
	  verstr = h->verinfo.vertree->name;
	  verlen = strlen (verstr);
	  newlen = namelen + verlen + 2;

	  newname = (char *) bfd_malloc ((bfd_size_type) newlen);
	  if (newname == NULL)
	    goto error_return;
	  memcpy (newname, name, namelen);

	  /* Check the hidden versioned definition.  */
	  p = newname + namelen;
	  *p++ = ELF_VER_CHR;
	  memcpy (p, verstr, verlen + 1);
	  newh = elf_link_hash_lookup (elf_hash_table (info), newname,
				       false, false, false);

	  if (newh
	      && (newh->root.type == bfd_link_hash_defined
		  || newh->root.type == bfd_link_hash_defweak))
	    /* We found a hidden versioned definition.  Hide the
	       default one.  */
	    (*bed->elf_backend_hide_symbol) (info, h, true);

	  free (newname);
@


1.179
log
@	* elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
	as elf_link_record_local_dynamic_symbol.
	(_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
	(elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
	* elflink.h (elf_link_record_local_dynamic_symbol): Move to..
	* elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
	attempt is made to record a symbol in a discarded section, and
	return `2' in that case.
@
text
@d6345 1
a6345 1
  if (strip)
@


1.178
log
@	* elflink.h (elf_link_input_bfd): Don't change internal symbols
	when outputting relocs.
@
text
@a2450 87

/* Record a new local dynamic symbol.  */

boolean
elf_link_record_local_dynamic_symbol (info, input_bfd, input_indx)
     struct bfd_link_info *info;
     bfd *input_bfd;
     long input_indx;
{
  struct elf_link_local_dynamic_entry *entry;
  struct elf_link_hash_table *eht;
  struct elf_strtab_hash *dynstr;
  Elf_External_Sym esym;
  Elf_External_Sym_Shndx eshndx;
  Elf_External_Sym_Shndx *shndx;
  unsigned long dynstr_index;
  char *name;
  file_ptr pos;
  bfd_size_type amt;

  if (! is_elf_hash_table (info))
    return false;

  /* See if the entry exists already.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)
      return true;

  entry = (struct elf_link_local_dynamic_entry *)
    bfd_alloc (input_bfd, (bfd_size_type) sizeof (*entry));
  if (entry == NULL)
    return false;

  /* Go find the symbol, so that we can find it's name.  */
  amt = sizeof (Elf_External_Sym);
  pos = elf_tdata (input_bfd)->symtab_hdr.sh_offset + input_indx * amt;
  if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
      || bfd_bread ((PTR) &esym, amt, input_bfd) != amt)
    return false;
  shndx = NULL;
  if (elf_tdata (input_bfd)->symtab_shndx_hdr.sh_size != 0)
    {
      amt = sizeof (Elf_External_Sym_Shndx);
      pos = elf_tdata (input_bfd)->symtab_shndx_hdr.sh_offset;
      pos += input_indx * amt;
      shndx = &eshndx;
      if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx, amt, input_bfd) != amt)
	return false;
    }
  elf_swap_symbol_in (input_bfd, (const PTR) &esym, (const PTR) shndx,
		      &entry->isym);

  name = (bfd_elf_string_from_elf_section
	  (input_bfd, elf_tdata (input_bfd)->symtab_hdr.sh_link,
	   entry->isym.st_name));

  dynstr = elf_hash_table (info)->dynstr;
  if (dynstr == NULL)
    {
      /* Create a strtab to hold the dynamic symbol names.  */
      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
      if (dynstr == NULL)
	return false;
    }

  dynstr_index = _bfd_elf_strtab_add (dynstr, name, false);
  if (dynstr_index == (unsigned long) -1)
    return false;
  entry->isym.st_name = dynstr_index;

  eht = elf_hash_table (info);

  entry->next = eht->dynlocal;
  eht->dynlocal = entry;
  entry->input_bfd = input_bfd;
  entry->input_indx = input_indx;
  eht->dynsymcount++;

  /* Whatever binding the symbol had before, it's now local.  */
  entry->isym.st_info
    = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (entry->isym.st_info));

  /* The dynindx will be set at the end of size_dynamic_sections.  */

  return true;
}
@


1.177
log
@	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.
@
text
@d6970 1
d7023 1
a7023 1
		  isym = isymbuf + r_symndx;
d7025 1
a7025 1
		  if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
d7072 1
a7072 1
				  (input_bfd, shlink, isym->st_name));
d7077 1
a7077 1
			  isym->st_shndx =
d7080 1
a7080 1
			  if (isym->st_shndx == SHN_BAD)
d7083 1
a7083 1
			  isym->st_value += sec->output_offset;
d7086 2
a7087 2
			      isym->st_value += osec->vma;
			      if (ELF_ST_TYPE (isym->st_info) == STT_TLS)
d7092 1
a7092 1
				  isym->st_value -= finfo->first_tls_sec->vma;
d7099 1
a7099 1
			  if (! elf_link_output_sym (finfo, name, isym, sec))
@


1.176
log
@	* elflink.h (elf_link_input_bfd): Don't call reloc_emitter when
	reloc section size is zero.  Correct reloc output location.
@
text
@d346 1
a346 1
	        {
d2855 3
a2857 3
/* We have a problem here.  The following code to optimize the table
   size requires an integer type with more the 32 bits.  If
   BFD_HOST_U_64_BIT is set we know about such a type.  */
d3175 1
a3175 1
			  bfd_archive_filename (sub));
d4031 1
a4031 1
	 h->root.root.string);
d4091 1
a4091 1
doit:
d4348 1
a4348 1
error_return:
d4362 1
a4362 1
      struct bfd_elf_version_tree *deflt;
d4368 1
a4368 1
      deflt = NULL;
d4378 1
d4391 2
d4394 1
a4394 1
		    deflt = t;
d4397 1
a4397 7
		      h->verinfo.vertree = t;
		      if (h->dynindx != -1
			  && info->shared
			  && ! info->export_dynamic)
			{
			  (*bed->elf_backend_hide_symbol) (info, h, true);
			}
d4407 1
a4407 1
      if (deflt != NULL && h->verinfo.vertree == NULL)
d4409 1
a4409 1
	  h->verinfo.vertree = deflt;
d4443 1
a4443 1
				    false, false, false);
d4448 2
a4449 2
	    /* We find a hidden versioned definition. Hide the default
	       one.  */
d4663 1
a4663 1
				       ELF_R_TYPE (irela[j].r_info));
d4676 2
a4677 1
struct elf_link_sort_rela {
d4680 2
a4681 1
  union {
d5355 1
a5355 1
	      size = o->offset + o->size;
d5494 2
a5495 2
		   && (e->isym.st_shndx < SHN_LORESERVE
		       || e->isym.st_shndx > SHN_HIRESERVE))
d6484 5
a6488 5
      (*_bfd_error_handler) (
        _("%s: relocation size mismatch in %s section %s"),
        bfd_get_filename (output_bfd),
        bfd_archive_filename (input_section->owner),
        input_section->name);
d6495 2
a6496 2
  irelaend = irela + NUM_SHDR_ENTRIES (input_rel_hdr)
		     * bed->s->int_rels_per_ext_rel;
a7130 1

d7647 4
a7650 4
  PARAMS ((struct bfd_link_info *info, asection *sec,
	   asection * (*gc_mark_hook)
	     PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
		      struct elf_link_hash_entry *, Elf_Internal_Sym *))));
d7653 3
a7655 4
  PARAMS ((struct bfd_link_info *info,
	   boolean (*gc_sweep_hook)
	     PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *o,
		      const Elf_Internal_Rela *relocs))));
d7658 1
a7658 1
  PARAMS ((struct elf_link_hash_entry *h, PTR idxptr));
d7661 1
a7661 1
  PARAMS ((struct elf_link_hash_entry *h, PTR offarg));
d7664 1
a7664 1
  PARAMS ((struct elf_link_hash_entry *h, PTR dummy));
d7667 1
a7667 1
  PARAMS ((struct elf_link_hash_entry *h, PTR dummy));
d7677 4
a7680 3
     asection * (*gc_mark_hook)
       PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
		struct elf_link_hash_entry *, Elf_Internal_Sym *));
d7792 2
a7793 3
     boolean (*gc_sweep_hook)
       PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *o,
		const Elf_Internal_Rela *relocs));
@


1.175
log
@bfd/
2002-07-14  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_link_assign_sym_version): Hide the default
	definition if there is a hidden versioned definition.

ld/
2002-07-14  H.J. Lu <hjl@@gnu.org>

	* ld.texinfo: Document a .symver takes precedence over a
	version script.
@
text
@d6948 1
a6948 1
	      Elf_Internal_Shdr *input_rel_hdr;
d7118 3
a7120 2
	      if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
				      internal_relocs))
d7123 2
a7124 2
	      input_rel_hdr = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr)
d7128 1
a7128 1
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
@


1.174
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d4348 1
d4419 37
@


1.174.2.1
log
@	* elflink.h (elf_link_input_bfd): Don't call reloc_emitter when
	reloc section size is zero.  Correct reloc output location.

	Merge from mainline.
	2002-07-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_link_assign_sym_version): Hide the default
	definition if there is a hidden versioned definition.
@
text
@a4347 1
error_return:
a4418 37

      /* We need to check if a hidden versioned definition should
	 hide the default one.  */
      if (h->dynindx != -1 && h->verinfo.vertree != NULL)
	{
	  const char *verstr, *name;
	  size_t namelen, verlen, newlen;
	  char *newname;
	  struct elf_link_hash_entry *newh;

	  name = h->root.root.string;
	  namelen = strlen (name);
	  verstr = h->verinfo.vertree->name;
	  verlen = strlen (verstr);
	  newlen = namelen + verlen + 2;

	  newname = (char *) bfd_malloc ((bfd_size_type) newlen);
	  if (newname == NULL)
	    goto error_return;
	  memcpy (newname, name, namelen);

	  /* Check the hidden versioned definition.  */
	  p = newname + namelen;
	  *p++ = ELF_VER_CHR;
	  memcpy (p, verstr, verlen + 1);
	  newh = elf_link_hash_lookup (elf_hash_table (info), newname,
				    false, false, false);

	  if (newh
	      && (newh->root.type == bfd_link_hash_defined
		  || newh->root.type == bfd_link_hash_defweak))
	    /* We find a hidden versioned definition. Hide the default
	       one.  */
	    (*bed->elf_backend_hide_symbol) (info, h, true);

	  free (newname);
	}
d6910 1
a6910 1
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
d7080 2
a7081 3
	      if (input_rel_hdr->sh_size != 0
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
d7084 2
a7085 2
	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
d7089 1
a7089 1
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
@


1.174.2.2
log
@	* elflink.h (elf_link_input_bfd): Don't change internal symbols
	when outputting relocs.
@
text
@a6970 1
		  Elf_Internal_Sym sym;
d7023 1
a7023 1
		  sym = isymbuf[r_symndx];
d7025 1
a7025 1
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
d7072 1
a7072 1
				  (input_bfd, shlink, sym.st_name));
d7077 1
a7077 1
			  sym.st_shndx =
d7080 1
a7080 1
			  if (sym.st_shndx == SHN_BAD)
d7083 1
a7083 1
			  sym.st_value += sec->output_offset;
d7086 2
a7087 2
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
d7092 1
a7092 1
				  sym.st_value -= finfo->first_tls_sec->vma;
d7099 1
a7099 1
			  if (! elf_link_output_sym (finfo, name, &sym, sec))
@


1.174.2.3
log
@        Merge from mainline:
        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * po/sv.po: Updated Swedish translation.

        2002-07-30  Jakub Jelinek  <jakub@@redhat.com>
        * elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

        2002-07-26  Chris Demetriou  <cgd@@broadcom.com>
        * elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Merge ASE
        flags into resulting BFD.

        2002-07-25  Alan Modra  <amodra@@bigpond.net.au>
        * elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
        as elf_link_record_local_dynamic_symbol.
        (_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
        (elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
        * elflink.h (elf_link_record_local_dynamic_symbol): Move to..
        * elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
        attempt is made to record a symbol in a discarded section, and
        return `2' in that case.
@
text
@d2451 87
@


1.174.2.4
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d1045 1
a1045 1
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);
d1113 1
a1113 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
d3824 1
a3824 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
@


1.174.2.5
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d346 1
a346 1
		{
d902 1
a902 1
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
d907 1
a907 1
elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
d914 1
a914 1
     asection **psec;
a928 1
  asection *sec;
d973 1
a973 2
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
d1080 1
a1080 2
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
d1088 4
a1091 7
	 the type of override we do in the case above unless it is
	 overridden by a versioned definiton.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
d2768 3
a2770 3
  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
a2940 3
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      boolean all_defined;
a3020 51
      /* Make all global versions with definiton.  */
      for (t = verdefs; t != NULL; t = t->next)
	for (d = t->globals; d != NULL; d = d->next)
	  if (!d->symver && strchr (d->pattern, '*') == NULL)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;
	      struct elf_link_hash_entry *newh;

	      name = d->pattern;
	      namelen = strlen (name);
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3; 

	      newname = (char *) bfd_malloc ((bfd_size_type) newlen);
	      if (newname == NULL)
		return false;
	      memcpy (newname, name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, false, false,
					   false);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, false, false,
					       false);
		}
	      free (newname);

	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
	      if (newh != NULL
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

a3032 22
      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definiton.  */
	  all_defined = true;
	  for (t = verdefs; t != NULL; t = t->next)
	    for (d = t->globals; d != NULL; d = d->next)
	      if (!d->symver && !d->script
		  && strchr (d->pattern, '*') == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = false;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	}

d3088 1
a3088 1
			 bfd_archive_filename (sub));
d3944 1
a3944 1
       h->root.root.string);
d4004 1
a4004 1
	doit:
d4261 1
d4275 1
a4275 1
      struct bfd_elf_version_tree *local_ver;
d4281 1
a4281 1
      local_ver = NULL;
a4285 3
	      boolean matched;

	      matched = false;
d4290 2
a4291 12
		      if (d->symver)
			matched = true;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
a4296 4
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, true);
a4302 2
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.  */
d4304 1
a4304 1
		    local_ver = t;
d4307 7
a4313 1
		      local_ver = t;
d4323 1
a4323 1
      if (local_ver != NULL)
d4325 1
a4325 1
	  h->verinfo.vertree = local_ver;
d4333 37
d4579 1
a4579 1
					  ELF_R_TYPE (irela[j].r_info));
d4592 1
a4592 2
struct elf_link_sort_rela
{
d4595 1
a4595 2
  union
  {
d5269 1
a5269 1
		  size = o->offset + o->size;
d5408 2
a5409 2
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
d6346 1
a6346 1
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
d6398 5
a6402 5
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
d6409 2
a6410 2
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
d7046 1
d7563 4
a7566 4
  PARAMS ((struct bfd_link_info *, asection *,
	   asection * (*) (asection *, struct bfd_link_info *,
			   Elf_Internal_Rela *, struct elf_link_hash_entry *,
			   Elf_Internal_Sym *)));
d7569 4
a7572 3
  PARAMS ((struct bfd_link_info *,
	   boolean (*) (bfd *, struct bfd_link_info *, asection *,
			const Elf_Internal_Rela *)));
d7575 1
a7575 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7578 1
a7578 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7581 1
a7581 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7584 1
a7584 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7594 3
a7596 4
     asection * (*gc_mark_hook) PARAMS ((asection *, struct bfd_link_info *,
					 Elf_Internal_Rela *,
					 struct elf_link_hash_entry *,
					 Elf_Internal_Sym *));
d7708 3
a7710 2
     boolean (*gc_sweep_hook) PARAMS ((bfd *, struct bfd_link_info *,
				       asection *, const Elf_Internal_Rela *));
d8425 1
a8425 6
	    {
	      /* Relocs have been edited.  Ensure edited version is
		 used later in relocate_section.  */
	      elf_section_data (eh)->relocs = cookie.rels;
	      ret = true;
	    }
@


1.174.2.6
log
@	* elflink.h (elf_link_input_bfd): Remove BFD_VERSION_DATE dependent
	code.
@
text
@d6815 1
d6818 6
d6828 1
d6844 1
d6848 6
d6860 1
@


1.174.2.7
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a923 1
  struct bfd_link_hash_entry *bh;
a981 1
      bh = &hi->root;
d984 2
a985 1
	      (bfd_vma) 0, name, false, collect, &bh)))
a986 1
      hi = (struct elf_link_hash_entry *) bh;
a1100 1
      bh = &hi->root;
d1103 2
a1104 1
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
a1105 1
      hi = (struct elf_link_hash_entry *) bh;
a2294 1
  struct bfd_link_hash_entry *bh;
d2387 1
a2387 1
  bh = NULL;
d2390 2
a2391 1
	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
a2392 1
  h = (struct elf_link_hash_entry *) bh;
a3328 1
	      struct bfd_link_hash_entry *bh;
d3335 1
a3335 1
	      bh = NULL;
d3339 2
a3340 1
		      get_elf_backend_data (dynobj)->collect, &bh)))
a3341 1
	      h = (struct elf_link_hash_entry *) bh;
@


1.174.2.8
log
@Merge from mainline.
@
text
@a1300 8
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;
d1330 2
d1348 2
d1393 7
d1413 1
a1413 1
		  for (pn = & runpath;
d1418 2
d1445 1
a1445 1
		  for (pn = & rpath;
d1450 1
a1454 15
	}

      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
@


1.174.2.9
log
@When examining weak symbols follow indirect links.
@
text
@a3902 4
      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

d3905 1
@


1.174.2.10
log
@        * elflink.h (elf_link_add_object_symbols): Don't overwrite the
        arch's st_other bits when merging visibilities.
        (elf_link_output_extsym): Tidy clearing of visibility field.
@
text
@d1941 3
a1943 5
	      unsigned char hvis, symvis, other;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);
d1945 2
a1946 3
	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
d1948 6
a1953 1
	      h->other = other | (hvis > symvis ? hvis : symvis);
d6355 2
a6356 1
  /* If a symbol is not defined locally, we clear the visibility field.  */
d6359 1
a6359 1
    sym.st_other &= ~ ELF_ST_VISIBILITY (-1);
@


1.173
log
@	* elflink.h (elf_link_add_object_symbols): Revert 1999-09-02 hpux
	fudge.
	* elf.c (bfd_section_from_shdr): Work around broken hpux shared
	libs here instead.
@
text
@a151 6
  Elf_Internal_Shdr * shndx_hdr;
  Elf_External_Sym *  esym;
  Elf_External_Sym *  esymend;
  Elf_External_Sym *  buf = NULL;
  Elf_External_Sym_Shndx * shndx_buf = NULL;
  Elf_External_Sym_Shndx * shndx;
d155 4
a158 3
  boolean result = false;
  file_ptr pos;
  bfd_size_type amt;
d176 1
a176 4
    {
      hdr = &elf_tdata (abfd)->symtab_hdr;
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
    }
d178 1
a178 4
    {
      hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      shndx_hdr = NULL;
    }
d195 8
a202 24
  amt = extsymcount * sizeof (Elf_External_Sym);
  buf = (Elf_External_Sym *) bfd_malloc (amt);
  if (buf == NULL && extsymcount != 0)
    return false;

  /* Read in the symbol table.
     FIXME:  This ought to be cached somewhere.  */
  pos = hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread ((PTR) buf, amt, abfd) != amt)
    goto error_exit;

  if (shndx_hdr != NULL && shndx_hdr->sh_size != 0)
    {
      amt = extsymcount * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL && extsymcount != 0)
	goto error_exit;

      pos = shndx_hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym_Shndx);
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	goto error_exit;
    }
d205 2
a206 4
  esymend = buf + extsymcount;
  for (esym = buf, shndx = shndx_buf;
       esym < esymend;
       esym++, shndx = (shndx != NULL ? shndx + 1 : NULL))
d208 1
a208 2
      Elf_Internal_Sym sym;
      const char * name;
d210 2
a211 3
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link, sym.st_name);
d217 1
a217 1
	  result = is_global_data_symbol_definition (abfd, & sym);
d222 1
a222 5
 error_exit:
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (buf != NULL)
    free (buf);
a1153 1
  Elf_Internal_Shdr *shndx_hdr;
a1156 3
  Elf_External_Sym *buf = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_External_Sym_Shndx *shndx;
a1160 1
  Elf_External_Dyn *dynbuf = NULL;
d1162 3
a1164 2
  Elf_External_Sym *esym;
  Elf_External_Sym *esymend;
a1167 1
  file_ptr pos;
a1265 77
  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    {
      hdr = &elf_tdata (abfd)->symtab_hdr;
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
    }
  else
    {
      hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      shndx_hdr = NULL;
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */

      if (! _bfd_elf_slurp_version_tables (abfd))
	goto error_return;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_return;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) extversym, amt, abfd) != amt)
	    goto error_return;
	}
    }

  symcount = hdr->sh_size / sizeof (Elf_External_Sym);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  amt = extsymcount * sizeof (Elf_External_Sym);
  buf = (Elf_External_Sym *) bfd_malloc (amt);
  if (buf == NULL && extsymcount != 0)
    goto error_return;

  if (shndx_hdr != NULL && shndx_hdr->sh_size != 0)
    {
      amt = extsymcount * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL && extsymcount != 0)
	goto error_return;
    }

  /* We store a pointer to the hash table entry for each external
     symbol.  */
  amt = extsymcount * sizeof (struct elf_link_hash_entry *);
  sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
  if (sym_hash == NULL)
    goto error_return;
  elf_sym_hashes (abfd) = sym_hash;

a1266 1

d1316 1
d1330 1
a1330 1
	    goto error_return;
d1334 1
a1334 1
	    goto error_return;
d1351 1
a1351 1
		    goto error_return;
d1363 1
a1363 1
		    goto error_return;
d1367 1
a1367 1
		    goto error_return;
d1395 1
a1395 1
		    goto error_return;
d1399 1
a1399 1
		    goto error_return;
d1423 1
a1423 1
		    goto error_return;
d1427 5
a1431 1
		    goto error_return;
a1445 1
	  dynbuf = NULL;
a1494 4
		      if (buf != NULL)
			free (buf);
		      if (extversym != NULL)
			free (extversym);
d1512 25
a1536 5
  pos = hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym);
  amt = extsymcount * sizeof (Elf_External_Sym);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread ((PTR) buf, amt, abfd) != amt)
    goto error_return;
d1538 2
a1539 1
  if (shndx_hdr != NULL && shndx_hdr->sh_size != 0)
d1541 3
a1543 4
      amt = extsymcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym_Shndx);
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
d1545 31
d1581 3
a1583 5
  esymend = buf + extsymcount;
  for (esym = buf, shndx = shndx_buf;
       esym < esymend;
       esym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL),
	 shndx = (shndx != NULL ? shndx + 1 : NULL))
a1584 1
      Elf_Internal_Sym sym;
a1598 2
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);

d1601 1
a1601 1
      value = sym.st_value;
d1604 1
a1604 1
      bind = ELF_ST_BIND (sym.st_info);
d1615 2
a1616 2
	  if (sym.st_shndx != SHN_UNDEF
	      && sym.st_shndx != SHN_COMMON)
d1626 1
a1626 1
      if (sym.st_shndx == SHN_UNDEF)
d1628 1
a1628 1
      else if (sym.st_shndx < SHN_LORESERVE || sym.st_shndx > SHN_HIRESERVE)
d1630 1
a1630 1
	  sec = section_from_elf_index (abfd, sym.st_shndx);
d1636 1
a1636 1
      else if (sym.st_shndx == SHN_ABS)
d1638 1
a1638 1
      else if (sym.st_shndx == SHN_COMMON)
d1643 1
a1643 1
	  value = sym.st_size;
d1650 2
a1651 1
      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link, sym.st_name);
d1653 1
a1653 1
	goto error_return;
d1655 2
a1656 1
      if (sym.st_shndx == SHN_COMMON && ELF_ST_TYPE (sym.st_info) == STT_TLS)
d1668 1
a1668 1
		goto error_return;
d1674 1
a1674 1
	  if (! (*add_symbol_hook) (abfd, info, &sym, &name, &flags, &sec,
d1676 1
a1676 1
	    goto error_return;
d1688 1
a1688 1
	  goto error_return;
d1722 1
a1722 1
		  if (sym.st_shndx != SHN_UNDEF)
d1731 1
a1731 1
			  goto error_return;
d1771 1
a1771 1
			  goto error_return;
d1779 1
a1779 1
		      && sym.st_shndx != SHN_UNDEF)
d1784 1
a1784 1
		    goto error_return;
d1792 1
a1792 1
		      && sym.st_shndx != SHN_UNDEF)
d1800 1
a1800 1
	  if (! elf_merge_symbol (abfd, info, name, &sym, &sec, &value,
d1803 1
a1803 1
	    goto error_return;
d1831 1
a1831 1
	goto error_return;
d1843 1
a1843 1
	  && ELF_ST_TYPE (sym.st_info) != STT_FUNC
d1865 1
a1865 1
      if (sym.st_shndx == SHN_COMMON
d1870 1
a1870 1
	  align = bfd_log2 (sym.st_value);
d1874 1
a1874 1
	      || (sym.st_value == 1 && old_alignment == 0))
d1885 1
a1885 1
	  if (sym.st_size != 0
d1888 1
a1888 1
	      if (h->size != 0 && h->size != sym.st_size && ! size_change_ok)
d1891 2
a1892 2
		   name, (unsigned long) h->size, (unsigned long) sym.st_size,
		   bfd_archive_filename (abfd));
d1894 1
a1894 1
	      h->size = sym.st_size;
d1905 1
a1905 1
	  if (ELF_ST_TYPE (sym.st_info) != STT_NOTYPE
d1909 1
a1909 1
		  && h->type != ELF_ST_TYPE (sym.st_info)
d1913 1
a1913 1
		   name, h->type, ELF_ST_TYPE (sym.st_info),
d1916 1
a1916 1
	      h->type = ELF_ST_TYPE (sym.st_info);
d1921 1
a1921 1
	  if (sym.st_other != 0)
d1925 1
a1925 1
	      unsigned char symvis = ELF_ST_VISIBILITY (sym.st_other);
d1928 1
a1928 1
		h->other = sym.st_other;
d1935 1
a1935 1
		h->other = sym.st_other;
d1979 1
a1979 1
	    if (! elf_add_default_symbol (abfd, info, h, name, &sym,
d1982 1
a1982 1
	      goto error_return;
d1987 1
a1987 1
		goto error_return;
d1993 1
a1993 1
		    goto error_return;
d2016 1
a2016 1
		goto error_return;
d2027 1
a2027 1
		goto error_return;
d2053 1
a2053 1
		goto error_return;
d2058 10
a2134 1

a2139 12
  if (buf != NULL)
    {
      free (buf);
      buf = NULL;
    }

  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

d2185 1
a2185 1
	  if (! info->keep_memory)
d2264 1
a2264 5
 error_return:
  if (buf != NULL)
    free (buf);
  if (dynbuf != NULL)
    free (dynbuf);
d2267 4
d4980 1
a4980 1
		  if (!info->keep_memory)
a6001 2
  Elf_External_Sym *buf;
  Elf_External_Versym *extversym;
d6018 3
d6022 1
a6022 4
      Elf_External_Sym *esym;
      Elf_External_Sym *esymend;
      bfd_size_type count;
      file_ptr pos;
d6049 3
a6051 3
      count = extsymcount * sizeof (Elf_External_Sym);
      buf = (Elf_External_Sym *) bfd_malloc (count);
      if (buf == NULL)
a6053 6
      /* Read in the symbol table.  */
      pos = hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym);
      if (bfd_seek (input, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) buf, count, input) != count)
	goto error_ret;

d6066 1
a6066 1
	  free (buf);
d6071 2
a6072 2
      esymend = buf + extsymcount;
      for (esym = buf; esym < esymend; esym++, ever++)
a6074 1
	  Elf_Internal_Sym sym;
d6077 2
a6078 3
	  elf_swap_symbol_in (input, esym, NULL, &sym);
	  if (ELF_ST_BIND (sym.st_info) == STB_LOCAL
	      || sym.st_shndx == SHN_UNDEF)
d6083 1
a6083 1
						  sym.st_name);
d6100 1
a6100 1
	      free (buf);
d6106 1
a6106 1
      free (buf);
a6530 1
  Elf_Internal_Shdr *shndx_hdr;
d6533 1
a6533 5
  Elf_External_Sym *external_syms;
  Elf_External_Sym *esym;
  Elf_External_Sym *esymend;
  Elf_External_Sym_Shndx *shndx_buf;
  Elf_External_Sym_Shndx *shndx;
d6535 1
d6570 2
a6571 5
  if (symtab_hdr->contents != NULL)
    external_syms = (Elf_External_Sym *) symtab_hdr->contents;
  else if (locsymcount == 0)
    external_syms = NULL;
  else
d6573 5
a6577 4
      bfd_size_type amt = locsymcount * sizeof (Elf_External_Sym);
      external_syms = finfo->external_syms;
      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (external_syms, amt, input_bfd) != amt)
d6581 7
a6587 19
  shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
  shndx_buf = NULL;
  if (shndx_hdr->sh_size != 0 && locsymcount != 0)
    {
      bfd_size_type amt = locsymcount * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = finfo->locsym_shndx;
      if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (shndx_buf, amt, input_bfd) != amt)
	return false;
    }

  /* Swap in the local symbols and write out the ones which we know
     are going into the output file.  */
  for (esym = external_syms, esymend = esym + locsymcount,
	 isym = finfo->internal_syms, pindex = finfo->indices,
	 ppsection = finfo->sections, shndx = shndx_buf;
       esym < esymend;
       esym++, isym++, pindex++, ppsection++,
	 shndx = (shndx != NULL ? shndx + 1 : NULL))
a6592 2
      elf_swap_symbol_in (input_bfd, (const PTR) esym, (const PTR) shndx,
			  isym);
d6631 1
a6631 1
      if (esym == external_syms)
d6901 1
a6901 1
				     finfo->internal_syms,
d6985 1
a6985 1
		  isym = finfo->internal_syms + r_symndx;
a7661 1
      Elf_Internal_Shdr *shndx_hdr;
a7664 2
      Elf_External_Sym *locsyms, *freesyms = NULL;
      Elf_External_Sym_Shndx *locsym_shndx;
d7667 1
a7667 3

      /* GCFIXME: how to arrange so that relocs and symbols are not
	 reread continually?  */
d7681 2
a7682 20
      if (symtab_hdr->contents)
	locsyms = (Elf_External_Sym *) symtab_hdr->contents;
      else if (nlocsyms == 0)
	locsyms = NULL;
      else
	{
	  bfd_size_type amt = nlocsyms * sizeof (Elf_External_Sym);
	  locsyms = freesyms = bfd_malloc (amt);
	  if (freesyms == NULL
	      || bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (locsyms, amt, input_bfd) != amt)
	    {
	      ret = false;
	      goto out1;
	    }
	}

      shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
      locsym_shndx = NULL;
      if (shndx_hdr->sh_size != 0 && nlocsyms != 0)
d7684 3
a7686 4
	  bfd_size_type amt = nlocsyms * sizeof (Elf_External_Sym_Shndx);
	  locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (locsym_shndx, amt, input_bfd) != amt)
d7692 1
a7692 1
		  (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL,
a7705 2
	  Elf_Internal_Sym s;
	  Elf_External_Sym_Shndx *locshndx;
d7711 2
a7712 16
	  if (elf_bad_symtab (sec->owner))
	    {
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
	      elf_swap_symbol_in (input_bfd,
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
				  &s);
	      if (ELF_ST_BIND (s.st_info) == STB_LOCAL)
		rsec = (*gc_mark_hook) (sec, info, rel, NULL, &s);
	      else
		{
		  h = sym_hashes[r_symndx - extsymoff];
		  rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
		}
	    }
	  else if (r_symndx >= nlocsyms)
d7719 1
a7719 6
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
	      elf_swap_symbol_in (input_bfd,
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
				  &s);
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &s);
d7735 1
a7735 1
      if (!info->keep_memory)
d7738 7
a7744 2
      if (freesyms)
	free (freesyms);
d7801 1
a7801 1
	      if (!info->keep_memory)
a8298 1
      Elf_Internal_Sym isym;
a8305 13
      if (rcookie->locsyms && r_symndx < rcookie->locsymcount)
	{
	  Elf_External_Sym *lsym;
	  Elf_External_Sym_Shndx *lshndx;

	  lsym = (Elf_External_Sym *) rcookie->locsyms + r_symndx;
	  lshndx = (Elf_External_Sym_Shndx *) rcookie->locsym_shndx;
	  if (lshndx != NULL)
	    lshndx += r_symndx;
	  elf_swap_symbol_in (rcookie->abfd, (const PTR) lsym,
			      (const PTR) lshndx, &isym);
	}

d8307 1
a8307 2
	  || (rcookie->locsyms
	      && ELF_ST_BIND (isym.st_info) != STB_LOCAL))
d8324 1
a8324 1
      else if (rcookie->locsyms)
d8330 1
d8333 2
a8334 1
	  if (isym.st_shndx < SHN_LORESERVE || isym.st_shndx > SHN_HIRESERVE)
d8336 1
a8336 1
	      isec = section_from_elf_index (rcookie->abfd, isym.st_shndx);
a8358 2
  Elf_Internal_Shdr *shndx_hdr;
  Elf_External_Sym *freesyms;
a8408 2
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;

d8424 2
a8425 6
      freesyms = NULL;
      if (symtab_hdr->contents)
	cookie.locsyms = (void *) symtab_hdr->contents;
      else if (cookie.locsymcount == 0)
	cookie.locsyms = NULL;
      else
d8427 3
a8429 2
	  bfd_size_type amt = cookie.locsymcount * sizeof (Elf_External_Sym);
	  cookie.locsyms = bfd_malloc (amt);
a8431 24
	  freesyms = cookie.locsyms;
	  if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (cookie.locsyms, amt, abfd) != amt)
	    {
	    error_ret_free_loc:
	      free (cookie.locsyms);
	      return false;
	    }
	}

      cookie.locsym_shndx = NULL;
      if (shndx_hdr->sh_size != 0 && cookie.locsymcount != 0)
	{
	  bfd_size_type amt;
	  amt = cookie.locsymcount * sizeof (Elf_External_Sym_Shndx);
	  cookie.locsym_shndx = bfd_malloc (amt);
	  if (cookie.locsym_shndx == NULL)
	    goto error_ret_free_loc;
	  if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (cookie.locsym_shndx, amt, abfd) != amt)
	    {
	      free (cookie.locsym_shndx);
	      goto error_ret_free_loc;
	    }
d8437 1
a8437 2
			 (abfd, stab, (PTR) NULL,
			  (Elf_Internal_Rela *) NULL,
d8449 1
a8449 1
	      if (! info->keep_memory)
d8473 1
a8473 1
	  if (! info->keep_memory)
d8483 8
a8490 5
      if (cookie.locsym_shndx != NULL)
	free (cookie.locsym_shndx);

      if (freesyms != NULL)
	free (freesyms);
@


1.172
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a1453 17
	  {
	    /* The shared libraries distributed with hpux11 have a bogus
	       sh_link field for the ".dynamic" section.  This code detects
	       when SHLINK refers to a section that is not a string table
	       and tries to find the string table for the ".dynsym" section
	       instead.  */
	    Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[shlink];
	    if (shdr->sh_type != SHT_STRTAB)
	      {
		asection *ds = bfd_get_section_by_name (abfd, ".dynsym");
		int elfdsec = _bfd_elf_section_from_bfd_section (abfd, ds);
		if (elfdsec == -1)
		  goto error_return;
		shlink = elf_elfsections (abfd)[elfdsec]->sh_link;
	      }
	  }

@


1.171
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d7732 1
a7732 1
	     PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d7762 1
a7762 1
       PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d7865 1
a7865 1
		rsec = (*gc_mark_hook) (sec->owner, info, rel, NULL, &s);
d7869 1
a7869 1
		  rsec = (*gc_mark_hook) (sec->owner, info, rel, h, NULL);
d7875 1
a7875 1
	      rsec = (*gc_mark_hook) (sec->owner, info, rel, h, NULL);
d7884 1
a7884 1
	      rsec = (*gc_mark_hook) (sec->owner, info, rel, NULL, &s);
d8132 1
a8132 1
    PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
@


1.170
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d963 1
d976 1
a976 1
	 need to crreate the indirect symbol from the default name.  */
d995 2
a996 2
  shortname = bfd_hash_allocate (&info->hash->table,
				 (size_t) (p - name + 1));
d999 2
a1000 2
  strncpy (shortname, name, (size_t) (p - name));
  shortname [p - name] = '\0';
d1105 2
a1106 1
  shortname = bfd_hash_allocate (&info->hash->table, strlen (name));
d1109 2
a1110 2
  strncpy (shortname, name, (size_t) (p - name));
  strcpy (shortname + (p - name), p + 1);
d1498 2
a1499 1
		  anm = bfd_alloc (abfd, (bfd_size_type) strlen (fnm) + 1);
d1502 1
a1502 1
		  strcpy (anm, fnm);
d1530 2
a1531 1
		  anm = bfd_alloc (abfd, (bfd_size_type) strlen (fnm) + 1);
d1534 1
a1534 1
		  strcpy (anm, fnm);
d1558 2
a1559 1
		  anm = bfd_alloc (abfd, (bfd_size_type) strlen (fnm) + 1);
d1562 1
a1562 1
		  strcpy (anm, fnm);
d1806 1
a1806 2
		  unsigned int namelen;
		  bfd_size_type newlen;
d1863 4
a1866 2
		  newlen = namelen + strlen (verstr) + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
d1869 1
a1869 1
		  newname = (char *) bfd_alloc (abfd, newlen);
d1872 1
a1872 1
		  strcpy (newname, name);
d1881 1
a1881 1
		  strcpy (p, verstr);
d4348 1
a4348 1
	      strncpy (alc, h->root.root.string, len - 1);
@


1.169
log
@	* elflink.h (elf_link_add_archive_symbols): For the default
	version, check references with only one `@@' first.
@
text
@d2943 1
a2943 1
  if (info->optimize == true)
@


1.168
log
@2002-06-23  Alan Modra  <amodra@@bigpond.net.au>

	* elflink.h: Comment typo fixes.

2002-06-23  H.J. Lu  <hjl@@gnu.org>

	* elf-bfd.h (elf_link_loaded_list): New structure.
	(elf_link_hash_table): Add "loaded".
	* elf.c (_bfd_elf_link_hash_table_init): Initialize "loaded".
	* elflink.h (elf_link_check_versioned_symbol): New function.
	(elf_link_output_extsym): Call elf_link_check_versioned_symbol.
@
text
@d356 1
d359 4
a362 4
		 look up the symbol again without the version.  The
		 effect is that references to the symbol without the
		 version will be matched by the default symbol in the
		 archive.  */
d368 3
a370 1
	      copy = bfd_alloc (abfd, (bfd_size_type) (p - symdef->name + 1));
d373 3
a375 2
	      memcpy (copy, symdef->name, (size_t) (p - symdef->name));
	      copy[p - symdef->name] = '\0';
d379 10
@


1.167
log
@If the target does not support an ELF style has table, return true, indicating
that nothing needed to be done, rather than false, indicating that the
section's size could not be computed.
@
text
@d2318 14
d4553 2
d6061 131
d6241 2
a6242 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d6415 2
a6416 2
     there now.  We have already know the symbol index.  We also fill
     in the entry in the .hash section.  */
d7110 1
a7110 1
			 section winds up in the output section.  */ 
@


1.166
log
@	* elflink.h (elf_bfd_final_link): Improve error handling for missing
	dynamic sections.
@
text
@d3056 1
a3056 1
    return false;
@


1.165
log
@	* elf-bfd.h (struct bfd_elf_section_data <group_name>): Replace with
	"group" union.
	(elf_group_name): Update.
	(elf_group_id): Define.
	(bfd_elf_set_group_contents): Declare.
	* elf.c (elf_fake_sections): Qualify use of elf_group_name.
	(set_group_contents): Rename to bfd_elf_set_group_contents.  Remove
	ATTRIBUTE_UNUSED from failedptrarg.  If elf_group_id is set, use
	that sym for the signature.
	(_bfd_elf_compute_section_file_positions): Don't call
	set_group_contents for "ld -r" case.
	(swap_out_syms): Use bfd_zalloc.
	* elflink.h (elf_link_add_archive_symbols): Likewise.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.
	(elf_bfd_final_link): Call bfd_elf_set_group_contents.
@
text
@d5695 7
a5701 1
	      BFD_ASSERT (o != NULL);
d5738 7
a5744 1
	      BFD_ASSERT (o != NULL);
@


1.164
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d316 2
a317 2
  defined = (boolean *) bfd_malloc (amt);
  included = (boolean *) bfd_malloc (amt);
a319 2
  memset (defined, 0, (size_t) amt);
  memset (included, 0, (size_t) amt);
d3666 1
a3666 1
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
a3668 1
      memset (s->contents, 0, (size_t) s->_raw_size);
d5809 9
@


1.163
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d240 1
a240 1
      elf_swap_symbol_in (abfd, (const PTR *) esym, (const PTR *) shndx, &sym);
d1669 1
a1669 1
      elf_swap_symbol_in (abfd, (const PTR *) esym, (const PTR *) shndx, &sym);
d2559 1
a2559 1
  elf_swap_symbol_in (input_bfd, (const PTR *) &esym, (const PTR *) shndx,
d6525 1
a6525 1
      elf_swap_symbol_in (input_bfd, (const PTR *) esym, (const PTR *) shndx,
d7675 2
a7676 2
				  (const PTR *) (locsyms + r_symndx),
				  (const PTR *) locshndx,
d7695 2
a7696 2
				  (const PTR *) (locsyms + r_symndx),
				  (const PTR *) locshndx,
d8290 2
a8291 2
	  elf_swap_symbol_in (rcookie->abfd, (const PTR *) lsym,
			      (const PTR *) lshndx, &isym);
@


1.162
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d240 1
a240 1
      elf_swap_symbol_in (abfd, esym, shndx, &sym);
d1669 1
a1669 1
      elf_swap_symbol_in (abfd, esym, shndx, &sym);
d2559 2
a2560 1
  elf_swap_symbol_in (input_bfd, &esym, shndx, &entry->isym);
d6525 2
a6526 1
      elf_swap_symbol_in (input_bfd, esym, shndx, isym);
d7665 1
d7673 1
d7675 2
a7676 2
				  locsyms + r_symndx,
				  locsym_shndx + (locsym_shndx ? r_symndx : 0),
d7693 1
d7695 2
a7696 2
				  locsyms + r_symndx,
				  locsym_shndx + (locsym_shndx ? r_symndx : 0),
d8290 2
a8291 1
	  elf_swap_symbol_in (rcookie->abfd, lsym, lshndx, &isym);
@


1.162.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d240 1
a240 1
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);
d316 2
a317 2
  defined = (boolean *) bfd_zmalloc (amt);
  included = (boolean *) bfd_zmalloc (amt);
d320 2
d1669 1
a1669 1
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);
d2559 1
a2559 2
  elf_swap_symbol_in (input_bfd, (const PTR) &esym, (const PTR) shndx,
		      &entry->isym);
d3057 1
a3057 1
    return true;
d3667 1
a3667 1
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d3670 1
d5697 1
a5697 7
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
d5734 1
a5734 7
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
a5812 9
  if (info->relocateable)
    {
      boolean failed = false;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

d6524 1
a6524 2
      elf_swap_symbol_in (input_bfd, (const PTR) esym, (const PTR) shndx,
			  isym);
a7662 1
	  Elf_External_Sym_Shndx *locshndx;
a7669 1
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
d7671 2
a7672 2
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
a7688 1
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
d7690 2
a7691 2
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
d8285 1
a8285 2
	  elf_swap_symbol_in (rcookie->abfd, (const PTR) lsym,
			      (const PTR) lshndx, &isym);
@


1.162.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d152 6
d161 3
a163 4
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  boolean result;
d181 4
a184 1
    hdr = &elf_tdata (abfd)->symtab_hdr;
d186 4
a189 1
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
d206 24
a229 8
  if (extsymcount == 0)
    return false;

  /* Read in the symbol table.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				  NULL, NULL, NULL);
  if (isymbuf == NULL)
    return false;
d232 4
a235 2
  result = false;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
d237 4
a240 1
      const char *name;
d242 1
a242 2
      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
d248 1
a248 1
	  result = is_global_data_symbol_definition (abfd, isym);
d253 5
a257 1
  free (isymbuf);
a355 1
	      size_t len, first;
d358 4
a361 4
		 look up the symbol again with only one `@@' as well
		 as without the version.  The effect is that references
		 to the symbol with and without the version will be
		 matched by the default symbol in the archive.  */
d367 1
a367 3
	      /* First check with only one `@@'.  */
	      len = strlen (symdef->name);
	      copy = bfd_alloc (abfd, (bfd_size_type) len);
d370 2
a371 3
	      first = p - symdef->name + 1;
	      memcpy (copy, symdef->name, first);
	      memcpy (copy + first, symdef->name + first + 1, len - first);
a375 10
	      if (h == NULL)
		{
		  /* We also need to check references to the symbol
		     without the version.  */

		  copy[first - 1] = '\0';
		  h = elf_link_hash_lookup (elf_hash_table (info),
					    copy, false, false, false);
		}

a948 1
  size_t len, shortlen;
d961 1
a961 1
	 need to create the indirect symbol from the default name.  */
d980 2
a981 2
  shortlen = p - name;
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
d984 2
a985 2
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';
d1090 1
a1090 2
  len = strlen (name);
  shortname = bfd_hash_allocate (&info->hash->table, len);
d1093 2
a1094 2
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);
d1173 1
d1177 3
d1184 1
d1186 2
a1187 3
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
d1191 1
d1290 77
d1368 1
a1417 1
	  Elf_External_Dyn *dynbuf = NULL;
d1431 1
a1431 1
	    goto error_free_dyn;
d1435 1
a1435 1
	    goto error_free_dyn;
d1438 17
d1469 1
a1469 1
		    goto error_free_dyn;
d1481 2
a1482 3
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
d1484 2
a1485 2
		    goto error_free_dyn;
		  memcpy (anm, fnm, (size_t) amt);
d1512 2
a1513 3
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
d1515 2
a1516 2
		    goto error_free_dyn;
		  memcpy (anm, fnm, (size_t) amt);
d1539 2
a1540 3
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
d1542 2
a1543 6
		    {
		    error_free_dyn:
		      free (dynbuf);
		      goto error_return;
		    }
		  memcpy (anm, fnm, (size_t) amt);
d1557 1
d1607 4
d1628 5
a1632 25
  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / sizeof (Elf_External_Sym);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }
d1634 1
a1634 2
  sym_hash = NULL;
  if (extsymcount != 0)
d1636 4
a1639 3
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
a1640 31

      /* We store a pointer to the hash table entry for each external
	 symbol.  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
      if (sym_hash == NULL)
	goto error_free_sym;
      elf_sym_hashes (abfd) = sym_hash;
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */
      if (! _bfd_elf_slurp_version_tables (abfd))
	goto error_free_sym;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_free_sym;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) extversym, amt, abfd) != amt)
	    goto error_free_vers;
	}
d1646 5
a1650 3
  for (isym = isymbuf, isymend = isymbuf + extsymcount;
       isym < isymend;
       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
d1652 1
d1667 2
d1671 1
a1671 1
      value = isym->st_value;
d1674 1
a1674 1
      bind = ELF_ST_BIND (isym->st_info);
d1685 2
a1686 2
	  if (isym->st_shndx != SHN_UNDEF
	      && isym->st_shndx != SHN_COMMON)
d1696 1
a1696 1
      if (isym->st_shndx == SHN_UNDEF)
d1698 1
a1698 1
      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
d1700 1
a1700 1
	  sec = section_from_elf_index (abfd, isym->st_shndx);
d1706 1
a1706 1
      else if (isym->st_shndx == SHN_ABS)
d1708 1
a1708 1
      else if (isym->st_shndx == SHN_COMMON)
d1713 1
a1713 1
	  value = isym->st_size;
d1720 1
a1720 2
      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
d1722 1
a1722 1
	goto error_free_vers;
d1724 1
a1724 2
      if (isym->st_shndx == SHN_COMMON
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
d1736 1
a1736 1
		goto error_free_vers;
d1742 1
a1742 1
	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
d1744 1
a1744 1
	    goto error_free_vers;
d1756 1
a1756 1
	  goto error_free_vers;
d1787 2
a1788 1
		  size_t namelen, verlen, newlen;
d1791 1
a1791 1
		  if (isym->st_shndx != SHN_UNDEF)
d1800 1
a1800 1
			  goto error_free_vers;
d1840 1
a1840 1
			  goto error_free_vers;
d1845 2
a1846 4
		  verlen = strlen (verstr);
		  newlen = namelen + verlen + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
d1849 1
a1849 1
		  newname = (char *) bfd_alloc (abfd, (bfd_size_type) newlen);
d1851 2
a1852 2
		    goto error_free_vers;
		  memcpy (newname, name, namelen);
d1859 1
a1859 1
		      && isym->st_shndx != SHN_UNDEF)
d1861 1
a1861 1
		  memcpy (p, verstr, verlen + 1);
d1867 1
a1867 1
	  if (! elf_merge_symbol (abfd, info, name, isym, &sec, &value,
d1870 1
a1870 1
	    goto error_free_vers;
d1898 1
a1898 1
	goto error_free_vers;
d1910 1
a1910 1
	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
d1932 1
a1932 1
      if (isym->st_shndx == SHN_COMMON
d1937 1
a1937 1
	  align = bfd_log2 (isym->st_value);
d1941 1
a1941 1
	      || (isym->st_value == 1 && old_alignment == 0))
d1952 1
a1952 1
	  if (isym->st_size != 0
d1955 1
a1955 1
	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
d1958 2
a1959 2
		   name, (unsigned long) h->size,
		   (unsigned long) isym->st_size, bfd_archive_filename (abfd));
d1961 1
a1961 1
	      h->size = isym->st_size;
d1972 1
a1972 1
	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
d1976 1
a1976 1
		  && h->type != ELF_ST_TYPE (isym->st_info)
d1980 1
a1980 1
		   name, h->type, ELF_ST_TYPE (isym->st_info),
d1983 1
a1983 1
	      h->type = ELF_ST_TYPE (isym->st_info);
d1988 1
a1988 1
	  if (isym->st_other != 0)
d1992 1
a1992 1
	      unsigned char symvis = ELF_ST_VISIBILITY (isym->st_other);
d1995 1
a1995 1
		h->other = isym->st_other;
d2002 1
a2002 1
		h->other = isym->st_other;
d2046 1
a2046 1
	    if (! elf_add_default_symbol (abfd, info, h, name, isym,
d2049 1
a2049 1
	      goto error_free_vers;
d2054 1
a2054 1
		goto error_free_vers;
d2060 1
a2060 1
		    goto error_free_vers;
d2083 1
a2083 1
		goto error_free_vers;
d2094 1
a2094 1
		goto error_free_vers;
d2120 1
a2120 1
		goto error_free_vers;
a2124 10
  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    free (isymbuf);
  isymbuf = NULL;

d2192 1
d2198 12
d2255 1
a2255 1
	  if (elf_section_data (o)->relocs != internal_relocs)
a2317 14
  if (is_elf_hash_table (info))
    {
      /* Add this bfd to the loaded list.  */
      struct elf_link_loaded_list *n;

      n = ((struct elf_link_loaded_list *)
	   bfd_alloc (abfd, sizeof (struct elf_link_loaded_list)));
      if (n == NULL)
	goto error_return;
      n->abfd = abfd;
      n->next = hash_table->loaded;
      hash_table->loaded = n;
    }

d2320 5
a2324 1
 error_free_vers:
a2326 4
 error_free_sym:
  if (isymbuf != NULL)
    free (isymbuf);
 error_return:
d2911 3
a2913 3
  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
d2915 1
a2915 1
  if (info->optimize)
d3231 1
a3231 1
			 bfd_archive_filename (sub));
d4087 1
a4087 1
       h->root.root.string);
d4147 1
a4147 1
	doit:
d4314 1
a4314 1
	      memcpy (alc, h->root.root.string, len - 1);
a4403 1
	error_return:
d4417 1
a4417 1
      struct bfd_elf_version_tree *local_ver;
d4423 1
a4423 1
      local_ver = NULL;
a4432 1
		      local_ver = NULL;
a4444 2
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.  */
d4446 1
a4446 1
		    local_ver = t;
d4449 7
a4455 1
		      local_ver = t;
d4465 1
a4465 1
      if (local_ver != NULL)
d4467 1
a4467 1
	  h->verinfo.vertree = local_ver;
a4474 37

      /* We need to check if a hidden versioned definition should
	 hide the default one.  */
      if (h->dynindx != -1 && h->verinfo.vertree != NULL)
	{
	  const char *verstr, *name;
	  size_t namelen, verlen, newlen;
	  char *newname;
	  struct elf_link_hash_entry *newh;

	  name = h->root.root.string;
	  namelen = strlen (name);
	  verstr = h->verinfo.vertree->name;
	  verlen = strlen (verstr);
	  newlen = namelen + verlen + 2;

	  newname = (char *) bfd_malloc ((bfd_size_type) newlen);
	  if (newname == NULL)
	    goto error_return;
	  memcpy (newname, name, namelen);

	  /* Check the hidden versioned definition.  */
	  p = newname + namelen;
	  *p++ = ELF_VER_CHR;
	  memcpy (p, verstr, verlen + 1);
	  newh = elf_link_hash_lookup (elf_hash_table (info), newname,
				       false, false, false);

	  if (newh
	      && (newh->root.type == bfd_link_hash_defined
		  || newh->root.type == bfd_link_hash_defweak))
	    /* We found a hidden versioned definition.  Hide the
	       default one.  */
	    (*bed->elf_backend_hide_symbol) (info, h, true);

	  free (newname);
	}
a4538 2
static boolean elf_link_check_versioned_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d4682 1
a4682 1
					  ELF_R_TYPE (irela[j].r_info));
d4695 1
a4695 2
struct elf_link_sort_rela
{
d4698 1
a4698 2
  union
  {
d5034 1
a5034 1
		  if (elf_section_data (o)->relocs != relocs)
d5372 1
a5372 1
		  size = o->offset + o->size;
d5511 2
a5512 2
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
a6044 121
/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.  */

static boolean
elf_link_check_versioned_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *undef_bfd = h->root.u.undef.abfd;
  struct elf_link_loaded_list *loaded;

  if ((undef_bfd->flags & DYNAMIC) == 0
      || info->hash->creator->flavour != bfd_target_elf_flavour
      || elf_dt_soname (h->root.u.undef.abfd) == NULL)
    return false;

  for (loaded = elf_hash_table (info)->loaded;
       loaded != NULL;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      bfd_size_type symcount;
      bfd_size_type extsymcount;
      bfd_size_type extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;

      /* We check each DSO for a possible hidden versioned definition.  */
      if (input == undef_bfd
	  || (input->flags & DYNAMIC) == 0
	  || elf_dynversym (input) == 0)
	continue;

      hdr = &elf_tdata (input)->dynsymtab_hdr;

      symcount = hdr->sh_size / sizeof (Elf_External_Sym);
      if (elf_bad_symtab (input))
	{
	  extsymcount = symcount;
	  extsymoff = 0;
	}
      else
	{
	  extsymcount = symcount - hdr->sh_info;
	  extsymoff = hdr->sh_info;
	}

      if (extsymcount == 0)
	continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return false;

      /* Read in any version definitions.  */
      versymhdr = &elf_tdata (input)->dynversym_hdr;
      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
      if (extversym == NULL)
	goto error_ret;

      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread ((PTR) extversym, versymhdr->sh_size, input)
	      != versymhdr->sh_size))
	{
	  free (extversym);
	error_ret:
	  free (isymbuf);
	  return false;
	}

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
	{
	  const char *name;
	  Elf_Internal_Versym iver;

	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
	      || isym->st_shndx == SHN_UNDEF)
	    continue;

	  name = bfd_elf_string_from_elf_section (input,
						  hdr->sh_link,
						  isym->st_name);
	  if (strcmp (name, h->root.root.string) != 0)
	    continue;

	  _bfd_elf_swap_versym_in (input, ever, &iver);

	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
	    {
	      /* If we have a non-hidden versioned sym, then it should
		 have provided a definition for the undefined sym.  */
	      abort ();
	    }

	  if ((iver.vs_vers & VERSYM_VERSION) == 2)
	    {
	      /* This is the oldest (default) sym.  We can use it.  */
	      free (extversym);
	      free (isymbuf);
	      return true;
	    }
	}

      free (extversym);
      free (isymbuf);
    }

  return false;
}

d6094 1
a6094 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
      && ! elf_link_check_versioned_symbol (finfo->info, h))
d6267 2
a6268 2
     there now.  We already know the symbol index.  We also fill in
     the entry in the .hash section.  */
d6379 5
a6383 5
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
d6390 2
a6391 2
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
d6463 1
d6466 5
a6470 1
  Elf_Internal_Sym *isymbuf;
a6471 1
  Elf_Internal_Sym *isymend;
d6506 5
a6510 2
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
d6512 4
a6515 5
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				      finfo->internal_syms,
				      finfo->external_syms,
				      finfo->locsym_shndx);
      if (isymbuf == NULL)
d6519 19
a6537 7
  /* Find local symbol sections and adjust values of symbols in
     SEC_MERGE sections.  Write out those local symbols we know are
     going into the output file.  */
  isymend = isymbuf + locsymcount;
  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
d6543 2
d6583 1
a6583 1
      if (ppsection == finfo->sections)
d6853 1
a6853 1
				     isymbuf,
d6862 1
a6862 1
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
d6937 1
a6937 1
		  isym = isymbuf + r_symndx;
d6962 1
a6962 1
			 section winds up in the output section.  */
d7032 2
a7033 3
	      if (input_rel_hdr->sh_size != 0
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
d7036 2
a7037 2
	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
d7041 1
a7041 1
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
d7045 1
d7562 4
a7565 4
  PARAMS ((struct bfd_link_info *, asection *,
	   asection * (*) (asection *, struct bfd_link_info *,
			   Elf_Internal_Rela *, struct elf_link_hash_entry *,
			   Elf_Internal_Sym *)));
d7568 4
a7571 3
  PARAMS ((struct bfd_link_info *,
	   boolean (*) (bfd *, struct bfd_link_info *, asection *,
			const Elf_Internal_Rela *)));
d7574 1
a7574 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7577 1
a7577 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7580 1
a7580 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7583 1
a7583 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7593 3
a7595 4
     asection * (*gc_mark_hook) PARAMS ((asection *, struct bfd_link_info *,
					 Elf_Internal_Rela *,
					 struct elf_link_hash_entry *,
					 Elf_Internal_Sym *));
d7614 1
d7618 2
d7622 3
a7624 1
      Elf_Internal_Sym *isym = NULL;
d7638 20
a7657 2
      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isym == NULL && nlocsyms != 0)
d7659 4
a7662 3
	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
				       NULL, NULL, NULL);
	  if (isym == NULL)
d7668 1
a7668 1
		  (input_bfd, sec, NULL, (Elf_Internal_Rela *) NULL,
d7682 2
d7689 16
a7704 2
	  if (r_symndx >= nlocsyms
	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
d7707 1
a7707 1
	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
d7711 6
a7716 1
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
d7732 1
a7732 1
      if (elf_section_data (sec)->relocs != relstart)
d7735 2
a7736 7
      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
	{
	  if (! info->keep_memory)
	    free (isym);
	  else
	    symtab_hdr->contents = (unsigned char *) isym;
	}
d7747 3
a7749 2
     boolean (*gc_sweep_hook) PARAMS ((bfd *, struct bfd_link_info *,
				       asection *, const Elf_Internal_Rela *));
d7793 1
a7793 1
	      if (elf_section_data (o)->relocs != internal_relocs)
d7964 1
a7964 1
    PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d8291 1
d8299 13
d8313 2
a8314 1
	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
d8331 1
a8331 1
      else
a8336 1
	  Elf_Internal_Sym *isym;
d8339 1
a8339 2
	  isym = &rcookie->locsyms[r_symndx];
	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
d8341 1
a8341 1
	      isec = section_from_elf_index (rcookie->abfd, isym->st_shndx);
d8364 2
d8416 2
d8433 6
a8438 2
      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
d8440 2
a8441 3
	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						 cookie.locsymcount, 0,
						 NULL, NULL, NULL);
d8444 24
d8473 2
a8474 1
			 (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d8486 1
a8486 1
	      if (elf_section_data (stab)->relocs != cookie.rels)
d8510 1
a8510 1
	  if (cookie.rels && elf_section_data (eh)->relocs != cookie.rels)
d8520 5
a8524 8
      if (cookie.locsyms != NULL
	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
	{
	  if (! info->keep_memory)
	    free (cookie.locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
	}
@


1.162.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1088 4
a1091 7
	 the type of override we do in the case above unless it is
	 overridden by a versioned definiton.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
d2451 87
a3027 3
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      boolean all_defined;
a3107 48
      /* Make all global versions with definiton.  */
      for (t = verdefs; t != NULL; t = t->next)
	for (d = t->globals; d != NULL; d = d->next)
	  if (!d->symver && strchr (d->pattern, '*') == NULL)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;
	      struct elf_link_hash_entry *newh;

	      name = d->pattern;
	      namelen = strlen (name);
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3; 

	      newname = (char *) bfd_malloc ((bfd_size_type) newlen);
	      if (newname == NULL)
		return false;
	      memcpy (newname, name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, false, false,
					   false);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, false, false,
					       false);
		}
	      free (newname);

	      /* Mark this version if there is a definition.  */
	      if (newh != NULL
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

a3119 22
      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definiton.  */
	  all_defined = true;
	  for (t = verdefs; t != NULL; t = t->next)
	    for (d = t->globals; d != NULL; d = d->next)
	      if (!d->symver && !d->script
		  && strchr (d->pattern, '*') == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = false;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	}

d4348 1
a4372 3
	      boolean matched;

	      matched = false;
d4377 3
a4379 12
		      if (d->symver)
			matched = true;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
a4384 4
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, true);
d4417 37
d6432 1
a6432 1
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
a6969 1
		  Elf_Internal_Sym sym;
d7022 1
a7022 1
		  sym = isymbuf[r_symndx];
d7024 1
a7024 1
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
d7071 1
a7071 1
				  (input_bfd, shlink, sym.st_name));
d7076 1
a7076 1
			  sym.st_shndx =
d7079 1
a7079 1
			  if (sym.st_shndx == SHN_BAD)
d7082 1
a7082 1
			  sym.st_value += sec->output_offset;
d7085 2
a7086 2
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
d7091 1
a7091 1
				  sym.st_value -= finfo->first_tls_sec->vma;
d7098 1
a7098 1
			  if (! elf_link_output_sym (finfo, name, &sym, sec))
@


1.162.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d902 1
a902 1
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
d907 1
a907 1
elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
d914 1
a914 1
     asection **psec;
a928 1
  asection *sec;
d973 1
a973 2
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
d1045 1
a1045 1
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);
d1080 1
a1080 2
  sec = *psec;
  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
d1116 1
a1116 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
d3068 1
a3068 2
	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
a3069 2
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d3900 1
a3900 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
@


1.162.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a3888 4
      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

d3891 1
d8482 1
a8482 6
	    {
	      /* Relocs have been edited.  Ensure edited version is
		 used later in relocate_section.  */
	      elf_section_data (eh)->relocs = cookie.rels;
	      ret = true;
	    }
@


1.162.2.6
log
@merge from mainline
@
text
@a923 1
  struct bfd_link_hash_entry *bh;
a981 1
      bh = &hi->root;
d984 2
a985 1
	      (bfd_vma) 0, name, false, collect, &bh)))
a986 1
      hi = (struct elf_link_hash_entry *) bh;
a1100 1
      bh = &hi->root;
d1103 2
a1104 1
	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
a1105 1
      hi = (struct elf_link_hash_entry *) bh;
a1297 8
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;
d1327 2
d1345 2
d1390 7
d1410 1
a1410 1
		  for (pn = & runpath;
d1415 2
d1442 1
a1442 1
		  for (pn = & rpath;
d1447 1
a1453 15
      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

a2294 1
  struct bfd_link_hash_entry *bh;
d2387 1
a2387 1
  bh = NULL;
d2390 2
a2391 1
	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
a2392 1
  h = (struct elf_link_hash_entry *) bh;
a3328 1
	      struct bfd_link_hash_entry *bh;
d3335 1
a3335 1
	      bh = NULL;
d3339 2
a3340 1
		      get_elf_backend_data (dynobj)->collect, &bh)))
a3341 1
	      h = (struct elf_link_hash_entry *) bh;
d4658 2
a4659 3
    /* We use these as arrays of size int_rels_per_ext_rel.  */
    Elf_Internal_Rel rel[1];
    Elf_Internal_Rela rela[1];
d4679 1
a4679 1
  if (ELF_R_SYM (a->u.rel->r_info) < ELF_R_SYM (b->u.rel->r_info))
d4681 1
a4681 1
  if (ELF_R_SYM (a->u.rel->r_info) > ELF_R_SYM (b->u.rel->r_info))
d4683 1
a4683 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4685 1
a4685 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
d4709 1
a4709 1
  if (a->u.rel->r_offset < b->u.rel->r_offset)
d4711 1
a4711 1
  if (a->u.rel->r_offset > b->u.rel->r_offset)
a4728 1
  int i2e = bed->s->int_rels_per_ext_rel;
d4752 1
a4752 17
  /* We waste some memory here when N = i2e is greater than 1, since
     we allocate space for N * sizeof (*rela) where sizeof (*rela) +
     (N - 1) * sizeof (Elf_Internal_Rel/Rela) would do.  Also, we use
     rela[k] only when k is a multiple of N, and then we index the
     array within the union, such that rela[k].u.rel[i], i < N, is the
     (i+1)th internal relocation corresponding to the (k/N)th external
     relocation.  This is done such that the relocation swap-in and
     swap-out functions can gen pointers to arrays of internal
     relocations that form a single external relocation.

     If C permitted arrays of structures with dynamic sizes, we could
     do better, but trying to avoid wasting space at the end of the
     chunk from rela[k] to rela[k+N-1] would require us to allocate a
     separate array of pointers and since most ports have N == 1, this
     would be more wasteful.  */
  rela = (struct elf_link_sort_rela *) bfd_zmalloc
    (sizeof (*rela) * count * i2e);
d4773 2
a4774 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4777 1
a4777 2
		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel,
					    s->u.rel);
d4779 1
a4779 1
		  elf_swap_reloc_in (abfd, erel, s->u.rel);
d4781 1
a4781 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4791 2
a4792 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4796 1
a4796 1
					     s->u.rela);
d4798 1
a4798 1
		  elf_swap_reloca_in (dynobj, erela, s->u.rela);
d4800 1
a4800 1
		s->type = (*bed->elf_backend_reloc_type_class) (s->u.rela);
d4805 2
a4806 3
  qsort (rela, (size_t) count, sizeof (*rela) * i2e, elf_link_sort_cmp1);
  for (ret = 0; ret < count * i2e && rela[ret].type == reloc_class_relative;
       ret += i2e)
d4808 1
a4808 1
  for (i = ret, j = ret; i < count * i2e; i += i2e)
d4810 1
a4810 2
      if (ELF_R_SYM (rela[i].u.rel->r_info)
	  != ELF_R_SYM (rela[j].u.rel->r_info))
d4812 1
a4812 1
      rela[i].offset = rela[j].u.rel->r_offset;
d4814 1
a4814 3
  ret /= i2e;
  qsort (rela + ret, (size_t) count - ret,
	 sizeof (*rela) * i2e, elf_link_sort_cmp2);
d4828 2
a4829 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rel) * i2e);
	    for (; erel < erelend; erel++, s += i2e)
d4832 1
a4832 1
		  (*bed->s->swap_reloc_out) (abfd, s->u.rel,
d4835 1
a4835 1
		  elf_swap_reloc_out (abfd, s->u.rel, erel);
d4845 2
a4846 2
	    s = rela + (o->output_offset / sizeof (Elf_External_Rela) * i2e);
	    for (; erela < erelaend; erela++, s += i2e)
d4849 1
a4849 1
		  (*bed->s->swap_reloca_out) (dynobj, s->u.rela,
d4852 1
a4852 1
		  elf_swap_reloca_out (dynobj, s->u.rela, erela);
d6818 1
d6821 6
d6831 1
d6847 1
d6851 6
d6863 1
@


1.162.2.7
log
@merge from mainline
@
text
@a4496 2
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
a4921 1
  Elf_Internal_Shdr *symtab_shndx_hdr;
a4974 1
  finfo.shndxbuf_size = 0;
d5195 3
a5197 1
  /* sh_flags, sh_addr and sh_size all start off zero.  */
d5224 1
a5224 3
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
d5226 1
a5226 1
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
d5286 1
a5286 1
	  if (i == SHN_LORESERVE - 1)
a5560 18
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, true);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite ((PTR) finfo.symshndxbuf, amt, abfd) != amt))
	return false;
    }


d5869 1
a5869 1
    free (finfo.symshndxbuf);
d5903 1
a5903 1
    free (finfo.symshndxbuf);
d5962 3
a5964 4
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;
d5966 1
a5966 13
	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return false;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }

  elf_swap_symbol_out (finfo->output_bfd, elfsym, (PTR) dest, (PTR) destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;
d5991 14
@


1.161
log
@	* elf-bfd.h (elf_backend_emit_relocs): Change prototype to return
	an error value.
	* elflink.h (elf_link_output_relocs): Likewise. Improve error message.
	return with false on error.
	(elf_link_input_bfd): Check reloc_emitter return value.
@
text
@d1726 17
a1742 1
      if (add_symbol_hook)
d3476 1
a3476 1
      if (info->new_dtags && info->flags)
d4500 2
d4981 8
d5353 34
d6163 10
a6172 1
	      sym.st_value += input_sec->output_section->vma;
d6636 9
a6644 1
	osym.st_value += isec->output_section->vma;
d6979 10
a6988 1
			    isym->st_value += osec->vma;
@


1.160
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d68 1
a68 1
static void elf_link_output_relocs
d6257 1
a6257 1
static void
d6289 10
a6298 2

  BFD_ASSERT (output_rel_hdr != NULL);
d6355 2
d6767 3
a6769 3
	      void (*reloc_emitter) PARAMS ((bfd *, asection *,
					     Elf_Internal_Shdr *,
					     Elf_Internal_Rela *));
d6926 3
a6928 1
	      (*reloc_emitter) (output_bfd, o, input_rel_hdr, internal_relocs);
d6935 3
a6937 2
		  (*reloc_emitter) (output_bfd, o, input_rel_hdr,
				    internal_relocs);
@


1.159
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d2261 3
a2263 1
      if (stab != NULL && !(stab->flags & SEC_MERGE))
d2289 2
a2290 1
	if (s->flags & SEC_MERGE)
d8273 2
a8274 1
	  if (eh && eh->_raw_size == 0)
d8278 8
a8285 1
      stab = strip ? NULL : bfd_get_section_by_name (abfd, ".stab");
@


1.159.2.1
log
@merge from trunk
@
text
@d68 1
a68 1
static boolean elf_link_output_relocs
d240 1
a240 1
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);
d316 2
a317 2
  defined = (boolean *) bfd_zmalloc (amt);
  included = (boolean *) bfd_zmalloc (amt);
d320 2
d1669 1
a1669 1
      elf_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx, &sym);
d1726 1
a1726 17
      if (sym.st_shndx == SHN_COMMON && ELF_ST_TYPE (sym.st_info) == STT_TLS)
	{
	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

	  if (tcomm == NULL)
	    {
	      tcomm = bfd_make_section (abfd, ".tcommon");
	      if (tcomm == NULL
		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
							   | SEC_IS_COMMON
							   | SEC_LINKER_CREATED
							   | SEC_THREAD_LOCAL)))
		goto error_return;
	    }
	  sec = tcomm;
	}
      else if (add_symbol_hook)
d2261 1
a2261 3
      if (stab != NULL
	  && (stab->flags & SEC_MERGE) == 0
	  && !bfd_is_abs_section (stab->output_section))
d2287 1
a2287 2
	if ((s->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (s->output_section))
d2540 1
a2540 2
  elf_swap_symbol_in (input_bfd, (const PTR) &esym, (const PTR) shndx,
		      &entry->isym);
d3457 1
a3457 1
      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
d3648 1
a3648 1
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d3651 1
a4480 2
  /* first SHF_TLS section (if any).  */
  asection *first_tls_sec;
a4959 8
  finfo.first_tls_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
	&& (o->flags & SEC_LOAD) != 0)
      {
	finfo.first_tls_sec = o;
	break;
      }
a5323 34
  if (finfo.first_tls_sec)
    {
      unsigned int align = 0;
      bfd_vma base = finfo.first_tls_sec->vma, end = 0;
      asection *sec;

      for (sec = finfo.first_tls_sec;
	   sec && (sec->flags & SEC_THREAD_LOCAL);
	   sec = sec->next)
	{
	  bfd_vma size = sec->_raw_size;

	  if (bfd_get_section_alignment (abfd, sec) > align)
	    align = bfd_get_section_alignment (abfd, sec);
	  if (sec->_raw_size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      struct bfd_link_order *o;

	      size = 0;
	      for (o = sec->link_order_head; o != NULL; o = o->next)
		if (size < o->offset + o->size)
	      size = o->offset + o->size;
	    }
	  end = sec->vma + size;
	}
      elf_hash_table (info)->tls_segment
	= bfd_zalloc (abfd, sizeof (struct elf_link_tls_segment));
      if (elf_hash_table (info)->tls_segment == NULL)
	goto error_return;
      elf_hash_table (info)->tls_segment->start = base;
      elf_hash_table (info)->tls_segment->size = end - base;
      elf_hash_table (info)->tls_segment->align = align;
    }

d5634 1
a5634 7
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
d5671 1
a5671 7
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
a5749 9
  if (info->relocateable)
    {
      boolean failed = false;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

d6100 1
a6100 10
	      {
		sym.st_value += input_sec->output_section->vma;
		if (h->type == STT_TLS)
		  {
		    /* STT_TLS symbols are relative to PT_TLS segment
		       base.  */
		    BFD_ASSERT (finfo->first_tls_sec != NULL);
		    sym.st_value -= finfo->first_tls_sec->vma;
		  }
	      }
d6254 1
a6254 1
static boolean
d6286 2
a6287 10
  else
    {
      (*_bfd_error_handler) (
        _("%s: relocation size mismatch in %s section %s"),
        bfd_get_filename (output_bfd),
        bfd_archive_filename (input_section->owner),
        input_section->name);
      bfd_set_error (bfd_error_wrong_object_format);
      return false;
    }
a6343 2

  return true;
d6442 1
a6442 2
      elf_swap_symbol_in (input_bfd, (const PTR) esym, (const PTR) shndx,
			  isym);
d6554 1
a6554 9
	{
	  osym.st_value += isec->output_section->vma;
	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
	    {
	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
	      BFD_ASSERT (finfo->first_tls_sec != NULL);
	      osym.st_value -= finfo->first_tls_sec->vma;
	    }
	}
d6754 3
a6756 3
	      boolean (*reloc_emitter) PARAMS ((bfd *, asection *,
						Elf_Internal_Shdr *,
						Elf_Internal_Rela *));
d6889 1
a6889 10
			    {
			      isym->st_value += osec->vma;
			      if (ELF_ST_TYPE (isym->st_info) == STT_TLS)
				{
				  /* STT_TLS symbols are relative to PT_TLS
				     segment base.  */
				  BFD_ASSERT (finfo->first_tls_sec != NULL);
				  isym->st_value -= finfo->first_tls_sec->vma;
				}
			    }
d6913 1
a6913 3
	      if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
				      internal_relocs))
		return false;
d6920 2
a6921 3
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					  internal_relocs))
		    return false;
a7560 1
	  Elf_External_Sym_Shndx *locshndx;
a7567 1
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
d7569 2
a7570 2
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
a7586 1
	      locshndx = locsym_shndx + (locsym_shndx ? r_symndx : 0);
d7588 2
a7589 2
				  (const PTR) (locsyms + r_symndx),
				  (const PTR) locshndx,
d8183 1
a8183 2
	  elf_swap_symbol_in (rcookie->abfd, (const PTR) lsym,
			      (const PTR) lshndx, &isym);
d8270 1
a8270 2
	  if (eh && (eh->_raw_size == 0
		     || bfd_is_abs_section (eh->output_section)))
d8274 1
a8274 8
      stab = NULL;
      if (!strip)
	{
	  stab = bfd_get_section_by_name (abfd, ".stab");
	  if (stab && (stab->_raw_size == 0
		       || bfd_is_abs_section (stab->output_section)))
	    stab = NULL;
	}
@


1.159.2.2
log
@Merge with trunk.
@
text
@d3056 1
a3056 1
    return true;
@


1.158
log
@	* elflink.h (elf_link_input_bfd <emit_relocs>): Adjust r_offset
	when not relocatable.  Fix reloc_emitter call for K&R.
@
text
@d6757 6
d6836 3
a6838 4
		      if (sec != NULL
			  && (bfd_is_abs_section (sec)
			      || (sec->output_section != NULL
				  && bfd_is_abs_section (sec->output_section))))
d6850 5
a6912 1
	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
@


1.157
log
@	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
@
text
@d6779 1
a6779 1
		  if (finfo->info->emitrelocations)
d6911 2
a6912 1
		  reloc_emitter (output_bfd, o, input_rel_hdr, internal_relocs);
@


1.156
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@a5349 2
	  Elf_Internal_Shdr *rhdr;

d5351 1
a5351 1
	      && (bfd_get_flavour (p->u.indirect.section->owner)
d5353 1
a5353 8
	      && (((rhdr = &elf_section_data (p->u.indirect.section)->rel_hdr)
		   ->sh_entsize == 0)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rel)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rela))
	      && (((rhdr = elf_section_data (p->u.indirect.section)->rel_hdr2)
		   == NULL)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rel)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rela)))
a5354 1
	      sub = p->u.indirect.section->owner;
@


1.155
log
@2002-03-26  H.J. Lu  (hjl@@gnu.org)

	* elflink.h (elf_link_input_bfd): Revert the last change since
	the gcc exception handling isn't fixed yet.
@
text
@a59 2
static boolean elf_link_find_version_dependencies
  PARAMS ((struct elf_link_hash_entry *, PTR));
d3688 3
d3970 11
d4097 3
d4157 3
d4240 3
d5953 3
d5991 7
d6075 1
a6135 10

    case bfd_link_hash_warning:
      /* We can't represent these symbols in ELF, although a warning
	 symbol may have come from a .gnu.warning.SYMBOL section.  We
	 just put the target symbol in the hash table.  If the target
	 symbol does not really exist, don't do anything.  */
      if (h->root.u.i.link->type == bfd_link_hash_new)
	return true;
      return (elf_link_output_extsym
	      ((struct elf_link_hash_entry *) h->root.u.i.link, data));
d7702 3
d7722 3
d7787 3
d8077 3
d8119 3
@


1.154
log
@2002-03-26  H.J. Lu  (hjl@@gnu.org)

	* elflink.h (elf_link_input_bfd): Complain about relocations
	against local symbols in discarded sections.
@
text
@d6665 2
a6666 1
			  if ((o->flags & SEC_DEBUGGING) != 0)
@


1.153
log
@	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.
@
text
@d6665 1
a6665 2
			  if ((o->flags & SEC_DEBUGGING) != 0
			      || (sec->flags & SEC_LINK_ONCE) != 0)
@


1.152
log
@	* elflink.h (NAME(bfd_elf,record_link_assignment)): Don't set
	STT_NOTYPE symbols to STT_OBJECT.
@
text
@d7573 9
a7581 5
	    if (!elf_gc_mark (info, rsec, gc_mark_hook))
	      {
		ret = false;
		goto out2;
	      }
@


1.151
log
@2002-03-14  H.J. Lu <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.
@
text
@a2797 4
  /* When possible, keep the original type of the symbol.  */
  if (h->type == STT_NOTYPE)
    h->type = STT_OBJECT;

@


1.150
log
@	* cpu-mips.c (mips_compatible): New.  Don't check bits_per_word.
	(N): Use the above.
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.
@
text
@d3223 1
@


1.149
log
@Revert last change.
@
text
@d5089 2
d5092 1
a5092 1
	      /* We must be careful to add the relocation froms the
d5094 9
a5102 1
	      if (esdi->rel_hdr.sh_entsize == esdo->rel_hdr.sh_entsize)
d5332 2
d5335 1
a5335 1
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
d5337 8
a5344 2
	      && (sub->arch_info->bits_per_word
		  == abfd->arch_info->bits_per_word))
d5346 1
@


1.148
log
@	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Use ELF section
	types instead of section names to determine whether init/fini array
	dynamic tags are needed.
@
text
@a3071 3
      bfd *sub;
      asection *o;
      int dt_done;
d3203 19
a3221 47
      dt_done = 0;
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	for (o = sub->sections; o != NULL; o = o->next)
	  {
	    int tag1, tag2;

	    if (o->output_section == bfd_abs_section_ptr)
	      continue;

	    switch (elf_section_data (o)->this_hdr.sh_type)
	      {
	      default:
		continue;

	      case SHT_INIT_ARRAY:
		if (dt_done & 1)
		  continue;
		dt_done |= 1;
		tag1 = DT_INIT_ARRAY;
		tag2 = DT_INIT_ARRAYSZ;
		break;

	      case SHT_FINI_ARRAY:
		if (dt_done & 2)
		  continue;
		dt_done |= 2;
		tag1 = DT_FINI_ARRAY;
		tag2 = DT_FINI_ARRAYSZ;
		break;

	      case SHT_PREINIT_ARRAY:
		/* DT_PREINIT_ARRAY is not allowed in a shared library.  */
		if (info->shared)
		  {
		    (*_bfd_error_handler)
		      (_("%s: .preinit_array section is not allowed in DSO"),
		       bfd_archive_filename (sub));
		    bfd_set_error (bfd_error_bad_value);
		    return false;
		  }
		if (dt_done & 4)
		  continue;
		dt_done |= 4;
		tag1 = DT_PREINIT_ARRAY;
		tag2 = DT_PREINIT_ARRAYSZ;
		break;
	      }
a3222 2
	    if (!elf_add_dynamic_entry (info, (bfd_vma) tag1, (bfd_vma) 0)
		|| !elf_add_dynamic_entry (info, (bfd_vma) tag2, (bfd_vma) 0))
d3224 24
a3247 1
	  }
@


1.147
log
@	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
@
text
@d3072 3
d3206 47
a3252 19
      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (info->shared)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%s: .preinit_array section is not allowed in DSO"),
			  bfd_archive_filename (sub));
		      break;
		    }
d3254 2
d3257 1
a3257 24
	    }

	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}
@


1.146
log
@	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.
@
text
@a6031 4
      input_sec = bfd_und_section_ptr;
      sym.st_shndx = SHN_UNDEF;
      break;

d8218 2
a8219 1
      if ((! stab || elf_section_data(stab)->sec_info_type != ELF_INFO_TYPE_STABS)
d8307 1
a8307 2
			   (abfd, eh, (PTR) NULL,
			    (Elf_Internal_Rela *) NULL,
d8336 1
a8336 3
  if (ehdr
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd,
						info, ehdr))
d8345 2
d8355 4
a8358 4
  if ((get_elf_backend_data (sec->owner)->elf_backend_ignore_discarded_relocs
       != NULL)
      && (*get_elf_backend_data (sec->owner)
	   ->elf_backend_ignore_discarded_relocs) (sec))
@


1.145
log
@	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
@
text
@d5323 4
a5326 2
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_elf_flavour))
a5327 1
	      sub = p->u.indirect.section->owner;
@


1.144
log
@2002-03-04  H.J. Lu <hjl@@gnu.org>

	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.

	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.
@
text
@d595 1
a595 1
         indices used by MIPS ELF.  */
d705 4
a708 4
         common warning if desired.  Note that we only warn if the
         size is different.  If the size is the same, we simply let
         the old symbol override the new one as normally happens with
         symbols defined in dynamic objects.  */
d758 4
a761 4
         we are explicitly letting it override a weak symbol or
         function in a dynamic object, and we don't want to warn about
         a type change.  If the old symbol is a defined symbol, a type
         change warning may still be appropriate.  */
d820 1
a820 1
         overriding a function.  */
d832 5
a836 5
         we want the caller to frob with H rather than with the
         indirect symbol.  That will permit the caller to redefine the
         target of the indirection, rather than the indirect symbol
         itself.  FIXME: This will break the -y option if we store a
         symbol with a different name.  */
d859 1
a859 1
         larger, pretend that the new symbol has its size.  */
d893 2
a894 2
         of the code does not think we are using the regular
         definition.  */
d903 3
a905 3
         use H rather than the indirect symbol.  Otherwise if we are
         defining a new indirect symbol we will wind up attaching it
         to the entry we are overriding.  */
d1050 1
a1050 1
         other fields correctly.  */
d1136 1
a1136 1
          (*bed->elf_backend_copy_indirect_symbol) (h, hi);
d1262 2
a1263 2
                         the section size so that the warning does not
                         get copied into the output file.  */
d1287 1
a1287 1
                     not get copied into the output file.  */
d1318 1
a1318 1
         to internal format.  */
d1376 4
a1379 4
         sections immediately.  We need to attach them to something,
         so we attach them to this BFD, provided it is the right
         format.  FIXME: If there are no input BFD's of the same
         format as the output, we can't make a shared library.  */
d1414 1
a1414 1
	        dt_needed = true;
d1534 1
a1534 1
	        {
d1626 1
a1626 1
         linker emulation code will need to know it.  */
d1767 4
a1770 4
                 1, we append the version name to the symbol name.
                 However, we do not modify a non-hidden absolute
                 symbol, because it might be the version symbol
                 itself.  FIXME: What if it isn't?  */
d1869 4
a1872 4
             that we don't reduce the alignment later on.  We can't
             check later, because _bfd_generic_link_add_one_symbol
             will set a default for the alignment which we want to
             override.  */
d1953 4
a1956 4
             to be the size of the common symbol.  The code just above
             won't fix the size if a common symbol becomes larger.  We
             don't warn about a size change here, because that is
             covered by --warn-common.  */
d1986 2
a1987 2
	         definition.  This is an arbitrary choice, since the
	         other bits have no general meaning.  */
d2074 1
a2074 1
	         the regular object to create a dynamic executable. We
d2170 4
a2173 4
                 symbols, make sure the weak definition is put there
                 as well.  If we don't do this, then the dynamic
                 loader might not merge the entries for the real
                 definition and the weak definition.  */
d3143 1
a3143 1
         table (this is not the normal case), then do so.  */
d3147 1
a3147 1
			          (PTR) &eif);
d3288 1
a3288 1
         just linking a regular application.  */
d3682 1
a3682 1
      
d3685 1
a3685 1
        
d3765 1
a3765 1
                    
d3795 1
a3795 1
                    
d3873 5
a3877 5
         was first seen in a non-ELF file.  Fortunately, if the symbol
         was first seen in an ELF file, we're probably OK unless the
         symbol was defined in a non-ELF file.  Catch that case here.
         FIXME: We're still in trouble if the symbol was first seen in
         a dynamic object, and then later in a non-ELF regular object.  */
d4117 1
a4117 1
        {
d4124 1
a4124 1
        }
d4250 1
a4250 1
         not a hidden symbol.  */
d4278 1
a4278 1
	        return false;
d4282 1
a4282 1
	        alc[len - 2] = '\0';
d4296 1
a4296 1
                 local scope.  */
d4321 1
a4321 1
         version node for this version.  */
d4328 1
a4328 1
             to worry about it.  */
d4364 1
a4364 1
             generating a shared archive.  Return an error.  */
d4386 2
a4387 2
         symbol is supposed to be local, then don't actually register
         it.  */
d4907 2
a4908 2
                 || info->emitrelocations
                 || bed->elf_backend_emit_relocs);
d4978 1
a4978 1
              else if (bed->elf_backend_count_relocs)
d4986 2
a4987 2
		  o->reloc_count += (*bed->elf_backend_count_relocs)
		                      (sec, relocs);
d5348 14
a5366 17
  if (info->shared)
    {
      /* Output any global symbols that got converted to local in a
         version script.  We do this in a separate step since ELF
         requires all local symbols to appear prior to any global
         symbols.  FIXME: We should only do this if some global
         symbols were, in fact, converted to become local.  FIXME:
         Will this work correctly with the Irix 5 linker?  */
      eoinfo.failed = false;
      eoinfo.finfo = &finfo;
      eoinfo.localsyms = true;
      elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			      (PTR) &eoinfo);
      if (eoinfo.failed)
	return false;
    }

d5418 2
a5419 2
                 the original st_name with the dynstr_index.  */
              sym = e->isym;
d5696 1
a5696 1
                 created by elf_link_create_dynamic_sections.  */
d5712 1
a5712 1
                 stringtab.  */
d5768 1
a5768 1
        free (elf_section_data (o)->rel_hashes);
d5819 1
a5819 1
  
d6085 5
a6089 5
         to the decorated version of the name.  For example, if the
         symbol foo@@@@GNU_1.2 is the default, which should be used when
         foo is used with no version, then we add an indirect symbol
         foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
         since the indirected symbol is already in the hash table.  */
d6094 3
a6096 3
         symbol may have come from a .gnu.warning.SYMBOL section.  We
         just put the target symbol in the hash table.  If the target
         symbol does not really exist, don't do anything.  */
d6105 2
a6106 1
     symbol.  */
d6109 2
d6364 2
a6365 2
                 || finfo->info->emitrelocations
                 || bed->elf_backend_emit_relocs);
d6481 4
a6484 4
         discarding, we don't need to keep it, but note that
         linker_mark is only reliable for sections that have contents.
         For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
         as well as linker_mark.  */
d6559 3
a6561 3
         relaxation routine.  Note that o is a section in an input
         file, so the contents field will not have been set by any of
         the routines which work on output files.  */
d6871 2
a6872 2
              if (bed->elf_backend_emit_relocs
                  && !(finfo->info->relocateable
d6874 3
a6876 3
                reloc_emitter = bed->elf_backend_emit_relocs;
              else
                reloc_emitter = elf_link_output_relocs;
d6879 1
a6879 1
              (*reloc_emitter) (output_bfd, o, input_rel_hdr, internal_relocs);
d6882 3
a6884 3
              if (input_rel_hdr)
                {
                  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
d6886 2
a6887 2
                  reloc_emitter (output_bfd, o, input_rel_hdr, internal_relocs);
                }
d6987 1
a6987 1
         actually against the section.  */
d7002 2
a7003 2
             addend here, but in practice it has already been added
             because it was passed to constructor_callback.  */
d7476 1
a7476 1
          extsymoff = 0;
d7538 1
a7538 1
	        rsec = (*gc_mark_hook) (sec->owner, info, rel, NULL, &s);
d7541 2
a7542 2
	          h = sym_hashes[r_symndx - extsymoff];
	          rsec = (*gc_mark_hook) (sec->owner, info, rel, h, NULL);
d7713 3
a7715 3
          asection *sec = h->root.u.def.section;
          struct elf_backend_data *bed = get_elf_backend_data (sec->owner);
          int file_align = bed->s->file_align;
d7792 1
a7792 1
             struct elf_link_hash_entry *h, Elf_Internal_Sym *));
d7826 1
a7826 1
  	    if (!elf_gc_mark (info, o, gc_mark_hook))
d8246 1
a8246 1
        cookie.locsyms = (void *) symtab_hdr->contents;
d8248 1
a8248 1
        cookie.locsyms = NULL;
d8250 4
a8253 4
        {
          bfd_size_type amt = cookie.locsymcount * sizeof (Elf_External_Sym);
          cookie.locsyms = bfd_malloc (amt);
          if (cookie.locsyms == NULL)
d8257 1
a8257 1
              || bfd_bread (cookie.locsyms, amt, abfd) != amt)
d8262 2
a8263 2
            }
        }
@


1.143
log
@        * elflink.h (size_dynamic_sections): If section named
        ".preinit_array" exists, create DT_PREINIT_ARRAY and
        DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
        ".init_array" and ".fini_array".
        (elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
        DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
        DT_FINI_ARRAY.
@
text
@d3032 1
a3032 3
  bfd *dynobj, *sub;
  asection *o;
  int need_preinit_array = 0, need_init_array = 0, need_fini_array = 0;
d3203 22
a3224 4
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	for (o = sub->sections; o != NULL; o = o->next)
	  {
	    /* yuck, more matching by name... */
a3225 9
	    if (strcmp (bfd_section_name (sub, o), ".preinit_array") == 0)
	      need_preinit_array = 1;
	    if (strcmp (bfd_section_name (sub, o), ".init_array") == 0)
	      need_init_array = 1;
	    if (strcmp (bfd_section_name (sub, o), ".fini_array") == 0)
	      need_fini_array = 1;
	  }
      if (need_preinit_array)
	{
d3232 1
a3232 1
      if (need_init_array)
d3240 1
a3240 1
      if (need_fini_array)
d5610 3
@


1.142
log
@	* elflink.h (elf_bfd_final_link): Don't crash on SHN_UNDEF local
	dynsyms.
@
text
@d3032 3
a3034 1
  bfd *dynobj;
d3205 37
d5591 25
@


1.141
log
@	* elf-bfd.h (elf_backend_data <elf_backend_hide_symbol>): Add
	boolean param.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_hide_symbol.
	(elf_fix_symbol_flags): Likewise.
	(elf_link_assign_sym_version): Likewise. Use bfd_malloc rather
	than bfd_alloc.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Add "force_local" param.
	Set ELF_LINK_FORCED_LOCAL and call _bfd_elf_strtab_delref.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	(clobber_millicode_symbols): Adjust to suit new hide_symbol.
	* elf32-cris.c (elf_cris_hide_symbol): Add "force_local" param
	and adjust to suit.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise, and call
	_bfd_elf_link_hash_hide_symbol rather than duplicating code.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d5378 3
a5380 2
	      if (e->isym.st_shndx < SHN_LORESERVE
		  || e->isym.st_shndx > SHN_HIRESERVE)
@


1.141.2.1
log
@	* elflink.h (elf_bfd_final_link): Don't crash on SHN_UNDEF local
	dynsyms.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d5378 2
a5379 3
	      if (e->isym.st_shndx != SHN_UNDEF
		   && (e->isym.st_shndx < SHN_LORESERVE
		       || e->isym.st_shndx > SHN_HIRESERVE))
@


1.141.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d595 1
a595 1
	 indices used by MIPS ELF.  */
d705 4
a708 4
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */
d758 4
a761 4
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */
d820 1
a820 1
	 overriding a function.  */
d832 5
a836 5
	 we want the caller to frob with H rather than with the
	 indirect symbol.  That will permit the caller to redefine the
	 target of the indirection, rather than the indirect symbol
	 itself.  FIXME: This will break the -y option if we store a
	 symbol with a different name.  */
d859 1
a859 1
	 larger, pretend that the new symbol has its size.  */
d893 2
a894 2
	 of the code does not think we are using the regular
	 definition.  */
d903 3
a905 3
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
d1050 1
a1050 1
	 other fields correctly.  */
d1136 1
a1136 1
	  (*bed->elf_backend_copy_indirect_symbol) (h, hi);
d1262 2
a1263 2
			 the section size so that the warning does not
			 get copied into the output file.  */
d1287 1
a1287 1
		     not get copied into the output file.  */
d1318 1
a1318 1
	 to internal format.  */
d1376 4
a1379 4
	 sections immediately.  We need to attach them to something,
	 so we attach them to this BFD, provided it is the right
	 format.  FIXME: If there are no input BFD's of the same
	 format as the output, we can't make a shared library.  */
d1414 1
a1414 1
		dt_needed = true;
d1534 1
a1534 1
		{
d1626 1
a1626 1
	 linker emulation code will need to know it.  */
d1767 4
a1770 4
		 1, we append the version name to the symbol name.
		 However, we do not modify a non-hidden absolute
		 symbol, because it might be the version symbol
		 itself.  FIXME: What if it isn't?  */
d1869 4
a1872 4
	     that we don't reduce the alignment later on.  We can't
	     check later, because _bfd_generic_link_add_one_symbol
	     will set a default for the alignment which we want to
	     override.  */
d1953 4
a1956 4
	     to be the size of the common symbol.  The code just above
	     won't fix the size if a common symbol becomes larger.  We
	     don't warn about a size change here, because that is
	     covered by --warn-common.  */
d1986 2
a1987 2
		 definition.  This is an arbitrary choice, since the
		 other bits have no general meaning.  */
d2074 1
a2074 1
		 the regular object to create a dynamic executable. We
d2170 4
a2173 4
		 symbols, make sure the weak definition is put there
		 as well.  If we don't do this, then the dynamic
		 loader might not merge the entries for the real
		 definition and the weak definition.  */
d3143 1
a3143 1
	 table (this is not the normal case), then do so.  */
d3147 1
a3147 1
				  (PTR) &eif);
a3202 47
      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (info->shared)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%s: .preinit_array section is not allowed in DSO"),
			  bfd_archive_filename (sub));
		      break;
		    }

	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
	{
	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAY,
				      (bfd_vma) 0)
	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAYSZ,
					 (bfd_vma) 0))
	    return false;
	}

d3242 1
a3242 1
	 just linking a regular application.  */
d3636 1
a3636 1

d3639 1
a3639 1

d3719 1
a3719 1

d3749 1
a3749 1

d3827 5
a3831 5
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
d4071 1
a4071 1
	{
d4078 1
a4078 1
	}
d4204 1
a4204 1
	 not a hidden symbol.  */
d4232 1
a4232 1
		return false;
d4236 1
a4236 1
		alc[len - 2] = '\0';
d4250 1
a4250 1
		 local scope.  */
d4275 1
a4275 1
	 version node for this version.  */
d4282 1
a4282 1
	     to worry about it.  */
d4318 1
a4318 1
	     generating a shared archive.  Return an error.  */
d4340 2
a4341 2
	 symbol is supposed to be local, then don't actually register
	 it.  */
d4861 2
a4862 2
		 || info->emitrelocations
		 || bed->elf_backend_emit_relocs);
d4932 1
a4932 1
	      else if (bed->elf_backend_count_relocs)
d4940 2
a4941 2
		  o->reloc_count
		    += (*bed->elf_backend_count_relocs) (sec, relocs);
a5042 2
	      bfd_size_type entsize;
	      bfd_size_type entsize2;
d5044 1
a5044 1
	      /* We must be careful to add the relocations from the
d5046 1
a5046 9
	      entsize = esdi->rel_hdr.sh_entsize;
	      entsize2 = esdi->rel_hdr2 ? esdi->rel_hdr2->sh_entsize : 0;
	      BFD_ASSERT ((entsize == sizeof (Elf_External_Rel)
			   || entsize == sizeof (Elf_External_Rela))
			  && entsize2 != entsize
			  && (entsize2 == 0
			      || entsize2 == sizeof (Elf_External_Rel)
			      || entsize2 == sizeof (Elf_External_Rela)));
	      if (entsize == esdo->rel_hdr.sh_entsize)
a5275 2
	  Elf_Internal_Shdr *rhdr;

d5278 1
a5278 9
		  == bfd_target_elf_flavour)
	      && (((rhdr = &elf_section_data (p->u.indirect.section)->rel_hdr)
		   ->sh_entsize == 0)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rel)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rela))
	      && (((rhdr = elf_section_data (p->u.indirect.section)->rel_hdr2)
		   == NULL)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rel)
		  || rhdr->sh_entsize == sizeof (Elf_External_Rela)))
a5301 14
  /* Output any global symbols that got converted to local in a
     version script or due to symbol visibility.  We do this in a
     separate step since ELF requires all local symbols to appear
     prior to any global symbols.  FIXME: We should only do this if
     some global symbols were, in fact, converted to become local.
     FIXME: Will this work correctly with the Irix 5 linker?  */
  eoinfo.failed = false;
  eoinfo.finfo = &finfo;
  eoinfo.localsyms = true;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  (PTR) &eoinfo);
  if (eoinfo.failed)
    return false;

d5307 17
d5375 2
a5376 2
		 the original st_name with the dynstr_index.  */
	      sym = e->isym;
a5552 28
	    case DT_PREINIT_ARRAYSZ:
	      name = ".preinit_array";
	      goto get_size;
	    case DT_INIT_ARRAYSZ:
	      name = ".init_array";
	      goto get_size;
	    case DT_FINI_ARRAYSZ:
	      name = ".fini_array";
	    get_size:
	      o = bfd_get_section_by_name (abfd, name);
	      BFD_ASSERT (o != NULL);
	      if (o->_raw_size == 0)
		(*_bfd_error_handler)
		  (_("warning: %s section has zero size"), name);
	      dyn.d_un.d_val = o->_raw_size;
	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
	      break;

	    case DT_PREINIT_ARRAY:
	      name = ".preinit_array";
	      goto get_vma;
	    case DT_INIT_ARRAY:
	      name = ".init_array";
	      goto get_vma;
	    case DT_FINI_ARRAY:
	      name = ".fini_array";
	      goto get_vma;

d5625 1
a5625 1
		 created by elf_link_create_dynamic_sections.  */
d5641 1
a5641 1
		 stringtab.  */
d5697 1
a5697 1
	free (elf_section_data (o)->rel_hashes);
d5748 1
a5748 1

d5960 4
d6014 5
a6018 5
	 to the decorated version of the name.  For example, if the
	 symbol foo@@@@GNU_1.2 is the default, which should be used when
	 foo is used with no version, then we add an indirect symbol
	 foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
	 since the indirected symbol is already in the hash table.  */
d6023 3
a6025 3
	 symbol may have come from a .gnu.warning.SYMBOL section.  We
	 just put the target symbol in the hash table.  If the target
	 symbol does not really exist, don't do anything.  */
d6034 1
a6034 2
     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
     forced local syms when non-shared is due to a historical quirk.  */
a6036 2
      && (finfo->info->shared
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d6290 2
a6291 2
		 || finfo->info->emitrelocations
		 || bed->elf_backend_emit_relocs);
d6407 4
a6410 4
	 discarding, we don't need to keep it, but note that
	 linker_mark is only reliable for sections that have contents.
	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
	 as well as linker_mark.  */
d6485 3
a6487 3
	 relaxation routine.  Note that o is a section in an input
	 file, so the contents field will not have been set by any of
	 the routines which work on output files.  */
d6797 2
a6798 2
	      if (bed->elf_backend_emit_relocs
		  && !(finfo->info->relocateable
d6800 3
a6802 3
		reloc_emitter = bed->elf_backend_emit_relocs;
	      else
		reloc_emitter = elf_link_output_relocs;
d6805 1
a6805 1
	      (*reloc_emitter) (output_bfd, o, input_rel_hdr, internal_relocs);
d6808 3
a6810 3
	      if (input_rel_hdr)
		{
		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
d6812 2
a6813 2
		  reloc_emitter (output_bfd, o, input_rel_hdr, internal_relocs);
		}
d6913 1
a6913 1
	 actually against the section.  */
d6928 2
a6929 2
	     addend here, but in practice it has already been added
	     because it was passed to constructor_callback.  */
d7402 1
a7402 1
	  extsymoff = 0;
d7464 1
a7464 1
		rsec = (*gc_mark_hook) (sec->owner, info, rel, NULL, &s);
d7467 2
a7468 2
		  h = sym_hashes[r_symndx - extsymoff];
		  rsec = (*gc_mark_hook) (sec->owner, info, rel, h, NULL);
d7486 5
a7490 9
	    {
	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
		rsec->gc_mark = 1;
	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
		{
		  ret = false;
		  goto out2;
		}
	    }
d7639 3
a7641 3
	  asection *sec = h->root.u.def.section;
	  struct elf_backend_data *bed = get_elf_backend_data (sec->owner);
	  int file_align = bed->s->file_align;
d7718 1
a7718 1
	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));
d7752 1
a7752 1
	    if (!elf_gc_mark (info, o, gc_mark_hook))
d8147 1
a8147 2
      if ((! stab
	   || elf_section_data(stab)->sec_info_type != ELF_INFO_TYPE_STABS)
d8172 1
a8172 1
	cookie.locsyms = (void *) symtab_hdr->contents;
d8174 1
a8174 1
	cookie.locsyms = NULL;
d8176 4
a8179 4
	{
	  bfd_size_type amt = cookie.locsymcount * sizeof (Elf_External_Sym);
	  cookie.locsyms = bfd_malloc (amt);
	  if (cookie.locsyms == NULL)
d8183 1
a8183 1
	      || bfd_bread (cookie.locsyms, amt, abfd) != amt)
d8188 2
a8189 2
	    }
	}
d8235 2
a8236 1
			   (abfd, eh, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d8265 3
a8267 1
  if (ehdr && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info, ehdr))
a8275 2
  struct elf_backend_data *bed;

d8284 4
a8287 4

  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
@


1.141.2.3
log
@Merge from mainline.
@
text
@d60 2
d2798 4
a3693 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a3972 11
  if (h->root.type == bfd_link_hash_warning)
    {
      h->plt.offset = (bfd_vma) -1;
      h->got.offset = (bfd_vma) -1;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

a4088 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a4145 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a4225 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5935 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5970 7
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return true;
    }

a6047 1
    case bfd_link_hash_warning:
d6108 10
a7683 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a7700 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a7762 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a8049 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a8088 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.141.2.4
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d5350 2
d5353 1
a5353 1
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
d5355 8
a5362 1
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
d5364 1
@


1.141.2.5
log
@Merge from mainline
@
text
@a6756 6
	      boolean rela_normal;

	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
	      rela_normal = (bed->rela_normal
			     && (input_rel_hdr->sh_entsize
				 == sizeof (Elf_External_Rela)));
d6779 1
a6779 1
		  if (!finfo->info->relocateable)
d6830 4
a6833 3
		      if (bfd_is_abs_section (sec)
			  || (sec != NULL
			      && bfd_is_abs_section (sec->output_section)))
a6844 5

		      /* Adjust the addend according to where the
			 section winds up in the output section.  */ 
		      if (rela_normal)
			irela->r_addend += sec->output_offset;
d6903 1
d6911 1
a6911 2
		  (*reloc_emitter) (output_bfd, o, input_rel_hdr,
				    internal_relocs);
@


1.140
log
@	* elf32-arm.h (elf32_arm_size_dynamic_sections): When removing
	sections, use bfd_section_list_remove.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elflink.h (elf_link_add_object_symbols): When removing all
	sections, use bfd_section_list_clear.
@
text
@d2059 1
a2059 4
		h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
		(*bed->elf_backend_hide_symbol) (info, h);
		_bfd_elf_strtab_delref (hash_table->dynstr,
					h->dynstr_index);
d3873 1
d3876 4
a3879 8
      if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	{
	  h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
	  _bfd_elf_strtab_delref (elf_hash_table (eif->info)->dynstr,
				  h->dynstr_index);
	}
      (*bed->elf_backend_hide_symbol) (eif->info, h);
d4230 1
a4230 1
	      alc = bfd_alloc (sinfo->output_bfd, (bfd_size_type) len);
d4261 1
a4261 4
			      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
			      (*bed->elf_backend_hide_symbol) (info, h);
			      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
						      h->dynstr_index);
d4269 1
a4269 1
	      bfd_release (sinfo->output_bfd, alc);
d4373 1
a4373 4
			  h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
			  (*bed->elf_backend_hide_symbol) (info, h);
			  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
						  h->dynstr_index);
d4391 1
a4391 4
	      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
	      (*bed->elf_backend_hide_symbol) (info, h);
	      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				      h->dynstr_index);
@


1.139
log
@	* elflink.h (elf_link_input_bfd): Back out 2002-01-07 change.
	* elf.c (merge_sections_remove_hook): New function.
	(_bfd_elf_merge_sections): Pass it as 3rd argument to
	_bfd_merge_sections.
	* libbfd-in.h (_bfd_merge_sections): Add 3rd argument.
	* libbfd.h: Rebuilt.
	* merge.c (_bfd_merge_sections): Add remove_hook argument.
	Call remove_hook if a SEC_EXCLUDE section is encountered.
@
text
@d1571 1
a1571 2
      abfd->sections = NULL;
      abfd->section_count = 0;
@


1.138
log
@	* elflink.h (elf_link_input_bfd): Don't ask for the merged offset
	of a symbol in a section that will be deleted.
@
text
@a6377 2
	      && (finfo->info->relocateable
		  || ! (isec->flags & SEC_EXCLUDE))
@


1.137
log
@	* elflink.h (elf_bfd_final_link): Check if dynobj is not NULL
	before looking for .eh_frame_hdr section.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): If
	.eh_frame_hdr section is being stripped from output, don't do
	anything.
@
text
@d6378 2
@


1.136
log
@	* ldgram.y (vers_node): Support anonymous version tags.
	* ldlang.c (lang_register_vers_node): Ensure anonymous version
	tag is not defined together with non-anonymous versions.
	* ld.texinfo: Document it.

	* elflink.h (size_dynamic_sections): Skip anonymous version tag.
	(elf_link_assign_sym_version): Don't count anonymous version tag.
@
text
@d5673 1
a5673 1
  if (info->eh_frame_hdr)
@


1.135
log
@	* elf-bfd.h (elf_discarded_section): Define.
	* elflink.h (elf_link_input_bfd): Use it.
	(elf_reloc_symbol_deleted_p): Likewise.

	* elf64-alpha.c (elf64_alpha_relocate_section): Don't warn about
	overflows for pc relative relocs against discarded sections.
@
text
@d3249 4
d4314 3
@


1.134
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d6554 1
a6554 5
			  && ! bfd_is_abs_section (h->root.u.def.section)
			  && bfd_is_abs_section (h->root.u.def.section
						 ->output_section)
			  && (elf_section_data (h->root.u.def.section)
			      ->sec_info_type != ELF_INFO_TYPE_MERGE))
d6583 1
a6583 5
		      if (sec != NULL
			  && ! bfd_is_abs_section (sec)
			  && bfd_is_abs_section (sec->output_section)
			  && (elf_section_data (sec)->sec_info_type
			      != ELF_INFO_TYPE_MERGE))
d8080 1
a8080 3
	      && ! bfd_is_abs_section (h->root.u.def.section)
	      && bfd_is_abs_section (h->root.u.def.section
				     ->output_section))
d8096 1
a8096 3
	      if (isec != NULL
		  && ! bfd_is_abs_section (isec)
		  && bfd_is_abs_section (isec->output_section))
@


1.133
log
@	* elf-bfd.h (_bfd_elf_maybe_strip_eh_frame_hdr): New prototype.
	* elf-eh-frame.c (struct eh_frame_hdr_info): Add strip.
	(_bfd_elf_discard_section_eh_frame): Don't create .eh_frame_hdr
	sec_info here.  Free ehbuf.
	(_bfd_elf_discard_section_eh_frame_hdr): Don't size the section
	if hdr_info->strip.
	(_bfd_elf_maybe_strip_eh_frame_hdr): New.
	* elflink.h (size_dynamic_sections): Call it.
@
text
@d154 1
d158 2
d183 4
a186 1
    hdr = &elf_tdata (abfd)->symtab_hdr;
d188 4
a191 1
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
d218 3
d222 9
a230 2
      free (buf);
      return false;
d235 1
a235 1
  for (esym = buf;
d237 1
a237 1
       esym++)
d242 1
a242 1
      elf_swap_symbol_in (abfd, esym, & sym);
d255 5
a259 1
  free (buf);
d1177 1
d1182 2
d1300 4
a1303 1
    hdr = &elf_tdata (abfd)->symtab_hdr;
d1305 4
a1308 1
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
d1355 8
d1639 9
d1652 1
a1652 1
  for (esym = buf;
d1654 2
a1655 1
       esym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
d1672 1
a1672 1
      elf_swap_symbol_in (abfd, esym, &sym);
d1703 1
a1703 1
      else if (sym.st_shndx > 0 && sym.st_shndx < SHN_LORESERVE)
d2509 2
d2533 1
a2533 1
      || bfd_bread (&esym, amt, input_bfd) != amt)
d2535 12
a2546 1
  elf_swap_symbol_in (input_bfd, &esym, &entry->isym);
d3596 1
a3596 2
	  elf_swap_symbol_out (output_bfd, &isym,
			       (PTR) (Elf_External_Sym *) s->contents);
d4435 2
d4448 2
d4847 1
d4898 1
d4903 1
d4913 1
d4977 4
d5134 8
d5185 1
a5185 1
      for (i = 1; i < elf_elfheader (abfd)->e_shnum; i++)
d5198 2
d5205 53
a5257 23
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (PTR) bfd_malloc (max_external_reloc_size);
  finfo.internal_relocs = ((Elf_Internal_Rela *)
			   bfd_malloc (max_internal_reloc_count
				       * sizeof (Elf_Internal_Rela)
				       * bed->s->int_rels_per_ext_rel));
  finfo.external_syms = ((Elf_External_Sym *)
			 bfd_malloc (max_sym_count
				     * sizeof (Elf_External_Sym)));
  finfo.internal_syms = ((Elf_Internal_Sym *)
			 bfd_malloc (max_sym_count
				     * sizeof (Elf_Internal_Sym)));
  finfo.indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.sections = ((asection **)
		    bfd_malloc (max_sym_count * sizeof (asection *)));
  if ((finfo.contents == NULL && max_contents_size != 0)
      || (finfo.external_relocs == NULL && max_external_reloc_size != 0)
      || (finfo.internal_relocs == NULL && max_internal_reloc_count != 0)
      || (finfo.external_syms == NULL && max_sym_count != 0)
      || (finfo.internal_syms == NULL && max_sym_count != 0)
      || (finfo.indices == NULL && max_sym_count != 0)
      || (finfo.sections == NULL && max_sym_count != 0))
    goto error_return;
d5357 2
d5363 2
a5364 3

	      elf_swap_symbol_out (abfd, &sym,
				   dynsym + elf_section_data (s)->dynindx);
d5377 1
d5387 2
a5388 1
	      if (e->isym.st_shndx > 0 && e->isym.st_shndx < SHN_LORESERVE)
d5403 2
a5404 1
	      elf_swap_symbol_out (abfd, &sym, dynsym + e->dynindx);
d5594 1
a5594 1
	      for (i = 1; i < elf_elfheader (abfd)->e_shnum; i++)
d5689 2
d5699 2
d5723 2
d5733 2
d5754 3
d5790 5
a5794 2
  elf_swap_symbol_out (finfo->output_bfd, elfsym,
		       (PTR) (finfo->symbuf + finfo->symbuf_count));
d5810 1
a5810 1
      Elf_Internal_Shdr *symtab;
d5814 2
a5815 2
      symtab = &elf_tdata (finfo->output_bfd)->symtab_hdr;
      pos = symtab->sh_offset + symtab->sh_size;
d5821 14
a5834 1
      symtab->sh_size += finfo->symbuf_count * sizeof (Elf_External_Sym);
d5986 1
a5986 1
	    if (sym.st_shndx == (unsigned short) -1)
d6099 1
a6099 1
      elf_swap_symbol_out (finfo->output_bfd, &sym, (PTR) esym);
d6271 1
d6277 2
d6327 11
d6340 6
a6345 6
  esym = external_syms;
  esymend = esym + locsymcount;
  isym = finfo->internal_syms;
  pindex = finfo->indices;
  ppsection = finfo->sections;
  for (; esym < esymend; esym++, isym++, pindex++, ppsection++)
d6351 1
a6351 1
      elf_swap_symbol_in (input_bfd, esym, isym);
d6365 2
a6366 1
      else if (isym->st_shndx > 0 && isym->st_shndx < SHN_LORESERVE)
d6419 1
a6419 2
      if (isym->st_shndx > 0
	  && isym->st_shndx < SHN_LORESERVE
d6449 1
a6449 1
      if (osym.st_shndx == (unsigned short) -1)
d6791 1
a6791 1
			  if (isym->st_shndx == (unsigned short) -1)
d7399 1
d7404 1
d7422 1
d7440 11
d7475 4
a7478 1
	      elf_swap_symbol_in (input_bfd, &locsyms[r_symndx], &s);
d7494 4
a7497 1
	      elf_swap_symbol_in (input_bfd, &locsyms[r_symndx], &s);
d8046 1
a8046 1
  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *)cookie;
d8063 10
a8072 3
	elf_swap_symbol_in (rcookie->abfd,
			    (Elf_External_Sym *) rcookie->locsyms + r_symndx,
			    &isym);
d8103 1
a8103 1
	  if (isym.st_shndx > 0 && isym.st_shndx < SHN_LORESERVE)
d8130 1
d8173 1
d8199 4
a8202 2
          if (cookie.locsyms == NULL
              || bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
d8205 3
a8207 5
	      /* Something is very wrong - but we can still do our job for
		 global symbols, so don't give up.  */
	      if (cookie.locsyms)
		free (cookie.locsyms);
	      cookie.locsyms = NULL;
d8209 12
a8220 1
	  else
d8222 2
a8223 1
	      freesyms = cookie.locsyms;
d8225 1
a8225 1
        }
d8278 4
a8281 1
      if (freesyms)
@


1.132
log
@	* elflink.h (elf_bfd_discard_info): Fix segfault when dynobj NULL.
@
text
@d3005 3
@


1.131
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d7953 4
a7956 2
  ehdr = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
				  ".eh_frame_hdr");
@


1.130
log
@2001-11-30  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_add_default_symbol): New.
	(elf_link_add_object_symbols): Call elf_add_default_symbol ()
	to create an indirect symbol from the default for the symbol
	with the default version if needed.
@
text
@d2217 1
a2217 1
      if (stab != NULL)
d2229 1
a2229 1
					     &secdata->stab_info))
d2231 2
d2243 12
a2254 4
	if ((s->flags & SEC_MERGE)
	    && ! _bfd_merge_section (abfd, & hash_table->merge_info, s,
				     & elf_section_data (s)->merge_info))
	  goto error_return;
d2313 10
d5545 13
d5707 1
a5707 1
      && elf_section_data (sec)->merge_info)
d5714 1
a5714 1
				    elf_section_data (sec)->merge_info,
d6206 2
a6207 1
	  if (isec && elf_section_data (isec)->merge_info
d6211 1
a6211 1
					  elf_section_data (isec)->merge_info,
d6395 2
a6396 2
			  && elf_section_data (h->root.u.def.section)->merge_info
			     == NULL)
d6428 2
a6429 1
			  && elf_section_data (sec)->merge_info == NULL)
d6678 1
a6678 1
      else if (elf_section_data (o)->stab_info)
d6680 1
d6682 3
a6684 2
		 (output_bfd, &elf_hash_table (finfo->info)->stab_info,
		  o, &elf_section_data (o)->stab_info, contents)))
d6686 2
a6687 3
	}
      else if (elf_section_data (o)->merge_info)
	{
d6689 1
a6689 1
		 (output_bfd, o, elf_section_data (o)->merge_info)))
d6691 16
a6706 4
	}
      else
	{
	  bfd_size_type sec_size;
d6708 9
a6716 7
	  sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
	  if (! (o->flags & SEC_EXCLUDE)
	      && ! bfd_set_section_contents (output_bfd, o->output_section,
					     contents,
					     (file_ptr) o->output_offset,
					     sec_size))
	    return false;
d7934 2
a7935 1
elf_bfd_discard_info (info)
d7939 1
a7939 1
  asection *o;
d7945 1
d7950 1
a7950 3
      || ! is_elf_hash_table (info)
      || info->strip == strip_all
      || info->strip == strip_debugger)
d7952 4
d7966 12
a7977 2
      o = bfd_get_section_by_name (abfd, ".stab");
      if (! o && ! bed->elf_backend_discard_info)
d8022 1
a8022 1
      if (o)
d8025 1
a8025 1
			 (abfd, o, (PTR) NULL,
d8032 3
a8034 3
		cookie.rels + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      if (_bfd_discard_section_stabs (abfd, o,
					      elf_section_data (o)->stab_info,
d8043 24
d8076 5
d8088 12
a8099 1
  if (strcmp (sec->name, ".stab") == 0)
d8101 2
a8102 7
  else if ((get_elf_backend_data (sec->owner)
	    ->elf_backend_ignore_discarded_relocs != NULL)
	   && (*get_elf_backend_data (sec->owner)
	       ->elf_backend_ignore_discarded_relocs) (sec))
    return true;
  else
    return false;
@


1.129
log
@2001-11-27  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_bfd_discard_info): Skip if the input bfd isn't
	ELF.
@
text
@d42 8
a49 3
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection **, bfd_vma *, struct elf_link_hash_entry **,
	   boolean *, boolean *, boolean *, boolean));
d902 237
d1618 3
a1710 1
	  boolean override;
d1982 2
a1983 5
	  /* If this symbol has a version, and it is the default
             version, we create an indirect symbol from the default
             name to the fully decorated name.  This will cause
             external references which do not specify a version to be
             bound to this version of the symbol.  */
d1985 4
a1988 205
	    {
	      char *p;

	      p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] == ELF_VER_CHR)
		{
		  char *shortname;
		  struct elf_link_hash_entry *hi;
		  boolean override;

		  shortname = bfd_hash_allocate (&info->hash->table,
						 (size_t) (p - name + 1));
		  if (shortname == NULL)
		    goto error_return;
		  strncpy (shortname, name, (size_t) (p - name));
		  shortname[p - name] = '\0';

		  /* We are going to create a new symbol.  Merge it
                     with any existing symbol with this name.  For the
                     purposes of the merge, act as though we were
                     defining the symbol we just defined, although we
                     actually going to define an indirect symbol.  */
		  type_change_ok = false;
		  size_change_ok = false;
		  if (! elf_merge_symbol (abfd, info, shortname, &sym, &sec,
					  &value, &hi, &override,
					  &type_change_ok,
					  &size_change_ok, dt_needed))
		    goto error_return;

		  if (! override)
		    {
		      if (! (_bfd_generic_link_add_one_symbol
			     (info, abfd, shortname, BSF_INDIRECT,
			      bfd_ind_section_ptr, (bfd_vma) 0, name, false,
			      collect, (struct bfd_link_hash_entry **) &hi)))
			goto error_return;
		    }
		  else
		    {
		      /* In this case the symbol named SHORTNAME is
                         overriding the indirect symbol we want to
                         add.  We were planning on making SHORTNAME an
                         indirect symbol referring to NAME.  SHORTNAME
                         is the name without a version.  NAME is the
                         fully versioned name, and it is the default
                         version.

			 Overriding means that we already saw a
			 definition for the symbol SHORTNAME in a
			 regular object, and it is overriding the
			 symbol defined in the dynamic object.

			 When this happens, we actually want to change
			 NAME, the symbol we just added, to refer to
			 SHORTNAME.  This will cause references to
			 NAME in the shared object to become
			 references to SHORTNAME in the regular
			 object.  This is what we expect when we
			 override a function in a shared object: that
			 the references in the shared object will be
			 mapped to the definition in the regular
			 object.  */

		      while (hi->root.type == bfd_link_hash_indirect
			     || hi->root.type == bfd_link_hash_warning)
			hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

		      h->root.type = bfd_link_hash_indirect;
		      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
		      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
			{
			  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
			  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
			  if (hi->elf_link_hash_flags
			      & (ELF_LINK_HASH_REF_REGULAR
				 | ELF_LINK_HASH_DEF_REGULAR))
			    {
			      if (! _bfd_elf_link_record_dynamic_symbol (info,
									 hi))
				goto error_return;
			    }
			}

		      /* Now set HI to H, so that the following code
                         will set the other fields correctly.  */
		      hi = h;
		    }

		  /* If there is a duplicate definition somewhere,
		     then HI may not point to an indirect symbol.  We
		     will have reported an error to the user in that
		     case.  */

		  if (hi->root.type == bfd_link_hash_indirect)
		    {
		      struct elf_link_hash_entry *ht;

		      /* If the symbol became indirect, then we assume
			 that we have not seen a definition before.  */
		      BFD_ASSERT ((hi->elf_link_hash_flags
				   & (ELF_LINK_HASH_DEF_DYNAMIC
				      | ELF_LINK_HASH_DEF_REGULAR))
				  == 0);

		      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
		      (*bed->elf_backend_copy_indirect_symbol) (ht, hi);

		      /* See if the new flags lead us to realize that
			 the symbol must be dynamic.  */
		      if (! dynsym)
			{
			  if (! dynamic)
			    {
			      if (info->shared
				  || ((hi->elf_link_hash_flags
				       & ELF_LINK_HASH_REF_DYNAMIC)
				      != 0))
				dynsym = true;
			    }
			  else
			    {
			      if ((hi->elf_link_hash_flags
				   & ELF_LINK_HASH_REF_REGULAR) != 0)
				dynsym = true;
			    }
			}
		    }

		  /* We also need to define an indirection from the
                     nondefault version of the symbol.  */

		  shortname = bfd_hash_allocate (&info->hash->table,
						 strlen (name));
		  if (shortname == NULL)
		    goto error_return;
		  strncpy (shortname, name, (size_t) (p - name));
		  strcpy (shortname + (p - name), p + 1);

		  /* Once again, merge with any existing symbol.  */
		  type_change_ok = false;
		  size_change_ok = false;
		  if (! elf_merge_symbol (abfd, info, shortname, &sym, &sec,
					  &value, &hi, &override,
					  &type_change_ok,
					  &size_change_ok, dt_needed))
		    goto error_return;

		  if (override)
		    {
		      /* Here SHORTNAME is a versioned name, so we
                         don't expect to see the type of override we
                         do in the case above.  */
		      (*_bfd_error_handler)
			(_("%s: warning: unexpected redefinition of `%s'"),
			 bfd_archive_filename (abfd), shortname);
		    }
		  else
		    {
		      if (! (_bfd_generic_link_add_one_symbol
			     (info, abfd, shortname, BSF_INDIRECT,
			      bfd_ind_section_ptr, (bfd_vma) 0, name, false,
			      collect, (struct bfd_link_hash_entry **) &hi)))
			goto error_return;

		      /* If there is a duplicate definition somewhere,
                         then HI may not point to an indirect symbol.
                         We will have reported an error to the user in
                         that case.  */

		      if (hi->root.type == bfd_link_hash_indirect)
			{
			  /* If the symbol became indirect, then we
                             assume that we have not seen a definition
                             before.  */
			  BFD_ASSERT ((hi->elf_link_hash_flags
				       & (ELF_LINK_HASH_DEF_DYNAMIC
					  | ELF_LINK_HASH_DEF_REGULAR))
				      == 0);

		          (*bed->elf_backend_copy_indirect_symbol) (h, hi);

			  /* See if the new flags lead us to realize
                             that the symbol must be dynamic.  */
			  if (! dynsym)
			    {
			      if (! dynamic)
				{
				  if (info->shared
				      || ((hi->elf_link_hash_flags
					   & ELF_LINK_HASH_REF_DYNAMIC)
					  != 0))
				    dynsym = true;
				}
			      else
				{
				  if ((hi->elf_link_hash_flags
				       & ELF_LINK_HASH_REF_REGULAR) != 0)
				    dynsym = true;
				}
			    }
			}
		    }
		}
	    }
@


1.128
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d7864 3
@


1.127
log
@2001-11-19  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_input_bfd): Assert r_symndx != 0 when
	discarding relocations.
@
text
@d6320 3
a6322 1
						 ->output_section))
d6353 2
a6354 1
			  && bfd_is_abs_section (sec->output_section))
@


1.126
log
@        * elflink.h (elf_reloc_symbol_deleted_p): Catch all relocs against
        local syms from discarded sections.  Update comment.
@
text
@d6331 1
d6363 1
@


1.125
log
@	* elflink.h (elf_link_input_bfd): Complain about all relocs
	against local syms from discarded sections.
	(elf_reloc_symbol_deleted_p): Don't try to swap in external syms.
@
text
@d7814 1
a7814 1
	     but it could be a relocation against a section
a7822 1
		  && ELF_ST_TYPE (isym.st_info) == STT_SECTION
@


1.124
log
@2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* bfd-in.h (bfd_elf32_discard_info): Add prototype.
	(bfd_elf64_discard_info): Likewise.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_reloc_cookie): New.
	(struct elf_backend_data): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and elf_backend_write_section.
	(_bfd_elf32_reloc_symbol_deleted_p): Add prototype.
	(_bfd_elf64_reloc_symbol_deleted_p): Likewise.
	* elf32-mips.c (_bfd_elf32_mips_discard_info): New.
	(_bfd_elf32_mips_ignore_discarded_relocs): New.
	(_bfd_elf32_mips_write_section): New.
	(elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	* elfcode.h (elf_bfd_discard_info): Define.
	(elf_reloc_symbol_deleted_p): Define.
	* elflink.h (elf_link_input_bfd): Check
	elf_section_ignore_discarded_relocs.  Call
	bed->elf_backend_write_section if available.
	(elf_reloc_symbol_deleted_p): New.
	(elf_bfd_discard_info): New.
	(elf_section_ignore_discarded_relocs): New.
	* elfxx-target.h (elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	(elfNN_bed): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and
	elf_backend_write_section.
	* libbfd-in.h (_bfd_discard_section_stabs): Add prototype.
	* libbfd.h: Regenerate.
	* stabs.c (_bfd_discard_section_stabs): New.

2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(struct ld_emulation_xfer_struct): Use it.
@
text
@d6346 5
a6350 2
		      isym = finfo->internal_syms + r_symndx;
		      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
d6352 3
a6354 5
			  asection *sec = finfo->sections[r_symndx];

			  if (sec != NULL
			      && ! bfd_is_abs_section (sec)
			      && bfd_is_abs_section (sec->output_section))
a6355 4
#if BFD_VERSION_DATE < 20031005
			      if ((o->flags & SEC_DEBUGGING) != 0
				  || (sec->flags & SEC_LINK_ONCE) != 0)
				{
d6357 10
a6366 4
				  (*finfo->info->callbacks->warning)
				    (finfo->info,
				     _("warning: relocation against removed section"),
				     NULL, input_bfd, o, rel->r_offset);
d6368 10
a6377 4
				  rel->r_info
				    = ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
				  rel->r_addend = 0;
				}
d6379 10
a6388 23
#endif
				{
				  boolean ok;
				  const char *msg
				    = _("local symbols in discarded section %s");
				  bfd_size_type amt
				    = strlen (sec->name) + strlen (msg) - 1;
				  char *buf = (char *) bfd_malloc (amt);

				  if (buf != NULL)
				    sprintf (buf, msg, sec->name);
				  else
				    buf = (char *) sec->name;
				  ok = (*finfo->info->callbacks
					->undefined_symbol) (finfo->info, buf,
							     input_bfd, o,
							     rel->r_offset,
							     true);
				  if (buf != sec->name)
				    free (buf);
				  if (!ok)
				    return false;
				}
d6594 1
a6594 1
	  && bed->elf_backend_write_section (output_bfd, o, contents))
d7785 1
a7785 1
      if (rcookie->locsyms)
d7787 1
a7787 1
			    ((Elf_External_Sym *)rcookie->locsyms) + r_symndx,
d7952 2
a7953 2
	   && (get_elf_backend_data (sec->owner)
	       ->elf_backend_ignore_discarded_relocs (sec)))
a7957 2


@


1.123
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d78 2
d6292 2
a6293 1
	  if (!finfo->info->relocateable)
d6597 6
a6602 1
      if (elf_section_data (o)->stab_info)
d7767 197
@


1.122
log
@	* Makefile.am (BFD32_BACKENDS): Add elf-strtab.lo.
	(BFD32_BACKENDS_CFILES): Add elf-strtab.c.
	(elf-strtab.lo): Add rule.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-strtab.lo.
	* configure: Rebuilt.
	* elf-bfd.h (elf_strtab_hash): Forward declare.
	(struct elf_link_hash_table): Change dynstr type to
	struct elf_strtab_hash *.
	(struct elf_obj_tdata): Change strtab_ptr type to
	struct elf_strtab_hash *.
	(_bfd_elf_strtab_init, _bfd_elf_strtab_free, _bfd_elf_strtab_add,
	_bfd_elf_strtab_addref, _bfd_elf_strtab_delref,
	_bfd_elf_strtab_clear_all_refs, _bfd_elf_strtab_size,
	_bfd_elf_strtab_offset, _bfd_elf_strtab_emit,
	_bfd_elf_strtab_finalize): New prototypes.
	* elf-strtab.c: New file.
	* elflink.h (elf_link_add_object_symbols): Use _bfd_elf_strtab_add
	and _bfd_elf_strtab_size instead of _bfd_stringtab calls.
	Call _bfd_elf_strtab_delref if DT_NEEDED entry is not needed or
	when forcing dynamic symbol to local.
	(elf_link_create_dynamic_sections): Call
	_bfd_elf_strtab_init instead of elf_stringtab_init.
	(elf_link_record_local_dynamic_symbol): Likewise, change
	dynstr type.  Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.
	(size_dynamic_sections): Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.  For DT_RUNPATH and Verdaux vda_name fields,
	call _bfd_elf_strtab_addref.  Call elf_finalize_dynstr.
	(elf_adjust_dynstr_offsets, elf_finalize_dynstr): New functions.
	(elf_fix_symbol_flags): Call _bfd_elf_strtab_delref when forcing
	dynamic symbol to local.
	(elf_link_assign_sym_version): Likewise.
	(elf_bfd_final_link): Call _bfd_elf_strtab_emit instead of
	_bfd_stringtab_emit.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Change dynstr
	type.  Call _bfd_elf_strtab functions instead of
	_bfd_stringtab functions.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.
	* elf.c (_bfd_elf_init_reloc_shdr): Likewise.
	(elf_fake_sections): Likewise.
	(assign_section_numbers): Call _bfd_elf_strtab_clear_all_refs
	on shstrtab hash table, call _bfd_elf_strtab_addref on each section
	name in the output.  Call _bfd_elf_strtab_finalize and
	use _bfd_elf_strtab_offset to finalize sh_name section header fields.
	(_bfd_elf_compute_section_file_positions): Use _bfd_elf_strtab_size
	instead of _bfd_stringtab_size.
	(prep_headers): Change shstrtab type.
	Use _bfd_elf_strtab calls instead of _bfd_stringtab calls.
@
text
@d6280 39
a6318 37
	  {
	    Elf_Internal_Rela *rel, *relend;
	    /* Run through the relocs looking for any against symbols
	       from discarded sections and section symbols from
	       removed link-once sections.  Complain about relocs
	       against discarded sections.  Zero relocs against removed
	       link-once sections.  We should really complain if
	       anything in the final link tries to use it, but
	       DWARF-based exception handling might have an entry in
	       .eh_frame to describe a routine in the linkonce section,
	       and it turns out to be hard to remove the .eh_frame
	       entry too.  FIXME.  */
	    rel = internal_relocs;
	    relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	    for ( ; rel < relend; rel++)
	      {
		unsigned long r_symndx = ELF_R_SYM (rel->r_info);

		if (r_symndx >= locsymcount
		    || (elf_bad_symtab (input_bfd)
			&& finfo->sections[r_symndx] == NULL))
		  {
		    struct elf_link_hash_entry *h;

		    h = sym_hashes[r_symndx - extsymoff];
		    while (h->root.type == bfd_link_hash_indirect
			   || h->root.type == bfd_link_hash_warning)
		      h = (struct elf_link_hash_entry *) h->root.u.i.link;

		    /* Complain if the definition comes from a
		       discarded section.  */
		    if ((h->root.type == bfd_link_hash_defined
			 || h->root.type == bfd_link_hash_defweak)
			&& ! bfd_is_abs_section (h->root.u.def.section)
			&& bfd_is_abs_section (h->root.u.def.section
					       ->output_section))
		      {
d6320 2
a6321 2
			if ((o->flags & SEC_DEBUGGING) != 0)
			  {
d6323 4
a6326 4
			    (*finfo->info->callbacks->warning)
			      (finfo->info,
			       _("warning: relocation against removed section; zeroing"),
				   NULL, input_bfd, o, rel->r_offset);
d6329 2
a6330 2
			  }
			else
d6332 20
a6351 20
			  {
			    if (! ((*finfo->info->callbacks->undefined_symbol)
				    (finfo->info, h->root.root.string,
				     input_bfd, o, rel->r_offset,
				     true)))
			      return false;
			  }
		      }
		  }
		else
		  {
		    isym = finfo->internal_syms + r_symndx;
		    if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
		      {
			asection *sec = finfo->sections[r_symndx];

			if (sec != NULL
			    && ! bfd_is_abs_section (sec)
			    && bfd_is_abs_section (sec->output_section))
			  {
d6353 3
a6355 3
			    if ((o->flags & SEC_DEBUGGING) != 0
			        || (sec->flags & SEC_LINK_ONCE) != 0)
			      {
d6357 4
a6360 4
				(*finfo->info->callbacks->warning)
				  (finfo->info,
				   _("warning: relocation against removed section"),
				   NULL, input_bfd, o, rel->r_offset);
d6362 5
a6366 3
				memset (rel, 0, sizeof (*rel));
			      }
			    else
d6368 27
a6394 27
			      {
				boolean ok;
				const char *msg
				  = _("local symbols in discarded section %s");
				bfd_size_type amt
				  = strlen (sec->name) + strlen (msg) - 1;
				char *buf = (char *) bfd_malloc (amt);

				if (buf != NULL)
				  sprintf (buf, msg, sec->name);
				else
				  buf = (char *) sec->name;
				ok = (*finfo->info->callbacks
				      ->undefined_symbol) (finfo->info, buf,
							   input_bfd, o,
							   rel->r_offset,
							   true);
				if (buf != sec->name)
				  free (buf);
				if (!ok)
				  return false;
			      }
			  }
		      }
		  }
	      }
	  }
@


1.121
log
@	* elflink.h (elf_link_input_bfd <removed linkonce relocs>): Fix
	bad symtab segfault.  Formatting and warning fixes.  Improve
	error message for internationalisation.
@
text
@d47 2
d1299 2
a1300 3
	  oldsize = _bfd_stringtab_size (hash_table->dynstr);
	  strindex = _bfd_stringtab_add (hash_table->dynstr, name,
					 true, false);
d1304 1
a1304 1
	  if (oldsize == _bfd_stringtab_size (hash_table->dynstr))
d1332 1
d1970 2
d1990 3
a1992 4
	      oldsize = _bfd_stringtab_size (hash_table->dynstr);
	      strindex = _bfd_stringtab_add (hash_table->dynstr,
	      				     elf_dt_soname (abfd),
					     true, false);
d1996 1
a1996 2
	      if (oldsize
		  == _bfd_stringtab_size (hash_table->dynstr))
d2295 1
a2295 1
      elf_hash_table (info)->dynstr = elf_stringtab_init ();
d2395 1
a2395 1
  struct bfd_strtab_hash *dynstr;
d2431 1
a2431 1
      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_stringtab_init ();
d2436 1
a2436 1
  dynstr_index = _bfd_stringtab_add (dynstr, name, true, false);
d2954 2
a2955 2
	  soname_indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					    soname, true, true);
d2974 4
a2977 2
	  indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr, rpath,
				     true, true);
d2990 2
a2991 2
	  indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
				     filter_shlib, true, true);
d3005 2
a3006 2
	      indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					 *p, true, true);
d3088 1
a3088 1
	  strsize = _bfd_stringtab_size (elf_hash_table (info)->dynstr);
d3171 2
d3183 2
a3184 2
	      indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					    name, true, false);
d3243 2
d3264 5
a3268 1
		    defaux.vda_name = n->version_needed->name_indx;
d3367 5
a3371 8
		if (elf_dt_name (t->vn_bfd) != NULL)
		  indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					     elf_dt_name (t->vn_bfd),
					     true, false);
		else
		  indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					     basename (t->vn_bfd->filename),
					     true, false);
d3389 2
a3390 2
		    indx = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
					       a->vna_nodename, true, false);
d3494 4
a3497 1
      s->_raw_size = _bfd_stringtab_size (elf_hash_table (info)->dynstr);
d3507 144
d3750 5
a3754 1
	h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
d4139 2
a4140 3
			      /* FIXME: The name of the symbol has
				 already been recorded in the dynamic
				 string table section.  */
d4251 2
a4252 3
			  /* FIXME: The name of the symbol has already
			     been recorded in the dynamic string table
			     section.  */
d4272 2
a4273 2
	      /* FIXME: The name of the symbol has already been
		 recorded in the dynamic string table section.  */
d5469 2
a5470 2
		  || ! _bfd_stringtab_emit (abfd,
					    elf_hash_table (info)->dynstr))
@


1.120
log
@2001-11-06  H.J. Lu  (hjl@@gnu.org)

	* elflink.h (elf_link_input_bfd): Complain relocs against
	discarded sections.
@
text
@d6126 3
a6128 3
	       removed link-once sections. Complain about relocs
	       against discarded sections. Zero relocs against removed
	       link-once sections. We should really complain if
d6146 1
a6146 1
		    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d6150 1
d6156 2
a6157 1
			&& bfd_is_abs_section (h->root.u.def.section->output_section))
d6199 1
a6199 1
				   _("warning: relocation against removed section; zeroing"),
d6208 6
a6213 6
				const char *msg =
				  _("local symbols in discarded section");
				char *buf
				  = (char *) bfd_malloc
				      (strlen (sec->name) + 3
				       + strlen (msg));
d6215 1
a6215 2
				  sprintf (buf, "%s: %s", msg,
					   sec->name);
d6218 5
a6222 4
				ok = (*finfo->info->callbacks->undefined_symbol)
				       (finfo->info, buf,
					input_bfd, o, rel->r_offset,
					true);
@


1.119
log
@2001-10-31  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_link_output_extsym): Don't clear the visibility
	field for relocateable.
@
text
@d5901 1
d6074 1
a6121 1
#if BFD_VERSION_DATE < 20031005
d6124 10
a6133 7
	    /* Run through the relocs looking for any against section
	       symbols from removed link-once sections.  Zero any such
	       relocs.  We should really complain if anything in the
	       final link tries to use it, but DWARF-based exception
	       handling might have an entry in .eh_frame to describe a
	       routine in the linkonce section, and it turns out to be
	       hard to remove the .eh_frame entry too.  FIXME.  */
d6140 40
a6179 3
		if (r_symndx < locsymcount
		    && (!elf_bad_symtab (input_bfd)
			|| finfo->sections[r_symndx] != NULL))
d6187 1
a6187 1
			    && (sec->flags & SEC_LINK_ONCE) != 0
d6190 4
d6195 8
a6202 4
			    (*finfo->info->callbacks->warning)
			      (finfo->info,
			       _("warning: relocation against removed section; zeroing"),
			       NULL, input_bfd, o, rel->r_offset);
d6204 22
a6225 1
			    memset (rel, 0, sizeof (*rel));
a6230 3
#else
#error "gcc should be fixed by now, and this kludge no longer needed"
#endif
@


1.118
log
@	* elflink.h (elf_link_input_bfd): Zero the reloc instead of doing
	bfd_reloc_type_lookup (bfd, BFD_RELOC_NONE) as bfd_reloc_type_lookup
	doesn't accept BFD_RELOC_* on some targets, eg. hppa.

	* elf32-hppa.c (elf32_hppa_link_hash_entry): Remove plt_abs.
	(hppa_link_hash_newfunc): Likewise.
	(elf32_hppa_finish_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Always allocate .got relocs if shared.
	(elf32_hppa_relocate_section): Output them too.  Similarly
	consolidate .plt reloc code, and no longer initialise .plt
	when a reloc is output.
	(elf32_hppa_finish_dynamic_symbol): Only initialise .plt entries
	when no reloc is output.

	From Herbert Xu <herbert@@gondor.apana.org.au>
	* elf32-hppa.c (final_link_relocate): Call bfd_set_error for
	unreachable branches.
@
text
@d5699 2
a5700 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
@


1.117
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@a5899 2
  reloc_howto_type *none_howto;
  bfd_vma none_r_info;
a6070 3
  none_howto = bfd_reloc_type_lookup (output_bfd, BFD_RELOC_NONE);
  none_r_info = ELF_R_INFO (0, none_howto->type);

d6123 6
a6128 7
	       symbols from removed link-once sections.  Set any such
	       relocs to be against 0.  We should really complain if
	       anything in the final link tries to use it, but
	       DWARF-based exception handling might have an entry in
	       .eh_frame to describe a routine in the linkonce section,
	       and it turns out to be hard to remove the .eh_frame entry
	       too.  FIXME.  */
a6147 2
			    rel->r_info = none_r_info;

d6154 1
d6161 1
a6161 1
#error "This kludge ought to be fixed properly in gcc by now"
@


1.116
log
@2001-10-16  Jeff Holcomb  <jeffh@@redhat.com>

        * elflink.h (elf_link_sort_relocs): Remove unnecessary pointer
        casts.
@
text
@d4483 1
a4483 1
  qsort (rela, count, sizeof (*rela), elf_link_sort_cmp1);
d4492 1
a4492 1
  qsort (rela + ret, count - ret, sizeof (*rela), elf_link_sort_cmp2);
@


1.115
log
@2001-10-15  H.J. Lu <hjl@@gnu.org>

	* elflink.h (elf_link_input_bfd): Set type to BFD_RELOC_NONE
	for relocations against discarded link-once section.
@
text
@d4505 1
a4505 1
	    erelend = (Elf_External_Rel *) ((PTR) o->contents + o->_raw_size);
d4522 1
a4522 1
	    erelaend = (Elf_External_Rela *) ((PTR) o->contents + o->_raw_size);
@


1.114
log
@	* elflink.h (elf_link_sort_cmp2): Don't mix PLT and non-PLT
	relocations against the same symbol in .rel{,a}.dyn section.
@
text
@d5900 2
d6073 3
d6154 1
a6154 2
			    long r_type = ELF_R_TYPE (rel->r_info);
			    rel->r_info = ELF_R_INFO (0, r_type);
@


1.113
log
@	* elf-bfd.h (struct bfd_elf_section_data): Add "group" and
	"next_in_group".  Fix gp and gp_size comments.
	* elf.c (union elf_internal_group): New.
	(setup_group): New function.
	(_bfd_elf_make_section_from_shdr): Set BFD flags for SHT_GROUP.
	Call setup_group for SHF_GROUP sections.
	(bfd_section_from_shdr): Build a BFD section for SHT_GROUP.
	(elf_fake_sections): Set header type for SEC_GROUP, and header
	flags for sections in a group.
	(set_group_contents): New function.
	(_bfd_elf_compute_section_file_positions): Call it.
	(assign_section_numbers): Set sh_link for SHT_GROUP.
	* elflink.h (gc_mark_hook): Handle section groups.
	* elfxx-target.h: Add SEC_GROUP to applicable_flags.
	* section.c (SEC_GROUP): Define.
	(struct sec): Comment fixes.
	* bfd-in2.h: Regenerate.

	* elf.c (bfd_elf_print_symbol): Formatting fix; migrate expression
	out of function args.
	(_bfd_elf_canonicalize_reloc): Similarly.
	(_bfd_elf_get_symtab): Here too.
	(_bfd_elf_canonicalize_dynamic_symtab): And here.
	* elfcode.h (elf_slurp_symbol_table): Don't recalculate size for
	bfd_bread, and remove unnecessary cast.
@
text
@d4381 2
a4382 2
  copya = a->type == reloc_class_copy;
  copyb = b->type == reloc_class_copy;
@


1.112
log
@	* elflink.h (elf_link_input_bfd): Don't zero discarded link-once
	section sym values.  Instead replace any relocs against them with
	relocs against STN_UNDEF, which has a zero value.
@
text
@d6881 2
a6882 1
   it, and all the sections which define symbols to which it refers.  */
d6892 2
a6893 1
  boolean ret = true;
d6897 6
d6904 1
a6904 1

@


1.111
log
@	* elflink.h (elf_fix_symbol_flags): Copy flags to weakdef using
	elf_backend_copy_indirect_symbol so that backend has a chance to
	copy other necessary fields.
	* elf-bfd.h (struct elf_backend_data): Update description of
	elf_backend_copy_indirect_symbol.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Bail out after
	copying flags if this is a weakdef.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_link_hash_lookup rather
	than bfd_link_hash_lookup.
	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Don't do copy
	reloc processing for weakdefs.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
@
text
@a5995 14
	  /* If this is a discarded link-once section symbol, set its
	     value to 0.  We should really undefine it, and complain
	     if anything in the final link tries to use it, but
	     DWARF-based exception handling might have an entry in
	     .eh_frame to describe a routine in the linkonce section,
	     and it turns out to be hard to remove the .eh_frame entry
	     too.  FIXME.  */
	  if (isec != NULL
	      && (bfd_get_section_flags (input_bfd, isec) & SEC_LINK_ONCE) != 0
	      && bfd_is_abs_section (isec->output_section))
	    {
	      isym->st_value = 0;
	    }

d6118 48
@


1.110
log
@	* section.c (struct sec): Remove kept_section.
	(STD_SECTION): Remove kept_section initialisation.
	(bfd_make_section_anyway): Here too.
	* ecoff.c (bfd_debug_section): Remove kept_section initialisation.
	* cofflink.c (_bfd_coff_link_input_bfd): Don't test kept_section.
	* elflink.h (elf_link_input_bfd): Set discarded link-once section
	symbols to zero, and remove all code involved with kept_section
	and tracking section symbol values.
	* bfd-in2.h: Regenerate.
	* configure.in: Bump version number.
	* configure: Regenerate.

	* ldlang.c (section_already_linked): Remove assignment to kept_section.
@
text
@d3618 6
a3623 5
	weakdef->elf_link_hash_flags |=
	  (h->elf_link_hash_flags
	   & (ELF_LINK_HASH_REF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR_NONWEAK
	      | ELF_LINK_NON_GOT_REF));
@


1.109
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@a5964 1
      name = NULL;
d5966 1
a5966 4
        {
	  isec = bfd_und_section_ptr;
	  name = isec->name;
	}
d5978 1
a5978 4
	{
	  isec = bfd_abs_section_ptr;
	  name = isec->name;
	}
d5980 1
a5980 4
	{
	  isec = bfd_com_section_ptr;
	  name = isec->name;
	}
d5995 7
a6001 23
	  asection *ksec;

	  /* Save away all section symbol values.  */
	  if (isec != NULL)
	    {
	      if (name)
		{
		  if (isec->symbol->value != isym->st_value)
		    (*_bfd_error_handler)
		      (_("%s: invalid section symbol index 0x%x (%s) ignored"),
		       bfd_archive_filename (input_bfd), isym->st_shndx,
		       name);
		  continue;
		}
	      isec->symbol->value = isym->st_value;
	    }

	  /* If this is a discarded link-once section symbol, update
	     it's value to that of the kept section symbol.  The
	     linker will keep the first of any matching link-once
	     sections, so we should have already seen it's section
	     symbol.  I trust no-one will have the bright idea of
	     re-ordering the bfd list...  */
d6004 1
a6004 1
	      && (ksec = isec->kept_section) != NULL)
d6006 1
a6006 6
	      isym->st_value = ksec->symbol->value;

	      /* That put the value right, but the section info is all
		 wrong.  I hope this works.  */
	      isec->output_offset = ksec->output_offset;
	      isec->output_section = ksec->output_section;
@


1.108
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d2923 4
@


1.107
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d4341 2
a4342 2
  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *)A;
  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *)B;
d4368 2
a4369 2
  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *)A;
  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *)B;
d4398 2
a4399 1
  size_t count, size, i, j, ret;
d4425 1
a4425 1
  rela = (struct elf_link_sort_rela *) calloc (sizeof (*rela), count);
d4445 1
a4445 1
	    erelend = (Elf_External_Rel *) ((PTR) o->contents + o->_raw_size);
d4454 1
a4454 2
		s->type = ((*bed->elf_backend_reloc_type_class)
			   ((int) ELF_R_TYPE (s->u.rel.r_info)));
d4463 1
a4463 1
	    erelaend = (Elf_External_Rela *) ((PTR) o->contents + o->_raw_size);
d4473 1
a4473 2
		s->type = ((*bed->elf_backend_reloc_type_class)
			   ((int) ELF_R_TYPE (s->u.rel.r_info)));
@


1.106
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1488 1
a1488 1
			     bfd_get_filename (abfd), name, vernum,
d1529 1
a1529 1
			     bfd_get_filename (abfd), name, vernum);
d1650 1
a1650 1
		   bfd_get_filename (abfd));
d1672 1
a1672 1
		   bfd_get_filename (abfd));
d1895 1
a1895 1
			 bfd_get_filename (abfd), shortname);
d6012 1
a6012 1
		       bfd_get_filename (input_bfd), isym->st_shndx,
d7291 1
a7291 1
			 bfd_get_filename (abfd), sec->name,
@


1.105
log
@Fix typo
@
text
@d148 3
a150 3
  size_t symcount;
  size_t extsymcount;
  size_t extsymoff;
d152 2
d190 2
a191 2
  buf = ((Elf_External_Sym *)
	 bfd_malloc (extsymcount * sizeof (Elf_External_Sym)));
d197 3
a199 5
  if (bfd_seek (abfd,
		hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym),
		SEEK_SET) != 0
      || (bfd_read ((PTR) buf, sizeof (Elf_External_Sym), extsymcount, abfd)
	  != extsymcount * sizeof (Elf_External_Sym)))
d267 1
d284 4
a287 2
  defined = (boolean *) bfd_malloc (c * sizeof (boolean));
  included = (boolean *) bfd_malloc (c * sizeof (boolean));
d290 2
a291 2
  memset (defined, 0, c * sizeof (boolean));
  memset (included, 0, c * sizeof (boolean));
d339 1
a339 1
	      copy = bfd_alloc (abfd, p - symdef->name + 1);
d342 1
a342 1
	      memcpy (copy, symdef->name, p - symdef->name);
d908 3
a910 3
  size_t symcount;
  size_t extsymcount;
  size_t extsymoff;
d923 2
d1049 1
d1051 1
a1051 2
	      || (bfd_read ((PTR) extversym, 1, versymhdr->sh_size, abfd)
		  != versymhdr->sh_size))
d1072 2
a1073 2
  buf = ((Elf_External_Sym *)
	 bfd_malloc (extsymcount * sizeof (Elf_External_Sym)));
d1079 2
a1080 3
  sym_hash = ((struct elf_link_hash_entry **)
	      bfd_alloc (abfd,
			 extsymcount * sizeof (struct elf_link_hash_entry *)));
d1139 1
a1139 1
	  unsigned long link;
d1143 1
a1143 1
	  dynbuf = (Elf_External_Dyn *) bfd_malloc ((size_t) s->_raw_size);
d1154 1
a1154 1
	  link = elf_elfsections (abfd)[elfsec]->sh_link;
d1159 2
a1160 2
	       when LINK refers to a section that is not a string table and
	       tries to find the string table for the ".dynsym" section
d1162 2
a1163 2
	    Elf_Internal_Shdr *hdr = elf_elfsections (abfd)[link];
	    if (hdr->sh_type != SHT_STRTAB)
d1165 3
a1167 3
		asection *s = bfd_get_section_by_name (abfd, ".dynsym");
		int elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
		if (elfsec == -1)
d1169 1
a1169 1
		link = elf_elfsections (abfd)[elfsec]->sh_link;
d1184 2
a1185 2
		  name = bfd_elf_string_from_elf_section (abfd, link,
							  dyn.d_un.d_val);
d1193 1
d1195 3
a1197 4
		  n = ((struct bfd_link_needed_list *)
		       bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
		  fnm = bfd_elf_string_from_elf_section (abfd, link,
							 dyn.d_un.d_val);
d1200 1
a1200 1
		  anm = bfd_alloc (abfd, strlen (fnm) + 1);
d1217 1
d1226 3
a1228 4
		  n = ((struct bfd_link_needed_list *)
		       bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
		  fnm = bfd_elf_string_from_elf_section (abfd, link,
							 dyn.d_un.d_val);
d1231 1
a1231 1
		  anm = bfd_alloc (abfd, strlen (fnm) + 1);
d1251 1
d1253 3
a1255 4
		  n = ((struct bfd_link_needed_list *)
		       bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
		  fnm = bfd_elf_string_from_elf_section (abfd, link,
							 dyn.d_un.d_val);
d1258 1
a1258 1
		  anm = bfd_alloc (abfd, strlen (fnm) + 1);
d1336 1
a1336 1
	  if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
d1347 4
a1350 5
  if (bfd_seek (abfd,
		hdr->sh_offset + extsymoff * sizeof (Elf_External_Sym),
		SEEK_SET) != 0
      || (bfd_read ((PTR) buf, sizeof (Elf_External_Sym), extsymcount, abfd)
	  != extsymcount * sizeof (Elf_External_Sym)))
d1478 2
a1479 1
		  int namelen, newlen;
d1751 1
a1751 1
						 p - name + 1);
d1754 1
a1754 1
		  strncpy (shortname, name, p - name);
d1876 1
a1876 1
		  strncpy (shortname, name, p - name);
d2017 1
a2017 1
	      if (! elf_add_dynamic_entry (info, DT_NEEDED, strindex))
d2356 1
a2356 1
  size_t newsize;
d2397 2
d2409 1
a2409 1
    bfd_alloc (input_bfd, sizeof (*entry));
d2414 4
a2417 6
  if (bfd_seek (input_bfd,
		(elf_tdata (input_bfd)->symtab_hdr.sh_offset
		 + input_indx * sizeof (Elf_External_Sym)),
		SEEK_SET) != 0
      || (bfd_read (&esym, sizeof (Elf_External_Sym), 1, input_bfd)
	  != sizeof (Elf_External_Sym)))
d2474 1
d2485 1
a2485 2
  if (bfd_read (external_relocs, 1, shdr->sh_size, abfd)
      != shdr->sh_size)
d2501 2
a2502 2
      irel = bfd_alloc (abfd, (bed->s->int_rels_per_ext_rel
			       * sizeof (Elf_Internal_Rel)));
d2577 1
a2577 1
      size_t size;
d2579 2
a2580 2
      size = (o->reloc_count * bed->s->int_rels_per_ext_rel
	      * sizeof (Elf_Internal_Rela));
d2591 1
a2591 1
      size_t size = (size_t) rel_hdr->sh_size;
d2594 1
a2594 1
	size += (size_t) elf_section_data (o)->rel_hdr2->sh_size;
d2760 1
d2765 3
a2767 2
  hashcodes = (unsigned long int *) bfd_malloc (dynsymcount
						* sizeof (unsigned long int));
d2798 3
a2800 2
      counts = (unsigned long int *) bfd_malloc (maxsize
						 * sizeof (unsigned long int));
d2951 2
a2952 1
	      || ! elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
d2958 2
a2959 1
	  if (! elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
d2971 1
a2971 1
	      || ! elf_add_dynamic_entry (info, DT_RPATH, indx)
d2973 2
a2974 1
		  && ! elf_add_dynamic_entry (info, DT_RUNPATH, indx)))
d2985 1
a2985 1
	      || ! elf_add_dynamic_entry (info, DT_FILTER, indx))
d3000 2
a3001 1
		  || ! elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
d3055 1
a3055 1
	  if (! elf_add_dynamic_entry (info, DT_INIT, 0))
d3067 1
a3067 1
	  if (! elf_add_dynamic_entry (info, DT_FINI, 0))
d3081 6
a3086 6
	  if (! elf_add_dynamic_entry (info, DT_HASH, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || ! elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || ! elf_add_dynamic_entry (info, DT_SYMENT,
					  sizeof (Elf_External_Sym)))
d3099 1
a3099 1
      size_t dynsymcount;
d3264 3
a3266 2
	  if (! elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || ! elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
d3274 1
a3274 1
	  if (! elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
d3284 2
a3285 1
	  if (! elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
d3332 1
a3332 1
	    s->contents = (bfd_byte *) bfd_alloc (output_bfd, size);
d3392 4
a3395 2
	    if (! elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| ! elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
d3427 1
a3427 1
	  if (! elf_add_dynamic_entry (info, DT_VERSYM, 0))
d3472 3
a3474 2
      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
d3484 1
a3484 1
	if (! elf_add_dynamic_entry (info, DT_NULL, 0))
d3808 1
d3835 2
a3836 1
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, sizeof *t);
d3848 2
a3849 1
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, sizeof *a);
d3880 2
a3881 3
  struct elf_assign_sym_version_info *sinfo =
    (struct elf_assign_sym_version_info *) data;
  struct bfd_link_info *info = sinfo->info;
d3885 4
d3936 1
a3936 1
	      int len;
d3941 1
a3941 1
	      alc = bfd_alloc (sinfo->output_bfd, len);
d4001 1
d4003 1
a4003 1
	       bfd_alloc (sinfo->output_bfd, sizeof *t));
d4195 2
a4196 2
  unsigned reloc_count;
  unsigned num_rel_hashes;
d4207 1
a4207 1
  
d4254 1
d4256 1
a4256 2
  irel = (Elf_Internal_Rel *) bfd_zmalloc (sizeof (Elf_Internal_Rel)
					   * bed->s->int_rels_per_ext_rel);
d4263 2
a4264 2
  irela = (Elf_Internal_Rela *) bfd_zmalloc (sizeof (Elf_Internal_Rela)
					     * bed->s->int_rels_per_ext_rel);
d4428 2
a4429 1
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
d4453 3
a4455 3
		s->type = (*bed->elf_backend_reloc_type_class)
			    (ELF_R_TYPE (s->u.rel.r_info));
	      }	    
d4468 2
a4469 1
		  (*bed->s->swap_reloca_in) (dynobj, (bfd_byte *) erela, &s->u.rela);
d4473 3
a4475 3
		s->type = (*bed->elf_backend_reloc_type_class)
			    (ELF_R_TYPE (s->u.rel.r_info));
	      }	    
d4489 1
a4489 1
  
d4506 2
a4507 1
		  (*bed->s->swap_reloc_out) (abfd, &s->u.rel, (bfd_byte *) erel);
d4523 2
a4524 1
		  (*bed->s->swap_reloca_out) (dynobj, &s->u.rela, (bfd_byte *) erela);
d4527 1
a4527 1
	      }	    
d4550 4
a4553 4
  size_t max_contents_size;
  size_t max_external_reloc_size;
  size_t max_internal_reloc_count;
  size_t max_sym_count;
d4564 1
d4828 3
a4830 2
  finfo.symbuf = ((Elf_External_Sym *)
		  bfd_malloc (finfo.symbuf_size * sizeof (Elf_External_Sym)));
d5080 6
a5085 5
      if (! (*bed->elf_backend_output_arch_syms)
	      (abfd, info, (PTR) &finfo,
	       (boolean (*) PARAMS ((PTR, const char *,
	                    Elf_Internal_Sym *, asection *)))
	       elf_link_output_sym))
d5296 2
a5297 1
					      o->contents, o->output_offset,
a5302 2
	      file_ptr off;

d5439 2
d5443 4
a5446 6

      if (bfd_seek (finfo->output_bfd, symtab->sh_offset + symtab->sh_size,
		    SEEK_SET) != 0
	  || (bfd_write ((PTR) finfo->symbuf, finfo->symbuf_count,
			 sizeof (Elf_External_Sym), finfo->output_bfd)
	      != finfo->symbuf_count * sizeof (Elf_External_Sym)))
d5530 1
a5530 1
	      (asection *) NULL, 0, true)))
d5709 1
d5712 2
a5713 5

      elf_swap_symbol_out (finfo->output_bfd, &sym,
			   (PTR) (((Elf_External_Sym *)
				   finfo->dynsym_sec->contents)
				  + h->dynindx));
d5722 2
a5723 1
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
d5731 1
d5751 3
a5753 4
	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym,
				    (((Elf_External_Versym *)
				      finfo->symver_sec->contents)
				     + h->dynindx));
d5791 1
d5821 3
a5823 3
      
      irel = (Elf_Internal_Rel *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
					       * sizeof (Elf_Internal_Rel));
d5834 1
a5834 1
	  
d5930 1
d5933 1
a5933 3
	  || (bfd_read (external_syms, sizeof (Elf_External_Sym),
			locsymcount, input_bfd)
	      != locsymcount * sizeof (Elf_External_Sym)))
d6194 3
a6196 3
	      void (* reloc_emitter) PARAMS ((bfd *, asection *,
					      Elf_Internal_Shdr *,
					      Elf_Internal_Rela *));
d6201 1
a6201 2
	      irelaend = irela
		         + o->reloc_count * bed->s->int_rels_per_ext_rel;
a6207 1
		  Elf_Internal_Sym *isym;
d6290 1
a6290 1
			  unsigned long link;
d6304 1
a6304 1
			  link = symtab_hdr->sh_link;
d6306 1
a6306 1
				  (input_bfd, link, isym->st_name));
d6349 2
a6350 2
                  internal_relocs += NUM_SHDR_ENTRIES (input_rel_hdr)
				     * bed->s->int_rels_per_ext_rel;
d6373 8
a6380 6
	  if (! (o->flags & SEC_EXCLUDE) &&
	      ! bfd_set_section_contents (output_bfd, o->output_section,
					  contents, o->output_offset,
					  (o->_cooked_size != 0
					   ? o->_cooked_size
					   : o->_raw_size)))
d6477 1
d6483 1
a6483 1
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
d6488 1
d6492 1
d6494 5
d6500 2
a6501 7
		 (info,
		  (link_order->type == bfd_section_reloc_link_order
		   ? bfd_section_name (output_bfd,
				       link_order->u.reloc.p->u.section)
		   : link_order->u.reloc.p->u.name),
		  howto->name, addend, (bfd *) NULL, (asection *) NULL,
		  (bfd_vma) 0)))
d6526 1
d6530 3
a6532 3
      
      irel = (Elf_Internal_Rel *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
					       * sizeof (Elf_Internal_Rel));
d6535 1
a6535 1
      
d6552 1
d6556 3
a6558 3
      
      irela = (Elf_Internal_Rela *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
						 * sizeof (Elf_Internal_Rela));
d6593 2
a6594 1
  unsigned long r_symndx = ELF_R_SYM (rel->r_info);;
d6629 3
a6631 3
	  ptr = (elf_linker_section_pointers_t **)
	    bfd_alloc (abfd,
		       num_symbols * sizeof (elf_linker_section_pointers_t *));
d6662 2
a6663 2
  linker_section_ptr = (elf_linker_section_pointers_t *)
    bfd_alloc (abfd, sizeof (elf_linker_section_pointers_t));
d6791 1
d6794 1
d6796 2
a6797 3
	      outrel = (Elf_Internal_Rela *)
		bfd_zmalloc (sizeof (Elf_Internal_Rela)
			     * bed->s->int_rels_per_ext_rel);
d6821 3
a6823 5
	      elf_swap_reloca_out (output_bfd, outrel,
				   (((Elf_External_Rela *)
				     lsect->section->contents)
				    + (elf_section_data (lsect->section)
				       ->rel_count)));
d6825 1
a6825 1
	      
d6921 2
a6922 2
	  locsyms = freesyms =
	    bfd_malloc (nlocsyms * sizeof (Elf_External_Sym));
d6925 1
a6925 3
	      || (bfd_read (locsyms, sizeof (Elf_External_Sym),
			    nlocsyms, input_bfd)
		  != nlocsyms * sizeof (Elf_External_Sym)))
d7208 1
a7208 1
    PARAMS ((bfd *abfd, struct bfd_link_info *, Elf_Internal_Rela *,
d7296 1
a7296 1
win:
d7350 1
a7350 1
	  ptr = bfd_realloc (ptr - 1, bytes);
d7362 1
a7362 1
	ptr = bfd_zmalloc (bytes);
d7494 2
a7495 2
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
@


1.104
log
@Fix off-by-one error whilst sweeping vtable relocs
@
text
@d5983 1
a5983 1
		      (_("%s: invalid section symbol index 0x%x (%s) ingored"),
@


1.103
log
@Apply H.J.'s patch to revert change to elfxx-target.h
Apply my patch to allow SREC as output format.
@
text
@d7104 1
a7104 1
	  while (--n != 0)
d7106 4
a7109 2
	      if (*pu) *cu = true;
	      pu++, cu++;
@


1.102
log
@	* elflink.h (elf_link_sort_cmp1): Sort RELATIVE relocs first, not
	last.
	(elf_link_sort_relocs): Adjust accordingly.

	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Add reltext flag.
	(elf64_alpha_check_relocs): Set it if section this reloc is against
	is read-only.  Set DF_TEXTREL if a RELATIVE reloc is needed against
	read-only section.
	(elf64_alpha_calc_dynrel_sizes): Set DF_TEXTREL flag if relocation
	is is against read-only section.
	(elf64_alpha_size_dynamic_sections): Use DF_TEXTREL flag, don't
	check section names.
	(elf64_alpha_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d919 3
d976 1
a976 1
		  h = elf_link_hash_lookup (elf_hash_table (info), name,
d1091 2
a1092 1
	  && ! elf_hash_table (info)->dynamic_sections_created
d1099 2
d1203 1
a1203 1
		  for (pn = &elf_hash_table (info)->needed;
d1218 2
a1219 2
		  if (rpath && elf_hash_table (info)->runpath)
		    elf_hash_table (info)->runpath = NULL;
d1234 1
a1234 1
		  for (pn = &elf_hash_table (info)->runpath;
d1261 1
a1261 1
		  for (pn = &elf_hash_table (info)->runpath;
d1286 3
a1288 5
      if (! elf_hash_table (info)->dynamic_sections_created)
	{
	  if (! elf_link_create_dynamic_sections (abfd, info))
	    goto error_return;
	}
d1293 2
a1294 2
	  oldsize = _bfd_stringtab_size (elf_hash_table (info)->dynstr);
	  strindex = _bfd_stringtab_add (elf_hash_table (info)->dynstr, name,
d1299 1
a1299 1
	  if (oldsize == _bfd_stringtab_size (elf_hash_table (info)->dynstr))
d1309 1
a1309 2
	      sdyn = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
					      ".dynamic");
d1319 1
a1319 2
		  elf_swap_dyn_in (elf_hash_table (info)->dynobj, dyncon,
				   &dyn);
d1974 3
d1982 2
a1983 2
	      oldsize = _bfd_stringtab_size (elf_hash_table (info)->dynstr);
	      strindex = _bfd_stringtab_add (elf_hash_table (info)->dynstr,
d1990 1
a1990 1
		  == _bfd_stringtab_size (elf_hash_table (info)->dynstr))
d1995 1
a1995 1
		  sdyn = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
d2006 1
a2006 1
		      elf_swap_dyn_in (elf_hash_table (info)->dynobj,
d2163 1
d2179 1
a2179 1
					     &elf_hash_table (info)->stab_info,
d2187 2
a2188 1
  if (! info->relocateable && ! dynamic)
d2194 2
a2195 3
	    && ! _bfd_merge_section (abfd,
				     &elf_hash_table (info)->merge_info,
				     s, &elf_section_data (s)->merge_info))
d2228 3
d2355 3
d2394 3
d2913 3
d3563 1
d3570 1
d3625 3
d4537 3
@


1.101
log
@	* elf-bfd.h (enum elf_reloc_type_class): New.
	(struct elf_backend_data): Add elf_backend_reloc_type_class.
	(_bfd_elf_reloc_type_class): New.
	* elfxx-target.h (elf_backend_reloc_type_class): Define.
	(elfNN_bed): Add elf_backend_reloc_type_class.
	* elf.c (_bfd_elf_reloc_type_class): New.
	* elf32-i386.c (elf_i386_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(elf_i386_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_i386_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_sparc_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_sparc_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf64-sparc.c (sparc64_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(sparc64_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(sparc64_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add reltext field.
	(elfNN_ia64_hash_table_create): Clear ia64_info.
	(get_reloc_section): Set DF_TEXTREL if the reloc is against read-only
	section.
	(elfNN_ia64_size_dynamic_sections): Use ia64_info->reltext flag
	instead of looking up section names for DT_TEXTREL.
	(elfNN_ia64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elflink.h (size_dynamic_sections): Add spare DT_NULL tags.
	(struct elf_link_sort_rela): New.
	(elf_link_sort_cmp1, elf_link_sort_cmp2, elf_link_sort_relocs): New.
	(elf_bfd_final_link): Call elf_link_sort_relocs.
	Convert one spare DT_NULL into DT_RELCOUNT resp. DT_RELACOUNT if
	necessary.

	* bfdlink.h (struct bfd_link_info): Add combreloc and
	spare_dynamic_tags fields.

	* emultempl/elf32.em (place_orphan): Place orphan .rel* sections
	into .rel.dyn resp. .rela.dyn if combreloc.
	(get_script): If .x linker script is equal to .xn, only put it
	once into the binary.
	Add .xc and .xsc scripts.
	(parse_args): Handle -z combreloc and -z nocombreloc.
	* scripttempl/elf.sc (.rela.sbss): Fix a typo.
	For .xc and .xsc scripts put all .rel* or .rela* input sections
	but .rel*.plt and PLT-like sections into .rel.dyn resp. .rela.dyn.
	* genscripts.sh (GENERATE_COMBRELOC_SCRIPT): Set if SCRIPT_NAME
	is elf.
	Strip trailing whitespace from script.
	Generate .xc and .xsc scripts if requested.
	* ldmain.c (main): Initialize link_info.combreloc and
	link_info.spare_dynamic_tags.
	* lexsup.c (OPTION_SPARE_DYNAMIC_TAGS): Define.
	(ld_options): Add --spare-dynamic-tags option.
	(parse_args): Likewise.
	* ld.texinfo: Document -z combreloc and -z nocombreloc.
	* ldint.texinfo: Document .xc and .xsc linker scripts.
	* NEWS: Add notes about -z combreloc and SHF_MERGE.
@
text
@d4303 2
a4305 2
  if (relativea > relativeb)
    return 1;
d4432 3
a4434 1
  for (i = 0, j = 0; i < count && rela[i].type != reloc_class_relative; i++)
d4440 1
a4440 2
  ret = count - i;
  qsort (rela, i, sizeof (*rela), elf_link_sort_cmp2);
@


1.100
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d70 6
d3074 1
d3449 3
a3451 2
      if (! elf_add_dynamic_entry (info, DT_NULL, 0))
	return false;
d4281 204
d4511 2
d5083 3
d5109 17
@


1.99
log
@* elflink.h (elf_link_output_extsym): Revert 1999-04-10.
@
text
@d33 4
d61 2
d1942 1
a1942 2
		  if (! _bfd_elf_link_record_dynamic_symbol (info,
							     h->weakdef))
a2610 1
/*ARGSUSED*/
d2628 1
a2628 1
    h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d2650 1
a2650 1
  /* When possible, keep the original type of the symbol */
d3146 1
a3146 1
				    (Elf_External_Verdef *)p);
d4730 1
a4730 1
	(Elf_External_Sym *)finfo.dynsym_sec->contents;
d5120 1
a5120 2
							    name, true,
							    false);
d5391 2
a5392 2
      && (ELF_ST_BIND(sym.st_info) == STB_GLOBAL
	  || ELF_ST_BIND(sym.st_info) == STB_WEAK))
d5406 1
a5406 1
    sym.st_other ^= ELF_ST_VISIBILITY(sym.st_other);
d6018 2
a6019 3
			  name = bfd_elf_string_from_elf_section (input_bfd,
								  link,
								  isym->st_name);
d6034 2
a6035 1
			  finfo->indices[r_symndx] = bfd_get_symcount (output_bfd);
d6050 2
a6051 1
                  && ! (finfo->info->relocateable || finfo->info->emitrelocations))
d6303 1
a6303 1
  /* Is this a global symbol? */
d6306 1
a6306 1
      /* Has this symbol already been allocated, if so, our work is done */
d6323 1
a6323 2

  else  /* Allocation of a pointer to a local symbol */
d6325 1
d6328 1
a6328 1
      /* Allocate a table to hold the local symbols if first time */
d6335 2
a6336 1
	    bfd_alloc (abfd, num_symbols * sizeof (elf_linker_section_pointers_t *));
d6343 1
a6343 1
	    ptr[i] = (elf_linker_section_pointers_t *)0;
d6346 1
a6346 1
      /* Has this symbol already been allocated, if so, our work is done */
d6364 2
a6365 2
  /* Allocate space for a pointer in the linker section, and allocate a new pointer record
     from internal memory.  */
d6382 2
a6383 1
      linker_section_ptr->offset = lsect->section->_raw_size - lsect->hole_size + (ARCH_SIZE / 8);
d6386 1
a6386 1
      if (lsect->sym_hash)	/* Bump up symbol value if needed */
d6388 1
d6393 2
a6394 2
		   (long)ARCH_SIZE / 8,
		   (long)lsect->sym_hash->root.u.def.value);
d6405 4
a6408 2
  fprintf (stderr, "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long)linker_section_ptr->offset, (long)lsect->section->_raw_size);
d6424 2
a6425 1
elf_finish_pointer_linker_section (output_bfd, input_bfd, info, lsect, h, relocation, rel, relative_reloc)
d6439 1
a6439 1
  if (h != NULL)		/* global symbol */
d6441 5
a6445 3
      linker_section_ptr = _bfd_elf_find_pointer_linker_section (h->linker_section_pointer,
								 rel->r_addend,
								 lsect->which);
d6465 4
a6468 2
	      bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
			  lsect->section->contents + linker_section_ptr->offset);
d6472 1
a6472 1
  else				/* local symbol */
d6474 1
d6478 4
a6481 3
      linker_section_ptr = _bfd_elf_find_pointer_linker_section (elf_local_ptr_offsets (input_bfd)[r_symndx],
								 rel->r_addend,
								 lsect->which);
d6485 1
a6485 1
      /* Write out pointer if it hasn't been rewritten out before */
d6499 3
a6501 2
	      outrel = (Elf_Internal_Rela *) bfd_zmalloc (sizeof (Elf_Internal_Rela)
							  * bed->s->int_rels_per_ext_rel);
d6508 2
a6509 1
	      /* We need to generate a relative reloc for the dynamic linker.  */
d6511 5
a6515 2
		lsect->rel_section = srel = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
								     lsect->rel_name);
d6528 2
a6529 1
				    + elf_section_data (lsect->section)->rel_count));
d6543 3
a6545 2
  fprintf (stderr, "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long)relocation, (long)relocation);
a6831 1
      
d6880 1
a6880 1
    return *(boolean *)okp = false;
d6955 1
a6955 1
  if (!elf_gc_sweep(info, get_elf_backend_data (abfd)->gc_sweep_hook))
d6998 1
a6998 1
			 (unsigned long)offset);
d7062 3
a7064 2
	      oldbytes = (h->vtable_entries_size/file_align + 1) * sizeof (boolean);
	      memset (((char *)ptr) + oldbytes, 0, bytes - oldbytes);
@


1.98
log
@        * elf-bfd.h (struct elf_backend_data):
        elf_backend_emit_relocs: New field: Function for emitting
        relocs.
        elf_backend_count_relocs: New field: Function for determining
        the number of relocs to be emitted.
        * elfxx-target.h: Provide default (NULL) values for
        elf_backend_emit_relocs and elf_backend_count_relocs.
        * elflink.h (elf_link_size_reloc_section): Make the hash table
        big enough to hold the relocs counted by either reloc_count or
        o->reloc_count.
        (elf_bfd_final_link) emit_relocs: New boolean, set if relocs
        should be emitted, either because of a command line option
        stored in the info structure or because the target provides a
        special reloc emitting function.
        If the target provides a reloc counting function use it,
        unless performing a relocatable link or emitting all relocs.
        Also set the SEC_RELOC flag on any output section which will
        contain relocs.
        (elf_link_input_bfd): emit_relocs: New boolean, set if relocs
        should be emitted, either because of a command line option
        stored in the info structure or because the target provides a
        special reloc emitting function.
        If the target provides a reloc emitting function, use it,
        unless performing a relocatable link or emitting all relocs.
@
text
@d5230 1
a5230 2
      && ! (finfo->info->shared
	    && !finfo->info->no_undefined)
@


1.97
log
@	* elflink.h (struct elf_assign_sym_version_info): Remove member
	export_dynamic.  All users changed to use info member.
	NAME(bfd_elf,size_dynamic_sections)): Remove parameter
	export_dynamic, instead use member in parameter info.
	* bfd-in.h (bfd_elf32_size_dynamic_sections,
	bfd_elf64_size_dynamic_sections): Update prototype.
	* bfd-in2.h: Regenerate.
@
text
@d4138 1
d4146 4
d4163 2
a4164 1
  if (elf_section_data (o)->rel_hashes == NULL)
d4169 1
a4169 1
	   bfd_zmalloc (o->reloc_count
d4171 1
a4171 1
      if (p == NULL && o->reloc_count != 0)
d4277 1
d4302 4
d4371 14
d4455 1
a4455 1
  if (info->relocateable || info->emitrelocations)
d4495 1
d4562 2
a4563 1
  if (info->strip != strip_all || info->relocateable || info->emitrelocations)
d4596 2
a4597 1
  if (info->strip != strip_all || info->relocateable || info->emitrelocations)
d5049 1
a5049 1
	free (elf_section_data (o)->rel_hashes);
d5603 1
d5615 4
d5896 1
a5896 1
	  if (finfo->info->relocateable || finfo->info->emitrelocations)
d5903 3
d6047 6
d6054 2
a6055 5
	      elf_link_output_relocs (output_bfd, o,
				      input_rel_hdr,
				      internal_relocs);
	      internal_relocs += NUM_SHDR_ENTRIES (input_rel_hdr)
				 * bed->s->int_rels_per_ext_rel;
d6057 7
a6063 4
	      if (input_rel_hdr)
		elf_link_output_relocs (output_bfd, o,
					input_rel_hdr,
					internal_relocs);
@


1.96
log
@2001-06-18  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_info_failed): Add a new field, verdefs.
	(NAME(bfd_elf,size_dynamic_sections): Pass verdefs to
	elf_export_symbol.
	(elf_export_symbol): Check eif->verdefs to decide if a symbol
	should be exported.
@
text
@a2682 2
  /* Whether we are exporting all dynamic symbols.  */
  boolean export_dynamic;
d2864 1
a2864 1
				     export_dynamic, filter_shlib,
a2869 1
     boolean export_dynamic;
d2973 1
a2973 1
      if (export_dynamic)
a2984 1
      asvinfo.export_dynamic = export_dynamic;
d3913 1
a3913 1
			      && ! sinfo->export_dynamic)
d4025 1
a4025 1
			  && ! sinfo->export_dynamic)
d4047 1
a4047 1
	      && ! sinfo->export_dynamic)
@


1.95
log
@        * elflink.h (elf_gc_propagate_vtable_entries): Replace FILE_ALIGN
        with the file_align entry from elf_backend_data.
        (elf_gc_smash_unused_vtentry_relocs): Likewise.
        (elf_gc_record_vtentry): Likewise.
@
text
@d30 1
d2971 1
d3710 4
a3713 1
      if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
d3715 17
a3731 2
	  eif->failed = true;
	  return false;
d3733 10
@


1.94
log
@	* elflink.h: Whitespace changes.
	(elf_link_read_relocs_from_section): Use "unsigned int" iterator
	rather than "unsigned char".
	(elf_link_output_relocs): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_reloc_link_order): LIkewise.
	* elf.c: s/CONST/const/.  Whitespace changes.
	* elf32-mips.c: Formatting fix.

	* Makefile.am (SOURCE_HFILES): Include xcoff-target.h, remove xcoff.h.
	* Makefile.in: Regenerate.
	* po/Make-in: Remove trailing tab.
@
text
@d6742 1
d6749 5
a6753 1
	  n = h->vtable_parent->vtable_entries_size / FILE_ALIGN;
d6774 1
d6793 2
d6804 1
a6804 1
	    bfd_vma entry = (rel->r_offset - hstart) / FILE_ALIGN;
d6938 3
d6963 1
a6963 1
      bytes = (size / FILE_ALIGN + 1) * sizeof (boolean);
d6973 1
a6973 1
	      oldbytes = (h->vtable_entries_size/FILE_ALIGN + 1) * sizeof (boolean);
d6988 1
a6988 1
  h->vtable_entries_used[addend / FILE_ALIGN] = true;
@


1.93
log
@Handle MIPS64 relocs which use a non-1 valued int_rels_per_ext_rel
@
text
@d124 1
a124 1
   whoes archive map contains a mention of SYMDEF, and determine if
d2474 1
a2474 1
	  unsigned char i;
d5487 1
a5487 1
	  unsigned char i;
d5843 1
a5843 1
	      unsigned char next_erel;
d6165 1
a6165 1
      unsigned char i;
d6190 1
a6190 1
      unsigned char i;
@


1.92
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@a4110 1
  register struct elf_link_hash_entry **p, **pend;
d4134 2
d4137 2
a4138 2
	   bfd_malloc (o->reloc_count
		       * sizeof (struct elf_link_hash_entry *)));
a4142 3
      pend = p + o->reloc_count;
      for (; p < pend; p++)
	*p = NULL;
d4162 18
d4191 1
a4191 1
	  Elf_Internal_Rel irel;
d4195 1
a4195 1
	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, &irel);
d4197 6
a4202 3
	    elf_swap_reloc_in (abfd, erel, &irel);
	  irel.r_info = ELF_R_INFO ((*rel_hash)->indx,
				    ELF_R_TYPE (irel.r_info));
d4204 1
a4204 1
	    (*bed->s->swap_reloc_out) (abfd, &irel, (bfd_byte *) erel);
d4206 1
a4206 1
	    elf_swap_reloc_out (abfd, &irel, erel);
d4211 1
a4211 1
	  Elf_Internal_Rela irela;
d4218 1
a4218 1
	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, &irela);
d4220 6
a4225 3
	    elf_swap_reloca_in (abfd, erela, &irela);
	  irela.r_info = ELF_R_INFO ((*rel_hash)->indx,
				     ELF_R_TYPE (irela.r_info));
d4227 1
a4227 1
	    (*bed->s->swap_reloca_out) (abfd, &irela, (bfd_byte *) erela);
d4229 1
a4229 1
	    elf_swap_reloca_out (abfd, &irela, erela);
d4232 3
d5468 3
a5470 1
  irelaend = irela + NUM_SHDR_ENTRIES (input_rel_hdr);
d5474 9
d5485 1
a5485 1
      for (; irela < irelaend; irela++, erel++)
d5487 8
a5494 1
	  Elf_Internal_Rel irel;
a5495 3
	  irel.r_offset = irela->r_offset;
	  irel.r_info = irela->r_info;
	  BFD_ASSERT (irela->r_addend == 0);
d5497 1
a5497 1
	    (*bed->s->swap_reloc_out) (output_bfd, &irel, (PTR) erel);
d5499 1
a5499 1
	    elf_swap_reloc_out (output_bfd, &irel, erel);
d5501 2
d5508 2
a5509 2
      BFD_ASSERT (input_rel_hdr->sh_entsize
		  == sizeof (Elf_External_Rela));
d5511 1
a5511 1
      for (; irela < irelaend; irela++, erela++)
d5843 1
d5848 2
a5849 2
	      irelaend =
		irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
d5853 1
a5853 1
	      for (; irela < irelaend; irela++, rel_hash++)
d5859 6
d5881 1
a5881 1
		      long indx;
d5989 2
a5990 1
	      internal_relocs += NUM_SHDR_ENTRIES (input_rel_hdr);
d6163 1
a6163 1
      Elf_Internal_Rel irel;
d6165 10
a6175 2
      irel.r_offset = offset;
      irel.r_info = ELF_R_INFO (indx, howto->type);
d6178 1
d6180 1
a6180 1
	(*bed->s->swap_reloc_out) (output_bfd, &irel, (bfd_byte *) erel);
d6182 3
a6184 1
	elf_swap_reloc_out (output_bfd, &irel, erel);
d6188 1
a6188 1
      Elf_Internal_Rela irela;
d6190 11
a6201 3
      irela.r_offset = offset;
      irela.r_info = ELF_R_INFO (indx, howto->type);
      irela.r_addend = addend;
d6204 1
d6206 1
a6206 1
	(*bed->s->swap_reloca_out) (output_bfd, &irela, (bfd_byte *) erela);
d6208 1
a6208 1
	elf_swap_reloca_out (output_bfd, &irela, erela);
d6345 1
a6345 1
/* Fill in the address for a pointer generated in alinker section.  */
d6412 11
a6422 1
	      Elf_Internal_Rela outrel;
d6431 7
a6437 6
	      outrel.r_offset = (lsect->section->output_section->vma
				 + lsect->section->output_offset
				 + linker_section_ptr->offset);
	      outrel.r_info = ELF_R_INFO (0, relative_reloc);
	      outrel.r_addend = 0;
	      elf_swap_reloca_out (output_bfd, &outrel,
d6442 2
@


1.91
log
@2001-05-18  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Revert the last
	change.
@
text
@d2468 1
a2468 1
      erelend = erel + shdr->sh_size / shdr->sh_entsize;
d2498 1
a2498 1
      erelaend = erela + shdr->sh_size / shdr->sh_entsize;
d2578 1
a2578 1
       internal_relocs + (rel_hdr->sh_size / rel_hdr->sh_entsize
d4416 1
a4416 2
	      *rel_count += (esdi->rel_hdr.sh_size
			     / esdi->rel_hdr.sh_entsize);
d4418 1
a4418 2
		*rel_count2 += (esdi->rel_hdr2->sh_size
				/ esdi->rel_hdr2->sh_entsize);
d5443 1
a5443 1
  irelaend = irela + input_rel_hdr->sh_size / input_rel_hdr->sh_entsize;
d5478 1
a5478 1
  *rel_countp += input_rel_hdr->sh_size / input_rel_hdr->sh_entsize;
d5940 1
a5940 2
	      internal_relocs
		+= input_rel_hdr->sh_size / input_rel_hdr->sh_entsize;
@


1.90
log
@2001-05-17  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the
	version definition to basename of the output filename.
@
text
@d1098 1
a1098 1
      name = basename (bfd_get_filename (abfd));
@


1.89
log
@2001-05-17  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Set DT_NEEDED to
	basename of the bfd filename.
@
text
@d3133 1
a3133 1
	      name = output_bfd->filename;
@


1.88
log
@2001-05-09  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Fix a typo. Allocate
	versymhdr->sh_size bytes for extversym instead of hdr->sh_size.
	Remove the unused veriable `dynver'.
@
text
@d1098 1
a1098 1
      name = bfd_get_filename (abfd);
@


1.87
log
@2001-05-03  H.J. Lu  <hjl@@gnu.org>

	* elfcode.h: Include "libiberty.h".

	* elflink.h (elf_link_add_object_symbols): Set
	elf_dt_name (abfd) to basename of the bfd filename.
	(NAME(bfd_elf,size_dynamic_sections)): Set vn_file to basename
	of the bfd filename.
@
text
@a897 1
  bfd_byte *dynver = NULL;
d1025 1
a1025 1
	  extversym = (Elf_External_Versym *) bfd_malloc (hdr->sh_size);
a2187 2
  if (dynver != NULL)
    free (dynver);
@


1.86
log
@2000-04-27  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_link_hash_hide_symbol): Set dynindx to -1
	only for ELF_LINK_FORCED_LOCAL.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.

	* elflink.h (elf_fix_symbol_flags): Set ELF_LINK_FORCED_LOCAL
	if the symbol has hidden or internal visibility.
@
text
@d1325 1
a1325 1
	name = bfd_get_filename (abfd);
d3320 2
a3321 1
					     t->vn_bfd->filename, true, false);
@


1.85
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d3544 3
@


1.84
log
@	* elflink.h (elf_fix_symbol_flags): For non-default visibilities,
	only hide symbols marked STV_INTERNAL or STV_HIDDEN.
@
text
@d2170 12
d4084 2
d4235 1
d4281 1
d4303 3
d4363 4
d5086 27
d5578 9
a5586 1
	isec = section_from_elf_index (input_bfd, isym->st_shndx);
d5688 3
a5690 1
	  || (finfo->info->discard == discard_l
d5952 14
a5965 1
      if (elf_section_data (o)->stab_info == NULL)
a5972 7
	    return false;
	}
      else
	{
	  if (! (_bfd_write_section_stabs
		 (output_bfd, &elf_hash_table (finfo->info)->stab_info,
		  o, &elf_section_data (o)->stab_info, contents)))
@


1.83
log
@	* elflink.h (elf_fix_symbol_flags): Call elf_backend_hide_symbol
	when -Bsymbolic causes a symbol to no longer need a .plt entry.
@
text
@d3518 5
a3522 3
     need a PLT entry.  Likewise, if the symbol has any kind of
     visibility (internal, hidden, or protected), it doesn't need a
     PLT.  */
d3525 3
a3527 1
      && (eif->info->symbolic || ELF_ST_VISIBILITY (h->other))
@


1.82
log
@Update copyright notices
@
text
@d2960 3
a2966 4
	  struct elf_info_failed eif;

	  eif.failed = false;
	  eif.info = info;
a2987 2
      eif.failed = false;
      eif.info = info;
d3526 3
a3528 2
      h->elf_link_hash_flags &=~ ELF_LINK_HASH_NEEDS_PLT;
      h->plt.offset = (bfd_vma) -1;
@


1.81
log
@2001-02-18  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_input_bfd): Ignore invalid section symbol
	index.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.80
log
@2001-02-11  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_bfd_final_link): Use file_align for STMTAB
	alignment.
@
text
@d5518 1
d5520 4
a5523 1
	isec = bfd_und_section_ptr;
d5527 4
a5530 1
	isec = bfd_abs_section_ptr;
d5532 4
a5535 1
	isec = bfd_com_section_ptr;
d5554 12
a5565 1
	    isec->symbol->value = isym->st_value;
@


1.79
log
@ignore common definitions of function symbols in unlinked archives
@
text
@d4438 1
a4438 1
  symtab_hdr->sh_addralign = 4;  /* FIXME: system dependent?  */
@


1.78
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d83 1
a83 1
/* Return true iff this is a non-common definition of a symbol.  */
d85 1
a85 1
is_global_symbol_definition (abfd, sym)
d94 4
d123 1
a123 1
   whoes archove map contains a mention of SYMDEF, and determine if
d208 1
a208 1
	  result = is_global_symbol_definition (abfd, & sym);
@


1.78.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.78.2.2
log
@Merge from mainline.
@
text
@d84 1
a84 1
/* Return true iff this is a non-common, definition of a non-function symbol.  */
d86 1
a86 1
is_global_data_symbol_definition (abfd, sym)
a94 4
  /* Function symbols do not count.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
    return false;

d120 1
a120 1
   whose archive map contains a mention of SYMDEF, and determine if
d205 1
a205 1
	  result = is_global_data_symbol_definition (abfd, & sym);
d894 1
d1022 1
a1022 1
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
d2173 2
d2455 1
a2455 1
      erelend = erel + NUM_SHDR_ENTRIES (shdr);
d2461 1
a2461 1
	  unsigned int i;
d2485 1
a2485 1
      erelaend = erela + NUM_SHDR_ENTRIES (shdr);
d2565 1
a2565 1
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
a2955 3
      eif.info = info;
      eif.failed = false;

d2960 4
d2985 2
d3517 3
a3519 5
     need a PLT entry, and we can accomplish that by forcing it local.
     Likewise, if the symbol has hidden or internal visibility.
     FIXME: It might be that we also do not need a PLT for other
     non-hidden visibilities, but we would have to tell that to the
     backend specifically; we can't just clear PLT-related data here.  */
d3522 1
a3522 3
      && (eif->info->symbolic
	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
d3525 2
a3526 6
      struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      (*bed->elf_backend_hide_symbol) (eif->info, h);
d4090 1
a4113 2
      struct elf_link_hash_entry **p;

d4115 2
a4116 2
	   bfd_zmalloc (o->reloc_count
			* sizeof (struct elf_link_hash_entry *)));
d4121 3
a4142 18
  Elf_Internal_Rel *irel;
  Elf_Internal_Rela *irela;

  irel = (Elf_Internal_Rel *) bfd_zmalloc (sizeof (Elf_Internal_Rel)
					   * bed->s->int_rels_per_ext_rel);
  if (irel == NULL)
    {
      (*_bfd_error_handler) (_("Error: out of memory"));
      abort ();
    }

  irela = (Elf_Internal_Rela *) bfd_zmalloc (sizeof (Elf_Internal_Rela)
					     * bed->s->int_rels_per_ext_rel);
  if (irela == NULL)
    {
      (*_bfd_error_handler) (_("Error: out of memory"));
      abort ();
    }
d4154 1
a4154 1
	  unsigned int j;
d4158 1
a4158 1
	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, irel);
d4160 3
a4162 6
	    elf_swap_reloc_in (abfd, erel, irel);

	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	    irel[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
					 ELF_R_TYPE (irel[j].r_info));

d4164 1
a4164 1
	    (*bed->s->swap_reloc_out) (abfd, irel, (bfd_byte *) erel);
d4166 1
a4166 1
	    elf_swap_reloc_out (abfd, irel, erel);
d4171 1
a4171 1
	  unsigned int j;
d4178 1
a4178 1
	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, irela);
d4180 3
a4182 6
	    elf_swap_reloca_in (abfd, erela, irela);

	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	    irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
				       ELF_R_TYPE (irela[j].r_info));

d4184 1
a4184 1
	    (*bed->s->swap_reloca_out) (abfd, irela, (bfd_byte *) erela);
d4186 1
a4186 1
	    elf_swap_reloca_out (abfd, irela, erela);
a4188 3

  free (irel);
  free (irela);
d4386 2
a4387 1
	      *rel_count += NUM_SHDR_ENTRIES (& esdi->rel_hdr);
d4389 2
a4390 1
		*rel_count2 += NUM_SHDR_ENTRIES (esdi->rel_hdr2);
d4435 1
a4435 1
  symtab_hdr->sh_addralign = bed->s->file_align;
d5388 1
a5388 3
  irelaend = irela + NUM_SHDR_ENTRIES (input_rel_hdr)
		     * bed->s->int_rels_per_ext_rel;

a5391 9
      Elf_Internal_Rel *irel;
      
      irel = (Elf_Internal_Rel *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
					       * sizeof (Elf_Internal_Rel));
      if (irel == NULL)
	{
	  (*_bfd_error_handler) (_("Error: out of memory"));
	  abort ();
	}
d5394 1
a5394 1
      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erel++)
d5396 1
a5396 8
	  unsigned int i;
	  
	  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	    {
	      irel[i].r_offset = irela[i].r_offset;
	      irel[i].r_info = irela[i].r_info;
	      BFD_ASSERT (irela[i].r_addend == 0);
	    }
d5398 3
d5402 1
a5402 1
	    (*bed->s->swap_reloc_out) (output_bfd, irel, (PTR) erel);
d5404 1
a5404 1
	    elf_swap_reloc_out (output_bfd, irel, erel);
a5405 2

      free (irel);
d5411 2
a5412 2
      BFD_ASSERT (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela));

d5414 1
a5414 1
      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erela++)
d5423 1
a5423 1
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);
a5514 1
      name = NULL;
d5516 1
a5516 4
        {
	  isec = bfd_und_section_ptr;
	  name = isec->name;
	}
d5520 1
a5520 4
	{
	  isec = bfd_abs_section_ptr;
	  name = isec->name;
	}
d5522 1
a5522 4
	{
	  isec = bfd_com_section_ptr;
	  name = isec->name;
	}
d5541 1
a5541 12
	    {
	      if (name)
		{
		  if (isec->symbol->value != isym->st_value)
		    (*_bfd_error_handler)
		      (_("%s: invalid section symbol index 0x%x (%s) ingored"),
		       bfd_get_filename (input_bfd), isym->st_shndx,
		       name);
		  continue;
		}
	      isec->symbol->value = isym->st_value;
	    }
a5714 1
	      unsigned int next_erel;
d5719 2
a5720 2
	      irelaend = irela
		         + o->reloc_count * bed->s->int_rels_per_ext_rel;
d5724 1
a5724 1
	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
a5729 6
		  if (next_erel == bed->s->int_rels_per_ext_rel)
		    {
		      rel_hash++;
		      next_erel = 0;
		    }

d5746 1
a5746 1
		      unsigned long indx;
d5854 2
a5855 2
	      internal_relocs += NUM_SHDR_ENTRIES (input_rel_hdr)
				 * bed->s->int_rels_per_ext_rel;
d6022 1
a6022 1
      Elf_Internal_Rel *irel;
a6023 10
      unsigned int i;
      
      irel = (Elf_Internal_Rel *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
					       * sizeof (Elf_Internal_Rel));
      if (irel == NULL)
	return false;
      
      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	irel[i].r_offset = offset;
      irel[0].r_info = ELF_R_INFO (indx, howto->type);
d6025 2
a6028 1

d6030 1
a6030 1
	(*bed->s->swap_reloc_out) (output_bfd, irel, (bfd_byte *) erel);
d6032 1
a6032 3
	elf_swap_reloc_out (output_bfd, irel, erel);

      free (irel);
d6036 1
a6036 1
      Elf_Internal_Rela *irela;
a6037 11
      unsigned int i;
      
      irela = (Elf_Internal_Rela *) bfd_zmalloc (bed->s->int_rels_per_ext_rel
						 * sizeof (Elf_Internal_Rela));
      if (irela == NULL)
	return false;

      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
	irela[i].r_offset = offset;
      irela[0].r_info = ELF_R_INFO (indx, howto->type);
      irela[0].r_addend = addend;
d6039 3
a6043 1

d6045 1
a6045 1
	(*bed->s->swap_reloca_out) (output_bfd, irela, (bfd_byte *) erela);
d6047 1
a6047 1
	elf_swap_reloca_out (output_bfd, irela, erela);
d6184 1
a6184 1
/* Fill in the address for a pointer generated in a linker section.  */
d6251 1
a6251 11
	      Elf_Internal_Rela *outrel;
	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
	      unsigned int i;

	      outrel = (Elf_Internal_Rela *) bfd_zmalloc (sizeof (Elf_Internal_Rela)
							  * bed->s->int_rels_per_ext_rel);
	      if (outrel == NULL)
		{
		  (*_bfd_error_handler) (_("Error: out of memory"));
		  return 0;
		}
d6260 6
a6265 7
	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		outrel[i].r_offset = (lsect->section->output_section->vma
				      + lsect->section->output_offset
				      + linker_section_ptr->offset);
	      outrel[0].r_info = ELF_R_INFO (0, relative_reloc);
	      outrel[0].r_addend = 0;
	      elf_swap_reloca_out (output_bfd, outrel,
a6269 2
	      
	      free (outrel);
@


1.77
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* ecoffswap.h: Fix formatting.
	* elf-bfd.h: Likewise.
	* elfarm-nabi.c: Likewise.
	* elfarm-oabi.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-target.h: Likewise.
@
text
@a213 1

a2410 1

a2587 1

a6052 1

a6174 1

@


1.76
log
@Add link option to allow undefiedn symbols in shared libraries
@
text
@d53 1
a53 1
static boolean elf_link_read_relocs_from_section 
d59 2
a60 2
static void elf_link_adjust_relocs 
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned int, 
d97 1
a97 1
  
d107 1
a107 1
       
d109 1
a109 1
       
d114 1
a114 1
      
a117 1

d134 1
a134 1
  
d148 1
a148 1
  
d210 1
a210 1
  
d630 1
a630 1
     required at the run time. */
d686 1
a686 1
     may not be required at the run time. */
d694 1
a694 1
      && (h->root.type != bfd_link_hash_defweak 
d832 1
a832 1
     the DT_NEEDED entry may not be required at the run time. */
d1220 1
a1220 1
	      /* Ignore DT_RPATH if we have seen DT_RUNPATH. */
d1662 1
a1662 1
	      
d1665 1
a1665 1
	      
d1944 1
a1944 1
	      case STV_HIDDEN:  
d1959 1
a1959 1
		 have to make sure there is a DT_NEEDED entry for it. */
d2536 1
a2536 1
      size = (o->reloc_count * bed->s->int_rels_per_ext_rel 
d2562 2
a2563 2
  if (!elf_link_read_relocs_from_section 
      (abfd, 
d3002 1
a3002 1
	   ? elf_link_hash_lookup (elf_hash_table (info), 
d3014 1
a3014 1
	   ? elf_link_hash_lookup (elf_hash_table (info), 
d3351 1
a3351 1
      /* Assign dynsym indicies.  In a shared library we generate a 
d3422 1
a3422 1
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount, 
d3897 1
a3897 1
             to worry about it. */
d4111 1
a4111 1
  
d4157 1
a4157 1
	  
d4174 1
a4174 1
	  
d4177 1
a4177 1
	  
d4368 1
a4368 1
	      struct bfd_elf_section_data *esdi 
d4370 1
a4370 1
	      struct bfd_elf_section_data *esdo 
d4387 2
a4388 2
	      
	      *rel_count += (esdi->rel_hdr.sh_size 
d4391 1
a4391 1
		*rel_count2 += (esdi->rel_hdr2->sh_size 
d4415 1
a4415 1
	 to count upwards while actually outputting the relocations. */
d4594 1
a4594 1
     converted to local in a version script. */
d4707 1
a4707 1
    }      
d4746 1
a4746 1
      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr, 
d4752 1
a4752 1
				(elf_section_data (o)->rel_hashes 
d5270 1
a5270 1
     field. */
d5295 1
a5295 1
      hash_entry_size 
d5355 1
a5355 1
elf_link_output_relocs (output_bfd, input_section, input_rel_hdr, 
d5372 1
a5372 1
  if (elf_section_data (output_section)->rel_hdr.sh_entsize 
d5721 1
a5721 1
	      irelaend = 
d5774 1
a5774 1
		  /* This is a reloc against a local symbol. */
d5853 1
a5853 1
	      elf_link_output_relocs (output_bfd, o, 
d5856 1
a5856 1
	      internal_relocs 
d5860 1
a5860 1
		elf_link_output_relocs (output_bfd, o, 
d6406 1
a6406 1
	        rsec = (*gc_mark_hook)(sec->owner, info, rel, NULL, &s);
d6410 1
a6410 1
	          rsec = (*gc_mark_hook)(sec->owner, info, rel, h, NULL);
d6416 1
a6416 1
	      rsec = (*gc_mark_hook)(sec->owner, info, rel, h, NULL);
d6421 1
a6421 1
	      rsec = (*gc_mark_hook)(sec->owner, info, rel, NULL, &s);
d6492 1
a6492 1
	      r = (*gc_sweep_hook)(o->owner, info, o, internal_relocs);
d6545 1
a6545 1
  /* Those that are not vtables. */
d6787 1
a6787 1
	  
d6801 1
a6801 1
      
d6806 1
a6806 1
  
@


1.75
log
@2000-11-08  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): Also add indirect
	symbols for common symbols with the default version.
@
text
@d5098 1
@


1.74
log
@Another try at correcting relocations against discarded
link-once section symbols.
@
text
@d1718 1
a1718 1
	  if (definition)
@


1.73
log
@Cure a number of segfaults caused by /DISCARD/ of dynamic sections.
@
text
@a1373 2
	  else
	    flags = 0;
d5537 32
a5571 5
	continue;

      /* We never output section symbols.  Instead, we use the section
	 symbol of the corresponding section in the output file.  */
      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
@


1.72
log
@* elflink.h (elf_link_add_object_symbols): Don't bfd_release runpath.
@
text
@d2900 1
a2900 1
      bfd_size_type strsize;
d3029 18
a3046 8
      strsize = _bfd_stringtab_size (elf_hash_table (info)->dynstr);
      if (! elf_add_dynamic_entry (info, DT_HASH, 0)
	  || ! elf_add_dynamic_entry (info, DT_STRTAB, 0)
	  || ! elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	  || ! elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	  || ! elf_add_dynamic_entry (info, DT_SYMENT,
				      sizeof (Elf_External_Sym)))
	return false;
a3059 1
      Elf_Internal_Sym isym;
d3396 14
a3409 9
      /* The first entry in .dynsym is a dummy symbol.  */
      isym.st_value = 0;
      isym.st_size = 0;
      isym.st_name = 0;
      isym.st_info = 0;
      isym.st_other = 0;
      isym.st_shndx = 0;
      elf_swap_symbol_out (output_bfd, &isym,
			   (PTR) (Elf_External_Sym *) s->contents);
d4619 2
a4620 1
  if (dynamic)
d4885 2
a4886 1
	      || o->_raw_size == 0)
@


1.71
log
@Allow common symbols to have an alignment of 1 if explicitly requested, and
not overridden by other definitions.
@
text
@d1194 3
a1196 1
		     to free runpath. */
d1198 1
a1198 11
		    {
		      struct bfd_link_needed_list *nn;
		      for (n = elf_hash_table (info)->runpath;
			   n != NULL; n = nn)
			{
			  nn = n->next;
			  bfd_release (abfd, n);
			}
		      bfd_release (abfd, elf_hash_table (info)->runpath);
		      elf_hash_table (info)->runpath = NULL;
		    }
@


1.70
log
@2000-08-22  H.J. Lu  <hjl@@gnu.org>

	* elf-bfd.h (elf_link_hash_table): Add runpath.

	* bfd-in.h (bfd_elf_get_runpath_list): New prototype.
	* bfd-in2.h: Rebuilt.

	* elf.c (_bfd_elf_link_hash_table_init): Initialize the
	"runpath" field to NULL.
	(bfd_elf_get_runpath_list): New function.

	* elflink.h (elf_link_add_object_symbols): Record DT_RPATH and
	DT_RUNPATH entries.
@
text
@d1618 4
a1621 1
	  if (align > old_alignment)
@


1.69
log
@2000-07-27  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_merge_symbol): Take one more argument,
	dt_needed, to indicate if the symbol comes from a DT_NEEDED
	entry. Don't overide the existing weak definition if dt_needed
	is true.
	(elf_link_add_object_symbols): Pass dt_needed to
	elf_merge_symbol ().
@
text
@d1115 2
d1150 2
d1187 67
@


1.68
log
@Zero the allocated contents of reloc sections.
@
text
@d38 1
a38 1
	   boolean *, boolean *, boolean *));
d436 2
a437 1
   change.  */
d441 1
a441 1
		  override, type_change_ok, size_change_ok)
d452 1
d629 3
a631 1
     new symbol is weak.  */
d633 1
a633 1
  if (h->root.type == bfd_link_hash_defweak
d685 3
a687 1
     definition in the executable.  */
d695 2
a696 1
      && (h->root.type != bfd_link_hash_defweak
d831 3
a833 1
     case, we prefer the definition in the shared object.  */
d835 1
d1478 1
a1478 1
				  &size_change_ok))
d1681 2
a1682 1
					  &type_change_ok, &size_change_ok))
d1799 2
a1800 1
					  &type_change_ok, &size_change_ok))
@


1.67
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Don't check
	info->new_dtags when setting DT_FLAGS_1. It will only be set
	by the new linker options. It shouldn't break anything.
@
text
@d4016 4
a4019 2
     allocate it with bfd_alloc rather than malloc.  */
  rel_hdr->contents = (PTR) bfd_alloc (abfd, rel_hdr->sh_size);
@


1.66
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set DT_FLAGS_1
	only if info->new_dtags is true.
@
text
@d3147 1
a3147 1
      if (info->new_dtags && info->flags_1)
@


1.65
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set
	DT_RUNPATH and DT_FLAGS only if info->new_dtags is true.
@
text
@d3147 1
a3147 1
      if (info->flags_1)
@


1.64
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d2851 2
a2852 1
	      || ! elf_add_dynamic_entry (info, DT_RUNPATH, indx))
d3141 1
a3141 1
      if (info->flags)
@


1.63
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* bfd-in.h (bfd_elf_set_dt_needed_soname): New.
	* bfd-in2.h: Rebuild.

	* elf-bfd.h (elf_obj_tdata): Add dt_soname.
	(elf_dt_soname): New.

	* elf.c (bfd_elf_set_dt_needed_soname): New.

	* elflink.h (elf_link_add_object_symbols): Add the DT_NEEDED
	entry if the shared object loaded by DT_NEEDED is used to
	resolve the reference in a regular object.
@
text
@d2840 1
d2850 2
a2851 1
	      || ! elf_add_dynamic_entry (info, DT_RPATH, indx))
d3138 16
@


1.62
log
@2000-06-18  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf_bfd.h (struct elf_backend_data): Add info argument to
	elf_backend_hide_symbol.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Likewise.
	* elf64-ia64.c (elf64_ia64_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
@
text
@d893 1
d1053 2
d1091 6
a1096 1
	    add_needed = false;
d1874 47
@


1.61
log
@2000-06-15  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elflink.h (elf_link_adjust_relocs): Check for and call backend
	specifific swap_reloc_{in,out} and swap_reloca_{in,out} if
	available.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
@
text
@d1863 1
a1863 1
		(*bed->elf_backend_hide_symbol) (h);
d3710 1
a3710 1
			      (*bed->elf_backend_hide_symbol) (h);
d3822 1
a3822 1
			  (*bed->elf_backend_hide_symbol) (h);
d3844 1
a3844 1
	      (*bed->elf_backend_hide_symbol) (h);
@


1.60
log
@Remove the `/* Fall through.  */' comment in elf_link_output_extsym ()
for the indirect symbol.
@
text
@d3979 1
d3994 4
a3997 1
	  elf_swap_reloc_in (abfd, erel, &irel);
d4000 4
a4003 1
	  elf_swap_reloc_out (abfd, &irel, erel);
d4014 4
a4017 1
	  elf_swap_reloca_in (abfd, erela, &irela);
d4020 4
a4023 1
	  elf_swap_reloca_out (abfd, &irela, erela);
d5199 1
d5219 2
a5220 1
  
d5235 4
a5238 1
	  elf_swap_reloc_out (output_bfd, &irel, erel);
d5249 4
a5252 1
	elf_swap_reloca_out (output_bfd, irela, erela);
d5712 1
d5836 4
a5839 1
      elf_swap_reloc_out (output_bfd, &irel, erel);
d5851 4
a5854 1
      elf_swap_reloca_out (output_bfd, &irela, erela);
@


1.59
log
@2000-06-05  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_fix_symbol_flags): Follow the link for the
	indirect symbol for the ELF_LINK_NON_ELF bit.
	(elf_link_output_extsym): Don't output the indirect symbol even
	if the ELF_LINK_NON_ELF bit is set.
@
text
@a5038 1
      /* Fall through.  */
@


1.58
log
@2000-05-30  H.J. Lu  <hjl@@gnu.org>

	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Clear the
	visibility bits if the symbol is undefined. Correctly handle
	weak undefined symbols with hidden and internal attributes.

	* elflink.h (elf_link_add_object_symbols): Always turn the
	symbol into local if it has the hidden or internal attribute.
@
text
@d3292 3
d5036 2
a5037 4
         since the indirected symbol is already in the hash table.  If
         the indirect symbol is non-ELF, fall through and output it.  */
      if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) == 0)
	return true;
@


1.57
log
@2000-05-22  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_output_extsym): Clear the visibility
	field for symbols not defined locally.
@
text
@a892 1
  boolean visibility_changed = false;
d1583 1
a1583 4
		{
		  visibility_changed = true;
		  h->other = sym.st_other;
		}
d1854 1
a1854 1
	  else if (dynsym && h->dynindx != -1 && visibility_changed)
@


1.56
log
@Force relocs emited for an executable to contain virtual addresses.
@
text
@d5092 5
@


1.55
log
@Add part of patch omittede from previous delta
@
text
@d4326 1
a4326 1
	  if (info->relocateable || info->emitrelocations || o == NULL)
d5516 4
@


1.54
log
@Apply patch from  Richard Gorton <gorton@@scrugs.lkg.dec.com> to implement
--emit-relocs switch to the linker to preserve relocs in an output executable
@
text
@d6423 1
a6423 1
      || info->relocateable
@


1.53
log
@2000-05-03  Martin v. Lwis  <loewis@@informatik.hu-berlin.de>

	* elflink.h (elf_link_add_object_symbols): Reset dynindx for
	hidden and internal symbols.
	(elf_fix_symbol_flags): Clear NEEDS_PLT for symbols with
	visibility.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Do not
	assign a PLT or GOT entry to symbols with hidden and
	internal visibility.
@
text
@a359 1

d4106 1
a4106 1
	      if (info->relocateable)
d4174 1
a4174 1
  if (info->relocateable)
d4282 1
a4282 1
  if (info->strip != strip_all || info->relocateable)
d4315 1
a4315 1
  if (info->strip != strip_all || info->relocateable)
d4326 1
a4326 1
	  if (info->relocateable || o == NULL)
d5494 1
a5494 1
	  if (finfo->info->relocateable)
@


1.52
log
@Reference count .plt and .got on x86 for garbage collection code.  Fix a
couple of m68k and ppc bugs discovered while testing x86 gc.
@
text
@d894 1
d1585 4
a1588 1
		h->other = sym.st_other;
d1859 12
d3358 3
a3360 1
     need a PLT entry.  */
d3363 1
a3363 1
      && eif->info->symbolic
@


1.51
log
@Fix building with --enable-targets=all
@
text
@d6618 2
a6619 1
  /* Then the global .got and .plt entries.  */
@


1.51.2.1
log
@Merge from mainline
@
text
@a1854 12
	  else if (dynsym && h->dynindx != -1)
	    /* If the symbol already has a dynamic index, but
	       visibility says it should not be visible, turn it into
	       a local symbol.  */
	    switch (ELF_ST_VISIBILITY (h->other))
	      {
	      case STV_INTERNAL:
	      case STV_HIDDEN:  
		h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
		(*bed->elf_backend_hide_symbol) (h);
		break;
	      }
d3342 1
a3342 3
     need a PLT entry.  Likewise, if the symbol has any kind of
     visibility (internal, hidden, or protected), it doesn't need a
     PLT.  */
d3345 1
a3345 1
      && (eif->info->symbolic || ELF_ST_VISIBILITY (h->other))
a5073 5

  /* If a symbol is not defined locally, we clear the visibility
     field. */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    sym.st_other ^= ELF_ST_VISIBILITY(sym.st_other);
@


1.50
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d86 1
a86 1
     bfd * abfd;
@


1.49
log
@2000-02-22  H.J. Lu  <hjl@@gnu.org>

	* elflink.h (elf_link_add_object_symbols): If a version symbol is
	not defined, don't add a second ELF_VER_CHR.
@
text
@d4398 3
a4400 1
     with the global symbols.  */
d4909 1
a4909 1
	      (asection *) NULL, 0)))
@


1.48
log
@2000-02-22  H.J. Lu  <hjl@@gnu.org>

        * elflink.h (elf_bfd_final_link): Call output_extsym for global
	symbols converted to local symbols even when stripping all
	symbols.
        (elf_link_output_extsym): Process global symbols converted to
	local symbols even if they are being stripped.
@
text
@d1447 5
a1451 1
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
@


1.47
log
@This lot mainly cleans up `comparison between signed and unsigned' gcc
warnings.  One usused var, and a macro parenthesis fix too.  Also check
input sections are elf when doing gc in elflink.h.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d4396 1
a4396 1
  if (info->strip != strip_all && info->shared)
d4931 4
a4934 2
     nothing else to do.  */
  if (strip && h->dynindx == -1)
@


1.46
log
@        * elf-bfd.h (struct elf_link_hash_table): Remove copy_indirect
        and hide_symbol members.
        (elf_link_hash_copy_indirect): Remove.
        (elf_link_hash_hide_symbol): Remove.
        (struct elf_backend_data): Add elf_backend_copy_indirect_symbol
        and elf_backend_hide_symbol.
        (_bfd_elf_link_hash_copy_indirect): Declare.
        (_bfd_elf_link_hash_hide_symbol): Declare.
        * elf.c (_bfd_elf_link_hash_copy_indirect): Remove table argument.
        (_bfd_elf_link_hash_hide_symbol): Likewise.
        (_bfd_elf_link_hash_table_init): Don't init killed members.
        * elflink.h (elf_link_add_object_symbols): Use the bed function
        pointers not elf_link_hash_{copy_indirect,hide_symbol}.
        (elf_link_assign_sym_version): Likewise.
        * elfxx-target.h (elf_backend_copy_indirect_symbol): Default.
        (elf_backend_hide_symbol): Likewise.
        (elfNN_bed): Update for new members.
@
text
@d6205 3
d6422 4
d6581 1
a6581 1
      bfd_signed_vma *local_got = elf_local_got_refcounts (i);
d6585 4
@


1.45
log
@        * elf-bfd.h (struct elf_link_hash_table): Add copy_indirect and
        hide_symbol members.
        (elf_link_hash_copy_indirect): New.
        (elf_link_hash_hide_symbol): New.
        * elflink.h (elf_link_add_object_symbols): Break out copy from
        indirect new new symbol to elf.c.
        (elf_link_assign_sym_version): Break out privatization of
        non-exported symbol to elf.c.
        * elf.c (_bfd_elf_link_hash_copy_indirect): New.
        (_bfd_elf_link_hash_hide_symbol): New.
        (_bfd_elf_link_hash_table_init): Init copy_indirect and hide_symbol.
@
text
@d893 1
d895 3
a897 2
  add_symbol_hook = get_elf_backend_data (abfd)->elf_add_symbol_hook;
  collect = get_elf_backend_data (abfd)->collect;
d1739 1
a1739 2
		      elf_link_hash_copy_indirect (elf_hash_table (info),
						   ht, hi);
d1812 1
a1812 2
			  elf_link_hash_copy_indirect (elf_hash_table (info),
						       h, hi);
d3603 1
d3622 1
d3690 1
a3690 2
			      elf_link_hash_hide_symbol (elf_hash_table (info),
							 h);
d3802 1
a3802 1
			  elf_link_hash_hide_symbol (elf_hash_table (info), h);
d3824 1
a3824 1
	      elf_link_hash_hide_symbol (elf_hash_table (info), h);
@


1.44
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d1737 2
a1738 39

		      /* Copy down any references that we may have
			 already seen to the symbol which just became
			 indirect.  */
		      ht->elf_link_hash_flags |=
			(hi->elf_link_hash_flags
			 & (ELF_LINK_HASH_REF_DYNAMIC
			    | ELF_LINK_HASH_REF_REGULAR
			    | ELF_LINK_HASH_REF_REGULAR_NONWEAK
			    | ELF_LINK_NON_GOT_REF));

		      /* Copy over the global and procedure linkage table
			 offset entries.  These may have been already set
			 up by a check_relocs routine.  */
		      if (ht->got.offset == (bfd_vma) -1)
			{
			  ht->got.offset = hi->got.offset;
			  hi->got.offset = (bfd_vma) -1;
			}
		      BFD_ASSERT (hi->got.offset == (bfd_vma) -1);

		      if (ht->plt.offset == (bfd_vma) -1)
			{
			  ht->plt.offset = hi->plt.offset;
			  hi->plt.offset = (bfd_vma) -1;
			}
		      BFD_ASSERT (hi->plt.offset == (bfd_vma) -1);

		      if (ht->dynindx == -1)
			{
			  ht->dynindx = hi->dynindx;
			  ht->dynstr_index = hi->dynstr_index;
			  hi->dynindx = -1;
			  hi->dynstr_index = 0;
			}
		      BFD_ASSERT (hi->dynindx == -1);

		      /* FIXME: There may be other information to copy
			 over for particular targets.  */
d1811 2
a1812 38
			  /* Copy down any references that we may have
                             already seen to the symbol which just
                             became indirect.  */
			  h->elf_link_hash_flags |=
			    (hi->elf_link_hash_flags
			     & (ELF_LINK_HASH_REF_DYNAMIC
				| ELF_LINK_HASH_REF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR_NONWEAK
				| ELF_LINK_NON_GOT_REF));

			  /* Copy over the global and procedure linkage
                             table offset entries.  These may have been
                             already set up by a check_relocs routine.  */
			  if (h->got.offset == (bfd_vma) -1)
			    {
			      h->got.offset = hi->got.offset;
			      hi->got.offset = (bfd_vma) -1;
			    }
			  BFD_ASSERT (hi->got.offset == (bfd_vma) -1);

			  if (h->plt.offset == (bfd_vma) -1)
			    {
			      h->plt.offset = hi->plt.offset;
			      hi->plt.offset = (bfd_vma) -1;
			    }
			  BFD_ASSERT (hi->got.offset == (bfd_vma) -1);

			  if (h->dynindx == -1)
			    {
			      h->dynindx = hi->dynindx;
			      h->dynstr_index = hi->dynstr_index;
			      hi->dynindx = -1;
			      hi->dynstr_index = 0;
			    }
			  BFD_ASSERT (hi->dynindx == -1);

			  /* FIXME: There may be other information to
                             copy over for particular targets.  */
d3688 2
a3689 4
			      h->elf_link_hash_flags &=~
				ELF_LINK_HASH_NEEDS_PLT;
			      h->dynindx = -1;
			      h->plt.offset = (bfd_vma) -1;
d3801 1
a3801 3
			  h->elf_link_hash_flags &=~ ELF_LINK_HASH_NEEDS_PLT;
			  h->dynindx = -1;
			  h->plt.offset = (bfd_vma) -1;
d3823 1
a3823 3
	      h->elf_link_hash_flags &=~ ELF_LINK_HASH_NEEDS_PLT;
	      h->dynindx = -1;
	      h->plt.offset = (bfd_vma) -1;
@


1.43
log
@ELF visibility patch from Martin Loewis.
@
text
@d2984 1
a2984 1
	_bfd_strip_section_from_output (s);
d3160 1
a3160 1
	  _bfd_strip_section_from_output (s);
d3264 1
a3264 1
	  _bfd_strip_section_from_output (s);
@


1.42
log
@        * elflink.h (bfd_elf,size_dynamic_sections): Don't export all
        if no dynamic sections created.
@
text
@d1569 18
a1586 3
	  if (sym.st_other != 0
	      && (definition || h->other == 0))
	    h->other = sym.st_other;
@


1.41
log
@Fix detection of common symbols
@
text
@a2805 14
  /* If we are supposed to export all symbols into the dynamic symbol
     table (this is not the normal case), then do so.  */
  if (export_dynamic)
    {
      struct elf_info_failed eif;

      eif.failed = false;
      eif.info = info;
      elf_link_hash_traverse (elf_hash_table (info), elf_export_symbol,
			      (PTR) &eif);
      if (eif.failed)
	return false;
    }

d2866 14
@


1.40
log
@fix detection of common symbols.
@
text
@d83 36
d143 7
d205 1
a205 5
	  result =
	    (ELF_ST_BIND (sym.st_info) == STB_GLOBAL)
	    && (sym.st_shndx != SHN_UNDEF)
	    && (sym.st_shndx != SHN_COMMON)
	    ;
@


1.39
log
@Fix elf linker's handling of commons in archive maps
@
text
@d164 3
a166 1
	    && (sym.st_shndx != SHN_UNDEF);
@


1.38
log
@Revert previous patch.
@
text
@d83 91
d294 18
a311 1
	  if (h->root.type != bfd_link_hash_undefined)
@


1.37
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@d203 1
a203 20
	  /* We have changed the GNU archiver so that it will only place
	     non-common symbols into its archive map.  Thus if we come across
	     a symbol in the archive map, which is currently considered to be
	     a common symbol, we can safely assume that we should link the
	     element in, in order to get in the definition of the symbol.
	     
	     Previous versions of the archiver would place common symbols into
	     the archive map.  This meant that in order to only link in an
	     element if it contained a *definition* of a common symbol, it
	     would be necessary to read in the element and scan its symbol
	     table - a slow and wasteful process.

	     In fact previous versions of this code did not even do that,
	     instead it just unilaterally ignored any symbols in the archive
	     map which were currently marked as common.  So in order to link
	     in an archive element containing the definition of a common
	     symbol it was necessary to have that element also contain the
	     defintion of a currently undefined symbol.  */
	  if (h->root.type != bfd_link_hash_undefined
	      && h->root.type != bfd_link_hash_common)
@


1.36
log
@	* elflink.h (elf_bfd_final_link): Make last_local signed.
@
text
@d203 20
a222 1
	  if (h->root.type != bfd_link_hash_undefined)
@


1.35
log
@	* elflink.h (elf_merge_symbol): When overriding a weak symbol with
	a defined symbol in a shared library, clear the DEF_DYNAMIC flag
	too.
@
text
@d4335 1
a4335 1
      unsigned long last_local = 0;
d4397 2
a4398 2
      elf_section_data (finfo.dynsym_sec->output_section)
	->this_hdr.sh_info = last_local + 1;
@


1.34
log
@	* elflink.h (elf_fix_symbol_flags): Move weakdef handling here...
	(elf_adjust_dynamic_symbol): ...from here.
@
text
@d686 6
a691 2
      h->elf_link_hash_flags &= ~ ELF_LINK_HASH_DEF_REGULAR;
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
@


1.33
log
@	* elflink.h (elf_link_add_object_symbols): Copy NON_GOT_REF flag
	to version symbols.
@
text
@d3253 27
d3362 5
a3366 1
      struct elf_link_hash_entry *weakdef;
d3368 2
a3369 25
      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      weakdef = h->weakdef;
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	{
	  /* This symbol is defined by a regular object file, so we
	     will not do anything special.  Clear weakdef for the
	     convenience of the processor backend.  */
	  h->weakdef = NULL;
	}
      else
	{
	  /* There is an implicit reference by a regular object file
	     via the weak symbol.  */
	  weakdef->elf_link_hash_flags |=
	    (ELF_LINK_HASH_REF_REGULAR
	     | (h->elf_link_hash_flags
		& (ELF_LINK_HASH_REF_REGULAR_NONWEAK
		   | ELF_LINK_NON_GOT_REF)));
	  if (! elf_adjust_dynamic_symbol (weakdef, (PTR) eif))
	    return false;
	}
@


1.32
log
@use bfd memory allcation routines
@
text
@d1577 2
a1578 1
			    | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
d1687 2
a1688 1
				| ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.31
log
@	* elf-bfd.h (ELF_LINK_NON_GOT_REF): Define.
	* elflink.h (elf_adjust_dynamic_symbol): Copy REF_REGULAR_NONWEAK
	and NON_GOT_REF from weak defined symbol to real symbol.
	* elf32-i386.c (elf_i386_check_relocs): Set NON_GOT_REF.
	(elf_i386_adjust_dynamic_symbol): If NON_GOT_REF is not set, don't
	create a COPY reloc.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set NON_GOT_REF.
	(elf32_sparc_adjust_dynamic_symbol): If NON_GOT_REF is not set,
	don't create a COPY reloc.
@
text
@d6422 1
a6422 1
      bytes = (size / FILE_ALIGN + 1) * sizeof(boolean);
d6426 5
a6430 1
	  size_t oldbytes;
d6432 3
a6434 6
	  ptr = realloc (ptr-1, bytes);
	  if (ptr == NULL)
	    return false;

	  oldbytes = (h->vtable_entries_size/FILE_ALIGN + 1) * sizeof(boolean);
	  memset (((char *)ptr) + oldbytes, 0, bytes - oldbytes);
d6437 1
a6437 5
	{
	  ptr = calloc (1, bytes);
	  if (ptr == NULL)
	    return false;
	}
d6439 3
d6443 1
a6443 1
      h->vtable_entries_used = ptr+1;
d6446 1
@


1.30
log
@	* elflink.h (elf_bfd_final_link): When counting relocations, don't
	count those in sections we are not including in the link.
@
text
@d3352 5
a3356 4
	  weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
	  if (h->weakdef->elf_link_hash_flags
	      & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	    weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
@


1.29
log
@
        * elflink.h (elf_link_add_object_symbols): Work around bogus SH_LINK
        field in hpux11 shared libraries.
@
text
@d4056 1
a4056 1
	  asection* output_section = o->output_section;
d4058 10
a4067 1
	  if (output_section && (o->flags & SEC_RELOC) != 0)
@


1.28
log
@Fix memory leak.
@
text
@d957 17
@


1.27
log
@When possible, keep the	original type of the symbol.
@
text
@d6406 1
a6406 1
	  memset (ptr + oldbytes, 0, bytes - oldbytes);
@


1.26
log
@	* elf32-mips.c (_bfd_mips_elf_add_symbol_hook): Set BSF_DYNAMIC
	for special section symbols.
	* elflink.h (elf_merge_symbol): If we have no old BFD, check
	BSF_DYNAMIC on the section symbol to see whether the old BFD is
	dynamic.
@
text
@d2374 4
a2377 1
  h->type = STT_OBJECT;
@


1.25
log
@	* elflink.h (elf_bfd_final_link): Tweak last change.
@
text
@d387 2
a388 2
  if (oldbfd == NULL || (oldbfd->flags & DYNAMIC) == 0)
    olddyn = false;
d390 26
a415 1
    olddyn = true;
@


1.24
log
@	* elflink.h (elf_link_size_reloc_section): Use the counts in the
	elf-section data to allocate just the right amount of relocation
	space.  Don't allocate the hash space twice.
	(elf_bfd_final_link): Calculate the amount of space to allocate in
	each relocation section.
@
text
@d4019 2
d4022 15
a4036 2
	      esdo->rel_count += (esdi->rel_hdr.sh_size 
				  / esdi->rel_hdr.sh_entsize);
d4038 2
a4039 2
		esdo->rel_count2 += (esdi->rel_hdr2->sh_size 
				     / esdi->rel_hdr2->sh_entsize);
@


1.23
log
@1999-08-09  Geoff Keating  <geoffk@@cygnus.com>

	* elflink.h (elf_link_output_extsym): Don't output a weak
	reference to an undefined symbol just because it was defined weak
	in a shared object.
@
text
@d3764 1
d3766 8
a3773 10
  /* We are overestimating the size required for the relocation
     sections, in the case that we are using both REL and RELA
     relocations for a single section.  In that case, RELOC_COUNT will
     be the total number of relocations required, and we allocate
     space for that many REL relocations as well as that many RELA
     relocations.  This approximation is wasteful of disk space.
     However, until we keep track of how many of each kind of
     relocation is required, it's difficult to calculate the right
     value.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * o->reloc_count;
d3780 10
d3791 5
a3795 10
  p = ((struct elf_link_hash_entry **)
       bfd_malloc (o->reloc_count
		   * sizeof (struct elf_link_hash_entry *)));
  if (p == NULL && o->reloc_count != 0)
    return false;

  elf_section_data (o)->rel_hashes = p;
  pend = p + o->reloc_count;
  for (; p < pend; p++)
    *p = NULL;
d4004 24
d4045 5
d4285 3
@


1.22
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elflink.h (elf_bfd_final_link): Copy the whole isym, not just
        some fields.
        * elf64-sparc.c (sparc64_elf_output_arch_syms): Declare used
        variables and initialize them.
@
text
@d4843 2
a4844 1
     mark the symbol as weak undefined.  We can't do this earlier,
a4847 1
      && sym.st_info == ELF_ST_INFO (STB_GLOBAL, h->type)
d4849 11
a4859 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) == 0)
    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
@


1.21
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf-bfd.h (struct elf_backend_data): Add
        print_symbol_all and output_arch_syms backend methods.
        * elfxx-target.h: Likewise.
        * elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create,
        sparc64_elf_add_symbol_hook, sparc64_elf_output_arch_syms,
        sparc64_elf_get_symbol_type, sparc64_elf_symbol_processing): New
        functions.
        (sparc64_elf_size_dynamic_sections): Leave space for STT_REGISTER
        symbols in .dynsym, add their names into .dynstr. Put those symbols
        into dynlocal.
        (sparc64_elf_finish_dynamic_sections): Fix up DT_SPARC_REGISTER
        pointers to STT_REGISTER symbols in dynsym section.
        (sparc64_elf_print_symbol_all): New function.
        * elf.c (bfd_elf_print_symbol): Allow special backend symbol
        printing using the print_symbol_all hook.
@
text
@d4253 2
a4254 4
	      sym.st_size = e->isym.st_size;
	      sym.st_other = e->isym.st_other;

	      /* Note that we saved a word of storage and overwrote
d4256 1
a4256 1
	      sym.st_name = e->isym.st_name;
d4258 1
a4258 6
	      if (e->isym.st_shndx == 0 || e->isym.st_shndx >= SHN_LORESERVE)
		{
		  sym.st_shndx = e->isym.st_shndx;
		  sym.st_value = e->isym.st_value;
		}
	      else
@


1.20
log
@	* elflink.h (elf_merge_symbol): Do merge symbols from the same BFD
	if they appear to be specially created by the linker.
@
text
@d2119 4
d4260 16
a4275 10
	      /* Whatever binding the symbol had before, it's now local.  */
	      sym.st_info = ELF_ST_INFO (STB_LOCAL,
					 ELF_ST_TYPE (e->isym.st_info));

	      s = bfd_section_from_elf_index (e->input_bfd, e->isym.st_shndx);

	      sym.st_shndx = elf_section_data (s->output_section)->this_idx;
	      sym.st_value = (s->output_section->vma
			      + s->output_offset
			      + e->isym.st_value);
d4285 1
a4285 1
	->this_hdr.sh_info = last_local;
d4296 12
@


1.19
log
@	* elflink.h (elf_bfd_final_link): Remove unused variables rel_hash
	and rel_hdr.
@
text
@d371 6
a376 2
     itself.  */
  if (abfd == oldbfd)
@


1.18
log
@	* elflink.h (elf_link_adjust_relocs): New function.
	(elf_bfd_final_link): Use it.
	(elf_link_input_bfd): Deal with the fact that there can be
	two relocation sections for a single section.
	(elf_reloc_link_order): Likewise.

	* elf32-mips.c (_bfd_mips_elf_final_link): Don't set GP for
	a relocateable object.
	(_bfd_mips_elf_relocate_section): Handle relocateable links.
@
text
@a4316 3
      struct elf_link_hash_entry **rel_hash;
      Elf_Internal_Shdr *rel_hdr;

@


1.17
log
@	* elflink.h (elf_link_record_local_dynamic_symbol): Remove unused
	variables `link' and `elfsec'.
	(elf_bfd_final_link): Remove unused variable `os'.
@
text
@d59 3
d3788 49
d4323 8
a4330 36
      rel_hash = elf_section_data (o)->rel_hashes;
      rel_hdr = &elf_section_data (o)->rel_hdr;
      BFD_ASSERT (elf_section_data (o)->rel_count == o->reloc_count);
      for (i = 0; i < o->reloc_count; i++, rel_hash++)
	{
	  if (*rel_hash == NULL)
	    continue;

	  BFD_ASSERT ((*rel_hash)->indx >= 0);

	  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
	    {
	      Elf_External_Rel *erel;
	      Elf_Internal_Rel irel;

	      erel = (Elf_External_Rel *) rel_hdr->contents + i;
	      elf_swap_reloc_in (abfd, erel, &irel);
	      irel.r_info = ELF_R_INFO ((*rel_hash)->indx,
					ELF_R_TYPE (irel.r_info));
	      elf_swap_reloc_out (abfd, &irel, erel);
	    }
	  else
	    {
	      Elf_External_Rela *erela;
	      Elf_Internal_Rela irela;

	      BFD_ASSERT (rel_hdr->sh_entsize
			  == sizeof (Elf_External_Rela));

	      erela = (Elf_External_Rela *) rel_hdr->contents + i;
	      elf_swap_reloca_in (abfd, erela, &irela);
	      irela.r_info = ELF_R_INFO ((*rel_hash)->indx,
					 ELF_R_TYPE (irela.r_info));
	      elf_swap_reloca_out (abfd, &irela, erela);
	    }
	}
d5251 2
a5252 1
			  + elf_section_data (o->output_section)->rel_count);
d5442 2
a5443 1
		  + elf_section_data (output_section)->rel_count);
@


1.16
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@a2064 1
  int elfsec, link;
d4191 1
a4191 1
	      asection *s, *os;
@


1.15
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@a50 2
static boolean elf_link_renumber_dynsyms
  PARAMS ((struct elf_link_hash_entry *, PTR));
a54 2
static void elf_link_remove_section_and_adjust_dynindices 
  PARAMS ((struct bfd_link_info *, asection *));
d2050 67
a2375 2
  /* Whether we removed any symbols from the dynamic symbol table.  */
  boolean removed_dynamic;
a2549 36
/* Remove SECTION from the BFD.  If a symbol for SECTION was going to
   be put into the dynamic symbol table, remove it, and renumber
   subsequent entries.  */

static void
elf_link_remove_section_and_adjust_dynindices (info, section)
     struct bfd_link_info *info;
     asection *section;
{
  /* Remove the section from the output list.  */
  _bfd_strip_section_from_output (section);

  if (elf_section_data (section->output_section)->dynindx)
    {
      asection *s;
      int increment = -1;

      /* We were going to output an entry in the dynamic symbol table
	 for the symbol corresponding to this section.  Now, the
	 section is gone.  So, we must renumber the dynamic indices of
	 all subsequent sections and all other entries in the dynamic
	 symbol table.  */
      elf_section_data (section->output_section)->dynindx = 0;
      for (s = section->output_section->next; s; s = s->next)
	if (elf_section_data (s)->dynindx)
	  --elf_section_data (s)->dynindx;
      
      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_link_adjust_dynindx,
			      &increment);

      /* There is one less dynamic symbol than there was before.  */
      --elf_hash_table (info)->dynsymcount;
    }
}

a2572 1
  bfd_size_type old_dynsymcount;
a2676 1
      asvinfo.removed_dynamic = false;
a2737 1
  old_dynsymcount = elf_hash_table (info)->dynsymcount;
d2759 1
a2759 1
	elf_link_remove_section_and_adjust_dynindices (info, s);
a2768 17
	  if (asvinfo.removed_dynamic)
	    {
	      /* Some dynamic symbols were changed to be local
		 symbols.  In this case, we renumber all of the
		 dynamic symbols, so that we don't have a hole.  If
		 the backend changed dynsymcount, then assume that the
		 new symbols are at the start.  This is the case on
		 the MIPS.  FIXME: The names of the removed symbols
		 will still be in the dynamic string table, wasting
		 space.  */
	      elf_hash_table (info)->dynsymcount =
		1 + (elf_hash_table (info)->dynsymcount - old_dynsymcount);
	      elf_link_hash_traverse (elf_hash_table (info),
				      elf_link_renumber_dynsyms,
				      (PTR) info);
	    }

d2935 1
a2935 1
	  elf_link_remove_section_and_adjust_dynindices (info, s);
d3026 6
a3031 1
      dynsymcount = elf_hash_table (info)->dynsymcount;
d3039 1
a3039 1
	  elf_link_remove_section_and_adjust_dynindices (info, s);
d3042 1
a3042 1
	  dynsymcount = elf_hash_table (info)->dynsymcount;
a3525 1
			      sinfo->removed_dynamic = true;
a3640 1
			  sinfo->removed_dynamic = true;
a3664 1
	      sinfo->removed_dynamic = true;
a3676 20

/* This function is used to renumber the dynamic symbols, if some of
   them are removed because they are marked as local.  This is called
   via elf_link_hash_traverse.  */

static boolean
elf_link_renumber_dynsyms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;

  if (h->dynindx != -1)
    {
      h->dynindx = elf_hash_table (info)->dynsymcount;
      ++elf_hash_table (info)->dynsymcount;
    }

  return true;
}
d4151 1
a4151 2
  /* The sh_info field records the index of the first non local
     symbol.  */
d4153 1
d4155 67
a4221 1
    elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info = 1;
@


1.14
log
@	* elf.c (bfd_elf_hash): Change parameter from unsigned char * to
	char *.
	* elf-bfd.h (bfd_elf_hash): Update declaration.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Remove casts
	when calling bfd_elf_hash.
@
text
@d2240 1
a2240 1
     bfd *output_bfd;
d2359 1
a2359 1
  size_t best_size;
d4852 1
a4852 1
  unsigned int *rel_countp;
d6186 2
a6187 2
     bfd *abfd;
     asection *sec;
@


1.13
log
@	* elflink.h (elf_link_read_relocs_from_section): Be type-correct.
@
text
@d2803 1
a2803 1
	      def.vd_hash = bfd_elf_hash ((const unsigned char *) soname);
d2812 1
a2812 1
	      def.vd_hash = bfd_elf_hash ((const unsigned char *) name);
d2860 1
a2860 1
	      def.vd_hash = bfd_elf_hash ((const unsigned char *) t->name);
d2996 1
a2996 2
		    a->vna_hash = bfd_elf_hash ((const unsigned char *)
						a->vna_nodename);
@


1.12
log
@	* elflink.h (elf_link_create_dynamic_sections): Handle non-standard
	hash-entry sizes.
	(size_dynamic_sections): Likewise.
	(elf_link_output_extsym): Likewise.
	* elf.c: (elf_fake_sections): Likewise.
	* libbfd.c (bfd_get): New macro.
	(bfd_put): Likewise.
	* bfd-in2.h: Regenerated.
	* elf-bfd.h (elf_size_info): Add hash_entry_size,
	int_rels_per_ext_rel, swap_dyn_out, swap_reloc_in, swap_reloc_out,
	wap_reloca_in, and swap_reloca_out.
	* elflink.h (elf_link_read_relocs_from_section): Adjust to handle
	multiple internal relocations per external relocation.
	(link_read_relocs): Likewise.
	(elf_bfd_final_link): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	* elfcode.h (elf_swap_dyn_out): Adjust type to match
	elf_swap_dyn_in.
	(size_info): Add entries for new fields.
	* elf64-mips.c (mips_elf64_swap_reloc_out): Enable.
	(mips_elf64_be_swap_reloc_in): New function.
	(mips_elf64_be_swap_reloc_out): Likewise.
	(mips_elf64_be_swap_reloca_in): Likewise.
	(mips_elf64_be_swap_reloca_out): Likewise.
	(mips_elf64_size_info): Add entries for new fields.
@
text
@d2105 1
a2105 1
	  int i;
@


1.11
log
@tweak last elf_merge_symbol patch
@
text
@d2000 2
d2007 1
a2011 1
  bed = get_elf_backend_data (abfd);
d2073 2
d2088 2
d2096 1
d2101 3
a2103 1
      for (; erel < erelend; erel++, irela++)
d2105 6
a2110 1
	  Elf_Internal_Rel irel;
d2112 6
a2117 4
	  elf_swap_reloc_in (abfd, erel, &irel);
	  irela->r_offset = irel.r_offset;
	  irela->r_info = irel.r_info;
	  irela->r_addend = 0;
d2131 7
a2137 2
      for (; erela < erelaend; erela++, irela++)
	elf_swap_reloca_in (abfd, erela, irela);
d2165 1
d2179 2
a2180 1
      size = o->reloc_count * sizeof (Elf_Internal_Rela);
d2209 2
a2210 1
       internal_relocs + rel_hdr->sh_size / rel_hdr->sh_entsize))
d2726 1
d3075 2
a3076 1
      s->_raw_size = (2 + bucketcount + dynsymcount) * (ARCH_SIZE / 8);
d3082 3
a3084 2
      put_word (output_bfd, bucketcount, s->contents);
      put_word (output_bfd, dynsymcount, s->contents + (ARCH_SIZE / 8));
d4073 2
a4074 1
				       * sizeof (Elf_Internal_Rela)));
d4769 1
d4782 2
d4785 6
a4790 6
		   + (bucket + 2) * (ARCH_SIZE / 8));
      chain = get_word (finfo->output_bfd, bucketpos);
      put_word (finfo->output_bfd, h->dynindx, bucketpos);
      put_word (finfo->output_bfd, chain,
		((bfd_byte *) finfo->hash_sec->contents
		 + (bucketcount + 2 + h->dynindx) * (ARCH_SIZE / 8)));
d4932 1
d4935 2
a4936 2
  relocate_section =
    get_elf_backend_data (output_bfd)->elf_backend_relocate_section;
d5173 2
a5174 1
	      irelaend = irela + o->reloc_count;
d5784 1
d5828 1
a5828 1
      relend = relstart + sec->reloc_count;
d6034 1
d6052 2
a6053 1
  relend = relstart + sec->reloc_count;
@


1.10
log
@	* elflink.h (elf_bfd_final_link): Assert that section reloc_count
	field equals the new rel_count field.
	(elf_link_input_bfd): When doing a relocateable link, use the new
	rel_count field rather than the reloc_count field.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	Based on patch from H.J. Lu <hjl@@gnu.org>:
	* elflink.h (elf_merge_symbol): Permit a non-weak definition in a
	shared library to override a weak definition in a regular object.
@
text
@d369 7
d648 1
a648 2
     case, we prefer the definition in the shared object.  To make
     this work we have to frob the flags.  */
a649 1
      && ! olddyn
d654 13
a666 1
    h->elf_link_hash_flags &= ~ ELF_LINK_HASH_DEF_REGULAR;
@


1.9
log
@	* elf-bfd.h (bfd_elf_section_data): Add rel_count and rel_count2
	fields.
	(_bfd_elf_init_reloc_shdr): New function.
	* elf.c (_bfd_elf_new_section_hook): Use bfd_zalloc, rather than
	bfd_alloc followed by memset.
	(_bfd_elf_init_reloc_shdr): New function, split out from ...
	(elf_fake_sections): Here.
	(assign_section_numbers): Assign section numbers for the second
	relocation section, if required.
	* elflink.h (elf_link_output_relocs): New function.
	(elf_link_size_reloc_section): Likewise.
	(elf_bfd_final_link): Use elf_link_size_reloc_section.
	(elf_link_input_bfd): Use elf_link_output_relocs.
	* elf32-mips.c (_bfd_mips_elf_fake_sections): Use
	_bfd_elf_init_reloc_shdr to initialize rel_hdr2.
@
text
@d495 4
a498 1
     object to override a weak symbol in a shared object.  */
d505 3
a507 1
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC))))
d551 4
a554 1
     symbol is a function or is weak.  */
d563 3
a565 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d639 25
d4177 1
d5126 1
a5126 1
			  + o->output_section->reloc_count);
d5316 1
a5316 1
		  + output_section->reloc_count);
d5425 1
a5425 1
	      + output_section->reloc_count);
d5437 1
a5437 1
	       + output_section->reloc_count);
d5441 1
a5441 1
  ++output_section->reloc_count;
d5661 2
a5662 2
				    + lsect->section->reloc_count));
	      ++lsect->section->reloc_count;
@


1.8
log
@	* elflink.h (elf_link_output_extsym): It's OK for a -Bsymbolic
	shared library to have an undefined symbol.
@
text
@d59 4
d2070 9
a2078 6
/* Read and swap the relocs for a section.  They may have been cached.
   If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are not NULL,
   they are used as buffers to read into.  They are known to be large
   enough.  If the INTERNAL_RELOCS relocs argument is NULL, the return
   value is allocated using either malloc or bfd_alloc, according to
   the KEEP_MEMORY argument.  */
d3679 42
d3882 3
a3884 11
	  Elf_Internal_Shdr *rel_hdr;
	  register struct elf_link_hash_entry **p, **pend;

	  rel_hdr = &elf_section_data (o)->rel_hdr;

	  rel_hdr->sh_size = rel_hdr->sh_entsize * o->reloc_count;

	  /* The contents field must last into write_object_contents,
	     so we allocate it with bfd_alloc rather than malloc.  */
	  rel_hdr->contents = (PTR) bfd_alloc (abfd, rel_hdr->sh_size);
	  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
d3887 4
a3890 4
	  p = ((struct elf_link_hash_entry **)
	       bfd_malloc (o->reloc_count
			   * sizeof (struct elf_link_hash_entry *)));
	  if (p == NULL && o->reloc_count != 0)
a3891 8
	  elf_section_data (o)->rel_hashes = p;
	  pend = p + o->reloc_count;
	  for (; p < pend; p++)
	    *p = NULL;

	  /* Use the reloc_count field as an index when outputting the
	     relocs.  */
	  o->reloc_count = 0;
d4753 70
a5083 1
	      Elf_Internal_Shdr *output_rel_hdr;
d5214 10
a5223 34
	      output_rel_hdr = &elf_section_data (o->output_section)->rel_hdr;
	      BFD_ASSERT (output_rel_hdr->sh_entsize
			  == input_rel_hdr->sh_entsize);
	      irela = internal_relocs;
	      irelaend = irela + o->reloc_count;
	      if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
		{
		  Elf_External_Rel *erel;

		  erel = ((Elf_External_Rel *) output_rel_hdr->contents
			  + o->output_section->reloc_count);
		  for (; irela < irelaend; irela++, erel++)
		    {
		      Elf_Internal_Rel irel;

		      irel.r_offset = irela->r_offset;
		      irel.r_info = irela->r_info;
		      BFD_ASSERT (irela->r_addend == 0);
		      elf_swap_reloc_out (output_bfd, &irel, erel);
		    }
		}
	      else
		{
		  Elf_External_Rela *erela;

		  BFD_ASSERT (input_rel_hdr->sh_entsize
			      == sizeof (Elf_External_Rela));
		  erela = ((Elf_External_Rela *) output_rel_hdr->contents
			   + o->output_section->reloc_count);
		  for (; irela < irelaend; irela++, erela++)
		    elf_swap_reloca_out (output_bfd, irela, erela);
		}

	      o->output_section->reloc_count += o->reloc_count;
@


1.7
log
@	* elflink.h (size_dynamic_sections): Use user-specified init/fini
	functions instead of _init/_fini if requested.
@
text
@a4484 1
	    && !finfo->info->symbolic
@


1.6
log
@	* elflink.h (link_read_relocs): Explicitly cast external_relocs to
	bfd_byte * before performing pointer arithmetic.
@
text
@d2592 8
a2599 2
      h =  elf_link_hash_lookup (elf_hash_table (info), "_init", false,
				false, false);
d2607 5
a2611 2
      h =  elf_link_hash_lookup (elf_hash_table (info), "_fini", false,
				 false, false);
d2619 1
a4171 4

	      /* SVR4 linkers seem to set DT_INIT and DT_FINI based on
                 magic _init and _fini symbols.  This is pretty ugly,
                 but we are compatible.  */
d4173 1
a4173 1
	      name = "_init";
d4176 1
a4176 1
	      name = "_fini";
@


1.5
log
@	* elflink.h (elf_link_remove_section_and_adjust_dynindices):
	Remove unused local variable spp.
@
text
@d2126 1
a2126 1
       external_relocs + rel_hdr->sh_size,
@


1.4
log
@	* elflink.h (elf_link_remove_section_and_adjust_dynindices):
	Remove abfd parameter.  Use _bfd_strip_section_from_output.
	(bfd_elf_size_dynamic_sections): Adjust callers accordingly.
@
text
@a2414 2
  asection **spp;

@


1.3
log
@	* elf-bfd.h (_bfd_elf_link_adjust_dynindx): New function.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Define it.
	* elflink.h (elf_link_remove_section_and_adjust_dynindices): New
	function.
	(bfd_elf_size_dynamic_sections): Use it.
@
text
@d58 1
a58 1
  PARAMS ((bfd *, struct bfd_link_info *, asection *));
d2411 1
a2411 2
elf_link_remove_section_and_adjust_dynindices (abfd, info, section)
     bfd *abfd;
d2418 1
a2418 6
  for (spp = &abfd->sections;
       *spp != section->output_section;
       spp = &(*spp)->next)
    ;
  *spp = section->output_section->next;
  --abfd->section_count;
d2645 1
a2645 3
	elf_link_remove_section_and_adjust_dynindices (output_bfd,
						       info,
						       s);
d2838 1
a2838 3
	  elf_link_remove_section_and_adjust_dynindices (output_bfd,
							 info,
							 s);
d2938 1
a2938 3
	  elf_link_remove_section_and_adjust_dynindices (output_bfd,
							 info,
							 s);
@


1.2
log
@	* elflink.h (elf_link_read_relocs_from_section): New function,
	split out from ...
	(elf_link_read_relocs): Here.  Use it for both relocation
	sections.
@
text
@d57 2
d2406 44
d2651 3
a2653 11
	{
	  asection **spp;

	  /* Don't include this section in the output file.  */
	  for (spp = &output_bfd->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --output_bfd->section_count;
	}
d2846 3
a2848 13
	  {
	    asection **spp;

	    /* We don't have any version definitions, so we can just
               remove the section.  */

	    for (spp = &output_bfd->sections;
		 *spp != s->output_section;
		 spp = &(*spp)->next)
	      ;
	    *spp = s->output_section->next;
	    --output_bfd->section_count;
	  }
d2948 6
a2953 10
	  asection **spp;

	  /* We don't need any symbol versions; just discard the
             section.  */
	  for (spp = &output_bfd->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --output_bfd->section_count;
@


1.1
log
@Initial revision
@
text
@d55 2
d1996 68
d2107 5
a2111 1
      alloc1 = (PTR) bfd_malloc ((size_t) rel_hdr->sh_size);
d2117 9
a2125 3
  if ((bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0)
      || (bfd_read (external_relocs, 1, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
a2126 37

  /* Swap in the relocs.  For convenience, we always produce an
     Elf_Internal_Rela array; if the relocs are Rel, we set the addend
     to 0.  */
  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
    {
      Elf_External_Rel *erel;
      Elf_External_Rel *erelend;
      Elf_Internal_Rela *irela;

      erel = (Elf_External_Rel *) external_relocs;
      erelend = erel + o->reloc_count;
      irela = internal_relocs;
      for (; erel < erelend; erel++, irela++)
	{
	  Elf_Internal_Rel irel;

	  elf_swap_reloc_in (abfd, erel, &irel);
	  irela->r_offset = irel.r_offset;
	  irela->r_info = irel.r_info;
	  irela->r_addend = 0;
	}
    }
  else
    {
      Elf_External_Rela *erela;
      Elf_External_Rela *erelaend;
      Elf_Internal_Rela *irela;

      BFD_ASSERT (rel_hdr->sh_entsize == sizeof (Elf_External_Rela));

      erela = (Elf_External_Rela *) external_relocs;
      erelaend = erela + o->reloc_count;
      irela = internal_relocs;
      for (; erela < erelaend; erela++, irela++)
	elf_swap_reloca_in (abfd, erela, irela);
    }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

