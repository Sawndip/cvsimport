head	1.29;
access;
symbols
	binutils-2_20_1:1.24
	sid-snapshot-20100401:1.28
	gdb_7_1-2010-03-18-release:1.27
	sid-snapshot-20100301:1.27
	gdb_7_1-branch:1.27.0.2
	gdb_7_1-2010-02-18-branchpoint:1.27
	sid-snapshot-20100201:1.27
	sid-snapshot-20100101:1.26
	gdb_7_0_1-2009-12-22-release:1.24
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.24
	binutils-2_20:1.24
	gdb_7_0-2009-10-06-release:1.24
	sid-snapshot-20091001:1.24
	gdb_7_0-branch:1.24.0.8
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.21
	binutils-arc-20081103-branch:1.21.0.22
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.24.0.6
	binutils-2_20-branchpoint:1.24
	sid-snapshot-20090901:1.24
	sid-snapshot-20090801:1.24
	msnyder-checkpoint-072509-branch:1.24.0.4
	msnyder-checkpoint-072509-branchpoint:1.24
	sid-snapshot-20090701:1.24
	dje-cgen-play1-branch:1.24.0.2
	dje-cgen-play1-branchpoint:1.24
	sid-snapshot-20090601:1.24
	sid-snapshot-20090501:1.24
	sid-snapshot-20090401:1.24
	arc-20081103-branch:1.21.0.20
	arc-20081103-branchpoint:1.21
	arc-insight_6_8-branch:1.21.0.18
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.16
	insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.23
	binutils-2_19_1:1.21
	sid-snapshot-20090201:1.22
	sid-snapshot-20090101:1.22
	reverse-20081226-branch:1.22.0.4
	reverse-20081226-branchpoint:1.22
	sid-snapshot-20081201:1.22
	multiprocess-20081120-branch:1.22.0.2
	multiprocess-20081120-branchpoint:1.22
	sid-snapshot-20081101:1.21
	binutils-2_19:1.21
	sid-snapshot-20081001:1.21
	reverse-20080930-branch:1.21.0.14
	reverse-20080930-branchpoint:1.21
	binutils-2_19-branch:1.21.0.12
	binutils-2_19-branchpoint:1.21
	sid-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	reverse-20080717-branch:1.21.0.10
	reverse-20080717-branchpoint:1.21
	sid-snapshot-20080701:1.21
	msnyder-reverse-20080609-branch:1.21.0.8
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.19.0.4
	drow-reverse-20070409-branchpoint:1.19
	sid-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	gdb_6_8-2008-03-27-release:1.21
	sid-snapshot-20080301:1.21
	gdb_6_8-branch:1.21.0.6
	gdb_6_8-2008-02-26-branchpoint:1.21
	sid-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.21
	gdb_6_7-2007-10-10-release:1.21
	sid-snapshot-20071001:1.21
	gdb_6_7-branch:1.21.0.4
	gdb_6_7-2007-09-07-branchpoint:1.21
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.2
	binutils-2_18-branchpoint:1.21
	insight_6_6-20070208-release:1.19
	binutils-csl-coldfire-4_1-32:1.18
	binutils-csl-sourcerygxx-4_1-32:1.18
	gdb_6_6-2006-12-18-release:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.18
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.18
	binutils-csl-sourcerygxx-4_1-30:1.18
	binutils-csl-coldfire-4_1-28:1.18
	binutils-csl-sourcerygxx-4_1-29:1.18
	binutils-csl-sourcerygxx-4_1-28:1.18
	gdb_6_6-branch:1.19.0.2
	gdb_6_6-2006-11-15-branchpoint:1.19
	binutils-csl-arm-2006q3-27:1.18
	binutils-csl-sourcerygxx-4_1-27:1.18
	binutils-csl-arm-2006q3-26:1.18
	binutils-csl-sourcerygxx-4_1-26:1.18
	binutils-csl-sourcerygxx-4_1-25:1.18
	binutils-csl-sourcerygxx-4_1-24:1.18
	binutils-csl-sourcerygxx-4_1-23:1.18
	insight_6_5-20061003-release:1.18
	gdb-csl-symbian-6_4_50_20060226-12:1.18
	binutils-csl-sourcerygxx-4_1-21:1.18
	binutils-csl-arm-2006q3-21:1.18
	binutils-csl-sourcerygxx-4_1-22:1.18
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18
	binutils-csl-sourcerygxx-4_1-20:1.18
	binutils-csl-arm-2006q3-19:1.18
	binutils-csl-sourcerygxx-4_1-19:1.18
	binutils-csl-sourcerygxx-4_1-18:1.18
	binutils-csl-renesas-4_1-9:1.18
	gdb-csl-sourcerygxx-3_4_4-25:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.18
	gdb-csl-symbian-6_4_50_20060226-11:1.18
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	gdb-csl-sourcerygxx-4_1-17:1.18
	binutils-csl-sourcerygxx-4_1-17:1.18
	gdb-csl-20060226-branch-local-2:1.18
	gdb-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	gdb-csl-sourcerygxx-4_1-13:1.18
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.18
	gdb-csl-sourcerygxx-4_1-12:1.18
	binutils-csl-sourcerygxx-4_1-12:1.18
	gdb-csl-sourcerygxx-3_4_4-21:1.18
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	gdb_6_5-20060621-release:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	gdb-csl-sourcerygxx-4_1-9:1.18
	binutils-csl-sourcerygxx-4_1-9:1.18
	gdb-csl-sourcerygxx-4_1-8:1.18
	binutils-csl-sourcerygxx-4_1-8:1.18
	gdb-csl-sourcerygxx-4_1-7:1.18
	binutils-csl-sourcerygxx-4_1-7:1.18
	gdb-csl-arm-2006q1-6:1.18
	binutils-csl-arm-2006q1-6:1.18
	gdb-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.15
	gdb-csl-symbian-6_4_50_20060226-10:1.18
	gdb-csl-symbian-6_4_50_20060226-9:1.18
	gdb-csl-symbian-6_4_50_20060226-8:1.18
	gdb-csl-coldfire-4_1-11:1.18
	binutils-csl-coldfire-4_1-11:1.18
	gdb-csl-sourcerygxx-3_4_4-19:1.18
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	gdb-csl-coldfire-4_1-10:1.18
	gdb_6_5-branch:1.18.0.30
	gdb_6_5-2006-05-14-branchpoint:1.18
	binutils-csl-coldfire-4_1-10:1.18
	gdb-csl-sourcerygxx-4_1-5:1.18
	binutils-csl-sourcerygxx-4_1-5:1.18
	nickrob-async-20060513-branch:1.18.0.28
	nickrob-async-20060513-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-4:1.18
	binutils-csl-sourcerygxx-4_1-4:1.18
	msnyder-reverse-20060502-branch:1.18.0.26
	msnyder-reverse-20060502-branchpoint:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.15
	gdb-csl-morpho-4_1-4:1.18
	binutils-csl-morpho-4_1-4:1.18
	gdb-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.15
	readline_5_1-import-branch:1.18.0.24
	readline_5_1-import-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.18
	binutils-2_17-branch:1.18.0.22
	binutils-2_17-branchpoint:1.18
	gdb-csl-symbian-20060226-branch:1.18.0.20
	gdb-csl-symbian-20060226-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.18
	msnyder-reverse-20060331-branch:1.18.0.18
	msnyder-reverse-20060331-branchpoint:1.18
	binutils-csl-2_17-branch:1.18.0.16
	binutils-csl-2_17-branchpoint:1.18
	gdb-csl-available-20060303-branch:1.18.0.14
	gdb-csl-available-20060303-branchpoint:1.18
	gdb-csl-20060226-branch:1.18.0.12
	gdb-csl-20060226-branchpoint:1.18
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.18.0.10
	msnyder-fork-checkpoint-branchpoint:1.18
	gdb-csl-gxxpro-6_3-branch:1.18.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.6
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.4
	gdb-csl-arm-20051020-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.15.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	msnyder-tracepoint-checkpoint-branch:1.18.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.18
	gdb-csl-arm-20050325-2005-q1b:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	gdb-csl-arm-20050325-2005-q1a:1.15
	binutils-csl-arm-2005q1a:1.15
	csl-arm-20050325-branch:1.15.0.6
	csl-arm-20050325-branchpoint:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.18
	gdb_6_3-20041019-branchpoint:1.13
	csl-arm-2004-q3:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.20
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.14
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.12
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.8
	drow_intercu-20040221-branchpoint:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	csl-arm-2003-q4:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.42
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.40
	cagney_x86i386-20030821-branch:1.12.0.38
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.36
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.12
	binutils-2_14:1.12
	cagney_convert-20030606-branch:1.12.0.32
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.30
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.26
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.12
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.22
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.20
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.18
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.16
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.14
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.12
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.10
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.8
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.6
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.24
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.22
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.20
	gdb_5_3-branch:1.10.0.18
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.16
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.14
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.12
	kseitz_interps-20020528-branch:1.10.0.10
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.8
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.10.0.6
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	insight-precleanup-2001-01-01:1.5
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.28
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2010.04.14.09.24.59;	author gingold;	state dead;
branches;
next	1.28;

1.28
date	2010.04.01.09.47.14;	author gingold;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.27.16.43.27;	author gingold;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.24.13.13.43;	author gingold;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.18.11.47.18;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.23.09.28.43;	author gingold;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.14.09.57.33;	author gingold;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.15.53.40;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.07.19.38;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.14.12.06.03;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.02.05.58.41;	author amodra;	state Exp;
branches
	1.10.10.1
	1.10.22.1
	1.10.24.1;
next	1.9;

1.9
date	2001.09.19.05.33.13;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.01.10.29.27;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.26.19.50.50;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.12.21.18.40.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.30.12;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.07.35.17;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.10.10.1
date	2002.11.03.22.01.38;	author ezannoni;	state Exp;
branches;
next	;

1.10.22.1
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.10.22.2;

1.10.22.2
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	1.10.22.3;

1.10.22.3
date	2003.12.15.23.59.54;	author carlton;	state Exp;
branches;
next	;

1.10.24.1
date	2002.10.26.17.12.00;	author drow;	state Exp;
branches;
next	1.10.24.2;

1.10.24.2
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;


desc
@@


1.29
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (BFD32_BACKENDS): Remove vms-gsd.lo, vms-hdr.lo,
	vms-tir.lo, vms.lo and add vms-alpha.lo
	(BFD32_BACKENDS_CFILES): Remove vms-gsd.c, vms-hdr.c,
	vms-tir.c, vms.c and add vms-alpha.c
	* Makefile.in: Regenerate.
	* configure.in (TDEFINES): Adjust file list for vms_alpha_vec.
	Remove vms_vax_vec.
	* configure: Regenerate.
	* targets.c (vms_vax_vec): Remove the declaration.
	(_bfd_target_vector): Remove vms_vax_vec.
	* vms-alpha.c: New file.
	* vms-gsd.c: Removed, rewritten in vms-alpha.c
	* vms-hdr.c: Ditto.
	* vms-tir.c: Ditto.
	* vms.c: Ditto.
	* vms-misc.c: Fix indentation and comments.  Replace most of
	#if VMS_DEBUG/vms_debug with vms_debug2.
	(_bfd_vms_hash_newfunc): Moved to vms-alpha.c
	(hash_string): Ditto.
	(_bfd_vms_length_hash_symbol): Ditto.
	(maybe_adjust_record_pointer_for_object): Ditto.
	(_bfd_vms_get_object_record): Ditto.
	(vms_get_remaining_object_record): Ditto.
	(_bfd_vms_push): Ditto.
	(_bfd_vms_pop): Ditto.
	(_bfd_vms_get_header_values): Removed.
	(_bfd_vms_get_first_record): Removed.
	(vms_get_remaining_image_record): Removed.
	(new_symbol): Removed.
	(_bfd_vms_enter_symbol): Removed.
	(_bfd_vms_save_sized_string): Use memcpy instead of strncpy.
	(_bfd_vms_output_begin): Remove rechead parameter.  Replace bfd
	parameter with struct vms_rec_wr.
	(_bfd_vms_output_push): Removed and replaced by ...
	(_bfd_vms_output_begin_subrec): ... new function.
	(_bfd_vms_output_alignment): Replace bfd parameter with
	struct vms_rec_wr, and adjust.
	(_bfd_vms_output_check): Ditto
	(_bfd_vms_output_byte): Ditto.
	(_bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long): Ditto.
	(_bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted): Ditto.
	(_bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(_bfd_vms_output_pop): Removed and replaced by ...
	(_bfd_vms_output_end_subrec): ... new function.
	(_bfd_vms_output_flush): Removed.
	(_bfd_vms_output_align): New function.
	(_bfd_vms_output_end): Add recwr parameter.  Adjust for this new
	parameter.
	(vms_convert_to_var): New function imported from vms.c
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_get_module_name): Ditto.
	(get_vms_time_string): Ditto.
	(vms_time_to_time_t): Ditto.
	(vms_rawtime_to_time_t): Ditto.
	* vms.h: All macros for the VMS file format are now in include/vms.
	Prototypes for vms.c, vms-gsd.c, vms-misc.c, vms-hdr.c, vms-tir.c
	have been removed.
	(struct vms_symbol_struct, struct stack_struct): Moved to vms-alpha.c
	(struct fileinfo, struct srecinfo, struct lineinfo): Ditto.
	(struct funcinfo, struct vms_private_data_struct): Ditto.
	(struct vms_section_data_struct): Ditto.
	(struct vms_rec_rd, stryct vms_rec_wr): New declarations.
	(vms_get_module_name, get_vms_time_string): New declarations.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	(_bfd_vms_output_begin_subrec, _bfd_vms_output_end_subrec): Ditto.
	(_bfd_vms_save_sized_string, _bfd_vms_save_counted_string): Adjusted.
	(_bfd_vms_output_begin, _bfd_vms_output_alignment): Ditto.
	(_bfd_vms_output_end,_bfd_vms_output_check): Ditto.
	(_bfd_vms_output_byte, _bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long, _bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted, _bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(bfd_vms_set_section_flags): Ditto.
@
text
@/* vms-hdr.c -- BFD back-end for VMS/VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
   2007, 2008, 2009 Free Software Foundation, Inc.

   HDR record handling functions
   EMH record handling functions

   EOM record handling functions
   EEOM record handling functions

   IHD record handling functions
   EIHD record handling functions

   ISD record handling functions
   EISD record handling functions

   IHS record handling functions
   EIHS record handling functions

   DBG record handling functions
   EDBG record handling functions

   TBT record handling functions
   ETBT record handling functions

   DST/DMT section handling functions

   Written by Klaus K"ampf (kkaempf@@rmi.de)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdver.h"
#include "bfdlink.h"
#include "safe-ctype.h"
#include "libbfd.h"

#include "vms.h"

static struct module *new_module (bfd *);
static void parse_module
  (bfd *, struct module *, unsigned char *, unsigned int);
static struct module *build_module_list (bfd *);
static bfd_boolean module_find_nearest_line
  (bfd *, struct module *, bfd_vma, const char **, const char **,
   unsigned int *);
static int vms_slurp_debug (bfd *);

#define SET_MODULE_PARSED(m) \
  do { if ((m)->name == NULL) (m)->name = ""; } while (0)
#define IS_MODULE_PARSED(m) ((m)->name != NULL)


/* Read & process emh record
   return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_hdr (bfd *abfd, int objtype)
{
  unsigned char *ptr;
  unsigned char *vms_rec;
  int subtype;

  vms_rec = PRIV(vms_rec);

#if VMS_DEBUG
  vms_debug(2, "HDR/EMH\n");
#endif

  switch (objtype)
    {
    case OBJ_S_C_HDR:
      subtype = vms_rec[1];
      break;
    case EOBJ_S_C_EMH:
      subtype = bfd_getl16 (vms_rec + 4) + EVAX_OFFSET;
      break;
    default:
      subtype = -1;
    }

#if VMS_DEBUG
  vms_debug(3, "subtype %d\n", subtype);
#endif

  switch (subtype)
    {
    case MHD_S_C_MHD:
      /* Module header.  */
      PRIV (hdr_data).hdr_b_strlvl = vms_rec[2];
      PRIV (hdr_data).hdr_l_recsiz = bfd_getl16 (vms_rec + 3);
      PRIV (hdr_data).hdr_t_name = _bfd_vms_save_counted_string (vms_rec + 5);
      ptr = vms_rec + 5 + vms_rec[5] + 1;
      PRIV (hdr_data).hdr_t_version = _bfd_vms_save_counted_string (ptr);
      ptr += *ptr + 1;
      PRIV (hdr_data).hdr_t_date = _bfd_vms_save_sized_string (ptr, 17);
      break;

    case MHD_S_C_LNM:
      PRIV (hdr_data).hdr_c_lnm = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 2));
      break;

    case MHD_S_C_SRC:
      PRIV (hdr_data).hdr_c_src = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 2));
      break;

    case MHD_S_C_TTL:
      PRIV (hdr_data).hdr_c_ttl = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 2));
      break;

    case EMH_S_C_MHD + EVAX_OFFSET:
      /* Module header.  */
      PRIV (hdr_data).hdr_b_strlvl = vms_rec[6];
      PRIV (hdr_data).hdr_l_arch1  = bfd_getl32 (vms_rec + 8);
      PRIV (hdr_data).hdr_l_arch2  = bfd_getl32 (vms_rec + 12);
      PRIV (hdr_data).hdr_l_recsiz = bfd_getl32 (vms_rec + 16);
      PRIV (hdr_data).hdr_t_name   = _bfd_vms_save_counted_string (vms_rec + 20);
      ptr = vms_rec + 20 + vms_rec[20] + 1;
      PRIV (hdr_data).hdr_t_version =_bfd_vms_save_counted_string (ptr);
      ptr += *ptr + 1;
      PRIV (hdr_data).hdr_t_date = _bfd_vms_save_sized_string (ptr, 17);
      break;

    case EMH_S_C_LNM + EVAX_OFFSET:
      PRIV (hdr_data).hdr_c_lnm = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 6));
      break;

    case EMH_S_C_SRC + EVAX_OFFSET:
      PRIV (hdr_data).hdr_c_src = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 6));
      break;

    case EMH_S_C_TTL + EVAX_OFFSET:
      PRIV (hdr_data).hdr_c_ttl = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_size - 6));
      break;

    case MHD_S_C_CPR:
    case MHD_S_C_MTC:
    case MHD_S_C_GTX:
    case EMH_S_C_CPR + EVAX_OFFSET:
    case EMH_S_C_MTC + EVAX_OFFSET:
    case EMH_S_C_GTX + EVAX_OFFSET:
      break;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return 0;
}

/* Output routines.  */

/* Manufacture a VMS like time on a unix based system.
   stolen from obj-vms.c.  */

static unsigned char *
get_vms_time_string (void)
{
  static unsigned char tbuf[18];
#ifndef VMS
#include <time.h>

  char *pnt;
  time_t timeb;

  time (& timeb);
  pnt = ctime (&timeb);
  pnt[3] = 0;
  pnt[7] = 0;
  pnt[10] = 0;
  pnt[16] = 0;
  pnt[24] = 0;
  sprintf ((char *) tbuf, "%2s-%3s-%s %s",
	   pnt + 8, pnt + 4, pnt + 20, pnt + 11);
#else
#include <starlet.h>
  struct
  {
    int Size;
    unsigned char *Ptr;
  } Descriptor;
  Descriptor.Size = 17;
  Descriptor.Ptr = tbuf;
  SYS$ASCTIM (0, &Descriptor, 0, 0);
#endif /* not VMS */

#if VMS_DEBUG
  vms_debug (6, "vmstimestring:'%s'\n", tbuf);
#endif

  return tbuf;
}

/* Write object header for bfd abfd.  */

int
_bfd_vms_write_hdr (bfd *abfd, int objtype)
{
  asymbol *symbol;
  unsigned int symnum;
  int had_case = 0;
  int had_file = 0;
  char version [256];

#if VMS_DEBUG
  vms_debug (2, "vms_write_hdr (%p)\n", abfd);
#endif

  _bfd_vms_output_alignment (abfd, 2);

  /* MHD.  */
  if (objtype != OBJ_S_C_HDR)
    {
      _bfd_vms_output_begin (abfd, EOBJ_S_C_EMH, EMH_S_C_MHD);
      _bfd_vms_output_short (abfd, EOBJ_S_C_STRLVL);
      _bfd_vms_output_long (abfd, 0);
      _bfd_vms_output_long (abfd, 0);
      _bfd_vms_output_long (abfd, MAX_OUTREC_SIZE);
    }

  /* Create module name from filename.  */
  if (bfd_get_filename (abfd) != 0)
    {
      char *module = vms_get_module_name (bfd_get_filename (abfd), TRUE);
      _bfd_vms_output_counted (abfd, module);
      free (module);
    }
  else
    _bfd_vms_output_counted (abfd, "NONAME");

  _bfd_vms_output_counted (abfd, BFD_VERSION_STRING);
  _bfd_vms_output_dump (abfd, get_vms_time_string (), EMH_DATE_LENGTH);
  _bfd_vms_output_fill (abfd, 0, EMH_DATE_LENGTH);
  _bfd_vms_output_flush (abfd);

  /* LMN.  */
  _bfd_vms_output_begin (abfd, EOBJ_S_C_EMH, EMH_S_C_LNM);
  snprintf (version, sizeof (version), "GAS BFD v%s", BFD_VERSION_STRING);
  _bfd_vms_output_dump (abfd, (unsigned char *)version, strlen (version));
  _bfd_vms_output_flush (abfd);

  /* SRC.  */
  _bfd_vms_output_begin (abfd, EOBJ_S_C_EMH, EMH_S_C_SRC);

  for (symnum = 0; symnum < abfd->symcount; symnum++)
    {
      symbol = abfd->outsymbols[symnum];

      if (symbol->flags & BSF_FILE)
	{
	  if (CONST_STRNEQ ((char *)symbol->name, "<CASE:"))
	    {
	      PRIV (flag_hash_long_names) = symbol->name[6] - '0';
	      PRIV (flag_show_after_trunc) = symbol->name[7] - '0';

	      if (had_file)
		break;
	      had_case = 1;
	      continue;
	    }

	  _bfd_vms_output_dump (abfd, (unsigned char *) symbol->name,
				(int) strlen (symbol->name));
	  if (had_case)
	    break;
	  had_file = 1;
	}
    }

  if (symnum == abfd->symcount)
    _bfd_vms_output_dump (abfd, (unsigned char *) STRING_COMMA_LEN ("noname"));

  _bfd_vms_output_flush (abfd);

  /* TTL.  */
  _bfd_vms_output_begin (abfd, EOBJ_S_C_EMH, EMH_S_C_TTL);
  _bfd_vms_output_dump (abfd, (unsigned char *) STRING_COMMA_LEN ("TTL"));
  _bfd_vms_output_flush (abfd);

  /* CPR.  */
  _bfd_vms_output_begin (abfd, EOBJ_S_C_EMH, EMH_S_C_CPR);
  _bfd_vms_output_dump (abfd,
			 (unsigned char *)"GNU BFD ported by Klaus Kämpf 1994-1996",
			 39);
  _bfd_vms_output_flush (abfd);

  return 0;
}

/* Process EOM/EEOM record
   return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_eom (bfd *abfd, int objtype)
{
  unsigned char *vms_rec;

#if VMS_DEBUG
  vms_debug(2, "EOM/EEOM\n");
#endif

  vms_rec = PRIV (vms_rec);

  if ((objtype == OBJ_S_C_EOM)
     || (objtype == OBJ_S_C_EOMW))
    {
    }
  else
    {
      PRIV (eom_data).eom_l_total_lps
        = bfd_getl32 (vms_rec + EEOM_S_L_TOTAL_LPS);
      PRIV (eom_data).eom_w_comcod = bfd_getl16 (vms_rec + EEOM_S_W_COMCOD);
      if (PRIV (eom_data).eom_w_comcod > 1)
	{
	  (*_bfd_error_handler) (_("Object module NOT error-free !\n"));
	  bfd_set_error (bfd_error_bad_value);
	  return -1;
	}
      PRIV (eom_data).eom_has_transfer = FALSE;
      if (PRIV (rec_size) > 10)
	{
	   PRIV (eom_data).eom_has_transfer = TRUE;
	   PRIV (eom_data).eom_b_tfrflg = vms_rec[EEOM_S_B_TFRFLG];
	   PRIV (eom_data).eom_l_psindx
	     = bfd_getl32 (vms_rec + EEOM_S_L_PSINDX);
	   PRIV (eom_data).eom_l_tfradr
	     = bfd_getl32 (vms_rec + EEOM_S_L_TFRADR);

	   abfd->start_address = PRIV (eom_data).eom_l_tfradr;
	}
    }
  return 0;
}

/* Write eom record for bfd abfd.  */

int
_bfd_vms_write_eom (bfd *abfd, int objtype)
{
#if VMS_DEBUG
  vms_debug (2, "vms_write_eom (%p, %d)\n", abfd, objtype);
#endif

  _bfd_vms_output_begin (abfd, objtype, -1);
  _bfd_vms_output_long (abfd, (unsigned long) (PRIV (vms_linkage_index) >> 1));
  _bfd_vms_output_byte (abfd, 0);	/* Completion code.  */
  _bfd_vms_output_byte (abfd, 0);	/* Fill byte.  */

  if (bfd_get_start_address (abfd) != (bfd_vma)-1)
    {
      asection *section;

      section = bfd_get_section_by_name (abfd, ".link");
      if (section == 0)
	{
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return -1;
	}
      _bfd_vms_output_short (abfd, 0);
      _bfd_vms_output_long (abfd, (unsigned long) (section->index));
      _bfd_vms_output_long (abfd,
			     (unsigned long) bfd_get_start_address (abfd));
      _bfd_vms_output_long (abfd, 0);
    }

  _bfd_vms_output_end (abfd);
  return 0;
}

/* Read & process IHD/EIHD record.
   Return 0 on success, -1 on error  */
int
_bfd_vms_slurp_ihd (bfd *abfd, unsigned int *isd_offset,
		    unsigned int *ihs_offset)
{
  unsigned int imgtype, size;
  bfd_vma symvva;

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_slurp_ihd\n");
#endif

  size = bfd_getl32 (PRIV (vms_rec) + EIHD_S_L_SIZE);
  imgtype = bfd_getl32 (PRIV (vms_rec) + EIHD_S_L_IMGTYPE);

  if (imgtype == EIHD_S_K_EXE)
    abfd->flags |= EXEC_P;

  symvva = bfd_getl64 (PRIV (vms_rec) + EIHD_S_Q_SYMVVA);
  if (symvva != 0)
    {
      PRIV (symvva) = symvva;
      abfd->flags |= DYNAMIC;
    }

  *isd_offset = bfd_getl32 (PRIV (vms_rec) + EIHD_S_L_ISDOFF);
  *ihs_offset = bfd_getl32 (PRIV (vms_rec) + EIHD_S_L_SYMDBGOFF);

#if VMS_DEBUG
  vms_debug (4, "EIHD record size %d imgtype %d symvva 0x%llx isd %d ihs %d\n",
	     size, imgtype, symvva, *isd_offset, *ihs_offset);
#endif

  return 0;
}

/* Read & process ISD/EISD record
   return 0 on success, -1 on error  */

int
_bfd_vms_slurp_isd (bfd *abfd, unsigned int offset)
{
  int section_count = 0;
  unsigned char *p;
  unsigned int rec_size;

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_slurp_isd\n");
#endif

  for (p = PRIV (vms_rec) + offset;
       (rec_size = bfd_getl32 (p + EISD_S_L_EISDSIZE)) != 0;
       p += rec_size)
    {
      unsigned long long vaddr = bfd_getl64 (p + EISD_S_Q_VIR_ADDR);
      unsigned int size = bfd_getl32 (p + EISD_S_L_SECSIZE);
      unsigned int flags = bfd_getl32 (p + EISD_S_L_FLAGS);
      unsigned int vbn = bfd_getl32 (p + EISD_S_L_VBN);
      char *name = NULL;
      asection *section;
      flagword bfd_flags;

#if VMS_DEBUG
      vms_debug (4, "EISD record at 0x%x size 0x%x addr 0x%x bfd_flags 0x%x block %d\n",
		 p - PRIV (vms_rec), size, vaddr, flags, vbn);
#endif

      /* VMS combines psects from .obj files into isects in the .exe.  This
	 process doesn't preserve enough information to reliably determine
	 what's in each section without examining the data.  This is
	 especially true of DWARF debug sections.  */
      bfd_flags = SEC_ALLOC;

      if (flags & EISD_S_M_EXE)
	bfd_flags |= SEC_CODE | SEC_HAS_CONTENTS | SEC_LOAD;

      if (flags & EISD_S_M_NONSHRADR)
	bfd_flags |= SEC_DATA | SEC_HAS_CONTENTS | SEC_LOAD;

      if (!(flags & EISD_S_M_WRT))
	bfd_flags |= SEC_READONLY;

      if (flags & EISD_S_M_DZRO)
	bfd_flags |= SEC_DATA;

      if (flags & EISD_S_M_FIXUPVEC)
	bfd_flags |= SEC_DATA | SEC_HAS_CONTENTS | SEC_LOAD;

      if (flags & EISD_S_M_CRF)
	bfd_flags |= SEC_HAS_CONTENTS | SEC_LOAD;

      if (flags & EISD_S_M_GBL)
	{
	  name = _bfd_vms_save_counted_string (p + EISD_S_T_GBLNAM);
	  bfd_flags |= SEC_COFF_SHARED_LIBRARY;
	  bfd_flags &= ~(SEC_ALLOC | SEC_LOAD);
	}
      else
	{
	  name = (char*) bfd_alloc (abfd, 32);
	  sprintf (name, "$LOCAL_%03d$", section_count++);
	}

      section = bfd_make_section (abfd, name);

      if (!section)
	return -1;

      section->filepos = vbn ? VMS_BLOCK_SIZE * (vbn - 1) : (unsigned int)-1;
      section->size = size;
      section->vma = vaddr;

      if (!bfd_set_section_flags (abfd, section, bfd_flags))
	return -1;
    }

  return 0;
}

/* Read & process IHS/EIHS record
   return 0 on success, -1 on error  */
int
_bfd_vms_slurp_ihs (bfd *abfd, unsigned int offset)
{
  unsigned char *p = PRIV (vms_rec) + offset;
  unsigned int gstvbn = bfd_getl32 (p + EIHS_S_L_GSTVBN);
  unsigned int gstsize ATTRIBUTE_UNUSED = bfd_getl32 (p + EIHS_S_L_GSTSIZE);
  unsigned int dstvbn = bfd_getl32 (p + EIHS_S_L_DSTVBN);
  unsigned int dstsize = bfd_getl32 (p + EIHS_S_L_DSTSIZE);
  unsigned int dmtvbn = bfd_getl32 (p + EIHS_S_L_DMTVBN);
  unsigned int dmtbytes = bfd_getl32 (p + EIHS_S_L_DMTBYTES);
  asection *section;

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_slurp_ihs\n");
  vms_debug (4, "EIHS record gstvbn %d gstsize %d dstvbn %d dstsize %d dmtvbn %d dmtbytes %d\n",
	     gstvbn, gstsize, dstvbn, dstsize, dmtvbn, dmtbytes);
#endif

  if (dstvbn)
    {
      flagword bfd_flags = SEC_HAS_CONTENTS | SEC_DEBUGGING;

      section = bfd_make_section (abfd, "$DST$");
      if (!section)
	return -1;

      section->size = dstsize;
      section->filepos = VMS_BLOCK_SIZE * (dstvbn - 1);

      if (!bfd_set_section_flags (abfd, section, bfd_flags))
	return -1;

      PRIV (dst_section) = section;
      abfd->flags |= (HAS_DEBUG | HAS_LINENO);
    }

  if (dmtvbn)
    {
      flagword bfd_flags = SEC_HAS_CONTENTS | SEC_DEBUGGING;

      section = bfd_make_section (abfd, "$DMT$");
      if (!section)
	return -1;

      section->size = dmtbytes;
      section->filepos = VMS_BLOCK_SIZE * (dmtvbn - 1);

      if (!bfd_set_section_flags (abfd, section, bfd_flags))
	return -1;
    }

  if (gstvbn)
    {
      flagword bfd_flags = SEC_HAS_CONTENTS;

      section = bfd_make_section (abfd, "$GST$");
      if (!section)
	return -1;

      if (bfd_seek (abfd, VMS_BLOCK_SIZE * (gstvbn - 1), SEEK_SET))
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return -1;
	}

      if (_bfd_vms_slurp_object_records (abfd) != 0)
	return -1;

      section->filepos = VMS_BLOCK_SIZE * (gstvbn - 1);
      section->size = bfd_tell (abfd) - section->filepos;

      if (!bfd_set_section_flags (abfd, section, bfd_flags))
	return -1;

      abfd->flags |= HAS_SYMS;
    }

  return 0;
}

/* Build a new module for the specified BFD.  */

static struct module *
new_module (bfd *abfd)
{
  struct module *module
    = (struct module *) bfd_zalloc (abfd, sizeof (struct module));
  module->file_table_count = 16; /* Arbitrary.  */
  module->file_table
    = bfd_malloc (module->file_table_count * sizeof (struct fileinfo));
  return module;
}

/* Parse debug info for a module and internalize it.  */

static void
parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
	      unsigned int length)
{
  unsigned char *maxptr = ptr + length, *src_ptr, *pcl_ptr;
  unsigned int prev_linum = 0, curr_linenum = 0;
  bfd_vma prev_pc = 0, curr_pc = 0;
  struct srecinfo *curr_srec, *srec;
  struct lineinfo *curr_line, *line;
  struct funcinfo *funcinfo;

  /* Initialize tables with zero element.  */
  curr_srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
  module->srec_table = curr_srec;

  curr_line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
  module->line_table = curr_line;

  while (ptr < maxptr)
    {
      /* The first byte is not counted in the recorded length.  */
      int rec_length = bfd_getl16 (ptr) + 1;
      int rec_type = bfd_getl16 (ptr + 2);

#if VMS_DEBUG
      _bfd_vms_debug (2, "DST record: length %d, type %d\n",
		      rec_length, rec_type);
#endif

      switch (rec_type)
	{
	case DST_S_C_MODBEG:
	  module->name
	    = _bfd_vms_save_counted_string (ptr + DST_S_B_MODBEG_NAME);

	  curr_pc = 0;
	  prev_pc = 0;
	  curr_linenum = 0;
	  prev_linum = 0;

#if VMS_DEBUG
          _bfd_vms_debug (3, "module: %s\n", module->name);
#endif
	  break;

	case DST_S_C_MODEND:
#if VMS_DEBUG
          _bfd_vms_debug (3, "end module\n");
#endif
	  break;

	case DST_S_C_RTNBEG:
	  funcinfo = (struct funcinfo *)
	    bfd_zalloc (abfd, sizeof (struct funcinfo));
          funcinfo->name
	    = _bfd_vms_save_counted_string (ptr + DST_S_B_RTNBEG_NAME);
	  funcinfo->low = bfd_getl32 (ptr + DST_S_L_RTNBEG_ADDRESS);
	  funcinfo->next = module->func_table;
	  module->func_table = funcinfo;
    
#if VMS_DEBUG
          _bfd_vms_debug (3, "routine: %s at 0x%x\n",
			  funcinfo->name, funcinfo->low);
#endif
	  break;

	case DST_S_C_RTNEND:
	  module->func_table->high = module->func_table->low
	    + bfd_getl32 (ptr + DST_S_L_RTNEND_SIZE) - 1;

	  if (module->func_table->high > module->high)
	    module->high = module->func_table->high;

#if VMS_DEBUG
          _bfd_vms_debug (3, "end routine\n");
#endif
	  break;

	case DST_S_C_PROLOG:
#if VMS_DEBUG
          _bfd_vms_debug (3, "prologue\n");
#endif
	  break;

	case DST_S_C_EPILOG:
#if VMS_DEBUG
          _bfd_vms_debug (3, "epilog\n");
#endif
	  break;

	case DST_S_C_BLKBEG:
#if VMS_DEBUG
          _bfd_vms_debug (3, "block\n");
#endif
	  break;

	case DST_S_C_BLKEND:
#if VMS_DEBUG
          _bfd_vms_debug (3, "end block\n");
#endif
	  break;

	case DST_S_C_SOURCE:
	  src_ptr = ptr + DST_S_C_SOURCE_HEADER_SIZE;

#if VMS_DEBUG
	  _bfd_vms_debug (3, "source info\n");
#endif

	  while (src_ptr < ptr + rec_length)
	    {
	      int cmd = src_ptr[0], cmd_length, data;

	      switch (cmd)
		{
		case DST_S_C_SRC_DECLFILE:
		  {
		    unsigned int fileid
		      = bfd_getl16 (src_ptr + DST_S_W_SRC_DF_FILEID);
		    char *filename
		      = _bfd_vms_save_counted_string (src_ptr
			  + DST_S_B_SRC_DF_FILENAME);

		    while (fileid >= module->file_table_count)
		      {
			module->file_table_count *= 2;
			module->file_table
			  = bfd_realloc (module->file_table,
					 module->file_table_count
					   * sizeof (struct fileinfo));
		      }

		    module->file_table [fileid].name = filename;
		    module->file_table [fileid].srec = 1;
		    cmd_length = src_ptr[DST_S_B_SRC_DF_LENGTH] + 2;
#if VMS_DEBUG
		    _bfd_vms_debug (4, "DST_S_C_SRC_DECLFILE: %d, %s\n",
				    fileid,
				    module->file_table [fileid].name);
#endif
		  }
		  break;

		case DST_S_C_SRC_DEFLINES_B:
		  /* Perform the association and set the next higher index
		     to the limit.  */
		  data = src_ptr[DST_S_B_SRC_UNSBYTE];
		  srec = (struct srecinfo *)
		    bfd_zalloc (abfd, sizeof (struct srecinfo));
		  srec->line = curr_srec->line + data;
		  srec->srec = curr_srec->srec + data;
		  srec->sfile = curr_srec->sfile;
		  curr_srec->next = srec;
		  curr_srec = srec;
		  cmd_length = 2;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_DEFLINES_B: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_DEFLINES_W:
		  /* Perform the association and set the next higher index
		     to the limit.  */
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  srec = (struct srecinfo *)
		    bfd_zalloc (abfd, sizeof (struct srecinfo));
		  srec->line = curr_srec->line + data;
		  srec->srec = curr_srec->srec + data,
		  srec->sfile = curr_srec->sfile;
		  curr_srec->next = srec;
		  curr_srec = srec;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_DEFLINES_W: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_INCRLNUM_B:
		  data = src_ptr[DST_S_B_SRC_UNSBYTE];
		  curr_srec->line += data;
		  cmd_length = 2;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_INCRLNUM_B: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_SETFILE:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->sfile = data;
		  curr_srec->srec = module->file_table[data].srec;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_SETFILE: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_SETLNUM_L:
		  data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
		  curr_srec->line = data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_SETLNUM_L: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_SETLNUM_W:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->line = data;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_SETLNUM_W: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_SETREC_L:
		  data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
		  curr_srec->srec = data;
		  module->file_table[curr_srec->sfile].srec = data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_SETREC_L: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_SETREC_W:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->srec = data;
		  module->file_table[curr_srec->sfile].srec = data;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_SETREC_W: %d\n", data);
#endif
		  break;

		case DST_S_C_SRC_FORMFEED:
		  cmd_length = 1;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SRC_FORMFEED\n");
#endif
		  break;

		default:
		  (*_bfd_error_handler) (_("unknown source command %d"),
					 cmd);
		  cmd_length = 2;
		  break;
		}

	      src_ptr += cmd_length;
	    }
	  break;

	case DST_S_C_LINE_NUM:
	  pcl_ptr = ptr + DST_S_C_LINE_NUM_HEADER_SIZE;

#if VMS_DEBUG
	  _bfd_vms_debug (3, "line info\n");
#endif

	  while (pcl_ptr < ptr + rec_length)
	    {
	      /* The command byte is signed so we must sign-extend it.  */
	      int cmd = ((signed char *)pcl_ptr)[0], cmd_length, data;

	      switch (cmd)
		{
		case DST_S_C_DELTA_PC_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_pc += data;
		  curr_linenum += 1;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_DELTA_PC_W: %d\n", data);
#endif
		  break;

		case DST_S_C_DELTA_PC_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc += data;
		  curr_linenum += 1;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_DELTA_PC_L: %d\n", data);
#endif
		  break;

		case DST_S_C_INCR_LINUM:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_linenum += data;
		  cmd_length = 2;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_INCR_LINUM: %d\n", data);
#endif
		  break;

		case DST_S_C_INCR_LINUM_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_linenum += data;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_INCR_LINUM_W: %d\n", data);
#endif
		  break;

		case DST_S_C_INCR_LINUM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_linenum += data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_INCR_LINUM_L: %d\n", data);
#endif
		  break;

		case DST_S_C_SET_LINUM_INCR:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_LINUM_INCR not implemented"));
		  cmd_length = 2;
		  break;

		case DST_S_C_SET_LINUM_INCR_W:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_LINUM_INCR_W not implemented"));
		  cmd_length = 3;
		  break;

		case DST_S_C_RESET_LINUM_INCR:
		  (*_bfd_error_handler)
		    (_("DST_S_C_RESET_LINUM_INCR not implemented"));
		  cmd_length = 1;
		  break;

		case DST_S_C_BEG_STMT_MODE:
		  (*_bfd_error_handler)
		    (_("DST_S_C_BEG_STMT_MODE not implemented"));
		  cmd_length = 1;
		  break;

		case DST_S_C_END_STMT_MODE:
		  (*_bfd_error_handler)
		    (_("DST_S_C_END_STMT_MODE not implemented"));
		  cmd_length = 1;
		  break;

		case DST_S_C_SET_LINUM_B:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_linenum = data;
		  cmd_length = 2;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SET_LINUM_B: %d\n", data);
#endif
		  break;
	
		case DST_S_C_SET_LINE_NUM:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_linenum = data;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SET_LINE_NUM: %d\n", data);
#endif
		  break;

		case DST_S_C_SET_LINUM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_linenum = data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SET_LINUM_L: %d\n", data);
#endif
		  break;

		case DST_S_C_SET_PC:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_PC not implemented"));
		  cmd_length = 2;
		  break;

		case DST_S_C_SET_PC_W:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_PC_W not implemented"));
		  cmd_length = 3;
		  break;

		case DST_S_C_SET_PC_L:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_PC_L not implemented"));
		  cmd_length = 5;
		  break;

		case DST_S_C_SET_STMTNUM:
		  (*_bfd_error_handler)
		    (_("DST_S_C_SET_STMTNUM not implemented"));
		  cmd_length = 2;
		  break;

		case DST_S_C_TERM:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_pc += data;
		  cmd_length = 2;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_TERM: %d\n", data);
#endif
		  break;

		case DST_S_C_TERM_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_pc += data;
		  cmd_length = 3;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_TERM_W: %d\n", data);
#endif
		  break;

		case DST_S_C_TERM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc += data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_TERM_L: %d\n", data);
#endif
		  break;

		case DST_S_C_SET_ABS_PC:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc = data;
		  cmd_length = 5;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "DST_S_C_SET_ABS_PC: 0x%x\n", data);
#endif
		  break;

		default:
		  if (cmd <= 0)
		    {
		      curr_pc -= cmd;
		      curr_linenum += 1;
		      cmd_length = 1;
#if VMS_DEBUG
		      _bfd_vms_debug (4, "bump pc to 0x%llx and line to %d\n",
				      curr_pc, curr_linenum);
#endif
		    }
		  else
		    {
		      (*_bfd_error_handler) (_("unknown line command %d"),
					     cmd);
		      cmd_length = 2;
		    }
		  break;
		}

	      if ((curr_linenum != prev_linum && curr_pc != prev_pc)
		  || cmd <= 0
		  || cmd == DST_S_C_DELTA_PC_L
		  || cmd == DST_S_C_DELTA_PC_W)
		{
		  line = (struct lineinfo *)
		    bfd_zalloc (abfd, sizeof (struct lineinfo));
		  line->address = curr_pc;
		  line->line = curr_linenum;

		  curr_line->next = line;
		  curr_line = line;

		  prev_linum = curr_linenum;
		  prev_pc = curr_pc;
#if VMS_DEBUG
		  _bfd_vms_debug (4, "-> correlate pc 0x%llx with line %d\n",
				  curr_pc, curr_linenum);
#endif
		}

	      pcl_ptr += cmd_length;
	    }
	  break;

	case 0x17: /* Undocumented type used by DEC C to declare equates.  */
#if VMS_DEBUG
	  _bfd_vms_debug (3, "undocumented type 0x17\n");
#endif
	  break;

	default:
#if VMS_DEBUG
	  _bfd_vms_debug (3, "ignoring record\n");
#endif
	  break;

	}

      ptr += rec_length;
    }

  /* Finalize tables with EOL marker.  */
  srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
  srec->line = (unsigned int) -1;
  srec->srec = (unsigned int) -1;
  curr_srec->next = srec;

  line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
  line->line = (unsigned int) -1;
  line->address = (bfd_vma) -1;
  curr_line->next = line;

  /* Advertise that this module has been parsed.  This is needed
     because parsing can be either performed at module creation
     or deferred until debug info is consumed.  */
  SET_MODULE_PARSED (module);
}

/* Build the list of modules for the specified BFD.  */

static struct module *
build_module_list (bfd *abfd)
{
  struct module *module, *list = NULL;
  asection *dmt;

  if ((dmt = bfd_get_section_by_name (abfd, "$DMT$")))
    {
      /* We have a DMT section so this must be an image.  Parse the
	 section and build the list of modules.  This is sufficient
	 since we can compute the start address and the end address
	 of every module from the section contents.  */
      bfd_size_type size = bfd_get_section_size (dmt);
      unsigned char *ptr, *end;

      ptr = (unsigned char *) bfd_alloc (abfd, size);
      if (! ptr)
	return NULL;

      if (! bfd_get_section_contents (abfd, dmt, ptr, 0, size))
	return NULL;

#if VMS_DEBUG
      _bfd_vms_debug (2, "DMT\n");
#endif

      end = ptr + size;

      while (ptr < end)
	{
	  /* Each header declares a module with its start offset and size
	     of debug info in the DST section, as well as the count of
	     program sections (i.e. address spans) it contains.  */
	  int modbeg = bfd_getl32 (ptr + DBG_S_L_DMT_MODBEG);
	  int msize = bfd_getl32 (ptr + DBG_S_L_DST_SIZE);
	  int count = bfd_getl16 (ptr + DBG_S_W_DMT_PSECT_COUNT);
	  ptr += DBG_S_C_DMT_HEADER_SIZE;

#if VMS_DEBUG
	  _bfd_vms_debug (3, "module: modbeg = %d, size = %d, count = %d\n",
			  modbeg, msize, count);
#endif

	  /* We create a 'module' structure for each program section since
	     we only support contiguous addresses in a 'module' structure.
	     As a consequence, the actual debug info in the DST section is
	     shared and can be parsed multiple times; that doesn't seem to
	     cause problems in practice.  */
	  while (count-- > 0)
	    {
	      int start = bfd_getl32 (ptr + DBG_S_L_DMT_PSECT_START);
	      int length = bfd_getl32 (ptr + DBG_S_L_DMT_PSECT_LENGTH);
	      module = new_module (abfd);
	      module->modbeg = modbeg;
	      module->size = msize;
	      module->low = start;
	      module->high = start + length;
	      module->next = list;
	      list = module;
	      ptr += DBG_S_C_DMT_PSECT_SIZE;

#if VMS_DEBUG
	      _bfd_vms_debug (4, "section: start = 0x%x, length = %d\n",
			      start, length);
#endif
	    }
	}
    }
  else
    {
      /* We don't have a DMT section so this must be an object.  Parse
	 the module right now in order to compute its start address and
	 end address.  */
      module = new_module (abfd);
      parse_module (abfd, module, PRIV (dst_section)->contents,
		    PRIV (dst_ptr_end) - PRIV (dst_section)->contents);
      list = module;
    }

  return list;
}

/* Calculate and return the name of the source file and the line nearest
   to the wanted location in the specified module.  */

static bfd_boolean
module_find_nearest_line (bfd *abfd, struct module *module, bfd_vma addr,
			  const char **file, const char **func, 
			  unsigned int *line)
{
  struct funcinfo *funcinfo;
  struct lineinfo *lineinfo;
  struct srecinfo *srecinfo;
  bfd_boolean ret = FALSE;

  /* Parse this module if that was not done at module creation.  */
  if (! IS_MODULE_PARSED (module))
    {
      unsigned int size = module->size;
      unsigned int modbeg = PRIV (dst_section)->filepos + module->modbeg;
      unsigned char *buffer = (unsigned char *) bfd_malloc (module->size);

      if (bfd_seek (abfd, modbeg, SEEK_SET) != 0
	  || bfd_bread (buffer, size, abfd) != size)
	{
	  bfd_set_error (bfd_error_no_debug_section);
	  return FALSE;
	}

      parse_module (abfd, module, buffer, size);
      free (buffer);
    }

  /* Find out the function (if any) that contains the address.  */
  for (funcinfo = module->func_table; funcinfo; funcinfo = funcinfo->next)
    if (addr >= funcinfo->low && addr <= funcinfo->high)
      {
        *func = funcinfo->name;
	ret = TRUE;
	break;
      }

  /* Find out the source file and the line nearest to the address.  */
  for (lineinfo = module->line_table; lineinfo; lineinfo = lineinfo->next)
    if (lineinfo->next && addr < lineinfo->next->address)
      {
	for (srecinfo = module->srec_table; srecinfo; srecinfo = srecinfo->next)
	  if (srecinfo->next && lineinfo->line < srecinfo->next->line)
	    {
	      if (srecinfo->sfile > 0)
		{
		  *file = module->file_table[srecinfo->sfile].name;
		  *line = srecinfo->srec + lineinfo->line - srecinfo->line;
		}
	      else
		{
		  *file = module->name;
		  *line = lineinfo->line;
		}
	      return TRUE;
	    }

	break;
      }

  return ret;
}

/* Provided a BFD, a section and an offset into the section, calculate and
   return the name of the source file and the line nearest to the wanted
   location.  */

bfd_boolean
_bfd_vms_find_nearest_dst_line (bfd *abfd, asection *section,
				asymbol **symbols ATTRIBUTE_UNUSED,
				bfd_vma offset, const char **file,
				const char **func, unsigned int *line)
{
  struct module *module;

  /* What address are we looking for?  */
  bfd_vma addr = section->vma + offset;

  *file = NULL;
  *func = NULL;
  *line = 0;

  if (PRIV (dst_section) == NULL)
    return FALSE;

  if (PRIV (modules) == NULL)
    {
      PRIV (modules) = build_module_list (abfd);
      if (PRIV (modules) == NULL)
        return FALSE;
    }

  for (module = PRIV (modules); module; module = module->next)
    if (addr >= module->low && addr <= module->high)
      return module_find_nearest_line (abfd, module, addr, file, func, line);

  return FALSE;
}

/* Process EDBG/ETBT record.
   Return 0 on success, -1 on error  */

static int
vms_slurp_debug (bfd *abfd)
{
  if (PRIV (dst_section) == NULL)
    {
      /* We have no way to find out beforehand how much debug info there
	 is in an object file, so pick an initial amount and grow it as
	 needed later.  */
      flagword flags = SEC_HAS_CONTENTS | SEC_DEBUGGING | SEC_RELOC;
      asection *section = bfd_make_section (abfd, "$DST$");
      if (!section)
	return -1;
      section->size = 1024;
      if (!bfd_set_section_flags (abfd, section, flags))
	return -1;
      section->contents = ((unsigned char *)
			   bfd_zmalloc (section->size));
      if (section->contents == NULL)
	return -1;
      section->filepos = (unsigned int)-1;
      PRIV (dst_section) = section;
    }

  PRIV (image_section) = PRIV (dst_section);
  PRIV (image_ptr) = PRIV (dst_section)->contents;
 
  return _bfd_vms_slurp_tir (abfd, EOBJ_S_C_ETIR);
}

/* Process DBG/EDBG record.
   Return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_dbg (bfd *abfd, int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "DBG/EDBG\n");
#endif

  abfd->flags |= (HAS_DEBUG | HAS_LINENO);

  return vms_slurp_debug (abfd);
}

/* Process TBT/ETBT record.
   Return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_tbt (bfd *abfd, int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "TBT/ETBT\n");
#endif

  abfd->flags |= HAS_LINENO;

  return vms_slurp_debug (abfd);
}

/* Write DBG/EDBG record.  */

int
_bfd_vms_write_dbg (bfd *abfd ATTRIBUTE_UNUSED, int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_dbg (%p, %d)\n", abfd, objtype);
#endif

  return 0;
}

/* Write TBT/ETBT record.  */

int
_bfd_vms_write_tbt (bfd *abfd ATTRIBUTE_UNUSED, int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_tbt (%p, %d)\n", abfd, objtype);
#endif

  return 0;
}
@


1.28
log
@2010-04-01  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Include time.h. Add prototypes for vms_get_module_name,
	vms_time_to_time_t and vms_rawtime_to_time_t.
	* vms.c (vms_alpha_vec): Add archives support.
	* vms-misc.c: Include safe-ctype.h
	(vms_get_module_name): New function.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	* vms-hdr.c (_bfd_vms_write_hdr): Put module name creation to the
	vms_get_module_name function.  Use this function.
	* targets.c: Declare vms_lib_txt_vec.  Add it to _bfd_target_vector.
	* libbfd-in.h: Add prototype for _bfd_append_relative_path.
	Add prototypes for vms-lib.c
	* libbfd.h: Regenerate.
	* configure.in (TDEFINES): Add an entry for vms_lib_txt_vec.  Add
	vms-lib.lo to vms_alpha_vec.
	* config.bfd (targ_cpu): Add targ_selvecs for alpha*-*-*vms*.
	* configure: Regenerate.
	* bfd.c: Add selective_search field.
	* bfd-in2.h: Regenerate.
	* archive.c (append_relative_path): Rename to
	_bfd_append_relative_path and make it public.
	(_bfd_get_elt_at_filepos): Adjust for above renaming.
	* Makefile.am (BFD32_BACKENDS): Add vms-lib.lo
	(BFD32_BACKENDS_CFILES): Add vms-lib.c
	* Makefile.in: Regenerate.
@
text
@@


1.27
log
@2010-01-27  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Remove trailing spaces.
	(struct hdr_struct): Remove unused hdr_c_cpr field.
	(enum file_format_enum): Add comments.
	* vms.c (vms_bfd_print_private_bfd_data): New function that
	replaces the macro.
	Remove trailing spaces.
	* vms-misc.c: Improve comments.
	(_bfd_vms_get_object_record): Also handle files without pads.
	* vms-hdr.c (_bfd_vms_write_dbg): Fix format string.
	* vms-gsd.c (struct flagdescstruct): Make name field const.
	(gsyflagdesc): Fix typo.
@
text
@d240 3
a242 37
      /* Strip path and suffix information.  */
      char *fname, *fout, *fptr;

      fptr = bfd_get_filename (abfd);
      fname = strdup (fptr);

      /* Strip VMS path.  */
      fout = strrchr (fname, ']');
      if (fout == NULL)
	fout = strchr (fname, ':');
      if (fout != NULL)
	fout++;
      else
	fout = fname;

      /* Strip UNIX path.  */
      fptr = strrchr (fout, '/');
      if (fptr != NULL)
	fout = fptr + 1;

      /* Strip suffix.  */
      fptr = strrchr (fout, '.');
      if (fptr != 0)
	*fptr = 0;

      /* Convert to upper case and truncate at 31 characters.
         (VMS object file format restricts module name length to 31).  */
      fptr = fout;
      while (*fptr != 0)
	{
	  *fptr = TOUPPER (*fptr);
	  fptr++;
	  if (*fptr == ';' || (fptr - fout) >= 31)
	    *fptr = 0;
	}
      _bfd_vms_output_counted (abfd, fout);
      free (fname);
@


1.26
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1400 1
a1400 1
  _bfd_vms_debug (2, "vms_write_dbg (%p, objtype)\n", abfd, objtype);
@


1.25
log
@2009-11-24  Tristan Gingold  <gingold@@adacore.com>

	* vms-hdr.c (_bfd_vms_write_hdr): Strip any suffix to create module
	name.
	* vms.h (vms_debug2): Add vms_debug2.
	* vms.c (vms_archive_p): Remove
	(vms_bfd_free_cached_info): Remove the function, use libbfd.h macro
	instead.
	(vms_get_section_contents_in_window): Ditto.
	(vms_bfd_copy_private_bfd_data): Ditto.
	(vms_bfd_copy_private_section_data): Ditto.
	(vms_bfd_copy_private_symbol_data): Ditto.
	(vms_bfd_print_private_bfd_data): Ditto.
	(vms_bfd_set_private_flags): Ditto.
	(vms_bfd_merge_private_bfd_data): Ditto.
	(vms_read_minisymbols): Ditto.
	(vms_minisymbol_to_symbol): Ditto.
	(vms_get_lineno): Ditto.
	(vms_find_nearest_line): Ditto.
	(vms_bfd_make_debug_symbol): Ditto.
	(vms_core_file_failing_command): Remove.
	(vms_core_file_failing_signal): Remove.
	(vms_core_file_matches_executable_p): Remove.
	(vms_slurp_armap): Remove.
	(vms_slurp_extended_name_table): Remove.
	(vms_construct_extended_name_table): Remove.
	(vms_truncate_arname): Remove.
	(vms_write_armap): Remove.
	(vms_read_ar_hdr): Remove.
	(vms_get_elt_at_index): Remove.
	(vms_openr_next_archived_file): Remove.
	(vms_update_armap_timestamp): Remove.
	(vms_generic_stat_arch_elt): Remove.
	(vms_get_symtab_upper_bound): Remove.
	(vms_sizeof_headers): Remove.
	(vms_bfd_get_relocated_section_contents): Remove.
	(vms_bfd_relax_section): Remove.
	(vms_bfd_gc_sections): Remove.
	(vms_bfd_merge_sections): Remove.
	(vms_bfd_link_hash_table_create): Remove.
	(vms_bfd_link_hash_table_free): Remove.
	(vms_bfd_link_add_symbols): Remove.
	(vms_bfd_final_link): Remove.
	(vms_bfd_link_split_section): Remove.
	(vms_get_dynamic_symtab_upper_bound): Remove.
	(vms_canonicalize_dynamic_symtab): Remove.
	(vms_get_dynamic_reloc_upper_bound): Remove.
	(vms_canonicalize_dynamic_reloc): Remove.
	(fill_section_ptr): Use vms_debug2 instead of vms_debug.
	(_bfd_vms_slurp_object_records): Ditto.
	(vms_object_p): Ditto.
	(vms_mkobject): Ditto.
	(vms_write_object_contents): Ditto.
	(vms_close_and_cleanup): Ditto.
	(vms_new_section_hook): Ditto.
	(vms_get_section_contents): Ditto.
	(vms_get_symtab_upper_bound): Ditto.
	(vms_canonicalize_symtab): Ditto.
	(vms_print_symbol): Ditto.
	(vms_get_symbol_info): Ditto.
	(vms_bfd_is_local_label_name): Ditto.
	(vms_find_nearest_line): Ditto.
	(vms_slurp_reloc_table): Ditto.
	(vms_bfd_reloc_type_lookup): Ditto.
	(vms_set_arch_mach): Ditto.
	(vms_alpha_vec, vms_vax_vec): Use _bfd_nocore, _bfd_noarchive,
	_bfd_nolink and _bfd_nodynamic methods instead of vms stubs.
@
text
@d1182 1
a1182 1
	  int size = bfd_getl32 (ptr + DBG_S_L_DST_SIZE);
d1188 1
a1188 1
			  modbeg, size, count);
d1202 1
a1202 1
	      module->size = size;
@


1.24
log
@bfd/
	* vms-hdr.c: Don't include alloca.h.
opcodes/
	* cgen-opc.c: Include alloca-conf.h rather than alloca.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d237 1
d260 1
a260 1
      /* Strip .obj suffix.  */
d262 1
a262 1
      if (fptr != 0 && strcasecmp (fptr, ".OBJ") == 0)
@


1.23
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@a54 4
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif

@


1.22
log
@bfd/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* configure.com: Handle bfd_default_target_size, BFD_HOST_LONG_LONG,
	BFD_HOST_64BIT_LONG_LONG, BFD_HOSTPTR_T, bfd_file_ptr.
	Generate bfdver.h.
	* vms-hdr.c (_bfd_vms_write_hdr): Use strdup/free instead of alloca.
	* hosts/alphavms.h: Defines macros to bypass i18n.
	* makefile.vms (OBJS): Update file list.
	(DEFS): Remove VMS_DEBUG, const, add DEBUGDIR.
	(CFLAGS): Update flags.
	* bfdio.c (real_fopen): Add code specific to VMS: extract attributes
	from modes.

binutils/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* configure.com: Get version from configure.in of bfd.
	* makefile.vms-in (DEBUG_OBJS): Add dwarf.obj.
	(CFLAGS): Update flags.

include/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* fopen-vms.h (FOPEN_RB): Use a single string to match the
	standard prototype.
	(FOPEN_WB): Ditto.
	(FOPEN_AB): Ditto.
	(FOPEN_RUB): Ditto.
	(FOPEN_WUB): Ditto.
	(FOPEN_AUB): Ditto.

libiberty/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms (OBJS): Update objects list.
	(CFLAGS): Update.
	(libiberty.olb): Remove alloca-conf.h dependency.
	* config.h-vms: Use new macro sets, use builtin alloca.

opcodes/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms (OBJS): Update list of objects.
	(DEFS): Update
	(CFLAGS): Update.
@
text
@d4 1
a4 1
   2007 Free Software Foundation, Inc.
d8 1
a8 1
   and
d12 17
d59 14
d119 1
a119 1
      PRIV (hdr_data).hdr_c_lnm = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 2));
d123 1
a123 1
      PRIV (hdr_data).hdr_c_src = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 2));
d127 1
a127 1
      PRIV (hdr_data).hdr_c_ttl = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 2));
d144 1
a144 1
      PRIV (hdr_data).hdr_c_lnm = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 6));
d148 1
a148 1
      PRIV (hdr_data).hdr_c_src = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 6));
d152 1
a152 1
      PRIV (hdr_data).hdr_c_ttl = _bfd_vms_save_sized_string (vms_rec, PRIV (rec_length - 6));
d223 1
d248 2
d251 1
a251 1
      if (fout == 0)
d253 1
a253 1
      if (fout != 0)
d258 5
d264 2
a265 3
      fptr = strrchr (fname, '.');
      if ((fptr != 0)
	  && (strcasecmp (fptr, ".OBJ") == 0))
d268 2
d275 1
a275 2
	  if ((*fptr == ';')
	     || ((fptr - fout) > 31))
d285 2
a286 2
  _bfd_vms_output_dump (abfd, get_vms_time_string (), 17);
  _bfd_vms_output_fill (abfd, 0, 17);
d291 2
a292 1
  _bfd_vms_output_dump (abfd, (unsigned char *) STRING_COMMA_LEN ("GAS proGIS"));
d363 4
a366 4
      PRIV (eom_data).eom_l_total_lps = bfd_getl32 (vms_rec + 4);
      PRIV (eom_data).eom_b_comcod = *(vms_rec + 8);

      if (PRIV (eom_data).eom_b_comcod > 1)
d376 5
a380 3
	   PRIV (eom_data).eom_b_tfrflg = *(vms_rec + 9);
	   PRIV (eom_data).eom_l_psindx = bfd_getl32 (vms_rec + 12);
	   PRIV (eom_data).eom_l_tfradr = bfd_getl32 (vms_rec + 16);
d422 998
@


1.21
log
@Switch sources over to use the GPL version 3
@
text
@d215 1
a215 2
      fname = alloca (strlen (fptr) + 1);
      strcpy (fname, fptr);
d240 1
@


1.20
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d16 1
a16 1
   the Free Software Foundation; either version 2 of the License, or
d26 2
a27 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.19
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
   Free Software Foundation, Inc.
d28 1
a30 1
#include "sysdep.h"
@


1.18
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
d251 1
a251 1
  _bfd_vms_output_dump (abfd, (unsigned char *)"GAS proGIS", 10);
d263 1
a263 1
	  if (strncmp ((char *)symbol->name, "<CASE:", 6) == 0)
d283 1
a283 1
    _bfd_vms_output_dump (abfd, (unsigned char *)"noname", 6);
d289 1
a289 1
  _bfd_vms_output_dump (abfd, (unsigned char *)"TTL", 3);
@


1.17
log
@Update the FSF address in the copyright/GPL notice
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.16
log
@Update to ISO-C90 and fix formatting
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.15
log
@update copyright dates
@
text
@d14 13
a26 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a40 5
static unsigned char *get_vms_time_string PARAMS ((void));


/*---------------------------------------------------------------------------*/

d42 1
a42 1
   return 0 on success, -1 on error  */
d45 1
a45 3
_bfd_vms_slurp_hdr (abfd, objtype)
     bfd *abfd;
     int objtype;
d59 8
a66 8
      case OBJ_S_C_HDR:
	subtype = vms_rec[1];
	break;
      case EOBJ_S_C_EMH:
	subtype = bfd_getl16 (vms_rec + 4) + EVAX_OFFSET;
	break;
      default:
	subtype = -1;
d75 9
a83 46

      case MHD_S_C_MHD:
	/*
	 * module header
	 */
	PRIV(hdr_data).hdr_b_strlvl = vms_rec[2];
	PRIV(hdr_data).hdr_l_recsiz = bfd_getl16 (vms_rec + 3);
	PRIV(hdr_data).hdr_t_name = _bfd_vms_save_counted_string (vms_rec + 5);
	ptr = vms_rec + 5 + vms_rec[5] + 1;
	PRIV(hdr_data).hdr_t_version = _bfd_vms_save_counted_string (ptr);
	ptr += *ptr + 1;
	PRIV(hdr_data).hdr_t_date = _bfd_vms_save_sized_string (ptr, 17);

      break;

      case MHD_S_C_LNM:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_lnm = _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-2));
      break;

      case MHD_S_C_SRC:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_src = _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-2));
      break;

      case MHD_S_C_TTL:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_ttl = _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-2));
      break;

      case MHD_S_C_CPR:
	/*
	 *
	 */
      break;

      case MHD_S_C_MTC:
	/*
	 *
	 */
d86 2
a87 4
      case MHD_S_C_GTX:
	/*
	 *
	 */
d90 2
a91 17
      case EMH_S_C_MHD + EVAX_OFFSET:
	/*
	 * module header
	 */
	PRIV(hdr_data).hdr_b_strlvl = vms_rec[6];
	PRIV(hdr_data).hdr_l_arch1 = bfd_getl32 (vms_rec + 8);
	PRIV(hdr_data).hdr_l_arch2 = bfd_getl32 (vms_rec + 12);
	PRIV(hdr_data).hdr_l_recsiz = bfd_getl32 (vms_rec + 16);
	PRIV(hdr_data).hdr_t_name =
	  _bfd_vms_save_counted_string (vms_rec + 20);
	ptr = vms_rec + 20 + vms_rec[20] + 1;
	PRIV(hdr_data).hdr_t_version =
	  _bfd_vms_save_counted_string (ptr);
	ptr += *ptr + 1;
	PRIV(hdr_data).hdr_t_date =
	  _bfd_vms_save_sized_string (ptr, 17);

d94 2
a95 6
      case EMH_S_C_LNM + EVAX_OFFSET:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_lnm =
	  _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-6));
d98 11
a108 6
      case EMH_S_C_SRC + EVAX_OFFSET:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_src =
	  _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-6));
d111 2
a112 6
      case EMH_S_C_TTL + EVAX_OFFSET:
	/*
	 *
	 */
	PRIV(hdr_data).hdr_c_ttl =
	  _bfd_vms_save_sized_string (vms_rec, PRIV(rec_length-6));
d115 2
a116 4
      case EMH_S_C_CPR + EVAX_OFFSET:
	/*
	 *
	 */
d119 2
a120 4
      case EMH_S_C_MTC + EVAX_OFFSET:
	/*
	 *
	 */
d123 6
a128 4
      case EMH_S_C_GTX + EVAX_OFFSET:
	/*
	 *
	 */
d131 2
a132 2
      default:
	bfd_set_error (bfd_error_wrong_format);
d134 1
a134 2

    } /* switch */
a138 1
/*-----------------------------------------------------------------------------*/
d142 1
a142 1
   stolen from obj-vms.c  */
d145 1
a145 1
get_vms_time_string ()
d153 2
a154 1
  time (&timeb);
d182 1
a182 1
/* write object header for bfd abfd  */
d185 1
a185 3
_bfd_vms_write_hdr (abfd, objtype)
     bfd *abfd;
     int objtype;
d198 2
a199 6
  /* MHD */

  if (objtype == OBJ_S_C_HDR)
    {
    }
  else
d210 1
a210 2
      /* strip path and suffix information */

d214 1
a214 1
      fname = (char *) alloca (strlen (fptr) + 1);
d224 1
a224 2
      /* strip .obj suffix  */

d249 1
a249 2
  /* LMN */

d254 1
a254 2
  /* SRC */

d265 2
a266 2
	      PRIV(flag_hash_long_names) = symbol->name[6] - '0';
	      PRIV(flag_show_after_trunc) = symbol->name[7] - '0';
d287 1
a287 2
  /* TTL */

d292 1
a292 2
  /* CPR */

a301 2
/*-----------------------------------------------------------------------------*/

d303 1
a303 1
   return 0 on success, -1 on error  */
d306 1
a306 3
_bfd_vms_slurp_eom (abfd, objtype)
     bfd *abfd;
     int objtype;
d314 1
a314 1
  vms_rec = PRIV(vms_rec);
d322 4
a325 3
      PRIV(eom_data).eom_l_total_lps = bfd_getl32 (vms_rec + 4);
      PRIV(eom_data).eom_b_comcod = *(vms_rec + 8);
      if (PRIV(eom_data).eom_b_comcod > 1)
d331 2
a332 2
      PRIV(eom_data).eom_has_transfer = FALSE;
      if (PRIV(rec_size) > 10)
d334 4
a337 4
	   PRIV(eom_data).eom_has_transfer = TRUE;
	   PRIV(eom_data).eom_b_tfrflg = *(vms_rec + 9);
	   PRIV(eom_data).eom_l_psindx = bfd_getl32 (vms_rec + 12);
	   PRIV(eom_data).eom_l_tfradr = bfd_getl32 (vms_rec + 16);
d339 1
a339 1
	   abfd->start_address = PRIV(eom_data).eom_l_tfradr;
d345 1
a345 1
/* Write eom record for bfd abfd  */
d348 1
a348 3
_bfd_vms_write_eom (abfd, objtype)
     bfd *abfd;
     int objtype;
d355 3
a357 3
  _bfd_vms_output_long (abfd, (unsigned long) (PRIV(vms_linkage_index) >> 1));
  _bfd_vms_output_byte (abfd, 0);	/* completion code */
  _bfd_vms_output_byte (abfd, 0);	/* fill byte */
@


1.14
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2005
@


1.13
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d228 2
a229 1
  sprintf (tbuf, "%2s-%3s-%s %s", pnt + 8, pnt + 4, pnt + 20, pnt + 11);
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d209 1
a209 1
/* Manufacure a VMS like time on a unix based system.
@


1.11
log
@	* Makefile.am: Run "make dep-am".
	(BFD_H_FILES): Remove version.h.
	* bfd-in.h (BFD_VERSION, BFD_VERSION_DATE, BFD_VERSION_STRING): Move..
	* version.h: ..to here.
	* configure.in (bfd_version_date): Remove.
	(AC_OUTPUT): Make bfdver.h from version.h.
	* bfd.c: #include "bfdver.h".
	* vms-hdr.c: Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d412 1
a412 1
      PRIV(eom_data).eom_has_transfer = false;
d415 1
a415 1
	   PRIV(eom_data).eom_has_transfer = true;
@


1.10
log
@	* version.h: New file.
	* bfd-in.h: (BFD_VERSION): Substitute bfd_version.
	(BFD_VERSION_DATE): Define.
	(BFD_VERSION_STRING): Define.
	* configure.in: AC_SUBST bfd_version, bfd_version_date and
	bfd_version_string.
	(AC_OUTPUT <bfd-in3.h>): Depend on version.h.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.

	* bfd-in.h: Include "symcat.h".
	(CONCAT4): Redefine as for old CAT4.
	* aout-arm.c: Use equivalent CONCAT* macro in place of CAT* macros.
	Add warning regarding whitespace.
	* aout-cris.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aout-sparcle.c: Likewise.
	* aout-tic30.c: Likewise.
	* aout0.c: Likewise.
	* armnetbsd.c: Likewise.
	* demo64.c: Likewise.
	* elf-bfd.h: Likewise.
	* gen-aout.c: Likewise.
	* host-aout.c: Likewise.
	* hp300bsd.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386aout.c: Likewise.
	* i386bsd.c: Likewise.
	* i386dynix.c: Likewise.
	* i386freebsd.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386netbsd.c: Likewise.
	* libaout.h: Likewise.
	* m68k4knetbsd.c: Likewise.
	* m68klinux.c: Likewise.
	* m68klynx.c: Likewise.
	* m68knetbsd.c: Likewise.
	* m88kmach3.c: Likewise.
	* mipsbsd.c: Likewise.
	* newsos3.c: Likewise.
	* ns32knetbsd.c: Likewise.
	* pc532-mach.c: Likewise.
	* pdp11.c: Likewise.
	* riscix.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* sunos.c: Likewise.
	* targets.c: Likewise.
	* vaxnetbsd.c: Likewise.
	* vms-hdr.c: Likewise.
@
text
@d28 1
@


1.10.10.1
log
@merge from mainline
@
text
@a27 1
#include "bfdver.h"
@


1.10.24.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a27 1
#include "bfdver.h"
@


1.10.24.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d208 1
a208 1
/* Manufacture a VMS like time on a unix based system.
d411 1
a411 1
      PRIV(eom_data).eom_has_transfer = FALSE;
d414 1
a414 1
	   PRIV(eom_data).eom_has_transfer = TRUE;
@


1.10.22.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a27 1
#include "bfdver.h"
@


1.10.22.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d411 1
a411 1
      PRIV(eom_data).eom_has_transfer = FALSE;
d414 1
a414 1
	   PRIV(eom_data).eom_has_transfer = TRUE;
@


1.10.22.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d209 1
a209 1
/* Manufacture a VMS like time on a unix based system.
@


1.9
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d316 1
a316 1
  _bfd_vms_output_counted (abfd, BFD_VERSION);
@


1.8
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a26 2
#include <ctype.h>

d30 1
d305 1
a305 2
	  if (islower (*fptr))
	    *fptr = toupper (*fptr);
@


1.7
log
@	* vms-tir.c: Add missing prototypes.
	* vms-hdr.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d350 2
a351 1
	  _bfd_vms_output_dump (abfd, (unsigned char *)symbol->name, strlen (symbol->name));
@


1.6
log
@Update copyright notices
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d39 4
@


1.5
log
@2000-12-26  Kazu Hirata  <kazu@@hxi.com>

	* vaxnetbsd.c: Fix formatting.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.4
log
@Fixes to allow sources to compile under Solaris 2.8
@
text
@a40 1

a200 1

a203 1

a242 1

a254 1

d393 1
a393 1
  if ((objtype == OBJ_S_C_EOM) 
a420 1

d433 1
a433 1
  _bfd_vms_output_long (abfd, (unsigned long)(PRIV(vms_linkage_index) >> 1));
d448 1
a448 1
      _bfd_vms_output_long (abfd, (unsigned long)(section->index));
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d36 3
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d252 1
a252 1
  int symnum;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
a336 2
	  char *s;

@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

