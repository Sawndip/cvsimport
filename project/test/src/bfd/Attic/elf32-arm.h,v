head	1.156;
access;
symbols
	gdb_6_3-20041109-release:1.153
	gdb_6_3-branch:1.153.0.2
	gdb_6_3-20041019-branchpoint:1.153
	csl-arm-2004-q3:1.145
	drow_intercu-merge-20040921:1.144
	drow_intercu-merge-20040915:1.140
	jimb-gdb_6_2-e500-branch:1.133.0.6
	jimb-gdb_6_2-e500-branchpoint:1.133
	gdb_6_2-20040730-release:1.133
	gdb_6_2-branch:1.133.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.133
	gdb_6_1_1-20040616-release:1.120
	binutils-2_15:1.120.4.4
	binutils-2_15-branchpoint:1.120
	csl-arm-2004-q1a:1.131
	csl-arm-2004-q1:1.129
	gdb_6_1-2004-04-05-release:1.120
	drow_intercu-merge-20040402:1.128
	drow_intercu-merge-20040327:1.124
	ezannoni_pie-20040323-branch:1.123.0.2
	ezannoni_pie-20040323-branchpoint:1.123
	cagney_tramp-20040321-mergepoint:1.121
	cagney_tramp-20040309-branch:1.120.0.10
	cagney_tramp-20040309-branchpoint:1.120
	gdb_6_1-branch:1.120.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.120
	drow_intercu-20040221-branch:1.120.0.6
	drow_intercu-20040221-branchpoint:1.120
	binutils-2_15-branch:1.120.0.4
	cagney_bfdfile-20040213-branch:1.120.0.2
	cagney_bfdfile-20040213-branchpoint:1.120
	drow-cplus-merge-20040208:1.120
	carlton_dictionary-20040126-merge:1.120
	cagney_bigcore-20040122-branch:1.119.0.2
	cagney_bigcore-20040122-branchpoint:1.119
	drow-cplus-merge-20040113:1.118
	csl-arm-2003-q4:1.117
	drow-cplus-merge-20031224:1.117
	drow-cplus-merge-20031220:1.117
	carlton_dictionary-20031215-merge:1.117
	drow-cplus-merge-20031214:1.117
	carlton-dictionary-20031111-merge:1.116
	gdb_6_0-2003-10-04-release:1.106
	kettenis_sparc-20030918-branch:1.110.0.6
	kettenis_sparc-20030918-branchpoint:1.110
	carlton_dictionary-20030917-merge:1.110
	ezannoni_pie-20030916-branchpoint:1.110
	ezannoni_pie-20030916-branch:1.110.0.4
	cagney_x86i386-20030821-branch:1.110.0.2
	cagney_x86i386-20030821-branchpoint:1.110
	carlton_dictionary-20030805-merge:1.108
	carlton_dictionary-20030627-merge:1.107
	gdb_6_0-branch:1.106.0.14
	gdb_6_0-2003-06-23-branchpoint:1.106
	jimb-ppc64-linux-20030613-branch:1.106.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.106
	binutils-2_14:1.105
	cagney_convert-20030606-branch:1.106.0.10
	cagney_convert-20030606-branchpoint:1.106
	cagney_writestrings-20030508-branch:1.106.0.8
	cagney_writestrings-20030508-branchpoint:1.106
	jimb-ppc64-linux-20030528-branch:1.106.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.106
	carlton_dictionary-20030523-merge:1.106
	cagney_fileio-20030521-branch:1.106.0.4
	cagney_fileio-20030521-branchpoint:1.106
	kettenis_i386newframe-20030517-mergepoint:1.106
	jimb-ppc64-linux-20030509-branch:1.106.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.106
	kettenis_i386newframe-20030504-mergepoint:1.105
	carlton_dictionary-20030430-merge:1.105
	binutils-2_14-branch:1.105.0.8
	binutils-2_14-branchpoint:1.105
	kettenis_i386newframe-20030419-branch:1.105.0.6
	kettenis_i386newframe-20030419-branchpoint:1.105
	carlton_dictionary-20030416-merge:1.105
	cagney_frameaddr-20030409-mergepoint:1.105
	kettenis_i386newframe-20030406-branch:1.105.0.4
	kettenis_i386newframe-20030406-branchpoint:1.105
	cagney_frameaddr-20030403-branchpoint:1.105
	cagney_frameaddr-20030403-branch:1.105.0.2
	cagney_framebase-20030330-mergepoint:1.104
	cagney_framebase-20030326-branch:1.104.0.2
	cagney_framebase-20030326-branchpoint:1.104
	cagney_lazyid-20030317-branch:1.103.0.8
	cagney_lazyid-20030317-branchpoint:1.103
	kettenis-i386newframe-20030316-mergepoint:1.103
	offbyone-20030313-branch:1.103.0.6
	offbyone-20030313-branchpoint:1.103
	kettenis-i386newframe-20030308-branch:1.103.0.4
	kettenis-i386newframe-20030308-branchpoint:1.103
	carlton_dictionary-20030305-merge:1.103
	cagney_offbyone-20030303-branch:1.103.0.2
	cagney_offbyone-20030303-branchpoint:1.103
	carlton_dictionary-20030207-merge:1.100
	interps-20030202-branch:1.100.0.4
	interps-20030202-branchpoint:1.100
	cagney-unwind-20030108-branch:1.100.0.2
	cagney-unwind-20030108-branchpoint:1.100
	binutils-2_13_2_1:1.87.2.2
	binutils-2_13_2:1.87.2.2
	carlton_dictionary-20021223-merge:1.100
	gdb_5_3-2002-12-12-release:1.91
	carlton_dictionary-20021115-merge:1.98
	binutils-2_13_1:1.87.2.2
	kseitz_interps-20021105-merge:1.97
	kseitz_interps-20021103-merge:1.96
	drow-cplus-merge-20021020:1.96
	drow-cplus-merge-20021025:1.96
	carlton_dictionary-20021025-merge:1.96
	carlton_dictionary-20021011-merge:1.94
	drow-cplus-branch:1.93.0.4
	drow-cplus-branchpoint:1.93
	kseitz_interps-20020930-merge:1.93
	carlton_dictionary-20020927-merge:1.93
	carlton_dictionary-branch:1.93.0.2
	carlton_dictionary-20020920-branchpoint:1.93
	sid-20020905-branchpoint:1.91
	sid-20020905-branch:1.91.0.4
	gdb_5_3-branch:1.91.0.2
	gdb_5_3-2002-09-04-branchpoint:1.91
	kseitz_interps-20020829-merge:1.91
	cagney_sysregs-20020825-branch:1.90.0.4
	cagney_sysregs-20020825-branchpoint:1.90
	readline_4_3-import-branch:1.90.0.2
	readline_4_3-import-branchpoint:1.90
	binutils-2_13:1.87
	gdb_5_2_1-2002-07-23-release:1.76
	binutils-2_13-branchpoint:1.87
	binutils-2_13-branch:1.87.0.2
	kseitz_interps-20020528-branch:1.82.0.2
	kseitz_interps-20020528-branchpoint:1.82
	cagney_regbuf-20020515-branch:1.81.0.2
	cagney_regbuf-20020515-branchpoint:1.81
	binutils-2_12_1:1.75.2.4
	jimb-macro-020506-branch:1.80.0.2
	jimb-macro-020506-branchpoint:1.80
	gdb_5_2-2002-04-29-release:1.76
	binutils-2_12:1.75.2.1
	gdb_5_2-branch:1.76.0.2
	gdb_5_2-2002-03-03-branchpoint:1.76
	binutils-2_12-branch:1.75.0.2
	binutils-2_12-branchpoint:1.75
	gdb_5_1_1-2002-01-24-release:1.52
	gdb_5_1_0_1-2002-01-03-release:1.52
	cygnus_cvs_20020108_pre:1.69
	gdb_5_1_0_1-2002-01-03-branch:1.52.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.52
	gdb_5_1-2001-11-21-release:1.52
	gdb_s390-2001-09-26-branch:1.52.0.4
	gdb_s390-2001-09-26-branchpoint:1.52
	gdb_5_1-2001-07-29-branch:1.52.0.2
	gdb_5_1-2001-07-29-branchpoint:1.52
	binutils-2_11_2:1.43.2.5
	binutils-2_11_1:1.43.2.5
	binutils-2_11:1.43.2.1
	x86_64versiong3:1.44
	binutils-2_11-branch:1.43.0.2
	insight-precleanup-2001-01-01:1.43
	binutils-2_10_1:1.25.2.6
	binutils-2_10:1.25
	gdb-premipsmulti-2000-06-06-branch:1.30.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.30
	gdb_5_0-2000-05-19-release:1.28
	gdb_4_18_2-2000-05-18-release:1.28
	gdb_4_95_1-2000-05-11-snapshot:1.28
	gdb_4_95_0-2000-04-27-snapshot:1.28
	gdb_5_0-2000-04-10-branch:1.28.0.2
	gdb_5_0-2000-04-10-branchpoint:1.28
	binutils-2_10-branch:1.25.0.2
	binutils-2_10-branchpoint:1.25
	binutils_latest_snapshot:1.155
	repo-unification-2000-02-06:1.24
	binu_ss_19990721:1.13
	binu_ss_19990602:1.6
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.156
date	2004.11.04.15.54.38;	author drow;	state dead;
branches;
next	1.155;

1.155
date	2004.10.27.20.48.21;	author pbrook;	state Exp;
branches;
next	1.154;

1.154
date	2004.10.21.15.28.20;	author hjl;	state Exp;
branches;
next	1.153;

1.153
date	2004.10.13.17.45.30;	author mmitchel;	state Exp;
branches;
next	1.152;

1.152
date	2004.10.13.03.09.28;	author mmitchel;	state Exp;
branches;
next	1.151;

1.151
date	2004.10.12.14.51.42;	author pbrook;	state Exp;
branches;
next	1.150;

1.150
date	2004.10.12.14.17.01;	author pbrook;	state Exp;
branches;
next	1.149;

1.149
date	2004.10.08.14.53.59;	author nickc;	state Exp;
branches;
next	1.148;

1.148
date	2004.10.07.15.00.20;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2004.10.07.14.57.57;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	2004.10.01.12.59.38;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2004.09.30.17.03.48;	author pbrook;	state Exp;
branches;
next	1.144;

1.144
date	2004.09.17.12.34.54;	author pbrook;	state Exp;
branches;
next	1.143;

1.143
date	2004.09.17.07.14.26;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2004.09.16.14.52.02;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2004.09.16.12.49.53;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2004.09.13.14.14.23;	author pbrook;	state Exp;
branches;
next	1.139;

1.139
date	2004.09.06.20.55.22;	author mmitchel;	state Exp;
branches;
next	1.138;

1.138
date	2004.09.03.17.15.34;	author mmitchel;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.26.16.18.37;	author pbrook;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.17.08.12.26;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.13.15.35.22;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.24.04.46.18;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.06.23.43.40;	author drow;	state Exp;
branches;
next	1.131;

1.131
date	2004.04.27.03.13.14;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2004.04.23.19.12.55;	author pb;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.02.15.25.05;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2004.04.01.12.32.35;	author pbrook;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.01.11.20.03;	author pbrook;	state Exp;
branches;
next	1.126;

1.126
date	2004.03.31.10.20.12;	author pbrook;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.27.10.58.05;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.25.12.48.32;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.23.23.05.50;	author pbrook;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.22.02.28.15;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.12.11.57.05;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2004.01.23.16.51.48;	author drow;	state Exp;
branches
	1.120.4.1
	1.120.6.1
	1.120.10.1;
next	1.119;

1.119
date	2004.01.13.21.09.34;	author drow;	state Exp;
branches;
next	1.118;

1.118
date	2004.01.09.16.53.45;	author drow;	state Exp;
branches;
next	1.117;

1.117
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches;
next	1.116;

1.116
date	2003.11.11.13.32.37;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2003.11.03.15.17.38;	author drow;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.29.22.33.26;	author pb;	state Exp;
branches;
next	1.112;

1.112
date	2003.10.27.17.33.44;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2003.10.21.14.20.39;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2003.08.05.16.24.12;	author drow;	state Exp;
branches;
next	1.108;

1.108
date	2003.07.12.11.16.46;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.09.02.27.02;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.01.13.08.05;	author nickc;	state Exp;
branches
	1.105.6.1
	1.105.8.1;
next	1.104;

1.104
date	2003.03.25.20.55.57;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2003.02.13.19.35.22;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2003.02.10.11.21.19;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2003.02.10.10.44.47;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2002.11.28.11.55.38;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2002.11.09.00.52.27;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.05.05.01.11;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.17.02.59.15;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2002.10.16.08.39.37;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2002.09.19.14.59.51;	author nickc;	state Exp;
branches
	1.93.2.1
	1.93.4.1;
next	1.92;

1.92
date	2002.09.12.13.18.57;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2002.08.27.11.01.55;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.01.14.03.01;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2002.07.31.12.04.46;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.30.17.32.26;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2002.07.01.08.06.41;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.25.06.21.51;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.83;

1.83
date	2002.05.29.16.03.04;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.23.12.37.19;	author nickc;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2002.05.07.00.16.50;	author amodra;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2002.05.06.13.47.55;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2002.04.04.19.53.36;	author drow;	state Exp;
branches;
next	1.78;

1.78
date	2002.03.28.03.27.42;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2002.03.21.15.26.03;	author rearnsha;	state Exp;
branches;
next	1.76;

1.76
date	2002.02.19.12.40.23;	author jakub;	state Exp;
branches;
next	1.75;

1.75
date	2002.02.08.19.18.35;	author cgd;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2002.02.01.13.26.56;	author pthomas;	state Exp;
branches;
next	1.73;

1.73
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2002.01.30.14.51.39;	author pthomas;	state Exp;
branches;
next	1.71;

1.71
date	2002.01.16.13.01.54;	author rearnsha;	state Exp;
branches;
next	1.70;

1.70
date	2002.01.16.05.37.10;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2002.01.03.14.23.01;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2002.01.02.15.36.27;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2001.12.07.11.12.17;	author jakub;	state Exp;
branches;
next	1.65;

1.65
date	2001.12.06.10.22.36;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.23.12.17.18;	author jakub;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.12.11.16.21;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.27.13.49.27;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2001.09.27.07.49.27;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.31.16.23.25;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.26.18.03.19;	author aj;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.25.09.47.34;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.03.11.14.42;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.09.20.19.29;	author pb;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.28.10.50.31;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.04.08.32.21;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.16.17.34.31;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.11.13.10.51;	author pb;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.07.23.52.58;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.06.22.33.46;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.28.10.13.20;	author pb;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.09.20.12.57;	author nickc;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2000.12.03.20.44.04;	author kazu;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.06.19.38.10;	author pb;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.01.07.20.04;	author pb;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.27.22.24.52;	author pb;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.29.13.51.49;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.09.00.40.08;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.03.16.32.02;	author pb;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.10.19.41.07;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.04.00.07.42;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.24.20.10.24;	author aoliva;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.22.18.44.02;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.08.00.10.49;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.06.23.38.47;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.06.23.32.19;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.01.27.20.05.29;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.13.22.55.12;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	99.11.25.11.45.05;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	99.09.17.11.04.47;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	99.09.16.15.32.40;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	99.09.13.09.59.02;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	99.08.20.07.56.08;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	99.08.19.10.12.28;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	99.08.12.08.37.15;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	99.08.11.10.56.35;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.07.30.15.09.54;	author clm;	state Exp;
branches;
next	1.13;

1.13
date	99.07.12.10.29.11;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.07.12.07.34.56;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.07.02.21.03.52;	author mmitchel;	state Exp;
branches;
next	1.10;

1.10
date	99.06.30.02.30.04;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.06.29.02.51.50;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	99.06.04.06.35.04;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.06.03.12.46.15;	author drepper;	state Exp;
branches;
next	1.6;

1.6
date	99.05.30.11.36.53;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.05.29.11.05.20;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.05.26.08.27.38;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.05.24.10.06.39;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.14.02.02.26;	author schwab;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;

1.25.2.1
date	2000.10.16.17.57.07;	author pb;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2000.10.22.15.19.56;	author pb;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2000.10.23.09.19.21;	author pb;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2000.10.27.22.39.05;	author pb;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2000.10.31.22.56.17;	author pb;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2000.11.06.19.41.20;	author pb;	state Exp;
branches;
next	;

1.43.2.1
date	2001.03.11.13.12.59;	author pb;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2001.05.28.17.45.51;	author pb;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2001.06.09.20.18.32;	author pb;	state Exp;
branches;
next	1.43.2.5;

1.43.2.5
date	2001.06.14.11.16.59;	author nickc;	state Exp;
branches;
next	1.43.2.6;

1.43.2.6
date	2001.07.16.21.41.24;	author pb;	state Exp;
branches;
next	1.43.2.7;

1.43.2.7
date	2001.08.03.11.16.39;	author nickc;	state Exp;
branches;
next	;

1.75.2.1
date	2002.02.19.13.10.19;	author jakub;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2002.04.04.14.52.56;	author amodra;	state Exp;
branches;
next	1.75.2.3;

1.75.2.3
date	2002.05.06.13.50.53;	author nickc;	state Exp;
branches;
next	1.75.2.4;

1.75.2.4
date	2002.05.09.11.50.21;	author amodra;	state Exp;
branches;
next	;

1.81.2.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.82.2.1
date	2002.06.20.01.30.03;	author kseitz;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2002.07.22.21.46.42;	author kseitz;	state Exp;
branches;
next	1.82.2.3;

1.82.2.3
date	2002.08.09.18.34.12;	author kseitz;	state Exp;
branches;
next	1.82.2.4;

1.82.2.4
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.82.2.5;

1.82.2.5
date	2002.10.01.00.45.46;	author kseitz;	state Exp;
branches;
next	1.82.2.6;

1.82.2.6
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	1.82.2.7;

1.82.2.7
date	2002.11.05.20.33.25;	author ezannoni;	state Exp;
branches;
next	;

1.87.2.1
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	;

1.93.2.1
date	2002.10.11.22.22.47;	author carlton;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2002.11.15.19.18.26;	author carlton;	state Exp;
branches;
next	1.93.2.4;

1.93.2.4
date	2002.12.23.19.37.38;	author carlton;	state Exp;
branches;
next	1.93.2.5;

1.93.2.5
date	2003.03.06.00.56.14;	author carlton;	state Exp;
branches;
next	1.93.2.6;

1.93.2.6
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.93.2.7;

1.93.2.7
date	2003.05.23.18.40.22;	author carlton;	state Exp;
branches;
next	1.93.2.8;

1.93.2.8
date	2003.06.27.21.49.12;	author carlton;	state Exp;
branches;
next	1.93.2.9;

1.93.2.9
date	2003.08.05.17.12.46;	author carlton;	state Exp;
branches;
next	1.93.2.10;

1.93.2.10
date	2003.09.17.21.27.50;	author carlton;	state Exp;
branches;
next	1.93.2.11;

1.93.2.11
date	2003.11.11.23.50.14;	author carlton;	state Exp;
branches;
next	1.93.2.12;

1.93.2.12
date	2003.12.15.23.59.22;	author carlton;	state Exp;
branches;
next	1.93.2.13;

1.93.2.13
date	2004.01.26.19.11.04;	author carlton;	state Exp;
branches;
next	;

1.93.4.1
date	2002.10.26.17.11.57;	author drow;	state Exp;
branches;
next	1.93.4.2;

1.93.4.2
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	1.93.4.3;

1.93.4.3
date	2004.01.13.16.11.36;	author drow;	state Exp;
branches;
next	1.93.4.4;

1.93.4.4
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.105.6.1
date	2003.05.18.09.43.39;	author kettenis;	state Exp;
branches;
next	;

1.105.8.1
date	2003.08.05.16.26.23;	author drow;	state Exp;
branches;
next	;

1.120.4.1
date	2004.04.08.12.41.37;	author amodra;	state Exp;
branches;
next	1.120.4.2;

1.120.4.2
date	2004.04.09.18.27.59;	author drow;	state Exp;
branches;
next	1.120.4.3;

1.120.4.3
date	2004.04.25.23.35.38;	author pb;	state Exp;
branches;
next	1.120.4.4;

1.120.4.4
date	2004.05.06.23.44.12;	author drow;	state Exp;
branches;
next	;

1.120.6.1
date	2004.03.27.17.37.31;	author drow;	state Exp;
branches;
next	1.120.6.2;

1.120.6.2
date	2004.04.02.16.47.33;	author drow;	state Exp;
branches;
next	1.120.6.3;

1.120.6.3
date	2004.09.16.17.00.21;	author drow;	state Exp;
branches;
next	1.120.6.4;

1.120.6.4
date	2004.09.21.20.44.01;	author drow;	state Exp;
branches;
next	;

1.120.10.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.156
log
@./
	* configure.in (arm-*-oabi*, thumb-*-oabi*): Remove.
	* configure: Regenerated.
bfd/
	* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Replace
	elfarm-nabi with elf32-arm.  Remove elfarm-oabi.
	(elf32-arm.lo): Replace elfarm-nabi.lo rule.  Remove elf32-arm.h
	dependency.
	* config.bfd: Move arm-*-oabi* and thumb-*-oabi* from obsolete list
	to a new removed list.  Remove normal configuration stanzas.
	* configure.in: (bfd_elf32_bigarm_vec, bfd_elf32_bigarm_symbian_vec)
	(bfd_elf32_littlearm_symbian_vec, bfd_elf32_littlearm_vec): Replace
	elfarm-nabi.lo with elf32-arm.lo.
	(bfd_elf32_bigarm_oabi_vec, bfd_elf32_littlearm_oabi_vec): Remove.
	* elf32-arm.c: Renamed from elfarm-nabi.c.  Inline elf32-arm.h.
	* elf32-arm.h: Remove.
	* elfarm-oabi.c: Remove.
	* targets.c (_bfd_target_vector): Remove bfd_elf32_bigarm_oabi_vec
	and bfd_elf32_littlearm_oabi_vec.
	* aclocal.m4, Makefile.in, configure, doc/Makefile.in: Regenerated.
gas/
	* configure.in: Remove arm-*-oabi and thumb-*-oabi.
	* config/tc-arm.c (target_oabi): Delete.
	(md_apply_fix3, elf32_arm_target_format): Remove target_oabi checks.
	(arm_opts): Remove moabi.
	* doc/as.texinfo (Overview): Remove documentation of -moabi.
	* doc/c-arm.texi (ARM Options): Likewise.
	* configure: Regenerated.
ld/
	* Makefile.am (ALL_EMULATIONS): Remove earmelf_oabi.o.
	(earmelf_oabi.c): Remove rule.
	* configure.tgt: Remove arm-*-oabi and thumb-*-oabi.
	* emulparams/armelf_oabi.sh, emultempl/armelf_oabi.em: Delete files.
	* Makefile.in: Regenerated.
@
text
@/* 32-bit ELF support for ARM
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef USE_REL
#define USE_REL	0
#endif

typedef unsigned long int insn32;
typedef unsigned short int insn16;

/* In lieu of proper flags, assume all EABIv4 objects are interworkable.  */
#define INTERWORK_FLAG(abfd)  \
  (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) == EF_ARM_EABI_VER4 \
  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK))

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.  */
#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
#define ELF_DYNAMIC_INTERPRETER     "/usr/lib/ld.so.1"

#ifdef FOUR_WORD_PLT

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [] =
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };

#else

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [] =
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };

#endif

/* The entries in a PLT when using a DLL-based target with multiple
   address spaces.  */
static const bfd_vma elf32_arm_symbian_plt_entry [] = 
  {
    0xe51ff004,         /* ldr   pr, [pc, #-4] */
    0x00000000,         /* dcd   R_ARM_GLOB_DAT(X) */
  };

/* Used to build a map of a section.  This is required for mixed-endian
   code/data.  */

typedef struct elf32_elf_section_map
{
  bfd_vma vma;
  char type;
}
elf32_arm_section_map;

struct _arm_elf_section_data
{
  struct bfd_elf_section_data elf;
  int mapcount;
  elf32_arm_section_map *map;
};

#define elf32_arm_section_data(sec) \
  ((struct _arm_elf_section_data *) elf_section_data (sec))

/* The ARM linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */
struct elf32_arm_relocs_copied
  {
    /* Next section.  */
    struct elf32_arm_relocs_copied * next;
    /* A section in dynobj.  */
    asection * section;
    /* Number of relocs copied in this section.  */
    bfd_size_type count;
  };

/* Arm ELF linker hash entry.  */
struct elf32_arm_link_hash_entry
  {
    struct elf_link_hash_entry root;

    /* Number of PC relative relocs copied for this symbol.  */
    struct elf32_arm_relocs_copied * relocs_copied;
  };

/* Traverse an arm ELF linker hash table.  */
#define elf32_arm_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *))) (func), \
    (info)))

/* Get the ARM elf linker hash table from a link_info structure.  */
#define elf32_arm_hash_table(info) \
  ((struct elf32_arm_link_hash_table *) ((info)->hash))

/* ARM ELF linker hash table.  */
struct elf32_arm_link_hash_table
  {
    /* The main hash table.  */
    struct elf_link_hash_table root;

    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
    bfd_size_type thumb_glue_size;

    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
    bfd_size_type arm_glue_size;

    /* An arbitrary input BFD chosen to hold the glue sections.  */
    bfd * bfd_of_glue_owner;

    /* A boolean indicating whether knowledge of the ARM's pipeline
       length should be applied by the linker.  */
    int no_pipeline_knowledge;

    /* Nonzero to output a BE8 image.  */
    int byteswap_code;

    /* Zero if R_ARM_TARGET1 means R_ARM_ABS32.
       Nonzero if R_ARM_TARGET1 means R_ARM_ABS32.  */
    int target1_is_rel;

    /* The relocation to use for R_ARM_TARGET2 relocations.  */
    int target2_reloc;

    /* The number of bytes in the initial entry in the PLT.  */
    bfd_size_type plt_header_size;

    /* The number of bytes in the subsequent PLT etries.  */
    bfd_size_type plt_entry_size;

    /* True if the target system is Symbian OS.  */
    int symbian_p;

    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;

    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
  };

/* Create an entry in an ARM ELF linker hash table.  */

static struct bfd_hash_entry *
elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
                             struct bfd_hash_table * table,
                             const char * string)
{
  struct elf32_arm_link_hash_entry * ret =
    (struct elf32_arm_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf32_arm_link_hash_entry *) NULL)
    ret = bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_arm_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != NULL)
    ret->relocs_copied = NULL;

  return (struct bfd_hash_entry *) ret;
}

/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  /* BPABI objects never have a GOT, or associated sections.  */
  if (htab->symbian_p)
    return TRUE;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");

  if (!htab->splt 
      || !htab->srelplt
      || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;

	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->relocs_copied;
	}

      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

/* Create an ARM elf linker hash table.  */

static struct bfd_link_hash_table *
elf32_arm_link_hash_table_create (bfd *abfd)
{
  struct elf32_arm_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf32_arm_link_hash_table);

  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (& ret->root, abfd,
				      elf32_arm_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->thumb_glue_size = 0;
  ret->arm_glue_size = 0;
  ret->bfd_of_glue_owner = NULL;
  ret->no_pipeline_knowledge = 0;
  ret->byteswap_code = 0;
  ret->target1_is_rel = 0;
  ret->target2_reloc = R_ARM_NONE;
#ifdef FOUR_WORD_PLT
  ret->plt_header_size = 16;
  ret->plt_entry_size = 16;
#else
  ret->plt_header_size = 20;
  ret->plt_entry_size = 12;
#endif
  ret->symbian_p = 0;
  ret->sym_sec.abfd = NULL;

  return &ret->root.root;
}

/* Locate the Thumb encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_thumb_glue (struct bfd_link_info *link_info,
		 const char *name,
		 bfd *input_bfd)
{
  char *tmp_name;
  struct elf_link_hash_entry *hash;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the armelf specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);

  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  hash = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (hash == NULL)
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%B: unable to find THUMB glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);

  free (tmp_name);

  return hash;
}

/* Locate the ARM encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_arm_glue (struct bfd_link_info *link_info,
	       const char *name,
	       bfd *input_bfd)
{
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the elfarm specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);

  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%B: unable to find ARM glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);

  free (tmp_name);

  return myh;
}

/* ARM->Thumb glue:

   .arm
   __func_from_arm:
   ldr r12, __func_addr
   bx  r12
   __func_addr:
   .word func    @@ behave as if you saw a ARM_32 reloc.  */

#define ARM2THUMB_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM

   .thumb                               .thumb
   .align 2                             .align 2
   __func_from_thumb:              __func_from_thumb:
   bx pc                                push {r6, lr}
   nop                                  ldr  r6, __func_addr
   .arm                                         mov  lr, pc
   __func_change_to_arm:                        bx   r6
   b func                       .arm
   __func_back_to_thumb:
   ldmia r13! {r6, lr}
   bx    lr
   __func_addr:
   .word        func  */

#define THUMB2ARM_GLUE_SIZE 8
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn = 0x46c0;
static const insn32 t2a3_b_insn = 0xea000000;

#ifndef ELFARM_NABI_C_INCLUDED
bfd_boolean
bfd_elf32_arm_allocate_interworking_sections (struct bfd_link_info * info)
{
  asection * s;
  bfd_byte * foo;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
				   ARM2THUMB_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->arm_glue_size);

      s->size = globals->arm_glue_size;
      s->contents = foo;
    }

  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->thumb_glue_size);

      s->size = globals->thumb_glue_size;
      s->contents = foo;
    }

  return TRUE;
}

static void
record_arm_to_thumb_glue (struct bfd_link_info * link_info,
			  struct elf_link_hash_entry * h)
{
  const char * name = h->root.root.string;
  asection * s;
  char * tmp_name;
  struct elf_link_hash_entry * myh;
  struct bfd_link_hash_entry * bh;
  struct elf32_arm_link_hash_table * globals;
  bfd_vma val;

  globals = elf32_arm_hash_table (link_info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = bfd_malloc ((bfd_size_type) strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return;
    }

  /* The only trick here is using hash_table->arm_glue_size as the value.
     Even though the section isn't allocated yet, this is where we will be
     putting it.  */
  bh = NULL;
  val = globals->arm_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;

  return;
}

static void
record_thumb_to_arm_glue (struct bfd_link_info *link_info,
			  struct elf_link_hash_entry *h)
{
  const char *name = h->root.root.string;
  asection *s;
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct bfd_link_hash_entry *bh;
  struct elf32_arm_link_hash_table *hash_table;
  char bind;
  bfd_vma val;

  hash_table = elf32_arm_hash_table (link_info);

  BFD_ASSERT (hash_table != NULL);
  BFD_ASSERT (hash_table->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (hash_table->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return;
    }

  bh = NULL;
  val = hash_table->thumb_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  /* If we mark it 'Thumb', the disassembler will do a better job.  */
  myh = (struct elf_link_hash_entry *) bh;
  bind = ELF_ST_BIND (myh->type);
  myh->type = ELF_ST_INFO (bind, STT_ARM_TFUNC);

  free (tmp_name);

#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"

  /* Allocate another symbol to mark where we switch to Arm mode.  */
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (CHANGE_TO_ARM) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, CHANGE_TO_ARM, name);

  bh = NULL;
  val = hash_table->thumb_glue_size + 4,
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  hash_table->thumb_glue_size += THUMB2ARM_GLUE_SIZE;

  return;
}

/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */

bfd_boolean
bfd_elf32_arm_add_glue_sections_to_bfd (bfd *abfd,
					struct bfd_link_info *info)
{
  flagword flags;
  asection *sec;

  /* If we are only performing a partial
     link do not bother adding the glue.  */
  if (info->relocatable)
    return TRUE;

  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      /* Note: we do not include the flag SEC_LINKER_CREATED, as this
	 will prevent elf_link_input_bfd() from processing the contents
	 of this section.  */
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);

      if (sec == NULL
	  || !bfd_set_section_flags (abfd, sec, flags)
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      /* Set the gc mark to prevent the section from being removed by garbage
	 collection, despite the fact that no relocs refer to this section.  */
      sec->gc_mark = 1;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	| SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);

      if (sec == NULL
	  || !bfd_set_section_flags (abfd, sec, flags)
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      sec->gc_mark = 1;
    }

  return TRUE;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */

bfd_boolean
bfd_elf32_arm_get_bfd_for_interworking (bfd *abfd, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocatable)
    return TRUE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;

  return TRUE;
}

bfd_boolean
bfd_elf32_arm_process_before_allocation (bfd *abfd,
					 struct bfd_link_info *link_info,
					 int no_pipeline_knowledge,
					 int byteswap_code)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;

  asection *sec;
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (link_info->relocatable)
    return TRUE;

  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
  globals = elf32_arm_hash_table (link_info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  globals->no_pipeline_knowledge = no_pipeline_knowledge;

  if (byteswap_code && !bfd_big_endian (abfd))
    {
      _bfd_error_handler (_("%B: BE8 images only valid in big-endian mode."),
			  abfd);
      return FALSE;
    }
  globals->byteswap_code = byteswap_code;

  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return TRUE;

  for (; sec != NULL; sec = sec->next)
    {
      if (sec->reloc_count == 0)
	continue;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

      /* Load the relocs.  */
      internal_relocs
	= _bfd_elf_link_read_relocs (abfd, sec, (void *) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);

      if (internal_relocs == NULL)
	goto error_return;

      irelend = internal_relocs + sec->reloc_count;
      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  long r_type;
	  unsigned long r_index;

	  struct elf_link_hash_entry *h;

	  r_type = ELF32_R_TYPE (irel->r_info);
	  r_index = ELF32_R_SYM (irel->r_info);

	  /* These are the only relocation types we care about.  */
	  if (   r_type != R_ARM_PC24
#ifndef OLD_ARM_ABI
	      && r_type != R_ARM_CALL
	      && r_type != R_ARM_JUMP24
#endif
	      && r_type != R_ARM_THM_PC22)
	    continue;

	  /* Get the section contents if we haven't done so already.  */
	  if (contents == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (elf_section_data (sec)->this_hdr.contents != NULL)
		contents = elf_section_data (sec)->this_hdr.contents;
	      else
		{
		  /* Go get them off disk.  */
		  if (! bfd_malloc_and_get_section (abfd, sec, &contents))
		    goto error_return;
		}
	    }

	  /* If the relocation is not against a symbol it cannot concern us.  */
	  h = NULL;

	  /* We don't care about local symbols.  */
	  if (r_index < symtab_hdr->sh_info)
	    continue;

	  /* This is an external symbol.  */
	  r_index -= symtab_hdr->sh_info;
	  h = (struct elf_link_hash_entry *)
	    elf_sym_hashes (abfd)[r_index];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  switch (r_type)
	    {
	    case R_ARM_PC24:
#ifndef OLD_ARM_ABI
	    case R_ARM_CALL:
	    case R_ARM_JUMP24:
#endif
	      /* This one is a call from arm code.  We need to look up
	         the target of the call.  If it is a thumb target, we
	         insert glue.  */
	      if (ELF_ST_TYPE(h->type) == STT_ARM_TFUNC)
		record_arm_to_thumb_glue (link_info, h);
	      break;

	    case R_ARM_THM_PC22:
	      /* This one is a call from thumb code.  We look
	         up the target of the call.  If it is not a thumb
                 target, we insert glue.  */
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC)
		record_thumb_to_arm_glue (link_info, h);
	      break;

	    default:
	      break;
	    }
	}

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;

      if (internal_relocs != NULL
	  && elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      internal_relocs = NULL;
    }

  return TRUE;

error_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}
#endif


#ifndef OLD_ARM_ABI
/* Set target relocation values needed during linking.  */

void
bfd_elf32_arm_set_target_relocs (struct bfd_link_info *link_info,
				 int target1_is_rel,
				 char * target2_type)
{
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (link_info);

  globals->target1_is_rel = target1_is_rel;
  if (strcmp (target2_type, "rel") == 0)
    globals->target2_reloc = R_ARM_REL32;
  else if (strcmp (target2_type, "abs") == 0)
    globals->target2_reloc = R_ARM_ABS32;
  else if (strcmp (target2_type, "got-rel") == 0)
    globals->target2_reloc = R_ARM_GOT_PREL;
  else
    {
      _bfd_error_handler (_("Invalid TARGET2 relocation type '%s'."),
			  target2_type);
    }
}
#endif

/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an
   offset, insert the offset into the thumb branch and return finished
   instruction.

   It takes two thumb instructions to encode the target address. Each has
   11 bits to invest. The upper 11 bits are stored in one (identified by
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).

   Combine together and shifted left by 1 (it's a half word address) and
   there you have it.

   Op: 1111 = F,
   H-0, upper address-0 = 000
   Op: 1111 = F,
   H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com.  */

#define LOW_HI_ORDER      0xF800F000
#define HI_LOW_ORDER      0xF000F800

static insn32
insert_thumb_branch (insn32 br_insn, int rel_off)
{
  unsigned int low_bits;
  unsigned int high_bits;

  BFD_ASSERT ((rel_off & 1) != 1);

  rel_off >>= 1;				/* Half word aligned address.  */
  low_bits = rel_off & 0x000007FF;		/* The bottom 11 bits.  */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* The top 11 bits.  */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    /* FIXME: abort is probably not the right call. krk@@cygnus.com  */
    abort ();	/* Error - not a valid branch instruction form.  */

  return br_insn;
}

/* Thumb code calling an ARM function.  */

static int
elf32_thumb_to_arm_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
{
  asection * s = 0;
  bfd_vma my_offset;
  unsigned long int tmp;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_thumb_glue (info, name, input_bfd);
  if (myh == NULL)
    return FALSE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;

  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: thumb call to arm"),
	     sym_sec->owner, input_bfd, name);

	  return FALSE;
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
		  s->contents + my_offset);

      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
		  s->contents + my_offset + 2);

      ret_offset =
	/* Address of destination of the stub.  */
	((bfd_signed_vma) val)
	- ((bfd_signed_vma)
	   /* Offset from the start of the current section
	      to the start of the stubs.  */
	   (s->output_offset
	    /* Offset of the start of this stub from the start of the stubs.  */
	    + my_offset
	    /* Address of the start of the current section.  */
	    + s->output_section->vma)
	   /* The branch instruction is 4 bytes into the stub.  */
	   + 4
	   /* ARM branches work from the pc of the instruction + 8.  */
	   + 8);

      bfd_put_32 (output_bfd,
		  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
		  s->contents + my_offset + 4);
    }

  BFD_ASSERT (my_offset <= globals->thumb_glue_size);

  /* Now go back and fix up the original BL insn to point to here.  */
  ret_offset =
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset
       + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
    - 8;

  tmp = bfd_get_32 (input_bfd, hit_data
		    - input_section->vma);

  bfd_put_32 (output_bfd,
	      (bfd_vma) insert_thumb_branch (tmp, ret_offset),
	      hit_data - input_section->vma);

  return TRUE;
}

/* Arm code calling a Thumb function.  */

static int
elf32_arm_to_thumb_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
{
  unsigned long int tmp;
  bfd_vma my_offset;
  asection * s;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_arm_glue (info, name, input_bfd);
  if (myh == NULL)
    return FALSE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: arm call to thumb"),
	     sym_sec->owner, input_bfd, name);
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
		  s->contents + my_offset);

      bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
		  s->contents + my_offset + 4);

      /* It's a thumb address.  Add the low order bit.  */
      bfd_put_32 (output_bfd, val | a2t3_func_addr_insn,
		  s->contents + my_offset + 8);
    }

  BFD_ASSERT (my_offset <= globals->arm_glue_size);

  tmp = bfd_get_32 (input_bfd, hit_data);
  tmp = tmp & 0xFF000000;

  /* Somehow these are both 4 too far, so subtract 8.  */
  ret_offset = (s->output_offset
		+ my_offset
		+ s->output_section->vma
		- (input_section->output_offset
		   + input_section->output_section->vma
		   + offset + addend)
		- 8);

  tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);

  bfd_put_32 (output_bfd, (bfd_vma) tmp, hit_data - input_section->vma);

  return TRUE;
}


#ifndef OLD_ARM_ABI
/* Some relocations map to different relocations depending on the
   target.  Return the real relocation.  */
static int
arm_real_reloc_type (struct elf32_arm_link_hash_table * globals,
		     int r_type)
{
  switch (r_type)
    {
    case R_ARM_TARGET1:
      if (globals->target1_is_rel)
	return R_ARM_REL32;
      else
	return R_ARM_ABS32;

    case R_ARM_TARGET2:
      return globals->target2_reloc;

    default:
      return r_type;
    }
}
#endif /* OLD_ARM_ABI */


/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
elf32_arm_final_link_relocate (reloc_howto_type *           howto,
			       bfd *                        input_bfd,
			       bfd *                        output_bfd,
			       asection *                   input_section,
			       bfd_byte *                   contents,
			       Elf_Internal_Rela *          rel,
			       bfd_vma                      value,
			       struct bfd_link_info *       info,
			       asection *                   sym_sec,
			       const char *                 sym_name,
			       int		            sym_flags,
			       struct elf_link_hash_entry * h)
{
  unsigned long                 r_type = howto->type;
  unsigned long                 r_symndx;
  bfd_byte *                    hit_data = contents + rel->r_offset;
  bfd *                         dynobj = NULL;
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  bfd_vma *                     local_got_offsets;
  asection *                    sgot = NULL;
  asection *                    splt = NULL;
  asection *                    sreloc = NULL;
  bfd_vma                       addend;
  bfd_signed_vma                signed_addend;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);

#ifndef OLD_ARM_ABI
  /* Some relocation type map to different relocations depending on the
     target.  We pick the right one here.  */
  r_type = arm_real_reloc_type (globals, r_type);
  if (r_type != howto->type)
    howto = elf32_arm_howto_from_type (r_type);
#endif /* OLD_ARM_ABI */

  /* If the start address has been set, then set the EF_ARM_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.

     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.

     Note - if the user deliberately sets a start address of 0, the
     flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_ARM_HASENTRY;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      splt = bfd_get_section_by_name (dynobj, ".plt");
    }
  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);
  r_symndx = ELF32_R_SYM (rel->r_info);

#if USE_REL
  addend = bfd_get_32 (input_bfd, hit_data) & howto->src_mask;

  if (addend & ((howto->src_mask + 1) >> 1))
    {
      signed_addend = -1;
      signed_addend &= ~ howto->src_mask;
      signed_addend |= addend;
    }
  else
    signed_addend = addend;
#else
  addend = signed_addend = rel->r_addend;
#endif

  switch (r_type)
    {
    case R_ARM_NONE:
      return bfd_reloc_ok;

    case R_ARM_PC24:
    case R_ARM_ABS32:
    case R_ARM_REL32:
#ifndef OLD_ARM_ABI
    case R_ARM_CALL:
    case R_ARM_JUMP24:
    case R_ARM_XPC25:
    case R_ARM_PREL31:
#endif
    case R_ARM_PLT32:
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	return bfd_reloc_ok;

      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	   && r_type != R_ARM_PREL31
#endif
	   )
	  && h != NULL
	  && splt != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset);
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}

      /* When generating a shared object, these relocations are copied
	 into the output file to be resolved at run time.  */
      if (info->shared
	  && (input_section->flags & SEC_ALLOC)
	  && ((r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	      && r_type != R_ARM_PREL31
#endif
	      ) || !SYMBOL_CALLS_LOCAL (info, h))
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
#ifndef OLD_ARM_ABI
	  && r_type != R_ARM_CALL
	  && r_type != R_ARM_JUMP24
#endif
	  && r_type != R_ARM_PLT32)
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;
	  bfd_boolean skip, relocate;

	  if (sreloc == NULL)
	    {
	      const char * name;

	      name = (bfd_elf_string_from_elf_section
		      (input_bfd,
		       elf_elfheader (input_bfd)->e_shstrndx,
		       elf_section_data (input_section)->rel_hdr.sh_name));
	      if (name == NULL)
		return bfd_reloc_notsupported;

	      BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			  && strcmp (bfd_get_section_name (input_bfd,
							   input_section),
				     name + 4) == 0);

	      sreloc = bfd_get_section_by_name (dynobj, name);
	      BFD_ASSERT (sreloc != NULL);
	    }

	  skip = FALSE;
	  relocate = FALSE;

	  outrel.r_offset =
	    _bfd_elf_section_offset (output_bfd, info, input_section,
				     rel->r_offset);
	  if (outrel.r_offset == (bfd_vma) -1)
	    skip = TRUE;
	  else if (outrel.r_offset == (bfd_vma) -2)
	    skip = TRUE, relocate = TRUE;
	  outrel.r_offset += (input_section->output_section->vma
			      + input_section->output_offset);

	  if (skip)
	    memset (&outrel, 0, sizeof outrel);
	  else if (h != NULL
		   && h->dynindx != -1
		   && (!info->shared
		       || !info->symbolic
		       || !h->def_regular))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
	  else
	    {
	      /* This symbol is local, or marked to become local.  */
	      relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	    }

	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);

	  /* If this reloc is against an external symbol, we do not want to
	     fiddle with the addend.  Otherwise, we need to include the symbol
	     value so that it becomes an addend for the dynamic reloc.  */
	  if (! relocate)
	    return bfd_reloc_ok;

	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}
      else switch (r_type)
	{
#ifndef OLD_ARM_ABI
	case R_ARM_XPC25:	  /* Arm BLX instruction.  */
	case R_ARM_CALL:
	case R_ARM_JUMP24:
#endif
	case R_ARM_PC24:	  /* Arm B/BL instruction */
	case R_ARM_PLT32:
#ifndef OLD_ARM_ABI
	  if (r_type == R_ARM_XPC25)
	    {
	      /* Check for Arm calling Arm function.  */
	      /* FIXME: Should we translate the instruction into a BL
		 instruction instead ?  */
	      if (sym_flags != STT_ARM_TFUNC)
		(*_bfd_error_handler)
		  (_("\%B: Warning: Arm BLX instruction targets Arm function '%s'."),
		   input_bfd,
		   h ? h->root.root.string : "(local)");
	    }
	  else
#endif
	    {
	      /* Check for Arm calling Thumb function.  */
	      if (sym_flags == STT_ARM_TFUNC)
		{
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd,
					   output_bfd, input_section,
					   hit_data, sym_sec, rel->r_offset,
					   signed_addend, value);
		  return bfd_reloc_ok;
		}
	    }

	  if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
	      || strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0)
	    {
	      /* The old way of doing things.  Trearing the addend as a
		 byte sized field and adding in the pipeline offset.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += addend;

	      if (! globals->no_pipeline_knowledge)
		value -= 8;
	    }
	  else
	    {
	      /* The ARM ELF ABI says that this reloc is computed as: S - P + A
		 where:
		  S is the address of the symbol in the relocation.
		  P is address of the instruction being relocated.
		  A is the addend (extracted from the instruction) in bytes.

		 S is held in 'value'.
		 P is the base address of the section containing the
		   instruction plus the offset of the reloc into that
		   section, ie:
		     (input_section->output_section->vma +
		      input_section->output_offset +
		      rel->r_offset).
		 A is the addend, converted into bytes, ie:
		     (signed_addend * 4)

		 Note: None of these operations have knowledge of the pipeline
		 size of the processor, thus it is up to the assembler to
		 encode this information into the addend.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += (signed_addend << howto->size);

	      /* Previous versions of this code also used to add in the
		 pipeline offset here.  This is wrong because the linker is
		 not supposed to know about such things, and one day it might
		 change.  In order to support old binaries that need the old
		 behaviour however, so we attempt to detect which ABI was
		 used to create the reloc.  */
	      if (! globals->no_pipeline_knowledge)
		{
		  Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form */

		  i_ehdrp = elf_elfheader (input_bfd);

		  if (i_ehdrp->e_ident[EI_OSABI] == 0)
		    value -= 8;
		}
	    }

	  signed_addend = value;
	  signed_addend >>= howto->rightshift;

	  /* It is not an error for an undefined weak reference to be
	     out of range.  Any program that branches to such a symbol
	     is going to crash anyway, so there is no point worrying
	     about getting the destination exactly right.  */
	  if (! h || h->root.type != bfd_link_hash_undefweak)
	    {
	      /* Perform a signed range check.  */
	      if (   signed_addend >   ((bfd_signed_vma)  (howto->dst_mask >> 1))
		  || signed_addend < - ((bfd_signed_vma) ((howto->dst_mask + 1) >> 1)))
		return bfd_reloc_overflow;
	    }

#ifndef OLD_ARM_ABI
	  /* If necessary set the H bit in the BLX instruction.  */
	  if (r_type == R_ARM_XPC25 && ((value & 2) == 2))
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask))
	      | (1 << 24);
	  else
#endif
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
	  break;

	case R_ARM_ABS32:
	  value += addend;
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
	  break;

	case R_ARM_REL32:
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  value += addend;
	  break;

#ifndef OLD_ARM_ABI
	case R_ARM_PREL31:
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  value += signed_addend;
	  if (! h || h->root.type != bfd_link_hash_undefweak)
	    {
	      /* Check for overflow */
	      if ((value ^ (value >> 1)) & (1 << 30))
		return bfd_reloc_overflow;
	    }
	  value &= 0x7fffffff;
	  value |= (bfd_get_32 (input_bfd, hit_data) & 0x80000000);
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
	  break;
#endif
	}

      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS8:
      value += addend;
      if ((long) value > 0x7f || (long) value < -0x80)
	return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS16:
      value += addend;

      if ((long) value > 0x7fff || (long) value < -0x8000)
	return bfd_reloc_overflow;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS12:
      /* Support ldr and str instruction for the arm */
      /* Also thumb b (unconditional branch).  ??? Really?  */
      value += addend;

      if ((long) value > 0x7ff || (long) value < -0x800)
	return bfd_reloc_overflow;

      value |= (bfd_get_32 (input_bfd, hit_data) & 0xfffff000);
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_THM_ABS5:
      /* Support ldr and str instructions for the thumb.  */
#if USE_REL
      /* Need to refetch addend.  */
      addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
      /* ??? Need to determine shift amount from operand size.  */
      addend >>= howto->rightshift;
#endif
      value += addend;

      /* ??? Isn't value unsigned?  */
      if ((long) value > 0x1f || (long) value < -0x10)
	return bfd_reloc_overflow;

      /* ??? Value needs to be properly shifted into place first.  */
      value |= bfd_get_16 (input_bfd, hit_data) & 0xf83f;
      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

#ifndef OLD_ARM_ABI
    case R_ARM_THM_XPC22:
#endif
    case R_ARM_THM_PC22:
      /* Thumb BL (branch long instruction).  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
	bfd_signed_vma signed_check;

#if USE_REL
	/* Need to refetch the addend and squish the two 11 bit pieces
	   together.  */
	{
	  bfd_vma upper = upper_insn & 0x7ff;
	  bfd_vma lower = lower_insn & 0x7ff;
	  upper = (upper ^ 0x400) - 0x400; /* Sign extend.  */
	  addend = (upper << 12) | (lower << 1);
	  signed_addend = addend;
	}
#endif
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22)
	  {
	    /* Check for Thumb to Thumb call.  */
	    /* FIXME: Should we translate the instruction into a BL
	       instruction instead ?  */
	    if (sym_flags == STT_ARM_TFUNC)
	      (*_bfd_error_handler)
		(_("%B: Warning: Thumb BLX instruction targets thumb function '%s'."),
		 input_bfd,
		 h ? h->root.root.string : "(local)");
	  }
	else
#endif
	  {
	    /* If it is not a call to Thumb, assume call to Arm.
	       If it is a call relative to a section name, then it is not a
	       function call at all, but rather a long jump.  */
	    if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
	      {
		if (elf32_thumb_to_arm_stub
		    (info, sym_name, input_bfd, output_bfd, input_section,
		     hit_data, sym_sec, rel->r_offset, signed_addend, value))
		  return bfd_reloc_ok;
		else
		  return bfd_reloc_dangerous;
	      }
	  }

	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	if (! globals->no_pipeline_knowledge)
	  {
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form.  */

	    i_ehdrp = elf_elfheader (input_bfd);

	    /* Previous versions of this code also used to add in the pipline
	       offset here.  This is wrong because the linker is not supposed
	       to know about such things, and one day it might change.  In order
	       to support old binaries that need the old behaviour however, so
	       we attempt to detect which ABI was used to create the reloc.  */
	    if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
		|| strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0
		|| i_ehdrp->e_ident[EI_OSABI] == 0)
	      relocation += 4;
	  }

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  relocation = (relocation + 2) & ~ 3;
#endif
	/* Put RELOCATION back into the insn.  */
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 12) & 0x7ff);
	lower_insn = (lower_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 1) & 0x7ff);

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }
      break;

    case R_ARM_THM_PC11:
      /* Thumb B (branch) instruction).  */
      {
	bfd_signed_vma relocation;
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_signed_vma signed_check;

#if USE_REL
	/* Need to refetch addend.  */
	addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	if (addend & ((howto->src_mask + 1) >> 1))
	  {
	    signed_addend = -1;
	    signed_addend &= ~ howto->src_mask;
	    signed_addend |= addend;
	  }
	else
	  signed_addend = addend;
	/* The value in the insn has been right shifted.  We need to
	   undo this, so that we can perform the address calculation
	   in terms of bytes.  */
	signed_addend <<= howto->rightshift;
#endif
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	relocation >>= howto->rightshift;
	signed_check = relocation;
	relocation &= howto->dst_mask;
	relocation |= (bfd_get_16 (input_bfd, hit_data) & (~ howto->dst_mask));

	bfd_put_16 (input_bfd, relocation, hit_data);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  return bfd_reloc_overflow;

	return bfd_reloc_ok;
      }

#ifndef OLD_ARM_ABI
    case R_ARM_ALU_PCREL7_0:
    case R_ARM_ALU_PCREL15_8:
    case R_ARM_ALU_PCREL23_15:
      {
	bfd_vma insn;
	bfd_vma relocation;

	insn = bfd_get_32 (input_bfd, hit_data);
#if USE_REL
	/* Extract the addend.  */
	addend = (insn & 0xff) << ((insn & 0xf00) >> 7);
	signed_addend = addend;
#endif
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
	insn = (insn & ~0xfff)
	       | ((howto->bitpos << 7) & 0xf00)
	       | ((relocation >> howto->bitpos) & 0xff);
	bfd_put_32 (input_bfd, value, hit_data);
      }
      return bfd_reloc_ok;
#endif

    case R_ARM_GNU_VTINHERIT:
    case R_ARM_GNU_VTENTRY:
      return bfd_reloc_ok;

    case R_ARM_COPY:
      return bfd_reloc_notsupported;

    case R_ARM_GLOB_DAT:
      return bfd_reloc_notsupported;

    case R_ARM_JUMP_SLOT:
      return bfd_reloc_notsupported;

    case R_ARM_RELATIVE:
      return bfd_reloc_notsupported;

    case R_ARM_GOTOFF:
      /* Relocation is relative to the start of the
         global offset table.  */

      BFD_ASSERT (sgot != NULL);
      if (sgot == NULL)
        return bfd_reloc_notsupported;

      /* If we are addressing a Thumb function, we need to adjust the
	 address by one, so that attempts to call the function pointer will
	 correctly interpret it as Thumb code.  */
      if (sym_flags == STT_ARM_TFUNC)
	value += 1;

      /* Note that sgot->output_offset is not involved in this
         calculation.  We always want the start of .got.  If we
         define _GLOBAL_OFFSET_TABLE in a different way, as is
         permitted by the ABI, we might have to change this
         calculation.  */
      value -= sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_GOTPC:
      /* Use global offset table as symbol value.  */
      BFD_ASSERT (sgot != NULL);

      if (sgot == NULL)
        return bfd_reloc_notsupported;

      value = sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
    case R_ARM_GOT_PREL:
#endif
      /* Relocation is to the entry for this symbol in the
         global offset table.  */
      if (sgot == NULL)
	return bfd_reloc_notsupported;

      if (h != NULL)
	{
	  bfd_vma off;
	  bfd_boolean dyn;

	  off = h->got.offset;
	  BFD_ASSERT (off != (bfd_vma) -1);
	  dyn = globals->root.dynamic_sections_created;

	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
	    {
	      /* This is actually a static link, or it is a -Bsymbolic link
		 and the symbol is defined locally.  We must initialize this
		 entry in the global offset table.  Since the offset must
		 always be a multiple of 4, we use the least significant bit
		 to record whether we have initialized it already.

		 When doing a dynamic link, we create a .rel.got relocation
		 entry to initialize the value.  This is done in the
		 finish_dynamic_symbol routine.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  /* If we are addressing a Thumb function, we need to
		     adjust the address by one, so that attempts to
		     call the function pointer will correctly
		     interpret it as Thumb code.  */
		  if (sym_flags == STT_ARM_TFUNC)
		    value |= 1;

		  bfd_put_32 (output_bfd, value, sgot->contents + off);
		  h->got.offset |= 1;
		}
	    }

	  value = sgot->output_offset + off;
	}
      else
	{
	  bfd_vma off;

	  BFD_ASSERT (local_got_offsets != NULL &&
		      local_got_offsets[r_symndx] != (bfd_vma) -1);

	  off = local_got_offsets[r_symndx];

	  /* The offset must always be a multiple of 4.  We use the
	     least significant bit to record whether we have already
	     generated the necessary reloc.  */
	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      bfd_put_32 (output_bfd, value, sgot->contents + off);

	      if (info->shared)
		{
		  asection * srelgot;
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;

		  srelgot = bfd_get_section_by_name (dynobj, ".rel.got");
		  BFD_ASSERT (srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + off);
		  outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
		}

	      local_got_offsets[r_symndx] |= 1;
	    }

	  value = sgot->output_offset + off;
	}
      if (r_type != R_ARM_GOT32)
	value += sgot->output_section->vma;

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_SBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_AMP_VCALL9:
      return bfd_reloc_notsupported;

    case R_ARM_RSBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_THM_RPC22:
      return bfd_reloc_notsupported;

    case R_ARM_RREL32:
      return bfd_reloc_notsupported;

    case R_ARM_RABS32:
      return bfd_reloc_notsupported;

    case R_ARM_RPC24:
      return bfd_reloc_notsupported;

    case R_ARM_RBASE:
      return bfd_reloc_notsupported;

    default:
      return bfd_reloc_notsupported;
    }
}

#if USE_REL
/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS.  */
static void
arm_add_to_rel (bfd *              abfd,
		bfd_byte *         address,
		reloc_howto_type * howto,
		bfd_signed_vma     increment)
{
  bfd_signed_vma addend;

  if (howto->type == R_ARM_THM_PC22)
    {
      int upper_insn, lower_insn;
      int upper, lower;

      upper_insn = bfd_get_16 (abfd, address);
      lower_insn = bfd_get_16 (abfd, address + 2);
      upper = upper_insn & 0x7ff;
      lower = lower_insn & 0x7ff;

      addend = (upper << 12) | (lower << 1);
      addend += increment;
      addend >>= 1;

      upper_insn = (upper_insn & 0xf800) | ((addend >> 11) & 0x7ff);
      lower_insn = (lower_insn & 0xf800) | (addend & 0x7ff);

      bfd_put_16 (abfd, (bfd_vma) upper_insn, address);
      bfd_put_16 (abfd, (bfd_vma) lower_insn, address + 2);
    }
  else
    {
      bfd_vma        contents;

      contents = bfd_get_32 (abfd, address);

      /* Get the (signed) value from the instruction.  */
      addend = contents & howto->src_mask;
      if (addend & ((howto->src_mask + 1) >> 1))
	{
	  bfd_signed_vma mask;

	  mask = -1;
	  mask &= ~ howto->src_mask;
	  addend |= mask;
	}

      /* Add in the increment, (which is a byte value).  */
      switch (howto->type)
	{
	default:
	  addend += increment;
	  break;

	case R_ARM_PC24:
#ifndef OLD_ARM_ABI
	case R_ARM_CALL:
	case R_ARM_JUMP24:
#endif
	  addend <<= howto->size;
	  addend += increment;

	  /* Should we check for overflow here ?  */

	  /* Drop any undesired bits.  */
	  addend >>= howto->rightshift;
	  break;
	}

      contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);

      bfd_put_32 (abfd, contents, address);
    }
}
#endif /* USE_REL */

/* Relocate an ARM ELF section.  */
static bfd_boolean
elf32_arm_relocate_section (bfd *                  output_bfd,
			    struct bfd_link_info * info,
			    bfd *                  input_bfd,
			    asection *             input_section,
			    bfd_byte *             contents,
			    Elf_Internal_Rela *    relocs,
			    Elf_Internal_Sym *     local_syms,
			    asection **            local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;

#if !USE_REL
  if (info->relocatable)
    return TRUE;
#endif

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int                          r_type;
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      arelent                      bfd_reloc;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type   = ELF32_R_TYPE (rel->r_info);

      if (   r_type == R_ARM_GNU_VTENTRY
          || r_type == R_ARM_GNU_VTINHERIT)
        continue;

      elf32_arm_info_to_howto (input_bfd, & bfd_reloc, rel);
      howto = bfd_reloc.howto;

#if USE_REL
      if (info->relocatable)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  arm_add_to_rel (input_bfd, contents + rel->r_offset,
				  howto,
				  (bfd_signed_vma) (sec->output_offset
						    + sym->st_value));
		}
	    }

	  continue;
	}
#endif

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
#if USE_REL
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	  if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;
	      bfd_vma addend, value;

	      if (howto->rightshift)
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

	      value = bfd_get_32 (input_bfd, contents + rel->r_offset);

	      /* Get the (signed) value from the instruction.  */
	      addend = value & howto->src_mask;
	      if (addend & ((howto->src_mask + 1) >> 1))
		{
		  bfd_signed_vma mask;

		  mask = -1;
		  mask &= ~ howto->src_mask;
		  addend |= mask;
		}
	      msec = sec;
	      addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      value = (value & ~ howto->dst_mask) | (addend & howto->dst_mask);
	      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
	    }
#else
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
#endif
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  if (unresolved_reloc || relocation != 0)
	    {
	      /* In these cases, we don't need the relocation value.
	         We check specially because in some obscure cases
	         sec->output_section will be NULL.  */
	      switch (r_type)
		{
	        case R_ARM_PC24:
#ifndef OLD_ARM_ABI
		case R_ARM_CALL:
		case R_ARM_JUMP24:
#endif
	        case R_ARM_ABS32:
		case R_ARM_THM_PC22:
	        case R_ARM_PLT32:

	          if (info->shared
	              && ((!info->symbolic && h->dynindx != -1)
	                  || !h->def_regular)
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	              && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_ARM_ABS32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && h->def_dynamic))
		      )
	            relocation = 0;
		  break;

	        case R_ARM_GOTPC:
	          relocation = 0;
		  break;

	        case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
		case R_ARM_GOT_PREL:
#endif
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
	                  || (!info->symbolic && h->dynindx != -1)
	                  || !h->def_regular))
	            relocation = 0;
		  break;

	        default:
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%B(%A): warning: unresolvable relocation %d against symbol `%s'"),
		       input_bfd, input_section,
		       r_type,
		       h->root.root.string);
		  break;
		}
	    }
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      r = elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
					 input_section, contents, rel,
					 relocation, info, sec, name,
					 (h ? ELF_ST_TYPE (h->type) :
					  ELF_ST_TYPE (sym->st_info)), h);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) 0;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      /* If the overflowing reloc was to an undefined symbol,
		 we have already printed one error message and there
		 is no point complaining again.  */
	      if ((! h ||
		   h->root.type != bfd_link_hash_undefined)
		  && (!((*info->callbacks->reloc_overflow)
			(info, (h ? &h->root : NULL), name, howto->name,
			 (bfd_vma) 0, input_bfd, input_section,
			 rel->r_offset))))
		  return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, name, input_bfd, input_section,
		     rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous error");
	      goto common_error;

	    default:
	      msg = _("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (bfd *abfd)
{
  unsigned int mach;

  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);

  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  return TRUE;
}

/* Function to keep ARM specific flags in the ELF header.  */

static bfd_boolean
elf32_arm_set_private_flags (bfd *abfd, flagword flags)
{
  if (elf_flags_init (abfd)
      && elf_elfheader (abfd)->e_flags != flags)
    {
      if (EF_ARM_EABI_VERSION (flags) == EF_ARM_EABI_UNKNOWN)
	{
	  if (flags & EF_ARM_INTERWORK)
	    (*_bfd_error_handler)
	      (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
	       abfd);
	  else
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B due to outside request"),
	       abfd);
	}
    }
  else
    {
      elf_elfheader (abfd)->e_flags = flags;
      elf_flags_init (abfd) = TRUE;
    }

  return TRUE;
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
elf32_arm_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword in_flags;
  flagword out_flags;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (elf_flags_init (obfd)
      && EF_ARM_EABI_VERSION (out_flags) == EF_ARM_EABI_UNKNOWN
      && in_flags != out_flags)
    {
      /* Cannot mix APCS26 and APCS32 code.  */
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	return FALSE;

      /* Cannot mix float APCS and non-float APCS code.  */
      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	return FALSE;

      /* If the src and dest have different interworking flags
         then turn off the interworking bit.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (out_flags & EF_ARM_INTERWORK)
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
	       obfd, ibfd);

	  in_flags &= ~EF_ARM_INTERWORK;
	}

      /* Likewise for PIC, though don't warn for this case.  */
      if ((in_flags & EF_ARM_PIC) != (out_flags & EF_ARM_PIC))
	in_flags &= ~EF_ARM_PIC;
    }

  elf_elfheader (obfd)->e_flags = in_flags;
  elf_flags_init (obfd) = TRUE;

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
{
  flagword out_flags;
  flagword in_flags;
  bfd_boolean flags_compatible = TRUE;
  asection *sec;

  /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  /* The input BFD must have had its flags initialised.  */
  /* The following seems bogus to me -- The flags are initialized in
     the assembler but I don't think an elf_flags_init field is
     written into the object.  */
  /* BFD_ASSERT (elf_flags_init (ibfd)); */

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))
    {
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
         uninitialised values, which surprise surprise, correspond
         to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Identical flags must be compatible.  */
  if (in_flags == out_flags)
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatibility.  Do not short-circuit
     dynamic objects; their section list may be emptied by
    elf_link_add_object_symbols.

    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;
      bfd_boolean only_data_sections = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

	      null_input_bfd = FALSE;
	      break;
	    }
	}

      if (null_input_bfd || only_data_sections)
	return TRUE;
    }

  /* Complain about various flag mismatches.  */
  if (EF_ARM_EABI_VERSION (in_flags) != EF_ARM_EABI_VERSION (out_flags))
    {
      _bfd_error_handler
	(_("ERROR: Source object %B has EABI version %d, but target %B has EABI version %d"),
	 ibfd, obfd,
	 (in_flags & EF_ARM_EABIMASK) >> 24,
	 (out_flags & EF_ARM_EABIMASK) >> 24);
      return FALSE;
    }

  /* Not sure what needs to be checked for EABI versions >= 1.  */
  if (EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
    {
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	{
	  _bfd_error_handler
	    (_("ERROR: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
	     ibfd, obfd,
	     in_flags & EF_ARM_APCS_26 ? 26 : 32,
	     out_flags & EF_ARM_APCS_26 ? 26 : 32);
	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	{
	  if (in_flags & EF_ARM_APCS_FLOAT)
	    _bfd_error_handler
	      (_("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_VFP_FLOAT) != (out_flags & EF_ARM_VFP_FLOAT))
	{
	  if (in_flags & EF_ARM_VFP_FLOAT)
	    _bfd_error_handler
	      (_("ERROR: %B uses VFP instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("ERROR: %B uses FPA instructions, whereas %B does not"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler
	      (_("ERROR: %B uses Maverick instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("ERROR: %B does not use Maverick instructions, whereas %B does"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
	{
	  /* We can allow interworking between code that is VFP format
	     layout, and uses either soft float or integer regs for
	     passing floating point arguments and results.  We already
	     know that the APCS_FLOAT flags match; similarly for VFP
	     flags.  */
	  if ((in_flags & EF_ARM_APCS_FLOAT) != 0
	      || (in_flags & EF_ARM_VFP_FLOAT) == 0)
	    {
	      if (in_flags & EF_ARM_SOFT_FLOAT)
		_bfd_error_handler
		  (_("ERROR: %B uses software FP, whereas %B uses hardware FP"),
		   ibfd, obfd);
	      else
		_bfd_error_handler
		  (_("ERROR: %B uses hardware FP, whereas %B uses software FP"),
		   ibfd, obfd);

	      flags_compatible = FALSE;
	    }
	}
#endif

      /* Interworking mismatch is only a warning.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (in_flags & EF_ARM_INTERWORK)
	    {
	      _bfd_error_handler
		(_("Warning: %B supports interworking, whereas %B does not"),
		 ibfd, obfd);
	    }
	  else
	    {
	      _bfd_error_handler
		(_("Warning: %B does not support interworking, whereas %B does"),
		 ibfd, obfd);
	    }
	}
    }

  return flags_compatible;
}

/* Display the flags field.  */

static bfd_boolean
elf32_arm_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE * file = (FILE *) ptr;
  unsigned long flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;
  /* Ignore init flag - it may not be set, despite the flags field
     containing valid data.  */

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  switch (EF_ARM_EABI_VERSION (flags))
    {
    case EF_ARM_EABI_UNKNOWN:
      /* The following flag bits are GNU extensions and not part of the
	 official ARM ELF extended ABI.  Hence they are only decoded if
	 the EABI version is not set.  */
      if (flags & EF_ARM_INTERWORK)
	fprintf (file, _(" [interworking enabled]"));

      if (flags & EF_ARM_APCS_26)
	fprintf (file, " [APCS-26]");
      else
	fprintf (file, " [APCS-32]");

      if (flags & EF_ARM_VFP_FLOAT)
	fprintf (file, _(" [VFP float format]"));
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
      else
	fprintf (file, _(" [FPA float format]"));

      if (flags & EF_ARM_APCS_FLOAT)
	fprintf (file, _(" [floats passed in float registers]"));

      if (flags & EF_ARM_PIC)
	fprintf (file, _(" [position independent]"));

      if (flags & EF_ARM_NEW_ABI)
	fprintf (file, _(" [new ABI]"));

      if (flags & EF_ARM_OLD_ABI)
	fprintf (file, _(" [old ABI]"));

      if (flags & EF_ARM_SOFT_FLOAT)
	fprintf (file, _(" [software FP]"));

      flags &= ~(EF_ARM_INTERWORK | EF_ARM_APCS_26 | EF_ARM_APCS_FLOAT
		 | EF_ARM_PIC | EF_ARM_NEW_ABI | EF_ARM_OLD_ABI
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
      break;

    case EF_ARM_EABI_VER1:
      fprintf (file, _(" [Version1 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      flags &= ~ EF_ARM_SYMSARESORTED;
      break;

    case EF_ARM_EABI_VER2:
      fprintf (file, _(" [Version2 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      if (flags & EF_ARM_DYNSYMSUSESEGIDX)
	fprintf (file, _(" [dynamic symbols use segment index]"));

      if (flags & EF_ARM_MAPSYMSFIRST)
	fprintf (file, _(" [mapping symbols precede others]"));

      flags &= ~(EF_ARM_SYMSARESORTED | EF_ARM_DYNSYMSUSESEGIDX
		 | EF_ARM_MAPSYMSFIRST);
      break;

    case EF_ARM_EABI_VER3:
      fprintf (file, _(" [Version3 EABI]"));
      break;

    case EF_ARM_EABI_VER4:
      fprintf (file, _(" [Version4 EABI]"));

      if (flags & EF_ARM_BE8)
	fprintf (file, _(" [BE8]"));

      if (flags & EF_ARM_LE8)
	fprintf (file, _(" [LE8]"));

      flags &= ~(EF_ARM_LE8 | EF_ARM_BE8);
      break;

    default:
      fprintf (file, _(" <EABI version unrecognised>"));
      break;
    }

  flags &= ~ EF_ARM_EABIMASK;

  if (flags & EF_ARM_RELEXEC)
    fprintf (file, _(" [relocatable executable]"));

  if (flags & EF_ARM_HASENTRY)
    fprintf (file, _(" [has entry point]"));

  flags &= ~ (EF_ARM_RELEXEC | EF_ARM_HASENTRY);

  if (flags)
    fprintf (file, _("<Unrecognised flag bits set>"));

  fputc ('\n', file);

  return TRUE;
}

static int
elf32_arm_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
{
  switch (ELF_ST_TYPE (elf_sym->st_info))
    {
    case STT_ARM_TFUNC:
      return ELF_ST_TYPE (elf_sym->st_info);

    case STT_ARM_16BIT:
      /* If the symbol is not an object, return the STT_ARM_16BIT flag.
	 This allows us to distinguish between data used by Thumb instructions
	 and non-data (which is probably code) inside Thumb regions of an
	 executable.  */
      if (type != STT_OBJECT)
	return ELF_ST_TYPE (elf_sym->st_info);
      break;

    default:
      break;
    }

  return type;
}

static asection *
elf32_arm_gc_mark_hook (asection *                   sec,
			struct bfd_link_info *       info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *          rel,
			struct elf_link_hash_entry * h,
			Elf_Internal_Sym *           sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GNU_VTINHERIT:
      case R_ARM_GNU_VTENTRY:
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

	  default:
	    break;
          }
       }
     }
   else
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_arm_gc_sweep_hook (bfd *                     abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *    info ATTRIBUTE_UNUSED,
			 asection *                sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      int r_type;

      r_type = ELF32_R_TYPE (rel->r_info);
#ifndef OLD_ARM_ABI
      r_type = arm_real_reloc_type (globals, r_type);
#endif
      switch (r_type)
	{
	case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
	case R_ARM_GOT_PREL:
#endif
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_ARM_ABS32:
	case R_ARM_REL32:
	case R_ARM_PC24:
	case R_ARM_PLT32:
#ifndef OLD_ARM_ABI
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PREL31:
#endif
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      struct elf32_arm_link_hash_entry *eh;
	      struct elf32_arm_relocs_copied **pp;
	      struct elf32_arm_relocs_copied *p;

	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      if (r_type == R_ARM_ABS32
#ifndef OLD_ARM_ABI
		  || r_type == R_ARM_PREL31
#endif
		  || r_type == R_ARM_REL32)
		{
		  eh = (struct elf32_arm_link_hash_entry *) h;

		  for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		       pp = &p->next)
		  if (p->section == sec)
		    {
		      p->count -= 1;
		      if (p->count == 0)
			*pp = p->next;
		      break;
		    }
		}
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Look through the relocs for a section during the first phase.  */

static bfd_boolean
elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sreloc;
  bfd_vma *local_got_offsets;
  struct elf32_arm_link_hash_table *htab;

  if (info->relocatable)
    return TRUE;

  htab = elf32_arm_hash_table (info);
  sreloc = NULL;

  dynobj = elf_hash_table (info)->dynobj;
  local_got_offsets = elf_local_got_offsets (abfd);

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes
    + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);

  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;
      int r_type;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
#ifndef OLD_ARM_ABI
      r_type = arm_real_reloc_type (htab, r_type);
#endif
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      switch (r_type)
        {
	  case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
	  case R_ARM_GOT_PREL:
#endif
	    /* This symbol requires a global offset table entry.  */
	    if (h != NULL)
	      {
		h->got.refcount++;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;

		    size = symtab_hdr->sh_info;
		    size *= (sizeof (bfd_signed_vma) + sizeof (char));
		    local_got_refcounts = bfd_zalloc (abfd, size);
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		  }
		local_got_refcounts[r_symndx] += 1;
	      }
	    if (r_type == R_ARM_GOT32)
	      break;
	    /* Fall through.  */

	  case R_ARM_GOTOFF:
	  case R_ARM_GOTPC:
	    if (htab->sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
	    break;

	  case R_ARM_ABS32:
	  case R_ARM_REL32:
	  case R_ARM_PC24:
	  case R_ARM_PLT32:
#ifndef OLD_ARM_ABI
	  case R_ARM_CALL:
	  case R_ARM_JUMP24:
	  case R_ARM_PREL31:
#endif
	    if (h != NULL)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		if (!info->shared)
		  h->non_got_ref = 1;

		/* We may need a .plt entry if the function this reloc
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
		if (r_type == R_ARM_PC24
#ifndef OLD_ARM_ABI
		    || r_type == R_ARM_CALL
		    || r_type == R_ARM_JUMP24
#endif
		    || r_type == R_ARM_PLT32)
		  h->needs_plt = 1;

		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
		h->plt.refcount += 1;
	      }

	    /* If we are creating a shared library, and this is a reloc
               against a global symbol, or a non PC relative reloc
               against a local symbol, then we need to copy the reloc
               into the shared library.  However, if we are linking with
               -Bsymbolic, we do not need to copy a reloc against a
               global symbol which is defined in an object we are
               including in the link (i.e., DEF_REGULAR is set).  At
               this point we have not seen all the input files, so it is
               possible that DEF_REGULAR is not set now but will be set
               later (it is never cleared).  We account for that
               possibility below by storing information in the
               relocs_copied field of the hash table entry.  */
	    if (info->shared
		&& (sec->flags & SEC_ALLOC) != 0
		&& ((r_type != R_ARM_PC24
		     && r_type != R_ARM_PLT32
#ifndef OLD_ARM_ABI
		     && r_type != R_ARM_CALL
		     && r_type != R_ARM_JUMP24
		     && r_type != R_ARM_PREL31
#endif
		     && r_type != R_ARM_REL32)
		    || (h != NULL
			&& (! info->symbolic
			    || !h->def_regular))))
	      {
		struct elf32_arm_relocs_copied *p, **head;

	        /* When creating a shared object, we must copy these
                   reloc types into the output file.  We create a reloc
                   section in dynobj and make room for this reloc.  */
	        if (sreloc == NULL)
		  {
		    const char * name;

		    name = (bfd_elf_string_from_elf_section
			    (abfd,
			     elf_elfheader (abfd)->e_shstrndx,
			     elf_section_data (sec)->rel_hdr.sh_name));
		    if (name == NULL)
		      return FALSE;

		    BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			        && strcmp (bfd_get_section_name (abfd, sec),
					   name + 4) == 0);

		    sreloc = bfd_get_section_by_name (dynobj, name);
		    if (sreloc == NULL)
		      {
		        flagword flags;

		        sreloc = bfd_make_section (dynobj, name);
		        flags = (SEC_HAS_CONTENTS | SEC_READONLY
			         | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		        if ((sec->flags & SEC_ALLOC) != 0
			    /* BPABI objects never have dynamic
			       relocations mapped.  */
			    && !htab->symbian_p)
			  flags |= SEC_ALLOC | SEC_LOAD;
		        if (sreloc == NULL
			    || ! bfd_set_section_flags (dynobj, sreloc, flags)
			    || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			  return FALSE;
		      }

		    elf_section_data (sec)->sreloc = sreloc;
		  }

		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
		  {
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */

		    asection *s;
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
		    if (s == NULL)
		      return FALSE;

		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
		  }

		p = *head;
		if (p == NULL || p->section != sec)
		  {
		    bfd_size_type amt = sizeof *p;

		    p = bfd_alloc (htab->root.dynobj, amt);
		    if (p == NULL)
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->section = sec;
		    p->count = 0;
		  }

		if (r_type == R_ARM_ABS32
#ifndef OLD_ARM_ABI
		    || r_type == R_ARM_PREL31
#endif
		    || r_type == R_ARM_REL32)
		  p->count += 1;
	      }
	    break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_ARM_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_ARM_GNU_VTENTRY:
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
        }
    }

  return TRUE;
}

static bfd_boolean
is_arm_mapping_symbol_name (const char * name)
{
  return (name != NULL)
    && (name[0] == '$')
    && ((name[1] == 'a') || (name[1] == 't') || (name[1] == 'd'))
    && (name[2] == 0);
}

/* Treat mapping symbols as special target symbols.  */

static bfd_boolean
elf32_arm_is_target_special_symbol (bfd * abfd ATTRIBUTE_UNUSED, asymbol * sym)
{
  return is_arm_mapping_symbol_name (sym->name);
}

/* This is a copy of elf_find_function() from elf.c except that
   ARM mapping symbols are ignored when looking for function names
   and STT_ARM_TFUNC is considered to a function type.  */

static bfd_boolean
arm_elf_find_function (bfd *         abfd ATTRIBUTE_UNUSED,
		       asection *    section,
		       asymbol **    symbols,
		       bfd_vma       offset,
		       const char ** filename_ptr,
		       const char ** functionname_ptr)
{
  const char * filename = NULL;
  asymbol * func = NULL;
  bfd_vma low_func = 0;
  asymbol ** p;

  for (p = symbols; *p != NULL; p++)
    {
      elf_symbol_type *q;

      q = (elf_symbol_type *) *p;

      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))
	{
	default:
	  break;
	case STT_FILE:
	  filename = bfd_asymbol_name (&q->symbol);
	  break;
	case STT_FUNC:
	case STT_ARM_TFUNC:
	  /* Skip $a and $t symbols.  */
	  if ((q->symbol.flags & BSF_LOCAL)
	      && is_arm_mapping_symbol_name (q->symbol.name))
	    continue;
	  /* Fall through.  */
	case STT_NOTYPE:
	  if (bfd_get_section (&q->symbol) == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
	    {
	      func = (asymbol *) q;
	      low_func = q->symbol.value;
	    }
	  break;
	}
    }

  if (func == NULL)
    return FALSE;

  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return TRUE;
}  


/* Find the nearest line to a particular section and offset, for error
   reporting.   This code is a duplicate of the code in elf.c, except
   that it uses arm_elf_find_function.  */

static bfd_boolean
elf32_arm_find_nearest_line (bfd *          abfd,
			     asection *     section,
			     asymbol **     symbols,
			     bfd_vma        offset,
			     const char **  filename_ptr,
			     const char **  functionname_ptr,
			     unsigned int * line_ptr)
{
  bfd_boolean found = FALSE;

  /* We skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain uses it.  */

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     & elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	arm_elf_find_function (abfd, section, symbols, offset,
			       *filename_ptr ? NULL : filename_ptr,
			       functionname_ptr);

      return TRUE;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     & found, filename_ptr,
					     functionname_ptr, line_ptr,
					     & elf_tdata (abfd)->line_info))
    return FALSE;

  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  if (! arm_elf_find_function (abfd, section, symbols, offset,
			       filename_ptr, functionname_ptr))
    return FALSE;

  *line_ptr = 0;
  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf32_arm_adjust_dynamic_symbol (struct bfd_link_info * info,
				 struct elf_link_hash_entry * h)
{
  bfd * dynobj;
  asection * s;
  unsigned int power_of_two;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}

      return TRUE;
    }
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 or similar reloc to a non-function sym
       in check_relocs.  We can't decide accurately between function
       and non-function syms in check-relocs; Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_ARM_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rel.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rel);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += htab->plt_header_size;

	  h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->size += htab->plt_entry_size;

	  if (!htab->symbian_p)
	    /* We also need to make an entry in the .got.plt section, which
	       will be placed in the .got section by the linker script.  */
	    htab->sgotplt->size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->size += sizeof (Elf32_External_Rel);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (!htab->symbian_p)
	{
	  s = htab->sgot;
	  h->got.offset = s->size;
	  s->size += 4;
	  dyn = htab->root.dynamic_sections_created;
	  if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	      && (info->shared
		  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	    htab->srelgot->size += sizeof (Elf32_External_Rel);
	}
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_arm_link_hash_entry *) h;
  if (eh->relocs_copied == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* Discard relocs on undefined weak syms with non-default
         visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->relocs_copied = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->relocs_copied = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->relocs_copied; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->section)->sreloc;
      sreloc->size += p->count * sizeof (Elf32_External_Rel);
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info * info)
{
  bfd * dynobj;
  asection * s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_arm_relocs_copied *p;

	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->section)->sreloc;
		  srel->size += p->count * sizeof (Elf32_External_Rel);
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->size;
	      s->size += 4;
	      if (info->shared)
		srel->size += sizeof (Elf32_External_Rel);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (& htab->root, allocate_dynrelocs, info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char * name;
      bfd_boolean strip;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

      if (strcmp (name, ".plt") == 0)
	{
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
	}
      else if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rel.bss and
		 .rel.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there are any reloc sections other
                 than .rel.plt.  */
	      if (strcmp (name, ".rel.plt") != 0)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_arm_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!info->shared)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (   !add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (   !add_dynamic_entry (DT_REL, 0)
	      || !add_dynamic_entry (DT_RELSZ, 0)
	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
	    return FALSE;
	}

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	  info->flags |= DF_TEXTREL;
	}
    }
#undef add_synamic_entry

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf32_arm_finish_dynamic_symbol (bfd * output_bfd, struct bfd_link_info * info,
				 struct elf_link_hash_entry * h, Elf_Internal_Sym * sym)
{
  bfd * dynobj;
  struct elf32_arm_link_hash_table *htab;

  dynobj = elf_hash_table (info)->dynobj;
  htab = elf32_arm_hash_table (info);

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection * splt;
      asection * srel;
      bfd_byte *loc;
      bfd_vma plt_index;
      Elf_Internal_Rela rel;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      srel = bfd_get_section_by_name (dynobj, ".rel.plt");
      BFD_ASSERT (splt != NULL && srel != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = ((h->plt.offset - htab->plt_header_size) 
		   / htab->plt_entry_size);

      /* Fill in the entry in the procedure linkage table.  */
      if (htab->symbian_p)
	{
	  unsigned i;
	  for (i = 0; i < htab->plt_entry_size / 4; ++i)
	    bfd_put_32 (output_bfd, 
			elf32_arm_symbian_plt_entry[i],
			splt->contents + h->plt.offset + 4 * i);
	  
	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (splt->output_section->vma
			  + splt->output_offset
			  + h->plt.offset + 4 * (i - 1));
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
	}
      else
	{
	  bfd_vma got_offset;
	  bfd_vma got_displacement;
	  asection * sgot;
	  
	  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
	  BFD_ASSERT (sgot != NULL);

	  /* Get the offset into the .got table of the entry that
	     corresponds to this function.  Each .got entry is 4 bytes.
	     The first three are reserved.  */
	  got_offset = (plt_index + 3) * 4;

	  /* Calculate the displacement between the PLT slot and the
	     entry in the GOT.  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      + got_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - h->plt.offset
			      - 8);

	  BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
		      splt->contents + h->plt.offset + 0);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
		      splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
		      splt->contents + h->plt.offset + 8);
#ifdef FOUR_WORD_PLT
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		      splt->contents + h->plt.offset + 12);
#endif

	  /* Fill in the entry in the global offset table.  */
	  bfd_put_32 (output_bfd,
		      (splt->output_section->vma
		       + splt->output_offset),
		      sgot->contents + got_offset);
	  
	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_JUMP_SLOT);
	}

      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if (!h->ref_regular_nonweak)
	    sym->st_value = 0;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection * sgot;
      asection * srel;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rel.got");
      BFD_ASSERT (sgot != NULL && srel != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
	}

      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
    }

  if (h->needs_copy)
    {
      asection * s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rel.bss");
      BFD_ASSERT (s != NULL);

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_COPY);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info)
{
  bfd * dynobj;
  asection * sgot;
  asection * sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (elf32_arm_hash_table (info)->symbian_p || sgot != NULL);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;
      struct elf32_arm_link_hash_table *htab;

      htab = elf32_arm_hash_table (info);
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char * name;
	  asection * s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	      unsigned int type;

	    default:
	      break;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma_if_bpabi;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma_if_bpabi;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma_if_bpabi;
	    case DT_VERSYM:
	      name = ".gnu.version";
	      goto get_vma_if_bpabi;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma_if_bpabi;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma_if_bpabi;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rel.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      if (!htab->symbian_p)
		dyn.d_un.d_ptr = s->vma;
	      else
		/* In the BPABI, tags in the PT_DYNAMIC section point
		   at the file offset, not the memory address, for the
		   convenience of the post linker.  */
		dyn.d_un.d_ptr = s->filepos;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    get_vma_if_bpabi:
	      if (htab->symbian_p)
		goto get_vma;
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rel.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	      
	    case DT_RELSZ:
	      if (!htab->symbian_p)
		{
		  /* My reading of the SVR4 ABI indicates that the
		     procedure linkage table relocs (DT_JMPREL) should be
		     included in the overall relocs (DT_REL).  This is
		     what Solaris does.  However, UnixWare can not handle
		     that case.  Therefore, we override the DT_RELSZ entry
		     here to make it not include the JMPREL relocs.  Since
		     the linker script arranges for .rel.plt to follow all
		     other relocation sections, we don't have to worry
		     about changing the DT_REL entry.  */
		  s = bfd_get_section_by_name (output_bfd, ".rel.plt");
		  if (s != NULL)
		    dyn.d_un.d_val -= s->size;
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		  break;
		}
	      /* Fall through */

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELASZ:
	      /* In the BPABI, the DT_REL tag must point at the file
		 offset, not the VMA, of the first relocation
		 section.  So, we use code similar to that in
		 elflink.c, but do not check for SHF_ALLOC on the
		 relcoation section, since relocations sections are
		 never allocated under the BPABI.  The comments above
		 about Unixware notwithstanding, we include all of the
		 relocations here.  */
	      if (htab->symbian_p)
		{
		  unsigned int i;
		  type = ((dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
			  ? SHT_REL : SHT_RELA);
		  dyn.d_un.d_val = 0;
		  for (i = 1; i < elf_numsections (output_bfd); i++)
		    {
		      Elf_Internal_Shdr *hdr 
			= elf_elfsections (output_bfd)[i];
		      if (hdr->sh_type == type)
			{
			  if (dyn.d_tag == DT_RELSZ 
			      || dyn.d_tag == DT_RELASZ)
			    dyn.d_un.d_val += hdr->sh_size;
			  else if (dyn.d_un.d_val == 0
				   || hdr->sh_offset < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_offset;
			}
		    }
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		}
	      break;

	      /* Set the bottom bit of DT_INIT/FINI if the
		 corresponding function is Thumb.  */
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      /* If it wasn't set by elf_bfd_final_link
		 then there is nothing to adjust.  */
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry * eh;

		  eh = elf_link_hash_lookup (elf_hash_table (info), name,
					     FALSE, FALSE, TRUE);
		  if (eh != (struct elf_link_hash_entry *) NULL
		      && ELF_ST_TYPE (eh->type) == STT_ARM_TFUNC)
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0 && elf32_arm_hash_table (info)->plt_header_size)
	{
	  bfd_vma got_displacement;

	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[1], splt->contents +  4);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[2], splt->contents +  8);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[3], splt->contents + 12);
#ifdef FOUR_WORD_PLT
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
#else
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
#endif
	}

      /* UnixWare sets the entsize of .plt to 4, although that doesn't
	 really seem like the right value.  */
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot)
    {
      if (sgot->size > 0)
	{
	  if (sdyn == NULL)
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
	  else
	    bfd_put_32 (output_bfd,
			sdyn->output_section->vma + sdyn->output_offset,
			sgot->contents);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
	}

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }

  return TRUE;
}

static void
elf32_arm_post_process_headers (bfd * abfd, struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
  struct elf32_arm_link_hash_table *globals;

  i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI]      = ARM_ELF_OS_ABI_VERSION;
  i_ehdrp->e_ident[EI_ABIVERSION] = ARM_ELF_ABI_VERSION;

  if (link_info)
    {
      globals = elf32_arm_hash_table (link_info);
      if (globals->byteswap_code)
	i_ehdrp->e_flags |= EF_ARM_BE8;
    }
}

static enum elf_reloc_type_class
elf32_arm_reloc_type_class (const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_ARM_RELATIVE:
      return reloc_class_relative;
    case R_ARM_JUMP_SLOT:
      return reloc_class_plt;
    case R_ARM_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flagword *flags, const Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

static void
elf32_arm_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

/* Return TRUE if this is an unwinding table entry.  */

static bfd_boolean
is_arm_elf_unwind_section_name (bfd * abfd ATTRIBUTE_UNUSED, const char * name)
{
  size_t len1, len2;

  len1 = sizeof (ELF_STRING_ARM_unwind) - 1;
  len2 = sizeof (ELF_STRING_ARM_unwind_once) - 1;
  return (strncmp (name, ELF_STRING_ARM_unwind, len1) == 0
	  || strncmp (name, ELF_STRING_ARM_unwind_once, len2) == 0);
}


/* Set the type and flags for an ARM section.  We do this by
   the section name, which is a hack, but ought to work.  */

static bfd_boolean
elf32_arm_fake_sections (bfd * abfd, Elf_Internal_Shdr * hdr, asection * sec)
{
  const char * name;

  name = bfd_get_section_name (abfd, sec);

  if (is_arm_elf_unwind_section_name (abfd, name))
    {
      hdr->sh_type = SHT_ARM_EXIDX;
      hdr->sh_flags |= SHF_LINK_ORDER;
    }
  return TRUE;
}

/* Handle an ARM specific section when reading an object file.
   This is called when elf.c finds a section with an unknown type.  */

static bfd_boolean
elf32_arm_section_from_shdr (bfd *abfd,
			     Elf_Internal_Shdr * hdr,
			     const char *name)
{
  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     names for all the ARM specific sections, so we will probably get
     away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_ARM_EXIDX:
      break;

    default:
      return FALSE;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return FALSE;

  return TRUE;
}

/* Called for each symbol.  Builds a section map based on mapping symbols.
   Does not alter any of the symbols.  */

static bfd_boolean
elf32_arm_output_symbol_hook (struct bfd_link_info *info,
			      const char *name,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  int mapcount;
  elf32_arm_section_map *map;
  struct elf32_arm_link_hash_table *globals;

  /* Only do this on final link.  */
  if (info->relocatable)
    return TRUE;

  /* Only build a map if we need to byteswap code.  */
  globals = elf32_arm_hash_table (info);
  if (!globals->byteswap_code)
    return TRUE;

  /* We only want mapping symbols.  */
  if (! is_arm_mapping_symbol_name (name))
    return TRUE;

  mapcount = ++(elf32_arm_section_data (input_sec)->mapcount);
  map = elf32_arm_section_data (input_sec)->map;
  /* TODO: This may be inefficient, but we probably don't usually have many
     mapping symbols per section.  */
  map = bfd_realloc (map, mapcount * sizeof (elf32_arm_section_map));
  elf32_arm_section_data (input_sec)->map = map;

  map[mapcount - 1].vma = elfsym->st_value;
  map[mapcount - 1].type = name[1];
  return TRUE;
}


/* Allocate target specific section data.  */

static bfd_boolean
elf32_arm_new_section_hook (bfd *abfd, asection *sec)
{
  struct _arm_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}


/* Used to order a list of mapping symbols by address.  */

static int
elf32_arm_compare_mapping (const void * a, const void * b)
{
  return ((const elf32_arm_section_map *) a)->vma
	 > ((const elf32_arm_section_map *) b)->vma;
}


/* Do code byteswapping.  Return FALSE afterwards so that the section is
   written out as normal.  */

static bfd_boolean
elf32_arm_write_section (bfd *output_bfd ATTRIBUTE_UNUSED, asection *sec,
			 bfd_byte *contents)
{
  int mapcount;
  elf32_arm_section_map *map;
  bfd_vma ptr;
  bfd_vma end;
  bfd_vma offset;
  bfd_byte tmp;
  int i;

  mapcount = elf32_arm_section_data (sec)->mapcount;
  map = elf32_arm_section_data (sec)->map;

  if (mapcount == 0)
    return FALSE;

  qsort (map, mapcount, sizeof (elf32_arm_section_map),
	 elf32_arm_compare_mapping);

  offset = sec->output_section->vma + sec->output_offset;
  ptr = map[0].vma - offset;
  for (i = 0; i < mapcount; i++)
    {
      if (i == mapcount - 1)
	end = sec->size;
      else
	end = map[i + 1].vma - offset;

      switch (map[i].type)
	{
	case 'a':
	  /* Byte swap code words.  */
	  while (ptr + 3 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 3];
	      contents[ptr + 3] = tmp;
	      tmp = contents[ptr + 1];
	      contents[ptr + 1] = contents[ptr + 2];
	      contents[ptr + 2] = tmp;
	      ptr += 4;
	    }
	  break;

	case 't':
	  /* Byte swap code halfwords.  */
	  while (ptr + 1 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 1];
	      contents[ptr + 1] = tmp;
	      ptr += 2;
	    }
	  break;

	case 'd':
	  /* Leave data alone.  */
	  break;
	}
      ptr = end;
    }
  free (map);
  return FALSE;
}

#define ELF_ARCH			bfd_arch_arm
#define ELF_MACHINE_CODE		EM_ARM
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
#define ELF_MAXPAGESIZE			0x8000
#endif

#define bfd_elf32_bfd_copy_private_bfd_data	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	elf32_arm_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags		elf32_arm_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data	elf32_arm_print_private_bfd_data
#define bfd_elf32_bfd_link_hash_table_create    elf32_arm_link_hash_table_create
#define bfd_elf32_bfd_reloc_type_lookup		elf32_arm_reloc_type_lookup
#define bfd_elf32_find_nearest_line	        elf32_arm_find_nearest_line
#define bfd_elf32_new_section_hook		elf32_arm_new_section_hook
#define bfd_elf32_bfd_is_target_special_symbol	elf32_arm_is_target_special_symbol

#define elf_backend_get_symbol_type             elf32_arm_get_symbol_type
#define elf_backend_gc_mark_hook                elf32_arm_gc_mark_hook
#define elf_backend_gc_sweep_hook               elf32_arm_gc_sweep_hook
#define elf_backend_check_relocs                elf32_arm_check_relocs
#define elf_backend_relocate_section		elf32_arm_relocate_section
#define elf_backend_write_section		elf32_arm_write_section
#define elf_backend_adjust_dynamic_symbol	elf32_arm_adjust_dynamic_symbol
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
#define elf_backend_finish_dynamic_symbol	elf32_arm_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections	elf32_arm_finish_dynamic_sections
#define elf_backend_link_output_symbol_hook	elf32_arm_output_symbol_hook
#define elf_backend_size_dynamic_sections	elf32_arm_size_dynamic_sections
#define elf_backend_post_process_headers	elf32_arm_post_process_headers
#define elf_backend_reloc_type_class		elf32_arm_reloc_type_class
#define elf_backend_object_p			elf32_arm_object_p
#define elf_backend_section_flags		elf32_arm_section_flags
#define elf_backend_fake_sections  		elf32_arm_fake_sections
#define elf_backend_section_from_shdr  		elf32_arm_section_from_shdr
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol

#define elf_backend_can_refcount    1
#define elf_backend_can_gc_sections 1
#define elf_backend_plt_readonly    1
#define elf_backend_want_got_plt    1
#define elf_backend_want_plt_sym    0
#if !USE_REL
#define elf_backend_rela_normal     1
#endif

#define elf_backend_got_header_size	12

#include "elf32-target.h"
@


1.155
log
@2004-10-27  Richard Earnshaw  <rearnsha@@arm.com>

bfd/
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Handle
	R_ARM_CALL and R_ARM_JUMP24 as aliases of R_ARM_PC24.
	(elf32_arm_final_link_relocate): Ditto.
	(arm_add_to_rel, elf32_arm_relocate_section): Ditto.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto
	(elf32_arm_adjust_dynamic_symbol): Ditto.
	* elfarm-nabi.c (elf32_arm_howto_table): Add R_ARM_CALL and
	R_ARM_JUMP32.  Move R_ARM_R{REL32,ABS32,PC24,BASE}...
	(elf32_arm_r_howto): ... To here.
	(elf32_arm_howto_from_type): Use elf32_arm_r_howto.
include/
	* elf/arm.h: Add R_ARM_CALL and R_ARM_JUMP32.
@
text
@@


1.154
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d830 4
d871 4
d1306 2
d1357 4
d1433 2
d2047 4
d2211 4
d2888 2
d3033 2
d3053 4
d3082 2
d3373 3
a3375 3
       needed for an R_ARM_PC24 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
@


1.153
log
@	* elf32-arm.h (elf32_arm_finish_dynamic_sections): Use file
	offsets, not VMAs, for DT_VERSYM, DT_VERDEF, DT_VERNEED.

	* scripttempl/armbpabi.sc: Do not put .gnu.version.* into a
	loadable segment.
@
text
@d2268 3
a2270 2
			(info, name, howto->name, (bfd_vma) 0,
			 input_bfd, input_section, rel->r_offset))))
@


1.152
log
@	* elf32-arm.h (elf32_arm_finish_dynamic_symbol): Make .rel.plt
	relocations use a virtual address, not a section offset.
@
text
@d4050 10
a4059 1
	      
@


1.151
log
@	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Rephrase error
	message.
@
text
@d3856 2
a3857 1
	  rel.r_offset = (splt->output_offset
@


1.150
log
@2004-10-12  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.h: Support EABI version 4 objects.
binutils/
	* readelf.c (decode_ARM_machine_flags): Support EABI version 4.
gas/
	* config/tc-arm.c (md_begin): Change EF_ARM_EABI_VER3 to
	EF_ARM_EABI_VER4.
	(arm_eabis): Ditto.
	* doc/c-arm.texi: Document that we actually support -meabi=4, not
	-meabi=3.
include/
	* elf/arm.h (EF_ARM_EABI_VER4): Define.
@
text
@d2507 1
a2507 1
	(_("ERROR: %B is compiled for EABI version %d, whereas %B is compiled for version %d"),
@


1.149
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d28 1
a28 1
/* In lieu of proper flags, assume all EABIv3 objects are interworkable.  */
d30 1
a30 1
  (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) == EF_ARM_EABI_VER3 \
d2708 4
@


1.148
log
@apply mising piece of previous patch
@
text
@d28 1
a28 1
/* In leiu of proper flags, assume all EABIv3 objects are interworkable.  */
d2331 1
d3167 8
d4474 1
@


1.147
log
@Skip redundant/bogus test for section membership when examining symbols.
@
text
@d3204 1
a3204 1
	  if (q->symbol.section == section
@


1.146
log
@The patch below adds binutils support for the SHT_ARM_EXIDX, as defined by
 the ARM EABI.
@
text
@a3188 3
      if (bfd_get_section (&q->symbol) != section)
	continue;

@


1.145
log
@bfd/
	* elf32-arm.h (bfd_elf32_arm_set_target_relocs): Handle "abs"
	target2 relocation type.
ld/
	* ld.texinfo: Document --target2=abs.
	* emulparms/armsymbian.sh (TARGET2_TYPE): Set.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add test for --target2=abs.
	* ld-arm/arm-target2-abs.d: New file.
@
text
@a4237 3
static bfd_boolean elf32_arm_section_flags           (flagword *, const Elf_Internal_Shdr *);
static void        elf32_arm_final_write_processing  (bfd *, bfd_boolean);

d4255 59
d4485 2
@


1.144
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add prototype.
	(bfd_elf32_arm_process_before_allocation): Update prototype.
	* bfd-in2.h: Regenerate.
	* bfd/elf32-arm.h (elf32_arm_link_hash_table): Add target2_reloc.
	(elf32_arm_link_hash_table_create): Set it.
	(bfd_elf32_arm_process_before_allocation): Remove target1_is_rel.
	(bfd_elf32_arm_set_target_relocs): New function.
	(arm_real_reloc_type): New function.
	(elf32_arm_final_link_relocate): Use it.  Handle R_ARM_PREL31 and
	R_ARM_GOT_PREL.  Remove R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook): Ditto.
	(elf32_arm_check_relocs): Ditto.
	(elf32_arm_relocate_section): Handle R_ARM_GOT_PREL.
	* elfarm-nabi.c (elf32_arm_howto_table): Add R_ARM_PREL31 and
	R_ARM_GOT_TARGET2.
	(elf32_arm_got_prel): New variable.
	(elf32_arm_howto_from_type): New function.
	(elf32_arm_info_to_howto): Use it.
	(elf32_arm_reloc_map): Add BFD_RELOC_ARM_PREL31 and
	BFD_RELOC_ARM_TARGET2.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_TARGET2 and BFD_RELOC_ARM_PREL31.
gas/
	* config/tc-arm.c (s_arm_rel31): New funciton.
	(md_pseudo_table): Add .rel31.
	(md_apply_fix3): Handle BFD_RELOC_ARM_TARGET2,
	BFD_RELOC_32_PCREL and BFD_RELOC_ARM_PREL31.
	(tc_gen_reloc): Handle BFD_RELOC_ARM_PREL31 and BFD_RELOC_ARM_TARGET2.
	(arm_fix_adjustable): Return 0 for BFD_RELOC_ARM_TARGET2.
	(arm_parse_reloc): Add (target2).
gas/testsuite/
	* gas/arm/pic.s: Add (target2).
	* gas/arm/pic.d: Ditto.
include/
	* elf/arm.h: Remove R_ARM_STKCHK and R_ARM_THM_STKCHK.
	Add R_ARM_TARGET2, R_ARM_PREL31, R_ARM_GOT_ABS, R_ARM_GOT_PREL,
	R_ARM_GOT_BREL12, R_ARM_GOTOFF12 and R_ARM_GOTRELAX.
ld/
	* ld.texinfo: Rename arm-specific section.  Document --target*
	* emulparams/armelf_fbsd.sh: Set TARGET2_TYPE.
	* emulparams/armelf_linux.sh: Ditto.
	* emulparams/armelf_nbsd.sh: Ditto.
	* emultempl/armelf.em: Set default for TARGET2_TYPE.
	(target2_type): New variable.
	(arm_elf_before_allocation): Don't pass target1_type.
	(arm_elf_create_output_section_statements): New function.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_TARGET2.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add --target=.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_TARGET2.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Set.
	* emultempl/armelf_oabi.em (_before_allocation): Remove extra
	argument to bfd_elf32_arm_process_before_allocation.
ld/testsuite/
	* ld-arm/arm-target1-{abs,rel}.d}: New files.
	* ld-arm/arm-target1.s: New file.
	* ld-arm/arm-target2-{,got-}rel.d: New files.
	* ld-arm/arm-target2.s: New file.
	* ld-arm/arm-rel31.d: New files.
	* ld-arm/arm-rel31.s: New files.
	* ld-arm/arm.ld: New file.
	* ld-arm/arm-elf.exp: Add new tests.
@
text
@d928 2
@


1.143
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d189 3
d384 1
d764 1
a764 2
					 int byteswap_code,
					 int target1_is_rel)
d787 1
a787 1
  globals->target1_is_rel = target1_is_rel;
d912 26
d1183 26
d1244 3
a1246 9
  if (r_type == R_ARM_TARGET1)
    {
      if (globals->target1_is_rel)
	r_type = R_ARM_REL32;
      else
	r_type = R_ARM_ABS32;
      
      howto = &elf32_arm_howto_table[r_type];
    }
d1297 1
d1310 5
a1314 1
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
d1336 5
a1340 2
	  && (r_type != R_ARM_REL32
	      || !SYMBOL_CALLS_LOCAL (info, h))
d1540 18
d1847 3
d1938 2
d2213 3
d2812 3
d2824 26
a2849 16
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GOT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d2851 4
a2854 2
      case R_ARM_ABS32:
      case R_ARM_REL32:
d2856 1
a2856 1
      case R_ARM_TARGET1:
d2858 6
a2863 8
      case R_ARM_PC24:
      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_arm_link_hash_entry *eh;
	    struct elf32_arm_relocs_copied **pp;
	    struct elf32_arm_relocs_copied *p;
d2865 1
a2865 1
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d2867 2
a2868 2
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d2870 1
a2870 1
	    if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
d2872 1
a2872 1
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1
d2874 3
a2876 3
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
	      {
		eh = (struct elf32_arm_link_hash_entry *) h;
d2878 12
a2889 12
		for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		     pp = &p->next)
		if (p->section == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	      }
	  }
	break;
d2891 4
a2894 3
      default:
	break;
      }
d2937 1
d2940 4
d2949 1
a2949 1
      switch (ELF32_R_TYPE (rel->r_info))
d2952 3
d2979 3
a2981 1
	    break;
d2996 2
d2999 1
a2999 1
	  case R_ARM_TARGET1:
a3000 2
	  case R_ARM_PC24:
	  case R_ARM_PLT32:
d3016 2
a3017 2
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_PLT32)
d3039 2
a3040 2
		&& ((ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32
d3042 1
a3042 1
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_TARGET1
d3044 1
a3044 1
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32)
d3127 1
a3127 1
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
d3129 1
a3129 1
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1
d3131 1
a3131 1
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
@


1.142
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d3190 1
a3190 1
		  || h->weakdef != NULL
d3228 1
a3228 1
  if (h->weakdef != NULL)
d3230 4
a3233 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.141
log
@bfd/
	* elf32-arm.h (elf32_arm_gc_sweep_hook): Add #ifndef OLD_ARM_ABI
	around uses of R_ARM_TARGET1.
	(elf32_arm_check_relocs): Likewise.
ld/
	* emultempl/armelf_oabi.em (before_allocation): Add extra zero param
	to bfd_elf32_arm_process_before_allocation call.
@
text
@d1333 1
a1333 2
		       || (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2114 2
a2115 4
	              && (
			  (!info->symbolic && h->dynindx != -1)
	                  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
			  )
d2123 1
a2123 2
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d2138 1
a2138 2
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2903 1
a2903 1
		  h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d2911 1
a2911 1
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2940 1
a2940 2
			    || (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0))))
d3189 1
a3189 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d3191 3
a3193 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d3199 1
a3199 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d3212 1
a3212 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3270 1
a3270 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d3326 1
a3326 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3350 1
a3350 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3370 1
a3370 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3376 1
a3376 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3387 1
a3387 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3433 3
a3435 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3443 1
a3443 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3794 1
a3794 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3803 1
a3803 2
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
d3847 1
a3847 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.140
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-arm.h (elf32_arm_link_hash_table): Add target1_is_rel.
	(elf32_arm_link_hash_table_create): Set target1_is_rel.
	(bfd_elf32_arm_process_before_allocation): Ditto.
	(elf32_arm_final_link_relocate): Handle R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* elfarm-nabi.c (elf32_arm_howto_table): Rename RELABS to TARGET1.
	* reloc.c: Ditto.
gas/
	* config/tc-arm.c: Rename RELABS to TARGET1.
gas/testsuite/
	* gas/arm/pic.d: Rename RELABS to TARGET1.
	* gas/arm/pic.s: Ditto.
include/
	* elf/arm.h: Rename RELABS to TARGET1.
ld/
	* emulparams/armsymbian.sh: Set TARGET1_IS_REL.
	* emultempl/armelf.em: Use TARGET1_IS_REL.  Add --target1-{rel,abs}.
@
text
@d2762 1
d2764 1
d2780 4
a2783 2
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1)
d2894 1
d2896 1
d2939 4
a2942 2
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_TARGET1)
d3027 4
a3030 2
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1)
@


1.139
log
@	* elf-bfd.h (_bfd_elf_make_dynamic_segment): Declare it.
	* elf.c (_bfd_elf_make_dynamic_segment): New function, split out
	from ...
	(map_sections_to_segments): ... here.  Use it.  Assign a file
	position to the .dynamic section if it is not loadable, but part
	of the PT_DYNAMIC segment.
	* elf32-arm.h (elf32_arm_finish_dynamic_sections): Use file
	offsets, not VMAs, for the BPABI.  Do not fill in the header in
	the .got.plt section for the BPABI.
	* elfarm-nabi.c (elf32_arm_symbian_modify_segment_map): Add a
	PT_DYNAMIC segment.
	(elf_backend_want_got_plt): Define to zero for Symbian OS.

	* emulparams/armsymbian.sh: Use armbpabi script.
	* scripttempl/armbpabi.sc: New script.
@
text
@d185 4
d380 1
d760 2
a761 1
					 int byteswap_code)
d784 1
d1184 16
a1211 2
  globals = elf32_arm_hash_table (info);

d2762 1
d2778 2
a2779 1
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
d2890 1
d2933 2
a2934 1
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32)
d3019 2
a3020 1
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
@


1.138
log
@	* config.bfd (arm*-*-symbianelf*): Use OS-specific target vectors.
	* configure.in (bfd_elf32_bigarm_symbian_vec): Add it.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	* configure: Regenerated.
	* elf-bfd.h (elf_backend_data): Add dynamic_sec_flags.
	* elf32-arm.h (PLT_HEADER_SIZE): Do not define.
	(PLT_ENTRY_SIZE): Likewise.
	(bfd_vma_elf32_arm_symbian_plt_entry): New
	variable.
	(elf32_arm_link_hash_table): Add plt_header_size, plt_entry_size,
	and symbian_p.
	(create_got_section): Don't create sections when generating BPABI
	objects.
	(elf32_arm_create_dynamic_sections): Tidy.
	(elf32_arm_link_hash_table_create): Set plt_header_size,
	plt_entry_size, and symbian_p.
	(elf32_arm_check_relocs): Do not mark .rel.dyn as loadable when
	generating BPABI objects.
	(allocate_dynrelocs): Use htab->plt_header_size, not
	PLT_HEADER_SIZE.  Do not add to .got.plt when
	generating BPABI objects.
	(elf32_arm_finish_dynamic_symbol): Generate Symbian OS PLTs.
	* elfarm-nabi.c: Add SymbianOS target vectors.
	* elflink.c (_bfd_elf_create_got_section): Use dynamic_sec_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elfxx-target.h (ELF_DYNAMIC_SEC_FLAGS): New macro.
	(elfNN_bed): Use it.
	* targets.c (bfd_elf32_bigarm_symbian_vec): New variable.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(_bfd_target_vector): Add them.

	* Makefile.am (TARG_ENV_HFILES): Add te-symbian.h.
	* Makefile.in: Regenerated.
	* configure.in: Set em for arm*-*-symbianelf*.
	* configure: Regenerated.
	* config/tc-arm.c (elf32_arm_target_format): Use Symbian target
	vectors when appropriate.
	* config/te-symbian.h: New file.

	* Makefile.am (ALL_EMULATIONS): Add earmsymbian.o.
	(earmsymbian.c): New target.
	* configure.tgt: Use armsymbian emulation for arm*-*-symbianelf*.
	* Makefile.in: Regenerated.
	* aclocal.m4: Likewise.
	* configure: Likewise.
	* emulparams/armsymbian.sh: New file.
@
text
@d3864 1
a3864 1
  BFD_ASSERT (sgot != NULL);
d3871 1
d3873 1
d3890 2
d3895 10
d3913 7
a3919 1
	      dyn.d_un.d_ptr = s->vma;
d3923 5
d3934 20
d3955 33
a3987 14
	    case DT_RELSZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_REL).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELSZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rel.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_REL entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rel.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4048 1
a4048 1
  if (sgot->size > 0)
d4050 13
a4062 8
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
a4064 2
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

@


1.137
log
@	* INTERWORK_FLAG: Return true for EABIv3 objects.
@
text
@a48 7
/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 16

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 16

d53 1
a53 1
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
d63 1
a63 1
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
a72 7
/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 20

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12

d77 1
a77 1
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
d88 1
a88 1
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
d97 8
d185 9
d242 5
a249 1
  htab = elf32_arm_hash_table (info);
d288 3
a290 1
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
d376 8
d2943 4
a2946 1
		        if ((sec->flags & SEC_ALLOC) != 0)
d3313 1
a3313 1
	    s->size += PLT_HEADER_SIZE;
d3330 1
a3330 1
	  s->size += PLT_ENTRY_SIZE;
d3332 4
a3335 3
	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->size += 4;
d3366 12
a3377 9
      s = htab->sgot;
      h->got.offset = s->size;
      s->size += 4;
      dyn = htab->root.dynamic_sections_created;
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->size += sizeof (Elf32_External_Rel);
d3671 1
d3674 1
a3678 1
      asection * sgot;
d3680 1
a3681 1
      bfd_vma got_offset;
a3682 2
      bfd_byte *loc;
      bfd_vma got_displacement;
a3689 1
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d3691 1
a3691 1
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
d3697 30
a3726 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d3728 9
a3736 14
      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Calculate the displacement between the PLT slot and the
	 entry in the GOT.  */
      got_displacement = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset
			  - splt->output_section->vma
			  - splt->output_offset
			  - h->plt.offset
			  - 8);
d3738 1
a3738 1
      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);
d3740 6
a3745 7
      /* Fill in the entry in the procedure linkage table.  */
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
		  splt->contents + h->plt.offset + 0);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
		  splt->contents + h->plt.offset + 8);
d3747 2
a3748 2
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		  splt->contents + h->plt.offset + 12);
d3751 12
a3762 5
      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset),
		  sgot->contents + got_offset);
a3763 5
      /* Fill in the entry in the .rel.plt section.  */
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + got_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_JUMP_SLOT);
d3954 1
a3954 1
      if (splt->size > 0)
@


1.136
log
@(is_arm_mapping_symbol_name): New function - return true when a symbol name
 matches the requirements for an ARM mapping symbol name.
(arm_elf_find_function): New function based on elf_find_function in elf.c but
 skipping ARM mapping symbols and including thumb function symbols.
(elf32_arm_find_nearest_line): Use arm_elf_find_function.
(elf32_arm_output_symbol_hook): Use is_arm_mapping_symbol_name.
@
text
@d28 1
d30 2
a31 1
  (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK)
@


1.135
log
@Convert file to ISO C90
@
text
@a2995 4
/* Find the nearest line to a particular section and offset, for error
   reporting.   This code is a duplicate of the code in elf.c, except
   that it also accepts STT_ARM_TFUNC as a symbol that names a function.  */

d2997 1
a2997 7
elf32_arm_find_nearest_line (bfd *          abfd,
			     asection *     section,
			     asymbol **     symbols,
			     bfd_vma        offset,
			     const char **  filename_ptr,
			     const char **  functionname_ptr,
			     unsigned int * line_ptr)
d2999 5
a3003 5
  bfd_boolean found;
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;
d3005 3
a3007 5
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return TRUE;
d3009 12
a3020 15
  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return FALSE;

  if (found)
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  filename = NULL;
  func = NULL;
  low_func = 0;
a3037 1
	case STT_NOTYPE:
d3040 6
d3060 55
a3114 2
  *filename_ptr = filename;
  *functionname_ptr = bfd_asymbol_name (func);
a3115 1

d4032 1
a4032 5
  if (name == NULL
      || name[0] != '$'
      || (name[1] != 'a'
	  && name[1] != 't'
	  && name[1] != 'd'))
a4192 1

@


1.134
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d28 2
a29 86
static bfd_boolean elf32_arm_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean elf32_arm_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_arm_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_arm_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static int elf32_arm_get_symbol_type
  PARAMS (( Elf_Internal_Sym *, int));
static struct bfd_link_hash_table *elf32_arm_link_hash_table_create
  PARAMS ((bfd *));
static bfd_reloc_status_type elf32_arm_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma, struct bfd_link_info *, asection *,
	   const char *, int, struct elf_link_hash_entry *));
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
static struct elf_link_hash_entry *find_thumb_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
static struct elf_link_hash_entry *find_arm_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
static void elf32_arm_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));
static int elf32_arm_to_thumb_stub
  PARAMS ((struct bfd_link_info *, const char *, bfd *, bfd *, asection *,
	   bfd_byte *, asection *, bfd_vma, bfd_signed_vma, bfd_vma));
static int elf32_thumb_to_arm_stub
  PARAMS ((struct bfd_link_info *, const char *, bfd *, bfd *, asection *,
	   bfd_byte *, asection *, bfd_vma, bfd_signed_vma, bfd_vma));
static bfd_boolean elf32_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static asection * elf32_arm_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_arm_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static bfd_boolean elf32_arm_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf32_arm_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf32_arm_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf32_arm_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static struct bfd_hash_entry * elf32_arm_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
#if USE_REL
static void arm_add_to_rel
  PARAMS ((bfd *, bfd_byte *, reloc_howto_type *, bfd_signed_vma));
#endif
static bfd_boolean allocate_dynrelocs 
  PARAMS ((struct elf_link_hash_entry *h, PTR inf));
static bfd_boolean create_got_section 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static bfd_boolean elf32_arm_create_dynamic_sections 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static enum elf_reloc_type_class elf32_arm_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_object_p
  PARAMS ((bfd *));

#ifndef ELFARM_NABI_C_INCLUDED
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int, int));
#endif


#define INTERWORK_FLAG(abfd)   (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK)
d160 1
a160 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d205 3
a207 4
elf32_arm_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry * entry;
     struct bfd_hash_table * table;
     const char * string;
d215 2
a216 4
    ret = ((struct elf32_arm_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_arm_link_hash_entry)));
  if (ret == (struct elf32_arm_link_hash_entry *) NULL)
d223 1
a223 1
  if (ret != (struct elf32_arm_link_hash_entry *) NULL)
d233 1
a233 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d262 1
a262 3
elf32_arm_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d337 1
a337 2
elf32_arm_link_hash_table_create (abfd)
     bfd *abfd;
d342 2
a343 2
  ret = (struct elf32_arm_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf32_arm_link_hash_table *) NULL)
d346 1
a346 1
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
d373 3
a375 4
find_thumb_glue (link_info, name, input_bfd)
     struct bfd_link_info *link_info;
     const char *name;
     bfd *input_bfd;
d384 2
a385 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d407 3
a409 4
find_arm_glue (link_info, name, input_bfd)
     struct bfd_link_info *link_info;
     const char *name;
     bfd *input_bfd;
d418 2
a419 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d475 1
a475 2
bfd_elf32_arm_allocate_interworking_sections (info)
     struct bfd_link_info * info;
d494 1
a494 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);
d509 1
a509 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);
d519 2
a520 3
record_arm_to_thumb_glue (link_info, h)
     struct bfd_link_info * link_info;
     struct elf_link_hash_entry * h;
d540 1
a540 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d556 3
a558 3
  /* The only trick here is using hash_table->arm_glue_size as the value. Even
     though the section isn't allocated yet, this is where we will be putting
     it.  */
d573 2
a574 3
record_thumb_to_arm_glue (link_info, h)
     struct bfd_link_info *link_info;
     struct elf_link_hash_entry *h;
d595 2
a596 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d629 2
a630 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (CHANGE_TO_ARM) + 1);
d653 2
a654 3
bfd_elf32_arm_add_glue_sections_to_bfd (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d689 2
a690 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;
d710 1
a710 3
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d733 4
a736 7
bfd_elf32_arm_process_before_allocation (abfd, link_info,
					 no_pipeline_knowledge,
					 byteswap_code)
     bfd *abfd;
     struct bfd_link_info *link_info;
     int no_pipeline_knowledge;
     int byteswap_code;
d782 1
a782 1
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
d813 1
a813 1
		  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d915 1
a915 3
insert_thumb_branch (br_insn, rel_off)
     insn32 br_insn;
     int rel_off;
d932 1
a932 1
    abort ();			/* error - not a valid branch instruction form.  */
d940 10
a949 12
elf32_thumb_to_arm_stub (info, name, input_bfd, output_bfd, input_section,
			 hit_data, sym_sec, offset, addend, val)
     struct bfd_link_info * info;
     const char *           name;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             hit_data;
     asection *             sym_sec;
     bfd_vma                offset;
     bfd_signed_vma         addend;
     bfd_vma                val;
d1003 2
a1004 1
	   /* Offset from the start of the current section to the start of the stubs.  */
d1027 2
a1028 1
    - (input_section->output_section->vma + input_section->output_offset + offset)
d1047 10
a1056 12
elf32_arm_to_thumb_stub (info, name, input_bfd, output_bfd, input_section,
			 hit_data, sym_sec, offset, addend, val)
     struct bfd_link_info * info;
     const char *           name;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             hit_data;
     asection *             sym_sec;
     bfd_vma                offset;
     bfd_signed_vma         addend;
     bfd_vma                val;
d1131 12
a1142 15
elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
			       input_section, contents, rel, value,
			       info, sym_sec, sym_name, sym_flags, h)
     reloc_howto_type *     howto;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             contents;
     Elf_Internal_Rela *    rel;
     bfd_vma                value;
     struct bfd_link_info * info;
     asection *             sym_sec;
     const char *           sym_name;
     int		    sym_flags;
     struct elf_link_hash_entry * h;
d1342 3
a1344 2
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd, output_bfd,
					   input_section, hit_data, sym_sec, rel->r_offset,
d1372 3
a1374 2
		 P is the base address of the section containing the instruction
		   plus the offset of the reloc into that section, ie:
d1382 2
a1383 2
		 size of the processor, thus it is up to the assembler to encode
		 this information into the addend.  */
d1389 6
a1394 5
	      /* Previous versions of this code also used to add in the pipeline
		 offset here.  This is wrong because the linker is not supposed
		 to know about such things, and one day it might change.  In order
		 to support old binaries that need the old behaviour however, so
		 we attempt to detect which ABI was used to create the reloc.  */
d1858 4
a1861 5
arm_add_to_rel (abfd, address, howto, increment)
     bfd *              abfd;
     bfd_byte *         address;
     reloc_howto_type * howto;
     bfd_signed_vma     increment;
d1929 8
a1936 10
elf32_arm_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d2061 1
a2061 1
	  
d2192 1
a2192 2
elf32_arm_object_p (abfd)
     bfd *abfd;
d2195 1
a2195 1
  
d2212 1
a2212 3
elf32_arm_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d2241 1
a2241 3
elf32_arm_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2292 1
a2292 3
elf32_arm_merge_private_bfd_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
d2497 1
a2497 3
elf32_arm_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d2621 1
a2621 3
elf32_arm_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym * elf_sym;
     int type;
d2645 5
a2649 6
elf32_arm_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
d2683 4
a2686 5
elf32_arm_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d2764 2
a2765 5
elf32_arm_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2825 2
a2826 3
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
d2946 1
a2946 1
		    
d2952 1
a2952 1
		    
d2956 1
a2956 1
		
d2961 1
d2970 1
a2970 1
		
d3001 7
a3007 9
elf32_arm_find_nearest_line
  (abfd, section, symbols, offset, filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d3084 2
a3085 3
elf32_arm_adjust_dynamic_symbol (info, h)
     struct bfd_link_info * info;
     struct elf_link_hash_entry * h;
d3210 1
a3210 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d3378 2
a3379 3
elf32_arm_size_dynamic_sections (output_bfd, info)
     bfd * output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info * info;
d3470 1
a3470 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d3599 2
a3600 5
elf32_arm_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd * output_bfd;
     struct bfd_link_info * info;
     struct elf_link_hash_entry * h;
     Elf_Internal_Sym * sym;
d3667 1
a3667 1
      
d3764 1
a3764 3
elf32_arm_finish_dynamic_sections (output_bfd, info)
     bfd * output_bfd;
     struct bfd_link_info * info;
d3911 1
a3911 3
elf32_arm_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
d3930 1
a3930 2
elf32_arm_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d3945 2
a3946 2
static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, const Elf_Internal_Shdr *));
static void        elf32_arm_final_write_processing  PARAMS ((bfd *, bfd_boolean));
d3951 1
a3951 3
elf32_arm_section_flags (flags, hdr)
     flagword *flags;
     const Elf_Internal_Shdr *hdr;
d3960 1
a3960 3
elf32_arm_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d4003 1
a4003 1
  
d4051 1
a4051 1
  
d4069 1
a4069 1
      
@


1.133
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d489 2
a490 2
    (*_bfd_error_handler) (_("%s: unable to find THUMB glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);
d524 2
a525 2
    (*_bfd_error_handler) (_("%s: unable to find ARM glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);
d866 2
a867 3
      _bfd_error_handler (
	  _("%s: BE8 images only valid in big-endian mode."),
	  bfd_archive_filename (abfd));
d1092 3
a1094 5
	    (_("%s(%s): warning: interworking not enabled."),
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
	    (_("  first occurrence: %s: thumb call to arm"),
	     bfd_archive_filename (input_bfd));
d1197 3
a1199 5
	    (_("%s(%s): warning: interworking not enabled."),
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
	    (_("  first occurrence: %s: arm call to thumb"),
	     bfd_archive_filename (input_bfd));
d1443 4
a1446 4
		(*_bfd_error_handler) (_("\
%s: Warning: Arm BLX instruction targets Arm function '%s'."),
				       bfd_archive_filename (input_bfd),
				       h ? h->root.root.string : "(local)");
d1639 4
a1642 4
	      (*_bfd_error_handler) (_("\
%s: Warning: Thumb BLX instruction targets thumb function '%s'."),
				     bfd_archive_filename (input_bfd),
				     h ? h->root.root.string : "(local)");
d2134 2
a2135 3
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
d2222 2
a2223 2
		      (_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
		       bfd_archive_filename (input_bfd),
d2225 1
a2225 2
		       h->root.root.string,
		       bfd_get_section_name (input_bfd, input_section));
d2335 3
a2337 3
	    (*_bfd_error_handler) (_("\
Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
				   bfd_archive_filename (abfd));
d2339 3
a2341 3
	    _bfd_error_handler (_("\
Warning: Clearing the interworking flag of %s due to outside request"),
				bfd_archive_filename (abfd));
d2387 3
a2389 4
	    _bfd_error_handler (_("\
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
				bfd_get_filename (obfd),
				bfd_archive_filename (ibfd));
d2504 5
a2508 6
      _bfd_error_handler (_("\
ERROR: %s is compiled for EABI version %d, whereas %s is compiled for version %d"),
			  bfd_archive_filename (ibfd),
			  (in_flags & EF_ARM_EABIMASK) >> 24,
			  bfd_get_filename (obfd),
			  (out_flags & EF_ARM_EABIMASK) >> 24);
d2517 5
a2521 6
	  _bfd_error_handler (_("\
ERROR: %s is compiled for APCS-%d, whereas target %s uses APCS-%d"),
			      bfd_archive_filename (ibfd),
			      in_flags & EF_ARM_APCS_26 ? 26 : 32,
			      bfd_get_filename (obfd),
			      out_flags & EF_ARM_APCS_26 ? 26 : 32);
d2528 3
a2530 4
	    _bfd_error_handler (_("\
ERROR: %s passes floats in float registers, whereas %s passes them in integer registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2532 3
a2534 4
	    _bfd_error_handler (_("\
ERROR: %s passes floats in integer registers, whereas %s passes them in float registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2542 3
a2544 4
	    _bfd_error_handler (_("\
ERROR: %s uses VFP instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2546 3
a2548 4
	    _bfd_error_handler (_("\
ERROR: %s uses FPA instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2556 3
a2558 4
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2560 3
a2562 4
	    _bfd_error_handler (_("\
ERROR: %s does not use Maverick instructions, whereas %s does"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
d2579 3
a2581 4
		_bfd_error_handler (_("\
ERROR: %s uses software FP, whereas %s uses hardware FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));
d2583 3
a2585 4
		_bfd_error_handler (_("\
ERROR: %s uses hardware FP, whereas %s uses software FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));
d2597 3
a2599 4
	      _bfd_error_handler (_("\
Warning: %s supports interworking, whereas %s does not"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
d2603 3
a2605 4
	      _bfd_error_handler (_("\
Warning: %s does not support interworking, whereas %s does"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
@


1.132
log
@	* elf32-arm.h (elf32_arm_relocate_section): Remove R_ARM_PLT32
	special case.
@
text
@d592 1
a592 1
      s->_raw_size = s->_cooked_size = globals->arm_glue_size;
d608 1
a608 1
      s->_raw_size = s->_cooked_size = globals->thumb_glue_size;
d919 1
a919 6
		  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
		  if (contents == NULL)
		    goto error_return;

		  if (!bfd_get_section_contents (abfd, sec, contents,
						 (file_ptr) 0, sec->_raw_size))
d3329 1
a3329 1
      srel->_raw_size += sizeof (Elf32_External_Rel);
d3340 1
a3340 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d3349 1
a3349 1
  h->root.u.def.value = s->_raw_size;
d3352 1
a3352 1
  s->_raw_size += h->size;
d3401 2
a3402 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_HEADER_SIZE;
d3404 1
a3404 1
	  h->plt.offset = s->_raw_size;
d3419 1
a3419 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d3423 1
a3423 1
	  htab->sgotplt->_raw_size += 4;
d3426 1
a3426 1
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rel);
d3455 2
a3456 2
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
d3462 1
a3462 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rel);
d3522 1
a3522 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rel);
d3553 1
a3553 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d3592 1
a3592 1
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rel);
d3612 2
a3613 2
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
d3615 1
a3615 1
		srel->_raw_size += sizeof (Elf32_External_Rel);
d3647 1
a3647 1
	  if (s->_raw_size == 0)
d3661 1
a3661 1
	  if (s->_raw_size == 0)
d3699 2
a3700 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d3944 1
a3944 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d3974 1
a3974 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d3990 1
a3990 6
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
d4022 1
a4022 1
      if (splt->_raw_size > 0)
d4052 1
a4052 1
  if (sgot->_raw_size > 0)
d4232 1
a4232 1
	end = bfd_section_size (output_bfd, sec);
@


1.131
log
@	* elf64-alpha.c (elf64_alpha_read_ecoff_info): Don't assign
	structure field removed in 2004-04-24 patch.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): Warning fix.

	* elf-bfd.h (struct elf_backend_data <elf_backend_section_flags>):
	Constify hdr arg.
	* elf32-arm.h (elf32_arm_section_flags): Likewise.
	* elf64-alpha.c (elf64_alpha_section_flags): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_flags): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set the bfd_section
	field before calling elf_backend_section_flags.
@
text
@d2195 2
a2226 5
	            relocation = 0;
		  break;

	        case R_ARM_PLT32:
	          if (h->plt.offset != (bfd_vma)-1)
@


1.130
log
@2004-04-21  Philip Blundell  <pb@@nexus.co.uk>

	* elf32-arm.h (elf32_arm_check_relocs): Don't output REL32
	relocs for locally defined symbols during -shared final link.
	(elf32_arm_final_link_relocate): Likewise.
@
text
@d4124 1
a4124 1
static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, Elf_Internal_Shdr *));
d4132 1
a4132 1
     Elf_Internal_Shdr *hdr;
@


1.129
log
@2004-04-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.h (elf32_arm_final_link_relocate): Handle
	R_ARM_ALU* only if OLD_ARM_ABI is not defined.
@
text
@d1364 2
d3046 2
a3047 1
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32)
@


1.128
log
@This time the version of the patch that works.
	* bfd/elf32-arm.h (struct elf32_elf_section_map): New.
	(struct _arm_elf_section_data): New.
	(elf32_arm_section_data): Define.
	(struct elf32_arm_link_hash_table): Add byteswap_code.
	(elf32_arm_link_hash_table_create): Initialize byteswap_code.
	(bfd_elf32_arm_process_before_allocation): Add byteswap_code.
	(elf32_arm_post_process_headers): Set EF_ARM_BE8.
	(elf32_arm_output_symbol_hook, elf32_arm_new_section_hook,
	elf32_arm_compare_mapping, elf32_arm_write_section): New functions.
	(bfd_elf32_new_section_hook, elf_backend_write_section,
	elf_backend_link_output_symbol_hook): Define.
@
text
@d1770 1
d1795 1
@


1.127
log
@	* bfd/bfd-in.h (bfd_elf32_arm_process_before_allocation): Update.
	* bfd/elf32-arm.h (struct elf32_elf_section_map): New.
	(struct _arm_elf_section_data): New.
	(elf32_arm_section_data): Define.
	(struct elf32_arm_link_hash_table): Add byteswap_code.
	(elf32_arm_link_hash_table_create): Initialize byteswap_code.
	(bfd_elf32_arm_process_before_allocation): Add byteswap_code.
	(elf32_arm_post_process_headers): Set EF_ARM_BE8.
	(elf32_arm_output_symbol_hook, elf32_arm_new_section_hook,
	elf32_arm_compare_mapping, elf32_arm_write_section): New functions.
	(bfd_elf32_new_section_hook, elf_backend_write_section,
	elf_backend_link_output_symbol_hook): Define.
	* ld/emultempl/armelf.em (byteswap_code): Add.
	(arm_elf_before_allocation): Pass extra parameter.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_BE8.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add be8.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_BE8.
	* ld/emultempl/armelf_oabi.em: Pass extra parameter.
	* ld/ld.texinfo: Document --be8.
@
text
@d4094 6
a4099 3
  globals = elf32_arm_hash_table (link_info);
  if (globals->byteswap_code)
    i_ehdrp->e_flags |= EF_ARM_BE8;
d4281 1
a4281 1
  bfd_free (map);
@


1.126
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Add R_ARM_ALU*.
	* elfarm-nabi.c (elf32_arm_howto_table): Ditto.
@
text
@d109 1
a109 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d193 20
d270 3
d456 1
d835 3
a837 1
bfd_elf32_arm_process_before_allocation (abfd, link_info, no_pipeline_knowledge)
d841 1
d864 8
d4087 1
d4093 4
d4132 1
a4132 1
void
d4140 142
d4297 1
d4304 1
d4309 1
@


1.125
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d1735 25
@


1.124
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@a1211 12
/* This is the condition under which elf32_arm_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_arm_relocate_section
   and elf32_arm_final_link_relocate.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H)			\
  ((DYN)								\
   && ((SHARED)							 	\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d3071 1
a3071 1
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3078 1
a3078 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d3334 1
a3334 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d3394 1
a3394 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d3447 1
a3447 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
@


1.123
log
@	* bfd/elf32-arm.h (arm_print_private_bfd_data): Add EABI v3.
	* binutils/readelf.c (decode_ARM_machine_flags): Add EABI v3.
	* gas/config/tc-arm.c (meabi_flags): New variable.
	(arm_parse_eabi): New function.
	(md_begin): Set flags for EABI v3.
	(arm_eabis): Add.
	(arm_long_opts): Add meabi.
	* include/elf/arm.h (EF_ERM_BE8, EF_ARM_LE8, EF_ARM_EABI_VER3): Add.
	* doc/as.texinf <ARM>: Document -meabi.
	* doc/c-arm.texi: Ditto.
@
text
@d3668 1
a3668 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.122
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d2682 12
@


1.121
log
@Ignore data-only sections when checking interworking status
@
text
@d2128 4
a2131 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation,
				   sec, unresolved_reloc, info,
				   warned);
@


1.120
log
@	* elf32-arm.h (elf32_arm_check_relocs): Revert part of 2004-01-13
	change.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d2434 1
a2434 1
     elf_link_add_object_symbols.  */
d2436 4
d2443 1
d2451 5
d2460 2
a2461 1
      if (null_input_bfd)
@


1.120.4.1
log
@Merge from mainline
@
text
@d1211 12
d2127 4
a2130 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d3059 1
a3059 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3066 1
a3066 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d3322 1
a3322 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3382 1
a3382 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3435 1
a3435 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3644 1
a3644 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
@


1.120.4.2
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d2421 1
a2421 1
    elf_link_add_object_symbols.
a2422 4
    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
a2425 1
      bfd_boolean only_data_sections = TRUE;
a2432 5
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

d2437 1
a2437 2

      if (null_input_bfd || only_data_sections)
@


1.120.4.3
log
@2004-04-21  Philip Blundell  <pb@@nexus.co.uk>

	* elf32-arm.h (elf32_arm_check_relocs): Don't output REL32
	relocs for locally defined symbols during -shared final link.
	(elf32_arm_final_link_relocate): Likewise.
@
text
@a1328 2
	  && (r_type != R_ARM_REL32
	      || !SYMBOL_CALLS_LOCAL (info, h))
d2970 1
a2970 2
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32)
@


1.120.4.4
log
@	* elf32-arm.h (elf32_arm_relocate_section): Remove R_ARM_PLT32
	special case.
@
text
@a2132 2
	        case R_ARM_PLT32:

d2163 5
@


1.120.6.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d2127 4
a2130 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2433 1
a2433 1
    elf_link_add_object_symbols.
a2434 4
    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
a2437 1
      bfd_boolean only_data_sections = TRUE;
a2444 5
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

d2449 1
a2449 2

      if (null_input_bfd || only_data_sections)
a2669 12
    case EF_ARM_EABI_VER3:
      fprintf (file, _(" [Version3 EABI]"));

      if (flags & EF_ARM_BE8)
	fprintf (file, _(" [BE8]"));

      if (flags & EF_ARM_LE8)
	fprintf (file, _(" [LE8]"));

      flags &= ~(EF_ARM_LE8 | EF_ARM_BE8);
      break;

d3644 1
a3644 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
@


1.120.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d109 1
a109 1
  PARAMS ((bfd *, struct bfd_link_info *, int, int));
a192 20
/* Used to build a map of a section.  This is required for mixed-endian
   code/data.  */

typedef struct elf32_elf_section_map
{
  bfd_vma vma;
  char type;
}
elf32_arm_section_map;

struct _arm_elf_section_data
{
  struct bfd_elf_section_data elf;
  int mapcount;
  elf32_arm_section_map *map;
};

#define elf32_arm_section_data(sec) \
  ((struct _arm_elf_section_data *) elf_section_data (sec))

a249 3
    /* Nonzero to output a BE8 image.  */
    int byteswap_code;

a432 1
  ret->byteswap_code = 0;
d811 1
a811 3
bfd_elf32_arm_process_before_allocation (abfd, link_info,
					 no_pipeline_knowledge,
					 byteswap_code)
a814 1
     int byteswap_code;
a836 8
  if (byteswap_code && !bfd_big_endian (abfd))
    {
      _bfd_error_handler (
	  _("%s: BE8 images only valid in big-endian mode."),
	  bfd_archive_filename (abfd));
      return FALSE;
    }
  globals->byteswap_code = byteswap_code;
d1212 12
a1746 25
    case R_ARM_ALU_PCREL7_0:
    case R_ARM_ALU_PCREL15_8:
    case R_ARM_ALU_PCREL23_15:
      {
	bfd_vma insn;
	bfd_vma relocation;

	insn = bfd_get_32 (input_bfd, hit_data);
#if USE_REL
	/* Extract the addend.  */
	addend = (insn & 0xff) << ((insn & 0xf00) >> 7);
	signed_addend = addend;
#endif
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
	insn = (insn & ~0xfff)
	       | ((howto->bitpos << 7) & 0xf00)
	       | ((relocation >> howto->bitpos) & 0xff);
	bfd_put_32 (input_bfd, value, hit_data);
      }
      return bfd_reloc_ok;

d3083 1
a3083 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3090 1
a3090 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d3346 1
a3346 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3406 1
a3406 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3459 1
a3459 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
a4038 1
  struct elf32_arm_link_hash_table *globals;
a4043 7

  if (link_info)
    {
      globals = elf32_arm_hash_table (link_info);
      if (globals->byteswap_code)
	i_ehdrp->e_flags |= EF_ARM_BE8;
    }
d4079 1
a4079 1
static void
a4086 142

/* Called for each symbol.  Builds a section map based on mapping symbols.
   Does not alter any of the symbols.  */

static bfd_boolean
elf32_arm_output_symbol_hook (struct bfd_link_info *info,
			      const char *name,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  int mapcount;
  elf32_arm_section_map *map;
  struct elf32_arm_link_hash_table *globals;

  /* Only do this on final link.  */
  if (info->relocatable)
    return TRUE;

  /* Only build a map if we need to byteswap code.  */
  globals = elf32_arm_hash_table (info);
  if (!globals->byteswap_code)
    return TRUE;

  /* We only want mapping symbols.  */
  if (name == NULL
      || name[0] != '$'
      || (name[1] != 'a'
	  && name[1] != 't'
	  && name[1] != 'd'))
    return TRUE;

  mapcount = ++(elf32_arm_section_data (input_sec)->mapcount);
  map = elf32_arm_section_data (input_sec)->map;
  /* TODO: This may be inefficient, but we probably don't usually have many
     mapping symbols per section.  */
  map = bfd_realloc (map, mapcount * sizeof (elf32_arm_section_map));
  elf32_arm_section_data (input_sec)->map = map;
  
  map[mapcount - 1].vma = elfsym->st_value;
  map[mapcount - 1].type = name[1];
  return TRUE;
}


/* Allocate target specific section data.  */

static bfd_boolean
elf32_arm_new_section_hook (bfd *abfd, asection *sec)
{
  struct _arm_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}


/* Used to order a list of mapping symbols by address.  */

static int
elf32_arm_compare_mapping (const void * a, const void * b)
{
  return ((const elf32_arm_section_map *) a)->vma
	 > ((const elf32_arm_section_map *) b)->vma;
}


/* Do code byteswapping.  Return FALSE afterwards so that the section is
   written out as normal.  */

static bfd_boolean
elf32_arm_write_section (bfd *output_bfd ATTRIBUTE_UNUSED, asection *sec,
			 bfd_byte *contents)
{
  int mapcount;
  elf32_arm_section_map *map;
  bfd_vma ptr;
  bfd_vma end;
  bfd_vma offset;
  bfd_byte tmp;
  int i;
  
  mapcount = elf32_arm_section_data (sec)->mapcount;
  map = elf32_arm_section_data (sec)->map;

  if (mapcount == 0)
    return FALSE;

  qsort (map, mapcount, sizeof (elf32_arm_section_map),
	 elf32_arm_compare_mapping);

  offset = sec->output_section->vma + sec->output_offset;
  ptr = map[0].vma - offset;
  for (i = 0; i < mapcount; i++)
    {
      if (i == mapcount - 1)
	end = bfd_section_size (output_bfd, sec);
      else
	end = map[i + 1].vma - offset;
      
      switch (map[i].type)
	{
	case 'a':
	  /* Byte swap code words.  */
	  while (ptr + 3 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 3];
	      contents[ptr + 3] = tmp;
	      tmp = contents[ptr + 1];
	      contents[ptr + 1] = contents[ptr + 2];
	      contents[ptr + 2] = tmp;
	      ptr += 4;
	    }
	  break;

	case 't':
	  /* Byte swap code halfwords.  */
	  while (ptr + 1 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 1];
	      contents[ptr + 1] = tmp;
	      ptr += 2;
	    }
	  break;

	case 'd':
	  /* Leave data alone.  */
	  break;
	}
      ptr = end;
    }
  free (map);
  return FALSE;
}

a4101 1
#define bfd_elf32_new_section_hook		elf32_arm_new_section_hook
a4107 1
#define elf_backend_write_section		elf32_arm_write_section
a4111 1
#define elf_backend_link_output_symbol_hook	elf32_arm_output_symbol_hook
@


1.120.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d28 86
a113 4
/* In leiu of proper flags, assume all EABIv3 objects are interworkable.  */
#define INTERWORK_FLAG(abfd)  \
  (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) == EF_ARM_EABI_VER3 \
  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK))
d131 7
d142 1
a142 1
static const bfd_vma elf32_arm_plt0_entry [] =
d152 1
a152 1
static const bfd_vma elf32_arm_plt_entry [] =
d162 7
d173 1
a173 1
static const bfd_vma elf32_arm_plt0_entry [] =
d184 1
a184 1
static const bfd_vma elf32_arm_plt_entry [] =
a192 8
/* The entries in a PLT when using a DLL-based target with multiple
   address spaces.  */
static const bfd_vma elf32_arm_symbian_plt_entry [] = 
  {
    0xe51ff004,         /* ldr   pr, [pc, #-4] */
    0x00000000,         /* dcd   R_ARM_GLOB_DAT(X) */
  };

d244 1
a244 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *))) (func), \
a272 13
    /* Zero if R_ARM_TARGET1 means R_ARM_ABS32.
       Nonzero if R_ARM_TARGET1 means R_ARM_ABS32.  */
    int target1_is_rel;

    /* The number of bytes in the initial entry in the PLT.  */
    bfd_size_type plt_header_size;

    /* The number of bytes in the subsequent PLT etries.  */
    bfd_size_type plt_entry_size;

    /* True if the target system is Symbian OS.  */
    int symbian_p;

d289 4
a292 3
elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
                             struct bfd_hash_table * table,
                             const char * string)
d300 4
a303 2
    ret = bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
  if (ret == NULL)
d310 1
a310 1
  if (ret != NULL)
d320 3
a322 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
a325 5
  htab = elf32_arm_hash_table (info);
  /* BPABI objects never have a GOT, or associated sections.  */
  if (htab->symbian_p)
    return TRUE;

d329 1
d351 3
a353 1
elf32_arm_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d370 1
a370 3
  if (!htab->splt 
      || !htab->srelplt
      || !htab->sdynbss
d428 2
a429 1
elf32_arm_link_hash_table_create (bfd *abfd)
d434 2
a435 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d438 1
a438 1
  if (!_bfd_elf_link_hash_table_init (& ret->root, abfd,
a456 9
  ret->target1_is_rel = 0;
#ifdef FOUR_WORD_PLT
  ret->plt_header_size = 16;
  ret->plt_entry_size = 16;
#else
  ret->plt_header_size = 20;
  ret->plt_entry_size = 12;
#endif
  ret->symbian_p = 0;
d465 4
a468 3
find_thumb_glue (struct bfd_link_info *link_info,
		 const char *name,
		 bfd *input_bfd)
d477 2
a478 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d489 2
a490 2
    (*_bfd_error_handler) (_("%B: unable to find THUMB glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);
d500 4
a503 3
find_arm_glue (struct bfd_link_info *link_info,
	       const char *name,
	       bfd *input_bfd)
d512 2
a513 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d524 2
a525 2
    (*_bfd_error_handler) (_("%B: unable to find ARM glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);
d569 2
a570 1
bfd_elf32_arm_allocate_interworking_sections (struct bfd_link_info * info)
d589 2
a590 1
      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->arm_glue_size);
d592 1
a592 1
      s->size = globals->arm_glue_size;
d605 2
a606 1
      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->thumb_glue_size);
d608 1
a608 1
      s->size = globals->thumb_glue_size;
d616 3
a618 2
record_arm_to_thumb_glue (struct bfd_link_info * link_info,
			  struct elf_link_hash_entry * h)
d638 2
a639 1
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d655 3
a657 3
  /* The only trick here is using hash_table->arm_glue_size as the value.
     Even though the section isn't allocated yet, this is where we will be
     putting it.  */
d672 3
a674 2
record_thumb_to_arm_glue (struct bfd_link_info *link_info,
			  struct elf_link_hash_entry *h)
d695 2
a696 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d729 2
a730 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (CHANGE_TO_ARM) + 1);
d753 3
a755 2
bfd_elf32_arm_add_glue_sections_to_bfd (bfd *abfd,
					struct bfd_link_info *info)
d790 1
a790 2
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	| SEC_CODE | SEC_READONLY;
d810 3
a812 1
bfd_elf32_arm_get_bfd_for_interworking (bfd *abfd, struct bfd_link_info *info)
d835 7
a841 5
bfd_elf32_arm_process_before_allocation (bfd *abfd,
					 struct bfd_link_info *link_info,
					 int no_pipeline_knowledge,
					 int byteswap_code,
					 int target1_is_rel)
a863 1
  globals->target1_is_rel = target1_is_rel;
d866 3
a868 2
      _bfd_error_handler (_("%B: BE8 images only valid in big-endian mode."),
			  abfd);
d888 1
a888 1
	= _bfd_elf_link_read_relocs (abfd, sec, (void *) NULL,
d919 6
a924 1
		  if (! bfd_malloc_and_get_section (abfd, sec, &contents))
d1026 3
a1028 1
insert_thumb_branch (insn32 br_insn, int rel_off)
d1045 1
a1045 1
    abort ();	/* Error - not a valid branch instruction form.  */
d1053 12
a1064 10
elf32_thumb_to_arm_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
d1098 5
a1102 3
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: thumb call to arm"),
	     sym_sec->owner, input_bfd, name);
d1120 1
a1120 2
	   /* Offset from the start of the current section
	      to the start of the stubs.  */
d1143 1
a1143 2
    - (input_section->output_section->vma + input_section->output_offset
       + offset)
d1162 12
a1173 10
elf32_arm_to_thumb_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
d1205 5
a1209 3
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: arm call to thumb"),
	     sym_sec->owner, input_bfd, name);
d1250 15
a1264 12
elf32_arm_final_link_relocate (reloc_howto_type *           howto,
			       bfd *                        input_bfd,
			       bfd *                        output_bfd,
			       asection *                   input_section,
			       bfd_byte *                   contents,
			       Elf_Internal_Rela *          rel,
			       bfd_vma                      value,
			       struct bfd_link_info *       info,
			       asection *                   sym_sec,
			       const char *                 sym_name,
			       int		            sym_flags,
			       struct elf_link_hash_entry * h)
a1279 16
  globals = elf32_arm_hash_table (info);

#ifndef OLD_ARM_ABI
  /* Some relocation type map to different relocations depending on the
     target.  We pick the right one here.  */
  if (r_type == R_ARM_TARGET1)
    {
      if (globals->target1_is_rel)
	r_type = R_ARM_REL32;
      else
	r_type = R_ARM_ABS32;
      
      howto = &elf32_arm_howto_table[r_type];
    }
#endif /* OLD_ARM_ABI */

d1292 2
a1363 2
	  && (r_type != R_ARM_REL32
	      || !SYMBOL_CALLS_LOCAL (info, h))
d1451 4
a1454 4
		(*_bfd_error_handler)
		  (_("\%B: Warning: Arm BLX instruction targets Arm function '%s'."),
		   input_bfd,
		   h ? h->root.root.string : "(local)");
d1462 2
a1463 3
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd,
					   output_bfd, input_section,
					   hit_data, sym_sec, rel->r_offset,
d1491 2
a1492 3
		 P is the base address of the section containing the
		   instruction plus the offset of the reloc into that
		   section, ie:
d1500 2
a1501 2
		 size of the processor, thus it is up to the assembler to
		 encode this information into the addend.  */
d1507 5
a1511 6
	      /* Previous versions of this code also used to add in the
		 pipeline offset here.  This is wrong because the linker is
		 not supposed to know about such things, and one day it might
		 change.  In order to support old binaries that need the old
		 behaviour however, so we attempt to detect which ABI was
		 used to create the reloc.  */
d1647 4
a1650 4
	      (*_bfd_error_handler)
		(_("%B: Warning: Thumb BLX instruction targets thumb function '%s'."),
		 input_bfd,
		 h ? h->root.root.string : "(local)");
a1769 1
#ifndef OLD_ARM_ABI
a1793 1
#endif
d1973 5
a1977 4
arm_add_to_rel (bfd *              abfd,
		bfd_byte *         address,
		reloc_howto_type * howto,
		bfd_signed_vma     increment)
d2045 10
a2054 8
elf32_arm_relocate_section (bfd *                  output_bfd,
			    struct bfd_link_info * info,
			    bfd *                  input_bfd,
			    asection *             input_section,
			    bfd_byte *             contents,
			    Elf_Internal_Rela *    relocs,
			    Elf_Internal_Sym *     local_syms,
			    asection **            local_sections)
d2140 3
a2142 2
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
d2180 1
a2180 1

a2190 2
	        case R_ARM_PLT32:

d2224 5
d2232 2
a2233 2
		      (_("%B(%A): warning: unresolvable relocation %d against symbol `%s'"),
		       input_bfd, input_section,
d2235 2
a2236 1
		       h->root.root.string);
d2315 2
a2316 1
elf32_arm_object_p (bfd *abfd)
d2319 1
a2319 1

d2336 3
a2338 1
elf32_arm_set_private_flags (bfd *abfd, flagword flags)
d2346 3
a2348 3
	    (*_bfd_error_handler)
	      (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
	       abfd);
d2350 3
a2352 3
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B due to outside request"),
	       abfd);
d2367 3
a2369 1
elf32_arm_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d2398 4
a2401 3
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
	       obfd, ibfd);
d2421 3
a2423 1
elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
d2516 6
a2521 5
      _bfd_error_handler
	(_("ERROR: %B is compiled for EABI version %d, whereas %B is compiled for version %d"),
	 ibfd, obfd,
	 (in_flags & EF_ARM_EABIMASK) >> 24,
	 (out_flags & EF_ARM_EABIMASK) >> 24);
d2530 6
a2535 5
	  _bfd_error_handler
	    (_("ERROR: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
	     ibfd, obfd,
	     in_flags & EF_ARM_APCS_26 ? 26 : 32,
	     out_flags & EF_ARM_APCS_26 ? 26 : 32);
d2542 4
a2545 3
	    _bfd_error_handler
	      (_("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers"),
	       ibfd, obfd);
d2547 4
a2550 3
	    _bfd_error_handler
	      (_("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers"),
	       ibfd, obfd);
d2558 4
a2561 3
	    _bfd_error_handler
	      (_("ERROR: %B uses VFP instructions, whereas %B does not"),
	       ibfd, obfd);
d2563 4
a2566 3
	    _bfd_error_handler
	      (_("ERROR: %B uses FPA instructions, whereas %B does not"),
	       ibfd, obfd);
d2574 4
a2577 3
	    _bfd_error_handler
	      (_("ERROR: %B uses Maverick instructions, whereas %B does not"),
	       ibfd, obfd);
d2579 4
a2582 3
	    _bfd_error_handler
	      (_("ERROR: %B does not use Maverick instructions, whereas %B does"),
	       ibfd, obfd);
d2599 4
a2602 3
		_bfd_error_handler
		  (_("ERROR: %B uses software FP, whereas %B uses hardware FP"),
		   ibfd, obfd);
d2604 4
a2607 3
		_bfd_error_handler
		  (_("ERROR: %B uses hardware FP, whereas %B uses software FP"),
		   ibfd, obfd);
d2619 4
a2622 3
	      _bfd_error_handler
		(_("Warning: %B supports interworking, whereas %B does not"),
		 ibfd, obfd);
d2626 4
a2629 3
	      _bfd_error_handler
		(_("Warning: %B does not support interworking, whereas %B does"),
		 ibfd, obfd);
d2640 3
a2642 1
elf32_arm_print_private_bfd_data (bfd *abfd, void * ptr)
d2766 3
a2768 1
elf32_arm_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
d2792 6
a2797 5
elf32_arm_gc_mark_hook (asection *                   sec,
			struct bfd_link_info *       info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *          rel,
			struct elf_link_hash_entry * h,
			Elf_Internal_Sym *           sym)
d2831 5
a2835 4
elf32_arm_gc_sweep_hook (bfd *                     abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *    info ATTRIBUTE_UNUSED,
			 asection *                sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
a2870 1
      case R_ARM_TARGET1:
d2886 1
a2886 2
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1)
d2913 5
a2917 2
elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
d2977 3
a2979 2
		    size *= (sizeof (bfd_signed_vma) + sizeof (char));
		    local_got_refcounts = bfd_zalloc (abfd, size);
a3000 1
	  case R_ARM_TARGET1:
d3042 1
a3042 3
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_TARGET1)
d3076 1
a3076 4
		        if ((sec->flags & SEC_ALLOC) != 0
			    /* BPABI objects never have dynamic
			       relocations mapped.  */
			    && !htab->symbian_p)
d3098 1
a3098 1

d3104 1
a3104 1

d3108 1
a3108 1

a3112 1

d3121 1
a3121 1

d3123 1
a3123 2
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_TARGET1)
d3147 4
d3152 27
a3178 7
is_arm_mapping_symbol_name (const char * name)
{
  return (name != NULL)
    && (name[0] == '$')
    && ((name[1] == 'a') || (name[1] == 't') || (name[1] == 'd'))
    && (name[2] == 0);
}
d3180 2
a3181 3
/* This is a copy of elf_find_function() from elf.c except that
   ARM mapping symbols are ignored when looking for function names
   and STT_ARM_TFUNC is considered to a function type.  */
d3183 6
a3188 12
static bfd_boolean
arm_elf_find_function (bfd *         abfd ATTRIBUTE_UNUSED,
		       asection *    section,
		       asymbol **    symbols,
		       bfd_vma       offset,
		       const char ** filename_ptr,
		       const char ** functionname_ptr)
{
  const char * filename = NULL;
  asymbol * func = NULL;
  bfd_vma low_func = 0;
  asymbol ** p;
d3206 1
a3208 6
	  /* Skip $a and $t symbols.  */
	  if ((q->symbol.flags & BSF_LOCAL)
	      && is_arm_mapping_symbol_name (q->symbol.name))
	    continue;
	  /* Fall through.  */
	case STT_NOTYPE:
d3223 3
a3225 54
  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return TRUE;
}  


/* Find the nearest line to a particular section and offset, for error
   reporting.   This code is a duplicate of the code in elf.c, except
   that it uses arm_elf_find_function.  */

static bfd_boolean
elf32_arm_find_nearest_line (bfd *          abfd,
			     asection *     section,
			     asymbol **     symbols,
			     bfd_vma        offset,
			     const char **  filename_ptr,
			     const char **  functionname_ptr,
			     unsigned int * line_ptr)
{
  bfd_boolean found = FALSE;

  /* We skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain uses it.  */

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     & elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	arm_elf_find_function (abfd, section, symbols, offset,
			       *filename_ptr ? NULL : filename_ptr,
			       functionname_ptr);

      return TRUE;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     & found, filename_ptr,
					     functionname_ptr, line_ptr,
					     & elf_tdata (abfd)->line_info))
    return FALSE;

  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  if (! arm_elf_find_function (abfd, section, symbols, offset,
			       filename_ptr, functionname_ptr))
    return FALSE;
a3226 1
  *line_ptr = 0;
d3237 3
a3239 2
elf32_arm_adjust_dynamic_symbol (struct bfd_link_info * info,
				 struct elf_link_hash_entry * h)
d3332 1
a3332 1
      srel->size += sizeof (Elf32_External_Rel);
d3343 2
a3344 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d3353 1
a3353 1
  h->root.u.def.value = s->size;
d3356 1
a3356 1
  s->size += h->size;
d3365 3
a3367 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d3405 2
a3406 2
	  if (s->size == 0)
	    s->size += htab->plt_header_size;
d3408 1
a3408 1
	  h->plt.offset = s->size;
d3423 1
a3423 1
	  s->size += htab->plt_entry_size;
d3425 3
a3427 4
	  if (!htab->symbian_p)
	    /* We also need to make an entry in the .got.plt section, which
	       will be placed in the .got section by the linker script.  */
	    htab->sgotplt->size += 4;
d3430 1
a3430 1
	  htab->srelplt->size += sizeof (Elf32_External_Rel);
d3458 9
a3466 12
      if (!htab->symbian_p)
	{
	  s = htab->sgot;
	  h->got.offset = s->size;
	  s->size += 4;
	  dyn = htab->root.dynamic_sections_created;
	  if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	      && (info->shared
		  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	    htab->srelgot->size += sizeof (Elf32_External_Rel);
	}
d3526 1
a3526 1
      sreloc->size += p->count * sizeof (Elf32_External_Rel);
d3535 3
a3537 2
elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info * info)
d3557 1
a3557 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d3596 1
a3596 1
		  srel->size += p->count * sizeof (Elf32_External_Rel);
d3616 2
a3617 2
	      *local_got = s->size;
	      s->size += 4;
d3619 1
a3619 1
		srel->size += sizeof (Elf32_External_Rel);
d3628 1
a3628 1
  elf_link_hash_traverse (& htab->root, allocate_dynrelocs, info);
d3651 1
a3651 1
	  if (s->size == 0)
d3665 1
a3665 1
	  if (s->size == 0)
d3703 2
a3704 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d3757 5
a3761 2
elf32_arm_finish_dynamic_symbol (bfd * output_bfd, struct bfd_link_info * info,
				 struct elf_link_hash_entry * h, Elf_Internal_Sym * sym)
a3763 1
  struct elf32_arm_link_hash_table *htab;
a3765 1
  htab = elf32_arm_hash_table (info);
d3770 1
a3771 1
      bfd_byte *loc;
d3773 1
d3775 2
d3784 1
d3786 1
a3786 1
      BFD_ASSERT (splt != NULL && srel != NULL);
d3792 1
a3792 2
      plt_index = ((h->plt.offset - htab->plt_header_size) 
		   / htab->plt_entry_size);
d3794 14
a3807 22
      /* Fill in the entry in the procedure linkage table.  */
      if (htab->symbian_p)
	{
	  unsigned i;
	  for (i = 0; i < htab->plt_entry_size / 4; ++i)
	    bfd_put_32 (output_bfd, 
			elf32_arm_symbian_plt_entry[i],
			splt->contents + h->plt.offset + 4 * i);
	  
	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (splt->output_offset
			  + h->plt.offset + 4 * (i - 1));
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
	}
      else
	{
	  bfd_vma got_offset;
	  bfd_vma got_displacement;
	  asection * sgot;
	  
	  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
	  BFD_ASSERT (sgot != NULL);
d3809 1
a3809 4
	  /* Get the offset into the .got table of the entry that
	     corresponds to this function.  Each .got entry is 4 bytes.
	     The first three are reserved.  */
	  got_offset = (plt_index + 3) * 4;
d3811 7
a3817 18
	  /* Calculate the displacement between the PLT slot and the
	     entry in the GOT.  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      + got_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - h->plt.offset
			      - 8);

	  BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
		      splt->contents + h->plt.offset + 0);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
		      splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
		      splt->contents + h->plt.offset + 8);
d3819 2
a3820 2
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		      splt->contents + h->plt.offset + 12);
d3823 11
a3833 13
	  /* Fill in the entry in the global offset table.  */
	  bfd_put_32 (output_bfd,
		      (splt->output_section->vma
		       + splt->output_offset),
		      sgot->contents + got_offset);
	  
	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_JUMP_SLOT);
	}

d3925 3
a3927 1
elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info)
d3936 1
a3936 1
  BFD_ASSERT (elf32_arm_hash_table (info)->symbian_p || sgot != NULL);
a3942 1
      struct elf32_arm_link_hash_table *htab;
a3943 1
      htab = elf32_arm_hash_table (info);
d3948 1
a3948 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
a3959 2
	      unsigned int type;

a3962 10
	    case DT_HASH:
	      name = ".hash";
	      goto get_vma_if_bpabi;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma_if_bpabi;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma_if_bpabi;
	      
d3971 1
a3971 7
	      if (!htab->symbian_p)
		dyn.d_un.d_ptr = s->vma;
	      else
		/* In the BPABI, tags in the PT_DYNAMIC section point
		   at the file offset, not the memory address, for the
		   convenience of the post linker.  */
		dyn.d_un.d_ptr = s->filepos;
a3974 5
	    get_vma_if_bpabi:
	      if (htab->symbian_p)
		goto get_vma;
	      break;

d3978 4
a3981 1
	      dyn.d_un.d_val = s->size;
d3984 1
a3984 1
	      
d3986 11
a3996 1
	      if (!htab->symbian_p)
d3998 4
a4001 49
		  /* My reading of the SVR4 ABI indicates that the
		     procedure linkage table relocs (DT_JMPREL) should be
		     included in the overall relocs (DT_REL).  This is
		     what Solaris does.  However, UnixWare can not handle
		     that case.  Therefore, we override the DT_RELSZ entry
		     here to make it not include the JMPREL relocs.  Since
		     the linker script arranges for .rel.plt to follow all
		     other relocation sections, we don't have to worry
		     about changing the DT_REL entry.  */
		  s = bfd_get_section_by_name (output_bfd, ".rel.plt");
		  if (s != NULL)
		    dyn.d_un.d_val -= s->size;
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		  break;
		}
	      /* Fall through */

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELASZ:
	      /* In the BPABI, the DT_REL tag must point at the file
		 offset, not the VMA, of the first relocation
		 section.  So, we use code similar to that in
		 elflink.c, but do not check for SHF_ALLOC on the
		 relcoation section, since relocations sections are
		 never allocated under the BPABI.  The comments above
		 about Unixware notwithstanding, we include all of the
		 relocations here.  */
	      if (htab->symbian_p)
		{
		  unsigned int i;
		  type = ((dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
			  ? SHT_REL : SHT_RELA);
		  dyn.d_un.d_val = 0;
		  for (i = 1; i < elf_numsections (output_bfd); i++)
		    {
		      Elf_Internal_Shdr *hdr 
			= elf_elfsections (output_bfd)[i];
		      if (hdr->sh_type == type)
			{
			  if (dyn.d_tag == DT_RELSZ 
			      || dyn.d_tag == DT_RELASZ)
			    dyn.d_un.d_val += hdr->sh_size;
			  else if (dyn.d_un.d_val == 0
				   || hdr->sh_offset < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_offset;
			}
		    }
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4003 1
d4034 1
a4034 1
      if (splt->size > 0 && elf32_arm_hash_table (info)->plt_header_size)
d4064 1
a4064 1
  if (sgot)
d4066 9
a4074 11
      if (sgot->size > 0)
	{
	  if (sdyn == NULL)
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
	  else
	    bfd_put_32 (output_bfd,
			sdyn->output_section->vma + sdyn->output_offset,
			sgot->contents);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
	}
d4076 1
a4076 2
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }
d4082 3
a4084 1
elf32_arm_post_process_headers (bfd * abfd, struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
d4103 2
a4104 1
elf32_arm_reloc_type_class (const Elf_Internal_Rela *rela)
d4119 2
a4120 2
static bfd_boolean elf32_arm_section_flags           (flagword *, const Elf_Internal_Shdr *);
static void        elf32_arm_final_write_processing  (bfd *, bfd_boolean);
d4125 3
a4127 1
elf32_arm_section_flags (flagword *flags, const Elf_Internal_Shdr *hdr)
d4136 3
a4138 1
elf32_arm_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
d4168 5
a4172 1
  if (! is_arm_mapping_symbol_name (name))
d4181 1
a4181 1

d4229 1
a4229 1

d4244 1
a4244 1
	end = sec->size;
d4247 1
a4247 1

d4333 1
@


1.120.6.4
log
@Merge from mainline.
@
text
@a188 3
    /* The relocation to use for R_ARM_TARGET2 relocations.  */
    int target2_reloc;

a380 1
  ret->target2_reloc = R_ARM_NONE;
d760 2
a761 1
					 int byteswap_code)
d784 1
a784 1

a908 26

#ifndef OLD_ARM_ABI
/* Set target relocation values needed during linking.  */

void
bfd_elf32_arm_set_target_relocs (struct bfd_link_info *link_info,
				 int target1_is_rel,
				 char * target2_type)
{
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (link_info);

  globals->target1_is_rel = target1_is_rel;
  if (strcmp (target2_type, "rel") == 0)
    globals->target2_reloc = R_ARM_REL32;
  else if (strcmp (target2_type, "got-rel") == 0)
    globals->target2_reloc = R_ARM_GOT_PREL;
  else
    {
      _bfd_error_handler (_("Invalid TARGET2 relocation type '%s'."),
			  target2_type);
    }
}
#endif

a1153 26

#ifndef OLD_ARM_ABI
/* Some relocations map to different relocations depending on the
   target.  Return the real relocation.  */
static int
arm_real_reloc_type (struct elf32_arm_link_hash_table * globals,
		     int r_type)
{
  switch (r_type)
    {
    case R_ARM_TARGET1:
      if (globals->target1_is_rel)
	return R_ARM_REL32;
      else
	return R_ARM_ABS32;

    case R_ARM_TARGET2:
      return globals->target2_reloc;

    default:
      return r_type;
    }
}
#endif /* OLD_ARM_ABI */


d1189 9
a1197 3
  r_type = arm_real_reloc_type (globals, r_type);
  if (r_type != howto->type)
    howto = elf32_arm_howto_from_type (r_type);
a1247 1
    case R_ARM_PREL31:
d1260 1
a1260 5
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	   && r_type != R_ARM_PREL31
#endif
	   )
d1282 2
a1283 5
	  && ((r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	      && r_type != R_ARM_PREL31
#endif
	      ) || !SYMBOL_CALLS_LOCAL (info, h))
d1333 2
a1334 1
		       || !h->def_regular))
a1483 18

#ifndef OLD_ARM_ABI
	case R_ARM_PREL31:
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  value += signed_addend;
	  if (! h || h->root.type != bfd_link_hash_undefweak)
	    {
	      /* Check for overflow */
	      if ((value ^ (value >> 1)) & (1 << 30))
		return bfd_reloc_overflow;
	    }
	  value &= 0x7fffffff;
	  value |= (bfd_get_32 (input_bfd, hit_data) & 0x80000000);
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
	  break;
#endif
a1772 3
#ifndef OLD_ARM_ABI
    case R_ARM_GOT_PREL:
#endif
a1860 2
      if (r_type != R_ARM_GOT32)
	value += sgot->output_section->vma;
d2115 4
a2118 2
	              && ((!info->symbolic && h->dynindx != -1)
	                  || !h->def_regular)
d2126 2
a2127 1
			      && h->def_dynamic))
a2136 3
#ifndef OLD_ARM_ABI
		case R_ARM_GOT_PREL:
#endif
d2142 2
a2143 1
	                  || !h->def_regular))
a2733 3
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);
d2743 16
a2758 2
    {
      int r_type;
d2760 22
a2781 23
      r_type = ELF32_R_TYPE (rel->r_info);
#ifndef OLD_ARM_ABI
      r_type = arm_real_reloc_type (globals, r_type);
#endif
      switch (r_type)
	{
	case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
	case R_ARM_GOT_PREL:
#endif
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d2783 12
a2794 13
	case R_ARM_ABS32:
	case R_ARM_REL32:
	case R_ARM_PC24:
	case R_ARM_PLT32:
#ifndef OLD_ARM_ABI
	case R_ARM_PREL31:
#endif
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      struct elf32_arm_link_hash_entry *eh;
	      struct elf32_arm_relocs_copied **pp;
	      struct elf32_arm_relocs_copied *p;
d2796 3
a2798 30
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      if (r_type == R_ARM_ABS32
#ifndef OLD_ARM_ABI
		  || r_type == R_ARM_PREL31
#endif
		  || r_type == R_ARM_REL32)
		{
		  eh = (struct elf32_arm_link_hash_entry *) h;

		  for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		       pp = &p->next)
		  if (p->section == sec)
		    {
		      p->count -= 1;
		      if (p->count == 0)
			*pp = p->next;
		      break;
		    }
		}
	    }
	  break;

	default:
	  break;
	}
    }
a2840 1
      int r_type;
a2842 4
      r_type = ELF32_R_TYPE (rel->r_info);
#ifndef OLD_ARM_ABI
      r_type = arm_real_reloc_type (htab, r_type);
#endif
d2848 1
a2848 1
      switch (r_type)
a2850 3
#ifndef OLD_ARM_ABI
	  case R_ARM_GOT_PREL:
#endif
d2875 1
a2875 3
	    if (r_type == R_ARM_GOT32)
	      break;
	    /* Fall through.  */
d2890 1
a2892 3
#ifndef OLD_ARM_ABI
	  case R_ARM_PREL31:
#endif
d2902 1
a2902 1
		  h->non_got_ref = 1;
d2908 3
a2910 3
		if (r_type == R_ARM_PC24
		    || r_type == R_ARM_PLT32)
		  h->needs_plt = 1;
d2931 4
a2934 6
		&& ((r_type != R_ARM_PC24
		     && r_type != R_ARM_PLT32
#ifndef OLD_ARM_ABI
		     && r_type != R_ARM_PREL31
#endif
		     && r_type != R_ARM_REL32)
d2937 2
a2938 1
			    || !h->def_regular))))
d3018 3
a3020 5
		if (r_type == R_ARM_ABS32
#ifndef OLD_ARM_ABI
		    || r_type == R_ARM_PREL31
#endif
		    || r_type == R_ARM_REL32)
d3185 8
a3192 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d3198 1
a3198 1
      || h->needs_plt)
d3211 1
a3211 1
	  h->needs_plt = 0;
d3227 1
a3227 1
  if (h->u.weakdef != NULL)
d3229 4
a3232 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d3269 1
a3269 1
      h->needs_copy = 1;
d3325 1
a3325 1
	  && !h->forced_local)
d3349 1
a3349 1
	      && !h->def_regular)
d3369 1
a3369 1
	  h->needs_plt = 0;
d3375 1
a3375 1
      h->needs_plt = 0;
d3386 1
a3386 1
	  && !h->forced_local)
d3432 3
a3434 3
      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
d3442 1
a3442 1
	      && !h->forced_local)
d3793 1
a3793 1
      if (!h->def_regular)
d3802 2
a3803 1
	  if (!h->ref_regular_nonweak)
d3847 1
a3847 1
  if (h->needs_copy)
@


1.120.10.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d2433 1
a2433 1
    elf_link_add_object_symbols.
a2434 4
    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
a2437 1
      bfd_boolean only_data_sections = TRUE;
a2444 5
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

d2449 1
a2449 2

      if (null_input_bfd || only_data_sections)
@


1.119
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Check that we created
	the .plt section.
	(elf32_arm_check_relocs): Don't increment the PLT refcount for
	relocs which would not use the PLT.
@
text
@d2948 5
a2952 4
		  {
		    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		    h->plt.refcount += 1;
		  }
@


1.118
log
@	* elf32-arm.h (struct elf32_arm_relocs_copied): Remove pc_count.
	(elf32_arm_copy_indirect_symbol): Don't copy pc_count.
	(elf32_arm_final_link_relocate): Handle PLT32 and PC24 relocs
	identically.  Do not emit PC24 relocations for shared libraries.
	(elf32_arm_gc_sweep_hook): Handle PLT32 and PC24 relocs
	identically.  Don't adjust pc_count.
	(elf32_arm_check_relocs): Handle PLT32 and PC24 relocs identically.
	Set ELF_LINK_HASH_NEEDS_PLT for both.  Don't adjust pc_count; don't
	adjust count for branch relocations.
	(allocate_dynrelocs): Correct typo in call to
	WILL_CALL_FINISH_DYNAMIC_SYMBOL.  Never allocate space for
	PC24 or PLT32 relocs when linking.
@
text
@d1320 1
d1323 3
a1325 1
	  BFD_ASSERT (splt != NULL);
d2943 3
a2945 1
		   refers to is in a different object.  */
d2948 4
a2951 3
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

		h->plt.refcount += 1;
@


1.117
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@a207 2
    /* Number of relocs copied in this section.  */
    bfd_size_type pc_count;
a383 1
		    q->pc_count += p->pc_count;
d1307 1
d1314 19
d1335 7
a1341 7
      if ((info->shared
	   && (input_section->flags & SEC_ALLOC)
	   && (h == NULL
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	   && (r_type != R_ARM_PC24
	       || !SYMBOL_CALLS_LOCAL (info, h))))
d1384 1
a1384 2
		   && (r_type == R_ARM_PC24
		       || !info->shared
d1416 1
a1888 31
    case R_ARM_PLT32:
      /* Relocation is to the entry for this symbol in the
         procedure linkage table.  */

      /* Resolve a PLT32 reloc against a local symbol directly,
         without using the procedure linkage table.  */
      if (h == NULL)
        return _bfd_final_link_relocate (howto, input_bfd, input_section,
				 contents, rel->r_offset, value,
				 (bfd_vma) 0);

      if (h->plt.offset == (bfd_vma) -1
	  || globals->splt == NULL)
        /* We didn't make a PLT entry for this symbol.  This
           happens when statically linking PIC code, or when
           using -Bsymbolic.  */
	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 (bfd_vma) 0);

      BFD_ASSERT(splt != NULL);
      if (splt == NULL)
        return bfd_reloc_notsupported;

      value = (splt->output_section->vma
	       + splt->output_offset
	       + h->plt.offset);
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
			       contents, rel->r_offset, value,
			       (bfd_vma) 0);

d2797 1
d2807 1
a2807 1
	    if (!info->shared && h->plt.refcount > 0)
d2810 4
a2813 1
	    eh = (struct elf32_arm_link_hash_entry *) h;
d2815 10
a2824 20
	    for (pp = &eh->relocs_copied; (p = *pp) != NULL; pp = &p->next)
	      if (p->section == sec)
		{
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
a2884 17
	  case R_ARM_PLT32:
	    /* This symbol requires a procedure linkage table entry.  We
               actually build the entry in adjust_dynamic_symbol,
               because this might be a case of linking PIC code which is
               never referenced by a dynamic object, in which case we
               don't need to generate a procedure linkage table entry
               after all.  */

	    /* If this is a local symbol, we resolve it directly without
               creating a procedure linkage table entry.  */
	    if (h == NULL)
	      continue;

	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    h->plt.refcount++;
	    break;

d2927 2
a2928 1
	    if (h != NULL && !info->shared)
d2936 3
a2938 2
		h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
		
d2940 5
a2944 1
		   refers to is in a shared lib.  */
d2962 2
a2963 1
		&& (ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
a3040 1
		    p->pc_count = 0;
d3043 3
a3045 3
		p->count += 1;
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		  p->pc_count += 1;
d3320 1
a3320 1
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d3404 2
a3405 23
      /* The only reloc that uses pc_count is R_ARM_PC24, which will
	 appear on a call or on something like ".long foo - .".  We
	 want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing assembly like ".long foo - .".  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf32_arm_relocs_copied **pp;

	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
@


1.116
log
@Fix decision about when a .interp section should exist
@
text
@d238 1
a238 1
    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
d241 1
a241 1
    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
d244 1
a244 1
    /* An arbitary input BFD chosen to hold the glue sections.  */
d968 1
a968 1
   11 bits to invest. The upper 11 bits are stored in one (identifed by
d2613 1
a2613 1
      /* The following flag bits are GNU extenstions and not part of the
d3988 1
a3988 1
		 then there is nothing to ajdust.  */
@


1.115
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d3526 1
a3526 1
      if (! info->shared)
@


1.114
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d2130 1
a2130 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.113
log
@2003-10-29  Daniel Jacobowitz  <drow@@mvista.com>

        * elf32-arm.h (elf32_arm_final_link_relocate): Move check for
        SEC_ALLOC.

2003-10-29  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_plt0_entry, elf32_arm_plt_entry): New
	code sequence.
	(PLT_HEADER_SIZE): New.
	(struct elf32_arm_pcrel_relocs_copied): Rename to ...
	(struct elf32_arm_relocs_copied): ... this.  Count both
	pcrel and non-pcrel relocs.  All uses updated.
	(struct elf32_arm_link_hash_table): Add pointers to dynamic linker
	sections and symbol/section mapping cache.
	(create_got_section): New.
	(elf32_arm_create_dynamic_sections): New.
	(elf_backend_create_dynamic_sections): Use it.
	(elf32_arm_final_link_relocate): Support garbage collection of relocs.
	(elf32_arm_check_relocs): Likewise.
	(elf32_arm_adjust_dynamic_symbol): Likewise.
	(elf32_arm_copy_indirect_symbol): New.
	(elf32_arm_link_hash_table_create): Initialise new fields.
	(elf32_arm_gc_sweep_hook): Implement.
	(elf32_arm_discard_copies): Delete.
	(elf32_arm_finish_dynamic_symbol): Use new PLT code.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf_backend_can_refcount): Define.
	(elf_backend_copy_indirect_symbol): Likewise.
	(elf_backend_plt_header_size): Set to PLT_HEADER_SIZE.
@
text
@a4150 1
#define elf_backend_plt_header_size	PLT_HEADER_SIZE
@


1.112
log
@	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Never skip dynamic
	objects.
@
text
@d87 6
d128 6
d141 1
a141 1
static const bfd_vma elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
d143 4
a146 4
    0xe52de004,	/* str   lr, [sp, #-4]!     */
    0xe59fe010,	/* ldr   lr, [pc, #16]      */
    0xe08fe00e,	/* add   lr, pc, lr         */
    0xe5bef008	/* ldr   pc, [lr, #8]!      */
d152 39
a190 6
 {
   0xe59fc004,	/* ldr   ip, [pc, #4]       */
   0xe08fc00c,	/* add   ip, pc, ip         */
   0xe59cf000,	/* ldr   pc, [ip]           */
   0x00000000	/* offset to symbol in got  */
 };
d200 1
a200 1
struct elf32_arm_pcrel_relocs_copied
d203 1
a203 1
    struct elf32_arm_pcrel_relocs_copied * next;
d208 2
d218 1
a218 1
    struct elf32_arm_pcrel_relocs_copied * pcrel_relocs_copied;
a220 4
/* Declare this now that the above structures are defined.  */
static bfd_boolean elf32_arm_discard_copies
  PARAMS ((struct elf32_arm_link_hash_entry *, PTR));

d250 12
d289 1
a289 1
    ret->pcrel_relocs_copied = NULL;
d294 110
d424 7
d435 1
d1310 6
d1318 7
a1324 8
      if (info->shared
	  && r_symndx != 0
	  && (r_type != R_ARM_PC24
	      || (h != NULL
	          && h->dynindx != -1
		  && (! info->symbolic
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1365 8
a1372 7
	  else if (r_type == R_ARM_PC24)
	    {
	      BFD_ASSERT (h != NULL && h->dynindx != -1);
	      if ((input_section->flags & SEC_ALLOC) == 0)
		relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_PC24);
	    }
d1375 3
a1377 15
	      if (h == NULL
		  || ((info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0))
		{
		  relocate = TRUE;
		  outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		}
	      else
		{
		  BFD_ASSERT (h->dynindx != -1);
		  if ((input_section->flags & SEC_ALLOC) == 0)
		    relocate = TRUE;
		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_ABS32);
		}
d1787 1
a1787 1
	  bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;
d1791 1
d1793 1
a1793 1
	  if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1795 3
a1797 3
		  && (info->symbolic || h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d1883 2
a1884 1
      if (h->plt.offset == (bfd_vma) -1)
d2155 1
a2155 1
		  (!info->symbolic && h->dynindx != -1)
d2158 1
d2776 76
a2851 1
  /* We don't support garbage collection of GOT and PLT relocs yet.  */
d2870 1
a2870 1
  asection *sgot, *srelgot, *sreloc;
d2872 1
d2877 2
a2878 1
  sgot = srelgot = sreloc = NULL;
a2902 18
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_ARM_GOT32:
	    case R_ARM_GOTOFF:
	    case R_ARM_GOTPC:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	      break;

	    default:
	      break;
	    }
	}

d2905 7
a2911 7
	  case R_ARM_GOT32:
	    /* This symbol requires a global offset table entry.  */
	    if (sgot == NULL)
	      {
	        sgot = bfd_get_section_by_name (dynobj, ".got");
	        BFD_ASSERT (sgot != NULL);
	      }
d2913 4
a2916 5
	    /* Get the got relocation section if necessary.  */
	    if (srelgot == NULL
	        && (h != NULL || info->shared))
	      {
	        srelgot = bfd_get_section_by_name (dynobj, ".rel.got");
d2918 3
a2920 16
	        /* If no got relocation section, make one and initialize.  */
	        if (srelgot == NULL)
		  {
		    srelgot = bfd_make_section (dynobj, ".rel.got");
		    if (srelgot == NULL
		        || ! bfd_set_section_flags (dynobj, srelgot,
						    (SEC_ALLOC
						     | SEC_LOAD
						     | SEC_HAS_CONTENTS
						     | SEC_IN_MEMORY
						     | SEC_LINKER_CREATED
						     | SEC_READONLY))
		        || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		      return FALSE;
		  }
	      }
d2922 2
d2926 1
a2926 12
	        if (h->got.offset != (bfd_vma) -1)
		  /* We have already allocated space in the .got.  */
		  break;

	        h->got.offset = sgot->_raw_size;

	        /* Make sure this symbol is output as a dynamic symbol.  */
	        if (h->dynindx == -1)
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return FALSE;

	        srelgot->_raw_size += sizeof (Elf32_External_Rel);
d2930 5
a2934 3
	        /* This is a global offset table entry for a local
                   symbol.  */
	        if (local_got_offsets == NULL)
a2936 1
		    unsigned int i;
d2939 4
a2942 3
		    size *= sizeof (bfd_vma);
		    local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		    if (local_got_offsets == NULL)
d2944 1
a2944 3
		    elf_local_got_offsets (abfd) = local_got_offsets;
		    for (i = 0; i < symtab_hdr->sh_info; i++)
		      local_got_offsets[i] = (bfd_vma) -1;
d2946 1
a2946 12

	        if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		  /* We have already allocated space in the .got.  */
		  break;

	        local_got_offsets[r_symndx] = sgot->_raw_size;

	        if (info->shared)
		  /* If we are generating a shared object, we need to
		     output a R_ARM_RELATIVE reloc so that the dynamic
		     linker can adjust this GOT entry.  */
		  srelgot->_raw_size += sizeof (Elf32_External_Rel);
a2947 2

	    sgot->_raw_size += 4;
d2950 9
a2958 14
	  case R_ARM_PLT32:
	    /* This symbol requires a procedure linkage table entry.  We
               actually build the entry in adjust_dynamic_symbol,
               because this might be a case of linking PIC code which is
               never referenced by a dynamic object, in which case we
               don't need to generate a procedure linkage table entry
               after all.  */

	    /* If this is a local symbol, we resolve it directly without
               creating a procedure linkage table entry.  */
	    if (h == NULL)
	      continue;

	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2964 15
d2990 1
a2990 1
               pcrel_relocs_copied field of the hash table entry.  */
d2992 6
a2997 5
	      && (ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
	        || (h != NULL
		  && (! info->symbolic
		    || (h->elf_link_hash_flags
		      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d2999 2
d3034 2
a3035 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d3038 24
a3061 11
	        sreloc->_raw_size += sizeof (Elf32_External_Rel);
	        /* If we are linking with -Bsymbolic, and this is a
                   global symbol, we count the number of PC relative
                   relocations we have entered for this symbol, so that
                   we can discard them again if the symbol is later
                   defined by a regular object.  Note that this function
                   is only called if we are using an elf_i386 linker
                   hash table, which means that h is really a pointer to
                   an elf_i386_link_hash_entry.  */
	        if (h != NULL && info->symbolic
		    && ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
d3063 2
a3064 9
		    struct elf32_arm_link_hash_entry * eh;
		    struct elf32_arm_pcrel_relocs_copied * p;

		    eh = (struct elf32_arm_link_hash_entry *) h;

		    for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		      if (p->section == sreloc)
		        break;

d3066 6
a3071 12
		      {
		        p = ((struct elf32_arm_pcrel_relocs_copied *)
			     bfd_alloc (dynobj, (bfd_size_type) sizeof * p));
		        if (p == NULL)
			  return FALSE;
		        p->next = eh->pcrel_relocs_copied;
		        eh->pcrel_relocs_copied = p;
		        p->section = sreloc;
		        p->count = 0;
		      }

		    ++p->count;
d3073 4
d3216 4
a3219 8
      /* If we link a program (not a DSO), we'll get rid of unnecessary
	 PLT entries; we point to the actual symbols -- even for pic
	 relocs, because a program built with -fpic should have the same
	 result as one built without -fpic, specifically considering weak
	 symbols.
	 FIXME: m68k and i386 differ here, for unclear reasons.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d3222 5
a3226 5
	     file, but the symbol was not defined by a dynamic object.
	     In such a case, we don't actually need to build a
	     procedure linkage table, and we can just do a PC32 reloc
	     instead.  */
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
a3227 8
	  return TRUE;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
a3229 37
      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->_raw_size == 0)
	s->_raw_size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	}

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += 4;

      /* We also need to make an entry in the .rel.plt section.  */

      s = bfd_get_section_by_name (dynobj, ".rel.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf32_External_Rel);

d3232 7
d3313 192
d3516 2
d3519 1
d3534 68
a3601 20
  else
    {
      /* We may have created entries in the .rel.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rel.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rel.got");
      if (s != NULL)
	s->_raw_size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    elf32_arm_link_hash_traverse (elf32_arm_hash_table (info),
				  elf32_arm_discard_copies,
				  (PTR) NULL);
a3725 27
/* This function is called via elf32_arm_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

static bfd_boolean
elf32_arm_discard_copies (h, ignore)
     struct elf32_arm_link_hash_entry * h;
     PTR ignore ATTRIBUTE_UNUSED;
{
  struct elf32_arm_pcrel_relocs_copied * s;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf32_arm_link_hash_entry *) h->root.root.u.i.link;

  /* We only discard relocs for symbols defined in a regular object.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rel);

  return TRUE;
}

d3749 1
d3765 1
a3765 1
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d3772 12
d3785 1
a3785 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0],
d3787 1
a3787 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1],
d3789 1
a3789 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2],
d3791 4
a3794 8
      bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset
		       - splt->output_section->vma
		       - splt->output_offset
		       - h->plt.offset - 12),
		      splt->contents + h->plt.offset + 12);
d3801 1
a3801 1

d3842 5
a3846 4
      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  The entry in
	 the global offset table will already have been initialized in
	 the relocate_section function.  */
d3848 5
a3852 3
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
d3855 1
d4009 9
d4022 7
d4130 1
a4130 1
#define elf_backend_create_dynamic_sections	_bfd_elf_create_dynamic_sections
d4139 1
d4141 1
d4151 1
a4151 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.111
log
@Fix up error messages for Maverick.
@
text
@a2219 1
  bfd_boolean null_input_bfd = TRUE;
d2270 7
a2276 4
  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
d2278 3
a2280 3
      /* Ignore synthetic glue sections.  */
      if (strcmp (sec->name, ".glue_7")
	  && strcmp (sec->name, ".glue_7t"))
d2282 7
a2288 2
	  null_input_bfd = FALSE;
	  break;
d2290 2
a2292 2
  if (null_input_bfd)
    return TRUE;
@


1.110
log
@Better handking for unresolved symbols
@
text
@d2354 1
a2354 1
ERROR: %s uses Maverick instructions, whereas %s does not"),
@


1.109
log
@	* elf32-arm.h (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(elf32_arm_final_link_relocate, elf32_arm_relocate_section): Use it.
@
text
@d1966 2
a1967 1
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1969 6
a1974 6
	  while (   h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (   h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
a1975 4
	      int relocation_needed = 1;

	      sec = h->root.u.def.section;

d1998 1
a1998 1
	            relocation_needed = 0;
d2002 1
a2002 1
	          relocation_needed = 0;
d2007 1
a2007 1
		       (elf_hash_table(info)->dynamic_sections_created,
d2013 1
a2013 1
	            relocation_needed = 0;
d2018 1
a2018 1
	            relocation_needed = 0;
d2022 8
a2029 10
		  if (sec->output_section == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
			 bfd_archive_filename (input_bfd),
			 r_type,
			 h->root.root.string,
			 bfd_get_section_name (input_bfd, input_section));
		      relocation_needed = 0;
		    }
a2030 23

	      if (relocation_needed)
		relocation = h->root.u.def.value
		  + sec->output_section->vma
		  + sec->output_offset;
	      else
		relocation = 0;
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
@


1.108
log
@Set maxpagesize for NTO targets to 4k
@
text
@d1041 12
d1620 1
d1625 5
a1629 3
	  if (!elf_hash_table (info)->dynamic_sections_created ||
	      (info->shared && (info->symbolic || h->dynindx == -1)
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2009 4
a2012 2
	          if (elf_hash_table(info)->dynamic_sections_created
	              && (!info->shared
d2014 2
a2015 3
	                  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
			  )
		      )
@


1.107
log
@Correct spelling of "relocatable".
@
text
@d3702 3
d3706 1
@


1.106
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d567 1
a567 1
  if (info->relocateable)
d623 1
a623 1
  if (info->relocateable)
d655 1
a655 1
  if (link_info->relocateable)
d1841 1
a1841 1
  if (info->relocateable)
d1873 1
a1873 1
      if (info->relocateable)
d1875 1
a1875 1
	  /* This is a relocateable link.  We don't have to change
d2633 1
a2633 1
  if (info->relocateable)
@


1.105
log
@Fixes for iWMMXt contribution.
@
text
@d682 2
a683 2
	= _bfd_elf32_link_read_relocs (abfd, sec, (PTR) NULL,
				       (Elf_Internal_Rela *) NULL, FALSE);
@


1.105.8.1
log
@	* elf32-arm.h (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(elf32_arm_final_link_relocate, elf32_arm_relocate_section): Use it.
@
text
@a1040 12
/* This is the condition under which elf32_arm_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_arm_relocate_section
   and elf32_arm_final_link_relocate.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H)			\
  ((DYN)								\
   && ((SHARED)							 	\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

a1607 1
	  bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;
d1612 3
a1614 5
	  if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && (info->symbolic || h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d1994 2
a1995 4
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table(info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
d1997 3
a1999 2
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
@


1.105.6.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d682 2
a683 2
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);
@


1.104
log
@Add iWMMXt support
@
text
@d2122 3
a2124 1
  asection * arm_arch_section;
d2126 2
a2127 1
  arm_arch_section = bfd_get_section_by_name (abfd, ARM_NOTE_SECTION);
d2129 2
a2130 4
  if (arm_arch_section)
    {
      char          buffer [4];
      unsigned long arm_mach;
a2131 23
      if (! bfd_get_section_contents (abfd, arm_arch_section, buffer,
				      (file_ptr) 0, sizeof buffer))
	(*_bfd_error_handler)
	  (_("%s: warning: unable to retrieve %s section from %s"),
	   ARM_NOTE_SECTION, bfd_get_filename (abfd));
      else
	{
	  /* We have to extract the value this way to allow for a
	     host whose endian-ness is different from the target.  */
	  arm_mach = bfd_get_32 (abfd, buffer);
	  bfd_default_set_arch_mach (abfd, bfd_arch_arm, arm_mach);

	  if (bfd_get_arch (abfd) == bfd_arch_arm)
	    return TRUE;
      
	  /* If the set failed for some reason, do not leave the architecture
	     type as 0 (unknown), but issue a warning message and force it to
	     be set to bfd_arch_arm.  */
	  (*_bfd_error_handler)
	    (_("%s: warning: unrecognized ARM machine number: %x"),
	     bfd_get_filename (abfd), arm_mach);
	}
    }
d2133 1
a2133 4
    {
      if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
	bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);
    }
d2274 4
a2277 18
  if (bfd_get_mach (obfd) && bfd_get_mach (obfd) != bfd_get_mach (ibfd))
    {
      /* For now, allow an output file type of 'xscale' if the
	 input file type is 'iWMMXt'.  This means that we will
	 not have to build an entire iWMMXt enabled set of libraries
	 just to test a iWMMXt enabled binary.  Change the output
	 type to iWMMXt though.  Similarly allow 'xscale' binaries
         to be linked into a 'iWMMXt' output binary.  */
      if (   bfd_get_mach (obfd) == bfd_mach_arm_XScale
	  && bfd_get_mach (ibfd) == bfd_mach_arm_iWMMXt)
	bfd_set_arch_mach (obfd, bfd_get_arch (obfd), bfd_mach_arm_iWMMXt);
      else if (   bfd_get_mach (ibfd) != bfd_mach_arm_XScale
	       || bfd_get_mach (obfd) != bfd_mach_arm_iWMMXt)
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return FALSE;
	}
    }
d3697 1
a3697 36
  asection *    arm_arch_section;
  char          buffer [4];
  unsigned long arm_mach;

  /* Look for a .note.arm.ident section.  If one is present check
     the machine number encoded in it, and set it to the current
     machine number if it is different.  This allows XScale and
     iWMMXt binaries to be merged and the resulting output to be set
     to iWMMXt, even if the first input file had an XScale .note.  */

  arm_arch_section = bfd_get_section_by_name (abfd, ARM_NOTE_SECTION);

  if (arm_arch_section == NULL)
    return;

  if (! bfd_get_section_contents (abfd, arm_arch_section, buffer,
				(file_ptr) 0, sizeof buffer))
    /* If the ident section does not exist then just skip this check.  */
    return;

  /* We have to extract the value this way to allow for a
     host whose endian-ness is different from the target.  */
  arm_mach = bfd_get_32 (abfd, buffer);

  if (arm_mach == bfd_get_mach (abfd))
    return;

  bfd_put_32 (abfd, bfd_get_mach (abfd), buffer);

  if (! bfd_set_section_contents (abfd, arm_arch_section, buffer,
				  (file_ptr) 0, sizeof buffer))
    (*_bfd_error_handler)
      (_("warning: unable to update contents of %s section in %s"),
       ARM_NOTE_SECTION, bfd_get_filename (abfd));

  return;
@


1.103
log
@(elf32_thumb_to_arm_stub): Include section VMAs	in computation of offset to
insert into BL instruction.
@
text
@d2122 1
a2122 1
  /* XXX - we ought to examine a .note section here.  */
d2124 35
a2158 2
  if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);
d2299 19
d3715 59
d3799 2
@


1.102
log
@Add function to set machine number based on flags in header.
@
text
@d932 10
a941 7
  /* Now go back and fix up the original BL insn to point
     to here.  */
  ret_offset = (s->output_offset
		+ my_offset
		- (input_section->output_offset
		   + offset + addend)
		- 8);
@


1.101
log
@Add support for marking ARM ELF binaries as support the Cirrus EP9312 Maverick
floating point co-processor.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d89 2
d2113 14
a3659 1

d3684 1
@


1.100
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2313 1
a2313 1
ERROR: %s uses VFP instructions, whereas %s uses FPA instructions"),
d2318 17
a2334 1
ERROR: %s uses FPA instructions, whereas %s uses VFP instructions"),
d2429 2
d2451 2
a2452 1
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT);
@


1.99
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d27 1
a27 1
static boolean elf32_arm_set_private_flags
d29 1
a29 1
static boolean elf32_arm_copy_private_bfd_data
d31 1
a31 1
static boolean elf32_arm_merge_private_bfd_data
d33 1
a33 1
static boolean elf32_arm_print_private_bfd_data
d57 1
a57 1
static boolean elf32_arm_relocate_section
d63 1
a63 1
static boolean elf32_arm_gc_sweep_hook
d66 1
a66 1
static boolean elf32_arm_check_relocs
d69 1
a69 1
static boolean elf32_arm_find_nearest_line
d72 1
a72 1
static boolean elf32_arm_adjust_dynamic_symbol
d74 1
a74 1
static boolean elf32_arm_size_dynamic_sections
d76 1
a76 1
static boolean elf32_arm_finish_dynamic_symbol
d79 1
a79 1
static boolean elf32_arm_finish_dynamic_sections
d95 1
a95 1
boolean bfd_elf32_arm_allocate_interworking_sections
d97 1
a97 1
boolean bfd_elf32_arm_get_bfd_for_interworking
d99 1
a99 1
boolean bfd_elf32_arm_process_before_allocation
d173 1
a173 1
static boolean elf32_arm_discard_copies
d180 1
a180 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d288 1
a288 1
    (&(hash_table)->root, tmp_name, false, false, true);
d323 1
a323 1
    (&(hash_table)->root, tmp_name, false, false, true);
d371 1
a371 1
boolean
d415 1
a415 1
  return true;
d449 1
a449 1
    (&(globals)->root, tmp_name, false, false, true);
d465 1
a465 1
				    NULL, true, false, &bh);
d506 1
a506 1
    (&(hash_table)->root, tmp_name, false, false, true);
d519 1
a519 1
				    NULL, true, false, &bh);
d543 1
a543 1
				    NULL, true, false, &bh);
d555 1
a555 1
boolean
d566 1
a566 1
    return true;
d582 1
a582 1
	return false;
d600 1
a600 1
	return false;
d605 1
a605 1
  return true;
d612 1
a612 1
boolean
d622 1
a622 1
    return true;
d629 1
a629 1
    return true;
d634 1
a634 1
  return true;
d637 1
a637 1
boolean
d654 1
a654 1
    return true;
d669 1
a669 1
    return true;
d681 1
a681 1
				       (Elf_Internal_Rela *) NULL, false);
d772 1
a772 1
  return true;
d782 1
a782 1
  return false;
d867 1
a867 1
    return false;
d896 1
a896 1
	  return false;
d945 1
a945 1
  return true;
d973 1
a973 1
    return false;
d1033 1
a1033 1
  return true;
d1133 1
a1133 1
	  boolean skip, relocate;
d1155 2
a1156 2
	  skip = false;
	  relocate = false;
d1162 1
a1162 1
	    skip = true;
d1164 1
a1164 1
	    skip = true, relocate = true;
d1174 1
a1174 1
		relocate = true;
d1184 1
a1184 1
		  relocate = true;
d1191 1
a1191 1
		    relocate = true;
d1392 4
a1395 4
	bfd_vma        relocation;
	boolean        overflow = false;
	bfd_vma        upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma        lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
d1398 1
a1398 1
	bfd_vma        check;
d1475 1
a1475 1
	  overflow = true;
d1817 1
a1817 1
static boolean
d1820 8
a1827 8
     bfd *                  output_bfd;
     struct bfd_link_info * info;
     bfd *                  input_bfd;
     asection *             input_section;
     bfd_byte *             contents;
     Elf_Internal_Rela *    relocs;
     Elf_Internal_Sym *     local_syms;
     asection **            local_sections;
d1829 5
a1833 5
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
  const char *                  name;
d1837 1
a1837 1
    return true;
d1917 1
a1917 1
		  return false;
d2036 1
a2036 1
		return false;
d2072 1
a2072 1
		  return false;
d2078 2
a2079 2
		     rel->r_offset, true)))
		return false;
d2102 1
a2102 1
		return false;
d2108 1
a2108 1
  return true;
d2112 1
a2112 1
static boolean
d2135 1
a2135 1
      elf_flags_init (abfd) = true;
d2138 1
a2138 1
  return true;
d2143 1
a2143 1
static boolean
d2153 1
a2153 1
    return true;
d2164 1
a2164 1
	return false;
d2168 1
a2168 1
	return false;
d2189 1
a2189 1
  elf_flags_init (obfd) = true;
d2191 1
a2191 1
  return true;
d2197 1
a2197 1
static boolean
d2204 2
a2205 2
  boolean flags_compatible = true;
  boolean null_input_bfd = true;
d2210 1
a2210 1
    return false;
d2214 1
a2214 1
    return true;
d2235 1
a2235 1
	return true;
d2237 1
a2237 1
      elf_flags_init (obfd) = true;
d2244 1
a2244 1
      return true;
d2249 1
a2249 1
    return true;
d2260 1
a2260 1
	  null_input_bfd = false;
d2265 1
a2265 1
    return true;
d2276 1
a2276 1
      return false;
d2290 1
a2290 1
	  flags_compatible = false;
d2306 1
a2306 1
	  flags_compatible = false;
d2322 1
a2322 1
	  flags_compatible = false;
d2347 1
a2347 1
	      flags_compatible = false;
d2377 1
a2377 1
static boolean
d2485 1
a2485 1
  return true;
d2553 1
a2553 1
static boolean
d2561 1
a2561 1
  return true;
d2566 1
a2566 1
static boolean
d2568 4
a2571 4
     bfd *                      abfd;
     struct bfd_link_info *     info;
     asection *                 sec;
     const Elf_Internal_Rela *  relocs;
d2573 8
a2580 8
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  struct elf_link_hash_entry ** sym_hashes_end;
  const Elf_Internal_Rela *     rel;
  const Elf_Internal_Rela *     rel_end;
  bfd *                         dynobj;
  asection * sgot, *srelgot, *sreloc;
  bfd_vma * local_got_offsets;
d2583 1
a2583 1
    return true;
d2620 1
a2620 1
		return false;
d2657 1
a2657 1
		      return false;
d2672 1
a2672 1
		    return false;
d2689 1
a2689 1
		      return false;
d2761 1
a2761 1
		      return false;
d2780 1
a2780 1
			  return false;
d2812 1
a2812 1
			  return false;
d2828 1
a2828 1
            return false;
d2835 1
a2835 1
            return false;
d2840 1
a2840 1
  return true;
d2847 1
a2847 1
static boolean
d2850 13
a2862 13
     bfd *          abfd;
     asection *     section;
     asymbol **     symbols;
     bfd_vma        offset;
     const char **  filename_ptr;
     const char **  functionname_ptr;
     unsigned int * line_ptr;
{
  boolean      found;
  const char * filename;
  asymbol *    func;
  bfd_vma      low_func;
  asymbol **   p;
d2868 1
a2868 1
    return true;
d2874 1
a2874 1
    return false;
d2877 1
a2877 1
    return true;
d2880 1
a2880 1
    return false;
d2917 1
a2917 1
    return false;
d2923 1
a2923 1
  return true;
d2932 1
a2932 1
static boolean
d2976 1
a2976 1
	  return true;
d2983 1
a2983 1
	    return false;
d3023 1
a3023 1
      return true;
d3035 1
a3035 1
      return true;
d3046 1
a3046 1
    return true;
d3086 1
a3086 1
	return false;
d3096 1
a3096 1
  return true;
d3101 1
a3101 1
static boolean
d3108 2
a3109 2
  boolean plt;
  boolean relocs;
d3149 2
a3150 2
  plt = false;
  relocs = false;
d3154 1
a3154 1
      boolean strip;
d3163 1
a3163 1
      strip = false;
d3171 1
a3171 1
	      strip = true;
d3176 1
a3176 1
	      plt = true;
d3192 1
a3192 1
	      strip = true;
d3199 1
a3199 1
		relocs = true;
d3221 1
a3221 1
	return false;
d3237 1
a3237 1
	    return false;
d3246 1
a3246 1
	    return false;
d3254 1
a3254 1
	    return false;
d3260 1
a3260 1
	    return false;
d3266 1
a3266 1
  return true;
d3276 1
a3276 1
static boolean
d3288 1
a3288 1
    return true;
d3293 1
a3293 1
  return true;
d3299 1
a3299 1
static boolean
d3449 1
a3449 1
  return true;
d3454 1
a3454 1
static boolean
d3551 1
a3551 1
					     false, false, true);
d3556 1
a3556 1
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);		
d3592 1
a3592 1
  return true;
@


1.98
log
@	* elf32-arm.h (elf32_arm_size_dynamic_sections): Don't strip output
	section when dynamic section unused;  _bfd_strip_section_from_output
	instead.
@
text
@d1131 2
a1132 1
	  Elf_Internal_Rel outrel;
d1196 3
a1198 5
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
				    (((Elf32_External_Rel *)
				      sreloc->contents)
				     + sreloc->reloc_count));
	  ++sreloc->reloc_count;
d1659 2
a1660 1
		  Elf_Internal_Rel outrel;
d1669 3
a1671 5
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
					    (((Elf32_External_Rel *)
					      srelgot->contents)
					     + srelgot->reloc_count));
		  ++srelgot->reloc_count;
a1863 4
#if USE_REL
      elf32_arm_info_to_howto (input_bfd, & bfd_reloc,
			       (Elf_Internal_Rel *) rel);
#else
a1864 1
#endif
d3317 2
a3318 1
      Elf_Internal_Rel rel;
d3368 2
a3369 3
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) srel->contents
				 + plt_index));
d3390 2
a3391 1
      Elf_Internal_Rel rel;
d3417 2
a3418 4
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) srel->contents
				 + srel->reloc_count));
      ++srel->reloc_count;
d3424 2
a3425 1
      Elf_Internal_Rel rel;
d3440 2
a3441 4
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) s->contents
				 + s->reloc_count));
      ++s->reloc_count;
@


1.97
log
@	* elf32-arm.h (t2a1_push_insn, t2a2_ldr_insn, t2a3_mov_insn,
	t2a4_bx_insn, t2a5_pop_insn, t2a6_bx_insn): Remove.
@
text
@d3221 1
a3221 13
	  asection ** spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != NULL;
	       spp = &(*spp)->next)
	    {
	      if (*spp == s->output_section)
		{
		  bfd_section_list_remove (s->output_section->owner, spp);
		  --s->output_section->owner->section_count;
		  break;
		}
	    }
@


1.96
log
@	* elfxx-target.h (USE_REL): Don't define as 1.
	* elf32-arm.h (USE_REL): Provide a default define of 0.
	Use #if rather than #ifdef when testing USE_REL.
	* elf32-m32r.c: Likewise.

	* elf32-arc.c (USE_REL): Define as 1.
	* elf32-d10v.c (USE_REL): Likewise.
	* elf32-m32r.c (USE_REL): Likewise.
	* elf32-m68hc11.c (USE_REL): Likewise.
	* elf32-m68hc12.c (USE_REL): Likewise.
	* elf32-or32.c (USE_REL): Likewise.
	* elfarm-nabi.c (USE_REL): Likewise.
@
text
@a369 7
static const insn16 t2a1_push_insn = 0xb540;
static const insn16 t2a2_ldr_insn = 0x4e03;
static const insn16 t2a3_mov_insn = 0x46fe;
static const insn16 t2a4_bx_insn = 0x4730;
static const insn32 t2a5_pop_insn = 0xe8bd4040;
static const insn32 t2a6_bx_insn = 0xe12fff1e;

@


1.95
log
@	* Makefile.am (BFD32_BACKENDS): Remove elfarmqnx-nabi.lo,
	elf32-i386-fbsd.lo, elf32-i386qnx.lo, elf32-ppcqnx.lo,
	elf32-sh-lin.lo, elf32-sh64-lin.lo, elf32-sh-nbsd.lo,
	elf32-sh64-nbsd.lo, elf32-shqnx.lo.  Add elf32-qnx.lo.
	(BFD32_BACKENDS_CFILES): Likewise for corresponding C files.
	(BFD64_BACKENDS): Remove elf64-sh64-lin.lo, elf64-sh64-nbsd.lo.
	(BFD64_BACKENDS_CFILES): Likewise for corresponding C files.
	(SOURCE_HFILES): Add elf32-qnx.h.
	(BUILD_HFILES): Add bfdver.h.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in Update bfd vector dependencies.
	* configure: Regenerate.
	* elf32-i386-fbsd.c: Delete.  Move code to elf32-i386.c.
	* elf32-i386qnx.c: Likewise.
	* elf32-ppcqnx.c: Delete.  Move code to elf32-ppc.c.
	* elf32-sh-nbsd.c: Delete.  Move code to elf32-sh.c.
	* elf32-sh-lin.c: Likewise.
	* elf32-shqnx.c: Likewise.
	* elf32-sh64-lin.c: Delete.  Move code to elf32-sh64.c.
	* elf32-sh64-nbsd.c: Likewise.
	* elf64-sh64-lin.c: Delete.  Move code to elf64-sh64.c.
	* elf64-sh64-nbsd.c: Likewise.
	* elfarmqnx-nabi.c: Delete.  Move code to elfarm-nabi.c.
	* elf32-arm.h (ELF_MAXPAGESIZE): Always define.
	* elf32-i386.c: Remove ELF_ARCH and ELF32_I386_C_INCLUDED tests.
	* elf32-ppc.c: Remove ELF32_PPC_C_INCLUDED tests.
	* elf32-qnx.h (elf_backend_set_nonloadable_filepos): Always define.
	(elf_backend_is_contained_by_filepos): Likewise.
	(elf_backend_copy_private_bfd_data_p): Likewise.
	Globalize and move functions to..
	* elf32-qnx.c: ..here.  New file.
	* elf32-sh.c: Remove ELF_ARCH and ELF32_SH_C_INCLUDED tests.  Don't
	emit target vectors when INCLUDE_SHMEDIA.
	* elf32-sh64.c: Remove ELF_ARCH test.  Move TARGET_* etc. defines to
	end of file.
	* elf64-sh64.c: Remove ELF_ARCH test.
	* elfarm-nabi.c: Remove ELFARM_NABI_C_INCLUDED test.
	* po/BLD-POTFILES.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d20 4
d83 1
a83 1
#ifdef USE_REL
d1101 1
a1101 1
#ifdef USE_REL
d1377 1
a1377 1
#ifdef USE_REL
d1409 1
a1409 1
#ifdef USE_REL
d1514 1
a1514 1
#ifdef USE_REL
d1752 1
a1752 1
#ifdef USE_REL
d1844 1
a1844 1
#ifndef USE_REL
d1873 1
a1873 1
#ifdef USE_REL
d1881 1
a1881 1
#ifdef USE_REL
d1914 1
a1914 1
#ifdef USE_REL
d3683 1
a3683 1
#ifndef USE_REL
@


1.94
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a3651 1
#ifndef ELF_MAXPAGESIZE
a3652 1
#endif
@


1.93
log
@(elf32_arm_adjust_dynamic_symbol): Update ELF_LINK_HASH_NEEDS_PLT logic.
@
text
@d430 1
d464 1
d468 1
a468 2
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
d486 1
d518 1
d522 1
a522 2
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
d525 1
d542 1
a542 2
  myh = NULL;

d546 1
a546 2
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
@


1.93.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a19 4
#ifndef USE_REL
#define USE_REL	0
#endif

d79 1
a79 1
#if USE_REL
a429 1
  struct bfd_link_hash_entry * bh;
a462 1
  bh = NULL;
d466 2
a467 1
				    NULL, true, false, &bh);
a484 1
  struct bfd_link_hash_entry *bh;
a515 1
  bh = NULL;
d519 2
a520 1
				    NULL, true, false, &bh);
a522 1
  myh = (struct elf_link_hash_entry *) bh;
d539 2
a540 1
  bh = NULL;
d544 2
a545 1
				    NULL, true, false, &bh);
d1096 1
a1096 1
#if USE_REL
d1372 1
a1372 1
#if USE_REL
d1404 1
a1404 1
#if USE_REL
d1509 1
a1509 1
#if USE_REL
d1747 1
a1747 1
#if USE_REL
d1839 1
a1839 1
#if !USE_REL
d1868 1
a1868 1
#if USE_REL
d1876 1
a1876 1
#if USE_REL
d1909 1
a1909 1
#if USE_REL
d3651 1
d3653 1
d3680 1
a3680 1
#if !USE_REL
@


1.93.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d27 1
a27 1
static bfd_boolean elf32_arm_set_private_flags
d29 1
a29 1
static bfd_boolean elf32_arm_copy_private_bfd_data
d31 1
a31 1
static bfd_boolean elf32_arm_merge_private_bfd_data
d33 1
a33 1
static bfd_boolean elf32_arm_print_private_bfd_data
d57 1
a57 1
static bfd_boolean elf32_arm_relocate_section
d63 1
a63 1
static bfd_boolean elf32_arm_gc_sweep_hook
d66 1
a66 1
static bfd_boolean elf32_arm_check_relocs
d69 1
a69 1
static bfd_boolean elf32_arm_find_nearest_line
d72 1
a72 1
static bfd_boolean elf32_arm_adjust_dynamic_symbol
d74 1
a74 1
static bfd_boolean elf32_arm_size_dynamic_sections
d76 1
a76 1
static bfd_boolean elf32_arm_finish_dynamic_symbol
d79 1
a79 1
static bfd_boolean elf32_arm_finish_dynamic_sections
a86 6
static bfd_boolean allocate_dynrelocs 
  PARAMS ((struct elf_link_hash_entry *h, PTR inf));
static bfd_boolean create_got_section 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static bfd_boolean elf32_arm_create_dynamic_sections 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
a88 2
static bfd_boolean elf32_arm_object_p
  PARAMS ((bfd *));
d95 1
a95 1
bfd_boolean bfd_elf32_arm_allocate_interworking_sections
d97 1
a97 1
bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
d99 1
a99 1
bfd_boolean bfd_elf32_arm_process_before_allocation
a119 6
#ifdef FOUR_WORD_PLT

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 16

d127 1
a127 1
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
d129 4
a132 4
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
d138 6
a143 39
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };

#else

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 20

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };

#endif
d153 1
a153 1
struct elf32_arm_relocs_copied
d156 1
a156 1
    struct elf32_arm_relocs_copied * next;
a160 2
    /* Number of relocs copied in this section.  */
    bfd_size_type pc_count;
d169 1
a169 1
    struct elf32_arm_relocs_copied * relocs_copied;
d172 4
d180 1
a180 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d193 1
a193 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d196 1
a196 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d199 1
a199 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
a204 12

    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;

    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
d232 1
a232 1
    ret->relocs_copied = NULL;
a236 110
/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf32_arm_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");

  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;

	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->relocs_copied;
	}

      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a256 7
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
a260 1
  ret->sym_sec.abfd = NULL;
d288 1
a288 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d323 1
a323 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d370 7
d378 1
a378 1
bfd_boolean
d422 1
a422 1
  return TRUE;
d456 1
a456 1
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d472 1
a472 1
				    NULL, TRUE, FALSE, &bh);
d513 1
a513 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d526 1
a526 1
				    NULL, TRUE, FALSE, &bh);
d550 1
a550 1
				    NULL, TRUE, FALSE, &bh);
d562 1
a562 1
bfd_boolean
d572 2
a573 2
  if (info->relocatable)
    return TRUE;
d589 1
a589 1
	return FALSE;
d607 1
a607 1
	return FALSE;
d612 1
a612 1
  return TRUE;
d619 1
a619 1
bfd_boolean
d628 2
a629 2
  if (info->relocatable)
    return TRUE;
d636 1
a636 1
    return TRUE;
d641 1
a641 1
  return TRUE;
d644 1
a644 1
bfd_boolean
d660 2
a661 2
  if (link_info->relocatable)
    return TRUE;
d676 1
a676 1
    return TRUE;
d687 2
a688 2
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);
d779 1
a779 1
  return TRUE;
d789 1
a789 1
  return FALSE;
d800 1
a800 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
d874 1
a874 1
    return FALSE;
d903 1
a903 1
	  return FALSE;
d937 7
a943 10
  /* Now go back and fix up the original BL insn to point to here.  */
  ret_offset =
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
    - 8;
d952 1
a952 1
  return TRUE;
d980 1
a980 1
    return FALSE;
d1040 1
a1040 1
  return TRUE;
a1042 12
/* This is the condition under which elf32_arm_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_arm_relocate_section
   and elf32_arm_final_link_relocate.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H)			\
  ((DYN)								\
   && ((SHARED)							 	\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

a1126 6
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	return bfd_reloc_ok;

d1129 11
a1139 11
      if ((info->shared
	   && (input_section->flags & SEC_ALLOC)
	   && (h == NULL
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	   && (r_type != R_ARM_PC24
	       || !SYMBOL_CALLS_LOCAL (info, h))))
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;
	  bfd_boolean skip, relocate;
d1161 2
a1162 2
	  skip = FALSE;
	  relocate = FALSE;
d1168 1
a1168 1
	    skip = TRUE;
d1170 1
a1170 1
	    skip = TRUE, relocate = TRUE;
d1176 7
a1182 8
	  else if (h != NULL
		   && h->dynindx != -1
		   && (r_type == R_ARM_PC24
		       || !info->shared
		       || !info->symbolic
		       || (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d1185 15
a1199 3
	      /* This symbol is local, or marked to become local.  */
	      relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
d1202 5
a1206 3
	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1400 4
a1403 4
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
d1406 1
a1406 1
	bfd_vma check;
d1483 1
a1483 1
	  overflow = TRUE;
a1610 1
	  bfd_boolean dyn;
a1613 1
	  dyn = globals->root.dynamic_sections_created;
d1615 3
a1617 5
	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
d1667 1
a1667 2
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;
d1676 5
a1680 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1704 1
a1704 2
      if (h->plt.offset == (bfd_vma) -1
	  || globals->splt == NULL)
d1826 1
a1826 1
static bfd_boolean
d1829 8
a1836 8
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1838 5
a1842 5
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;
d1845 2
a1846 2
  if (info->relocatable)
    return TRUE;
d1873 4
d1878 1
d1882 1
a1882 1
      if (info->relocatable)
d1884 1
a1884 1
	  /* This is a relocatable link.  We don't have to change
d1931 1
a1931 1
		  return FALSE;
d1955 1
a1955 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1960 1
a1960 2
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
d1962 6
a1967 6
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation,
				   sec, unresolved_reloc, info,
				   warned);
	  
	  if (unresolved_reloc || relocation != 0)
d1969 4
d1983 1
a1983 1
			  (!info->symbolic && h->dynindx != -1)
a1985 1
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
d1995 1
a1995 1
	            relocation = 0;
d1999 1
a1999 1
	          relocation = 0;
d2003 2
a2004 4
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
d2006 4
a2009 3
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
	            relocation = 0;
d2014 1
a2014 1
	            relocation = 0;
d2018 10
a2027 8
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
		       bfd_archive_filename (input_bfd),
		       r_type,
		       h->root.root.string,
		       bfd_get_section_name (input_bfd, input_section));
		  break;
d2029 23
d2086 1
a2086 1
		  return FALSE;
d2092 2
a2093 2
		     rel->r_offset, TRUE)))
		return FALSE;
d2116 1
a2116 1
		return FALSE;
d2122 1
a2122 23
  return TRUE;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (abfd)
     bfd *abfd;
{
  unsigned int mach;
  
  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);

  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  return TRUE;
d2126 1
a2126 1
static bfd_boolean
d2149 1
a2149 1
      elf_flags_init (abfd) = TRUE;
d2152 1
a2152 1
  return TRUE;
d2157 1
a2157 1
static bfd_boolean
d2167 1
a2167 1
    return TRUE;
d2178 1
a2178 1
	return FALSE;
d2182 1
a2182 1
	return FALSE;
d2203 1
a2203 1
  elf_flags_init (obfd) = TRUE;
d2205 1
a2205 1
  return TRUE;
d2211 1
a2211 1
static bfd_boolean
d2218 2
a2219 1
  bfd_boolean flags_compatible = TRUE;
d2224 1
a2224 1
    return FALSE;
d2228 1
a2228 1
    return TRUE;
d2249 1
a2249 1
	return TRUE;
d2251 1
a2251 1
      elf_flags_init (obfd) = TRUE;
d2258 1
a2258 1
      return TRUE;
a2260 5
  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

d2263 1
a2263 7
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatibility.  Do not short-circuit
     dynamic objects; their section list may be emptied by
     elf_link_add_object_symbols.  */
d2265 8
a2272 5
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
d2274 2
a2275 7
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      null_input_bfd = FALSE;
	      break;
	    }
a2276 2
      if (null_input_bfd)
	return TRUE;
d2278 2
d2290 1
a2290 1
      return FALSE;
d2304 1
a2304 1
	  flags_compatible = FALSE;
d2320 1
a2320 1
	  flags_compatible = FALSE;
d2327 1
a2327 17
ERROR: %s uses VFP instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s uses FPA instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
d2332 1
a2332 1
ERROR: %s does not use Maverick instructions, whereas %s does"),
d2336 1
a2336 1
	  flags_compatible = FALSE;
d2361 1
a2361 1
	      flags_compatible = FALSE;
d2391 1
a2391 1
static bfd_boolean
d2414 1
a2414 1
      /* The following flag bits are GNU extensions and not part of the
a2426 2
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
d2447 1
a2447 2
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
d2499 1
a2499 1
  return TRUE;
d2567 1
a2567 1
static bfd_boolean
d2574 2
a2575 77
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GOT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_ARM_ABS32:
      case R_ARM_REL32:
      case R_ARM_PC24:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_arm_link_hash_entry *eh;
	    struct elf32_arm_relocs_copied **pp;
	    struct elf32_arm_relocs_copied *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf32_arm_link_hash_entry *) h;

	    for (pp = &eh->relocs_copied; (p = *pp) != NULL; pp = &p->next)
	      if (p->section == sec)
		{
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      default:
	break;
      }

  return TRUE;
d2580 1
a2580 1
static bfd_boolean
d2582 4
a2585 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2587 8
a2594 9
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sreloc;
  bfd_vma *local_got_offsets;
  struct elf32_arm_link_hash_table *htab;
d2596 2
a2597 2
  if (info->relocatable)
    return TRUE;
d2599 1
a2599 2
  htab = elf32_arm_hash_table (info);
  sreloc = NULL;
d2624 18
d2644 7
a2650 7
	  case R_ARM_PLT32:
	    /* This symbol requires a procedure linkage table entry.  We
               actually build the entry in adjust_dynamic_symbol,
               because this might be a case of linking PIC code which is
               never referenced by a dynamic object, in which case we
               don't need to generate a procedure linkage table entry
               after all.  */
d2652 5
a2656 4
	    /* If this is a local symbol, we resolve it directly without
               creating a procedure linkage table entry.  */
	    if (h == NULL)
	      continue;
d2658 16
a2673 3
	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    h->plt.refcount++;
	    break;
a2674 2
	  case R_ARM_GOT32:
	    /* This symbol requires a global offset table entry.  */
d2677 12
a2688 1
		h->got.refcount++;
d2692 3
a2694 5
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
d2697 1
d2700 7
a2706 6
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
d2708 12
a2719 1
		local_got_refcounts[r_symndx] += 1;
d2721 2
d2725 14
a2738 9
	  case R_ARM_GOTOFF:
	  case R_ARM_GOTPC:
	    if (htab->sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
a2743 15
	    if (h != NULL && !info->shared)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
		
		/* We may need a .plt entry if the function this reloc
		   refers to is in a shared lib.  */
		h->plt.refcount += 1;
	      }

d2755 1
a2755 1
               relocs_copied field of the hash table entry.  */
d2757 5
a2761 6
		&& (sec->flags & SEC_ALLOC) != 0
		&& (ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		    || (h != NULL
			&& (! info->symbolic
			    || (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0))))
a2762 2
		struct elf32_arm_relocs_copied *p, **head;

d2775 1
a2775 1
		      return FALSE;
d2794 1
a2794 1
			  return FALSE;
d2796 2
a2797 2

		    elf_section_data (sec)->sreloc = sreloc;
d2800 11
a2810 3
		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
d2812 9
a2820 23
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */
		    
		    asection *s;
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
		    if (s == NULL)
		      return FALSE;
		    
		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
		  }
		
		p = *head;
		if (p == NULL || p->section != sec)
		  {
		    bfd_size_type amt = sizeof *p;
		    p = bfd_alloc (htab->root.dynobj, amt);
d2822 12
a2833 6
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->section = sec;
		    p->count = 0;
		    p->pc_count = 0;
a2834 4
		
		p->count += 1;
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		  p->pc_count += 1;
d2842 1
a2842 1
            return FALSE;
d2849 1
a2849 1
            return FALSE;
d2854 1
a2854 1
  return TRUE;
d2861 1
a2861 1
static bfd_boolean
d2864 13
a2876 13
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  bfd_boolean found;
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;
d2882 1
a2882 1
    return TRUE;
d2888 1
a2888 1
    return FALSE;
d2891 1
a2891 1
    return TRUE;
d2894 1
a2894 1
    return FALSE;
d2931 1
a2931 1
    return FALSE;
d2937 1
a2937 1
  return TRUE;
d2946 1
a2946 1
static bfd_boolean
d2974 8
a2981 4
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d2984 5
a2988 5
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
d2990 1
d2993 45
a3037 1
      return TRUE;
a3038 7
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;
d3049 1
a3049 1
      return TRUE;
d3060 1
a3060 1
    return TRUE;
d3100 1
a3100 1
	return FALSE;
d3110 1
a3110 193
  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_HEADER_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rel);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rel);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_arm_link_hash_entry *) h;
  if (eh->relocs_copied == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* The only reloc that uses pc_count is R_ARM_PC24, which will
	 appear on a call or on something like ".long foo - .".  We
	 want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing assembly like ".long foo - .".  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf32_arm_relocs_copied **pp;

	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->relocs_copied = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->relocs_copied = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->relocs_copied; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->section)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rel);
    }

  return TRUE;
d3115 1
a3115 1
static bfd_boolean
d3122 2
a3123 4
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;
a3124 1
  htab = elf32_arm_hash_table (info);
d3131 1
a3131 1
      if (info->executable)
d3139 20
a3158 68

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_arm_relocs_copied *p;

	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->section)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rel);
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rel);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d3163 2
a3164 2
  plt = FALSE;
  relocs = FALSE;
d3168 1
a3168 1
      bfd_boolean strip;
d3177 1
a3177 1
      strip = FALSE;
d3185 1
a3185 1
	      strip = TRUE;
d3190 1
a3190 1
	      plt = TRUE;
d3206 1
a3206 1
	      strip = TRUE;
d3213 1
a3213 1
		relocs = TRUE;
d3228 13
a3240 1
	  _bfd_strip_section_from_output (info, s);
d3247 1
a3247 1
	return FALSE;
d3263 1
a3263 1
	    return FALSE;
d3272 1
a3272 1
	    return FALSE;
d3280 1
a3280 1
	    return FALSE;
d3286 1
a3286 1
	    return FALSE;
d3292 28
a3319 1
  return TRUE;
d3325 1
a3325 1
static bfd_boolean
d3343 1
a3343 3
      Elf_Internal_Rela rel;
      bfd_byte *loc;
      bfd_vma got_displacement;
d3359 1
a3359 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
a3365 12
      /* Calculate the displacement between the PLT slot and the
	 entry in the GOT.  */
      got_displacement = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset
			  - splt->output_section->vma
			  - splt->output_offset
			  - h->plt.offset
			  - 8);

      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

d3367 1
a3367 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
d3369 1
a3369 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
d3371 1
a3371 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
d3373 8
a3380 4
#ifdef FOUR_WORD_PLT
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		  splt->contents + h->plt.offset + 12);
#endif
d3387 1
a3387 1
      
d3393 3
a3395 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3416 1
a3416 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3428 4
a3431 5
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
d3433 3
a3435 5
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	}
a3437 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
d3442 4
a3445 2
      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3451 1
a3451 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3466 4
a3469 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3477 1
a3477 1
  return TRUE;
d3482 1
a3482 1
static bfd_boolean
d3573 1
a3573 1
		 then there is nothing to adjust.  */
d3579 1
a3579 1
					     FALSE, FALSE, TRUE);
d3584 1
a3584 1
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a3593 9
	  bfd_vma got_displacement;

	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

a3597 7
#ifdef FOUR_WORD_PLT
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
#else
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
#endif
d3620 1
a3620 1
  return TRUE;
a3652 23
static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, Elf_Internal_Shdr *));
static void        elf32_arm_final_write_processing  PARAMS ((bfd *, bfd_boolean));

/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

void
elf32_arm_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}
a3655 3
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
a3656 1
#endif
d3672 1
a3672 1
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
a3677 4
#define elf_backend_object_p			elf32_arm_object_p
#define elf_backend_section_flags		elf32_arm_section_flags
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol
a3678 1
#define elf_backend_can_refcount    1
d3688 1
@


1.93.4.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d208 2
d386 1
a1309 1
    case R_ARM_PLT32:
a1315 19
      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
	  && h != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  BFD_ASSERT (splt != NULL);
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset);
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}

d1318 7
a1324 7
      if (info->shared
	  && (input_section->flags & SEC_ALLOC)
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
	  && r_type != R_ARM_PLT32)
d1367 2
a1368 1
		   && (!info->shared
a1399 1
	case R_ARM_PLT32:
d1872 31
a2810 1
      case R_ARM_PLT32:
d2820 1
a2820 1
	    if (h->plt.refcount > 0)
d2823 14
a2836 4
	    if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
	      {
		eh = (struct elf32_arm_link_hash_entry *) h;
d2838 7
a2844 10
		for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		     pp = &p->next)
		if (p->section == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	      }
d2905 17
d2964 1
a2964 2
	  case R_ARM_PLT32:
	    if (h != NULL)
d2972 2
a2973 3
		if (!info->shared)
		  h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

d2975 1
a2975 5
		   refers to is in a different object.  */
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_PLT32)
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

d2993 1
a2993 2
		&& ((ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32)
d3071 1
d3074 3
a3076 3
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
		  p->count += 1;
d3351 1
a3351 1
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d3435 23
a3457 2
      /* Discard relocs on undefined weak syms with non-default
         visibility.  */
@


1.93.4.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a1319 1
	  && splt != NULL
d1322 1
a1322 3
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
d2940 1
a2940 3
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
a2944 2
		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
@


1.93.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a429 1
  struct bfd_link_hash_entry * bh;
a462 1
  bh = NULL;
d466 2
a467 1
				    NULL, true, false, &bh);
a484 1
  struct bfd_link_hash_entry *bh;
a515 1
  bh = NULL;
d519 2
a520 1
				    NULL, true, false, &bh);
a522 1
  myh = (struct elf_link_hash_entry *) bh;
d539 2
a540 1
  bh = NULL;
d544 2
a545 1
				    NULL, true, false, &bh);
@


1.93.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a19 4
#ifndef USE_REL
#define USE_REL	0
#endif

d79 1
a79 1
#if USE_REL
d1097 1
a1097 1
#if USE_REL
d1373 1
a1373 1
#if USE_REL
d1405 1
a1405 1
#if USE_REL
d1510 1
a1510 1
#if USE_REL
d1748 1
a1748 1
#if USE_REL
d1840 1
a1840 1
#if !USE_REL
d1869 1
a1869 1
#if USE_REL
d1877 1
a1877 1
#if USE_REL
d1910 1
a1910 1
#if USE_REL
d3652 1
d3654 1
d3681 1
a3681 1
#if !USE_REL
@


1.93.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d370 7
d3228 13
a3240 1
	  _bfd_strip_section_from_output (info, s);
@


1.93.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d27 1
a27 1
static bfd_boolean elf32_arm_set_private_flags
d29 1
a29 1
static bfd_boolean elf32_arm_copy_private_bfd_data
d31 1
a31 1
static bfd_boolean elf32_arm_merge_private_bfd_data
d33 1
a33 1
static bfd_boolean elf32_arm_print_private_bfd_data
d57 1
a57 1
static bfd_boolean elf32_arm_relocate_section
d63 1
a63 1
static bfd_boolean elf32_arm_gc_sweep_hook
d66 1
a66 1
static bfd_boolean elf32_arm_check_relocs
d69 1
a69 1
static bfd_boolean elf32_arm_find_nearest_line
d72 1
a72 1
static bfd_boolean elf32_arm_adjust_dynamic_symbol
d74 1
a74 1
static bfd_boolean elf32_arm_size_dynamic_sections
d76 1
a76 1
static bfd_boolean elf32_arm_finish_dynamic_symbol
d79 1
a79 1
static bfd_boolean elf32_arm_finish_dynamic_sections
d95 1
a95 1
bfd_boolean bfd_elf32_arm_allocate_interworking_sections
d97 1
a97 1
bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
d99 1
a99 1
bfd_boolean bfd_elf32_arm_process_before_allocation
d173 1
a173 1
static bfd_boolean elf32_arm_discard_copies
d180 1
a180 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d288 1
a288 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d323 1
a323 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d371 1
a371 1
bfd_boolean
d415 1
a415 1
  return TRUE;
d449 1
a449 1
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d465 1
a465 1
				    NULL, TRUE, FALSE, &bh);
d506 1
a506 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d519 1
a519 1
				    NULL, TRUE, FALSE, &bh);
d543 1
a543 1
				    NULL, TRUE, FALSE, &bh);
d555 1
a555 1
bfd_boolean
d566 1
a566 1
    return TRUE;
d582 1
a582 1
	return FALSE;
d600 1
a600 1
	return FALSE;
d605 1
a605 1
  return TRUE;
d612 1
a612 1
bfd_boolean
d622 1
a622 1
    return TRUE;
d629 1
a629 1
    return TRUE;
d634 1
a634 1
  return TRUE;
d637 1
a637 1
bfd_boolean
d654 1
a654 1
    return TRUE;
d669 1
a669 1
    return TRUE;
d681 1
a681 1
				       (Elf_Internal_Rela *) NULL, FALSE);
d772 1
a772 1
  return TRUE;
d782 1
a782 1
  return FALSE;
d867 1
a867 1
    return FALSE;
d896 1
a896 1
	  return FALSE;
d945 1
a945 1
  return TRUE;
d973 1
a973 1
    return FALSE;
d1033 1
a1033 1
  return TRUE;
d1131 2
a1132 3
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;
	  bfd_boolean skip, relocate;
d1154 2
a1155 2
	  skip = FALSE;
	  relocate = FALSE;
d1161 1
a1161 1
	    skip = TRUE;
d1163 1
a1163 1
	    skip = TRUE, relocate = TRUE;
d1173 1
a1173 1
		relocate = TRUE;
d1183 1
a1183 1
		  relocate = TRUE;
d1190 1
a1190 1
		    relocate = TRUE;
d1195 5
a1199 3
	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1393 4
a1396 4
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
d1399 1
a1399 1
	bfd_vma check;
d1476 1
a1476 1
	  overflow = TRUE;
d1660 1
a1660 2
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;
d1669 5
a1673 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1819 1
a1819 1
static bfd_boolean
d1822 8
a1829 8
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1831 5
a1835 5
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;
d1839 1
a1839 1
    return TRUE;
d1866 4
d1871 1
d1924 1
a1924 1
		  return FALSE;
d2043 1
a2043 1
		return FALSE;
d2079 1
a2079 1
		  return FALSE;
d2085 2
a2086 2
		     rel->r_offset, TRUE)))
		return FALSE;
d2109 1
a2109 1
		return FALSE;
d2115 1
a2115 1
  return TRUE;
d2119 1
a2119 1
static bfd_boolean
d2142 1
a2142 1
      elf_flags_init (abfd) = TRUE;
d2145 1
a2145 1
  return TRUE;
d2150 1
a2150 1
static bfd_boolean
d2160 1
a2160 1
    return TRUE;
d2171 1
a2171 1
	return FALSE;
d2175 1
a2175 1
	return FALSE;
d2196 1
a2196 1
  elf_flags_init (obfd) = TRUE;
d2198 1
a2198 1
  return TRUE;
d2204 1
a2204 1
static bfd_boolean
d2211 2
a2212 2
  bfd_boolean flags_compatible = TRUE;
  bfd_boolean null_input_bfd = TRUE;
d2217 1
a2217 1
    return FALSE;
d2221 1
a2221 1
    return TRUE;
d2242 1
a2242 1
	return TRUE;
d2244 1
a2244 1
      elf_flags_init (obfd) = TRUE;
d2251 1
a2251 1
      return TRUE;
d2256 1
a2256 1
    return TRUE;
d2267 1
a2267 1
	  null_input_bfd = FALSE;
d2272 1
a2272 1
    return TRUE;
d2283 1
a2283 1
      return FALSE;
d2297 1
a2297 1
	  flags_compatible = FALSE;
d2313 1
a2313 1
	  flags_compatible = FALSE;
d2329 1
a2329 1
	  flags_compatible = FALSE;
d2354 1
a2354 1
	      flags_compatible = FALSE;
d2384 1
a2384 1
static bfd_boolean
d2492 1
a2492 1
  return TRUE;
d2560 1
a2560 1
static bfd_boolean
d2568 1
a2568 1
  return TRUE;
d2573 1
a2573 1
static bfd_boolean
d2575 4
a2578 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2580 8
a2587 8
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sgot, *srelgot, *sreloc;
  bfd_vma *local_got_offsets;
d2590 1
a2590 1
    return TRUE;
d2627 1
a2627 1
		return FALSE;
d2664 1
a2664 1
		      return FALSE;
d2679 1
a2679 1
		    return FALSE;
d2696 1
a2696 1
		      return FALSE;
d2768 1
a2768 1
		      return FALSE;
d2787 1
a2787 1
			  return FALSE;
d2819 1
a2819 1
			  return FALSE;
d2835 1
a2835 1
            return FALSE;
d2842 1
a2842 1
            return FALSE;
d2847 1
a2847 1
  return TRUE;
d2854 1
a2854 1
static bfd_boolean
d2857 13
a2869 13
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  bfd_boolean found;
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;
d2875 1
a2875 1
    return TRUE;
d2881 1
a2881 1
    return FALSE;
d2884 1
a2884 1
    return TRUE;
d2887 1
a2887 1
    return FALSE;
d2924 1
a2924 1
    return FALSE;
d2930 1
a2930 1
  return TRUE;
d2939 1
a2939 1
static bfd_boolean
d2983 1
a2983 1
	  return TRUE;
d2990 1
a2990 1
	    return FALSE;
d3030 1
a3030 1
      return TRUE;
d3042 1
a3042 1
      return TRUE;
d3053 1
a3053 1
    return TRUE;
d3093 1
a3093 1
	return FALSE;
d3103 1
a3103 1
  return TRUE;
d3108 1
a3108 1
static bfd_boolean
d3115 2
a3116 2
  bfd_boolean plt;
  bfd_boolean relocs;
d3156 2
a3157 2
  plt = FALSE;
  relocs = FALSE;
d3161 1
a3161 1
      bfd_boolean strip;
d3170 1
a3170 1
      strip = FALSE;
d3178 1
a3178 1
	      strip = TRUE;
d3183 1
a3183 1
	      plt = TRUE;
d3199 1
a3199 1
	      strip = TRUE;
d3206 1
a3206 1
		relocs = TRUE;
d3228 1
a3228 1
	return FALSE;
d3244 1
a3244 1
	    return FALSE;
d3253 1
a3253 1
	    return FALSE;
d3261 1
a3261 1
	    return FALSE;
d3267 1
a3267 1
	    return FALSE;
d3273 1
a3273 1
  return TRUE;
d3283 1
a3283 1
static bfd_boolean
d3295 1
a3295 1
    return TRUE;
d3300 1
a3300 1
  return TRUE;
d3306 1
a3306 1
static bfd_boolean
d3324 1
a3324 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3374 3
a3376 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3397 1
a3397 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3423 4
a3426 2
      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3432 1
a3432 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3447 4
a3450 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3458 1
a3458 1
  return TRUE;
d3463 1
a3463 1
static bfd_boolean
d3560 1
a3560 1
					     FALSE, FALSE, TRUE);
d3565 1
a3565 1
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d3601 1
a3601 1
  return TRUE;
@


1.93.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a88 2
static bfd_boolean elf32_arm_object_p
  PARAMS ((bfd *));
d930 7
a936 10
  /* Now go back and fix up the original BL insn to point to here.  */
  ret_offset =
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
    - 8;
a2110 14
/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (abfd)
     bfd *abfd;
{
  /* XXX - we ought to examine a .note section here.  */

  if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  return TRUE;
}

d2313 1
a2313 17
ERROR: %s uses VFP instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s uses FPA instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
d2318 1
a2318 1
ERROR: %s uses Maverick instructions, whereas %s does not"),
a2412 2
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
d2433 1
a2433 2
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
d3625 1
a3649 1
#define elf_backend_object_p			elf32_arm_object_p
@


1.93.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2122 1
a2122 3
  unsigned int mach;
  
  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
d2124 1
a2124 4
  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
a2126 3
  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

a2265 5
  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

a3662 24
static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, Elf_Internal_Shdr *));
static void        elf32_arm_final_write_processing  PARAMS ((bfd *, bfd_boolean));

/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

void
elf32_arm_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

a3687 2
#define elf_backend_section_flags		elf32_arm_section_flags
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
@


1.93.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d682 2
a683 2
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);
@


1.93.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d567 1
a567 1
  if (info->relocatable)
d623 1
a623 1
  if (info->relocatable)
d655 1
a655 1
  if (link_info->relocatable)
d1841 1
a1841 1
  if (info->relocatable)
d1873 1
a1873 1
      if (info->relocatable)
d1875 1
a1875 1
	  /* This is a relocatable link.  We don't have to change
d2633 1
a2633 1
  if (info->relocatable)
@


1.93.2.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a3701 3
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
a3702 1
#endif
@


1.93.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a1040 12
/* This is the condition under which elf32_arm_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_arm_relocate_section
   and elf32_arm_final_link_relocate.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H)			\
  ((DYN)								\
   && ((SHARED)							 	\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

a1607 1
	  bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;
d1612 3
a1614 5
	  if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && (info->symbolic || h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d1951 5
a1955 2
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
d1957 2
a1958 6
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation,
				   sec, unresolved_reloc, info,
				   warned);
	  
	  if (unresolved_reloc || relocation != 0)
d1960 4
d1986 1
a1986 1
	            relocation = 0;
d1990 1
a1990 1
	          relocation = 0;
d1994 2
a1995 4
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
d1997 4
a2000 3
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
	            relocation = 0;
d2005 1
a2005 1
	            relocation = 0;
d2009 10
a2018 8
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
		       bfd_archive_filename (input_bfd),
		       r_type,
		       h->root.root.string,
		       bfd_get_section_name (input_bfd, input_section));
		  break;
d2020 23
@


1.93.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a86 6
static bfd_boolean allocate_dynrelocs 
  PARAMS ((struct elf_link_hash_entry *h, PTR inf));
static bfd_boolean create_got_section 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static bfd_boolean elf32_arm_create_dynamic_sections 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
a121 6
#ifdef FOUR_WORD_PLT

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 16

d129 1
a129 32
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };

#else

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 20

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
d131 4
a134 5
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
d140 6
a145 7
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };

#endif
d155 1
a155 1
struct elf32_arm_relocs_copied
d158 1
a158 1
    struct elf32_arm_relocs_copied * next;
a162 2
    /* Number of relocs copied in this section.  */
    bfd_size_type pc_count;
d171 1
a171 1
    struct elf32_arm_relocs_copied * relocs_copied;
d174 4
a206 12

    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;

    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
d234 1
a234 1
    ret->relocs_copied = NULL;
a238 110
/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf32_arm_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");

  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;

	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->relocs_copied;
	}

      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a258 7
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
a262 1
  ret->sym_sec.abfd = NULL;
a1136 6
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	return bfd_reloc_ok;

d1139 8
a1146 7
      if ((info->shared
	   && (input_section->flags & SEC_ALLOC)
	   && (h == NULL
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	   && (r_type != R_ARM_PC24
	       || !SYMBOL_CALLS_LOCAL (info, h))))
d1187 7
a1193 8
	  else if (h != NULL
		   && h->dynindx != -1
		   && (r_type == R_ARM_PC24
		       || !info->shared
		       || !info->symbolic
		       || (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d1196 15
a1210 3
	      /* This symbol is local, or marked to become local.  */
	      relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
d1620 1
a1620 1
	  bfd_boolean dyn;
a1623 1
	  dyn = globals->root.dynamic_sections_created;
d1625 1
a1625 1
	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1627 3
a1629 3
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
d1715 1
a1715 2
      if (h->plt.offset == (bfd_vma) -1
	  || globals->splt == NULL)
d1961 1
a1961 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1986 1
a1986 1
			  (!info->symbolic && h->dynindx != -1)
a1988 1
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
d2220 1
d2271 8
a2278 11
  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatibility.  Do not short-circuit
     dynamic objects; their section list may be emptied by
     elf_link_add_object_symbols.  */

  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
d2280 2
a2281 7
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      null_input_bfd = FALSE;
	      break;
	    }
a2282 2
      if (null_input_bfd)
	return TRUE;
d2284 2
d2354 1
a2354 1
ERROR: %s does not use Maverick instructions, whereas %s does"),
d2599 1
a2599 76
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GOT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_ARM_ABS32:
      case R_ARM_REL32:
      case R_ARM_PC24:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_arm_link_hash_entry *eh;
	    struct elf32_arm_relocs_copied **pp;
	    struct elf32_arm_relocs_copied *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf32_arm_link_hash_entry *) h;

	    for (pp = &eh->relocs_copied; (p = *pp) != NULL; pp = &p->next)
	      if (p->section == sec)
		{
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      default:
	break;
      }

d2618 1
a2618 1
  asection *sreloc;
a2619 1
  struct elf32_arm_link_hash_table *htab;
d2624 1
a2624 2
  htab = elf32_arm_hash_table (info);
  sreloc = NULL;
d2649 18
d2669 7
a2675 7
	  case R_ARM_PLT32:
	    /* This symbol requires a procedure linkage table entry.  We
               actually build the entry in adjust_dynamic_symbol,
               because this might be a case of linking PIC code which is
               never referenced by a dynamic object, in which case we
               don't need to generate a procedure linkage table entry
               after all.  */
d2677 5
a2681 4
	    /* If this is a local symbol, we resolve it directly without
               creating a procedure linkage table entry.  */
	    if (h == NULL)
	      continue;
d2683 16
a2698 3
	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    h->plt.refcount++;
	    break;
a2699 2
	  case R_ARM_GOT32:
	    /* This symbol requires a global offset table entry.  */
d2702 12
a2713 1
		h->got.refcount++;
d2717 3
a2719 5
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
d2722 1
d2725 3
a2727 4
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
d2729 3
a2731 1
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
d2733 12
a2744 1
		local_got_refcounts[r_symndx] += 1;
d2746 2
d2750 14
a2763 9
	  case R_ARM_GOTOFF:
	  case R_ARM_GOTPC:
	    if (htab->sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
a2768 15
	    if (h != NULL && !info->shared)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
		
		/* We may need a .plt entry if the function this reloc
		   refers to is in a shared lib.  */
		h->plt.refcount += 1;
	      }

d2780 1
a2780 1
               relocs_copied field of the hash table entry.  */
d2782 5
a2786 6
		&& (sec->flags & SEC_ALLOC) != 0
		&& (ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		    || (h != NULL
			&& (! info->symbolic
			    || (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0))))
a2787 2
		struct elf32_arm_relocs_copied *p, **head;

d2821 2
a2822 2

		    elf_section_data (sec)->sreloc = sreloc;
d2825 11
a2835 3
		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
d2837 9
a2845 23
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */
		    
		    asection *s;
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
		    if (s == NULL)
		      return FALSE;
		    
		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
		  }
		
		p = *head;
		if (p == NULL || p->section != sec)
		  {
		    bfd_size_type amt = sizeof *p;
		    p = bfd_alloc (htab->root.dynobj, amt);
d2847 12
a2858 6
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->section = sec;
		    p->count = 0;
		    p->pc_count = 0;
a2859 4
		
		p->count += 1;
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
		  p->pc_count += 1;
d2999 8
a3006 4
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d3009 5
a3013 5
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
d3015 8
d3025 37
a3063 7
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;
a3137 192
/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_HEADER_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rel);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rel);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_arm_link_hash_entry *) h;
  if (eh->relocs_copied == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* The only reloc that uses pc_count is R_ARM_PC24, which will
	 appear on a call or on something like ".long foo - .".  We
	 want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing assembly like ".long foo - .".  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf32_arm_relocs_copied **pp;

	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->relocs_copied = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->relocs_copied = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->relocs_copied; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->section)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rel);
    }

  return TRUE;
}

a3148 2
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;
a3149 1
  htab = elf32_arm_hash_table (info);
d3156 1
a3156 1
      if (info->executable)
d3164 20
a3183 68

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_arm_relocs_copied *p;

	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->section)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rel);
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rel);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d3308 27
a3357 1
      bfd_vma got_displacement;
d3373 1
a3373 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
a3379 12
      /* Calculate the displacement between the PLT slot and the
	 entry in the GOT.  */
      got_displacement = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset
			  - splt->output_section->vma
			  - splt->output_offset
			  - h->plt.offset
			  - 8);

      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

d3381 1
a3381 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
d3383 1
a3383 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
d3385 1
a3385 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
d3387 8
a3394 4
#ifdef FOUR_WORD_PLT
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		  splt->contents + h->plt.offset + 12);
#endif
d3401 1
a3401 1
      
d3442 4
a3445 5
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
d3447 3
a3449 5
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	}
a3451 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
a3604 9
	  bfd_vma got_displacement;

	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

a3608 7
#ifdef FOUR_WORD_PLT
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
#else
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
#endif
d3710 1
a3710 1
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
a3718 1
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol
a3719 1
#define elf_backend_can_refcount    1
d3729 1
@


1.93.2.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d238 1
a238 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d241 1
a241 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d244 1
a244 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
d968 1
a968 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
d2613 1
a2613 1
      /* The following flag bits are GNU extensions and not part of the
d3988 1
a3988 1
		 then there is nothing to adjust.  */
@


1.93.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d208 2
d386 1
a1309 1
    case R_ARM_PLT32:
a1315 22
      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
	  && h != NULL
	  && splt != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset);
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}

d1318 7
a1324 7
      if (info->shared
	  && (input_section->flags & SEC_ALLOC)
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
	  && r_type != R_ARM_PLT32)
d1367 2
a1368 1
		   && (!info->shared
a1399 1
	case R_ARM_PLT32:
d1872 31
a2810 1
      case R_ARM_PLT32:
d2820 1
a2820 1
	    if (h->plt.refcount > 0)
d2823 14
a2836 4
	    if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
	      {
		eh = (struct elf32_arm_link_hash_entry *) h;
d2838 7
a2844 10
		for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		     pp = &p->next)
		if (p->section == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	      }
d2905 17
d2964 1
a2964 2
	  case R_ARM_PLT32:
	    if (h != NULL)
d2972 2
a2973 3
		if (!info->shared)
		  h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

d2975 1
a2975 9
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_PLT32)
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
d2993 1
a2993 2
		&& ((ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32)
d3071 1
d3074 3
a3076 3
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
		  p->count += 1;
d3351 1
a3351 1
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d3435 23
a3457 2
      /* Discard relocs on undefined weak syms with non-default
         visibility.  */
@


1.92
log
@Fix handling of R_ARM_THM_PC11
@
text
@d2969 6
d2976 1
a2976 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
d2979 4
a2982 4
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PC32
             reloc instead.  */
d2984 1
@


1.91
log
@Revert ARM linker patch and apply similar patch to bfd instead
@
text
@d1504 1
a1504 1
	bfd_vma        relocation;
a1506 1
	bfd_vma        check;
d1512 12
a1523 2
	/* ??? Need to determine shift amount from operand size.  */
	addend >>= howto->rightshift;
d1525 1
a1525 1
	relocation = value + addend;
d1531 3
a1533 9
	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just
	   dropped leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

@


1.90
log
@Revert Adam Nemet's THUMB PLT patch
@
text
@d3549 25
@


1.89
log
@Add support for Thumb PLT entries with interworking
@
text
@a97 2
static boolean elf32_arm_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d117 1
a117 4
#define ARM_PLT_ENTRY_SIZE 	16
#define THUMB_PLT_ENTRY_SIZE	20
#define PLT_ENTRY_SIZE(ARM) \
  ((ARM) ? ARM_PLT_ENTRY_SIZE : THUMB_PLT_ENTRY_SIZE)
d123 1
a123 1
static const bfd_vma elf32_arm_plt0_entry [ARM_PLT_ENTRY_SIZE / 4] =
a130 14
static const insn16 elf32_thumb_plt0_entry [THUMB_PLT_ENTRY_SIZE / 2] =
  {
    0xb500,	/* push    {lr}		    */
    0xb082,	/* sub     sp, #8	    */
    0x9000,	/* str     r0, [sp]	    */
    0x4807,	/* ldr     r0, [pc, #28]    */
    0x300c,	/* add     r0, #12	    */
    0x4478,	/* add     r0, pc	    */
    0x4686,	/* mov     lr, r0	    */
    0x6800,	/* ldr     r0, [r0]	    */
    0x9001,	/* str     r0, [sp, #4]	    */
    0xbd01	/* pop     {r0, pc}	    */
  };

d133 1
a133 1
static const bfd_vma elf32_arm_plt_entry [ARM_PLT_ENTRY_SIZE / 4] =
a139 19
 
/* Note that on ARMv5 and above unlike the ARM PLT entries, the Thumb
   entry can switch mode depending on the corresponding address in the
   GOT.  The dynamic linker should set or clear the last bit of the
   address in the GOT accordingly.  */

static const insn16 elf32_thumb_plt_entry [THUMB_PLT_ENTRY_SIZE / 2] =
  {
    0xb082,	/* sub   sp, #8		    */
    0x9000,	/* str   r0, [sp]	    */
    0x4802,	/* ldr   r0, [pc, #8]	    */
    0x4478,	/* add   r0, pc		    */
    0x4684,	/* mov   ip, r0		    */
    0x6800,	/* ldr   r0, [r0]	    */
    0x9001,	/* str   r0, [sp, #4]	    */
    0xbd01,	/* pop   {r0, pc}	    */
    0x0000,	/* offset to symbol in got  */
    0x0000
  };
a158 19

/* We can generate Thumb or ARM PLT entries.  This structure holds
   additional information for symbols that have corresponding PLT
   entries.  */

struct elf32_arm_plt_entry_info
  {
    /* The first relocation type referring to this PLT entry.  Used to
       determine the type of the entry if the symbol is undefined.  */
    long first_rel_type;

    /* True if we decided to emit the ARM version of the PLT entry for
       this symbol.  Otherwise the entry is Thumb.  */
    boolean arm_plt;

    /* The offset of the corresponding .got.plt entry.  */
    bfd_vma got_plt_offset;
  };

a165 2

    struct elf32_arm_plt_entry_info plt_info;
d228 1
a228 4
    {
      ret->pcrel_relocs_copied = NULL;
      ret->plt_info.first_rel_type = R_ARM_NONE;
    }
a1065 1
  asection *                    splt_thumb = NULL;
a1089 1
      splt_thumb = bfd_get_section_by_name (dynobj, ".plt.thumb");
a1414 8

	/* If value is zero then we are linking a shared object and
	   this is a reference to an externally visible symbol.  */
	if (h != NULL && h->plt.offset != (bfd_vma) -1 && value == 0)
	  value = (splt_thumb->output_section->vma
		   + splt_thumb->output_offset
		   + h->plt.offset);

a2730 25
	    {
	      struct elf32_arm_link_hash_entry *eh;

	      eh = (struct elf32_arm_link_hash_entry *) h;
	      if (eh->plt_info.first_rel_type == R_ARM_NONE)
		eh->plt_info.first_rel_type = R_ARM_PLT32;
	    }
	    break;

	  case R_ARM_THM_PC22:
	    /* Since there is no PLT32 for Thumb if we are creating a
	       shared library and this is an externally visible symbol
	       then add it to the PLT.  */
	    if (info->shared && h != NULL && h->dynindx != -1
		&& (! info->symbolic
		    || (h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_REGULAR) == 0))
	      {
		struct elf32_arm_link_hash_entry *eh;

		eh = (struct elf32_arm_link_hash_entry *) h;
		h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		if (eh->plt_info.first_rel_type == R_ARM_NONE)
		  eh->plt_info.first_rel_type = R_ARM_THM_PC22;
	      }
d2963 1
a2963 1
  if (h->type == STT_FUNC || h->type == STT_ARM_TFUNC
a2965 7
      struct elf32_arm_plt_entry_info *plt_info;

      plt_info = &((struct elf32_arm_link_hash_entry *) h)->plt_info;
      plt_info->arm_plt = ! (h->type == STT_ARM_TFUNC ||
			     (h->type != STT_ARM_TFUNC && h->type != STT_FUNC
			      && plt_info->first_rel_type == R_ARM_THM_PC22));

d2986 1
a2986 2
      s = bfd_get_section_by_name (dynobj,
				   plt_info->arm_plt ? ".plt" : ".plt.thumb");
d2989 1
a2989 1
      /* If this is the first PLT entry, make room for the special
d2992 1
a2992 1
	s->_raw_size += PLT_ENTRY_SIZE (plt_info->arm_plt);
d3009 1
a3009 1
      s->_raw_size += PLT_ENTRY_SIZE (plt_info->arm_plt);
a3014 1
      plt_info->got_plt_offset = s->_raw_size;
d3165 1
a3165 2
      /* Match .plt.thumb as well.  */
      if (strncmp (name, ".plt", 4) == 0)
a3324 1
      asection * splt_thumb;
d3327 2
a3328 1
      bfd_vma rel_index;
a3329 1
      struct elf32_arm_plt_entry_info *plt_info;
a3336 1
      splt_thumb = bfd_get_section_by_name (dynobj, ".plt.thumb");
d3339 1
a3339 2
      BFD_ASSERT (splt != NULL && splt_thumb != NULL && sgot != NULL
		  && srel != NULL);
d3341 10
a3350 5
      plt_info = &((struct elf32_arm_link_hash_entry *) h)->plt_info;

      /* Get the index in the relocation table that corresponds to the
	 entry in the global offset table.  */
      rel_index = plt_info->got_plt_offset / 4 - 3;
d3353 7
a3359 11
      
      if (plt_info->arm_plt)
	{
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[0],
		      splt->contents + h->plt.offset + 0);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[1],
		      splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[2],
		      splt->contents + h->plt.offset + 8);

	  bfd_put_32 (output_bfd,
d3362 1
a3362 1
		       + plt_info->got_plt_offset
d3368 5
a3372 41
	  /* Fill in the entry in the global offset table.  */
	  bfd_put_32 (output_bfd,
		      (splt->output_section->vma
		       + splt->output_offset),
		      sgot->contents + plt_info->got_plt_offset);
	}
      else
	{
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[0],
		      splt_thumb->contents + h->plt.offset + 0);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[1],
		      splt_thumb->contents + h->plt.offset + 2);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[2],
		      splt_thumb->contents + h->plt.offset + 4);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[3],
		      splt_thumb->contents + h->plt.offset + 6);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[4],
		      splt_thumb->contents + h->plt.offset + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[5],
		      splt_thumb->contents + h->plt.offset + 10);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[6],
		      splt_thumb->contents + h->plt.offset + 12);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt_entry[7],
		      splt_thumb->contents + h->plt.offset + 14);

	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + plt_info->got_plt_offset
		       - splt_thumb->output_section->vma
		       - splt_thumb->output_offset
		       - h->plt.offset - 10),
		      splt_thumb->contents + h->plt.offset + 16);

	  /* Fill in the entry in the global offset table and set
	     bottom bit as plt[0] is a Thumb function.  */
	  bfd_put_32 (output_bfd,
		      (splt_thumb->output_section->vma
		       + (splt_thumb->output_offset | 1)),
		      sgot->contents + plt_info->got_plt_offset);
	}
d3377 1
a3377 1
		      + plt_info->got_plt_offset);
d3381 1
a3381 1
				 + rel_index));
a3485 1
      asection *splt_thumb;
d3489 1
a3489 2
      splt_thumb = bfd_get_section_by_name (dynobj, ".plt.thumb");
      BFD_ASSERT (splt != NULL && splt_thumb != NULL && sdyn != NULL);
d3552 1
a3552 1
      /* Fill in the first entries in the procedure linkage tables.  */
a3559 23
      if (splt_thumb->_raw_size > 0)
	{
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[0],
		      splt_thumb->contents + 0);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[1],
		      splt_thumb->contents + 2);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[2],
		      splt_thumb->contents + 4);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[3],
		      splt_thumb->contents + 6);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[4],
		      splt_thumb->contents + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[5],
		      splt_thumb->contents + 10);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[6],
		      splt_thumb->contents + 12);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[7],
		      splt_thumb->contents + 14);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[8],
		      splt_thumb->contents + 16);
	  bfd_put_16 (output_bfd, (bfd_vma) elf32_thumb_plt0_entry[9],
		      splt_thumb->contents + 18);
	}
a3613 30
boolean
elf32_arm_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  boolean ret;

  ret = _bfd_elf_create_dynamic_sections (abfd, info);
  if (ret)
    {
      asection *splt;
      asection *splt_thumb;
      flagword flags;
      unsigned int alignent_power;

      /* Let's match the attributes of .plt.  */
      splt = bfd_get_section_by_name (abfd, ".plt");
      BFD_ASSERT (splt != NULL);

      flags = bfd_get_section_flags (abfd, splt);
      alignent_power = bfd_get_section_alignment (abfd, splt);

      splt_thumb = bfd_make_section (abfd, ".plt.thumb");
      if (splt_thumb == NULL
	  || !bfd_set_section_flags (abfd, splt_thumb, flags)
	  || !bfd_set_section_alignment (abfd, splt_thumb, alignent_power))
	return false;
    }
  return ret;
}
d3635 1
a3635 1
#define elf_backend_create_dynamic_sections	elf32_arm_create_dynamic_sections
d3651 1
a3651 1
#define elf_backend_plt_header_size	ARM_PLT_ENTRY_SIZE
@


1.88
log
@Add arm-*-nto port.
@
text
@d98 2
d119 4
a122 1
#define PLT_ENTRY_SIZE 16
d128 1
a128 1
static const bfd_vma elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
d136 14
d152 1
a152 1
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
d159 19
d197 19
d223 2
d287 4
a290 1
    ret->pcrel_relocs_copied = NULL;
d1128 1
d1153 1
d1479 8
d2803 25
d3060 1
a3060 1
  if (h->type == STT_FUNC
d3063 7
d3090 2
a3091 1
      s = bfd_get_section_by_name (dynobj, ".plt");
d3094 1
a3094 1
      /* If this is the first .plt entry, make room for the special
d3097 1
a3097 1
	s->_raw_size += PLT_ENTRY_SIZE;
d3114 1
a3114 1
      s->_raw_size += PLT_ENTRY_SIZE;
d3120 1
d3271 2
a3272 1
      if (strcmp (name, ".plt") == 0)
d3432 1
d3435 1
a3435 2
      bfd_vma plt_index;
      bfd_vma got_offset;
d3437 1
d3445 1
d3448 2
a3449 1
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
d3451 5
a3455 10
      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;
d3458 11
a3468 7
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0],
		  splt->contents + h->plt.offset + 0);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1],
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2],
		  splt->contents + h->plt.offset + 8);
      bfd_put_32 (output_bfd,
d3471 1
a3471 1
		       + got_offset
d3477 41
a3517 5
      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset),
		  sgot->contents + got_offset);
d3522 1
a3522 1
		      + got_offset);
d3526 1
a3526 1
				 + plt_index));
d3631 1
d3635 2
a3636 1
      BFD_ASSERT (splt != NULL && sdyn != NULL);
d3699 1
a3699 1
      /* Fill in the first entry in the procedure linkage table.  */
d3707 23
d3784 30
d3835 1
a3835 1
#define elf_backend_create_dynamic_sections	_bfd_elf_create_dynamic_sections
d3851 1
a3851 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.87
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a44 4
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d83 2
d86 5
d97 2
a98 2
static enum elf_reloc_type_class elf32_arm_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d373 1
d786 1
d3617 1
d3619 1
d3654 1
@


1.87.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a2960 6
      /* If we link a program (not a DSO), we'll get rid of unnecessary
	 PLT entries; we point to the actual symbols -- even for pic
	 relocs, because a program built with -fpic should have the same
	 result as one built without -fpic, specifically considering weak
	 symbols.
	 FIXME: m68k and i386 differ here, for unclear reasons.  */
d2962 2
a2963 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d2966 4
a2969 4
	     file, but the symbol was not defined by a dynamic object.
	     In such a case, we don't actually need to build a
	     procedure linkage table, and we can just do a PC32 reloc
	     instead.  */
a2970 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
@


1.87.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a425 1
  struct bfd_link_hash_entry * bh;
a458 1
  bh = NULL;
d462 2
a463 1
				    NULL, true, false, &bh);
a480 1
  struct bfd_link_hash_entry *bh;
a511 1
  bh = NULL;
d515 2
a516 1
				    NULL, true, false, &bh);
a518 1
  myh = (struct elf_link_hash_entry *) bh;
d535 2
a536 1
  bh = NULL;
d540 2
a541 1
				    NULL, true, false, &bh);
@


1.86
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d642 1
a642 1
  Elf_Internal_Rela *free_relocs = NULL;
a644 3
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
d677 3
a679 2
      irel = (_bfd_elf32_link_read_relocs (abfd, sec, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL, false));
d681 2
a682 1
      BFD_ASSERT (irel != 0);
d684 2
a685 2
      irelend = irel + sec->reloc_count;
      for (; irel < irelend; irel++)
a712 2
		  free_contents = contents;

a718 23
	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (extsyms == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (symtab_hdr->contents != NULL)
		extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	      else
		{
		  /* Go get them off disk.  */
		  extsyms = ((Elf32_External_Sym *)
			     bfd_malloc (symtab_hdr->sh_size));
		  if (extsyms == NULL)
		    goto error_return;

		  free_extsyms = extsyms;

		  if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		      || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
			  != symtab_hdr->sh_size))
		    goto error_return;
		}
	    }

d758 10
d773 6
a778 6
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
@


1.85
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d61 1
a61 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d2532 2
a2533 2
elf32_arm_gc_mark_hook (abfd, info, rel, h, sym)
       bfd *abfd;
d2563 1
a2563 3
     {
       return bfd_section_from_elf_index (abfd, sym->st_shndx);
     }
@


1.84
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2226 1
a2226 1
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
@


1.83
log
@Fix genreation of arm <->thumb glue stubs by ensuring that they are in the last section linked.
@
text
@d631 1
a631 1
  
d1543 1
a1543 1
 
d1552 1
a1552 1
      
d1577 1
a1577 1
      /* If we are addressing a Thumb function, we need to adjust the 
d2377 1
a2377 1
				  bfd_get_filename (obfd));    
@


1.82
log
@For the Thumb BLX reloc round the relocation up rather than down.
@
text
@d550 2
a551 3
/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */
d554 1
a554 1
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
a557 1
  struct elf32_arm_link_hash_table *globals;
d561 2
a562 2
  /* If we are only performing a partial link do not bother
     getting a bfd to hold the glue.  */
a565 7
  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return true;

d603 26
d631 1
a631 1

@


1.82.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d550 3
a552 2
/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */
d555 1
a555 1
bfd_elf32_arm_add_glue_sections_to_bfd (abfd, info)
d559 1
d563 2
a564 2
  /* If we are only performing a partial
     link do not bother adding the glue.  */
d568 7
a611 26
  return true;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */

boolean
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocateable)
    return true;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return true;

d1526 1
a1526 1

d1535 1
a1535 1

d1560 1
a1560 1
      /* If we are addressing a Thumb function, we need to adjust the
d2360 1
a2360 1
				  bfd_get_filename (obfd));
@


1.82.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d61 1
a61 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d642 1
a642 1
  Elf_Internal_Rela *internal_relocs = NULL;
d645 3
d680 2
a681 3
      internal_relocs
	= _bfd_elf32_link_read_relocs (abfd, sec, (PTR) NULL,
				       (Elf_Internal_Rela *) NULL, false);
d683 1
a683 2
      if (internal_relocs == NULL)
	goto error_return;
d685 2
a686 2
      irelend = internal_relocs + sec->reloc_count;
      for (irel = internal_relocs; irel < irelend; irel++)
d714 2
d722 23
a783 10

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;

      if (internal_relocs != NULL
	  && elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      internal_relocs = NULL;
d789 6
a794 6
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d2226 1
a2226 1
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
d2532 2
a2533 2
elf32_arm_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
d2563 3
a2565 1
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.82.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d45 4
a86 2
static enum elf_reloc_type_class elf32_arm_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
a87 5
#ifndef ELFARM_NABI_C_INCLUDED
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d94 2
a95 2
#endif

a369 1
#ifndef ELFARM_NABI_C_INCLUDED
a781 1
#endif
a3611 1
#ifndef ELF_MAXPAGESIZE
a3612 1
#endif
a3646 1

@


1.82.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a3548 25

	      /* Set the bottom bit of DT_INIT/FINI if the
		 corresponding function is Thumb.  */
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      /* If it wasn't set by elf_bfd_final_link
		 then there is nothing to ajdust.  */
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry * eh;

		  eh = elf_link_hash_lookup (elf_hash_table (info), name,
					     false, false, true);
		  if (eh != (struct elf_link_hash_entry *) NULL
		      && ELF_ST_TYPE (eh->type) == STT_ARM_TFUNC)
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);		
		    }
		}
	      break;
@


1.82.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1504 1
a1504 1
	bfd_signed_vma relocation;
d1507 1
d1513 2
a1514 12
	if (addend & ((howto->src_mask + 1) >> 1))
	  {
	    signed_addend = -1;
	    signed_addend &= ~ howto->src_mask;
	    signed_addend |= addend;
	  }
	else
	  signed_addend = addend;
	/* The value in the insn has been right shifted.  We need to
	   undo this, so that we can perform the address calculation
	   in terms of bytes.  */
	signed_addend <<= howto->rightshift;
d1516 1
a1516 1
	relocation = value + signed_addend;
d1522 9
a1530 3
	relocation >>= howto->rightshift;
	signed_check = relocation;
	relocation &= howto->dst_mask;
a2965 6
      /* If we link a program (not a DSO), we'll get rid of unnecessary
	 PLT entries; we point to the actual symbols -- even for pic
	 relocs, because a program built with -fpic should have the same
	 result as one built without -fpic, specifically considering weak
	 symbols.
	 FIXME: m68k and i386 differ here, for unclear reasons.  */
d2967 2
a2968 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d2971 4
a2974 4
	     file, but the symbol was not defined by a dynamic object.
	     In such a case, we don't actually need to build a
	     procedure linkage table, and we can just do a PC32 reloc
	     instead.  */
a2975 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
@


1.82.2.6
log
@merge from mainline
@
text
@a19 4
#ifndef USE_REL
#define USE_REL	0
#endif

d79 1
a79 1
#if USE_REL
a429 1
  struct bfd_link_hash_entry * bh;
a462 1
  bh = NULL;
d466 2
a467 1
				    NULL, true, false, &bh);
a484 1
  struct bfd_link_hash_entry *bh;
a515 1
  bh = NULL;
d519 2
a520 1
				    NULL, true, false, &bh);
a522 1
  myh = (struct elf_link_hash_entry *) bh;
d539 2
a540 1
  bh = NULL;
d544 2
a545 1
				    NULL, true, false, &bh);
d1096 1
a1096 1
#if USE_REL
d1372 1
a1372 1
#if USE_REL
d1404 1
a1404 1
#if USE_REL
d1509 1
a1509 1
#if USE_REL
d1747 1
a1747 1
#if USE_REL
d1839 1
a1839 1
#if !USE_REL
d1868 1
a1868 1
#if USE_REL
d1876 1
a1876 1
#if USE_REL
d1909 1
a1909 1
#if USE_REL
d3651 1
d3653 1
d3680 1
a3680 1
#if !USE_REL
@


1.82.2.7
log
@merge from mainline
@
text
@d370 7
@


1.81
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d1474 9
a1486 12
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  lower_insn &= ~1;
#endif
@


1.81.2.1
log
@merge from trunk
@
text
@d550 3
a552 2
/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */
d555 1
a555 1
bfd_elf32_arm_add_glue_sections_to_bfd (abfd, info)
d559 1
d563 2
a564 2
  /* If we are only performing a partial
     link do not bother adding the glue.  */
d568 7
a611 26
  return true;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */

boolean
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocateable)
    return true;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return true;

d1474 4
d1481 8
a1488 5
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  relocation = (relocation + 2) & ~ 3;
a1489 4
	/* Put RELOCATION back into the insn.  */
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 12) & 0x7ff);
	lower_insn = (lower_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 1) & 0x7ff);

d1529 1
a1529 1

d1538 1
a1538 1

d1563 1
a1563 1
      /* If we are addressing a Thumb function, we need to adjust the
d2363 1
a2363 1
				  bfd_get_filename (obfd));
@


1.80
log
@Fix check for overflow of relocation for the Thumb BL instruction.
@
text
@d1833 5
d1870 1
a1882 1
#ifdef USE_REL
a1886 3
#else
		  rel->r_addend += (sec->output_offset + sym->st_value);
#endif
d1892 1
d3643 3
@


1.79
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1393 1
a1393 1
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
@


1.78
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d239 1
a239 1
  ret = (struct elf32_arm_link_hash_table *) bfd_alloc (abfd, amt);
d246 1
a246 1
      bfd_release (abfd, ret);
@


1.77
log
@* elf32-arm.h (elf32_arm_final_link_relocate case R_ARM_GOTOFF)
(case R_ARM_GOT): Handle relocations to Thumb functions.
@
text
@d3291 3
@


1.76
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d1563 6
d1621 7
@


1.75
log
@2002-02-08  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-arm.h: Fix formatting of _("...").
        * elf32-d10v.c: Likewise.
        * elf32-m68k.c: Likewise.
        * elf32-mips.c: Likewise.
@
text
@d1151 1
d1158 2
d1164 1
a1164 4
	    {
	      memset (&outrel, 0, sizeof outrel);
	      relocate = false;
	    }
d1168 1
a1168 3
	      if ((input_section->flags & SEC_ALLOC) != 0)
		relocate = false;
	      else
d1185 1
a1185 3
		  if ((input_section->flags & SEC_ALLOC) != 0)
		    relocate = false;
		  else
@


1.75.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1150 1
	  relocate = false;
a1156 2
	  else if (outrel.r_offset == (bfd_vma) -2)
	    skip = true, relocate = true;
d1161 4
a1164 1
	    memset (&outrel, 0, sizeof outrel);
d1168 3
a1170 1
	      if ((input_section->flags & SEC_ALLOC) == 0)
d1187 3
a1189 1
		  if ((input_section->flags & SEC_ALLOC) == 0)
@


1.75.2.2
log
@Merge from mainline.
@
text
@a1562 6
      /* If we are addressing a Thumb function, we need to adjust the 
	 address by one, so that attempts to call the function pointer will
	 correctly interpret it as Thumb code.  */
      if (sym_flags == STT_ARM_TFUNC)
	value += 1;

a1614 7
		  /* If we are addressing a Thumb function, we need to
		     adjust the address by one, so that attempts to
		     call the function pointer will correctly
		     interpret it as Thumb code.  */
		  if (sym_flags == STT_ARM_TFUNC)
		    value |= 1;

a3276 3

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf32_arm_link_hash_entry *) h->root.root.u.i.link;
@


1.75.2.3
log
@Fix check for overflow of relocation for the Thumb BL instruction.
@
text
@d1393 1
a1393 1
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
@


1.75.2.4
log
@Merge from mainline
@
text
@a1832 5
#ifndef USE_REL
  if (info->relocateable)
    return true;
#endif

a1864 1
#ifdef USE_REL
d1877 1
d1882 3
a1889 1
#endif
a3639 3
#ifndef USE_REL
#define elf_backend_rela_normal     1
#endif
@


1.74
log
@2002-01-31  Philipp Thomas  <pthomas@@suse.de>

        * coff-arm.c (coff_arm_merge_private_bfd_data): Move ERROR
        to front of message. Unify messages with elf32-arm.h. Use
        commas where neccessary.
        * elf32-arm.h (elf32_arm_merge_private_bfd_data): Use all upcase
        ERROR in messages. Unify messages with coff-arm.c. Correct
        VFP/FPA error message.
        (elf32_arm_print_private_bfd_data): Don't mark APCS-26 and
        APCS-32 for translation.
@
text
@d2328 1
a2328 1
		_bfd_error_handler (_ ("\
d2333 1
a2333 1
		_bfd_error_handler (_ ("\
@


1.73
log
@Fixes for better translation into other languages
@
text
@d2262 1
a2262 1
Error: %s compiled for EABI version %d, whereas %s is compiled for version %d"),
d2276 1
a2276 1
Error: %s compiled for APCS-%d, whereas %s is compiled for APCS-%d"),
d2288 1
a2288 1
Error: %s passes floats in FP registers, whereas %s passes them in integer registers"),
d2293 1
a2293 1
Error: %s passes floats in integer registers, whereas %s passes them in FP registers"),
d2304 1
a2304 1
Error: %s uses VFP instructions, whereas %s uses FPA instructions"),
d2309 1
a2309 1
Error: %s uses FPA instructions, whereas %s uses VFP instructions"),
d2329 1
a2329 1
Error: %s uses software FP, whereas %s uses hardware FP"),
d2334 1
a2334 1
Error: %s uses hardware FP, whereas %s uses software FP"),
d2398 1
a2398 1
	fprintf (file, _(" [APCS-26]"));
d2400 1
a2400 1
	fprintf (file, _(" [APCS-32]"));
@


1.72
log
@Unify messages in coff-arm.c and elf32-arm.h.
@
text
@d2304 1
a2304 1
Error: %s uses VFP instructions, whereas %s FPA instructions"),
d2309 1
a2309 1
Error: %s uses FPA instructions, whereas %s VFP instructions"),
@


1.71
log
@* elf32-arm.h (elf32_arm_merge_private_bfd_data): Handle
EF_ARM_VFP_FLOAT.
(elf32_arm_print_private_bfd_data): Likewise.
@
text
@d2115 1
a2115 1
Warning: Not setting interwork flag of %s since it has already been specified as non-interworking"),
d2119 1
a2119 1
Warning: Clearing the interwork flag of %s due to outside request"),
d2167 1
a2167 1
Warning: Clearing the interwork flag in %s because non-interworking code in %s has been linked with it"),
@


1.70
log
@	* elf32-arm.h (elf32_arm_size_dynamic_sections): When removing
	sections, use bfd_section_list_remove.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elflink.h (elf_link_add_object_symbols): When removing all
	sections, use bfd_section_list_clear.
@
text
@d2300 1
a2300 2
#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
d2302 3
a2304 3
	  if (in_flags & EF_ARM_SOFT_FLOAT)
	    _bfd_error_handler (_ ("\
Error: %s uses software FP, whereas %s uses hardware FP"),
d2308 2
a2309 2
	    _bfd_error_handler (_ ("\
Error: %s uses hardware FP, whereas %s uses software FP"),
d2315 26
d2402 5
d2422 3
a2424 2
      flags &= ~(EF_ARM_INTERWORK | EF_ARM_APCS_26 | EF_ARM_APCS_FLOAT | EF_ARM_PIC
		 | EF_ARM_NEW_ABI | EF_ARM_OLD_ABI | EF_ARM_SOFT_FLOAT);
@


1.69
log
@Handle R_ARM_THM_PC11
@
text
@d3173 1
a3173 1
	       *spp != s->output_section;
d3175 8
a3182 4
	    ;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

@


1.68
log
@Reformat error messages to ease translation into other languages.
@
text
@d1502 41
@


1.67
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d2245 10
a2254 2
	  char *s1 = in_flags  & EF_ARM_APCS_FLOAT ? _("float") : _("integer");
	  char *s2 = out_flags & EF_ARM_APCS_FLOAT ? _("float") : _("integer");
a2255 4
	  _bfd_error_handler (_("\
Error: %s passes floats in %s registers, whereas %s passes them in %s registers"),
			      bfd_archive_filename (ibfd), s1,
			      bfd_get_filename (obfd), s2);
d2262 10
a2271 2
	  char *s1 = in_flags  & EF_ARM_SOFT_FLOAT ? _("soft") : _("hard");
	  char *s2 = out_flags & EF_ARM_SOFT_FLOAT ? _("soft") : _("hard");
a2272 4
	  _bfd_error_handler (_ ("\
Error: %s uses %s floating point, whereas %s uses %s floating point"),
			      bfd_archive_filename (ibfd), s1,
			      bfd_get_filename (obfd), s2);
@


1.66
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d2458 3
a2460 8
       if (!(elf_bad_symtab (abfd)
           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
                && sym->st_shndx != SHN_COMMON))
          {
            return bfd_section_from_elf_index (abfd, sym->st_shndx);
          }
      }
@


1.65
log
@Fixes to improve the ability to translate messages in the binutils tools
@
text
@d1152 5
a1156 16
	  if (elf_section_data (input_section)->stab_info == NULL)
	    outrel.r_offset = rel->r_offset;
	  else
	    {
	      bfd_vma off;

	      off = (_bfd_stab_section_offset
		     (output_bfd, &elf_hash_table (info)->stab_info,
		      input_section,
		      & elf_section_data (input_section)->stab_info,
		      rel->r_offset));
	      if (off == (bfd_vma) -1)
		skip = true;
	      outrel.r_offset = off;
	    }

d1884 1
a1884 3
		_bfd_merged_section_offset (output_bfd, &msec,
					    elf_section_data (sec)->merge_info,
					    sym->st_value + addend, (bfd_vma) 0)
@


1.64
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d2285 14
a2298 8
	  char *s1 = (in_flags & EF_ARM_INTERWORK
		      ? _("supports") : _("does not support"));
	  char *s2 = out_flags & EF_ARM_INTERWORK ? _("does") : _("does not");

	  _bfd_error_handler (_("\
Warning: %s %s interworking, whereas %s %s"),
			      bfd_archive_filename (ibfd), s1,
			      bfd_get_filename (obfd), s2);
@


1.63
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1861 1
d1865 41
@


1.62
log
@Treat R_ARM_THM_PC22 like R_ARM_PC24.
@
text
@d1119 1
@


1.61
log
@Revert most of previous delta.  Do not call bfd_archive_filename on output
bfd, nor twice in one expression.
@
text
@d1886 1
d1927 4
a1930 2
			(_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
			 bfd_archive_filename (input_bfd), h->root.root.string,
@


1.60
log
@Replace bfd_get_filename with bfd_archive_filename in error message.
Fix detection of conflicting float flags.
@
text
@d2094 1
a2094 1
				bfd_archive_filename (obfd),
d2191 1
a2191 1
			  bfd_archive_filename (obfd),
d2205 1
a2205 1
			      bfd_archive_filename (obfd),
d2218 1
a2218 1
			      bfd_archive_filename (obfd), s2);
d2231 1
a2231 1
			      bfd_archive_filename (obfd), s2);
d2246 1
a2246 1
			      bfd_archive_filename (obfd), s2);
@


1.59
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d423 1
a423 1
  register asection * s;
d478 1
a478 1
  register asection *s;
d2044 1
a2044 1
	    (*_bfd_error_handler) (_("\
d2046 1
a2046 1
				   bfd_archive_filename (abfd));
d2092 1
a2092 2
	    {
	      (*_bfd_error_handler) (_("\
d2094 2
a2095 3
				     bfd_get_filename (obfd),
				     bfd_archive_filename (ibfd));
	    }
d2187 1
a2187 1
      (*_bfd_error_handler) (_("\
d2189 4
a2192 4
			     bfd_archive_filename (ibfd),
			     (in_flags & EF_ARM_EABIMASK) >> 24,
			     bfd_get_filename (obfd),
			     (out_flags & EF_ARM_EABIMASK) >> 24);
d2201 1
a2201 1
	  (*_bfd_error_handler) (_("\
d2203 4
a2206 4
				 bfd_archive_filename (ibfd),
				 in_flags & EF_ARM_APCS_26 ? 26 : 32,
				 bfd_get_filename (obfd),
				 out_flags & EF_ARM_APCS_26 ? 26 : 32);
d2212 4
a2215 3
	  char *s1 = in_flags & EF_ARM_APCS_FLOAT ? _("float") : _("integer");
	  char *s2 = out_flags & EF_ARM_APCS_26 ? _("float") : _("integer");
	  (*_bfd_error_handler) (_("\
d2217 2
a2218 2
				 bfd_archive_filename (ibfd), s1,
				 bfd_get_filename (obfd), s2);
d2225 1
a2225 1
	  char *s1 = in_flags & EF_ARM_SOFT_FLOAT ? _("soft") : _("hard");
d2227 2
a2228 1
	  (*_bfd_error_handler) (_ ("\
d2230 2
a2231 2
				 bfd_archive_filename (ibfd), s1,
				 bfd_get_filename (obfd), s2);
d2242 2
a2243 1
	  (*_bfd_error_handler) (_("\
d2245 2
a2246 2
				 bfd_archive_filename (ibfd), s1,
				 bfd_get_filename (obfd), s2);
d2249 1
d2562 1
a2562 1
		    register unsigned int i;
@


1.58
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d95 1
a95 1
  PARAMS ((int));
d3462 2
a3463 2
elf32_arm_reloc_type_class (type)
     int type;
d3465 1
a3465 1
  switch (type)
@


1.57
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d285 2
a286 2
    _bfd_error_handler (_("%s: unable to find THUMB glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
d320 2
a321 2
    _bfd_error_handler (_("%s: unable to find ARM glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
d885 1
a885 1
	  _bfd_error_handler
d887 2
a888 2
	     bfd_get_filename (sym_sec->owner), name);
	  _bfd_error_handler
d890 1
a890 1
	     bfd_get_filename (input_bfd));
d989 1
a989 1
	  _bfd_error_handler
d991 2
a992 2
	     bfd_get_filename (sym_sec->owner), name);
	  _bfd_error_handler
d994 1
a994 1
	     bfd_get_filename (input_bfd));
d1234 1
a1234 1
		_bfd_error_handler (_("\
d1236 2
a1237 2
				    bfd_get_filename (input_bfd),
				    h ? h->root.root.string : "(local)");
d1430 1
a1430 1
	      _bfd_error_handler (_("\
d1432 2
a1433 2
				  bfd_get_filename (input_bfd),
				  h ? h->root.root.string : "(local)");
d1927 1
a1927 1
			 bfd_get_filename (input_bfd), h->root.root.string,
d2040 1
a2040 1
	    _bfd_error_handler (_("\
d2042 1
a2042 1
				bfd_get_filename (abfd));
d2044 1
a2044 1
	    _bfd_error_handler (_("\
d2046 1
a2046 1
				bfd_get_filename (abfd));
d2092 2
a2093 1
	    _bfd_error_handler (_("\
d2095 3
a2097 1
			  bfd_get_filename (obfd), bfd_get_filename (ibfd));
d2189 1
a2189 1
      _bfd_error_handler (_("\
d2191 4
a2194 4
			 bfd_get_filename (ibfd),
			 (in_flags & EF_ARM_EABIMASK) >> 24,
			 bfd_get_filename (obfd),
			 (out_flags & EF_ARM_EABIMASK) >> 24);
d2203 1
a2203 1
	  _bfd_error_handler (_("\
d2205 4
a2208 4
			bfd_get_filename (ibfd),
			in_flags & EF_ARM_APCS_26 ? 26 : 32,
			bfd_get_filename (obfd),
			out_flags & EF_ARM_APCS_26 ? 26 : 32);
d2214 3
a2216 1
	  _bfd_error_handler (_("\
d2218 2
a2219 4
			bfd_get_filename (ibfd),
		     in_flags & EF_ARM_APCS_FLOAT ? _("float") : _("integer"),
			bfd_get_filename (obfd),
		      out_flags & EF_ARM_APCS_26 ? _("float") : _("integer"));
d2226 3
a2228 1
	  _bfd_error_handler (_ ("\
d2230 2
a2231 4
			      bfd_get_filename (ibfd),
			      in_flags & EF_ARM_SOFT_FLOAT ? _("soft") : _("hard"),
			      bfd_get_filename (obfd),
			      out_flags & EF_ARM_SOFT_FLOAT ? _("soft") : _("hard"));
d2238 5
a2242 1
	_bfd_error_handler (_("\
d2244 3
a2246 4
			    bfd_get_filename (ibfd),
			    in_flags & EF_ARM_INTERWORK ? _("supports") : _("does not support"),
			    bfd_get_filename (obfd),
			    out_flags & EF_ARM_INTERWORK ? _("does") : _("does not"));
a2247 1

@


1.56
log
@Do not rightshift recomputed addend during relocatable link if not USE_REL.
@
text
@d38 1
a38 1
	   const char *, unsigned char, struct elf_link_hash_entry *));
d120 1
a120 1
static const unsigned long elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
d130 1
a130 1
static const unsigned long elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
d187 1
a187 1
    long int thumb_glue_size;
d190 1
a190 1
    long int arm_glue_size;
d237 1
d239 1
a239 2
  ret = ((struct elf32_arm_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf32_arm_link_hash_table)));
d273 2
a274 2
  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1));
d308 2
a309 2
  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d386 2
a387 2
      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);
d391 2
a392 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->arm_glue_size);
d407 2
a408 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->thumb_glue_size);
d427 1
d439 2
a440 2
  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d459 3
a461 3
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner, tmp_name,
				    BSF_GLOBAL,
				    s, globals->arm_glue_size + 1,
d483 1
d495 2
a496 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d512 3
a514 2
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner, tmp_name,
			     BSF_GLOBAL, s, hash_table->thumb_glue_size + 1,
d528 2
a529 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (CHANGE_TO_ARM) + 1);
d537 3
a539 2
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner, tmp_name,
			      BSF_LOCAL, s, hash_table->thumb_glue_size + 4,
d664 1
a664 1
					(Elf_Internal_Rela *) NULL, false));
d700 1
a700 1
					      (file_ptr) 0, sec->_raw_size))
d722 1
a722 1
		      || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d855 1
a855 1
  long int my_offset;
d898 1
a898 1
      bfd_put_16 (output_bfd, t2a1_bx_pc_insn,
d901 1
a901 1
      bfd_put_16 (output_bfd, t2a2_noop_insn,
d920 1
a920 1
		  t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d928 5
a932 6
  ret_offset =
    s->output_offset
    + my_offset
    - (input_section->output_offset
       + offset + addend)
    - 8;
d938 1
a938 1
	      insert_thumb_branch (tmp, ret_offset),
d961 1
a961 1
  long int my_offset;
d1000 1
a1000 1
      bfd_put_32 (output_bfd, a2t1_ldr_insn,
d1003 1
a1003 1
      bfd_put_32 (output_bfd, a2t2_bx_r12_insn,
d1017 7
a1023 7
  ret_offset = s->output_offset
    + my_offset
    + s->output_section->vma
    - (input_section->output_offset
       + input_section->output_section->vma
       + offset + addend)
    - 8;
d1027 1
a1027 2
  bfd_put_32 (output_bfd, tmp, hit_data
	      - input_section->vma);
d1048 1
a1048 1
     unsigned char          sym_flags;
d1729 2
a1730 2
      bfd_put_16 (abfd, upper_insn, address);
      bfd_put_16 (abfd, lower_insn, address + 2);
d1758 1
a1758 1
	  addend +=  increment;
d1817 6
a1822 1
      elf32_arm_info_to_howto (input_bfd, & bfd_reloc, (Elf32_Internal_Rel *) rel);
d1839 3
a1841 1
				  howto, sec->output_offset + sym->st_value);
d2554 1
a2554 1
		    size_t size;
d2557 2
a2558 1
		    size = symtab_hdr->sh_info * sizeof (bfd_vma);
d2682 1
a2682 2
			     bfd_alloc (dynobj, sizeof * p));

d3105 4
a3108 1
      if (! info->shared)
d3110 1
a3110 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d3116 4
a3119 4
	  if (   ! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d3125 3
a3127 4
	  if (   ! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELENT,
						sizeof (Elf32_External_Rel)))
d3133 1
a3133 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d3138 1
d3271 1
a3271 1
		      + (h->got.offset &~ 1));
d3483 1
a3483 1
#define bfd_elf32_bfd_reloc_type_lookup	elf32_arm_reloc_type_lookup
d3490 1
a3490 1
#define elf_backend_relocate_section	elf32_arm_relocate_section
@


1.55
log
@	* elf32-cris.c (cris_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_cris_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_cris_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-sh.c (sh_elf_check_relocs): Set DF_TEXTREL if the reloc is
	against read-only section.
	(elf_backend_reloc_type_class): Define.
	(sh_elf_reloc_type_class): New.
	(sh_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.

	* elf32-arm.h (elf32_arm_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_arm_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_arm_reloc_type_class): New.
@
text
@d1813 1
a1813 1
      elf32_arm_info_to_howto (input_bfd, & bfd_reloc, rel);
d1832 1
a1832 2
		  rel->r_addend += (sec->output_offset + sym->st_value)
		    >> howto->rightshift;
@


1.54
log
@Add missing prototypes
@
text
@d94 3
d131 1
a131 1
 { 
d1064 1
a1064 1
     
d1072 1
a1072 1
      
d1116 1
a1116 1
 	      || (h != NULL
d1499 1
a1499 1
#endif	
d1539 2
a1540 2
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);
d1551 2
a1552 2
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);
d1635 2
a1636 2
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);
d1646 2
a1647 2
        				 contents, rel->r_offset, value,
        				 (bfd_vma) 0);
d1665 2
a1666 2
        			       contents, rel->r_offset, value,
        			       (bfd_vma) 0);
d1878 1
a1878 1
	              	  (!info->symbolic && h->dynindx != -1)
d2316 1
a2316 1
      flags &= ~(EF_ARM_SYMSARESORTED | EF_ARM_DYNSYMSUSESEGIDX 
d2512 1
a2512 1
		  				    (SEC_ALLOC
d2540 1
a2540 1
     	        /* This is a global offset table entry for a local
d2572 1
a2572 1
  	  case R_ARM_PLT32:
d2625 1
a2625 1
		 	        && strcmp (bfd_get_section_name (abfd, sec),
d2643 2
d2959 1
a2959 1
     bfd * output_bfd;
a2965 1
  boolean reltext;
a3006 1
  reltext = false;
a3051 2
	      asection * target;

d3055 1
a3055 19
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rel.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 4);

		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d3119 1
a3119 1
      if (reltext)
d3443 18
d3465 2
a3466 2
#define bfd_elf32_bfd_copy_private_bfd_data 	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data 	elf32_arm_merge_private_bfd_data
d3470 1
a3470 1
#define bfd_elf32_bfd_reloc_type_lookup 	elf32_arm_reloc_type_lookup
d3477 1
a3477 1
#define elf_backend_relocate_section    	elf32_arm_relocate_section
d3484 1
@


1.53
log
@Include offset of reloc from start of section when computing value for
R_ARM_REL32 reloc.
@
text
@d42 1
a42 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d44 1
a44 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d57 30
d88 6
d118 6
a123 6
{
  0xe52de004,	/* str   lr, [sp, #-4]!     */
  0xe59fe010,	/* ldr   lr, [pc, #16]      */
  0xe08fe00e,	/* add   lr, pc, lr         */
  0xe5bef008	/* ldr   pc, [lr, #8]!      */
};
d128 6
a133 6
{
  0xe59fc004,	/* ldr   ip, [pc, #4]       */
  0xe08fc00c,	/* add   ip, pc, ip         */
  0xe59cf000,	/* ldr   pc, [ip]           */
  0x00000000	/* offset to symbol in got  */
};
d144 8
a151 8
{
  /* Next section.  */
  struct elf32_arm_pcrel_relocs_copied * next;
  /* A section in dynobj.  */
  asection * section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};
d155 2
a156 2
{
  struct elf_link_hash_entry root;
d158 3
a160 3
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf32_arm_pcrel_relocs_copied * pcrel_relocs_copied;
};
d179 17
a195 17
{
  /* The main hash table.  */
  struct elf_link_hash_table root;

  /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
  long int thumb_glue_size;

  /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
  long int arm_glue_size;

  /* An arbitary input BFD chosen to hold the glue sections.  */
  bfd * bfd_of_glue_owner;

  /* A boolean indicating whether knowledge of the ARM's pipeline
     length should be applied by the linker.  */
  int no_pipeline_knowledge;
};
d260 1
a260 1
     CONST char *name;
d295 1
a295 1
     CONST char *name;
d2711 2
a2712 2
     CONST char **  filename_ptr;
     CONST char **  functionname_ptr;
@


1.52
log
@2001-06-09  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_plt0_entry): Correct error in last
	change.
	(elf32_arm_plt_entry): Likewise.
@
text
@d1298 1
a1298 1
		    + input_section->output_offset);
@


1.51
log
@Support big endian PLT entries.
@
text
@d81 1
a81 1
static const bfd_byte elf32_arm_plt0_entry [PLT_ENTRY_SIZE] =
d91 1
a91 1
static const bfd_byte elf32_arm_plt_entry [PLT_ENTRY_SIZE] =
@


1.50
log
@Set EF_ARM_HASENTRY if the start address is set.
@
text
@d83 4
a86 4
  0x04, 0xe0, 0x2d, 0xe5,	/* str   lr, [sp, #-4]!     */
  0x10, 0xe0, 0x9f, 0xe5,	/* ldr   lr, [pc, #16]      */
  0x0e, 0xe0, 0x8f, 0xe0,	/* adr   lr, pc, lr         */
  0x08, 0xf0, 0xbe, 0xe5	/* ldr   pc, [lr, #8]!      */
d93 4
a96 4
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr   ip, [pc, #4]       */
  0x0c, 0xc0, 0x8f, 0xe0,	/* add   ip, pc, ip         */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr   pc, [ip]           */
  0x00, 0x00, 0x00, 0x00        /* offset to symbol in got  */
d3180 6
a3185 3
      memcpy (splt->contents + h->plt.offset,
              elf32_arm_plt_entry,
	      PLT_ENTRY_SIZE);
d3381 6
a3386 1
	memcpy (splt->contents, elf32_arm_plt0_entry, PLT_ENTRY_SIZE);
@


1.49
log
@Fix warning message
@
text
@d1022 12
@


1.48
log
@2001-03-11  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_finish_dynamic_symbol): Don't make PLT
	entries that could serve as a definition for a weak symbol.
@
text
@d2176 4
a2179 4
			  bfd_get_filename (ibfd),
	  in_flags & EF_ARM_INTERWORK ? _("supports") : _("does not support"),
			  bfd_get_filename (obfd),
		    out_flags & EF_ARM_INTERWORK ? _("does not") : _("does"));
@


1.47
log
@Update copyright notices
@
text
@d3200 7
@


1.46
log
@Conditionalize prevbious pathc on ! defined OLD_ARM_ABI.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.45
log
@Fix BLX(1) for Thumb
@
text
@d1437 1
d1448 1
a1448 1
	
@


1.44
log
@2001-02-28  Philip Blundell  <pb@@futuretv.com>

	* elf32-arm.h: Update mentions of renamed EF_xx constants.
 	(elf32_arm_print_private_bfd_data): Handle ARM EABI version 2.
@
text
@d1437 11
@


1.43
log
@Pass dwarf2_find_line_info as last parameter to invocation of
_bfd_dwarf2_find_nearest_line.
@
text
@d58 1
a58 1
#define INTERWORK_FLAG(abfd)   (elf_elfheader (abfd)->e_flags & EF_INTERWORK)
d1966 1
a1966 1
	  if (flags & EF_INTERWORK)
d2007 1
a2007 1
      if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
d2011 1
a2011 1
      if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
d2016 1
a2016 1
      if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
d2018 1
a2018 1
	  if (out_flags & EF_INTERWORK)
d2023 1
a2023 1
	  in_flags &= ~EF_INTERWORK;
d2027 2
a2028 2
      if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
	in_flags &= ~EF_PIC;
d2125 1
a2125 1
      if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
d2130 1
a2130 1
			in_flags & EF_APCS_26 ? 26 : 32,
d2132 1
a2132 1
			out_flags & EF_APCS_26 ? 26 : 32);
d2136 1
a2136 1
      if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
d2141 1
a2141 1
		     in_flags & EF_APCS_FLOAT ? _("float") : _("integer"),
d2143 1
a2143 1
		      out_flags & EF_APCS_26 ? _("float") : _("integer"));
d2147 2
a2148 2
#ifdef EF_SOFT_FLOAT
      if ((in_flags & EF_SOFT_FLOAT) != (out_flags & EF_SOFT_FLOAT))
d2153 1
a2153 1
			      in_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"),
d2155 1
a2155 1
			      out_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"));
d2161 1
a2161 1
      if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
d2165 1
a2165 1
	  in_flags & EF_INTERWORK ? _("supports") : _("does not support"),
d2167 1
a2167 1
		    out_flags & EF_INTERWORK ? _("does not") : _("does"));
d2201 1
a2201 1
      if (flags & EF_INTERWORK)
d2204 1
a2204 1
      if (flags & EF_APCS_26)
d2209 1
a2209 1
      if (flags & EF_APCS_FLOAT)
d2212 1
a2212 1
      if (flags & EF_PIC)
d2215 1
a2215 1
      if (flags & EF_NEW_ABI)
d2218 1
a2218 1
      if (flags & EF_OLD_ABI)
d2221 1
a2221 1
      if (flags & EF_SOFT_FLOAT)
d2224 2
a2225 2
      flags &= ~(EF_INTERWORK | EF_APCS_26 | EF_APCS_FLOAT | EF_PIC
		 | EF_NEW_ABI | EF_OLD_ABI | EF_SOFT_FLOAT);
d2237 18
@


1.43.2.1
log
@2001-03-11  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_finish_dynamic_symbol): Don't make PLT
	entries that could serve as a definition for a weak symbol.
@
text
@a3169 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
@


1.43.2.2
log
@2001-05-28  Nicolas Pitre <nico@@cam.org>

	* elf32-arm.h: Fix PLT generation for big endian ARM.
@
text
@d83 4
a86 4
  0xe52de004,	/* str   lr, [sp, #-4]!     */
  0xe59fe010,	/* ldr   lr, [pc, #16]      */
  0xe08fe00e,	/* add   lr, pc, lr         */
  0xe5bef008	/* ldr   pc, [lr, #8]!      */
d93 4
a96 4
  0xe59fc004,	/* ldr   ip, [pc, #4]       */
  0xe08fc00c,	/* add   ip, pc, ip         */
  0xe59cf000,	/* ldr   pc, [ip]           */
  0x00000000	/* offset to symbol in got  */
d3138 3
a3140 6
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0],
		  splt->contents + h->plt.offset + 0);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1],
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2],
		  splt->contents + h->plt.offset + 8);
d3336 1
a3336 6
	{
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[1], splt->contents +  4);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[2], splt->contents +  8);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[3], splt->contents + 12);
	}
@


1.43.2.3
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.43.2.4
log
@2001-06-09  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_plt0_entry): Correct error in last
	change.
	(elf32_arm_plt_entry): Likewise.
@
text
@d81 1
a81 1
static const unsigned long elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
d91 1
a91 1
static const unsigned long elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
@


1.43.2.5
log
@Import changes from mainline into 2-11 branch
@
text
@a1021 12
  /* If the start address has been set, then set the EF_ARM_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.
     
     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.

     Note - if the user deliberately sets a start address of 0, the
     flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_ARM_HASENTRY;
      
a1436 12
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  lower_insn &= ~1;
#endif	
@


1.43.2.6
log
@2001-07-06  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Correct sense of
	`interworking' warning message.
@
text
@d2191 1
a2191 1
		    out_flags & EF_INTERWORK ? _("does") : _("does not"));
@


1.43.2.7
log
@Include offset of reloc from start of section when computing value for
R_ARM_REL32 reloc.
@
text
@d1298 1
a1298 1
		    + input_section->output_offset + rel->r_offset);
@


1.42
log
@Generalize DWARF2 and COFF support.
@
text
@d2645 2
a2646 1
				     line_ptr, 0, NULL))
@


1.41
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* elf32-arm.h: Fix formatting.
	* elf32-avr.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d10v.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@d2645 1
a2645 1
				     line_ptr, 0))
@


1.40
log
@2000-11-05  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Always permit
	BFDs containing no sections to be merged, regardless of their flags.

2000-11-04  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_relocate_section): Suppress error message
	if a relocation for an undefined symbol also results in an
	overflow.
@
text
@a19 1

a160 1

d683 1
a683 1
	  /* If the relocation is not against a symbol it cannot concern us. */
d1480 1
a1480 1
      /* Use global offset table as symbol value. */
a2621 1

a3365 1

a3368 1

@


1.39
log
@2000-10-31  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Only handle
	EF_SOFT_FLOAT if it is defined.
@
text
@d1910 9
a1918 4
	      if (!((*info->callbacks->reloc_overflow)
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return false;
d2050 2
d2094 16
@


1.38
log
@2000-10-27  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_copy_private_bfd_data): Don't refuse
	attempts to mix PIC code with non-PIC, just mark the output as
	being position dependent.
	(elf32_arm_merge_private_bfd_data): Likewise.  Print an error
	message for EF_SOFT_FLOAT mismatches.  Display diagnostics for
	all mismatches, not just the first one.
@
text
@d2126 1
d2137 1
@


1.37
log
@(arm_add_to_rel): Fix R_ARM_THM_PC22 relocations.
@
text
@a2002 4
      /* Cannot mix PIC and non-PIC code.  */
      if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
	return false;

d2022 4
d2044 1
d2085 1
a2085 1
  /* Check flag compatibility.  */
d2098 1
a2099 3
  else if (EF_ARM_EABI_VERSION (in_flags) != EF_ARM_EABI_UNKNOWN)
    /* Not sure what needs to be checked for EABI versions >= 1.  */
    return true;
d2101 6
a2106 2
  if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
    _bfd_error_handler (_("\
d2112 2
d2115 3
a2117 2
  if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
    _bfd_error_handler (_("\
d2123 2
d2126 10
a2135 6
  if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
    _bfd_error_handler (_("\
Error: %s is compiled as position %s code, whereas %s is not"),
			bfd_get_filename (ibfd),
		    in_flags & EF_PIC ? _("independent") : _("dependent"),
			bfd_get_filename (obfd));
d2137 3
a2139 4
  /* Interworking mismatch is only a warning.  */
  if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
    {
      _bfd_error_handler (_("\
a2144 1
      return true;
d2147 1
a2147 1
  return false;
@


1.36
log
@Do not initialise flags in output bfd if the input bfd is the default
architecture with the default flags.
@
text
@d547 1
a547 1
      
d565 1
a565 1
      
d727 1
a727 1
  
d735 1
a735 1
  
d982 1
a982 1
  
d1157 1
a1157 1
	  
d1163 1
a1163 1
	  
d1255 1
a1255 1
	  
d1258 2
a1259 2
	     is going to crash anyway, so there is no point worrying 
	     about getting the destination exactly right.  */	     
d1267 1
a1267 1
	      
d1404 1
a1404 1
	
d1408 1
a1408 1
	    
d1470 1
a1470 1
      
d1572 1
a1572 1
      
a1644 1
  bfd_vma        contents;
d1647 16
a1662 1
  contents = bfd_get_32 (abfd, address);
d1664 4
a1667 3
  /* Get the (signed) value from the instruction.  */
  addend = contents & howto->src_mask;
  if (addend & ((howto->src_mask + 1) >> 1))
d1669 32
a1700 6
      bfd_signed_vma mask;
      
      mask = -1;
      mask &= ~ howto->src_mask;
      addend |= mask;
    }
d1702 1
a1702 13
  /* Add in the increment, (which is a byte value).  */
  switch (howto->type)
    {
    case R_ARM_THM_PC22:
    default:
      addend += increment;
      break;
      
    case R_ARM_PC24:
      addend <<= howto->size;
      addend +=  increment;
      
      /* Should we check for overflow here ?  */
d1704 1
a1704 3
      /* Drop any undesired bits.  */
      addend >>= howto->rightshift;
      break;
a1705 4
  
  contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);
  
  bfd_put_32 (abfd, contents, address);
d2170 1
a2170 1
      
d2175 1
a2175 1
      
d2178 1
a2178 1
      
d2184 1
a2184 1
		 
d2187 1
a2187 1
		 
d2190 1
a2190 1
		 
d2194 1
a2194 1
      
d2197 1
a2197 1
      
d2202 1
a2202 1
      
d2205 1
a2205 1
      
d2223 1
a2223 1
  
d2247 1
a2247 1
      
d2329 1
a2329 1
  
d2332 1
a2332 1
  
d2334 1
a2334 1
  
d2351 1
a2351 1
      
d2357 1
a2357 1
      
d2391 1
a2391 1
		
d2576 1
a2576 1
	  
d2956 1
a2956 1
		  
@


1.35
log
@2000-09-03  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_relocate_section): Don't try to relocate
	references to undefined symbols in debugging sections.
@
text
@d2041 5
a2045 5
      /* If the input is the default architecture then do not
         bother setting the flags for the output architecture,
         instead allow future merges to do this.  If no future
         merges ever set these flags then they will retain their
         unitialised values, which surprise surprise, correspond
d2047 2
a2048 1
      if (bfd_get_arch_info (ibfd)->the_default)
@


1.34
log
@Fix formatting
@
text
@d1797 8
a1804 1
	              && ((input_section->flags & SEC_ALLOC) != 0)
@


1.33
log
@If the destination of a BLX instruction is aligned on a half word boundary,
set the H bit.
@
text
@a39 1

d59 2
d64 1
a64 5
   name can be changed. The only requirement is the %s be present.
 */

#define INTERWORK_FLAG( abfd )   (elf_elfheader (abfd)->e_flags & EF_INTERWORK)

a75 1

d81 1
a81 2
   linker first */

a91 1

a99 1

a107 1

a118 1

a127 1

a131 1

d142 1
a142 1
/* ARM ELF linker hash table */
d144 17
a160 17
  {
    /* The main hash table.  */
    struct elf_link_hash_table root;

    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
    long int thumb_glue_size;

    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
    long int arm_glue_size;

    /* An arbitary input BFD chosen to hold the glue sections.  */
    bfd * bfd_of_glue_owner;

    /* A boolean indicating whether knowledge of the ARM's pipeline
       length should be applied by the linker.  */
    int no_pipeline_knowledge;
  };
d193 1
a193 1
/* Create an ARM elf linker hash table */
d221 2
a235 1

d248 1
a248 1
    _bfd_error_handler (_ ("%s: unable to find THUMB glue '%s' for `%s'"),
d256 2
d283 1
a283 1
    _bfd_error_handler (_ ("%s: unable to find ARM glue '%s' for `%s'"),
d291 1
a291 2
/*
   ARM->Thumb glue:
d298 1
a298 2
   .word func    @@ behave as if you saw a ARM_32 reloc
 */
d305 1
a305 2
/*
   Thumb->ARM:                          Thumb->(non-interworking aware) ARM
d319 1
a319 2
   .word        func
 */
a398 1

d413 1
d415 1
a415 1
      return;			/* we've already seen this guy */
a420 1

d467 1
d469 1
a469 1
      return;			/* we've already seen this guy */
d477 1
a477 1
  /* If we mark it 'thumb', the disassembler will do a better job.  */
a482 2
  /* Allocate another symbol to mark where we switch to arm mode.  */

d486 1
d510 1
a598 1

d618 1
a619 1

d636 1
a636 1
	  /* These are the only relocation types we care about */
d653 1
d675 1
d677 1
a685 1

d688 1
a688 1
	  /* We don't care about local symbols */
d692 1
a692 1
	  /* This is an external symbol */
a707 1

a715 1

a777 1

d789 2
a790 1
    abort ();			/* error - not a valid branch instruction form */
a791 2
  /* FIXME: abort is probably not the right call. krk@@cygnus.com */
  
d795 2
a796 1
/* Thumb code calling an ARM function */
d843 1
a843 1
	    (_ ("%s(%s): warning: interworking not enabled."),
d846 1
a846 1
	    (_ ("  first occurrence: %s: thumb call to arm"),
d862 2
a863 1
	((bfd_signed_vma) val)	/* Address of destination of the stub */
d865 10
a874 5
	   (s->output_offset	/* Offset from the start of the current section to the start of the stubs.  */
	    + my_offset		/* Offset of the start of this stub from the start of the stubs.  */
	    + s->output_section->vma)	/* Address of the start of the current section.  */
	   + 4			/* The branch instruction is 4 bytes into the stub.  */
	   + 8);		/* ARM branches work from the pc of the instruction + 8.  */
d902 2
a903 1
/* Arm code calling a Thumb function */
d948 1
a948 1
	    (_ ("%s(%s): warning: interworking not enabled."),
d951 1
a951 1
	    (_ ("  first occurrence: %s: arm call to thumb"),
d954 1
d974 1
a974 1
  /* Somehow these are both 4 too far, so subtract 8. */
d992 1
d1064 1
a1064 2
	 into the output file to be resolved at run time. */

d1160 1
a1160 1
	     value so that it becomes an addend for the dynamic reloc. */
a1162 1

a1203 1

a1231 1

a1252 1
	  /* Perform a signed range check.  */
d1262 1
d1326 1
a1326 1
      /* Support ldr and str instructions for the thumb. */
d1365 1
a1365 1
	  upper = (upper ^ 0x400) - 0x400; /* sign extend */
d1407 1
a1407 1
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form */
d1475 1
a1475 2
         calculation. */

a1482 1

d1495 1
a1495 1
         global offset table. */
d1518 1
a1518 2
		 finish_dynamic_symbol routine. */

d1541 1
a1541 1
	     generated the necessary reloc. */
d1582 1
a1582 1
         without using the procedure linkage table. */
d1761 1
d1773 2
a1774 1
	  while (h->root.type == bfd_link_hash_indirect
d1777 2
a1778 1
	  if (h->root.type == bfd_link_hash_defined
d1787 1
a1787 1
	         sec->output_section will be NULL. */
d1894 1
a1894 1
	      msg = _ ("internal error: out of range error");
d1898 1
a1898 1
	      msg = _ ("internal error: unsupported relocation error");
d1902 1
a1902 1
	      msg = _ ("internal error: dangerous error");
d1906 1
a1906 1
	      msg = _ ("internal error: unknown error");
d1934 1
a1934 1
	    _bfd_error_handler (_ ("\
d1938 1
a1938 1
	    _bfd_error_handler (_ ("\
d1953 1
d1990 1
a1990 1
	    _bfd_error_handler (_ ("\
d2006 1
d2015 1
a2015 1
  /* Check if we have the same endianess */
d2026 1
a2026 1
     written into the object */
d2072 1
a2072 1
    _bfd_error_handler (_ ("\
d2080 1
a2080 1
    _bfd_error_handler (_ ("\
d2083 1
a2083 1
		     in_flags & EF_APCS_FLOAT ? _ ("float") : _ ("integer"),
d2085 1
a2085 1
		      out_flags & EF_APCS_26 ? _ ("float") : _ ("integer"));
d2088 1
a2088 1
    _bfd_error_handler (_ ("\
d2091 1
a2091 1
		    in_flags & EF_PIC ? _ ("independent") : _ ("dependent"),
d2094 1
a2094 1
  /* Interworking mismatch is only a warning. */
d2097 1
a2097 1
      _bfd_error_handler (_ ("\
d2100 1
a2100 1
	  in_flags & EF_INTERWORK ? _ ("supports") : _ ("does not support"),
d2102 1
a2102 1
		    out_flags & EF_INTERWORK ? _ ("does not") : _ ("does"));
d2109 2
a2110 1
/* Display the flags field */
d2125 2
a2126 1
  /* Ignore init flag - it may not be set, despite the flags field containing valid data.  */
d2129 1
a2129 1
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2138 1
a2138 1
	fprintf (file, _ (" [interworking enabled]"));
d2141 1
a2141 1
	fprintf (file, _ (" [APCS-26]"));
d2143 1
a2143 1
	fprintf (file, _ (" [APCS-32]"));
d2146 1
a2146 1
	fprintf (file, _ (" [floats passed in float registers]"));
d2149 1
a2149 1
	fprintf (file, _ (" [position independent]"));
d2152 1
a2152 1
	fprintf (file, _ (" [new ABI]"));
d2155 1
a2155 1
	fprintf (file, _ (" [old ABI]"));
d2158 1
a2158 1
	fprintf (file, _ (" [software FP]"));
d2165 1
a2165 1
      fprintf (file, _ (" [Version1 EABI]"));
d2168 1
a2168 1
	fprintf (file, _ (" [sorted symbol table]"));
d2170 1
a2170 1
	fprintf (file, _ (" [unsorted symbol table]"));
d2176 1
a2176 1
      fprintf (file, _ (" <EABI version unrecognised>"));
d2183 1
a2183 1
    fprintf (file, _ (" [relocatable executable]"));
d2186 1
a2186 1
    fprintf (file, _ (" [has entry point]"));
d2191 1
a2191 1
    fprintf (file, _ ("<Unrecognised flag bits set>"));
d2309 3
a2311 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d2314 1
a2314 1
  
d2561 1
a2561 1
   that it also accepts STT_ARM_TFUNC as a symbol that names a function. */
a2721 1

a2765 1

d2978 1
a2978 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
d2987 1
a2987 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
a3116 1

a3150 1

d3204 1
d3295 1
a3295 1
  Elf_Internal_Ehdr * i_ehdrp;	/* Elf file header, internal form */
@


1.32
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d1262 4
d1272 1
a1272 4
	      /* Perform a signed range check.  */
	      signed_addend = value;
	      signed_addend >>= howto->rightshift;
	      if (signed_addend > ((bfd_signed_vma)(howto->dst_mask >> 1))
d1277 10
a1286 2
	  value = (signed_addend & howto->dst_mask)
	    | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
@


1.31
log
@* elf32-arm.h (elf32_arm_final_link_relocate): Print `(local)'
for local symbols whose names are unknown.
@
text
@d2994 1
@


1.30
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d1191 1
a1191 1
				    h->root.root.string);
d1380 1
a1380 1
				  h->root.root.string);
@


1.29
log
@Use bfd_generic_verify_endian_match() and fix it to only check when endianness
is known.
@
text
@d1841 3
a1843 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d1850 2
a1851 1
		     (!info->shared || info->no_undefined))))
@


1.28
log
@Add support for R_ARM_XPC25 and R_ARM_THM_XPC22 relocs
@
text
@d2010 4
a2016 15

  /* Check if we have the same endianess */
  if (   ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	(_("%s: compiled for a %s endian system and target is %s endian"),
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
@


1.27
log
@Update copyright notice
@
text
@d778 1
a778 1
   reverse.  nickc@@cygnus.com  */
d780 2
a781 2
#define LOW_HI_ORDER 0xF800F000
#define HI_LOW_ORDER 0xF000F800
d794 3
a796 3
  rel_off >>= 1;		/* half word aligned address */
  low_bits = rel_off & 0x000007FF;	/* the bottom 11 bits */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* the top 11 bits */
d806 1
a806 1

d1065 3
d1177 18
a1194 5
	case R_ARM_PC24:
	  /* Arm B/BL instruction */

	  /* Check for arm calling thumb function.  */
	  if (sym_flags == STT_ARM_TFUNC)
d1196 8
a1203 4
	      elf32_arm_to_thumb_stub (info, sym_name, input_bfd, output_bfd,
				       input_section, hit_data, sym_sec, rel->r_offset,
				       signed_addend, value);
	      return bfd_reloc_ok;
d1344 3
d1348 1
a1348 1
      /* Thumb BL (branch long instruction). */
d1370 14
a1383 5

        /* If it is not a call to thumb, assume call to arm.
	   If it is a call relative to a section name, then it is not a
	   function call at all, but rather a long jump.  */
	if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
d1385 12
a1396 6
	    if (elf32_thumb_to_arm_stub
		(info, sym_name, input_bfd, output_bfd, input_section,
		 hit_data, sym_sec, rel->r_offset, signed_addend, value))
	      return bfd_reloc_ok;
	    else
	      return bfd_reloc_dangerous;
@


1.26
log
@Only check EF_xxx flags if the EABI version number is unknown.
@
text
@d2 1
a2 1
   Copyright 1998, 1999 Free Software Foundation, Inc.
d2173 1
a2173 1
      break;
d2181 3
@


1.25
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d1881 1
a1881 1
/* Function to keep ARM specific flags in the ELF header. */
d1890 4
a1893 2
      if (flags & EF_INTERWORK)
	_bfd_error_handler (_ ("\
d1895 3
a1897 3
			    bfd_get_filename (abfd));
      else
	_bfd_error_handler (_ ("\
d1899 2
a1900 1
			    bfd_get_filename (abfd));
d1911 1
a1911 1
/* Copy backend specific data from one object module to another */
d1920 1
a1920 1
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d1924 1
a1924 1
  in_flags = elf_elfheader (ibfd)->e_flags;
d1927 3
a1929 1
  if (elf_flags_init (obfd) && in_flags != out_flags)
d1966 2
a1967 2
     bfd *ibfd;
     bfd *obfd;
d2026 12
d2083 2
a2084 1
  FILE *file = (FILE *) ptr;
d2091 1
d2097 50
a2146 4
  if (elf_elfheader (abfd)->e_flags & EF_INTERWORK)
    fprintf (file, _ (" [interworking enabled]"));
  else
    fprintf (file, _ (" [interworking not enabled]"));
d2148 2
a2149 4
  if (elf_elfheader (abfd)->e_flags & EF_APCS_26)
    fprintf (file, _ (" [APCS-26]"));
  else
    fprintf (file, _ (" [APCS-32]"));
d2151 2
a2152 4
  if (elf_elfheader (abfd)->e_flags & EF_APCS_FLOAT)
    fprintf (file, _ (" [floats passed in float registers]"));
  else
    fprintf (file, _ (" [floats passed in integer registers]"));
d2154 1
a2154 4
  if (elf_elfheader (abfd)->e_flags & EF_PIC)
    fprintf (file, _ (" [position independent]"));
  else
    fprintf (file, _ (" [absolute position]"));
d2156 3
@


1.25.2.1
log
@Merge from mainline
@
text
@d1759 1
a1759 8
	              && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_ARM_ABS32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d1997 5
a2001 5
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
         uninitialised values, which surprise surprise, correspond
d2003 1
a2003 2
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
@


1.25.2.2
log
@Merge from mainline
@
text
@d1810 1
a1810 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1817 1
a1817 2
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
a3014 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) 
	      == 0)
	    sym->st_value = 0;
@


1.25.2.3
log
@Undo accidental commit
@
text
@d3018 7
@


1.25.2.4
log
@2000-10-27  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_copy_private_bfd_data): Don't refuse
	attempts to mix PIC code with non-PIC, just mark the output as
	being position dependent.
	(elf32_arm_merge_private_bfd_data): Likewise.  Print an error
	message for EF_SOFT_FLOAT mismatches.  Display diagnostics for
	all mismatches, not just the first one.
@
text
@d1936 4
a1958 4

      /* Likewise for PIC, though don't warn for this case.  */
      if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
	in_flags &= ~EF_PIC;
a1975 1
  boolean flags_compatible = true;
d2027 1
a2027 1
  /* Identical flags must be compatible.  */
d2031 1
a2031 4
  /* If any of the input BFDs is non-PIC, the output is also position 
     dependent.  */
  if (!(in_flags & EF_PIC))
    elf_elfheader (obfd)->e_flags &= ~EF_PIC;
a2032 1
  /* Complain about various flag mismatches.  */
d2034 1
a2034 2
    {
      _bfd_error_handler (_ ("\
a2039 2
      flags_compatible = false;
    }
d2042 1
a2042 2
    {
      _bfd_error_handler (_ ("\
a2047 2
      flags_compatible = false;
    }
d2049 9
a2057 1
  if ((in_flags & EF_SOFT_FLOAT) != (out_flags & EF_SOFT_FLOAT))
a2059 11
Error: %s uses %s floating point, whereas %s uses %s floating point"),
			  bfd_get_filename (ibfd),
			  in_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"),
			  bfd_get_filename (obfd),
			  out_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"));
      flags_compatible = false;
    }

  /* Interworking mismatch is only a warning.  */
  if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
    _bfd_error_handler (_ ("\
d2065 2
d2068 1
a2068 1
  return flags_compatible;
@


1.25.2.5
log
@2000-10-31  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Only handle
	EF_SOFT_FLOAT if it is defined.

	From 2000-05-23  H.J. Lu  <hjl@@gnu.org>
	* elf32-ppc.c (ppc_elf_relocate_section): Fix a typo.
@
text
@a2059 1
#ifdef EF_SOFT_FLOAT
a2069 1
#endif
@


1.25.2.6
log
@2000-11-05  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Always permit
	BFDs containing no sections to be merged, regardless of their flags.

2000-11-04  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_relocate_section): Suppress error message
	if a relocation for an undefined symbol also results in an
	overflow.
@
text
@d1849 4
a1852 9
	      /* If the overflowing reloc was to an undefined symbol,
		 we have already printed one error message and there
		 is no point complaining again.  */
	      if ((! h ||
		   h->root.type != bfd_link_hash_undefined)
		  && (!((*info->callbacks->reloc_overflow)
			(info, name, howto->name, (bfd_vma) 0,
			 input_bfd, input_section, rel->r_offset))))
		  return false;
a1976 2
  boolean null_input_bfd = true;
  asection *sec;
a2029 16
    return true;

  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic glue sections.  */
      if (strcmp (sec->name, ".glue_7")
	  && strcmp (sec->name, ".glue_7t"))
	{
	  null_input_bfd = false;
	  break;
	}
    }
  if (null_input_bfd)
@


1.24
log
@Apply Thoams de Lellis's patch to fic disassembly of Thumb instructions when
bounded by non-function labels.
@
text
@d1809 2
a1810 1
		     input_section, rel->r_offset)))
d1848 1
a1848 1
		     rel->r_offset)))
@


1.23
log
@Fix bug in interwork stubs from thumb to arm
@
text
@d717 1
a717 1
	         the target of the call. If it is a thumb target, we
d726 1
a726 1
	         up the target of the call. If it is not a thumb
d740 1
d748 1
a749 1

d2107 16
a2122 4
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_ARM_TFUNC)
    return ELF_ST_TYPE (elf_sym->st_info);
  else
    return type;
@


1.22
log
@Add SEC_CODE and SEC_READONLY flags to glue sections.
@
text
@d897 1
a897 1
    - 4;
@


1.21
log
@Undeo previous delta.  Set gc_mark instead.
@
text
@d551 1
a551 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d569 1
a569 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d2813 1
@


1.20
log
@Mark interworking sections as linker created to prevent garbage collection.
@
text
@d548 4
a551 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED;
d559 4
d569 1
a569 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED;
d577 2
@


1.19
log
@Apply Philip Blundell's patch to prevent range checks on weak symbols.
@
text
@d548 1
a548 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d562 1
a562 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
@


1.18
log
@fix bug in previous delta
@
text
@d84 1
a84 1
   called before the relocation has been set up calles the dynamic
d92 1
a92 1
  0x08, 0xf0, 0xbe, 0xe5	/* ldr   pc, [lr, #-4]      */
d1232 14
a1245 7
	  /* Perform a signed range check.  */
	  signed_addend = value;
	  signed_addend >>= howto->rightshift;
	  if (signed_addend > ((bfd_signed_vma)(howto->dst_mask >> 1))
	      || signed_addend < - ((bfd_signed_vma) ((howto->dst_mask + 1) >> 1)))
	    return bfd_reloc_overflow;
	  
d1596 1
a1596 1
     bfd_vma            address;
@


1.17
log
@Fix partial REL relocs.
@
text
@d1610 6
a1615 2
  addend <<= howto->size;
  addend +=  increment;
d1617 5
a1621 1
  /* Should we check for overflow here ?  */
d1623 4
a1626 2
  /* Drop any undesired bits.  */
  addend >>= howto->rightshift;
@


1.16
log
@Fix interworking problems.
@
text
@d1584 39
d1683 2
a1684 12
		  {
		    bfd_vma val;
		    bfd_vma insn;

		    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		    val = insn + ((sec->output_offset + sym->st_value)
				  >> howto->rightshift);
		    val &= howto->dst_mask;
		    val |= insn & ~(howto->dst_mask);

		    bfd_put_32 (input_bfd, val, contents + rel->r_offset);
		  }
@


1.15
log
@Check for overflow on R_ARM_PC24 relocs.
@
text
@d53 6
d718 1
a718 1
                 target, we insert glue. */
d804 10
a813 10
     struct bfd_link_info *info;
     char *name;
     bfd *input_bfd;
     bfd *output_bfd;
     asection *input_section;
     bfd_byte *hit_data;
     asection *sym_sec;
     int offset;
     int addend;
     bfd_vma val;
d815 1
a815 1
  asection *s = 0;
d819 2
a820 2
  struct elf_link_hash_entry *myh;
  struct elf32_arm_link_hash_table *globals;
d904 10
a913 11

     struct bfd_link_info *info;
     char *name;
     bfd *input_bfd;
     bfd *output_bfd;
     asection *input_section;
     bfd_byte *hit_data;
     asection *sym_sec;
     int offset;
     int addend;
     bfd_vma val;
d917 1
a917 1
  asection *s;
d919 2
a920 2
  struct elf_link_hash_entry *myh;
  struct elf32_arm_link_hash_table *globals;
d978 1
a978 1

a983 1

d1171 2
a1172 1
				       input_section, hit_data, sym_sec, rel->r_offset, addend, value);
d1331 4
a1334 2
        /* If it's not a call to thumb, assume call to arm */
	if (sym_flags != STT_ARM_TFUNC)
d1338 1
a1338 1
		 hit_data, sym_sec, rel->r_offset, addend, value))
@


1.14
log
@Correctly handle Vtentry relocs.
@
text
@d1226 7
d1234 2
a1235 3
	  value >>= howto->rightshift;
	  value &= howto->dst_mask;
	  value |= (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
@


1.13
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2367 1
a2367 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.12
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d2047 1
a2047 1
       struct bfd_link_info *info;
d2092 4
a2095 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2833 1
a2833 1
     PTR ignore;
d3112 1
a3112 1
     struct bfd_link_info * link_info;
@


1.11
log
@	* dwarf2.c (parse_comp_unit): Add ABBREV_LENGTH parameter.
	(_bfd_dwarf2_find_nearest_line): Add ADDR_SIZE parameter.
	* elf.c (_bfd_elf_find_nearest_line): Pass it.
	* elf32-arm.h (elf32_arm_find_nearest_line): Likewise.
	* elf32-mips.c (ABI_64_P): New macro.
	(IRIX_COMPAT): We are IRIX6-compatible if ABI_64_P.
	(_bfd_mips_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Update prototype.
	* libbfd.h: Regenerated.
@
text
@a627 1
	  unsigned char code;
a1302 1
	bfd_vma        src_mask = 0x007FFFFE;
d2069 3
@


1.10
log
@Define 'elf_backend_got_header_size' and 'elf_backend_plt_header_size'.
@
text
@d2399 1
a2399 1
				     line_ptr))
@


1.9
log
@Patch from:  Jim Pick  <jim@@jimpick.com>
Take note of 'no_undefined'.
@
text
@d3152 3
@


1.8
log
@(ELF_MAXPAGESIZE): Default to 0x1000 not 1
@
text
@d1736 2
@


1.7
log
@Fix typo: change ELF_MAXPAGE_SIZE to ELF_MAXPAGESIZE.
@
text
@d1147 1
a1147 1

d1154 1
d1227 1
a1227 1

d1338 1
a1338 1

d1342 1
a1342 1

d1404 1
a1404 1

d1509 1
a1509 1

d2115 1
a2115 1

d2118 1
a2118 1

d2120 1
a2120 1

d2129 1
a2129 1

d2135 1
a2135 1

d2141 1
a2141 1

d2175 1
a2175 1

d2360 1
a2360 1

@


1.6
log
@Philip Blundell  <philb@@gnu.org>
	* elf32-arm.h (elf32_arm_relocate_section): Reinstate change of
	1993-03-25 (!!).  Take into account the bitmasks for the reloc so
	the addend does not overflow into the rest of the word
@
text
@d32 1
a32 1
static int elf32_arm_get_symbol_type 
d324 1
a324 1
   .word        func 
d603 1
a603 1
  
d711 1
a711 1
	      /* This one is a call from thumb code.  We look 
d713 1
a713 1
                 target, we insert glue. */ 
d739 1
a739 1
   can occur in any order. So given a thumb form of long branch, and an 
d741 1
a741 1
   instruction. 
d743 1
a743 1
   It takes two thumb instructions to encode the target address. Each has 
d745 2
a746 2
   H-0.. see below), the lower 11 bits are stored in the other (identified 
   by H-1). 
d748 1
a748 1
   Combine together and shifted left by 1 (it's a half word address) and 
d756 1
a756 1
   They can be ordered either way, but the arm tools I've seen always put 
d1015 1
a1015 1
  
d1017 1
a1017 1
    
d1043 1
a1043 1
  
d1054 1
a1054 1
      
d1065 1
a1065 1
	  
d1069 1
a1069 1
	      
d1076 1
a1076 1
	      
d1081 1
a1081 1
	      
d1085 1
a1085 1
	  
d1087 1
a1087 1
	  
d1093 1
a1093 1
	      
d1103 1
a1103 1
	  
d1106 1
a1106 1
	  
d1141 1
a1141 1
	  
d1147 2
a1148 2
	  
	  /* If this reloc is against an external symbol, we do not want to 
d1153 2
a1154 2
	  
	  return _bfd_final_link_relocate (howto, input_bfd, input_section, 
d1162 1
a1162 1
	  
d1176 1
a1176 1
	      
d1181 1
a1181 1
	      
d1192 1
a1192 1
		 
d1210 1
a1210 1
	      
d1217 1
a1217 1
		{ 
d1219 1
a1219 1
		  
d1221 1
a1221 1
		  
d1226 2
a1227 2
	  
	  value >>= howto->rightshift;	  
d1231 1
a1231 1
	  
d1237 1
a1237 1
	  
d1244 1
a1244 1
      
d1331 1
a1331 1
	
d1333 1
a1333 1
	
d1337 1
a1337 1
      
d1341 1
a1341 1
		
d1343 1
a1343 1
	    
d1354 1
a1354 1
	
d1403 1
a1403 1
        
d1409 1
a1409 1
      
d1411 1
a1411 1
      return _bfd_final_link_relocate (howto, input_bfd, input_section, 
d1419 1
a1419 1
      
d1424 1
a1424 1
      return _bfd_final_link_relocate (howto, input_bfd, input_section, 
d1427 1
a1427 1
      
d1433 1
a1433 1
      
d1437 1
a1437 1
	  
d1440 1
a1440 1
	  
d1450 1
a1450 1
		 
d1452 1
a1452 1
		 entry to initialize the value.  This is done in the 
d1454 1
a1454 1
	      
d1463 1
a1463 1
	  
d1469 1
a1469 1
	  
d1472 1
a1472 1
	  
d1474 1
a1474 1
	  
d1483 1
a1483 1
	      
d1488 1
a1488 1
		  
d1491 1
a1491 1
		  
d1493 1
a1493 1
				     + sgot->output_offset 
d1502 1
a1502 1
	      
d1505 1
a1505 1
	  
d1508 2
a1509 2
      
      return _bfd_final_link_relocate (howto, input_bfd, input_section, 
d1512 1
a1512 1
      
d1542 1
a1542 1
      
d1608 1
a1608 1
      
d1635 1
a1635 1
		    
d1637 1
a1637 1
		    val = insn + ((sec->output_offset + sym->st_value) 
d1641 1
a1641 1
		    
d1676 1
a1676 1
	      
d1678 1
a1678 1
	      
d1680 1
a1680 1
	         We check specially because in some obscure cases 
d1695 1
a1695 1
		  
d1699 1
a1699 1
		  
d1709 1
a1709 1
		  
d1714 1
a1714 1
		  
d1754 1
a1754 1
      
d2042 1
a2042 1
    
d2114 1
a2114 1
   
d2117 1
a2117 1
 
d2119 1
a2119 1
				   
d2122 1
a2122 1
  
d2128 1
a2128 1
 
d2134 1
a2134 1
 
d2140 1
a2140 1
 
d2174 1
a2174 1
	      
d2197 1
a2197 1
		
d2224 1
a2224 1
		
d2339 1
a2339 1
			
d2359 1
a2359 1
 
d2368 1
a2368 1
 
d2372 1
a2372 1
       
d2395 1
a2395 1
				     filename_ptr, functionname_ptr, 
d2404 1
a2404 1
  
d2451 1
a2451 1
  
d2894 1
a2894 1
		       + got_offset 
d2931 1
a2931 1
      
d3121 1
a3121 1
#define ELF_MAXPAGE_SIZE		0x8000
@


1.5
log
@Fix implementation of R_ARM_PC24 and R_ARM_THM_PC22 relocs to conform to spec.
@
text
@d1634 8
a1641 2
		    val = bfd_get_32 (input_bfd, contents + rel->r_offset);
		    val += (sec->output_offset + sym->st_value);
@


1.4
log
@Applied patches from Philip Blundell  <pb@@nexus.co.uk>, to improve PIC support.
@
text
@d51 2
d120 1
a120 1
/* arm ELF linker hash entry.  */
d161 4
d221 1
d573 1
a573 1
bfd_elf32_arm_process_before_allocation (abfd, link_info)
d576 1
d602 2
d636 1
a636 1
	  if (r_type != R_ARM_PC24
d1013 4
d1030 10
a1039 1
  addend = (bfd_get_32 (input_bfd, hit_data) & howto->src_mask);
d1041 1
a1041 1
  addend = rel->r_addend;
d1170 56
d1227 3
a1229 8
	  value = value + addend;
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + 8);
	  value -= rel->r_offset;
	  value = value >> howto->rightshift;
	  
	  value &= 0xffffff;
	  value |= (bfd_get_32 (input_bfd, hit_data) & 0xff000000);
d1299 5
a1303 5
	bfd_vma relocation;
	boolean overflow = false;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_vma src_mask = 0x007FFFFE;
d1305 2
a1306 2
	bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	bfd_vma check;
a1307 2
	bfd_vma add;
	bfd_signed_vma signed_add;
d1313 2
a1314 2
	  bfd_vma upper = bfd_get_16 (input_bfd, hit_data) & 0x7ff;
	  bfd_vma lower = bfd_get_16 (input_bfd, hit_data + 2) & 0x7ff;
d1317 1
d1331 3
a1333 3

	/* +4: pc is offset by 4 */
	relocation = value + addend + 4;
d1335 20
a1354 3
		       + input_section->output_offset);
	relocation -= rel->r_offset;

a1363 8
	add = ((upper_insn & 0x7ff) << 12) | ((lower_insn & 0x7ff) << 1);
	/* sign extend */
	signed_add = (add ^ 0x400000) - 0x400000;

	/* Add the value from the object file.  */
	signed_check += signed_add;
	relocation += signed_add;

d1365 1
a1365 2
	if (signed_check > reloc_signed_max
	    || signed_check < reloc_signed_min)
d1599 5
a1603 5
      int r_type;
      reloc_howto_type * howto;
      unsigned long r_symndx;
      Elf_Internal_Sym * sym;
      asection * sec;
d1605 4
a1608 3
      bfd_vma relocation;
      bfd_reloc_status_type r;

d1610 1
a1610 1
      r_type = ELF32_R_TYPE (rel->r_info);
d1612 2
a1613 2
      if (r_type == R_ARM_GNU_VTENTRY
          || r_type == R_ARM_GNU_VTINHERIT )
d1616 2
a1617 3
      /* ScottB: range check r_type here. */
      
      howto = elf32_arm_howto_table + r_type;
d3099 14
d3136 1
@


1.3
log
@1999-05-24  Philip Blundell  <pb@@nexus.co.uk>
	* elf32-arm.h (elf32_arm_relocate_section): Undo change of
 	1999-03-25
@
text
@d37 3
a39 1
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma, struct bfd_link_info *, asection *, const char *, unsigned char));
d162 30
d206 1
a206 1
				      _bfd_elf_link_hash_newfunc))
d978 1
a978 1
			       info, sym_sec, sym_name, sym_flags)
d990 1
a1001 1
  struct elf_link_hash_entry *  h = NULL;
d1588 2
a1591 4
              relocation = (h->root.u.def.value
	  	           + sec->output_section->vma
		           + sec->output_offset);
	      
d1606 1
a1606 1
	            relocation = 0;
d1610 1
a1610 1
	          relocation = 0;
d1620 1
a1620 1
	            relocation = 0;
d1625 1
a1625 1
	            relocation = 0;
d1635 1
a1635 1
		      relocation = 0;
d1638 7
d1672 1
a1672 1
					  ELF_ST_TYPE (sym->st_info)));
d1997 2
d2006 1
a2006 1
  /* we don't use got and plt entries for armelf */
d2010 2
a2011 4
/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */
 
@


1.2
log
@	* elf32-arm.h (elf32_arm_relocate_section): Fix operator
 	precedence between bit-and and comparison.
@
text
@d1522 1
a1522 1
		    val += (sec->output_offset + sym->st_value) >> howto->rightshift;
@


1.1
log
@Initial revision
@
text
@d1572 1
a1572 1
	                  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR == 0)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

